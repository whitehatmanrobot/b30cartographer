to get the last write time.
    tm              - Where to return the last write time.

    Returns:

        TRUE if we succeed, FALSE otherwise.
---*/
{
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    BOOL                        bReturn;

    bReturn  = GetFileInformationByHandle(
                                    hFile,
                                    &FileInfo
                                    );

    if (!bReturn)
    {
        return FALSE;
    }

    *tm = FileInfo.ftLastWriteTime;

    return TRUE;
}


DWORD
CheckIfShortFileName(
    IN  CONST UCHAR * pszPath,
    IN  HANDLE        hImpersonation,
    OUT BOOL *        pfShort
    )
/*++
    Description:

        This function takes a suspected NT/Win95 short filename and checks if there's
        an equivalent long filename.  For example, c:\foobar\ABCDEF~1.ABC is the same
        as c:\foobar\abcdefghijklmnop.abc.

        NOTE: This function should be called unimpersonated - the FindFirstFile() must
        be called in the system context since most systems have traverse checking turned
        off - except for the UNC case where we must be impersonated to get network access.

    Arguments:

        pszPath - Path to check
        hImpersonation - Impersonation handle if this is a UNC path - can be NULL if not UNC
        pfShort - Set to TRUE if an equivalent long filename is found

    Returns:

        Win32 error on failure
--*/
{
    DWORD              err = NO_ERROR;
    WIN32_FIND_DATA    FindData;
    UCHAR *            psz;
    BOOL               fUNC;

    psz      = _mbschr( (UCHAR *) pszPath, '~' );
    *pfShort = FALSE;
    fUNC     = (*pszPath == '\\');

    //
    //  Loop for multiple tildas - watch for a # after the tilda
    //

    while ( psz++ )
    {
        if ( *psz >= '0' && *psz <= '9' )
        {
            UCHAR achTmp[MAX_PATH];
            UCHAR * pchEndSeg;
            UCHAR * pchBeginSeg;
            HANDLE  hFind;

            //
            //  Isolate the path up to the segment with the
            //  '~' and do the FindFirst with that path
            //

            pchEndSeg = _mbschr( psz, '\\' );

            if ( !pchEndSeg )
            {
                pchEndSeg = psz + _mbslen( psz );
            }

            //
            //  If the string is beyond MAX_PATH then we allow it through
            //

            if ( ((INT) (pchEndSeg - pszPath)) >= sizeof( achTmp ))
            {
                return NO_ERROR;
            }

            memcpy( achTmp, pszPath, (INT) (pchEndSeg - pszPath) );
            achTmp[pchEndSeg - pszPath] = '\0';

            if ( fUNC && hImpersonation )
            {
                if ( !ImpersonateLoggedOnUser( hImpersonation ))
                {
                    return GetLastError();
                }
            }

            hFind = FindFirstFile( (CHAR *) achTmp, &FindData );

            if ( fUNC && hImpersonation )
            {
                RevertToSelf();
            }

            if ( hFind == INVALID_HANDLE_VALUE )
            {
                err = GetLastError();

                DBGPRINTF(( DBG_CONTEXT,
                            "FindFirst failed!! - \"%s\", error %d\n",
                            achTmp,
                            GetLastError() ));

                //
                //  If the FindFirstFile() fails to find the file then return
                //  success - the path doesn't appear to be a valid path which
                //  is ok.
                //

                if ( err == ERROR_FILE_NOT_FOUND ||
                     err == ERROR_PATH_NOT_FOUND )
                {
                    return NO_ERROR;
                }

                return err;
            }

            DBG_REQUIRE( FindClose( hFind ));

            //
            //  Isolate the last segment of the string which should be
            //  the potential short name equivalency
            //

            pchBeginSeg = _mbsrchr( achTmp, '\\' );
            DBG_ASSERT( pchBeginSeg );
            pchBeginSeg++;

            //
            //  If the last segment doesn't match the long name then this is
            //  the short name version of the path
            //

            if ( _mbsicmp( (UCHAR *) FindData.cFileName, pchBeginSeg ))
            {
                *pfShort = TRUE;
                return NO_ERROR;
            }
        }

        psz = _mbschr( psz, '~' );
    }

    return err;
}

//
// filemisc.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\fileopen.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    fileopen.cxx

    This module contains the functions for creating and closing
    cached file information.


    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>
#include "filecach.hxx"
#include "filehash.hxx"
#include "tsunamip.hxx"
#include "tlcach.h"
#include <mbstring.h>

#include <atq.h>
#include <uspud.h>

#include "dbgutil.h"


extern CFileCacheStats * g_pFileCacheStats;
extern BOOL DisableTsunamiCaching;

//
// globals
//
LARGE_INTEGER g_liFileCacheByteThreshold;
DWORDLONG     g_dwMemCacheSize;
BOOL          g_bEnableSequentialRead;

//
// Private functions
//
LPTS_OPEN_FILE_INFO TspOpenFile( LPCSTR pszName, HANDLE hUser, DWORD dwOptions );
LPTS_OPEN_FILE_INFO TspOpenCachedFile( LPCSTR pszName, HANDLE hUser, DWORD dwOptions );
BOOL TspOpenCachedFileHelper( LPCSTR pszName, HANDLE hUser, TS_OPEN_FILE_INFO * pOpenFile, DWORD dwOptions );
DWORD TspMakeWidePath( LPCSTR pszName, DWORD cchWideName, BOOL bNoParse, LPWSTR pwszWideName );
VOID TspOplockNotification( PVOID pvContext, DWORD Status );

//
// flags to set on CreateFile
//

DWORD TsCreateFileShareMode = (FILE_SHARE_READ   |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE);

DWORD TsCreateFileFlags = (FILE_FLAG_OVERLAPPED       |
                           FILE_FLAG_BACKUP_SEMANTICS |
                           FILE_DIRECTORY_FILE );

const SECURITY_INFORMATION TsSecurityInfo
        = OWNER_SECURITY_INFORMATION
        | GROUP_SECURITY_INFORMATION
        | DACL_SECURITY_INFORMATION;


//
// macros
//
#define LockUriInfo()      ( EnterCriticalSection( &g_csUriInfo ) )
#define UnlockUriInfo()    ( LeaveCriticalSection( &g_csUriInfo ) )


LPTS_OPEN_FILE_INFO
TsCreateFile(
    IN const TSVC_CACHE     &TSvcCache,
    IN      LPCSTR          pszName,
    IN      HANDLE          OpeningUser,
    IN      DWORD           dwOptions
    )
/*++
Routine Description:

    Opens a TS_OPEN_FILE_INFO. When the requested file is no longer
    needed, the client should close it with TsCloseHandle.

Arguments:

    TSvcCache   - An initialized TSVC_CACHE structure. (Ignored)
    lpszName    - The name of the file
    OpeningUser - HANDLE for the user attempting the open
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON
        TS_FORBID_SHORT_NAMES

Return Values:

    On success TsCreateFile returns a pointer to a TS_OPEN_FILE_INFO
    for the requested file. NULL is returned on failure.  More error
    information can be obtained from GetLastError();

--*/
{
    TS_OPEN_FILE_INFO * pOpenFile = NULL;
    CHAR achUpName[MAX_PATH+1];
    BOOL bCacheToken = !(dwOptions & TS_DONT_CACHE_ACCESS_TOKEN);

    if (DisableTsunamiCaching) {
        dwOptions &= ~TS_CACHING_DESIRED;
    }

//
// This assert doesn't work on workstation, but it would
// be nice.
//
//    DBG_ASSERT( (~TsValidCreateFileOptions & dwOptions) == 0 );
//
    dwOptions &= TsValidCreateFileOptions;

    //
    // Make sure the path is upper case
    //
    IISstrncpy(achUpName, pszName, MAX_PATH);
    achUpName[MAX_PATH] = 0;

    _mbsupr(reinterpret_cast<PUCHAR>(achUpName));

    //
    //  Disallow short file names as they break metabase equivalency
    //  We do the expensive check anytime there's a tilde - number
    //  sequence.  If we find somebody used a short name we return file not found.
    //  Note we revert if not on UNC since most systems have traverse checking
    //  turned off.
    //

    if ( (dwOptions & TS_FORBID_SHORT_NAMES) &&
          strchr( pszName, '~' ))
    {
        DWORD  err;
        BOOL   fShort;

        //
        //  CheckIfShortFileName() should be called unimpersonated
        //
        err = CheckIfShortFileName( (UCHAR *) pszName, OpeningUser, &fShort );

        if ( !err && fShort )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Short filename being rejected \"%s\"\n",
                        pszName ));

            err = ERROR_FILE_NOT_FOUND;
        }

        if ( err )
        {
            SetLastError( err );
            return NULL;
        }
    }

    //
    // Try to get the file
    //
    if ( dwOptions & TS_CACHING_DESIRED ) {
        //
        // Look in the cache first
        //
        if ( CheckoutFile(achUpName, FCF_FOR_IO, &pOpenFile) ) {
            //
            // Make sure we can really use this handle
            //
            if ( ( !(dwOptions & TS_NO_ACCESS_CHECK) ) &&
                 ( !pOpenFile->AccessCheck(OpeningUser, bCacheToken) ) ) {

                CheckinFile(pOpenFile, FCF_FOR_IO);

                //
                // Return Access Denied
                //
                pOpenFile = NULL;
                SetLastError(ERROR_ACCESS_DENIED);
            }
        } else if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            //
            // The file was not in the cache.  Try to put it in.
            //
            pOpenFile = TspOpenCachedFile(achUpName, OpeningUser, dwOptions);
        }
    } else {
        //
        // We're not using the cache.  Just open the file.
        //
        pOpenFile = TspOpenFile(achUpName, OpeningUser, dwOptions);
    }

    return pOpenFile;
}



LPTS_OPEN_FILE_INFO
TsCreateFileFromURI(
    IN const TSVC_CACHE     &TSvcCache,
    IN      PW3_URI_INFO    pURIInfo,
    IN      HANDLE          OpeningUser,
    IN      DWORD           dwOptions,
    IN      DWORD           *dwError
    )
/*++
Routine Description:

    Opens the TS_OPEN_FILE_INFO associated with the W3_URI_INFO argument. When
    the client is done with the file it should be closed with TsCloseURIFile.

    As a side effect, this routine will set the pOpenFileInfo, and
    dwFileOpenError in the pURIInfo structure.

Arguments:

    TSvcCache   - An initialized TSVC_CACHE structure.
    pURIInfo    - Pointer to the W3_URI_INFO whose associated file should be opened
    OpeningUser - HANDLE for the user attempting the open
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON
        TS_FORBID_SHORT_NAMES
    dwError     - On failure this DWORD will contain an error code

Return Values:

    On success a pointer to the TS_OPEN_FILE_INFO is returned. On failure
    TsCreateFileFromURI returns NULL, and dwError is set to an error code.
--*/
{
    TS_OPEN_FILE_INFO * pOpenFile = NULL;
    DWORD               err;
    BOOL                bCacheToken = !(dwOptions & TS_DONT_CACHE_ACCESS_TOKEN);
    BOOL                bInfoValid;

//
// This assert doesn't work on workstation, but it would
// be nice.
//
//    DBG_ASSERT( (~TsValidCreateFileOptions & dwOptions) == 0 );
//
    dwOptions &= TsValidCreateFileOptions;

    if (DisableTsunamiCaching) {
        pOpenFile = TsCreateFile(TSvcCache,
                                 pURIInfo->pszName,
                                 OpeningUser,
                                 dwOptions);

        *dwError = GetLastError();

        return pOpenFile;
    }

    //
    // It seems that callers expect caching, but don't request it
    //
    dwOptions |= TS_CACHING_DESIRED;

    //
    // Assume no error
    //
    err = ERROR_SUCCESS;

    //
    // Try to get the file
    //
    bInfoValid = FALSE;
    
    LockUriInfo();
    
    pOpenFile = pURIInfo->pOpenFileInfo;
    if ( pOpenFile && CheckoutFileEntry(pOpenFile, FCF_FOR_IO) ) {
        bInfoValid = TRUE;
    }
    
    UnlockUriInfo();

    if ( bInfoValid ) {
        //
        // We've got a cached handle; make sure we're allowed to see it
        //
        if ( !pOpenFile->AccessCheck(OpeningUser, bCacheToken) ) {

            CheckinFile(pOpenFile, FCF_FOR_IO);

            //
            // Return Access Denied
            //
            pOpenFile = NULL;
            err = ERROR_ACCESS_DENIED;
        }
    } else {
        //
        // We've got either an invalid handle or no cached handle
        // at all.
        //
        if (pOpenFile) {
            //
            // The cached file handle is invalid
            //
            TS_OPEN_FILE_INFO * pOldFile;

            LockUriInfo();

            pOldFile = pURIInfo->pOpenFileInfo;
            pURIInfo->pOpenFileInfo = NULL;

            UnlockUriInfo();

            //
            // We've got an invalid entry checked out.
            // It's been checked out twice, once for I/O (above)
            // and once when it was first cached.
            //
            CheckinFile(pOpenFile, FCF_FOR_IO);

            //
            // Now we handle the reference that was cached in the
            // URI info structure.  If someone else already removed
            // the reference, then pOldFile will be NULL, or a new
            // value.
            //

            if (pOldFile == pOpenFile) {
                //
                // We've got the reference all to ourselves so
                // we can delete it.
                //
                CheckinFile(pOpenFile, 0);
            } else if (pOldFile) {
                //
                // Someone else took care of the reference,
                // and cached a new one. It would be nice
                // if we could use it, but the file might have
                // already been flushed. If we go back to the
                // top, there's a chance that we'll loop forever.
                // Instead, we'll just get rid of this new
                // reference and pretend it was never there.
                //
                CheckinFile(pOldFile, 0);
            }
        }

        //
        // No file is cached.  Try to open it.
        //
        pOpenFile = TsCreateFile(TSvcCache,
                                 pURIInfo->pszName,
                                 OpeningUser,
                                 dwOptions);

        //
        // Save the result.
        //
        if ( pOpenFile ) {
            if (dwOptions & TS_CACHING_DESIRED) {
                //
                // To save a copy of the info we need to reference it
                //
                if ( CheckoutFileEntry(pOpenFile, 0) ) {
                    TS_OPEN_FILE_INFO * pOldFile;

                    LockUriInfo();

                    pOldFile                = pURIInfo->pOpenFileInfo;
                    pURIInfo->pOpenFileInfo = pOpenFile;

                    UnlockUriInfo();

                    //
                    // Someone else might have written a value
                    // into the URI info before we got to it, but
                    // we'll show them.  Our value stays while
                    // theirs gets put back.
                    //
                    if (pOldFile) {
                        CheckinFile(pOldFile, 0);
                    }
                } else {
                    //
                    // It's been flushed, so we don't want to save it.
                    //
                    CheckinFile(pOpenFile, 0);
                }
            }
        } else {
            //
            // We couldn't open a file, so just record the error.
            //
            err = GetLastError();
        }
    }

    if ( err != ERROR_SUCCESS ) {
        *dwError = err;
        SetLastError(err);
    }
    return pOpenFile;
}



BOOL
TsCloseHandle(
    IN const TSVC_CACHE           &TSvcCache,
    IN       LPTS_OPEN_FILE_INFO  pOpenFile
    )
/*++
Routine Description:

    Closes a TS_OPEN_FILE_INFO opened with TsCreateFile.

Arguments:

    TSvcCache - An initialized TSVC_CACHE structure.
    pOpenFile - Pointer to the TS_OPEN_FILE_INFO to be closed

Return Values:

    TRUE on success
--*/
{
    if ( pOpenFile->IsCached() ) {
        CheckinFile(pOpenFile, FCF_FOR_IO);
    } else {
        //
        // This is an uncached file.  We can just get rid of it.
        //
        pOpenFile->CloseHandle();
        delete pOpenFile;
    }

    return TRUE;
}


BOOL
TsCloseURIFile(
    IN       LPTS_OPEN_FILE_INFO  pOpenFile
    )
/*++
Routine Description:

    Closes a TS_OPEN_FILE_INFO opened with TsCreateFileFromURI.

Arguments:

    pOpenFile - Pointer to the TS_OPEN_FILE_INFO to be closed

Return Values:

    TRUE on success
--*/
{
    if ( pOpenFile ) {
        if ( pOpenFile->IsCached() ) {
            CheckinFile(pOpenFile, FCF_FOR_IO);
        } else {
            //
            // This is an uncached file.  We can just get rid of it.
            //
            pOpenFile->CloseHandle();
            delete pOpenFile;
        }
    }
    return TRUE;
}




BOOL
TsDerefURIFile(
    IN       LPTS_OPEN_FILE_INFO  pOpenFile
    )
/*++
Routine Description:

    When a W3_URI_INFO gets cleaned up, it needs to get rid
    of it's reference to the file info by calling TsDerefURIFile.

Arguments:

    pOpenFile - Pointer to the TS_OPEN_FILE_INFO to be derefed.

Return Values:

    TRUE on success
--*/
{
    CheckinFile(pOpenFile, 0);

    return TRUE;
}



LPTS_OPEN_FILE_INFO
TspOpenFile(
    LPCSTR pszName,
    HANDLE hUser,
    DWORD  dwOptions
    )
/*++
Routine Description:

    Opens a non-cached TS_OPEN_FILE_INFO for TsCreateFile.

Arguments:

    pszName - The name of the file
    hUser   - HANDLE for the user attempting the open
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN (Ignored for non-cached case)
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON

Return Values:

    On success returns a pointer to a TS_OPEN_FILE_INFO
    for the requested file. NULL is returned on failure.
    More error information can be gotten
    from GetLastError(), which will return one of:

        ERROR_INSUFFICIENT_BUFFER
        ERROR_INVALID_NAME
        ERROR_ACCESS_DENIED
        ERROR_FILE_NOT_FOUND
        ERROR_PATH_NOT_FOUND
        ERROR_NOT_ENOUGH_MEMORY
--*/
{
    TS_OPEN_FILE_INFO * pOpenFile;
    HANDLE              hFile;
    WCHAR               awchPath[MAX_PATH+8+1];
    DWORD               cchPath;
    SECURITY_ATTRIBUTES sa;
    BOOL                bImpersonated;
    BOOL                bNoParse;
    DWORD               dwError = NO_ERROR;
    PSECURITY_DESCRIPTOR  pSecDesc;
    DWORD                 dwSecDescSize;
    DWORD                 dwSecDescSizeReq;
    BOOL                  fSecDescAllocated;

    bImpersonated = FALSE;

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = FALSE;

    //
    // Allocate a file info object
    //
    pOpenFile = new TS_OPEN_FILE_INFO();
    if (!pOpenFile || !pOpenFile->SetFileName(pszName)) {
        //
        // couldn't allocate an object
        //
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto err;
    }

    //
    // Convert path to unicode
    //
    bNoParse = ! ( dwOptions & TS_USE_WIN32_CANON );
    cchPath = TspMakeWidePath(pszName, MAX_PATH+8, bNoParse, awchPath);
    if (!cchPath) {
        //
        // Path couldn't be converted
        //
        dwError = GetLastError();
        goto err;
    }
    
    // avoid the infamous ::$DATA bug

    if ( wcsstr( awchPath, L"::" ) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto err;
    }

    //
    // We may need to impersonate some other user to open the file
    //
    if ( (dwOptions & TS_NOT_IMPERSONATED) &&
         !(dwOptions & TS_NO_ACCESS_CHECK) )
    {
        if ( !::ImpersonateLoggedOnUser( hUser ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "ImpersonateLoggedOnUser[%d] failed with %d\n",
                hUser, GetLastError()));
            //
            // Return access denied
            //
            dwError = ERROR_ACCESS_DENIED;

            goto err;
        }
        bImpersonated = TRUE;
    }

    DWORD dwFileAttributes;
    if ((awchPath[cchPath-1] == L'.' || awchPath[cchPath-1] == L'\\') &&
        ((DWORD(-1) != (dwFileAttributes = GetFileAttributesW(awchPath))) && 
        (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))) {
        SetLastError(ERROR_FILE_NOT_FOUND);
        hFile = INVALID_HANDLE_VALUE;
    } else {

        //
        // Open the file
        //
        hFile = CreateFileW(
            awchPath,
            GENERIC_READ,
            TsCreateFileShareMode,
            &sa,
            OPEN_EXISTING,
            TsCreateFileFlags,
            NULL);
    }

    if ( hFile == INVALID_HANDLE_VALUE ) {
        dwError = GetLastError();
        goto err;
    }

    //
    // If our buffer wasn't big enough we have to get a new one.
    //
    pSecDesc = pOpenFile->QuerySecDesc();
    dwSecDescSize = SECURITY_DESC_DEFAULT_SIZE;
    fSecDescAllocated = FALSE;
    while(1) {
        //
        // get the security descriptor
        //
        if (GetKernelObjectSecurity(hFile,
                                OWNER_SECURITY_INFORMATION
                                | GROUP_SECURITY_INFORMATION
                                | DACL_SECURITY_INFORMATION,
                                pSecDesc,
                                dwSecDescSize,
                                &dwSecDescSizeReq)) {
            break;
        }
        else {
            if (fSecDescAllocated)
            {
                FREE(pSecDesc);
            }
            pSecDesc = NULL;

            if (ERROR_INSUFFICIENT_BUFFER != GetLastError()) {
                //
                // We got some error other than not enough buffer.
                // Fail the whole request.
                //
                dwError = GetLastError();
                ::CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
                goto err;
            }
        }

        dwSecDescSize = ((dwSecDescSizeReq + SECURITY_DESC_GRANULARITY - 1)
            / SECURITY_DESC_GRANULARITY) * SECURITY_DESC_GRANULARITY;

        pSecDesc = ALLOC(dwSecDescSize);
        if (!pSecDesc) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            ::CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
            goto err;
        }

        fSecDescAllocated = TRUE;
    }

    //
    // Store the file information
    //
    pOpenFile->SetFileInfo(
        hFile,
        hUser,
        pSecDesc,
        dwSecDescSize
        );

    if ( bImpersonated ) {
        ::RevertToSelf();
    }

    pOpenFile->TraceCheckpointEx(TS_MAGIC_CREATE_NC, 0, 0);

    return pOpenFile;

err:
    if ( bImpersonated ) {
        ::RevertToSelf();
    }

    if (pOpenFile) {
        delete pOpenFile;
    }

    SetLastError(dwError);

    return NULL;
}


LPTS_OPEN_FILE_INFO
TspOpenCachedFile(
    LPCSTR pszName,
    HANDLE hUser,
    DWORD  dwOptions
    )
/*++
Routine Description:

    Helper function for TsCreateFile

    Opens a TS_OPEN_FILE_INFO and puts it in the file cache.
    We want to make sure that each file only gets opened once,
    so first we put an uninitialized file entry in the cache.
    If the open succeeds, we tell the cache that the file is
    ready for use.  Otherwise we decache it.

Arguments:

    pszName     - The name of the file
    OpeningUser - HANDLE for the user attempting the open
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON

Return Values:

    On success returns a pointer to a TS_OPEN_FILE_INFO
    for the requested file. NULL is returned on failure.
    More error information can be gotten
    from GetLastError(), which will return one of:

        ERROR_INSUFFICIENT_BUFFER
        ERROR_INVALID_NAME
        ERROR_ACCESS_DENIED
        ERROR_FILE_NOT_FOUND
        ERROR_PATH_NOT_FOUND
        ERROR_NOT_ENOUGH_MEMORY
--*/
{
    TS_OPEN_FILE_INFO *pOpenFile;
    DWORD dwResult;
    DWORD dwError = NO_ERROR;

    DBG_ASSERT( !DisableTsunamiCaching );

    //
    // Allocate a file info object
    //
    pOpenFile = new TS_OPEN_FILE_INFO();
    if (!pOpenFile || !pOpenFile->SetFileName(pszName)) {
        //
        // couldn't allocate an object
        //
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto err;
    }

Retry:

    //
    // Add a cache entry to prevent others from opening the file simultaneously
    //
    dwResult = CacheFile(pOpenFile, FCF_UNINITIALIZED | FCF_FOR_IO);

    if ( dwResult == TS_ERROR_OUT_OF_MEMORY ) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto err;
    }


    if (dwResult == TS_ERROR_SUCCESS) {
        //
        // Open the file
        //
        if ( TspOpenCachedFileHelper(pszName, hUser, pOpenFile, dwOptions) ) {
            //
            // Tell the cache it worked
            //
            NotifyInitializedFile(pOpenFile);
        } else {
            //
            // need to remove the entry in the cache
            // since it's not valid.
            //
            // First we need an extra reference which we'll use to tell
            // the cache that the file is initialized. Then we'll
            // decache the file, and finally mark it initialized.
            //
            // The file can't be marked initialized before the decache,
            // because then it might look like a successful open.
            // We need the extra reference because calling decache
            // gets rid of our original reference.
            //
            pOpenFile->TraceCheckpointEx(TS_MAGIC_OPLOCK_FAIL, 0, 0);

            CheckoutFileEntry(pOpenFile, 0);

            DecacheFile(pOpenFile, FCF_FOR_IO);

            NotifyInitializedFile(pOpenFile);
            CheckinFile(pOpenFile, 0);

            pOpenFile = NULL;

            dwError = GetLastError();
            goto err;
        }
    } else {
        TS_OPEN_FILE_INFO *             pExisting = NULL;
    
        DBG_ASSERT ( dwResult == TS_ERROR_ALREADY_CACHED );

        //
        // Someone beat us to it.  Try to check it out.
        //
        if ( !CheckoutFile(pszName, FCF_FOR_IO, &pExisting) ) {
            //
            // It's been removed from the cache since our
            // attempt to add it.  Try again
            //
            
            goto Retry;
        }

        delete pOpenFile;
        pOpenFile = pExisting;

    }


    return pOpenFile;

err:
    if (pOpenFile) {
        delete pOpenFile;
    }

    SetLastError(dwError);
    return NULL;
}


BOOL
TspOpenCachedFileHelper(
    LPCSTR              pszName,
    HANDLE              hUser,
    TS_OPEN_FILE_INFO * pOpenFile,
    DWORD               dwOptions
    )
/*++
Routine Description:

    This function actually attempts to open the file with AtqCreateFileW.

    When we enable oplocks, ATQ will need a reference to the object.
    Therefore AtqCreateFileW must somehow be modified to tell me whether
    it has a reference or not.  If ATQ has a reference, we tell the cache
    so here.

Arguments:

    pszName     - The name of the file
    OpeningUser - HANDLE for the user attempting the open
    pOpenFile   - the file info object to update on success
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED          (should always be set here)
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON

Return Values:

    TRUE if the file was opened, and file information was set.
    FALSE otherwise.  More error information can be gotten
    from GetLastError(), which will return one of:

        ERROR_INSUFFICIENT_BUFFER
        ERROR_INVALID_NAME
        ERROR_ACCESS_DENIED
        ERROR_FILE_NOT_FOUND
        ERROR_PATH_NOT_FOUND
--*/
{
    HANDLE hFile;
    WCHAR  awchPath[MAX_PATH+8+1];
    DWORD  cchPath;
    DWORD  dwError = NO_ERROR;
    BOOL   bSuccess;
    BOOL   bDirectory;
    BOOL   bSmallFile;
    BOOL   bImpersonated = FALSE;
    BOOL   bNoParse;
    SECURITY_ATTRIBUTES   sa;
    BOOL                  bCacheSecDesc;
    PSECURITY_DESCRIPTOR  pSecDesc;
    DWORD                 dwSecDescSize;
    DWORD                 dwSecDescSizeReq;
    SPUD_FILE_INFORMATION FileInfo;
    DWORD                 cbFileSize = 0;
    DWORD                 cbBytesRequired;
    PBYTE                 pBuffer = NULL;
    HANDLE                hCopyFile = INVALID_HANDLE_VALUE;

    DBG_ASSERT(dwOptions & TS_CACHING_DESIRED);

    bSuccess = FALSE;
    dwSecDescSizeReq = 0;

    //
    // Assume it's not cacheable
    //
    bSmallFile = FALSE;
    bDirectory = FALSE;

    //
    // set up security info
    //
    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = FALSE;

    //
    // Allocate space for security descriptor
    //

    bCacheSecDesc = TRUE;

    //
    // The open file info contains a buffer
    // of the default size.
    //
    pSecDesc = pOpenFile->QuerySecDesc();

    dwSecDescSize = SECURITY_DESC_DEFAULT_SIZE;

    //
    // Convert path to unicode
    //
    bNoParse = ! ( dwOptions & TS_USE_WIN32_CANON );
    cchPath = TspMakeWidePath(pszName, MAX_PATH+8, bNoParse, awchPath);
    
    if (!cchPath) {
        //
        // Path couldn't be converted
        //
        pSecDesc = NULL;                // Don't free the default buffer.
        dwError = GetLastError();
        goto err;
    }

    // avoid the infamous ::$DATA bug

    if ( wcsstr( awchPath, L"::" ) )
    {
        pSecDesc = NULL;
        dwError = ERROR_FILE_NOT_FOUND;
        goto err;
    }

    //
    // We may need to impersonate some other user to open the file
    //
    if ( (dwOptions & TS_NOT_IMPERSONATED) &&
         !(dwOptions & TS_NO_ACCESS_CHECK) )
    {
        if ( !::ImpersonateLoggedOnUser( hUser ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "ImpersonateLoggedOnUser[%d] failed with %d\n",
                hUser, GetLastError()));
            //
            // Return access denied
            //
            
            pSecDesc = NULL;
            dwError = ERROR_ACCESS_DENIED;
            goto err;
        }
        bImpersonated = TRUE;
    }


    //
    // Open the file
    //

    hFile = AtqCreateFileW(
        awchPath,                       // lpFileName
        TsCreateFileShareMode,          // dwShareMode
        &sa,                            // lpSecurityAttributes
        TsCreateFileFlags,              // dwFlagsAndAttributes
        TsSecurityInfo,                 // si
        pSecDesc,                       // sd
        dwSecDescSize,                  // Length
        &dwSecDescSizeReq,              // LengthNeeded
        &FileInfo);                     // pFileInfo

    if ( hFile == INVALID_HANDLE_VALUE ) {
        bSuccess = FALSE;
        pSecDesc = NULL;                // Don't free the default buffer.
        dwError = GetLastError();
        goto err;
    }

    // if the name ends with ('\' or '.')
    // and it is NOT a directory, than fail 404
    
    if ((awchPath[cchPath-1] == L'.' || awchPath[cchPath-1] == L'\\')  && // suspect file name
        !FileInfo.StandardInformation.Directory) {
         pSecDesc = NULL;
         dwError = ERROR_FILE_NOT_FOUND;         
         ::CloseHandle(hFile);
         hFile = INVALID_HANDLE_VALUE;
         goto err;   
    }
        
    //
    // If our buffer wasn't big enough we have to get a new one.
    //
    if (dwSecDescSizeReq > dwSecDescSize) {
        //
        // Code below shouldn't try to free our original buffer
        //
        pSecDesc = NULL;

        //
        // Keep getting the security descriptor until we have enough space.
        //

        while (dwSecDescSizeReq > dwSecDescSize) {
            DBGPRINTF(( DBG_CONTEXT,
                        "Allocating a new Security Descriptor buffer! %d > %d\n",
                        dwSecDescSizeReq,
                        dwSecDescSize ));

            dwSecDescSize = ((dwSecDescSizeReq + SECURITY_DESC_GRANULARITY - 1)
                / SECURITY_DESC_GRANULARITY) * SECURITY_DESC_GRANULARITY;

            if (pSecDesc) {
                FREE(pSecDesc);
            }

            pSecDesc = ALLOC(dwSecDescSize);
            if (!pSecDesc) {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto err;
            }

            //
            // get a new security descriptor
            //
            if (!GetKernelObjectSecurity(hFile,
                                     OWNER_SECURITY_INFORMATION
                                     | GROUP_SECURITY_INFORMATION
                                     | DACL_SECURITY_INFORMATION,
                                     pSecDesc,
                                     dwSecDescSize,
                                     &dwSecDescSizeReq)
                && (ERROR_INSUFFICIENT_BUFFER != GetLastError()) ) {
                //
                // We got some error other than not enough buffer.
                // Fail the whole request.
                //
                dwError = GetLastError();
                ::CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
                goto err;
            }
        }
    }

    //
    // Don't need to be impersonated anymore
    //
    if ( bImpersonated ) {
        ::RevertToSelf();
        bImpersonated = FALSE;
    }

    bDirectory = FileInfo.StandardInformation.Directory;

    //
    // We don't need to hold the handle open for directories.
    //
    if (bDirectory) {
        ::CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    //
    // If we're using a non cached token we don't want to save it
    //
    if (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) {
        hUser = INVALID_HANDLE_VALUE;
    }

    //
    // try to read the file into the memory cache
    //

    if ((FileInfo.StandardInformation.EndOfFile.QuadPart < g_liFileCacheByteThreshold.QuadPart)
        && (hFile != INVALID_HANDLE_VALUE)) {
        
        bSmallFile = TRUE;
        cbFileSize = FileInfo.StandardInformation.EndOfFile.LowPart;

    } else {
        bSmallFile = FALSE;
    }
    
    if (bSmallFile) {
        dwError = ReadFileIntoMemoryCache(
                      hFile,
                      cbFileSize,
                      &cbBytesRequired,
                      (PVOID *) &pBuffer
                      );

        if (dwError == ERROR_SUCCESS) {
            //
            // it worked. dump the file handle
            //
            ::CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
        } else {
            //
            // we failed to make it into
            // the cache, so don't cache
            // this entry
            //
            bSmallFile = FALSE;
        }
    }
    

    //
    // Add file information to pOpenFile
    //
    pOpenFile->SetFileInfo(
        pBuffer,                 // buffer contains contents of file
        hCopyFile,               // handle to a copy of the file
        hFile,                   // handle to the file
        hUser,                   // user token, if we're supposed to cache it
        pSecDesc,                // security descriptor
        dwSecDescSize,           // size of security descriptor
        &FileInfo                // file information struct
        );
    bSuccess = TRUE;


    //
    // fall through to do cleanup
    //

err:

    if (!bDirectory && !bSmallFile) {
        //
        // This is a regular file that is too large
        // for the cache, so don't cache it.
        //
        IF_DEBUG( OPLOCKS ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "Couldn't cache %8p \"%s\"\n",
                        pOpenFile, pOpenFile->GetKey()->m_pszFileName ));
        }

        CheckoutFileEntry(pOpenFile, 0);
        DecacheFile(pOpenFile, 0);
    }

    if ( bImpersonated ) {
        ::RevertToSelf();
    }
    
    if ( !bSuccess ) {
        if ( pSecDesc ) {
            FREE(pSecDesc);
        }

        SetLastError(dwError);
    }

    return bSuccess;
}

DWORD
TspMakeWidePath(
    IN  LPCSTR  pszName,
    IN  DWORD   cchWideName,
    IN  BOOL    bNoParse,
    OUT LPWSTR  pwszWideName
    )
/*++
Routine Description:

    This routine converts a path name from the local code page and
    converts it to wide characters.  In addition it adds a prefix
    to the string, which is "\\?\UNC\" for a UNC path, and "\\?\" for
    other paths.  This prefix tells Windows not to parse the path.

Arguments:

    IN  pszName      - The path to be converted
    IN  cchWideName  - The size of the pwszWideName buffer
    OUT pwszWideName - The converted path

Return Values:

    On success we return the number of wide characters in the
    converted path + the prefix.

    On failure we return zero.  More error information will be
    returned by GetLastError().  The error code will be one of:

        ERROR_INSUFFICIENT_BUFFER
        ERROR_INVALID_NAME
--*/
{
    DWORD  cbPrefix=0;
    LPCSTR pszPath;
    DWORD  cch=0;

    if ( bNoParse ) {
        if ( (pszName[0] == '\\') && (pszName[1] == '\\') )
        {
            CopyMemory(
                pwszWideName,
                L"\\\\?\\UNC\\",
                (sizeof("\\\\?\\UNC\\")-1) * sizeof(WCHAR)
                );

            cbPrefix = sizeof("\\\\?\\UNC\\")-1;
            pszPath = pszName + sizeof( "\\\\" ) -1;
        }
        else
        {
            CopyMemory(
                pwszWideName,
                L"\\\\?\\",
                (sizeof("\\\\?\\")-1) * sizeof(WCHAR)
                );

            cbPrefix = sizeof("\\\\?\\")-1;
            pszPath = pszName;
        }
    } else {
        //
        // We're not adding a prefix
        //
        cbPrefix = 0;
        pszPath = pszName;
    }

    cch = MultiByteToWideChar( CP_ACP,
                               MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                               pszPath,
                               -1,
                               pwszWideName + cbPrefix,
                               cchWideName - cbPrefix );

    if ( !cch && (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ) {
        SetLastError(ERROR_INVALID_NAME);

        return cch; // that is, return 0
    }

    return cch+cbPrefix-1; // return the string length without the ZERO
}


VOID
TspOplockNotification(
    PVOID pvContext,
    DWORD Status
    )
/*++
Routine Description:

    When an oplock break occurs, this function gets called. If the
    break occured because we closed the file, we just check it in
    to the cache. Otherwise we flush the file so it will be closed
    as soon as possible.

Arguments:

    pvContext - Pointer to the TS_OPEN_FILE_INFO
    Status    - Tells why the break occured.

Return Values:

    None.
--*/
{
    TS_OPEN_FILE_INFO * pOpenFile = static_cast<TS_OPEN_FILE_INFO*>(pvContext);
    CHECK_FILE_STATE( pOpenFile );
    DBG_ASSERT( (Status == SPUD_OPLOCK_BREAK_OPEN)
                || (Status == SPUD_OPLOCK_BREAK_CLOSE) );


    //
    // Someone else opened the file, or we decided to close it.
    // Flush it from the cache.
    //

    IF_DEBUG( OPLOCKS ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "Oplock break %d on %p \"%s\"\n",
                    Status, pOpenFile, pOpenFile->GetKey()->m_pszFileName ));
    }

    if (Status == SPUD_OPLOCK_BREAK_OPEN) {
        //
        // Someone tried to open the file.
        //
        pOpenFile->TraceCheckpointEx(TS_MAGIC_OPLOCK_2, (PVOID) (ULONG_PTR) pOpenFile->IsFlushed(), 0);

        g_pFileCacheStats->IncOplockBreaks();
    } else {
        //
        // We closed the file, or someone opened it "aggresively"
        // (eg CREATE_ALWAYS). Unfortunately there is no way to tell
        // the difference between these cases.
        //
        pOpenFile->TraceCheckpointEx(TS_MAGIC_OPLOCK_0, (PVOID) (ULONG_PTR) pOpenFile->IsFlushed(), 0);


        g_pFileCacheStats->IncOplockBreaksToNone();
    }

    DecacheFile(pOpenFile, 0);
}



HANDLE
TS_OPEN_FILE_INFO::QueryFileHandle(
    VOID
    )
/*++
Routine Description:

    Returns a handle to the file, which we may have to open.

Arguments:

    None.
    
Return Values:

    INVALID_HANDLE_VALUE on failure
--*/
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hOldFile;

    Lock();

    if (m_hFile == INVALID_HANDLE_VALUE) {
        WCHAR               awchPath[MAX_PATH+8+1];
        DWORD               cchPath;

        //
        // Convert path to unicode
        //
        cchPath = TspMakeWidePath(m_FileKey.m_pszFileName, MAX_PATH+8, FALSE, awchPath);

        if (cchPath) {
            DWORD dwFileAttributes;
            
            // avoid the infamous ::$DATA bug

            if ( wcsstr( awchPath, L"::" ) )
            {
                SetLastError(ERROR_FILE_NOT_FOUND);
            } else if ((awchPath[cchPath-1] == L'.' || awchPath[cchPath-1] == L'\\') &&
                ((DWORD(-1) != (dwFileAttributes = GetFileAttributesW(awchPath))) && 
                 (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))) {
                SetLastError(ERROR_FILE_NOT_FOUND);
            } else {
                SECURITY_ATTRIBUTES sa;

                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;

                //
                // Open the file
                //
                hFile = CreateFileW(
                    awchPath,
                    GENERIC_READ,
                    TsCreateFileShareMode,
                    &sa,
                    OPEN_EXISTING,
                    TsCreateFileFlags,
                    NULL);
            }
        }

        hOldFile = InterlockedExchangePointer(&m_hFile, hFile);

        if (hOldFile != INVALID_HANDLE_VALUE) {
            ::CloseHandle(hOldFile);
        }
        
        Unlock();
        
        //
        // Decache this file
        //
        DecacheFile(this, FCF_NO_DEREF);
    }
    else
    {
        Unlock();
    }

    return m_hFile;
}


//
// fileopen.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\etagmb.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    etagmb.h

    This module contains the methods for ETagMetabaseSink and
    ETagChangeNumber, which watch the metabase for change
    notifications relating to ETags

    (Adapted from the MB sink notification code in compfilt)

    The underlying rationale for this code is that ETags are computed from a
    function of several variables including the metabase change number. ETags
    are used as part of the If-Modified-Since logic of browsers and proxy
    caches. If the ETags don't match, the cached copy is discarded. The
    metabase change number changes a lot but most of the changes can have no
    possible effect on the contents of a page or its headers. The few
    properties that could make a difference, such as PICS headers or footers,
    are tracked by this code for a low-volatility change number. Voila, more
    effective browser and proxy caching, leading to reduced network utilization
    and better response times as well as reduced load on the server.

    The code persists this number to the metabase on shutdown. If it didn't,
    then the etagchangenumber used when the server restarts will not match the
    one used in the previous session, so ETags will differ and remote caches
    will not be as effective.

    FILE HISTORY:
        GeorgeRe    02-Aug-1999     Created
*/

#ifndef __ETAGMB_H__
#define __ETAGMB_H__

#include <iadmw.h>

class ETagChangeNumber;

class ETagMetabaseSink : public IMSAdminBaseSinkW
{
public:
    ETagMetabaseSink(
        ETagChangeNumber* pParent)
        : m_dwRefCount(1),
          m_pParent(pParent)
    {}

    ~ETagMetabaseSink()
    {}

    HRESULT STDMETHODCALLTYPE
    QueryInterface(REFIID riid, void **ppvObject)
    {
        if (riid == IID_IUnknown || riid == IID_IMSAdminBaseSink)
        {
            *ppvObject = (IMSAdminBaseSink*) this;
        }
        else
        {
            *ppvObject = NULL;
            return E_NOINTERFACE;
        }
        AddRef();
        return S_OK;
    }

    ULONG STDMETHODCALLTYPE
    AddRef()
    {
        return InterlockedIncrement((LONG*) &m_dwRefCount);
    }

    ULONG STDMETHODCALLTYPE
    Release()
    {
        DWORD dwRefCount = InterlockedDecrement((LONG*) &m_dwRefCount);
        if (dwRefCount == 0)
            delete this;
        return dwRefCount;
    }

    HRESULT STDMETHODCALLTYPE
    SinkNotify(
        /* [in] */          DWORD              dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT_W pcoChangeList[]);

    HRESULT STDMETHODCALLTYPE
    ShutdownNotify()
    {
        return S_OK;
    }

public:
    ULONG             m_dwRefCount;
    ETagChangeNumber* m_pParent;
};


class ETagChangeNumber
{
public:
    ETagChangeNumber();
    ~ETagChangeNumber();

    void UpdateChangeNumber()
    {
        InterlockedIncrement((LONG*) &m_dwETagMetabaseChangeNumber);
        // Don't write to the metabase now, or we'll generate recursive
        // notifications
        m_fChanged = TRUE;
    }

    static DWORD
    GetChangeNumber()
    {
        DWORD dw = 0;

        if (sm_pSingleton != NULL)
        {
            dw = sm_pSingleton->m_dwETagMetabaseChangeNumber;
            if (sm_pSingleton->m_fChanged)
            {
                sm_pSingleton->m_fChanged = FALSE;
                SetETagChangeNumberInMetabase(dw);
            }
        }

        return dw;
    }

    static HRESULT
    Create()
    {
        DBG_ASSERT(sm_pSingleton == NULL);
        sm_pSingleton = new ETagChangeNumber();
        if (sm_pSingleton == NULL)
            return E_OUTOFMEMORY;
        else if (sm_pSingleton->m_dwSinkNotifyCookie == 0)
            return E_FAIL;
        else
            return S_OK;
    }

    static void
    Destroy()
    {
        delete sm_pSingleton;
        sm_pSingleton = NULL;
    }

    static DWORD
    GetETagChangeNumberFromMetabase();

    static BOOL
    SetETagChangeNumberInMetabase(
        DWORD dwETagMetabaseChangeNumber);

private:
    void
    Cleanup();

    DWORD                       m_dwETagMetabaseChangeNumber;
    ETagMetabaseSink*           m_pSink;
    IMSAdminBase*               m_pcAdmCom;
    IConnectionPoint*           m_pConnPoint;
    IConnectionPointContainer*  m_pConnPointContainer;
    DWORD                       m_dwSinkNotifyCookie;
    BOOL                        m_fChanged;

    static ETagChangeNumber*    sm_pSingleton;
};

extern ETagChangeNumber* g_pETagChangeNumber;

#endif // __ETAGMB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\metacach.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        metacach.cxx

   Abstract:
        This module contains the tsunami caching routines for metadata.

   Author:
        Henry Sanders    ( henrysa )     15-Oct-1996

--*/
//

#include <tsunami.hxx>
#include "TsunamiP.Hxx"
#pragma hdrstop
#include <dbgutil.h>
#include <issched.hxx>
#include <metacach.hxx>

extern TCHAR * FlipSlashes( TCHAR * pszPath );

//
// The number of buckets in our hash table.
//

#define METACACHE_TABLE_SIZE    127
#define METACACHE_ENTRY_SIGN    ((DWORD)'ECEM')
#define METACACHE_ENTRY_FREE    ((DWORD)'ECEf')


// time in minutes to keep entry in metachace after it was used last time
#define TIME_TO_KEEP_METACACHE_ENTRY    (5)

//
// Structure of a metacache table entry.
//

typedef struct _METACACHE_ENTRY {

    DWORD                   Signature;
    struct _METACACHE_ENTRY *pNext;
    DWORD                   dwDataSetNumber;
    DWORD                   dwServiceID;
    PVOID                   pMetaData;
    DWORD                   dwRefCount;
    DWORD                   dwLastUsedTime;
    PMDFREERTN              pFreeRoutine;
    BOOL                    bValid;

} METACACHE_ENTRY, *PMETACACHE_ENTRY;

//
// Structure of a hash table bucket.
//

typedef struct _METACACHE_BUCKET {

    PMETACACHE_ENTRY        pEntry;
    CRITICAL_SECTION        csCritSec;

} METACACHE_BUCKET;

METACACHE_BUCKET    MetaCacheTable[METACACHE_TABLE_SIZE];

DWORD   MetaCacheTimerCookie = 0;
DWORD   g_dwMetaCacheScavengeCnt = 1;
/************************************************************
 *    Functions
 ************************************************************/
dllexp
PVOID
TsFindMetaData(

    IN      DWORD           dwDataSetNumber,
    IN      DWORD           dwServiceID

    )
/*++

  Routine Description:

    This function takes a data set number and service ID, and tries to find
    a formatted chunk of metadata in the cache. If it does so, it returns a
    pointer to it, otherwise it returns NULL.

  Arguments

    dwDataSetNumber         - The data set number to be found.
    dwServiceID             - ID of calling service.
--*/
{
    DWORD               dwIndex;
    PMETACACHE_ENTRY    pCurrentEntry;

    dwIndex = dwDataSetNumber % METACACHE_TABLE_SIZE;

    //
    // This needes to be protected, we use a critical section per bucket.
    //
    EnterCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    pCurrentEntry = MetaCacheTable[dwIndex].pEntry;

    // Walk the chain on the bucket. If we find a match, return it.
    //
    while (pCurrentEntry != NULL )
    {
        PCOMMON_METADATA        pCMD;

        pCMD = (PCOMMON_METADATA)pCurrentEntry->pMetaData;

        pCMD->CheckSignature();
        ASSERT(pCMD->QueryCacheInfo() == pCurrentEntry);


        if (pCurrentEntry->dwDataSetNumber == dwDataSetNumber &&
            pCurrentEntry->dwServiceID == dwServiceID &&
            pCurrentEntry->bValid)
        {

            ASSERT( pCurrentEntry->Signature == METACACHE_ENTRY_SIGN );

            // Found a match. Increment the refcount and return a pointer
            // to the metadata.
            InterlockedIncrement((LONG *)&pCurrentEntry->dwRefCount);
            pCurrentEntry->dwLastUsedTime = g_dwMetaCacheScavengeCnt;

            LeaveCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

            return pCurrentEntry->pMetaData;
        }

        // Otherwise try the next one.
        pCurrentEntry = pCurrentEntry->pNext;
    }


    // Didn't find a match, so we'll return NULL.
    LeaveCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    return NULL;
}

dllexp
PVOID
TsAddMetaData(

    IN      PCOMMON_METADATA pMetaData,
    IN      PMDFREERTN      pFreeRoutine,
    IN      DWORD           dwDataSetNumber,
    IN      DWORD           dwServiceID
    )
/*++

  Routine Description:

    Add a chunk of formatted metadata to our cache.

  Arguments

    pMetaData               - MetaData to be added.
    dwDataSetNumber         - The data set number to be found.
    dwServiceID             - ID of calling service.

  Returns
    Pointer to metacache 'handle' to be used when freeing information.

--*/
{
    PMETACACHE_ENTRY        pNewEntry;
    DWORD                   dwIndex;

    pMetaData->CheckSignature();

    dwIndex = dwDataSetNumber % METACACHE_TABLE_SIZE;


    pNewEntry = (PMETACACHE_ENTRY)ALLOC(sizeof(METACACHE_ENTRY));

    if (pNewEntry == NULL)
    {
        // Couldn't add the entry. No big deal, just return.
        return NULL;
    }

    pNewEntry->Signature = METACACHE_ENTRY_SIGN;
    pNewEntry->dwDataSetNumber = dwDataSetNumber;
    pNewEntry->dwServiceID = dwServiceID;
    pNewEntry->pMetaData = pMetaData;
    pNewEntry->pFreeRoutine = pFreeRoutine;
    pNewEntry->dwRefCount = 1;
    pNewEntry->bValid = TRUE;
    pNewEntry->dwLastUsedTime = g_dwMetaCacheScavengeCnt;

    pMetaData->SetCacheInfo(pNewEntry);

    EnterCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    pNewEntry->pNext = MetaCacheTable[dwIndex].pEntry;

    MetaCacheTable[dwIndex].pEntry = pNewEntry;

    LeaveCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    return pNewEntry;

}

dllexp
VOID
TsFreeMetaData(

    IN      PVOID           pCacheEntry

    )
/*++

  Routine Description:

    Free a chunk of formatted metadata to the cache. What we really do here
    is decrement the ref count. If it goes to 0 and the cache element is
    marked deleted, we'll free it here.

  Arguments

    pMetaData               - MetaData to be freed.
--*/
{
    PMETACACHE_ENTRY        pEntry = (PMETACACHE_ENTRY)pCacheEntry;
    PCOMMON_METADATA        pCMD;


    ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );

    pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

    pCMD->CheckSignature();

    ASSERT(pCMD->QueryCacheInfo() == pEntry);

    InterlockedDecrement((LONG *)&pEntry->dwRefCount);

}

dllexp
VOID
TsAddRefMetaData(

    IN      PVOID           pCacheEntry

    )
/*++

  Routine Description:

    Increment reference count to chunk of formatted metadata

  Arguments

    pMetaData               - MetaData to be AddRef'ed
--*/
{
    PMETACACHE_ENTRY        pEntry = (PMETACACHE_ENTRY)pCacheEntry;

    ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );

    InterlockedIncrement((LONG *)&pEntry->dwRefCount);
}

dllexp
VOID
TsFlushMetaCache(
    DWORD       dwService,
    BOOL        bTerminating
    )
/*++

  Routine Description:

    Called when we need to flush all of our cached metainformation. We walk
    the table, and for each entry we check to see if it's in use. If it's not
    we'll free it, otherwise we'll mark it as deleted.

    If the passed in dwService ID is non-zero, then we'll only
    flush those entries that match the service. Also, if we're terminating,
    we'll do some additional checking, and also cancle any callbacks if we need
    to.

  Arguments

        dwService       - Service ID of entries to be flushed, 0 for all
                            services.
        bTerminating    - TRUE if the caller is terminating.


--*/
{
    UINT                i;
    PMETACACHE_ENTRY    pEntry;
    PMETACACHE_ENTRY    pTrailer;
    PCOMMON_METADATA        pCMD;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        EnterCriticalSection(&MetaCacheTable[i].csCritSec);

        pTrailer = CONTAINING_RECORD(&MetaCacheTable[i].pEntry,
                                        METACACHE_ENTRY, pNext);

        // Walk the chain on the bucket. For every entry, if it's not in
        // use, free it.
        //
        while (pTrailer->pNext != NULL )
        {
            pEntry = pTrailer->pNext;

            ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );

            pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

            pCMD->CheckSignature();
            ASSERT(pCMD->QueryCacheInfo() == pEntry);

            if (dwService == 0 || dwService == pEntry->dwServiceID)
            {
                if (pEntry->dwRefCount == 0)
                {
                    // This entry is not in use.

                    // If whoever added it gave us a free routine, call it now.
                    if (pEntry->pFreeRoutine != NULL)
                    {
                        (*(pEntry->pFreeRoutine))(pEntry->pMetaData);
                    }

                    // Look at the next one.
                    pTrailer->pNext = pEntry->pNext;

                    pEntry->Signature = METACACHE_ENTRY_FREE;
                    FREE(pEntry);
                }
                else
                {
                    // In a debug build we'll assert here if we're terminating,
                    // since that shouldn't happen. In a free build we won't
                    // assert for that but we will NULL out the free routine to
                    // keep it from getting called, since presumably the owner is
                    // going away.

                    if (bTerminating)
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "\n=========================================\n"
                            "Leftover item in metacache - %8p, bValid = %s\n"
                            "\t dwServiceID    = %8d  pMetaData    = %8p\n"
                            "\t dwRefCount     = %8d  pFreeRoutine = %8p\n"
                            ,
                            pEntry,
                            (pEntry->bValid ? "TRUE" : "FALSE"),
                            pEntry->dwServiceID,
                            pEntry->pMetaData,
                            pEntry->dwRefCount,
                            pEntry->pFreeRoutine ));

                        pEntry->pFreeRoutine = NULL;
                    }


                    pEntry->bValid = FALSE;
                    pTrailer = pEntry;
                }
            }
            else
            {
                pTrailer = pEntry;
            }
        }


        LeaveCriticalSection(&MetaCacheTable[i].csCritSec);
    }
}

dllexp
VOID
TsReferenceMetaData(
    IN      PVOID           pEntry
    )
/*++

  Routine Description:

    Called when we need to reference a metadata cache entry. The caller
    must have already referenced it once.

  Arguments

    pEntry          - Entry to be referenced.


--*/
{
    PMETACACHE_ENTRY        pCacheEntry = (PMETACACHE_ENTRY)pEntry;
    PCOMMON_METADATA        pCMD;


    ASSERT( pCacheEntry->Signature == METACACHE_ENTRY_SIGN );

    pCMD = (PCOMMON_METADATA)pCacheEntry->pMetaData;

    pCMD->CheckSignature();

    ASSERT(pCMD->QueryCacheInfo() == pCacheEntry);

    InterlockedIncrement((LONG *)&pCacheEntry->dwRefCount);

}

VOID
WINAPI
MetaCacheScavenger(
    PVOID       pContext
    )
/*++

  Routine Description:

    Called periodically to time out metacache information. We scan the table;
    if we find an object that's not in use we free it.

  Arguments

    None.


--*/
{
    UINT                i;
    PMETACACHE_ENTRY    pEntry;
    PMETACACHE_ENTRY    pTrailer;
    PCOMMON_METADATA        pCMD;


    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        if (MetaCacheTable[i].pEntry == NULL)
        {
            continue;
        }

        EnterCriticalSection(&MetaCacheTable[i].csCritSec);

        pTrailer = CONTAINING_RECORD(&MetaCacheTable[i].pEntry,
                                        METACACHE_ENTRY, pNext);


        // Walk the chain on the bucket. For every entry, if it's not in
        // use, free it.
        //
        while (pTrailer->pNext != NULL )
        {
            pEntry = pTrailer->pNext;

            ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );
            pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

            pCMD->CheckSignature();
            ASSERT(pCMD->QueryCacheInfo() == pEntry);


            if (pEntry->dwRefCount == 0 &&
                (pEntry->dwLastUsedTime + TIME_TO_KEEP_METACACHE_ENTRY < g_dwMetaCacheScavengeCnt))
            {

                // This entry is not in use.

                // If whoever added it gave us a free routine, call it now.
                if (pEntry->pFreeRoutine != NULL)
                {
                    (*(pEntry->pFreeRoutine))(pEntry->pMetaData);
                }

                // Free the entry and look at the next one.
                pTrailer->pNext = pEntry->pNext;

                pEntry->Signature = METACACHE_ENTRY_FREE;

                FREE(pEntry);
            }
            else
            {
                pTrailer = pEntry;
            }
        }

        LeaveCriticalSection(&MetaCacheTable[i].csCritSec);
    }
    InterlockedIncrement ((long *)&g_dwMetaCacheScavengeCnt);
}


dllexp
VOID
_TsValidateMetaCache(
    VOID
    )
/*++


--*/
{
    UINT                i;
    PMETACACHE_ENTRY    pEntry;
    PCOMMON_METADATA        pCMD;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        if (MetaCacheTable[i].pEntry == NULL)
        {
            continue;
        }

        EnterCriticalSection(&MetaCacheTable[i].csCritSec);

        pEntry = MetaCacheTable[i].pEntry;

        while (pEntry != NULL )
        {

            ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );
            pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

            pCMD->CheckSignature();
            ASSERT(pCMD->QueryCacheInfo() == pEntry);

            pEntry = pEntry->pNext;
        }

        LeaveCriticalSection(&MetaCacheTable[i].csCritSec);
    }
}


BOOL
MetaCache_Initialize(
    VOID
    )
/*++

  Routine Description:

    Initialize our metacache code.

  Arguments

    Nothing.

--*/
{
    UINT        i;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        INITIALIZE_CRITICAL_SECTION(&MetaCacheTable[i].csCritSec);
        MetaCacheTable[i].pEntry = NULL;

    }

    MetaCacheTimerCookie = ScheduleWorkItem(
                                       MetaCacheScavenger,
                                       NULL,
                                       60 * 1000,  // 1 minute
                                       TRUE );     // Periodic

    if (!MetaCacheTimerCookie)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
MetaCache_Terminate(
    VOID
    )
/*++

  Routine Description:

    Terminate our metacache code.

  Arguments

    Nothing.

--*/
{
    UINT i;

    if (MetaCacheTimerCookie != 0)
    {
        RemoveWorkItem(MetaCacheTimerCookie);
        MetaCacheTimerCookie = 0;
    }

    TsFlushMetaCache(0, TRUE);

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        DeleteCriticalSection(&MetaCacheTable[i].csCritSec);
    }

    return TRUE;
}




COMMON_METADATA::COMMON_METADATA(VOID)
: m_IpDnsAccessCheckSize( 0 ),
  m_IpDnsAccessCheckPtr ( NULL ),
  m_IpDnsAccessCheckTag ( 0 ),
  m_fDontLog            ( FALSE ),
  m_dwAccessPerm        ( MD_ACCESS_READ ),
  m_dwSslAccessPerm     ( 0 ),
  m_pAcl                ( NULL ),
  m_dwAclTag            ( 0 ),
  m_dwVrLevel           ( 0 ),
  m_dwVrLen             ( 0 ),
  m_hVrToken            ( NULL ),
  m_fVrPassThrough      ( FALSE ),
  m_dwVrError           ( 0 ),
  m_Signature           ( CMD_SIG ),
  m_fDoCache            ( TRUE )
{
    //
    //  Hmmm, since most of these values aren't getting initialized, if
    //  somebody went and deleted all the metadata items from the tree, then
    //  bad things could happen.  We should initialize with defaults things
    //  that might cause us trouble us
    //

} // COMMON_METADATA::COMMON_METADATA()


COMMON_METADATA::~COMMON_METADATA(VOID)
{
    CheckSignature();

    if ( m_IpDnsAccessCheckTag )
        {
            FreeMdTag( m_IpDnsAccessCheckTag );
            m_IpDnsAccessCheckTag = 0;
        }
    else if ( m_IpDnsAccessCheckPtr != NULL )
        {
            LocalFree( m_IpDnsAccessCheckPtr );
            m_IpDnsAccessCheckPtr = NULL;
        }

    if ( m_dwAclTag )
        {
            FreeMdTag( m_dwAclTag );
            m_dwAclTag = 0;
        }

    if ( m_hVrToken )
        {
            TsDeleteUserToken( m_hVrToken );
            m_hVrToken = NULL;
        }

} // COMMON_METADATA::~COMMON_METADATA()


VOID
COMMON_METADATA::FreeMdTag(
    DWORD dwTag
    )
/*++

Routine Description:

    Free a metadata object accessed by reference

Arguments:

    dwTag - tag of metadata object reference

Returns:

    Nothing

--*/
{
    MB  mb( (IMDCOM*) m_pInstance->m_Service->QueryMDObject() );

    CheckSignature();
    mb.ReleaseReferenceData( dwTag );
}


//
//  Private constants.
//

#define DEFAULT_MD_RECORDS          40
#define DEFAULT_RECORD_SIZE         50

# define DEF_MD_REC_SIZE   ((1 + DEFAULT_MD_RECORDS) * \
                            (sizeof(METADATA_RECORD) + DEFAULT_RECORD_SIZE))

#define RMD_ASSERT(x) if (!(x)) {DBG_ASSERT(FALSE); return FALSE; }


BOOL
COMMON_METADATA::ReadMetaData(
    PIIS_SERVER_INSTANCE    pInstance,
    MB *                    pmb,
    LPSTR                   pszURL,
    PMETADATA_ERROR_INFO    pMDError
    )
{
    METADATA_GETALL_INTERNAL_RECORD *pMDRecord;
    DWORD               dwNumMDRecords;
    BYTE                tmpBuffer[ DEF_MD_REC_SIZE];
    BUFFER              TempBuff( tmpBuffer, DEF_MD_REC_SIZE);
    DWORD               i;
    DWORD               dwDataSetNumber;
    INT                 ch;
    LPSTR               pszInVr;
    LPSTR               pszMinInVr;
    DWORD               dwNeed;
    DWORD               dwL;
    DWORD               dwVRLen;
    LPSTR               pszVrUserName;
    LPSTR               pszVrPassword;
    BYTE                tmpPrivateBuffer[ 20 ];
    BUFFER              PrivateBuffer( tmpPrivateBuffer, 20 );
    DWORD               dwPrivateBufferUsed;



    CheckSignature();
    TsValidateMetaCache();

    m_pInstance = pInstance;

    DBG_ASSERT( TempBuff.QuerySize() >=
                (DEFAULT_MD_RECORDS *
                 (sizeof(METADATA_RECORD) + DEFAULT_RECORD_SIZE))
                );

    if ( !pmb->Open( pInstance->QueryMDVRPath() ))
    {
        return FALSE;
    }

    if ( !pmb->GetAll( pszURL,
                     METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_REFERENCE,
                     IIS_MD_UT_FILE,
                     &TempBuff,
                     &dwNumMDRecords,
                     &dwDataSetNumber ))
    {
        return FALSE;
    }

    pMDRecord = (METADATA_GETALL_INTERNAL_RECORD *)TempBuff.QueryPtr();
    i = 0;

    //
    // Check from where we got VR_PATH
    //

    pszMinInVr = pszURL ;
    if ( *pszURL )
    {
        for ( pszInVr = pszMinInVr + strlen(pszMinInVr) ;; )
        {
            ch = *pszInVr;
            *pszInVr = '\0';
            dwNeed = 0;
            if ( !pmb->GetString( pszURL, MD_VR_PATH, IIS_MD_UT_FILE, NULL, &dwNeed, 0 ) &&
                 GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                *pszInVr = (CHAR)ch;
                // VR_PATH was defined at this level !

                break;
            }
            *pszInVr = (CHAR)ch;

            if ( ch )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr = CharPrev( pszMinInVr, pszInVr );
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }

            // scan for previous delimiter

            while ( *pszInVr != '/' && *pszInVr != '\\' )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr = CharPrev( pszMinInVr, pszInVr );
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }
        }

        dwVRLen = DIFF(pszInVr - pszMinInVr);
    }
    else
    {
        dwVRLen = 0;
        pszInVr = pszMinInVr;
    }

    // Close this now to minimize lock contention.
    DBG_REQUIRE(pmb->Close());

    for ( dwL = 0 ; pszMinInVr < pszInVr - 1 ; pszMinInVr = CharNext(pszMinInVr) )
    {
        if ( *pszMinInVr == '/' || *pszMinInVr == '\\' )
        {
            ++dwL;
        }
    }

    // Now walk through the array of returned metadata objects and format
    // each one into our predigested form.

    SetVrLevelAndLen( dwL, dwVRLen );
    pszVrPassword = NULL;
    pszVrUserName = NULL;
    dwPrivateBufferUsed = 0;
    pMDError->IsValid = FALSE;

    for ( ; i < dwNumMDRecords; i++, pMDRecord++ ) {

        PVOID       pDataPointer;
        CHAR        *pszMimePtr;
        CHAR        *pszTemp;
        DWORD       dwTemp;


        pDataPointer = (PVOID) ((PCHAR)TempBuff.QueryPtr() +
                                    pMDRecord->dwMDDataOffset);

        switch ( pMDRecord->dwMDIdentifier ) {

        case MD_IP_SEC:
            RMD_ASSERT( pMDRecord->dwMDDataType == BINARY_METADATA );

            if ( pMDRecord->dwMDDataLen )
            {
                if ( !SetIpDnsAccessCheck( pMDRecord->dwMDDataTag ?
                                                pMDRecord->pbMDData :
                                                pDataPointer,
                                           pMDRecord->dwMDDataLen,
                                           pMDRecord->dwMDDataTag ) )
                {
                    goto FreeRefs;
                }
            }
            break;

        case MD_ACCESS_PERM:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetAccessPerms(*(UNALIGNED DWORD*) pDataPointer);
            break;

        case MD_SSL_ACCESS_PERM:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetSslAccessPerms( *((UNALIGNED DWORD *) pDataPointer) );
            break;

        case MD_DONT_LOG:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            DBG_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetDontLogFlag( *((UNALIGNED DWORD *) pDataPointer ));
            break;

        case MD_VR_PATH:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            if (!QueryVrPath()->Copy((const CHAR *)pDataPointer))
            {
                goto FreeRefs;
            }
            break;

                case MD_APP_ROOT:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            if (!QueryAppPath()->Copy((const CHAR *)pDataPointer))
            {
                goto FreeRefs;
            }
            break;

        case MD_VR_USERNAME:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            pszVrUserName = (LPSTR)pDataPointer;
            break;

        case MD_VR_PASSWORD:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            pszVrPassword = (LPSTR)pDataPointer;
            break;

        case MD_VR_PASSTHROUGH:
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetVrPassThrough( !!*((UNALIGNED DWORD *) pDataPointer) );
            break;

        case MD_VR_ACL:
            DBG_ASSERT( pMDRecord->dwMDDataTag );
            RMD_ASSERT( pMDRecord->dwMDDataType == BINARY_METADATA );
            if ( pMDRecord->dwMDDataTag )
            {
                SetAcl( pMDRecord->pbMDData,
                        pMDRecord->dwMDDataLen,
                        pMDRecord->dwMDDataTag );
            }
            break;

        case MD_VR_NO_CACHE:
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetDoCache( !*(UNALIGNED DWORD *) pDataPointer );
            break;

        default:
            if ( !HandlePrivateProperty( pszURL, pInstance, pMDRecord, pDataPointer, &PrivateBuffer, &dwPrivateBufferUsed, pMDError ) )
            {
                goto FreeRefs;
            }
            CheckSignature();
            break;
        }
    }


    if (!FinishPrivateProperties(&PrivateBuffer, dwPrivateBufferUsed, TRUE))
    {
        goto FreeRefs;
    }

    if ( QueryVrPath()->IsEmpty() )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[ReadMetaData] Virtual Dir Path mapping not found\n" ));
        SetLastError( ERROR_FILE_NOT_FOUND );
        return FALSE;
    }

    //
    // If this is an UNC share, logon using associated credentials
    // keep a reference to this access token in the cache
    //

    if ( QueryVrPath()->QueryStr()[0] == '\\' &&
         QueryVrPath()->QueryStr()[1] == '\\' )
    {
        if ( pszVrUserName != NULL && pszVrPassword != NULL &&
             pszVrUserName[0] )
        {

            if ( !SetVrUserNameAndPassword( pInstance, pszVrUserName, pszVrPassword ) )
            {
                return FALSE;
            }
        }
    }

    CheckSignature();
    TsValidateMetaCache();
    return TRUE;

FreeRefs:

    FinishPrivateProperties(&PrivateBuffer, dwPrivateBufferUsed, FALSE);
    CheckSignature();
    TsValidateMetaCache();

    for ( ; i < dwNumMDRecords; i++, pMDRecord++ )
    {
        if ( pMDRecord->dwMDDataTag )
        {
            pmb->ReleaseReferenceData( pMDRecord->dwMDDataTag );
        }
    }

    return FALSE;
}


BOOL
COMMON_METADATA::SetVrUserNameAndPassword(
    PIIS_SERVER_INSTANCE    pInstance,
    LPSTR                   pszUserName,
    LPSTR                   pszPassword
    )
/*++
    Description:

        Set the account used to access the virtual root
        associated with this metadata

    Arguments:
        pInstance - current instance
        pszUserName - User name
        pszPassword - password

    Returns:
        TRUE if success, otherwise FALSE

--*/
{
    LARGE_INTEGER       liPwdExpiry;
    BOOL                fHaveExp;
    BOOL                fAsGuest;
    BOOL                fAsAnonymous;
    TCP_AUTHENT_INFO    TAI;

    CheckSignature();
    TAI.fDontUseAnonSubAuth = TRUE;

    m_hVrToken = TsLogonUser( pszUserName,
                              pszPassword,
                              &fAsGuest,
                              &fAsAnonymous,
                              pInstance,
                              &TAI,
                              NULL,
                              &liPwdExpiry,
                              &fHaveExp );

    //
    // If fail to logo, we remember the error and return SUCCESS
    // Caller will have to check metadata after creating it to check
    // the error code. Necessary because metadata needs to be set in HTTP_REQUEST
    // to send back proper auth status even if virtual root init failed.
    //

    if ( !m_hVrToken )
    {
        m_dwVrError = GetLastError();
    }

    return TRUE;
}


BOOL
COMMON_METADATA::BuildApplPhysicalPath(
  MB *            pmb,
  STR *           pstrApplPhysicalPath
  ) const
/*++
  Description:
    This function builds the physical path for the ApplPath of the current
    METADATA object. The ApplPath is a metbase path of the form
     /LM/W3Svc/<instance>/app-root-path
    This function uses the VR_PATH & portion of the APPL_PATH to
      construct the appropriate physical path.

  Arguments:
    pmb                  - pointer to MB object (Metabase pointer)
    pstrApplPhysicalPath - pointer to STR object that will contain
                           the physical path on return.


  Returns:
    TRUE on success and FALSE if there are errors.
    Use GetLastError() to get the appropriate error code.
--*/
{
    BOOL    fRet;
        INT     cOffSet = 0;

    CheckSignature();
    DBG_ASSERT(NULL != pmb && NULL != pstrApplPhysicalPath);

    //    m_strAppPath is in the format of /LM/W3SVC/X/ROOT/AppRoot.....
        //    Now, the next code segment split this format into
        //    strInstanceMDPath = /LM/W3SVC/X/ROOT/
        //    strVrPath = /AppRoot....
    STR      strInstanceMDPath = STR(m_strAppPath);
    LPSTR    pszVrPath = strInstanceMDPath.QueryStr();
        INT      VrLevel = 0;

    while(*pszVrPath != NULL)
        {
        if ('/' == *pszVrPath)
                {
                        VrLevel++;
                        if (5 == VrLevel)
                        {
                                break;
                        }
                }
                pszVrPath++;
    }

        STR strVrPath = STR(pszVrPath);
    // Case: /LM/W3SVC/1/ROOT
        if (4 == VrLevel)
        {
            strVrPath.Append('/');
                // OffSet needs to minus 1 because strInstanceMDPath does not have
                // ending '/'
                cOffSet = strInstanceMDPath.QueryCCH()-1;
        }
        else if ( 5 == VrLevel)
        {
        // Make a copy of VRPath
            // Caculate the cOffSet of /LM/W3SVC/X/Root/
        // Set the strInstanceMDPath
        cOffSet = DIFF(pszVrPath-strInstanceMDPath.QueryStr());
        strInstanceMDPath.SetLen(cOffSet);
        }
        else
        {
            // Can not resolve Application Physical Path.
                DBG_ASSERT(FALSE);
                pstrApplPhysicalPath->SetLen(0);
        return FALSE;
        }

        // Open the metabase key from /LM/W3SVC/X/ROOT/
    fRet = pmb->Open(strInstanceMDPath.QueryStr());
    if (TRUE == fRet)
    {
            // Get VR Path first. (Note, this is not the final VRpath).
        fRet = pmb->GetStr(strVrPath.QueryStr(),
                        MD_VR_PATH,
                        IIS_MD_UT_FILE,
                        pstrApplPhysicalPath,
                        METADATA_INHERIT,
                        NULL);

        if (TRUE == fRet)
        {
            BOOL    fFound = FALSE;
            DWORD   dwBufferSizeNeeded;
            LPSTR   pszTempMDPath = strVrPath.QueryStr();
            LPSTR   pszTemp = pszTempMDPath + strVrPath.QueryCCH() - 1;
            BOOL    fNoMoreVR = FALSE;  // used to break out infinite loop if there is no VR_PATH
                                        // defined at /LM/W3SVC/X/ROOT

            // Find where we get the VR path
            do
            {
                            dwBufferSizeNeeded = 0;
                if ( !pmb->GetString(strVrPath.QueryStr(),
                                    MD_VR_PATH,
                                    IIS_MD_UT_FILE,
                                                                        NULL,
                                    &dwBufferSizeNeeded,
                                    0
                                    )
                     && GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                    fFound = TRUE;
                                        // cOffSet is the strlen(closest Metabase path that defined
                                        // a MDVrPath property).
                                        // For Example:
                                        // /LM/W3SVC/1/ROOT/VR1/VR2/VR3
                                        // VR2 defines MDVrPath. cOffSet is strlen(/VR2)
                                        // so, based on cOffSet, we can find VR3 later.
                                        cOffSet += strVrPath.QueryCCH();
                }
                 else
                {
                    // '/' is not a DBCS trailing byte.
                                        // going backwords in /VR1/VR2/VR3/.../VRn and search '/'
                                        // and shrink one VR Level
                    pszTemp = strrchr(pszTempMDPath, '/');
                    strVrPath.SetLen(DIFF(pszTemp-pszTempMDPath));
                    // if this is TRUE, then, strVrPath is empty now, and there is no VR_PATH
                    // defined.
                    if (fNoMoreVR)
                    {
                        break;
                    }

                    if (0 == strVrPath.QueryCCH())
                    {
                        fNoMoreVR = TRUE;
                    }
                }
            } while (!fFound);

            pmb->Close();
                    if (!fFound && 0 == strVrPath.QueryCCH())
                        {
                            DBG_ASSERT(FALSE);
                            pstrApplPhysicalPath->SetLen(0);
                            return FALSE;
                        }
            pstrApplPhysicalPath->Append(m_strAppPath.QueryStr()+cOffSet);
            if (pstrApplPhysicalPath->QueryCCH())
                {
                CHAR ch;

                ch = *CharPrev(pstrApplPhysicalPath->QueryStr(),
                               pstrApplPhysicalPath->QueryStr()+pstrApplPhysicalPath->QueryCCH());

                if (ch != '\\' && ch != '/')
                    {
                    pstrApplPhysicalPath->Append("\\");
                    }
                }

            FlipSlashes(pstrApplPhysicalPath->QueryStr());
        }
        else
        {
            pmb->Close();
        }
    }

        return fRet;
} // COMMON_METADATA::BuildApplPhysicalPath()



BOOL
COMMON_METADATA::BuildPhysicalPath(
    LPSTR           pszURL,
    STR *           pstrPhysicalPath
    )
{
    return BuildPhysicalPathWithAltRoot( pszURL, pstrPhysicalPath, NULL );
}


BOOL
COMMON_METADATA::BuildPhysicalPathWithAltRoot(
    LPSTR           pszURL,
    STR *           pstrPhysicalPath,
    PCSTR           pstrAltRoot
    )
/*++
    Description:

        Construct a physical path of the following components:
        - the virtual root mapping
        - if only '/' was used off the URI to match the VR, than insert an alternate root
        - the significant part of the URI

    Arguments:
        pszURL           - The URL to be converted
        pstrPhysicalPath - the resulting physical path
        pstrAltRoot      - the alternat root

    Returns:
        TRUE if success, otherwise FALSE

--*/
{
    LPSTR               pszInVr;
    DWORD               dwL;
    INT                 ch;


    CheckSignature();
    TsValidateMetaCache();

    //
    // Build physical path from VR_PATH & portion of URI not used to define VR_PATH
    //


    //
    // skip the URI components used to locate the virtual root
    //

    pszInVr = pszURL ;
    dwL = QueryVrLevel();
    while ( dwL-- )
    {
        if ( *pszInVr )
        {
            DBG_ASSERT( *pszInVr == '/' || *pszInVr == '\\' );

            ++pszInVr;

            while ( (ch = *pszInVr) && ch != '/' && ch !='\\' )
            {
                pszInVr = CharNext( pszInVr );
            }
        }
    }

    DBG_ASSERT( dwL == (DWORD)-1 );

    if ( !pstrPhysicalPath->Copy( m_strVrPath ) )
    {
        return FALSE;
    }

    //
    // Add the alternate root
    //

    if ( pstrAltRoot &&
         (pszInVr - pszURL) <= 1  )
    {
        //
        // no significant part of the URL has been used as VR alias, so we can add in the
        // alternate root
        //

        if ( pstrPhysicalPath->QueryCCH() )
        {
            //
            // ensure there is one and only one separator
            //

            ch = *CharPrev(pstrPhysicalPath->QueryStr(), pstrPhysicalPath->QueryStr() +
                                                         pstrPhysicalPath->QueryCCH());

            if ( (ch != '/') && (ch != '\\') &&
                 (*pstrAltRoot != '/') && (*pstrAltRoot != '\\') )
            {
                if ( !pstrPhysicalPath->Append( "\\" ) )
                {
                    return FALSE;
                }
            } else if ( (ch == '/' || ch == '\\') &&
                        (*pstrAltRoot == '/' || *pstrAltRoot == '\\') )
            {
                ++pstrAltRoot;
            }
        }

        if ( !pstrPhysicalPath->Append( pstrAltRoot ) )
        {
            return FALSE;
        }
    }

    //
    // Add a path delimiter char between virtual root mount point & significant part of URI
    //

    if ( pstrPhysicalPath->QueryCCH() )
    {
        ch = *CharPrev(pstrPhysicalPath->QueryStr(), pstrPhysicalPath->QueryStr() +
                                                     pstrPhysicalPath->QueryCCH());
        if ( (ch == '/' || ch == '\\') && *pszInVr )
        {
            ++pszInVr;
        }
    }

    if ( !pstrPhysicalPath->Append( pszInVr ) )
    {
        return FALSE;
    }

    //
    // insure physical path last char uses standard directory delimiter
    //

    FlipSlashes( pstrPhysicalPath->QueryStr() );

    CheckSignature();
    TsValidateMetaCache();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\filecach.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    filecach.cxx

    This module implements the private interface to the file cache

    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include "tsunamip.hxx"

#include <tsunami.hxx>
#include "filecach.hxx"
#include "filehash.hxx"
#include "tlcach.h"
#include <pudebug.h>

/*
 * Globals
 */
CFileHashTable *  g_pFileInfoTable;
CFileCacheStats * g_pFileCacheStats;

HANDLE            g_hFileCacheShutdownEvent;
BOOL              g_fFileCacheShutdown;

CRITICAL_SECTION  g_csUriInfo;



#if TSUNAMI_REF_DEBUG
PTRACE_LOG g_pFileRefTraceLog;
#endif


/*
 * Private helper function declarations
 */
inline VOID I_DerefFileInfo(TS_OPEN_FILE_INFO *pOpenFile);
VOID        I_AddRefIO(TS_OPEN_FILE_INFO *pOpenFile);
VOID        I_DerefIO(TS_OPEN_FILE_INFO *pOpenFile);


BOOL FileFlushFilterAll(TS_OPEN_FILE_INFO *pOpenFile, PVOID pv);


/*
 * function definitions
 */
BOOL
FileCache_Initialize(
    IN  DWORD dwMaxFiles
    )
{
    BOOL fReturn;
#if TSUNAMI_REF_DEBUG
    g_pFileRefTraceLog = CreateRefTraceLog(
                            256,              // LogSize
                            0                 // ExtraBytesInHeader
                            );
#endif  // TSUNAMI_REF_DEBUG

    g_pFileInfoTable = new CFileHashTable("FCinfo");
    g_pFileCacheStats = new CFileCacheStats;

    g_fFileCacheShutdown = FALSE;
    g_hFileCacheShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    INITIALIZE_CRITICAL_SECTION( &g_csUriInfo );

    if (g_bEnableSequentialRead) {
        TsCreateFileFlags |= FILE_FLAG_SEQUENTIAL_SCAN;
    }

    fReturn = (g_pFileInfoTable
               && g_pFileCacheStats
               && TS_OPEN_FILE_INFO::Initialize(dwMaxFiles)
               && (InitializeTwoLevelCache(g_dwMemCacheSize) == ERROR_SUCCESS)
               && g_hFileCacheShutdownEvent);

    if (!fReturn) {
        FileCache_Terminate();
    }

    return fReturn;

}

VOID
FileCache_Terminate(
    VOID
    )
{
    g_fFileCacheShutdown = TRUE;

    FlushFileCache();

    //
    // At this point the hash table is empty, but there will still
    // be some oplocked files hanging around. We have to wait for
    // all the oplock completions before moving on.
    //
    if (g_pFileCacheStats->GetFlushedEntries()) {
        WaitForSingleObject(g_hFileCacheShutdownEvent, TS_FILE_CACHE_SHUTDOWN_TIMEOUT);
        DBG_ASSERT( g_pFileCacheStats->GetFlushedEntries() == 0 );
    }


    DeleteCriticalSection( &g_csUriInfo );

    CloseHandle(g_hFileCacheShutdownEvent);
    g_hFileCacheShutdownEvent=NULL;

    DBG_REQUIRE(TerminateTwoLevelCache() == ERROR_SUCCESS);

    TS_OPEN_FILE_INFO::Cleanup();
    delete g_pFileInfoTable;

    DBGPRINTF(( DBG_CONTEXT,
                 "FileCache_Terminate: deleted g_pFileInfoTable.\n" ));

    delete g_pFileCacheStats;
    g_pFileInfoTable = NULL;
    g_pFileCacheStats = NULL;

#if TSUNAMI_REF_DEBUG
    if( g_pFileRefTraceLog != NULL ) {
        DestroyRefTraceLog( g_pFileRefTraceLog );
        g_pFileRefTraceLog = NULL;
    }
#endif  // TSUNAMI_REF_DEBUG
}


DWORD
CacheFile(
    IN  TS_OPEN_FILE_INFO * pOpenFile,
    IN  DWORD               dwFlags
    )
/*++
Routine Description:

    Add a file info structure to the cache.

    If the FCF_UNINITIALIZED flag is set, the file will be added to
    the cache, but calls to CheckoutFile will be blocked until the
    file is marked initialized with NotifyFileInitialized.
    CheckoutFileEntry will not block. I expect that this flag will
    always be set.

    The FCF_FOR_IO flag indicates that the caller will be performing
    I/O operations with the cached file handle. This flag will be
    clear in most cases except in TsCreateFile.

Arguments:

    pOpenFile - The structure to be cached.
    pstrPath - The pathname that will be used to look up the cache entry.
    dwFlags - Valid flags are FCF_UNINITIALIZED and FCF_FOR_IO.

Return Value:

    TS_ERROR_SUCCESS
    TS_ERROR_OUT_OF_MEMORY
    TS_ERROR_ALREADY_CACHED
--*/
{
    enum LK_RETCODE lkRetval;
    DWORD dwRetval;

    DBG_ASSERT( pOpenFile != NULL );

    //
    // The caller gets a reference to this file info object
    //
    pOpenFile->AddRef();

    //
    // Don't need to acquire the lock since the object is not yet
    // in the cache.
    //
    pOpenFile->SetCached();
    if (dwFlags & FCF_FOR_IO) {
        pOpenFile->AddRefIO();
    }
   
    if (! (dwFlags & FCF_UNINITIALIZED)) {
        pOpenFile->SetInitialized();
    }

    //
    // Put it in the hash table
    //
    lkRetval = g_pFileInfoTable->InsertRecord(pOpenFile, false);

    if (LK_SUCCESS == lkRetval) {
        dwRetval = TS_ERROR_SUCCESS;
        g_pFileCacheStats->IncFilesCached();
    } else {
        if (LK_ALLOC_FAIL == lkRetval) {
            dwRetval = TS_ERROR_OUT_OF_MEMORY;
        } else if (LK_KEY_EXISTS == lkRetval) {
            dwRetval = TS_ERROR_ALREADY_CACHED;
        } else {
            //
            // No other error should come to pass
            //
            dwRetval = TS_ERROR_OUT_OF_MEMORY;
            DBG_ASSERT(FALSE);
        }

        pOpenFile->ClearCached();
        if (dwFlags & FCF_FOR_IO) {
            pOpenFile->DerefIO();
        }

        //
        // Remove the reference we added.
        // Don't call I_DerefFileInfo, because this
        // object never made it to the cache.
        // The caller will free the memory.
        //
        pOpenFile->Deref();
    }

    return dwRetval;
}


VOID
NotifyInitializedFile(
    IN  TS_OPEN_FILE_INFO * pOpenFile
    )
/*++
Routine Description:

    This function tells that cache that a file previously cached with
    CacheUninitializedFile, is now ready for use.

Arguments:

    pOpenFile - The file which is now initialized.

Return Value:

    None.
--*/
{
    BOOL bShouldClose;

    CHECK_FILE_STATE( pOpenFile );

    //
    // Mark the file as initialized
    //
    pOpenFile->Lock();
    pOpenFile->SetInitialized();
    bShouldClose = pOpenFile->IsCloseable();
    pOpenFile->Unlock();

    //
    // Clean up as neccessary
    // Note that I don't have to worry about the IO refcount
    // going back up because the file is marked as flushed.
    //
    if (bShouldClose) {
        pOpenFile->CloseHandle();
    }

    //
    // TODO: need to execute any notification code?
    //
}


VOID
DecacheFile(
    IN  TS_OPEN_FILE_INFO * pOpenFile,
    IN  DWORD               dwFlags
    )
/*++
Routine Description:

    Remove a file info entry from the cache. After a call to
    DecacheFile the entry will not be returned by CheckoutFile. The
    entry itself is cleaned up when the last CheckinFile occurs.
    Calling DecacheFile checks the entry in.

    The FCF_FOR_IO flag indicates that the caller will be performing
    I/O operations with the cached file handle. I expect that this flag
    will always be clear.

Arguments:

    pOpenFile - The file info structure to be decached
    dwFlags   - Valid flags are FCF_FOR_IO, FCF_NO_DEREF.

Return Value:

    None.
--*/
{
    BOOL  bShouldClose;
    TS_OPEN_FILE_INFO * pHashFile;
    LK_RETCODE lkrc;

    CHECK_FILE_STATE( pOpenFile );

    //
    // remove the file from the hashtable
    //
    lkrc = g_pFileInfoTable->DeleteRecord(pOpenFile);
    DBG_ASSERT( LK_SUCCESS == lkrc || LK_NO_SUCH_KEY == lkrc );


#if TSUNAMI_REF_DEBUG
    if (LK_SUCCESS == lkrc) {
        pOpenFile->TraceCheckpoint();
    }
#endif

    //
    // update state
    //
    pOpenFile->Lock();

    if (! pOpenFile->IsFlushed() ) {
        pOpenFile->SetFlushed();

        g_pFileCacheStats->IncFlushedEntries();
        g_pFileCacheStats->DecFilesCached();
    }


    if (dwFlags & FCF_FOR_IO) {
        I_DerefIO(pOpenFile);
    }

    bShouldClose = pOpenFile->IsCloseable();

    pOpenFile->Unlock();

    //
    // Clean up as neccessary
    // Note that I don't have to worry about the IO refcount
    // going back up because the file is marked as flushed.
    //
    if (bShouldClose) {
        pOpenFile->CloseHandle();
    }

    if (!(dwFlags & FCF_NO_DEREF)) {
        I_DerefFileInfo(pOpenFile);
    }
}


VOID
FlushFileCache(
    VOID
    )
/*++
Routine Description:

    Removes all entries from the cache. Unlike DecacheFile, this
    function does not check any entries in.

Arguments:

    None

Return Value:

    None
--*/
{
    FilteredFlushFileCache(FileFlushFilterAll, NULL);
}



LK_PREDICATE
FileFlushCachePredicate(
    TS_OPEN_FILE_INFO *pOpenFile,
    void* pvState
    )
{
    TS_FILE_FLUSH_STATE * pFlushState = static_cast<TS_FILE_FLUSH_STATE*>(pvState);
    LK_PREDICATE          lkpAction;

    if (pFlushState->pfnFilter(pOpenFile, pFlushState->pvParm)) {
        //
        // put it on the list
        //
        pOpenFile->AddRef(); // for the list

        InsertHeadList(&pFlushState->ListHead, &pOpenFile->FlushList);
        lkpAction = LKP_PERFORM;
    } else {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
}


VOID
FilteredFlushFileCache(
    IN PFCFILTERRTN pFilterRoutine,
    IN PVOID        pv
    )
/*++
Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a
    parameter. The function will be called with each item in the cache.
    If the function returns TRUE, the item will be decached (but not
    checked in). Otherwise the item will remain in the cache.

Arguments:

    pFilterRoutine - A pointer to the filter function
    pv             - a parameter to the filter function

Return Value:

    None
--*/
{
    TS_FILE_FLUSH_STATE FlushState;

    g_pFileCacheStats->IncFlushes();

    //
    // Initialize the flush state
    //
    FlushState.pfnFilter = pFilterRoutine;
    InitializeListHead(&FlushState.ListHead);
    FlushState.pvParm = pv;

    //
    // Delete elements from table and construct list
    //
    g_pFileInfoTable->DeleteIf(FileFlushCachePredicate, &FlushState);

    //
    // Update element state and close file handles
    //
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNext;
    TS_OPEN_FILE_INFO * pOpenFile;
    BOOL                bShouldClose;

    for (pEntry = FlushState.ListHead.Flink;
         pEntry != &FlushState.ListHead;
         pEntry = pNext ) {

        pNext = pEntry->Flink;
        pOpenFile = CONTAINING_RECORD( pEntry, TS_OPEN_FILE_INFO, FlushList );
        DBG_ASSERT( pOpenFile->CheckSignature() );

        pOpenFile->Lock();

        if (! pOpenFile->IsFlushed() ) {
            pOpenFile->SetFlushed();

            g_pFileCacheStats->IncFlushedEntries();
            g_pFileCacheStats->DecFilesCached();
        }

        bShouldClose = pOpenFile->IsCloseable();

        pOpenFile->Unlock();

        if (bShouldClose) {
            pOpenFile->CloseHandle();
        }

        I_DerefFileInfo(pOpenFile);  // remove our list's reference
    }
}



BOOL
CheckoutFile(
    IN  LPCSTR               pstrPath,
    IN  DWORD                dwFlags,
    OUT TS_OPEN_FILE_INFO ** ppOpenFile
    )
/*++
Routine Description:

    Look up an entry in the cache and return it.

    The FCF_FOR_IO flag indicates that the caller will be performing
    I/O operations with the cached file handle. This flag will be clear
    in most cases except in TsCreateFile.

Arguments:

    pstrPath   - The pathname of the desired file info in UPPERCASE!!
    dwFlags    - The only valid flag is FCF_FOR_IO.
    ppOpenFile - On success this output points to the cached entry.
                 Otherwise it is not set.

Return Value:

    TRUE if the item was found, FALSE otherwise.
    Additional error information can be obtained from GetLastError()
--*/
{
    CFileKey fileKey;
    TS_OPEN_FILE_INFO * pOpenFile;
    BOOL bRetVal = FALSE;
    DWORD dwError;

    DBG_ASSERT( pstrPath != NULL );

    //
    // Look in the hash table
    //
    fileKey.m_pszFileName = const_cast<char *>(pstrPath);
    fileKey.m_cbFileName = strlen(pstrPath);

    g_pFileInfoTable->FindKey(&fileKey, &pOpenFile);

    if (NULL == pOpenFile) {
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    //
    // Make sure it's valid and update state
    //
    CHECK_FILE_STATE( pOpenFile );

    pOpenFile->Lock();

    DBG_ASSERT( pOpenFile->IsCached() );

    if (dwFlags & FCF_FOR_IO) {
        I_AddRefIO(pOpenFile);
    }

    pOpenFile->Unlock();


    //
    // Make sure it's initialized
    //
    if (!pOpenFile->IsInitialized()) {
        int t = 1;  // time to sleep
        int i = 0;  // number of times we've gone to sleep

        while (!pOpenFile->IsInitialized() && i < c_SleepTimeout) {
            Sleep(t);
            if (t < c_dwSleepmax) {
                t <<= 1;
            }

            i++;
        }
    }

    if (!pOpenFile->IsInitialized()) {
        //
        // OK we've waited long enough. Just return failure.
        //
        dwError = ERROR_BUSY;
        goto err;
    }

    if (pOpenFile->IsFlushed()) {
        dwError = ERROR_FILE_NOT_FOUND;
        goto err;
    }

    //
    // At last, sweet success!
    //
    bRetVal = TRUE;
    *ppOpenFile = pOpenFile;
exit:
    if (!bRetVal) {
        SetLastError(dwError);
    }
    
    if (dwFlags & FCF_FOR_IO) {
        if (bRetVal) {
            g_pFileCacheStats->IncHits();
        } else {
            g_pFileCacheStats->IncMisses();
        }
    }

    return bRetVal;

err:
    //
    // if we added to the IO refcount we have to decrement
    // that now.
    //
    if (dwFlags & FCF_FOR_IO) {
        pOpenFile->Lock();
        I_DerefIO(pOpenFile);
        pOpenFile->Unlock();
    }

    //
    // FindKey automatically increments the refcount so
    // we must deref here.
    //
    I_DerefFileInfo(pOpenFile);

    if (dwFlags & FCF_FOR_IO) {
        g_pFileCacheStats->IncMisses();
    }

    SetLastError(dwError);

    return FALSE;
}


BOOL
CheckoutFileEntry(
    IN  TS_OPEN_FILE_INFO * pOpenFile,
    IN  DWORD               dwFlags
    )
/*++
Routine Description:

    This function checks out an entry to which the caller already has
    a reference.

    The FCF_FOR_IO flag indicates that the caller will be performing
    I/O operations with the cached file handle.

Arguments:

    pOpenFile - The file info structure to be checked out.
    dwFlags   - The only valid flag is FCF_FOR_IO.

Return Value:

    TRUE  - File was successfully checked out
    FALSE - File was checked out, but should not be used by the
            caller. (it's been flushed)
--*/
{
    BOOL bSuccess;

    CHECK_FILE_STATE( pOpenFile );

    pOpenFile->AddRef();

    pOpenFile->Lock();

    if (dwFlags & FCF_FOR_IO) {
        I_AddRefIO(pOpenFile);
    }

    if (pOpenFile->IsFlushed() == FALSE) {
        bSuccess = TRUE;
    } else {
        bSuccess = FALSE;
    }

    if (dwFlags & FCF_FOR_IO) {
        if (bSuccess) {
            g_pFileCacheStats->IncHits();
        } else {
            g_pFileCacheStats->IncMisses();
        }
    }

    pOpenFile->Unlock();

    return bSuccess;
}


VOID
CheckinFile(
    IN TS_OPEN_FILE_INFO * pOpenFile,
    IN DWORD               dwFlags
    )
/*++
Routine Description:

    Indicate that a previously checked out file info is no longer in use.

    The FCF_FOR_IO flag indicates that the caller was be performing I/O
    operations with the cached file handle. This flag will be clear in
    most cases except in TsCloseHandle.

Arguments:

    pOpenFile - The file info structure to be checked in.
    dwFlags   - The only valid flag is FCF_FOR_IO.

Return Value:

    None.
--*/
{
    BOOL bShouldClose;

    CHECK_FILE_STATE( pOpenFile );

    //
    // update state
    //
    pOpenFile->Lock();

    if (dwFlags & FCF_FOR_IO) {
        I_DerefIO(pOpenFile);
    }

    bShouldClose = pOpenFile->IsCloseable();

    pOpenFile->Unlock();

    //
    // Clean up as necessary
    //
    if (bShouldClose) {
        pOpenFile->CloseHandle();
    }

    I_DerefFileInfo(pOpenFile);
}


inline VOID
I_DerefFileInfo(
    TS_OPEN_FILE_INFO *pOpenFile
    )
/*++

--*/
{
    LONG lRefCount;

    DBG_ASSERT( pOpenFile != NULL );
    DBG_ASSERT( pOpenFile->CheckSignature() );

    lRefCount = pOpenFile->Deref();

    DBG_ASSERT( lRefCount >= 0 );

    if (lRefCount == 0) {
        DBG_ASSERT(pOpenFile->IsFlushed());
        delete pOpenFile;

        g_pFileCacheStats->DecFlushedEntries();
    }
}


VOID
I_AddRefIO(
    TS_OPEN_FILE_INFO * pOpenFile
    )
/*++
Routine Description:

    Calls pOpenFile->AddRefIO. 

    This should be called with the fileinfo lock held.

Arguments:

    pOpenFile - the file to addref

Return Value:

    None.
--*/
{
    pOpenFile->AddRefIO();
}


VOID
I_DerefIO(
    TS_OPEN_FILE_INFO * pOpenFile
    )
/*++
Routine Description:

    Calls pOpenFile->DerefIO. 

    This should be called with the fileinfo lock held.

Arguments:

    pOpenFile - the file to deref

Return Value:

    None.
--*/
{
    pOpenFile->DerefIO();
}


VOID
TS_OPEN_FILE_INFO::Print(
    VOID
    ) const
{
    //
    // Doesn't do anything.  Ha!
    //
}





BOOL
CFileCacheStats::DumpToHtml(
    CHAR * pchBuffer,
    LPDWORD lpcbBuffer) const
{
    *lpcbBuffer = wsprintf(pchBuffer,
        "<table>"
        "<tr><td>Currently Cached Files</td><td align=right>%d</td></tr>"
        "<tr><td>Total # of files added</td><td align=right>%d</td></tr>"
        "<tr><td>Cache Hits</td><td align=right>%d</td></tr>"
        "<tr><td>Cache Misses</td><td align=right>%d</td></tr>"
        "<tr><td>Cache Flushes</td><td align=right>%d</td></tr>"
        "<tr><td>Oplock Breaks</td><td align=right>%d</td></tr>"
        "<tr><td>Oplock Breaks To None</td><td align=right>%d</td></tr>"
        "<tr><td>Flushed entries in cache</td><td align=right>%d</td></tr>"
        "<tr><td>Total # files flushed</td><td align=right>%d</td></tr>"
        "</table>",
        FilesCached,
        TotalFilesCached,
        Hits,
        Misses,
        Flushes,
        OplockBreaks,
        OplockBreaksToNone,
        FlushedEntries,
        TotalFlushed );

    return TRUE;
}

BOOL
CFileCacheStats::QueryStats(
    INETA_CACHE_STATISTICS * pCacheCtrs
    ) const
{
    return FALSE;
}


BOOL
FileFlushFilterAll(
    TS_OPEN_FILE_INFO *pOpenFile,
    PVOID              pv
    )
{
    return TRUE;
}

#if DBG
BOOL
CheckFileState(
    TS_OPEN_FILE_INFO *pOpenFile
    )
{
    DBG_ASSERT( pOpenFile );
    DBG_ASSERT( pOpenFile->CheckSignature() );
    DBG_ASSERT( pOpenFile->IsCached() );
    DBG_ASSERT( g_pFileInfoTable );

    TS_OPEN_FILE_INFO * pHashFile;
    BOOL                bOK;

    //
    // I was going to do some interesting checks here
    // but the synchronization is just too hard
    //
    bOK = TRUE;

    return bOK;
}
#endif // DBG

//
// filecach.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\tlcach.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    tlcach.cxx

    This module implements the private interface to the two-level cache.  This 
    cache is used to either cache the contents of a file or to copy the
    file and cache the handle to it

    FILE HISTORY:
        BAlam       10-31-1998      Created
*/

#include "TsunamiP.Hxx"
#pragma hdrstop

// #define LOCAL_ALLOC 1
#define PRIVATE_HEAP 1
// #define VIRTUAL_ALLOC 1
// #define LOOKASIDE 1

#include "issched.hxx"
#include "tlcach.h"

//
// Globals
//

// Memory Cache size statistics

DWORDLONG                   g_cbMaxMemCacheSize;
DWORDLONG                   g_cbMemCacheSize;
DWORDLONG                   g_cbMaxMemCacheUsed;
DWORD                       g_cMemCacheElements;
DWORD                       g_cMaxMemCacheElementsUsed;

// Cache utility
                            
CRITICAL_SECTION            g_csMemCache;
DWORD                       g_dwMemCacheSizeCookie;
DWORD                       g_cmsecAdjustmentTime = DEFAULT_ADJUSTMENT_TIME;
CHAR                        g_achTempPath[ MAX_PATH + 1 ];



#if defined(LOCAL_ALLOC)

const char                  g_szTsunamiAllocator[] = "LocalAlloc";

#elif defined(PRIVATE_HEAP)

const char                  g_szTsunamiAllocator[] = "PrivateHeap";

HANDLE                      g_hMemCacheHeap = NULL;

#elif defined(VIRTUAL_ALLOC)

const char                  g_szTsunamiAllocator[] = "VirtualAlloc";

#elif defined(LOOKASIDE)

const char                  g_szTsunamiAllocator[] = "LookAside";

enum {
    ENORMOUS = 300,
    MANY     = 200,
    LOTS     = 100,
    SOME     = 50,
    FEW      = 20,
    MINIMAL  = 4,

    KB = 1024,
};

ALLOC_CACHE_CONFIGURATION g_aacc[] = {
    { 1, SOME,          128},
    { 1, SOME,          256},
    { 1, SOME,          512},
    { 1, LOTS,          768},
    { 1, LOTS,       1 * KB},
    { 1, ENORMOUS,   2 * KB},
    { 1, ENORMOUS,   3 * KB},
    { 1, ENORMOUS,   4 * KB},
    { 1, MANY,       5 * KB},
    { 1, MANY,       6 * KB},
    { 1, MANY,       7 * KB},
    { 1, MANY,       8 * KB},
    { 1, LOTS,       9 * KB},
    { 1, LOTS,      10 * KB},
    { 1, LOTS,      11 * KB},
    { 1, LOTS,      12 * KB},
    { 1, LOTS,      14 * KB},
    { 1, SOME,      16 * KB},
    { 1, SOME,      20 * KB},
    { 1, SOME,      24 * KB},
    { 1, SOME,      28 * KB},
    { 1, SOME,      32 * KB},
    { 1, FEW,       36 * KB},
    { 1, FEW,       40 * KB},
    { 1, FEW,       44 * KB},
    { 1, FEW,       48 * KB},
    { 1, FEW,       56 * KB},
    { 1, MINIMAL,   64 * KB},
    { 1, MINIMAL,   80 * KB},
    { 1, MINIMAL,   96 * KB},
    { 1, MINIMAL,  128 * KB},
    { 1, MINIMAL,  160 * KB},
    { 1, MINIMAL,  192 * KB},
    { 1, MINIMAL,  256 * KB},
};

CLookAside* g_laMemCache = NULL;

// paacc must be sorted in increasing sizes, it is sorted right now from
// where it is called

CLookAside::CLookAside(
    ALLOC_CACHE_CONFIGURATION* paacc,
    SIZE_T                     caacc)
    : m_dwSignature(SIGNATURE),
      m_apach(NULL),
      m_aacc(NULL),
      m_cach(0),
      m_nMinSize(0),
      m_nMaxSize(0)
{
    ALLOC_CACHE_HANDLER** apach = new ALLOC_CACHE_HANDLER* [caacc];
    if (apach == NULL)
        return;

    ALLOC_CACHE_CONFIGURATION* paacc2 = new ALLOC_CACHE_CONFIGURATION [caacc];
    if (paacc2 == NULL)
        return;
    
    for (SIZE_T i = 0;  i < caacc;  ++i)
    {
        ALLOC_CACHE_CONFIGURATION acc = paacc[i];
        acc.cbSize -= HEAP_PREFIX + HEAP_SUFFIX + ACACHE_OVERHEAD;
        paacc2[i] = acc;

        if (i == 0)
            m_nMinSize = acc.cbSize;
        else if (i == caacc-1)
            m_nMaxSize = acc.cbSize;

        char szName[40];
        sprintf(szName, "TsLookAside-%d", acc.cbSize);
        
        apach[i] = new ALLOC_CACHE_HANDLER(szName, &acc);
        bool fInOrder = (i == 0  ||  paacc2[i].cbSize > paacc2[i-1].cbSize);

        if (!fInOrder)
        {
            DBGPRINTF((DBG_CONTEXT, "CLookAside: config array out of order\n"));
        }

        if (apach[i] == NULL  ||  !fInOrder)
        {
            for (SIZE_T j = i;  j-- > 0; )
            {
                delete apach[j];
            }
            m_nMinSize = m_nMaxSize = 0;
            return;
        }
    }

    m_apach = apach;
    m_aacc  = paacc2;
    m_cach  = caacc;
}



CLookAside::~CLookAside()
{
    for (SIZE_T j = m_cach;  j-- > 0; )
    {
        delete m_apach[j];
    }

    delete [] m_apach;
    delete [] m_aacc;

    m_dwSignature = SIGNATURE_X;
}



int
CLookAside::_FindAllocator(
    IN DWORD cbSize)
{
    if (cbSize > m_nMaxSize)
        return -1;  // too big to cache
    else if (cbSize <= m_nMinSize)
        return 0;

    int l = 0, h = m_cach-1;

    do
    {
        DBG_ASSERT(m_aacc[l].cbSize < cbSize  &&  cbSize <= m_aacc[h].cbSize);

        unsigned m = (unsigned) (l + h) >> 1;
        DBG_ASSERT(m > 0);

        if (m_aacc[m-1].cbSize < cbSize  &&  cbSize <= m_aacc[m].cbSize)
            return m;
        else if (m_aacc[m].cbSize < cbSize)
            l = m+1;
        else
            h = m-1;
    } while (l <= h);

    DBG_ASSERT(FALSE);
    return -1;
}



LPVOID
CLookAside::Alloc(
    IN DWORD cbSize)
{
    LPVOID pv = NULL;
    int iAllocator = _FindAllocator(cbSize);

    if (iAllocator < 0)
    {
        pv = VirtualAlloc(NULL, cbSize, MEM_COMMIT, PAGE_READWRITE);
    }
    else
    {
        DBG_ASSERT(iAllocator < m_cach && cbSize <= m_aacc[iAllocator].cbSize);
        pv = m_apach[iAllocator]->Alloc();
    }

    return pv;
}



BOOL
CLookAside::Free(
    IN LPVOID pv,
    IN DWORD cbSize)
{
    int iAllocator = _FindAllocator(cbSize);

    if (iAllocator < 0)
    {
        VirtualFree(pv, 0, MEM_RELEASE);
    }
    else
    {
        DBG_ASSERT(iAllocator < m_cach && cbSize <= m_aacc[iAllocator].cbSize);
        m_apach[iAllocator]->Free(pv);
    }

    return TRUE;
}


#endif // LOCAL_ALLOC

//
// Defines
//

#define MemCacheLock()      ( EnterCriticalSection( &g_csMemCache ) )
#define MemCacheUnlock()    ( LeaveCriticalSection( &g_csMemCache ) )

//
// Private declarations
//

VOID
WINAPI
I_MemoryCacheSizeAdjustor(
    PVOID       pContext
);

//
// Global functions
//

DWORD
InitializeTwoLevelCache( 
    IN DWORDLONG            cbMemoryCacheSize
)
/*++
Routine Description:

    Initialize memory cache

Arguments:

    cbMemoryCacheSize - Size of memory cache (in bytes).  
    
Return Value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    DWORD                   dwError = ERROR_SUCCESS;

    if (DisableTsunamiCaching)
        return dwError;
    
    INITIALIZE_CRITICAL_SECTION( &g_csMemCache );

    if ( cbMemoryCacheSize == (DWORDLONG)-1 )
    {
        MEMORYSTATUSEX          MemoryStatus;
        MemoryStatus.dwLength = sizeof MemoryStatus;
    
        // 
        // Get our own estimate of size of cache
        //
        
        GlobalMemoryStatusEx( &MemoryStatus );
        
        g_cbMaxMemCacheSize = min( MemoryStatus.ullAvailPhys,
                                   MemoryStatus.ullTotalVirtual ) / 2;
        
        //
        // Schedule a max cache size adjustor
        //
        
        g_dwMemCacheSizeCookie = ScheduleWorkItem( I_MemoryCacheSizeAdjustor,
                                                   NULL,
                                                   g_cmsecAdjustmentTime,
                                                   TRUE );
        if ( !g_dwMemCacheSizeCookie )
        {
            dwError = GetLastError();
        }
    }
    else
    {
        g_cbMaxMemCacheSize = cbMemoryCacheSize;
    }

    if ( dwError == ERROR_SUCCESS )
    {
#if defined(LOCAL_ALLOC)
        // no initialization needed
#elif defined(PRIVATE_HEAP)
        g_hMemCacheHeap = HeapCreate( 0, 0, 0 );
        if (g_hMemCacheHeap == NULL)
            dwError = ERROR_NOT_ENOUGH_MEMORY;
#elif defined(VIRTUAL_ALLOC)
        // no initialization needed
#elif defined(LOOKASIDE)
        g_laMemCache = new CLookAside(g_aacc,
                                      sizeof(g_aacc)/sizeof(g_aacc[0]));
        if (g_laMemCache == NULL)
            dwError = ERROR_NOT_ENOUGH_MEMORY;
#endif // LOCAL_ALLOC
    }

    if ( dwError != ERROR_SUCCESS )
    {
        TerminateTwoLevelCache();
    }
    return dwError;
}

DWORD
ReadFileIntoMemoryCache( 
    IN HANDLE               hFile,
    IN DWORD                cbFile,
    OUT DWORD *             pcbRequired,
    OUT VOID **             ppvBuffer
)
/*++
Routine Description:

    Read contents of file into a buffer

Arguments:

    hFile - Handle to valid file
    cbFile - Size of file ( ==> size of buffer )
    pcbRequired - Filled in with number of bytes required to be removed from
                  cache to fit element
    ppvBuffer - Filled in with pointer to buffer with file contents.  Set
                to NULL on failure

Return Value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    BOOL                    bRet;
    VOID *                  pvBuffer = NULL;
    DWORD                   cbRead;
    OVERLAPPED              Overlapped;
    DWORD                   dwError = ERROR_SUCCESS;

    DBG_ASSERT( hFile && ( hFile != INVALID_HANDLE_VALUE ) );
    DBG_ASSERT( pcbRequired != NULL );
    DBG_ASSERT( ppvBuffer != NULL );

    *pcbRequired = 0;

    //
    // First check whether there will be room in cache for the blob 
    //

    MemCacheLock();
    
    if ( ( g_cbMemCacheSize + cbFile ) > g_cbMaxMemCacheSize ) 
    {
        // 
        // Not enough room for cache
        //
        
        MemCacheUnlock();
        *pcbRequired = DIFF(( g_cbMemCacheSize + cbFile ) - g_cbMaxMemCacheSize);
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Finished;
    }
    
    g_cbMemCacheSize += cbFile;
    g_cbMaxMemCacheUsed = max( g_cbMaxMemCacheUsed, g_cbMemCacheSize );
    g_cMemCacheElements++;
    g_cMaxMemCacheElementsUsed = max( g_cMaxMemCacheElementsUsed, g_cMemCacheElements );
    
    MemCacheUnlock();

    *pcbRequired = 0;

    //
    // Allocate blob for file
    //
    
#if defined(LOCAL_ALLOC)
    pvBuffer = LocalAlloc( LMEM_FIXED, cbFile );
#elif defined(PRIVATE_HEAP)
    DBG_ASSERT(g_hMemCacheHeap != NULL);
    pvBuffer = HeapAlloc( g_hMemCacheHeap, 0, cbFile );
#elif defined(VIRTUAL_ALLOC)
    pvBuffer = VirtualAlloc(NULL, cbFile, MEM_COMMIT, PAGE_READWRITE);
#elif defined(LOOKASIDE)
    pvBuffer = g_laMemCache->Alloc(cbFile);
#endif // LOCAL_ALLOC

    if ( pvBuffer == NULL )
    {
        MemCacheLock();
        
        g_cbMemCacheSize -= cbFile;
        
        MemCacheUnlock();

        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Finished;
    }
    
    //
    // Read file into blob
    //
    
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;
    Overlapped.hEvent = NULL;
    
    bRet = ReadFile( hFile,
                     pvBuffer,
                     cbFile,
                     &cbRead,
                     &Overlapped );

    if ( !bRet )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_IO_PENDING )
        {
            // 
            // Something bad happened
            //
            
            goto Finished;
        }
        else
        {
            //
            // Reset the error lest we confuse ourselves later on cleanup
            //
            
            dwError = ERROR_SUCCESS;
        
            //
            // Wait for async read to complete
            //
                           
            bRet = GetOverlappedResult( hFile,
                                        &Overlapped,
                                        &cbRead,
                                        TRUE );
            if ( !bRet )
            {
                //
                // Something bad happened
                //
                
                dwError = GetLastError();
                
                goto Finished;
            }
        }
    }

    //
    // Ensure that we read the number of bytes we expected to
    //
    
    if ( cbRead != cbFile )
    {
        dwError = ERROR_INVALID_DATA;
    }
    
Finished:
    
    if ( dwError != ERROR_SUCCESS )
    {
        if ( pvBuffer != NULL )
        {
#if defined(LOCAL_ALLOC)
            LocalFree( pvBuffer );
#elif defined(PRIVATE_HEAP)
            HeapFree( g_hMemCacheHeap, 0, pvBuffer );
#elif defined(VIRTUAL_ALLOC)
            VirtualFree( pvBuffer, 0, MEM_RELEASE );
#elif defined(LOOKASIDE)
            g_laMemCache->Free(pvBuffer, cbFile);
#endif // LOCAL_ALLOC

            pvBuffer = NULL;
        }
    }
    
    *ppvBuffer = pvBuffer;

    return dwError;
}

DWORD
ReleaseFromMemoryCache(
    IN VOID *                  pvBuffer,
    IN DWORD                   cbBuffer
)
/*++
Routine Description:

    Release file content blob from cache

Arguments:

    pvBuffer - Buffer to release
    cbBuffer - Size of buffer

Return Value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    DBG_ASSERT( pvBuffer );
#if defined(LOCAL_ALLOC)
    LocalFree( pvBuffer );
#elif defined(PRIVATE_HEAP)
    DBG_ASSERT(g_hMemCacheHeap != NULL);

    HeapFree( g_hMemCacheHeap, 0, pvBuffer );
#elif defined(VIRTUAL_ALLOC)
    VirtualFree( pvBuffer, 0, MEM_RELEASE );
#elif defined(LOOKASIDE)
    g_laMemCache->Free(pvBuffer, cbBuffer);
#endif // LOCAL_ALLOC
    
    MemCacheLock();
    
    g_cbMemCacheSize -= cbBuffer;
    g_cMemCacheElements--;
    
    MemCacheUnlock();
    
    return ERROR_SUCCESS;
}

DWORD
TerminateTwoLevelCache(
    VOID
)
/*++
Routine Description:

    Terminate the memory cache

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful
    ERROR_INVALID_DATA if still elements in cache 

--*/
{
    if (DisableTsunamiCaching)
        return ERROR_SUCCESS;
    
#if defined(LOCAL_ALLOC)
    // no cleanup
#elif defined(PRIVATE_HEAP)
    if (g_hMemCacheHeap != NULL)
    {
        DBG_REQUIRE( HeapDestroy( g_hMemCacheHeap ) );
        g_hMemCacheHeap = NULL;
    }
#elif defined(VIRTUAL_ALLOC)
    // no cleanup
#elif defined(LOOKASIDE)
    delete g_laMemCache;
    g_laMemCache = NULL;
#endif // LOCAL_ALLOC

    if ( g_dwMemCacheSizeCookie != 0 )
    {
        RemoveWorkItem( g_dwMemCacheSizeCookie );
        g_dwMemCacheSizeCookie = 0;
    }

    DeleteCriticalSection( &g_csMemCache );
    
    return ( g_cbMemCacheSize ) ? 
            ERROR_INVALID_DATA : ERROR_SUCCESS;
}

VOID
WINAPI
I_MemoryCacheSizeAdjustor(
    IN PVOID                pContext
)
/*++

Routine Description:

    Called to adjust the maximum size of the memory cache

Arguments:

    pContext - Context (set to NULL)

Return value:

    None    

--*/
{
    MEMORYSTATUSEX              MemoryStatus;
    MemoryStatus.dwLength = sizeof MemoryStatus;

    GlobalMemoryStatusEx( &MemoryStatus );

    MemCacheLock();

    g_cbMaxMemCacheSize = min( MemoryStatus.ullAvailPhys + g_cbMemCacheSize,
                               MemoryStatus.ullTotalVirtual ) / 2;

    MemCacheUnlock();
}

DWORD
DumpMemoryCacheToHtml(
    IN CHAR *                   pszBuffer,
    IN OUT DWORD *              pcbBuffer
)
/*++

Routine Description:

    Dump memory cache stats to buffer

Arguments:

    pszBuffer - buffer to fill
    pcbBuffer - size of buffer

Return value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    *pcbBuffer = wsprintf( pszBuffer,
        "<table>"
        "<tr><td>Current memory cache size</td><td align=right>%I64d</td></tr>"
        "<tr><td>Current memory cache limit</td><td align=right>%I64d</td></tr>"
        "<tr><td>Number of items in memory cache</td><td align=right>%d</td></tr>"
        "<tr><td>Peak memory cache size</td><td align=right>%I64d</td></tr>"
        "<tr><td>Peak memory cache element count</td><td align=right>%d</td></tr>"
        "</table>",
        g_cbMemCacheSize,
        g_cbMaxMemCacheSize,
        g_cMemCacheElements,
        g_cbMaxMemCacheUsed,
        g_cMaxMemCacheElementsUsed 
    );

    return TRUE;
    
}

VOID
QueryMemoryCacheStatistics(
    IN  INETA_CACHE_STATISTICS * pCacheCtrs,
    IN  BOOL                     fClearAll
)
/*++

Routine Description:

    Query memory cache perfmon counters

Arguments:

    pCacheCtrs - Relevant members of stat structure are filled in
    fClearAll - Clear the counters

Return value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    DBG_ASSERT( pCacheCtrs );
    
    if ( fClearAll )
    {
        pCacheCtrs->CurrentFileCacheSize = 0;
        pCacheCtrs->MaximumFileCacheSize = 0;
    }
    else
    {
        pCacheCtrs->CurrentFileCacheSize = g_cbMemCacheSize;
        pCacheCtrs->MaximumFileCacheSize = g_cbMaxMemCacheUsed;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\tlcach.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    tlcach.h

    This module declares the private interface to the two level cache

    FILE HISTORY:
        BAlam           10-31-98        Initial Revision
*/

#ifndef _TLCACH_H_
#define _TLCACH_H_

//
// Default interval between adjusting the memory cache max size
//

#define DEFAULT_ADJUSTMENT_TIME         60000

DWORD
InitializeTwoLevelCache( 
    IN DWORDLONG                cbMemoryCacheSize
);

DWORD
ReadFileIntoMemoryCache( 
    IN HANDLE                   hFile,
    IN DWORD                    cbFile,
    OUT DWORD *                 pcbRequired,
    OUT VOID **                 ppvBuffer
);

DWORD
ReleaseFromMemoryCache(
    IN VOID *                   pvBuffer,
    IN DWORD                    cbBuffer
);

DWORD
TerminateTwoLevelCache(
    VOID
);

DWORD
DumpMemoryCacheToHtml(
    IN CHAR *                   pszBuffer,
    IN OUT DWORD *              pcbBuffer
);

VOID
QueryMemoryCacheStatistics(
    IN INETA_CACHE_STATISTICS * pCacheCtrs,
    IN BOOL                     fClearAll
);


#if defined(LOOKASIDE)

class CLookAside
{
public:
    CLookAside(
        ALLOC_CACHE_CONFIGURATION* paacc,
        SIZE_T                     caacc);
    ~CLookAside();

    LPVOID
    Alloc(
        IN DWORD cbSize);

    BOOL
    Free(
        IN LPVOID pv,
        IN DWORD cbSize);

protected:
    enum {
        HEAP_PREFIX = 8,
        HEAP_SUFFIX = 0,
        ACACHE_OVERHEAD = sizeof(DWORD),
        SIGNATURE   = 'ALsT',
        SIGNATURE_X = 'XLsT',
    };

    int
    _FindAllocator(
        IN DWORD cbSize);

    DWORD                       m_dwSignature;
    ALLOC_CACHE_HANDLER**       m_apach;    // array of acaches
    ALLOC_CACHE_CONFIGURATION*  m_aacc;     // parallel array of config data
    SIZE_T                      m_cach;     // number of acaches
    SIZE_T                      m_nMinSize;
    SIZE_T                      m_nMaxSize;
};

#endif // LOOKASIDE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\tsmemp.cxx ===
#include "TsunamiP.Hxx"
#pragma hdrstop

#if DBG

PVOID DbgAllocateHeap
(
    IN PCHAR File,
    IN int   Line,
    IN ULONG Flags,
    IN ULONG Size
)
{
    PVOID pv;

    ASSERT( Flags == 0 );

    pv= IisCalloc( Size + sizeof( PCHAR ) + sizeof( PCHAR ));

    if ( pv )
    {
        *((PCHAR *)pv)=File;
        pv= (( PCHAR *)pv)+1;

        *((int *)pv)=Line;
        pv= (( PCHAR *)pv)+1;
    }

    return( pv );
}

PVOID DbgReAllocateHeap
(
    IN PCHAR File,
    IN int   Line,
    IN ULONG Flags,
    IN PVOID pvOld,
    IN ULONG Size
)
{
    PVOID pv;

    ASSERT( Flags == 0 );

    pvOld = (PVOID)( ((PCHAR)pvOld) - (sizeof( PCHAR ) + sizeof( PCHAR )) );

    pv=IisReAlloc( pvOld, Size + sizeof( PCHAR ) + sizeof( PCHAR ) );

    if ( pv )
    {
        pv = (PVOID)( ((PCHAR)pv) + sizeof( PCHAR ) + sizeof( PCHAR ) );
    }

    return( pv );
}

BOOL DbgFreeHeap
(
    IN PCHAR File,
    IN int   Line,
    IN ULONG Flags,
    IN PVOID pvOld
)
{
    ASSERT( Flags == 0 );

    pvOld = (PVOID)( ((PCHAR)pvOld) - (sizeof( PCHAR ) + sizeof( PCHAR )) );

    return IisFree( pvOld );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\authent.cxx ===
/*++







   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      authent.cxx

   Abstract:
      Authentication support functions for IIS

   Author:

       Murali R. Krishnan    ( MuraliK )     11-Dec-1996

   Environment:
       User Mode - Win32

   Project:

       Internet Server DLL

   Functions Exported:
       TCP_AUTHENT::*

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "tcpdllp.hxx"
#pragma hdrstop

#if 1 // DBCS
#include <mbstring.h>
#endif
# include "infosec.hxx"
#include "TokenAcl.hxx"
#include <softpub.h>
#include <wininet.h>
#include <wincrypt.h>

#include <iiscert.hxx>
#include <iisctl.hxx>
#include <sslinfo.hxx>

#if !defined(CRYPT_E_REVOKED)
#define CRYPT_E_REVOKED                  _HRESULT_TYPEDEF_(0x80092010L)
#endif
#if !defined(CRYPT_E_NO_REVOCATION_CHECK)
#define CRYPT_E_NO_REVOCATION_CHECK      _HRESULT_TYPEDEF_(0x80092012L)
#endif
#if !defined(CRYPT_E_REVOCATION_OFFLINE)
#define CRYPT_E_REVOCATION_OFFLINE       _HRESULT_TYPEDEF_(0x80092013L)
#endif


BOOL
IsCertificateVerified(
    PSecPkgContext_RemoteCredentialInfo pspRCI
        );
extern BOOL g_fCertCheckCA;

/************************************************************
 *    Functions
 ************************************************************/

BOOL
IsCertificateVerified(
    PSecPkgContext_RemoteCredentialInfo pspRCI
    )
{
    if ( g_fCertCheckCA )
    {
        return ((pspRCI->fFlags & RCRED_STATUS_UNKNOWN_ISSUER) == 0);
    }

    return TRUE;
}

TCP_AUTHENT::TCP_AUTHENT(
    DWORD AuthFlags
    )
/*++

Routine Description:

    Constructor for the Authentication class
Arguments:

    AuthFlags - One of the TCPAUTH_* flags.

--*/
    : _hToken          ( NULL ),
      _hSSPToken       ( NULL ),
      _hSSPPrimaryToken( NULL ),
      _fHaveCredHandle ( FALSE ),
      _fHaveCtxtHandle ( FALSE ),
      _fClient         ( FALSE ),
      _fUUEncodeData   ( FALSE ),
      _pDeleteFunction ( NULL ),
      _fBase64         ( FALSE ),
      _fKnownToBeGuest ( FALSE ),
      _pClientCertContext( NULL ),
      _pSslInfo            ( NULL ),
      _pServerX509Certificate( NULL ),
      _fCertCheckForRevocation( TRUE ),
      _fCertCheckCacheOnly( FALSE )
{
    if ( AuthFlags & TCPAUTH_SERVER )
    {
        DBG_ASSERT( !(AuthFlags & TCPAUTH_CLIENT));
    }

    if ( AuthFlags & TCPAUTH_CLIENT )
    {
        _fClient = TRUE;
    }

    if ( AuthFlags & TCPAUTH_UUENCODE )
    {
        _fUUEncodeData = TRUE;
    }

    if ( AuthFlags & TCPAUTH_BASE64 )
    {
        _fBase64 = TRUE;
    }

    DBG_REQUIRE( Reset( TRUE ) );
}

/*******************************************************************/

TCP_AUTHENT::~TCP_AUTHENT(
    )
/*++

Routine Description:

    Destructor for the Authentication class

--*/
{
    Reset( TRUE );
}


BOOL
TCP_AUTHENT::DeleteCachedTokenOnReset(
    VOID
    )
{
    if ( _hToken != NULL )
    {
        CACHED_TOKEN *pct = (CACHED_TOKEN*)_hToken;
        DBG_ASSERT( _fClearText );
        RemoveTokenFromCache( pct);
    }

    return TRUE;
}


BOOL
TCP_AUTHENT::Reset(
    BOOL fSessionReset
    )
/*++

Routine Description:

    Resets this object in preparation for a brand new conversation

--*/
{
    if ( _hToken != NULL )
    {
        DBG_ASSERT( _fClearText );
        TsDeleteUserToken( _hToken );

        _hToken = NULL;
    }

    if ( _hSSPToken )
    {
        ////if ( !_pDeleteFunction )
        {
            CloseHandle( _hSSPToken );
        }

        //
        //  Don't delete the SSPI Token as we queried it directly from SSPI
        //

        _hSSPToken = NULL;
    }

    //
    //  We close this token because we duplicated it from _hSSPToken
    //

    if ( _hSSPPrimaryToken )
    {
        CloseHandle( _hSSPPrimaryToken );
        _hSSPPrimaryToken = NULL;
    }

    if ( _pDeleteFunction )
    {
        (_pDeleteFunction)( &_hctxt, _pDeleteArg );
        _pDeleteFunction = NULL;
        _fHaveCtxtHandle = FALSE;
        _fHaveCredHandle = FALSE;
    }
    else
    {
        if ( _fHaveCtxtHandle )
        {
            pfnDeleteSecurityContext( &_hctxt );
            _fHaveCtxtHandle = FALSE;
        }

        if ( _fHaveCredHandle )
        {
            pfnFreeCredentialsHandle( &_hcred );
            _fHaveCredHandle = FALSE;
        }
    }

    if ( fSessionReset )
    {
        if ( _pClientCertContext )
        {
            (pfnFreeCertCtxt)( _pClientCertContext );
            _pClientCertContext = NULL;
        }
        if ( _pServerX509Certificate )
        {
            (fnFreeCert)( _pServerX509Certificate );
            _pServerX509Certificate = NULL;
        }
        _phSslCtxt        = NULL;
        _fCertCheckForRevocation = TRUE;
        _fCertCheckCacheOnly = FALSE;

        if ( _pSslInfo )
        {
            IIS_SSL_INFO::Release( _pSslInfo );

            _pSslInfo = NULL;
        }
    }

    _fNewConversation = TRUE;
    _fClearText       = FALSE;
    _fHaveAccessTokens= FALSE;
    _cbMaxToken       = 0;
    _fDelegate        = FALSE;

    _pDeleteArg       = NULL;
    _fKnownToBeGuest  = FALSE;
    _fHaveExpiry      = FALSE;

    return TRUE;
}

/*******************************************************************/


BOOL
TCP_AUTHENT::SetSecurityContextToken(
    CtxtHandle* pCtxt,
    HANDLE hPrimaryToken,
    SECURITY_CONTEXT_DELETE_FUNCTION pFn,
    PVOID pArg,
    IIS_SSL_INFO *pSslInfo
    )
/*++

Routine Description:

    Store security context & impersonation token

Arguments:

    pCtxt - SSPI security context
    hPrimaryToken - access token associated with security context
    pFn - function to call to notify security context destruction
    pArg - argument for pFn call
    pSslInfo - pointer to SSL info object to be used for this security context

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( hPrimaryToken != NULL )
    {
        if ( _hSSPToken )
        {
            CloseHandle( _hSSPToken );
            _hSSPToken = NULL;
        }

        if ( _hSSPPrimaryToken )
        {
            CloseHandle( _hSSPPrimaryToken );
            _hSSPPrimaryToken = NULL;
        }

        AdjustTokenPrivileges( hPrimaryToken, TRUE, NULL, NULL, NULL, NULL );
        if ( g_pTokPrev )
        {
            AdjustTokenPrivileges( hPrimaryToken,
                                   FALSE,
                                   g_pTokPrev,
                                   NULL,
                                   NULL,
                                   NULL );
        }

        //
        //  We need to convert the NTLM primary token into a
        //  impersonation token
        //

        if ( !pfnDuplicateTokenEx( hPrimaryToken,
                                TOKEN_ALL_ACCESS,
                                NULL,
                                SecurityImpersonation,
                                TokenImpersonation,
                                &_hSSPToken ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[SetSecurityContextToken] DuplicateToken failed, error %lx\n",
                        GetLastError() ));

            return FALSE;
        }

        // Bug 86498:
        // Grant all access to the token for "Everyone" so that ISAPIs that run out of proc
        // can do an OpenThreadToken call
        HRESULT hr;
        if (FAILED( hr = GrantAllAccessToToken( _hSSPToken ) ) )
        {
            DBG_ASSERT( FALSE );
            DBGPRINTF(( DBG_CONTEXT,
                        "[SetSecurityContextToken] Failed to grant access to the token to everyone, error %lx\n",
                        hr ));
            return FALSE;
        }

        _hSSPPrimaryToken = hPrimaryToken;

        _hctxt = *pCtxt;
        _fHaveCtxtHandle = TRUE;
        _pDeleteFunction = pFn;
        _pDeleteArg = pArg;
    }

    _phSslCtxt = pCtxt;

    if ( _pSslInfo )
    {
        IIS_SSL_INFO::Release( _pSslInfo );
    }
    _pSslInfo = pSslInfo;

    return TRUE;
}


BOOL
TCP_AUTHENT::IsForwardable(
    VOID
    ) const
/*++

Routine Description:

    returns TRUE if auth info is forwardable ( e.g. kerberos )

Arguments:

    None

Return Value:

    TRUE if forwardable, otherwise FALSE

--*/
{
    return _fDelegate;
}


BOOL
TCP_AUTHENT::IsSslCertPresent(
    )
/*++

Routine Description:

    Check if SSL cert bound on this security context

Arguments:

    None

Return Value:

    TRUE if SSL cert present, otherwise FALSE

--*/
{
    return _phSslCtxt != NULL;
}


static BOOL IsValidKeyUsageForClientCert(
    PCCERT_CONTEXT pCliCert
    )
/*++

Routine Description:

    private routine checkin extended key usage validity for client certificate

Arguments:

    pCliCert - client certificate to be verified

Return Value:

    TRUE if client cert usage is valid, otherwise FALSE
    in the case of any error FALSE is returned and GetLastError() can be used to 
    retrieve the error code

--*/

{
    HRESULT                     hr = S_OK;
    BOOL                        fRet = TRUE;
    DWORD                       dwRet = ERROR_SUCCESS;
    const DWORD                 cbDefaultEnhKeyUsage = 100;
    STACK_BUFFER(               buffEnhKeyUsage, cbDefaultEnhKeyUsage );
    PCERT_ENHKEY_USAGE          pCertEnhKeyUsage = NULL;
    DWORD                       cbEnhKeyUsage = cbDefaultEnhKeyUsage;
    BOOL                        fEnablesClientAuth = FALSE;

    //
    // Now verify extended usage flags (only for the end certificate)
    //

    fRet = CertGetEnhancedKeyUsage( pCliCert,
                                    0,             //dwFlags,
                                    (PCERT_ENHKEY_USAGE) buffEnhKeyUsage.QueryPtr(),
                                    &cbEnhKeyUsage );
    dwRet = GetLastError();
                                    
    if ( !fRet && ( dwRet == ERROR_MORE_DATA ) )
    {
        //
        // Resize buffer
        //
        if ( !buffEnhKeyUsage.Resize( cbEnhKeyUsage ) ) 
        {
            dwRet = GetLastError();
            goto ExitPoint;
        }
        fRet = CertGetEnhancedKeyUsage( pCliCert,
                                        0,             //dwFlags,
                                        (PCERT_ENHKEY_USAGE) buffEnhKeyUsage.QueryPtr(),
                                        &cbEnhKeyUsage );
        dwRet = GetLastError();
    }
    if ( !fRet )
    {
        //
        // Bad.  Couldn't get the Enhanced Key Usage
        //
        
        goto ExitPoint;
    } 

    pCertEnhKeyUsage = (PCERT_ENHKEY_USAGE) buffEnhKeyUsage.QueryPtr();

    //
    // If the cUsageIdentifier member is zero (0), the certificate might be valid 
    // for all uses or the certificate it might have no valid uses. The return from 
    // a call to GetLastError can be used to determine whether the certificate is 
    // good for all uses or for no uses. If GetLastError returns CRYPT_E_NOT_FOUND 
    // if the certificate is good for all uses. If it returns zero (0), the 
    // certificate has no valid uses 
    //
    
    if ( pCertEnhKeyUsage->cUsageIdentifier == 0 )
    {
        if ( dwRet == CRYPT_E_NOT_FOUND )
        {
            //
            // Certificate valid for any use
            //
            fEnablesClientAuth = TRUE; 
        }
        else
        {
            //
            // Certificate NOT valid for any use
            //
        }
    }
    else
    {
        //
        // Find out if pCertEnhKeyUsage enables CLIENT_AUTH
        //
        for ( DWORD i = 0; i < pCertEnhKeyUsage->cUsageIdentifier; i++ )
        {
            DBG_ASSERT( pCertEnhKeyUsage->rgpszUsageIdentifier[i] != NULL );

            if ( strcmp( pCertEnhKeyUsage->rgpszUsageIdentifier[i], szOID_PKIX_KP_CLIENT_AUTH ) == 0 )
            {
                //
                // certificate enables CLIENT_AUTH
                //
                fEnablesClientAuth = TRUE; 
                break;
            }
        }
    }

    //
    // If ExtendedKeyUsage doesn't enable CLIENT_AUTH then add flag to CertFlags
    //
ExitPoint:    
    return fEnablesClientAuth;
}


BOOL
TCP_AUTHENT::QueryCertificateInfo(
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate information from SSL security context

Arguments:

    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SECURITY_STATUS                    ss;
    CERT_REVOCATION_STATUS             CertRevocationStatus;
    SecPkgContext_RemoteCredentialInfo spRCI;
    HCERTCHAINENGINE hEngine = NULL;
    PCCERT_CHAIN_CONTEXT pCertChain = NULL;

    if ( _pClientCertContext != NULL )
    {
        *pfNoCert = FALSE;
        return TRUE;
    }

    //
    // NULL handle <==> no certificate
    //

    if ( _phSslCtxt == NULL || pfnFreeCertCtxt == NULL )
    {
        goto LNoCertificate;
    }

    //
    // Win95 <==> no certificate
    // NOTE Currently security.dll is not supported in Win95.
    //

    if ( TsIsWindows95() )
    {
        goto LNoCertificate;
    }

    //
    // get cert context - if null, we have no certificate
    //

    DBG_ASSERT( RtlValidateProcessHeaps() );

    ss = (pfnQueryContextAttributes)( _phSslCtxt,
                                      SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                      &_pClientCertContext );


    DBG_ASSERT( RtlValidateProcessHeaps() );

    if ( ss || _pClientCertContext == NULL ) {

        goto LNoCertificate;
    }

    
    //
    // Try to verify the client certificate
    //

#if DBG
    CHAR szSubjectName[1024];
    if ( CertGetNameString( _pClientCertContext,
                            CERT_NAME_SIMPLE_DISPLAY_TYPE,
                            0,
                            NULL,
                            szSubjectName,
                            1024 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Verifying client cert for %s \n", 
                   szSubjectName));
    }

    if ( CertGetNameString( _pClientCertContext,
                            CERT_NAME_SIMPLE_DISPLAY_TYPE,
                            CERT_NAME_ISSUER_FLAG,
                            NULL,
                            szSubjectName,
                            1024 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Client cert issued by %s \n", 
                   szSubjectName));
    }
#endif

    _dwX509Flags = RCRED_CRED_EXISTS;

    if ( _pSslInfo && _pSslInfo->GetCertChainEngine( &hEngine ) )
    {
        //
        // Don't set any usage bits, because there are probably lots of certs floating
        // around out there with no usage bits and we don't want to break them
        // 
        // CODEWORK : might want to consider adding eg MB flag that allows setting of
        // required usage bits on certs
        //
        DWORD dwRevocationFlags = 0;
        DWORD dwCacheFlags = 0;
        CERT_CHAIN_PARA CCP;
        memset( &CCP, 0, sizeof( CCP ) );
        CCP.cbSize = sizeof(CCP);

        DBG_ASSERT( RtlValidateProcessHeaps() );

        //
        // Determine the CertGetCertificateChain() flags related to revocation
        // checking and cache retrieval 
        //
        
        dwRevocationFlags = ( _fCertCheckForRevocation 
                              || g_fCertCheckForRevocation ) 
                              ? CERT_CHAIN_REVOCATION_CHECK_CHAIN : 0;

        dwCacheFlags = _fCertCheckCacheOnly 
                       ? CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY : 0;

        if ( CertGetCertificateChain( hEngine,
                                      _pClientCertContext, 
                                      NULL,
                                      _pClientCertContext->hCertStore,
                                      &CCP,
                                      dwRevocationFlags | dwCacheFlags,
                                      NULL,
                                      &pCertChain ) )
        {
            //
            // Got a chain, look at the status bits and see whether we like it
            //
            DWORD dwChainStatus = pCertChain->TrustStatus.dwErrorStatus;

            if ( ( dwChainStatus & CERT_TRUST_IS_NOT_TIME_VALID ) ||
                 ( dwChainStatus & CERT_TRUST_CTL_IS_NOT_TIME_VALID ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Cert/CTL is not time-valid\n"));

                _dwX509Flags |= CRED_STATUS_INVALID_TIME;
            }


            if ( ( dwChainStatus & CERT_TRUST_IS_UNTRUSTED_ROOT ) ||
                 ( dwChainStatus & CERT_TRUST_IS_PARTIAL_CHAIN ) )
            {
                //
                // If we sign our CTLs, then we should be able to construct a complete
                // chain up to a trusted root for valid client certs, so we just look at 
                // the status bits of the chain.
                //
                // If our CTLs are not signed, we have to manually check whether the cert at the
                // top of the chain is in our CTL
                //

#if SIGNED_CTL
                DBGPRINTF((DBG_CONTEXT,
                           "Cert doesn't chain up to a trusted root\n"));

                _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;

#else //SIGNED_CTL

                PCERT_SIMPLE_CHAIN pSimpleChain = pCertChain->rgpChain[pCertChain->cChain - 1];

                PCERT_CHAIN_ELEMENT pChainElement = 
                    pSimpleChain->rgpElement[pSimpleChain->cElement - 1];

                PCCERT_CONTEXT pChainTop = pChainElement->pCertContext;

                BOOL fContains = FALSE;

                if ( !_pSslInfo->CTLContainsCert( pChainTop,
                                                  &fContains ) ||
                     !fContains )
                {
                    _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
                }
#endif //SIGNED_CTL
            }

            if ( ( dwChainStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) || 
                 ( dwChainStatus & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID ) ||
                 ( !IsValidKeyUsageForClientCert(_pClientCertContext) ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Cert/CTL is not signature valid\n"));
                //
                // if the signature has been tampered with, we'll just treat it
                // as an unknown issuer
                //
                _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
            }

            if ( dwChainStatus & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "CTL isn't valid for usage\n"));
            }

            //
            // If we were supposed to check for revocation and we couldn't do so,
            // treat it as if it were revoked ... ? 
            //
            
            if ( _fCertCheckForRevocation || g_fCertCheckForRevocation )
            {
                BOOL                fRevoke = FALSE;
                
                if ( dwChainStatus & CERT_TRUST_IS_REVOKED )
                {
                    fRevoke = TRUE;
                }
                else if ( dwChainStatus & CERT_TRUST_REVOCATION_STATUS_UNKNOWN )
                {
                    PCERT_SIMPLE_CHAIN      pSimpleChain;
                    PCERT_CHAIN_ELEMENT     pChainElement;
                    PCERT_REVOCATION_INFO   pRevocationInfo;
                    DWORD                   dwCounter;
                    
                    pSimpleChain = pCertChain->rgpChain[ 0 ];
                    
                    for ( dwCounter = 0;
                          dwCounter < pSimpleChain->cElement;
                          dwCounter++ )
                    {
                        pChainElement = pSimpleChain->rgpElement[ dwCounter ];
                        pRevocationInfo = pChainElement->pRevocationInfo;

                        if ( pRevocationInfo &&
                             ( ( pRevocationInfo->dwRevocationResult == CRYPT_E_REVOKED ) ||
                             ( pRevocationInfo->dwRevocationResult != CRYPT_E_NO_REVOCATION_CHECK ) ) )
                        {
                            fRevoke = TRUE;
                            break;
                        }
                    }
                }
            
                if ( fRevoke )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "'Certificate revoked' or 'CRL needed but not found'\n" ));
                    
                    _dwX509Flags |= CRED_STATUS_REVOKED;
                }
            }

            CERT_CHAIN_POLICY_STATUS ChainPolicyStatus = {0};
            ChainPolicyStatus.cbSize = sizeof(ChainPolicyStatus);

            if ( CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_BASIC_CONSTRAINTS, 
                pCertChain, NULL, &ChainPolicyStatus) )
            {
                if ( ChainPolicyStatus.dwError != NOERROR )
                    _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
            }
            else
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Couldn't verify certificate chain basic constraints : 0x%d\n",
                           GetLastError()));

                _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
            }
                 
            CertFreeCertificateChain( pCertChain );
            pCertChain = NULL;
        }
        else
        {
            //
            // We don't know anything about the client cert, so treat it as being
            // issued by an unknown CA
            //
            DBGPRINTF((DBG_CONTEXT,
                       "Couldn't get certificate chain : 0x%d\n",
                       GetLastError()));

            _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
        }
    }
    else
    {
        //
        // We don't know anything about the client cert, so treat it as being issued by
        // an unknown CA
        //

        DBGPRINTF((DBG_CONTEXT,
                   "Can't check anything about the client cert\n"));

        _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
    }

    DBG_ASSERT( RtlValidateProcessHeaps() );

    *pfNoCert = FALSE;

    return TRUE;

LNoCertificate:

    *pfNoCert = TRUE;
    return FALSE;
}



BOOL
TCP_AUTHENT::QueryServerCertificateInfo(
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get servercertificate information from SSL security context

Arguments:

    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SECURITY_STATUS                     ss;
    _SecPkgContext_LocalCredentialInfo  spcRCI;

    if ( _pServerX509Certificate == NULL )
    {
        if ( _phSslCtxt == NULL
             || fnCrackCert == NULL
             || fnFreeCert == NULL )
        {
            *pfNoCert = TRUE;
            return FALSE;
        }

        ss = pfnQueryContextAttributes( _phSslCtxt,
                                     SECPKG_ATTR_LOCAL_CRED,
                                     &spcRCI );

        if ( ss != STATUS_SUCCESS || !spcRCI.cCertificates )
        {
            *pfNoCert = FALSE;
            SetLastError( ss );
            return FALSE;
        }

        if ( !(fnCrackCert)( spcRCI.pbCertificateChain,
                             spcRCI.cbCertificateChain,
                             0,
                             &_pServerX509Certificate ) )
        {
            pfnFreeContextBuffer(spcRCI.pbCertificateChain);

            *pfNoCert = FALSE;
            return FALSE;
        }
        _dwServerX509Flags = spcRCI.fFlags;
        _dwServerBitsInKey = spcRCI.dwBits;

        pfnFreeContextBuffer(spcRCI.pbCertificateChain);
    }

    return TRUE;
}


BOOL
TCP_AUTHENT::QueryEncryptionKeySize(
    LPDWORD pdw,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get encryption session key size

Arguments:

    pdw - updated with number of bits in key size
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SecPkgContext_KeyInfo   ski;
    SECURITY_STATUS         ss;

    if ( _phSslCtxt == NULL )
    {
        *pfNoCert = TRUE;
        return FALSE;
    }

    ss = pfnQueryContextAttributes( _phSslCtxt,
                                 SECPKG_ATTR_KEY_INFO,
                                 &ski );

    if ( ss != STATUS_SUCCESS )
    {
        SetLastError( ss );
        *pfNoCert = FALSE;

        return FALSE;
    }

    *pdw = ski.KeySize;
    
    if ( ski.sSignatureAlgorithmName )
    {
        pfnFreeContextBuffer( ski.sSignatureAlgorithmName );
    }
    
    if ( ski.sEncryptAlgorithmName )
    {
        pfnFreeContextBuffer( ski.sEncryptAlgorithmName );
    }

    return TRUE;
}


BOOL
TCP_AUTHENT::QueryEncryptionServerPrivateKeySize(
    LPDWORD pdw,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get encryption server private key size

Arguments:

    pdw - updated with number of bits in key size
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryServerCertificateInfo( pfNoCert ) )
    {
        *pdw = _dwServerBitsInKey;

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryServerCertificateIssuer(
    LPSTR* ppIssuer,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get server certificate Issuer information from SSL security context

Arguments:

    ppIssuer - updated with ptr to Issuer name
               guaranteed to remain valid until auth Reset()
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryServerCertificateInfo( pfNoCert ) )
    {
        *ppIssuer = _pServerX509Certificate->pszIssuer;

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryServerCertificateSubject(
    LPSTR* ppSubject,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get server certificate Subject information from SSL security context

Arguments:

    ppSubject - updated with ptr to Subject name
               guaranteed to remain valid until auth Reset()
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryServerCertificateInfo( pfNoCert ) )
    {
        *ppSubject = _pServerX509Certificate->pszSubject;

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryCertificateIssuer(
    LPSTR   pIssuer,
    DWORD   dwIssuerMaxLen,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate Issuer information from SSL security context

Arguments:

    pIssuer - ptr to buffer filled with Issuer name
    dwIssuerMaxLen - size of pIssuer
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryCertificateInfo( pfNoCert) && pfnCertNameToStrA )
    {
        pfnCertNameToStrA( _pClientCertContext->dwCertEncodingType,
                           &_pClientCertContext->pCertInfo->Issuer,
                           CERT_X500_NAME_STR,
                           pIssuer,
                           dwIssuerMaxLen );

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryCertificateFlags(
    LPDWORD pdwFlags,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate flags information from SSL security context

Arguments:

    pdwFlags - updated with certificate flags
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryCertificateInfo( pfNoCert ) )
    {
        *pdwFlags = _dwX509Flags;

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryCertificateSubject(
    LPSTR   pSubject,
    DWORD   dwSubjectMaxLen,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate Subject information from SSL security context

Arguments:

    ppSubject - updated with ptr to Subject name
                guaranteed to remain valid until auth Reset()
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryCertificateInfo( pfNoCert) && pfnCertNameToStrA )
    {
        pfnCertNameToStrA( _pClientCertContext->dwCertEncodingType,
                           &_pClientCertContext->pCertInfo->Subject,
                           CERT_X500_NAME_STR,
                           pSubject,
                           dwSubjectMaxLen );

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryCertificateSerialNumber(
    LPBYTE* ppSerialNumber,
    LPDWORD pdwLen,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate serial number information from SSL security context

Arguments:

    ppSerialNumber - updated with ptr to serial number as
                     array of bytes
                     guaranteed to remain valid until auth Reset()
    pdwLen - length of serial number
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryCertificateInfo( pfNoCert ) )
    {
        *ppSerialNumber = _pClientCertContext->pCertInfo->SerialNumber.pbData;

        *pdwLen = _pClientCertContext->pCertInfo->SerialNumber.cbData;

        return TRUE;
    }

    return FALSE;
}


HANDLE
TCP_AUTHENT::QueryPrimaryToken(
    VOID
    )
/*++

Routine Description:

    Returns a non-impersonated token suitable for use with CreateProcessAsUser

--*/
{
    SECURITY_STATUS sc;

    if ( _hToken && _fClearText )
    {
        return CTO_TO_TOKEN( _hToken );
    }
    else if ( _fHaveAccessTokens )
    {
        return _hSSPPrimaryToken;
    }
    else if ( _fHaveCtxtHandle )
    {
        if ( !_hSSPPrimaryToken )
        {
            if ( !_hSSPToken )
            {
                sc = pfnQuerySecurityContextToken( &_hctxt,
                                                &_hSSPToken );

                if ( !NT_SUCCESS( sc ))
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "[QueryPrimaryToken] QuerySecurityContext failed, error 0x%lx\n",
                                sc ));

                    SetLastError( sc );

                    return NULL;
                }

                // Bug 86498:
                // Grant all access to the token for "Everyone" so that ISAPIs that run out of proc
                // can do an OpenThreadToken call
                HRESULT hr;
                if (FAILED( hr = GrantAllAccessToToken( _hSSPToken ) ) )
                {
                    DBG_ASSERT( FALSE );
                    DBGPRINTF(( DBG_CONTEXT,
                                "[QueryPrimaryToken] Failed to grant access to the token to everyone, error %lx\n",
                                hr ));
                    return FALSE;
                }

                AdjustTokenPrivileges( _hSSPToken, TRUE, NULL, NULL, NULL, NULL );
                if ( g_pTokPrev )
                {
                    AdjustTokenPrivileges( _hSSPToken,
                                           FALSE,
                                           g_pTokPrev,
                                           NULL,
                                           NULL,
                                           NULL );
                }
            }

            //
            //  We need to convert the NTLM impersonation token into a
            //  primary token
            //

            if ( !pfnDuplicateTokenEx( _hSSPToken,
                                    TOKEN_ALL_ACCESS,
                                    NULL,
                                    SecurityImpersonation,
                                    TokenPrimary,
                                    &_hSSPPrimaryToken ))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[QueryPrimaryToken] DuplicateToken failed, error %lx\n",
                            GetLastError() ));
            }
        }

        return _hSSPPrimaryToken;
    }

    SetLastError( ERROR_INVALID_HANDLE );
    return NULL;
}

HANDLE
TCP_AUTHENT::QueryImpersonationToken(
    VOID
    )
/*++

Routine Description:

    Returns an impersonation token for use with APIs like AccessCheck.

--*/
{
    SECURITY_STATUS sc;

    if ( _hToken == (TS_TOKEN)BOGUS_WIN95_TOKEN ) {
        return((HANDLE)BOGUS_WIN95_TOKEN);
    }

    if ( _hToken && _fClearText )
    {
        return ((CACHED_TOKEN *) _hToken)->QueryImpersonationToken();
    }
    else if ( _fHaveAccessTokens )
    {
        return _hSSPToken;
    }
    else if ( _fHaveCtxtHandle )
    {
        //
        //  We don't need to impersonate since this is already an impersonation
        //  token
        //

        if ( !_hSSPToken )
        {
            sc = pfnQuerySecurityContextToken( &_hctxt,
                                            &_hSSPToken );

            if ( !NT_SUCCESS( sc ))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[QueryImpersonationToken] QuerySecurityContext failed, error 0x%lx\n",
                            sc ));

                SetLastError( sc );

                return NULL;
            }

            // Bug 86498:
            // Grant all access to the token for "Everyone" so that ISAPIs that run out of proc
            // can do an OpenThreadToken call
            HRESULT hr;
            if (FAILED( hr = GrantAllAccessToToken( _hSSPToken ) ) )
            {
                DBG_ASSERT( FALSE );
                DBGPRINTF(( DBG_CONTEXT,
                            "[QueryImpersonationToken] Failed to grant access to the token to everyone, error %lx\n",
                            hr ));
                return NULL;
            }

            AdjustTokenPrivileges( _hSSPToken, TRUE, NULL, NULL, NULL, NULL );
            if ( g_pTokPrev )
            {
                AdjustTokenPrivileges( _hSSPToken,
                                       FALSE,
                                       g_pTokPrev,
                                       NULL,
                                       NULL,
                                       NULL );
            }
        }

        return _hSSPToken;
    }

    SetLastError( ERROR_INVALID_HANDLE );
    return NULL;
}


BOOL
TCP_AUTHENT::IsGuest(
    BOOL fIsImpersonated
    )
/*++

Routine Description:

    Returns TRUE if the account is the guest account

--*/
{
    fIsImpersonated;    // Unreferenced variable

    if ( _fHaveCtxtHandle )
    {
        return _fKnownToBeGuest;
    }

    return IsGuestUser( GetUserHandle() );
}

BOOL TCP_AUTHENT::EnumAuthPackages(
    BUFFER * pBuff
    )
/*++

Routine Description:

    Places a double null terminated list of authentication packages on the
    system in pBuff that looks like:

    NTLM\0
    MSKerberos\0
    Netware\0
    \0

Arguments:

    pBuff       - Buffer to receive list

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{

    SECURITY_STATUS   ss;
    PSecPkgInfo       pPackageInfo = NULL;
    ULONG             cPackages;
    ULONG             i;
    ULONG             fCaps;
    DWORD             cbBuffNew = 0;
    DWORD             cbBuffOld = 0;


    if ( !pBuff->Resize( 64 ) )
        return FALSE;

    //
    //  Get the list of security packages on this machine
    //

    ss = pfnEnumerateSecurityPackages( &cPackages,
                                    &pPackageInfo );

    if ( ss != STATUS_SUCCESS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[EnumAuthPackages] Failed with error %d\n",
                    ss ));

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  We'll only use the security package if it supports connection
        //  oriented security and it supports the appropriate side (client
        //  or server)
        //

        fCaps = pPackageInfo[i].fCapabilities;

        if ( fCaps & SECPKG_FLAG_CONNECTION )
        {
            if ( (fCaps & SECPKG_FLAG_CLIENT_ONLY) && !_fClient )
                continue;

            cbBuffNew += strlen( pPackageInfo[i].Name ) + 1;

            if ( pBuff->QuerySize() < cbBuffNew )
            {
                if ( !pBuff->Resize( cbBuffNew + 64 ))
                {
                    pfnFreeContextBuffer( pPackageInfo );
                    return FALSE;
                }
            }

            strcpy( (CHAR *)pBuff->QueryPtr() + cbBuffOld,
                    pPackageInfo[i].Name );

            cbBuffOld = cbBuffNew;
        }
    }

    *((CHAR *)pBuff->QueryPtr() + cbBuffOld) = '\0';

    pfnFreeContextBuffer( pPackageInfo );

    return TRUE;

} // EnumAuthPackages


BOOL
TCP_AUTHENT::QueryExpiry(
    PTimeStamp pExpiry
    )
/*++

Routine Description:

    Queries the expiration date/time for a SSPI logon

Arguments:

    pExpiry - ptr to buffer to update with expiration date

Return Value:

    TRUE if successful, FALSE if not available

--*/
{
    SECURITY_STATUS                ss;
    SecPkgContext_PasswordExpiry   speExpiry;

    if ( _fHaveCtxtHandle && !_pDeleteFunction )
    {
        ss = pfnQueryContextAttributes( &_hctxt,
                                     SECPKG_ATTR_PASSWORD_EXPIRY,
                                     &speExpiry );

        if ( ss != STATUS_SUCCESS )
        {
            ((LARGE_INTEGER*)pExpiry)->HighPart = 0x7fffffff;
            ((LARGE_INTEGER*)pExpiry)->LowPart = 0xffffffff;
            SetLastError( ss );
            return FALSE;
        }

        memcpy( pExpiry,
                &speExpiry.tsPasswordExpires,
                sizeof(speExpiry.tsPasswordExpires) );

        return TRUE;
    }
    else if ( _fHaveExpiry )
    {
        memcpy( pExpiry, (LPVOID)&_liPwdExpiry, sizeof(_liPwdExpiry) );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
TCP_AUTHENT::QueryFullyQualifiedUserName(
    LPSTR                   pszUser,
    STR *                   pstrU,
    PIIS_SERVER_INSTANCE    psi,
    PTCP_AUTHENT_INFO       pTAI
    )
/*++

Routine Description:

    Get fully qualified user name ( domain \ user name )

Arguments:

    pszUser - user name ( prefixed by optional domain )
    strU - string updated with fully qualified name
    psi - server instance data

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    CHAR        szDomainAndUser[IIS_DNLEN+UNLEN+2];

    //
    //  Empty user defaults to the anonymous user
    //

    if ( !pszUser || *pszUser == '\0' )
    {
        return FALSE;
    }

    //
    //  Validate parameters & state.
    //
    
    if ( strlen( pszUser ) >= sizeof( szDomainAndUser ) )
    {   
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    //
    //  Save a copy of the domain\user so we can squirrel around
    //  with it a bit.
    //

    int cL = 0;

    //
    // prepend default logon domain if no domain
    // and the default user name was not used
    //

    if ( strchr( pszUser, '/' ) == NULL
#if 1 // DBCS enabling for user name
         && _mbschr( (PUCHAR)pszUser, '\\' ) == NULL )
#else
         && strchr( pszUser, '\\' ) == NULL )
#endif
    {
        psi->LockThisForRead();
        PCSTR pD = pTAI->strDefaultLogonDomain.QueryStr();
        PCSTR pL;
        if ( pD != NULL && pD[0] != '\0' )
        {
#if 1 // DBCS enabling for user name
            if ( ( pL = (PCHAR)_mbschr( (PUCHAR)pD, '\\' ) ) )
#else
            if ( ( pL = strchr( pD, '\\' ) ) )
#endif
            {
                cL = DIFF(pL - pD);
            }
            else
            {
                cL = strlen( pD );
            }
            memcpy( szDomainAndUser, pD, cL );
            szDomainAndUser[ cL++ ] = '\\';
        }
        else
        {
            DWORD dwL = DNLEN + 1;
            if ( GetComputerName( szDomainAndUser, &dwL ) )
            {
                cL = dwL;
                szDomainAndUser[ cL++ ] = '\\';
            }
        }
        psi->UnlockThis();
    }

    strcpy( szDomainAndUser + cL, pszUser );

    return pstrU->Copy( (TCHAR*)szDomainAndUser );
}


BOOL
TCP_AUTHENT::QueryUserName(
    STR * pBuff,
    BOOL fImpersonated
    )
/*++

Routine Description:

    Queries the name associated with this *authenticated* object

Arguments:

    pBuff       - Buffer to receive name

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    SECURITY_STATUS     ss;
    DWORD               cbName;
    SecPkgContext_Names CredNames;
    UINT                l;

    if ( _pDeleteFunction )
    {
        //
        // this context is bound to a SSL/PCT client certificate
        // SECPKG_ATTR_NAMES returns certificate info in this case,
        // 1st try SECPKG_ATTR_MAPNAMES. If fails, use GetUserName()
        //

#if defined(SECPKG_ATTR_MAPNAMES)

        if ( _fHaveCtxtHandle )
        {
            ss = pfnQueryContextAttributes( &_hctxt,
                                         SECPKG_ATTR_MAPNAMES,
                                         &CredNames );

            if ( ss == STATUS_SUCCESS )
            {
                cbName = strlen( CredNames.sUserName ) + 1;
    
                if ( !pBuff->Resize( cbName ))
                {
                    LocalFree( CredNames.sUserName );
                    return FALSE;
                }

                memcpy( pBuff->QueryPtr(), CredNames.sUserName, cbName );

                pBuff->SetLen( cbName - 1 );

                LocalFree( CredNames.sUserName );

                return TRUE;
            }
        }
#endif
        if ( !fImpersonated && !Impersonate() )
        {
            return FALSE;
        }
        DWORD cL = pBuff->QuerySize();
        BOOL fSt = TRUE;
        if ( !GetUserName( (LPTSTR)pBuff->QueryPtr(), &cL ) )
        {
            if ( fSt = pBuff->Resize( cL ) )
            {
                fSt = GetUserName( (LPTSTR)pBuff->QueryPtr(), &cL );
            }
        }

        //
        // Add domain name if not present
        //

#if 1 // DBCS enabling for user name
        if ( fSt && _mbschr( (PUCHAR)pBuff->QueryPtr(), '\\') == NULL )
#else
        if ( fSt && strchr( (LPSTR)pBuff->QueryPtr(), '\\') == NULL )
#endif
        {
            cL = strlen(g_achComputerName);
            if ( pBuff->Resize( l=(cL+1+strlen((LPSTR)pBuff->QueryPtr()))+1 ) )
            {
                memmove( (LPBYTE)pBuff->QueryPtr()+cL+1,
                         pBuff->QueryPtr(),
                         strlen((LPSTR)pBuff->QueryPtr())+sizeof(CHAR) );
                memcpy( pBuff->QueryPtr(), g_achComputerName, cL );
                ((LPBYTE)pBuff->QueryPtr())[cL] = '\\';
                pBuff->SetLen( l );
            }
        }

        if ( !fImpersonated )
        {
            RevertToSelf();
        }

        return fSt;
    }
    else 
    {
        if ( _fHaveCtxtHandle )
        {
            ss = pfnQueryContextAttributes( &_hctxt,
                                         SECPKG_ATTR_NAMES,
                                         &CredNames );
        }
        else
        {
            ss = ERROR_INVALID_HANDLE;
        }

        if ( ss != STATUS_SUCCESS )
        {
            SetLastError( ss );
            return FALSE;
        }

        cbName = strlen( CredNames.sUserName ) + 1;

        if ( !pBuff->Resize( cbName ))
        {
            pfnFreeContextBuffer( CredNames.sUserName );
            return FALSE;
        }

        memcpy( pBuff->QueryPtr(), CredNames.sUserName, cbName );

        pBuff->SetLen( cbName - 1 );

        pfnFreeContextBuffer( CredNames.sUserName );
    }

    return TRUE;
}
/*******************************************************************/

BOOL TCP_AUTHENT::Converse(
    VOID   * pBuffIn,
    DWORD    cbBuffIn,
    BUFFER * pbuffOut,
    DWORD  * pcbBuffOut,
    BOOL   * pfNeedMoreData,
    PTCP_AUTHENT_INFO   pTAI,
    CHAR   * pszPackage,
    CHAR   * pszUser,
    CHAR   * pszPassword,
    PIIS_SERVER_INSTANCE psi
    )
/*++

Routine Description:

    Initiates or continues a previously initiated authentication conversation

    Client calls this first to get the negotiation message which
    it then sends to the server.  The server calls this with the
    client result and sends back the result.  The conversation
    continues until *pfNeedMoreData is FALSE.

    On the first call, pszPackage must point to the zero terminated
    authentication package name to be used and pszUser and pszPassword
    should point to the user name and password to authenticated with
    on the client side (server side will always be NULL).

Arguments:

    pBuffIn - Points to SSP message received from the
        client.  If TCPAUTH_UUENCODE is used, then this must point to a
        zero terminated uuencoded string (except for the first call).
    cbBuffIn - Number of bytes in pBuffIn or zero if pBuffIn points to a
        zero terminated, uuencoded string.
    pbuffOut - If *pfDone is not set to TRUE, this buffer contains the data
        that should be sent to the other side.  If this is zero, then no
        data needs to be sent.
    pcbBuffOut - Number of bytes in pbuffOut
    pfNeedMoreData - Set to TRUE while this side of the conversation is
        expecting more data from the remote side.
    pszPackage - On the first call points to a zero terminate string indicating
        the security package to use
    pszUser - Specifies user or domain\user the first time the client calls
        this method (client side only)
    pszPassword - Specifies the password for pszUser the first time the
        client calls this method (client side only)

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError).  Access is
    denied if FALSE is returned and GetLastError is ERROR_ACCESS_DENIED.

--*/
{
    SECURITY_STATUS       ss;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    SecBufferDesc         InBuffDesc;
    SecBuffer             InSecBuff;
    ULONG                 ContextAttributes;
    BUFFER                buffData;
    BUFFER                buff;
    STACK_STR             ( strDefaultLogonDomain, IIS_DNLEN+1 );

    //
    //  Decode the data if there's something to decode
    //

    if ( _fUUEncodeData && 
         pBuffIn && 
         PackageSupportsEncoding( pszPackage ) )
    {
        if ( !uudecode( (CHAR *) pBuffIn,
                        &buffData,
                        &cbBuffIn,
                        _fBase64
                        ))
        {
            return FALSE;
        }

        pBuffIn = buffData.QueryPtr();
    }

    //
    //  If this is a new conversation, then we need to get the credential
    //  handle and find out the maximum token size
    //

    if ( _fNewConversation )
    {
        if ( !_fClient )
        {
            if ( !CACHED_CREDENTIAL::GetCredential(
                        pszPackage,
                        psi,
                        pTAI,
                        &_hcred,
                        &_cbMaxToken ) )
            {
                return FALSE;
            }
        }
        else
        {
            SecPkgInfo *              pspkg;
            SEC_WINNT_AUTH_IDENTITY   AuthIdentity;
            SEC_WINNT_AUTH_IDENTITY * pAuthIdentity;
            CHAR *                    pszDomain = NULL;
            CHAR                      szDomainAndUser[IIS_DNLEN+UNLEN+2];


            //
            //  If this is the client and a username and password were
            //  specified, then fill out the authentication information
            //

            if ( _fClient &&
                 ((pszUser != NULL) ||
                  (pszPassword != NULL)) )
            {
                pAuthIdentity = &AuthIdentity;

                //
                //  Break out the domain from the username if one was specified
                //

                if ( pszUser != NULL )
                {
                    strcpy( szDomainAndUser, pszUser );
                    if ( !CrackUserAndDomain( szDomainAndUser,
                                              &pszUser,
                                              &pszDomain ))
                    {
                        return FALSE;
                    }
                }

                memset( &AuthIdentity,
                        0,
                        sizeof( AuthIdentity ));

                if ( pszUser != NULL )
                {
                    AuthIdentity.User       = (unsigned char *) pszUser;
                    AuthIdentity.UserLength = strlen( pszUser );
                }

                if ( pszPassword != NULL )
                {
                    AuthIdentity.Password       = (unsigned char *) pszPassword;
                    AuthIdentity.PasswordLength = strlen( pszPassword );
                }

                if ( pszDomain != NULL )
                {
                    AuthIdentity.Domain       = (unsigned char *) pszDomain;
                    AuthIdentity.DomainLength = strlen( pszDomain );
                }

                AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
            }
            else
            {
                //
                // provide default logon domain
                //

                if ( psi == NULL )
                {
                    pAuthIdentity = NULL;
                }
                else
                {
                    pAuthIdentity = &AuthIdentity;

                    memset( &AuthIdentity,
                            0,
                            sizeof( AuthIdentity ));

                    if ( pTAI->strDefaultLogonDomain.QueryCCH() <= IIS_DNLEN )
                    {
                        strDefaultLogonDomain.Copy( pTAI->strDefaultLogonDomain );
                        AuthIdentity.Domain = (LPBYTE)strDefaultLogonDomain.QueryStr();
                    }
                    if ( AuthIdentity.Domain != NULL )
                    {
                        if ( AuthIdentity.DomainLength =
                                strlen( (LPCTSTR)AuthIdentity.Domain ) )
                        {
                            // remove trailing '\\' if present

                            if ( AuthIdentity.Domain[AuthIdentity.DomainLength-1]
                                    == '\\' )
                            {
                                --AuthIdentity.DomainLength;
                            }
                        }
                    }
                    if ( AuthIdentity.DomainLength == 0 )
                    {
                        pAuthIdentity = NULL;
                    }
                    else
                    {
                        AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
                    }
                }
            }

            ss = pfnAcquireCredentialsHandle( NULL,             // New principal
                                           pszPackage,       // Package name
                                           (_fClient ? SECPKG_CRED_OUTBOUND :
                                                       SECPKG_CRED_INBOUND),
                                           NULL,             // Logon ID
                                           pAuthIdentity,    // Auth Data
                                           NULL,             // Get key func
                                           NULL,             // Get key arg
                                           &_hcred,
                                           &Lifetime );

            //
            //  Need to determine the max token size for this package
            //

            if ( ss == STATUS_SUCCESS )
            {
                _fHaveCredHandle = TRUE;
                ss = pfnQuerySecurityPackageInfo( (char *) pszPackage,
                                               &pspkg );
            }

            if ( ss != STATUS_SUCCESS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                           "[Converse] AcquireCredentialsHandle or QuerySecurityPackageInfo failed, error %d\n",
                            ss ));

                SetLastError( ss );
                return FALSE;
            }

            _cbMaxToken = pspkg->cbMaxToken;
            DBG_ASSERT( pspkg->fCapabilities & SECPKG_FLAG_CONNECTION );

            pfnFreeContextBuffer( pspkg );
        }
    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //

    if ( !buff.Resize( _cbMaxToken ))
        return FALSE;

    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = _cbMaxToken;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer   = buff.QueryPtr();

    //
    //  Prepare our Input buffer - Note the server is expecting the client's
    //  negotiation packet on the first call
    //

    if ( pBuffIn )
    {
        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers  = 1;
        InBuffDesc.pBuffers  = &InSecBuff;

        InSecBuff.cbBuffer   = cbBuffIn;
        InSecBuff.BufferType = SECBUFFER_TOKEN;
        InSecBuff.pvBuffer   = pBuffIn;
    }

    //
    //  Client side uses InitializeSecurityContext, server side uses
    //  AcceptSecurityContext
    //

    if ( _fClient )
    {
        //
        //  Note the client will return success when its done but we still
        //  need to send the out buffer if there are bytes to send
        //

        ss = pfnInitializeSecurityContext( &_hcred,
                                        _fNewConversation ? NULL :
                                                            &_hctxt,
                                        _strTarget.IsEmpty() ? 
                                            TCPAUTH_TARGET_NAME : 
                                            _strTarget.QueryStr(),
                                        0,
                                        0,
                                        SECURITY_NATIVE_DREP,
                                        _fNewConversation ? NULL :
                                                            &InBuffDesc,
                                        0,
                                        &_hctxt,
                                        &OutBuffDesc,
                                        &ContextAttributes,
                                        &Lifetime );
    }
    else
    {
        //
        //  This is the server side
        //

        SetLastError ( 0 );

        ss = pfnAcceptSecurityContext( &_hcred,
                                    _fNewConversation ? NULL :
                                                        &_hctxt,
                                    &InBuffDesc,
                                    ASC_REQ_EXTENDED_ERROR,
                                    SECURITY_NATIVE_DREP,
                                    &_hctxt,
                                    &OutBuffDesc,
                                    &ContextAttributes,
                                    &Lifetime );
    }

    if ( !NT_SUCCESS( ss ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[Converse] Initialize/AcceptCredentialsHandle failed, error %d\n",
                    ss ));

        if ( !_fNewConversation )
        {
            //
            // If not a new conversation, then when we fail we still have a context
            // handle from previous to AcceptSecurityContext. Need to call
            // DeleteSecurityContext to avoid leaking the context.
            // AcceptSecurityContext does not touch _hctxt if it fails.
            //

            DBG_ASSERT( _fHaveCtxtHandle );

            pfnDeleteSecurityContext( &_hctxt );
        }

        _fHaveCtxtHandle = FALSE;

        if ( ss == SEC_E_LOGON_DENIED ||
             ss == SEC_E_INVALID_TOKEN )
        {
            ss = ERROR_LOGON_FAILURE;
        }

        if ( GetLastError() != ERROR_PASSWORD_EXPIRED
             && GetLastError() != ERROR_PASSWORD_MUST_CHANGE )
        {
            SetLastError( ss );
        }

        return FALSE;
    }

    if( ContextAttributes & ASC_RET_NULL_SESSION  )
    {
        SetLastError( ERROR_LOGON_FAILURE );

        return FALSE;
    }

    _fHaveCtxtHandle = TRUE;

    //
    // NTLMSSP will set the last error to ERROR_NO_SUCH_USER
    // if success and Guest account was used
    //

    if ( GetLastError() == ERROR_NO_SUCH_USER )
    {
        _fKnownToBeGuest = TRUE;
    }

    //
    //  Now we just need to complete the token (if requested) and prepare
    //  it for shipping to the other side if needed
    //

    BOOL fReply = !!OutSecBuff.cbBuffer;

    if ( (ss == SEC_I_COMPLETE_NEEDED) ||
         (ss == SEC_I_COMPLETE_AND_CONTINUE) )
    {
        ss = pfnCompleteAuthToken( &_hctxt,
                                   &OutBuffDesc );

        if ( !NT_SUCCESS( ss ))
            return FALSE;

    }

    //
    //  Format or copy to the output buffer if we need to reply
    //

    if ( fReply )
    {
        if ( _fUUEncodeData && 
             PackageSupportsEncoding( pszPackage ) )
        {
            if ( !uuencode( (BYTE *) OutSecBuff.pvBuffer,
                            OutSecBuff.cbBuffer,
                            pbuffOut,
                            _fBase64 ))
            {
                return FALSE;
            }

            *pcbBuffOut = strlen( (CHAR *) pbuffOut->QueryPtr() );
        }
        else
        {
            if ( !pbuffOut->Resize( OutSecBuff.cbBuffer ))
                return FALSE;

            memcpy( pbuffOut->QueryPtr(),
                    OutSecBuff.pvBuffer,
                    OutSecBuff.cbBuffer );

            *pcbBuffOut = OutSecBuff.cbBuffer;
        }
    }
    else
    {
        *pcbBuffOut = 0;
    }

    if ( _fNewConversation )
        _fNewConversation = FALSE;

    *pfNeedMoreData = ((ss == SEC_I_CONTINUE_NEEDED) ||
                       (ss == SEC_I_COMPLETE_AND_CONTINUE));

    if ( !*pfNeedMoreData && !_fClient )
    {
        _fDelegate = !!(ContextAttributes & ASC_RET_DELEGATE);
    }

    return TRUE;
}


BOOL TCP_AUTHENT::ConverseEx(
    SecBufferDesc*          pInSecBufDesc,      // passed in by caller
    BUFFER *                pDecodedBuffer,     // passed in by caller
    BUFFER *                pbuffOut,
    DWORD  *                pcbBuffOut,
    BOOL   *                pfNeedMoreData,
    PTCP_AUTHENT_INFO       pTAI,
    CHAR   *                pszPackage,
    CHAR   *                pszUser,
    CHAR   *                pszPassword,
    PIIS_SERVER_INSTANCE    psi
    )
/*
 *  A variant of Converse that takes variable number of input SecBuffer.
 *  Caller will set the SecBuffers and pass in the SecBufferDesc pointer to ConverseEx.
 *  If the SecBuffer.pvBuffer needs to be decoded, caller has to pass in
 *  an array of BUFFER to hold the decoded data. The number of BUFFER elements
 *  should be the same as the number of SecBuffer.
 *  If decoding it not needed, pass NULL instead.
 *
 */
{

    SECURITY_STATUS       ss;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    ULONG                 ContextAttributes;
    BUFFER                buffData;
    BUFFER                buff;
    STACK_STR             ( strDefaultLogonDomain, IIS_DNLEN+1 );
    DWORD                 dw, dwDecodedLen;
    SecBuffer             *pSecBuffer;

    // make sure we have at least one SecBuffer to process
    if (pInSecBufDesc->cBuffers == 0)
        return FALSE;

    //
    //  Decode the data if there's something to decode
    //
    if (_fUUEncodeData && 
        pInSecBufDesc && 
        pDecodedBuffer &&
        PackageSupportsEncoding( pszPackage ) )
    {
        pSecBuffer = pInSecBufDesc->pBuffers;
        for (dw = 0; dw < pInSecBufDesc->cBuffers; dw++, pSecBuffer++)
        {
            if (!uudecode((CHAR *)pSecBuffer->pvBuffer,     // points to data to be decoded
                            &pDecodedBuffer[dw],            // to hold decoded data
                            &dwDecodedLen,                  // length of decoded data
                            _fBase64
                            ))
            {
                return FALSE;
            }

            // update the SecBuffer so it now points to the decoded data in BUFFER
            pSecBuffer->pvBuffer = pDecodedBuffer[dw].QueryPtr();
            pSecBuffer->cbBuffer = dwDecodedLen;
        }
    }

    //
    //  If this is a new conversation, then we need to get the credential
    //  handle and find out the maximum token size
    //

    if ( _fNewConversation )
    {
        SecPkgInfo *              pspkg;
        SEC_WINNT_AUTH_IDENTITY   AuthIdentity;
        SEC_WINNT_AUTH_IDENTITY * pAuthIdentity;
        CHAR *                    pszDomain = NULL;
        CHAR                      szDomainAndUser[IIS_DNLEN+UNLEN+2];


        //
        //  If this is the client and a username and password were
        //  specified, then fill out the authentication information
        //

        if ( _fClient &&
             ((pszUser != NULL) ||
              (pszPassword != NULL)) )
        {
            pAuthIdentity = &AuthIdentity;

            //
            //  Break out the domain from the username if one was specified
            //

            if ( pszUser != NULL )
            {
                strcpy( szDomainAndUser, pszUser );
                if ( !CrackUserAndDomain( szDomainAndUser,
                                          &pszUser,
                                          &pszDomain ))
                {
                    return FALSE;
                }
            }

            memset( &AuthIdentity,
                    0,
                    sizeof( AuthIdentity ));

            if ( pszUser != NULL )
            {
                AuthIdentity.User       = (unsigned char *) pszUser;
                AuthIdentity.UserLength = strlen( pszUser );
            }

            if ( pszPassword != NULL )
            {
                AuthIdentity.Password       = (unsigned char *) pszPassword;
                AuthIdentity.PasswordLength = strlen( pszPassword );
            }

            if ( pszDomain != NULL )
            {
                AuthIdentity.Domain       = (unsigned char *) pszDomain;
                AuthIdentity.DomainLength = strlen( pszDomain );
            }

            AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
        }
        else
        {
            //
            // provide default logon domain
            //

            if ( psi == NULL )
            {
                pAuthIdentity = NULL;
            }
            else
            {
                pAuthIdentity = &AuthIdentity;

                memset( &AuthIdentity,
                        0,
                        sizeof( AuthIdentity ));

                if ( pTAI->strDefaultLogonDomain.QueryCCH() <= IIS_DNLEN )
                {
                    strDefaultLogonDomain.Copy( pTAI->strDefaultLogonDomain );
                    AuthIdentity.Domain = (LPBYTE)strDefaultLogonDomain.QueryStr();
                }
                if ( AuthIdentity.Domain != NULL )
                {
                    if ( AuthIdentity.DomainLength =
                            strlen( (LPCTSTR)AuthIdentity.Domain ) )
                    {
                        // remove trailing '\\' if present

                        if ( AuthIdentity.Domain[AuthIdentity.DomainLength-1]
                                == '\\' )
                        {
                            --AuthIdentity.DomainLength;
                        }
                    }
                }
                if ( AuthIdentity.DomainLength == 0 )
                {
                    pAuthIdentity = NULL;
                }
                else
                {
                    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
                }
            }
        }

        ss = pfnAcquireCredentialsHandle( NULL,             // New principal
                                       pszPackage,       // Package name
                                       (_fClient ? SECPKG_CRED_OUTBOUND :
                                                   SECPKG_CRED_INBOUND),
                                       NULL,             // Logon ID
                                       pAuthIdentity,    // Auth Data
                                       NULL,             // Get key func
                                       NULL,             // Get key arg
                                       &_hcred,
                                       &Lifetime );

        //
        //  Need to determine the max token size for this package
        //

        if ( ss == STATUS_SUCCESS )
        {
            _fHaveCredHandle = TRUE;
            ss = pfnQuerySecurityPackageInfo( (char *) pszPackage,
                                           &pspkg );
        }

        if ( ss != STATUS_SUCCESS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[Converse] AcquireCredentialsHandle or QuerySecurityPackageInfo failed, error %d\n",
                        ss ));

            SetLastError( ss );
            return FALSE;
        }

        _cbMaxToken = pspkg->cbMaxToken;
        DBG_ASSERT( pspkg->fCapabilities & SECPKG_FLAG_CONNECTION );

        pfnFreeContextBuffer( pspkg );

    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //

    if ( !buff.Resize( _cbMaxToken ))
        return FALSE;

    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = _cbMaxToken;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer   = buff.QueryPtr();

    //
    // Input sec buffer is passed by caller
    //

    //
    //  Client side uses InitializeSecurityContext, server side uses
    //  AcceptSecurityContext
    //

    if ( _fClient )
    {
        //
        //  Note the client will return success when its done but we still
        //  need to send the out buffer if there are bytes to send
        //

        ss = pfnInitializeSecurityContext( &_hcred,
                                        _fNewConversation ? NULL : &_hctxt,
                                        _strTarget.IsEmpty() ? 
                                            TCPAUTH_TARGET_NAME : 
                                            _strTarget.QueryStr(),
                                        0,
                                        0,
                                        SECURITY_NATIVE_DREP,
                                        _fNewConversation ? NULL : pInSecBufDesc,
                                        0,
                                        &_hctxt,
                                        &OutBuffDesc,
                                        &ContextAttributes,
                                        &Lifetime );
    }
    else
    {
        //
        //  This is the server side
        //

        SetLastError ( 0 );

        ss = pfnAcceptSecurityContext( &_hcred,
                                    _fNewConversation ? NULL : &_hctxt,
                                    pInSecBufDesc,
                                    ASC_REQ_EXTENDED_ERROR,
                                    SECURITY_NATIVE_DREP,
                                    &_hctxt,
                                    &OutBuffDesc,
                                    &ContextAttributes,
                                    &Lifetime );
    }

    if ( !NT_SUCCESS( ss ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[Converse] Initialize/AcceptCredentialsHandle failed, error %d\n",
                    ss ));

        if ( ss == SEC_E_LOGON_DENIED ||
             ss == SEC_E_INVALID_TOKEN )
        {
            ss = ERROR_LOGON_FAILURE;
        }

        if ( GetLastError() != ERROR_PASSWORD_EXPIRED
             && GetLastError() != ERROR_PASSWORD_MUST_CHANGE )
        {
            SetLastError( ss );
        }

        return FALSE;
    }

    _fHaveCtxtHandle = TRUE;

    //
    // NTLMSSP will set the last error to ERROR_NO_SUCH_USER
    // if success and Guest account was used
    //

    if ( GetLastError() == ERROR_NO_SUCH_USER )
    {
        _fKnownToBeGuest = TRUE;
    }

    //
    //  Now we just need to complete the token (if requested) and prepare
    //  it for shipping to the other side if needed
    //

    BOOL fReply = !!OutSecBuff.cbBuffer;

    if ( (ss == SEC_I_COMPLETE_NEEDED) ||
         (ss == SEC_I_COMPLETE_AND_CONTINUE) )
    {
        ss = pfnCompleteAuthToken( &_hctxt,
                                   &OutBuffDesc );

        if ( !NT_SUCCESS( ss ))
            return FALSE;

    }

    //
    //  Format or copy to the output buffer if we need to reply
    //

    if ( fReply )
    {
        if ( _fUUEncodeData &&
             PackageSupportsEncoding( pszPackage ) )
        {
            if ( !uuencode( (BYTE *) OutSecBuff.pvBuffer,
                            OutSecBuff.cbBuffer,
                            pbuffOut,
                            _fBase64 ))
            {
                return FALSE;
            }

            *pcbBuffOut = strlen( (CHAR *) pbuffOut->QueryPtr() );
        }
        else
        {
            if ( !pbuffOut->Resize( OutSecBuff.cbBuffer ))
                return FALSE;

            memcpy( pbuffOut->QueryPtr(),
                    OutSecBuff.pvBuffer,
                    OutSecBuff.cbBuffer );

            *pcbBuffOut = OutSecBuff.cbBuffer;
        }
    }
    else
    {
        *pcbBuffOut = 0;
    }

    if ( _fNewConversation )
        _fNewConversation = FALSE;

    *pfNeedMoreData = ((ss == SEC_I_CONTINUE_NEEDED) ||
                       (ss == SEC_I_COMPLETE_AND_CONTINUE));

    if ( !*pfNeedMoreData && !_fClient )
    {
        _fDelegate = !!(ContextAttributes & ASC_RET_DELEGATE);
    }

    return TRUE;
}


/*******************************************************************/

#if 0
BOOL
TCP_AUTHENT::DigestLogon(
    PSTR pszUserName,
    PSTR pszRealm,
    PSTR pszUri,
    PSTR pszMethod,
    PSTR pszNonce,
    PSTR pszServerNonce,
    PSTR pszDigest,
    DWORD dwAlgo,
    LPTSVC_INFO     psi
    )
{
    HANDLE      hToken;
    CHAR        szDomainAndUser[IIS_DNLEN+UNLEN+2];
    int         cL = 0;
    CHAR   *    pszUserOnly;
    CHAR   *    pszDomain;

    //
    // prepend default logon domain if no domain
    //

    if (    strchr( pszUserName, '/' ) == NULL
            && strchr( pszUserName, '\\' ) == NULL )
    {
        psi->LockThisForRead();
        PCSTR pD = psi->QueryDefaultLogonDomain();
        PCSTR pL;
        if ( pD != NULL && pD[0] != '\0' )
        {
            if ( ( pL = strchr( pD, '\\' ) ) )
            {
                cL = pL - pD;
            }
            else
            {
                cL = strlen( pD );
            }
            memcpy( szDomainAndUser, pD, cL );
            szDomainAndUser[ cL++ ] = '\\';
        }
        psi->UnlockThis();
    }

    strcpy( szDomainAndUser + cL, pszUserName );

    //
    //  Crack the name into domain/user components.
    //

    if ( !CrackUserAndDomain( szDomainAndUser,
                              &pszUserOnly,
                              &pszDomain ))
    {
        return FALSE;
    }

    if ( LogonDigestUserA(
            pszUserOnly,
            pszDomain,
            pszRealm,
            pszUri,
            pszMethod,
            pszNonce,
            pszServerNonce,
            pszDigest,
            dwAlgo,
            &hToken )
          && SetAccessToken( NULL, hToken ) )
    {
        return TRUE;
    }

    return FALSE;
}
#endif


BOOL
TCP_AUTHENT::ClearTextLogon(
    IN  PCHAR            pszUser,
    IN  PCHAR            pszPassword,
    OUT PBOOL            pfAsGuest,
    OUT PBOOL            pfAsAnonymous,
    IN  PIIS_SERVER_INSTANCE pInstance,
    PTCP_AUTHENT_INFO    pTAI,
    IN  PCHAR            pszWorkstation
    )
/*++

Routine Description:

    Gets a network logon token using clear text

Arguments:

    pszUser - User name (optionally with domain)
    pszPassword - password
    pfAsGuest - Set to TRUE if granted with guest access (NOT SUPPORTED)
    pfAsAnonymous - Set to TRUE if the user received the anonymous token
    pInstance - pointer to Server instance

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    BOOL fHaveExp;

    DBG_ASSERT( !_fHaveCredHandle && !_fHaveCtxtHandle );

    //
    // short circuit fast path
    //

    if ( pszUser == NULL ) {

        _hToken = FastFindAnonymousToken( pTAI );

        //
        // success!
        //

        if ( _hToken != NULL ) {

            _liPwdExpiry.LowPart = _hToken->QueryExpiry()->LowPart;
            _liPwdExpiry.HighPart = _hToken->QueryExpiry()->HighPart;

            _fHaveExpiry = TRUE;
            _fClearText = TRUE;

            *pfAsGuest = _hToken->IsGuest();
            *pfAsAnonymous = TRUE;
            return TRUE;
        }

        //
        // use normal path
        //
    }

    _hToken = TsLogonUser( pszUser,
                           pszPassword,
                           pfAsGuest,
                           pfAsAnonymous,
                           pInstance,
                           pTAI,
                           pszWorkstation,
                           &_liPwdExpiry,
                           &fHaveExp );

    if ( _hToken == NULL  ) {
        return FALSE;
    }

    _fClearText = TRUE;
    _fHaveExpiry = fHaveExp;

    switch ( pTAI->dwLogonMethod )
    {
    case LOGON32_LOGON_BATCH:
    case LOGON32_LOGON_INTERACTIVE:
    case LOGON32_LOGON_NETWORK_CLEARTEXT:
        _fDelegate = TRUE;
    }

    return TRUE;

} // TCP_AUTHENT::ClearTextLogon


BOOL TCP_AUTHENT::SetAccessToken(
    HANDLE          hPrimaryToken,
    HANDLE          hImpersonationToken
    )
/*++

Routine Description:

    Set primary & impersonation token

Arguments:

    hPrimaryToken -- Primary Access Token
    hImpersonationToken -- Impersonation Access Token
      One the two above tokens can be NULL ( but not both )
    psi - pointer to Service info struct

Return Value:

    TRUE if successful, FALSE otherwise ( tokens will be closed )

--*/
{
    if ( !hPrimaryToken )
    {
        if ( !hImpersonationToken )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if ( !pfnDuplicateTokenEx( hImpersonationToken,
                                TOKEN_ALL_ACCESS,
                                NULL,
                                SecurityImpersonation,
                                TokenPrimary,
                                &hPrimaryToken ))
        {

            CloseHandle( hImpersonationToken );
            return FALSE;
        }
    }

    if ( !hImpersonationToken )
    {
        if ( !pfnDuplicateTokenEx( hPrimaryToken,
                                TOKEN_ALL_ACCESS,
                                NULL,
                                SecurityImpersonation,
                                TokenImpersonation,
                                &hImpersonationToken ))
        {

            CloseHandle( hPrimaryToken );
            return FALSE;
        }
    }

    _hSSPToken = hImpersonationToken;
    _hSSPPrimaryToken = hPrimaryToken;

    _fHaveAccessTokens = TRUE;

    return TRUE;
}


/*******************************************************************/

BOOL TCP_AUTHENT::Impersonate(
    VOID
    )
/*++

Routine Description:

    Impersonates the authenticated user

Arguments:

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    if ( _hToken == (TS_TOKEN)BOGUS_WIN95_TOKEN )
    {
        return(TRUE);
    }

    if ( _fClearText )
    {
        return TsImpersonateUser( _hToken );
    }
    else if ( _fHaveAccessTokens || _pDeleteFunction )
    {
        return ImpersonateLoggedOnUser( _hSSPToken );
    }
    else
    {
        DBG_ASSERT( _fHaveCtxtHandle );

        return !!NT_SUCCESS( pfnImpersonateSecurityContext( &_hctxt ));
    }
}

/*******************************************************************/

BOOL TCP_AUTHENT::RevertToSelf(
    VOID
    )
/*++

Routine Description:

    Undoes the impersonation

Arguments:

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    if ( _hToken == (TS_TOKEN)BOGUS_WIN95_TOKEN )
    {
        return(TRUE);
    }

    if ( _fClearText || _fHaveAccessTokens || _pDeleteFunction )
    {
        return ::RevertToSelf();
    }
    else
    {
        DBG_ASSERT( _fHaveCtxtHandle );

        return !!NT_SUCCESS( pfnRevertSecurityContext( &_hctxt ));
    }
}

/*******************************************************************/

BOOL TCP_AUTHENT::StartProcessAsUser(
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
/*++

Routine Description:

    Creates a process as the authenticated user

Arguments:

    Standard CreateProcess args

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    HANDLE htoken;
    BOOL   fRet;

    if ( _fClearText )
    {
        htoken = CTO_TO_TOKEN( _hToken );
    }
    else
    {
        //
        //  Need to extract the impersonation token from the opaque SSP
        //  structures
        //

        if ( !Impersonate() )
        {
            return FALSE;
        }

        if ( !OpenThreadToken( GetCurrentThread(),
                               TOKEN_QUERY,
                               TRUE,
                               &htoken ))
        {
            RevertToSelf();
            return FALSE;
        }

        RevertToSelf();
    }

    fRet = CreateProcessAsUser( htoken,
                                lpApplicationName,
                                lpCommandLine,
                                NULL,
                                NULL,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation );

    if ( !_fClearText )
    {
        DBG_REQUIRE( CloseHandle( htoken ) );
    }

    return fRet;
}


BOOL
TCP_AUTHENT::GetClientCertBlob
(
IN  DWORD           cbAllocated,
OUT DWORD *         pdwCertEncodingType,
OUT unsigned char * pbCertEncoded,
OUT DWORD *         pcbCertEncoded,
OUT DWORD *         pdwCertificateFlags
)
{

    if ( (pdwCertEncodingType == NULL)  ||
         (pbCertEncoded == NULL)        ||
         (pcbCertEncoded == NULL)
         ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return ( FALSE);
    }

    BOOL            fReturn = FALSE;
    BOOL            fNoCert;


    //
    // Win95 <==> no certificate
    // NOTE Currently security.dll is not supported in Win95.
    //

    if ( TsIsWindows95() ) {

        goto LNoCertificate;
    }


    if ( !QueryCertificateInfo( &fNoCert) ) {

        goto LNoCertificate;
    }

    //
    // fill in cert size out-parameter
    //

    *pcbCertEncoded = _pClientCertContext->cbCertEncoded;


    //
    //  if buffer is adequate, fill in remaining out-parameters
    //  else return error
    //

    if ( cbAllocated >= *pcbCertEncoded ) {

        CopyMemory( pbCertEncoded,
                    _pClientCertContext->pbCertEncoded,
                    _pClientCertContext->cbCertEncoded );

        *pdwCertEncodingType = _pClientCertContext->dwCertEncodingType;
        *pdwCertificateFlags = _dwX509Flags;
        fReturn = TRUE;

    } else {

        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        fReturn = FALSE;

    }


LExit:

    return fReturn;


LNoCertificate:

    //
    //  No cert: zero-out buffer and return success
    //

    *pbCertEncoded = NULL;
    *pcbCertEncoded = 0;
    *pdwCertEncodingType = 0;
    *pdwCertificateFlags = 0;

    fReturn = TRUE;

    goto LExit;

} // TCP_AUTHENT::GetClientCertBlob()


BOOL
TCP_AUTHENT::UpdateClientCertFlags(
    DWORD   dwFlags,
    LPBOOL  pfNoCert,
    LPBYTE  pbCa,
    DWORD   dwCa
    )
{
    BOOL    fNoCert;

    _fCertCheckForRevocation = !( dwFlags & MD_CERT_NO_REVOC_CHECK );
    _fCertCheckCacheOnly = !!( dwFlags & MD_CERT_CACHE_RETRIEVAL_ONLY );

    if ( QueryCertificateInfo( pfNoCert ) )
    {
        *pfNoCert = FALSE;
        return TRUE;
    }

    return FALSE;
}

BOOL
TCP_AUTHENT::PackageSupportsEncoding(
    LPSTR   pszPackage
)
/*++

Routine Description:

    Check whether the SSPI package should (not) be encoded.    

Arguments:

    pszPackage - Name of SSPI package

Return Value:

    TRUE if should encode, FALSE otherwise

--*/
{
    SECURITY_STATUS     SecurityStatus;
    PSecPkgInfo         pPackageInfo;
    BOOL                fRet = FALSE;

    if ( pszPackage != NULL )
    {
        SecurityStatus = pfnQuerySecurityPackageInfo( pszPackage,
                                                      &pPackageInfo );
    
        if ( SecurityStatus == SEC_E_OK )
        {
            if ( !( pPackageInfo->fCapabilities & SECPKG_FLAG_ASCII_BUFFERS ) )
            {
                fRet = TRUE;
            }
            pfnFreeContextBuffer( pPackageInfo );
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        DBG_ASSERT( FALSE );
    }
    
    return fRet;
}

BOOL
TCP_AUTHENT::SetTargetName(
    LPSTR   pszTargetName
)
/*++

Routine Description:

    Set the target name to pass into InitializeSecurityContext() calls

Arguments:

    pszTargetName - Target name

Return Value:

    TRUE if successful, else FALSE.  Use GetLastError() for error

--*/
{
    if ( pszTargetName != NULL )
    {
        return _strTarget.Copy( pszTargetName );
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
}
/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
      MuraliK  1-Nov-1996  Use common macros from pudebug.h
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


/************************************************************
 *     Include Headers
 ************************************************************/

// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

# include <pudebug.h>


//
//  Define the debugging constants
//

#define DEBUG_OPLOCKS              0x00001000L

#define DEBUG_GATEWAY              0x00010000L
#define DEBUG_INSTANCE             0x00020000L
#define DEBUG_ENDPOINT             0x00040000L
#define DEBUG_METABASE             0x00080000L

#define DEBUG_DLL_EVENT_LOG        0x00100000L
#define DEBUG_DLL_SERVICE_INFO     0x00200000L
#define DEBUG_DLL_SECURITY         0x00400000L
#define DEBUG_DLL_CONNECTION       0x00800000L

#define DEBUG_DLL_RPC              0x01000000L
#define DEBUG_ODBC                 0x02000000L
#define DEBUG_MIME_MAP             0x04000000L
#define DEBUG_DLL_VIRTUAL_ROOTS    0x08000000L
# define DEBUG_VIRTUAL_ROOTS       (DEBUG_DLL_VIRTUAL_ROOTS)


# define DEBUG_DIR_LIST            0x10000000L
# define DEBUG_OPEN_FILE           0x20000000L
# define DEBUG_CACHE               0x40000000L
# define DEBUG_DIRECTORY_CHANGE    0x80000000L



# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\certnotf.cxx ===
/*++







Copyright (c) 1995  Microsoft Corporation

Module Name:

   certnotf.cxx

Abstract:

    This module contains the code for the class to deal with CAPI store change notifications

Author:

    Alex Mallet [amallet] 17-Dec-1997

Revision History:
--*/



#include "tcpdllp.hxx"
#pragma hdrstop

#include <winbase.h>
#include <dbgutil.h>
#include <ole2.h>
#include <imd.h>
#include <nturtl.h>
#include <certnotf.hxx>



#if DBG
#define VALIDATE_HEAP() DBG_ASSERT( RtlValidateProcessHeaps() )
#else
#define VALIDATE_HEAP()
#endif 

DWORD STORE_CHANGE_ENTRY::m_dwNumEntries = 0;
CRITICAL_SECTION *STORE_CHANGE_NOTIFIER::m_pStoreListCS = NULL;


STORE_CHANGE_NOTIFIER::STORE_CHANGE_NOTIFIER() :
m_dwSignature(NOTIFIER_GOOD_SIG)
/*++

Routine Description:

     Constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    //
    // Critical sections
    //
    if ( !STORE_CHANGE_NOTIFIER::m_pStoreListCS )
    {
        STORE_CHANGE_NOTIFIER::m_pStoreListCS = new CRITICAL_SECTION;
        
        if ( STORE_CHANGE_NOTIFIER::m_pStoreListCS )
        {
            INITIALIZE_CRITICAL_SECTION(STORE_CHANGE_NOTIFIER::m_pStoreListCS);
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Failed to allocate memory for store list critical section !\n"));
        }
    }
    
    InitializeListHead( &m_StoreList );
}

STORE_CHANGE_NOTIFIER::~STORE_CHANGE_NOTIFIER()
/*++

Routine Description:

    Destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    DBG_ASSERT( CheckSignature() );

    STORE_CHANGE_NOTIFIER::Lock();

    //
    // Clean up all the stores, so we don't get bitten in the @$$ when trying to
    // clean up the STORE_CHANGE_ENTRY objects : CertCloseStore() calls RtlDeregisterWait()
    // which can't be called from inside a callback function, so we need to clean up 
    // the cert stores before triggering any of the callbacks used to clean up the
    // STORE_CHANGE_ENTRY objects.
    //
    LIST_ENTRY *pListEntry;
    STORE_CHANGE_ENTRY *pStoreEntry;

    for ( pListEntry = m_StoreList.Flink;
          pListEntry != &m_StoreList;
          pListEntry = pListEntry->Flink )
    {
        pStoreEntry = CONTAINING_RECORD( pListEntry, STORE_CHANGE_ENTRY, m_StoreListEntry );
        
        CertCloseStore( pStoreEntry->m_hCertStore,
                        0 );
        pStoreEntry->m_hCertStore = NULL;
    }

    //
    // Go through both the active and inactive store entries and start the process to
    // clean them up [they'll actually be cleaned up on a different thread, in a callback from
    // the thread pool].
    //
    while ( !IsListEmpty( &m_StoreList ) )
    {
        pStoreEntry = CONTAINING_RECORD( m_StoreList.Flink,
                                    STORE_CHANGE_ENTRY,
                                    m_StoreListEntry );

        RemoveEntryList( &(pStoreEntry->m_StoreListEntry) );
        
        InitializeListHead( &(pStoreEntry->m_StoreListEntry) );

        StartCleanup( pStoreEntry );
    }

    STORE_CHANGE_NOTIFIER::Unlock();

    //
    // The STORE_CHANGE_ENTRY objects are cleaned up on a different so we loop and wait 
    // until they've all been cleaned up, to avoid problems with a thread/DLL going away
    // before proper cleanup has occurred.
    //
    DWORD dwNumWaits = 0;
    DWORD dwNumEntries = 0;
    while ( ( dwNumEntries = STORE_CHANGE_ENTRY::QueryStoreEntryCount() ) &&
            dwNumWaits < 30 * 5 ) //sleep for 2 secs => 30x/min, wait for 5 mins
    {
        Sleep( 2000 );

        DBGPRINTF((DBG_CONTEXT,
                   "Waiting %d seconds for %d store entries to be cleaned up\n",
                   dwNumWaits * 2,
                   dwNumEntries));

        dwNumWaits++;
    }

    if ( dwNumEntries != 0 )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WARNING : Failed to clean up all STORE_CHANGE_ENTRY objects, %d left\n",
                   dwNumEntries));
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Cleaned up all store entries \n"));
    }

    m_dwSignature = NOTIFIER_BAD_SIG;

}

VOID STORE_CHANGE_NOTIFIER::ReleaseRegisteredStores()
/*++

Routine Description:

    Releases all the events that have been registered for store change notifications
    and closes the stores that were being watched.

Arguments:

    None

Returns:

    Nothing

--*/

{
    LIST_ENTRY *        pEntry;

    DBG_ASSERT( CheckSignature() );

    STORE_CHANGE_NOTIFIER::Lock();

    for ( pEntry = m_StoreList.Flink;
          pEntry != &m_StoreList;
          pEntry = pEntry->Flink )
    {
        STORE_CHANGE_ENTRY *pStoreEntry = CONTAINING_RECORD( pEntry,
                                                             STORE_CHANGE_ENTRY,
                                                             m_StoreListEntry );
                                                        
        StartCleanup( pStoreEntry );
    }

    STORE_CHANGE_NOTIFIER::Unlock();
}


VOID STORE_CHANGE_NOTIFIER::StartCleanup( IN STORE_CHANGE_ENTRY *pEntry )
/*++

Routine Description:

    Start the cleanup for a STORE_CHANGE_ENTRY object.
    This function MUST be called between calls to STORE_CHANGE_NOTIFIER::Lock()/Unlock() !

Arguments:

    pEntry - STORE_CHANGE_ENTRY to clean up.

Returns:

    Nothing

--*/

{
    //
    // Grab the lock, mark the entry as being ready for deletion,signal the event associated 
    // with it and release a reference to the entry . We hold the lock, so we have exclusive 
    // access to the entries. Possible execution paths : 
    //
    // #1. No callback comes in while we're executing this code. We set the deletion bit and 
    // signal the event. If the callback now fires, it smacks into
    // the lock and waits its turn. If it doesn't fire, that's OK too. We unlock and go on our 
    // merry way. At some point in time, the callback -will- fire, because we didn't call 
    // UnregisterWait(). Then, in the callback, we see the "delete me" flag and delete the
    // entry. Also, the wait is cancelled because we acquired the wait handle with the 
    // WT_EXECUTEDELETEWAIT flag, which removes the wait immediately after calling the callback. 
    // 
    // #2. A callback comes in while we're executing this code. It waits to acquire the lock,
    // and by the time it acquires it we've set the deletion bit and signalled the event.
    // The callback sees the deletion bit and deletes the entry. The wait is cancelled, and
    // so it doesn't matter that we signalled the event.
    //

    pEntry->MarkForDelete();
    
    SetEvent( pEntry->QueryStoreEvent() );

}

BOOL STORE_CHANGE_NOTIFIER::IsStoreRegisteredForChange( IN LPTSTR pszStoreName,
                                                        IN NOTIFFNCPTR pFncPtr,
                                                        IN LPVOID pvParam )
/*++

Routine Description:

    Check whether the store described by the parameters already has an event registered
    for change notifications. 

Arguments:

    pszStoreName - name of cert store
    pFncPtr - pointer to  notification function. If pFncPtr == INVALID_FNC_PTR, checks for any
    notification functions
    pvParam - arg to notification function; if pFncPtr == INVALID_FNC_PTR, is ignored

Returns:

   TRUE if store is registered, FALSE if not.

--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( pszStoreName );
    DBG_ASSERT( pFncPtr );

    PSTORE_CHANGE_ENTRY pEntry = InternalIsStoreRegisteredForChange( pszStoreName,
                                                                     pFncPtr,
                                                                     pvParam ) ;


    return ( pEntry ? TRUE : FALSE );

}

PSTORE_CHANGE_ENTRY
STORE_CHANGE_NOTIFIER::InternalIsStoreRegisteredForChange( IN LPTSTR pszStoreName,
                                                           IN NOTIFFNCPTR pFncPtr,
                                                           IN LPVOID pvParam )

/*++

Routine Description:

    Check whether the store described by the parameters already has an event registered
    for change notifications. 

Arguments:

    pszStoreName - name of cert store
    pFncPtr - pointer to notification function. If pFncPtr == INVALID_FNC_PTR, checks for any
    notification functions
    pvParam - arg for notification function. Ignored if pFncPtr == INVALID_FNC_PTR

Returns:

   pointer to STORE_ENTRY structure that contains the registration info, NULL if non-existent.

--*/

{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( pszStoreName );
    DBG_ASSERT( pFncPtr );

    STORE_CHANGE_ENTRY *pStoreEntry = NULL, *pMatchingEntry = NULL;
    LIST_ENTRY *pEntry;
    BOOL fFound = FALSE;

    STORE_CHANGE_NOTIFIER::Lock();

    for ( pEntry = m_StoreList.Flink;
          pEntry != &m_StoreList;
          pEntry = pEntry->Flink )
    {
        pStoreEntry = CONTAINING_RECORD( pEntry, STORE_CHANGE_ENTRY, m_StoreListEntry );

        if ( pStoreEntry->Matches( pszStoreName,
                                   pFncPtr,
                                   pvParam ) )
        {
            pMatchingEntry = pStoreEntry;
            break;
        }
    }

    STORE_CHANGE_NOTIFIER::Unlock();

    return pMatchingEntry;
}


BOOL STORE_CHANGE_NOTIFIER::RegisterStoreForChange( IN LPTSTR pszStoreName,
                                                    IN HCERTSTORE hStore,
                                                    IN NOTIFFNCPTR pFncPtr,
                                                    IN LPVOID pvParam )
/*++

Routine Description:

    Register the store for change notifications

    Critical Sections acquired : m_pStoreListCS, m_pStoreArrayCS

Arguments:

    pszStoreName - name of cert store
    hCertStore - handle to cert store 
    pFncPtr - pointer to notification function
    pvParam  - arg to notification function

Returns:

   TRUE if store was registered, FALSE if not
--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( pszStoreName );
    DBG_ASSERT( pFncPtr );

    BOOL fAlreadyRegistered = FALSE;
    BOOL fSuccess = FALSE;
    PSTORE_CHANGE_ENTRY pStoreEntry = NULL;

    STORE_CHANGE_NOTIFIER::Lock();

    //
    // Check whether there already some notifications on this store
    //
    pStoreEntry = InternalIsStoreRegisteredForChange( pszStoreName,
                                                      (NOTIFFNCPTR)   INVALID_FNC_PTR,
                                                      NULL );

    fAlreadyRegistered = (pStoreEntry == NULL ? FALSE : TRUE );

    //
    // If this is a totally new store, need to allocate and fill in new store watch entry
    //
    if ( !pStoreEntry )
    {
        HCERTSTORE hCertStore = NULL;
        HANDLE hStoreEvent = NULL;
        HANDLE hWaitHandle = NULL;

        pStoreEntry = new STORE_CHANGE_ENTRY( this,
                                              pszStoreName, 
                                              hStore,
                                              pFncPtr,
                                              pvParam) ;
        
        if ( !pStoreEntry || pStoreEntry->GetLastError() )
        {
            if ( pStoreEntry )
            {
                SetLastError( pStoreEntry->GetLastError() );
            }
            goto EndRegisterStore;
        }

        //
        // Add the entire entry to the list of stores to be watched
        //
        InsertTailList( &m_StoreList, &pStoreEntry->m_StoreListEntry );                      
    }
    //
    // Else, possibly update the notification functions to be called - only update
    // if there isn't already a copy of this function with the same parameters
    //
    else
    {
        DBG_ASSERT( pStoreEntry->QueryStoreHandle() &&
                    pStoreEntry->QueryStoreEvent() &&
                    pStoreEntry->QueryNotifier() &&
                    pStoreEntry->QueryWaitHandle() );

        if ( !pStoreEntry->ContainsNotifFnc( pFncPtr,
                                             pvParam ) )
        {
            if ( !pStoreEntry->AddNotifFnc( pFncPtr,
                                            pvParam ) )
            {
                SetLastError( pStoreEntry->GetLastError() );
                goto EndRegisterStore;
            }
        }
    }

    fSuccess = TRUE;

EndRegisterStore:
    
    if ( !fSuccess )
    {
        //
        // If we failed to register the store and we allocated a new STORE_CHANGE_ENTRY
        // object, clean it up. Note that ref count is only set if everything succeeds
        //
        if ( !fAlreadyRegistered && pStoreEntry )
        {
            delete pStoreEntry;
        }

        DBGPRINTF((DBG_CONTEXT,"Failed to register store %s : 0x%x\n",
                   pszStoreName, GetLastError()));
    }

    STORE_CHANGE_NOTIFIER::Unlock();

    return fSuccess;
}


VOID STORE_CHANGE_NOTIFIER::UnregisterStore( IN LPTSTR pszStoreName,
                                             IN NOTIFFNCPTR pNotifFnc,
                                             IN LPVOID pvParam )
/*++

Routine Description:

   Unregister a notification function for a store

Arguments:

   pszStoreName - name of store
   pNotifFnc - notification function to deregister. If pNotifFnc == INVALID_FNC_PTR,
   all notifications for that store are removed
   pvParam - arg to notification function. Ignored if pNotifFnc == INVALID_FNC_PTR

--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( pszStoreName );
    DBG_ASSERT( pNotifFnc );

    STORE_CHANGE_ENTRY *pStoreEntry;
    LIST_ENTRY *pEntry;
    BOOL fRemoveAll = (pNotifFnc == (NOTIFFNCPTR) INVALID_FNC_PTR ? TRUE : FALSE );

    STORE_CHANGE_NOTIFIER::Lock();

    //
    // Iterate through the active list to find it
    //
    for ( pEntry = m_StoreList.Flink;
          pEntry != &m_StoreList;
          pEntry = pEntry->Flink )
    {
        pStoreEntry = CONTAINING_RECORD( pEntry, STORE_CHANGE_ENTRY, m_StoreListEntry );

        if ( pStoreEntry->Matches( pszStoreName,
                                   pNotifFnc,
                                   pvParam  ) )
        {
            //
            // If we're removing all notifications for this store, or there will be no
            // notification functions left for this store, clean everything up
            //
            if ( fRemoveAll || ( pStoreEntry->RemoveNotifFnc( pNotifFnc,
                                                              pvParam ) &&
                                 !pStoreEntry->HasNotifFncs() ) )
            {
                StartCleanup( pStoreEntry );
            }

            break;
        }

    }

    STORE_CHANGE_NOTIFIER::Unlock();
}
    

#if DBG
VOID STORE_CHANGE_NOTIFIER::DumpRegisteredStores()
/*++

Routine Description:

  Dumps all the stores currently being watched

Arguments:

   None

Returns:

   Nothing 
--*/

{
    STORE_CHANGE_ENTRY *pStoreEntry = NULL;
    LIST_ENTRY *pEntry1 = NULL, *pEntry2 = NULL;

    DBG_ASSERT( CheckSignature() );

    STORE_CHANGE_NOTIFIER::Lock();


    DBGPRINTF((DBG_CONTEXT,
                   "------------------------------------------------------------------------\nRegistered Stores : \n"));

    for ( pEntry1 = m_StoreList.Flink;
          pEntry1 != &m_StoreList;
          pEntry1 = pEntry1->Flink )
    {
        pStoreEntry = CONTAINING_RECORD( pEntry1, 
                                         STORE_CHANGE_ENTRY,
                                         m_StoreListEntry );
                                                            
        DBGPRINTF((DBG_CONTEXT,
                   "Store %s, store handle 0x%x, event handle 0x%x, wait handle 0x%x has the ff functions registered : \n", 
                   pStoreEntry->QueryStoreName(),
                   pStoreEntry->QueryStoreHandle(),
                   pStoreEntry->QueryStoreEvent(), 
                   pStoreEntry->QueryWaitHandle() ));

        LIST_ENTRY *pFncs = pStoreEntry->QueryNotifFncChain();

        for ( pEntry2 = pFncs->Flink;
              pEntry2 != pFncs;
              pEntry2 = pEntry2->Flink )
        {
            PNOTIF_FNC_CHAIN_ENTRY pNFE = CONTAINING_RECORD( pEntry2,
                                                             NOTIF_FNC_CHAIN_ENTRY,
                                                             ListEntry );

            DBGPRINTF((DBG_CONTEXT,"Function 0x%x, parameter 0x%x\n",
                       pNFE->pNotifFnc,
                       pNFE->pvParam ));
        }

    }
    DBGPRINTF((DBG_CONTEXT,
               "------------------------------------------------------------------------\n"));

    STORE_CHANGE_NOTIFIER::Unlock();
}
#endif //DBG


VOID NTAPI STORE_CHANGE_NOTIFIER::NotifFncCaller( IN PVOID pvCallbackArg,
                                                  IN BOOLEAN fUnused )
/*++

Routine Description:

   This is the function called when one of the events we registered for is signalled.
   The context passed in can be in one of three states :

   1. Valid : has an associated chain of notification functions that are to be called.
   2. Invalid : don't do any processing, because we're not interested in that store anymore
   ie UnregisterStore() has been called on it
   3. To Be Deleted : the context is to be deleted, because we're shutting down 

Arguments:

   pvCallbackArg - context pointer 
   fUnused - boolean, not used. [part of WAITFORTIMERCALLBACKFUNC prototype, which this function
   has to conform to]

--*/
{
    LIST_ENTRY *            pNotifFncChain = NULL;
    PSTORE_CHANGE_ENTRY     pEntry = NULL;
    
    if ( !pvCallbackArg )
    {
        DBG_ASSERT( FALSE ); //make sure we barf in debug build

        return;
    }
   
    pEntry = (PSTORE_CHANGE_ENTRY) pvCallbackArg;

    //
    // Make sure we have exclusive access 
    //
    STORE_CHANGE_NOTIFIER::Lock();

    DBG_ASSERT( pEntry->CheckSignature() );

    //
    // If we signalled the event ourselves because we need to clean up this context,
    // just delete it - we know we won't get any more callbacks, since we acquired the
    // wait handle with WTEXECUTEDELETEWAIT. We don't need to remove it from a list 
    // because it has already been removed prior to this callback being generated. 
    // [in the destructor for STORE_CHANGE_NOTIFIER]
    //
    if ( !pEntry->IsMarkedForDelete() && !pEntry->IsInvalid() )
    {
        //
        // Make a copy of the list of notification functions to call, so that even if
        // one of the functions called changes the list, we still have a kosher copy to
        // work with. 
        //
        // Note that another assumption is that if functions A and B are both in the list
        // being walked, and A is called before B, it doesn't destroy anything that B uses.
        //
        
        pNotifFncChain = CopyNotifFncChain( pEntry->QueryNotifFncChain() );
        
        //
        // Remove this entry from the active list and delete it: it'll never get notified again
        // because we acquired it with the WTEXECUTEDELETEWAIT flag 
        //
        
    }
    
    RemoveEntryList( &(pEntry->m_StoreListEntry) );

    delete pEntry;

    STORE_CHANGE_NOTIFIER::Unlock();

    // Call the notification functions now, after releasing the lock.  This
    // prevents deadlock with SSPIFILT.  In particular the scenario where:
    //
    // SSPIFILT__AddFullyQualifiedItem acquires SSPI then StoreChange
    // NotifyFncCaller acquires StoreChange then SSPI 
    //
    // should be avoided

    if ( pNotifFncChain )
    {
        NOTIF_FNC_CHAIN_ENTRY * pChainEntry = NULL;
        LIST_ENTRY *            pListEntry = NULL;
        
        //
        // Walk the list, call the functions and be generally studly ...
        //
        
        for ( pListEntry =  pNotifFncChain->Flink;
              pListEntry != pNotifFncChain;
              pListEntry = pListEntry->Flink )
        {
            pChainEntry = CONTAINING_RECORD( pListEntry, NOTIF_FNC_CHAIN_ENTRY,
                                                 ListEntry );
                
            if ( pChainEntry->pNotifFnc )
            {
#ifdef NOTIFICATION_DBG
                DBGPRINTF((DBG_CONTEXT,
                           "Calling notification fnc %p, arg %p\n",
                           pChainEntry->pNotifFnc, pChainEntry->pvParam));
#endif                                

                pChainEntry->pNotifFnc( pChainEntry->pvParam );

            }
        }
            
        DeallocateNotifFncChain( pNotifFncChain );
    }                

    return;
}

STORE_CHANGE_ENTRY::STORE_CHANGE_ENTRY( STORE_CHANGE_NOTIFIER *pNotifier,
                                        LPSTR pszStoreName,
                                        HCERTSTORE hStore,
                                        NOTIFFNCPTR pFncPtr,
                                        PVOID pvParam ) :
m_dwSignature( STORE_ENTRY_GOOD_SIG ),
m_pNotifier( pNotifier ),
m_dwRefCount( -1 ),
m_dwError( 0 ),
m_hCertStore( NULL ),
m_hStoreEvent( NULL ),
m_hWaitHandle( NULL ),
m_fDeleteMe( FALSE ),
m_fInvalid( FALSE ),
m_strStoreName( pszStoreName )
/*++

Routine Description:

  Constructor

Arguments:

  pNotifier - parent notifier object
  pszStoreName - name of store to be watched
  hStore - handle to store to be watched
  pFncPtr - notification function to call when store changes
  pvParam - arg to notification function

Returns:
  
  Nothing 

--*/
{
    PNOTIF_FNC_CHAIN_ENTRY pNewNotifFnEntry = NULL;

    INITIALIZE_CRITICAL_SECTION( &m_CS );

    InitializeListHead( &m_NotifFncChain );

    //
    // Duplicate store handle to watch
    //
    m_hCertStore = CertDuplicateStore( hStore );

    //
    // Create the event to be signalled when store changes
    //
    if ( !(m_hStoreEvent = CreateEvent( NULL, //default attributes,
                                        TRUE,
                                        FALSE, //initally non-signalled
                                        NULL ) ) ) //no name
    {
        m_dwError = GetLastError();
        return;
    }
        
    //
    // Register with wait thread pool
    //
#if 1
    if ( !NT_SUCCESS( RtlRegisterWait( &m_hWaitHandle,
                                       m_hStoreEvent,
                                       STORE_CHANGE_NOTIFIER::NotifFncCaller,
                                       (PVOID) this,
                                       INFINITE,
                                       WT_EXECUTEONLYONCE ) ) )
#else

    if ( !(m_hWaitHandle = RegisterWaitForSingleObjectEx( m_hStoreEvent, 
                                                        STORE_CHANGE_NOTIFIER::NotifFncCaller,
                                                        (PVOID) this,
                                                        INFINITE,
                                                        WT_EXECUTEONLYONCE ) ) )
#endif 
    {
        m_dwError = GetLastError();
        goto cleanup;
    }

    //
    // Register for change events on the store
    //
    if ( !CertControlStore( m_hCertStore,
                            0,
                            CERT_STORE_CTRL_NOTIFY_CHANGE,
                            (LPVOID) &m_hStoreEvent) )
    {
        m_dwError = GetLastError();
        goto cleanup;
    }


    //
    // Create a new chain of notification functions
    //
    pNewNotifFnEntry = new NOTIF_FNC_CHAIN_ENTRY;
    if ( !pNewNotifFnEntry )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Couldn't allocate new notification function chain : 0x%x\n",
                   GetLastError()));
        m_dwError = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    pNewNotifFnEntry->pNotifFnc = pFncPtr;
    pNewNotifFnEntry->pvParam = pvParam;

    //
    // Add the function to the chain
    //
    InsertTailList( &m_NotifFncChain, &pNewNotifFnEntry->ListEntry );              

    //
    // Increment number of entry objects, to help in cleanup later
    //
    STORE_CHANGE_ENTRY::IncrementStoreEntryCount();

cleanup:

    //
    // Cleanup that's only done on error
    //
    if ( m_dwError != 0 )
    {
        if ( m_hWaitHandle )
        {
            RtlDeregisterWait( m_hWaitHandle );
            m_hWaitHandle = NULL;
        }

        if ( m_hStoreEvent )
        {
            CloseHandle( m_hStoreEvent );
            m_hStoreEvent = NULL;
        }

        if ( m_hCertStore )
        {
            CertCloseStore( m_hCertStore,
                            0 );
            m_hCertStore = NULL;
        }

        //
        // Go through the chain of notification functions and clean it up
        //
        while ( !IsListEmpty(&(m_NotifFncChain)) )
        {
            NOTIF_FNC_CHAIN_ENTRY *pChainEntry = CONTAINING_RECORD( m_NotifFncChain.Flink,
                                                                    NOTIF_FNC_CHAIN_ENTRY,
                                                                    ListEntry );
            RemoveEntryList( &(pChainEntry->ListEntry) );
            
            delete pChainEntry;
        }
    }

}

STORE_CHANGE_ENTRY::~STORE_CHANGE_ENTRY()
/*++

Routine Description:

   Destructor 

Arguments:

   None

Return value:

   None
--*/

{
    DBG_ASSERT( CheckSignature() );

    //
    // No need to call RtlDeregisterWait() for the handle, since it's already been
    // deregistered [after having been used in the callback]
    //

    //
    // Clean up store change event
    //
    if ( m_hStoreEvent )
    {
        CloseHandle( m_hStoreEvent );
        m_hStoreEvent = NULL;
    }

    //
    // Close cert store
    //
    if ( m_hCertStore )
    {
        CertCloseStore( m_hCertStore,
                        0 );
        m_hCertStore = NULL;
    }

    //
    // Go through the chain of notification functions and clean it up
    //
    while ( !IsListEmpty(&(m_NotifFncChain)) )
    {
        NOTIF_FNC_CHAIN_ENTRY *pChainEntry = CONTAINING_RECORD( m_NotifFncChain.Flink,
                                                                NOTIF_FNC_CHAIN_ENTRY,
                                                                ListEntry );
        RemoveEntryList( &(pChainEntry->ListEntry) );

        delete pChainEntry;
    }

    DeleteCriticalSection( &m_CS );

    //
    // Another one bites the dust ...
    //
    STORE_CHANGE_ENTRY::DecrementStoreEntryCount();

    m_dwSignature = STORE_ENTRY_BAD_SIG;

}


BOOL STORE_CHANGE_ENTRY::ContainsNotifFnc( IN NOTIFFNCPTR pFncPtr,
                                           IN LPVOID pvParam )
/*++

Routine Description:

   Checks whether the given store watch entry contains the specified notification function with
   the specified args

Arguments:

  pFncPtr - pointer to notification function 
  pvParam - arg to notification function
Returns:
  
   True if function is found, false otherwise
--*/

{
    NOTIF_FNC_CHAIN_ENTRY *pChainEntry;
    LIST_ENTRY *pEntry = NULL;
    BOOL fFound = FALSE;

    Lock();

    for ( pEntry = m_NotifFncChain.Flink;
          pEntry != &m_NotifFncChain;
          pEntry = pEntry->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pEntry, NOTIF_FNC_CHAIN_ENTRY, ListEntry );

        if ( pChainEntry->pNotifFnc == pFncPtr && pChainEntry->pvParam == pvParam )
        {
            fFound = TRUE;
            break;
        }
    }

    Unlock();

    return fFound;
}    


BOOL STORE_CHANGE_ENTRY::AddNotifFnc( IN NOTIFFNCPTR pFncPtr,
                                      IN LPVOID pvParam )
/*++

Routine Description:

  Adds a notification function to a store entry

Arguments:

  pFncPtr - pointer to notification function 
  pvParam - arg to notification function

Returns:
  
   TRUE if function is added, FALSE otherwise
--*/

{
    PNOTIF_FNC_CHAIN_ENTRY pNewFnc = new NOTIF_FNC_CHAIN_ENTRY;
    
    if ( !pNewFnc )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to get new notif fnc entry : 0x%x\n",
                   GetLastError()));

        m_dwError = ERROR_OUTOFMEMORY;
        return FALSE;
    }

    pNewFnc->pNotifFnc = pFncPtr;
    pNewFnc->pvParam = pvParam;

    Lock();

    InsertTailList( &m_NotifFncChain, &pNewFnc->ListEntry );

    Unlock();

    return TRUE;
}

BOOL STORE_CHANGE_ENTRY::RemoveNotifFnc( IN NOTIFFNCPTR pFncPtr,
                                         IN LPVOID pvParam )
/*++

Routine Description:

  Removes a notification function from a store entry

Arguments:

  pFncPtr - pointer to notification function 
  pvParam - arg to notification function

Returns:
  
   Noting
--*/
{
    NOTIF_FNC_CHAIN_ENTRY *pChainEntry;
    LIST_ENTRY *pEntry = NULL;

    Lock();

    for ( pEntry = m_NotifFncChain.Flink;
          pEntry != &m_NotifFncChain;
          pEntry = pEntry->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pEntry, NOTIF_FNC_CHAIN_ENTRY, ListEntry );

        if ( pChainEntry->pNotifFnc == pFncPtr && pChainEntry->pvParam == pvParam )
        {
            RemoveEntryList( pEntry );

            break;
        }
    }
    
    Unlock();

    return TRUE;
}

BOOL STORE_CHANGE_ENTRY::Matches( IN LPSTR pszStoreName,
                                  IN NOTIFFNCPTR pFncPtr,
                                  IN PVOID pvParam )
/*++

Routine Description:

   Checks whether a given store change object matches the given store/function combination

Arguments:

    pszStoreName - name of cert store
    pFncPtr - pointer to notification function; may be INVALID_FNC_PTR if any function will match
    pvParam - parameter for function pointed to by pFncPtr

Return Value:

    TRUE if it matches, FALSE if not 

--*/
{
    BOOL fFound = FALSE;

    Lock();

    if ( ( ( m_strStoreName.IsEmpty() && pszStoreName == NULL) ||
            !strcmp(m_strStoreName.QueryStr(), pszStoreName)  ) && 
             ( pFncPtr == (NOTIFFNCPTR) INVALID_FNC_PTR || 
               ContainsNotifFnc( pFncPtr,
                                 pvParam ) ) )
    {
        fFound = TRUE;
    }

    Unlock();

    return fFound;
}


LIST_ENTRY* CopyNotifFncChain( LIST_ENTRY *pNotifFncChain )
/*++

Routine Description:

   Function that copies a chain of notification functions

Arguments:

   pNotifFncChain - pointer to chain to be copied

Return Value:

   Pointer to copied chain, NULL on failure 

--*/
{
    LIST_ENTRY *pNewChain = new LIST_ENTRY;

    if ( !pNewChain )
    {
        return NULL;
    }
    
    InitializeListHead( pNewChain );

    NOTIF_FNC_CHAIN_ENTRY *pChainEntry, *pNewChainEntry;
    LIST_ENTRY *pListEntry;
    
    for ( pListEntry = pNotifFncChain->Flink;
          pListEntry != pNotifFncChain;
          pListEntry = pListEntry->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pListEntry, NOTIF_FNC_CHAIN_ENTRY,
                                         ListEntry );
        
        
        pNewChainEntry = new NOTIF_FNC_CHAIN_ENTRY;
        
        if ( !pNewChainEntry )
        {
            DeallocateNotifFncChain( pNewChain );
            return NULL;
        }

        pNewChainEntry->pNotifFnc = pChainEntry->pNotifFnc;
        pNewChainEntry->pvParam = pChainEntry->pvParam;

        InsertTailList( pNewChain, &(pNewChainEntry->ListEntry) );
    }

    return ( pNewChain );
}




VOID DeallocateNotifFncChain( LIST_ENTRY *pChain )
/*++

Routine Description:

   Function that cleans up resources associated with a notification function chain

Arguments:

   pChain - chain to be cleaned up 

Return Value:

   None

--*/
{
    if ( !pChain )
    {
        return;
    }
    
    NOTIF_FNC_CHAIN_ENTRY *pChainEntry;
    LIST_ENTRY *pListEntry;
    

    while ( !IsListEmpty( pChain ) ) 
    {
        pChainEntry = CONTAINING_RECORD( pChain->Flink,
                                         NOTIF_FNC_CHAIN_ENTRY,
                                         ListEntry );

        RemoveEntryList( &(pChainEntry->ListEntry) );
        
        delete pChainEntry; 
    }

    delete pChain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\tsunami.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    tsunami.cxx

    This module contains most of the public Tsunami Cache routines.

    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>
#include <inetinfo.h>
#include <issched.hxx>
#include "inetreg.h"
#include "globals.hxx"
#include "tsunamip.hxx"
#include <inetsvcs.h>
#include "metacach.hxx"
#include "filecach.hxx"
#include "blobcach.hxx"
#include "atq.h"
#include "tracelog.h"
#include <lkrhash.h>
#include "filehash.hxx"
#include "blobhash.hxx"
#include "tlcach.h"
#include "etagmb.h"

BOOL  g_fCacheSecDesc = TRUE;

//
// from TsInit.cxx
//

HANDLE g_hQuit = NULL;
HANDLE g_hNewItem   = NULL;
BOOL g_fW3OnlyNoAuth = FALSE;
BOOL  TsNoDirOpenSupport = FALSE;


#if TSUNAMI_REF_DEBUG
PTRACE_LOG RefTraceLog;
#endif  // TSUNAMI_REF_DEBUG

//
//  The TTL to scavenge the cache and the id of the scheduled work item of the
//  next scheduled scavenge
//

DWORD g_cmsecObjectCacheTTL = (INETA_DEF_OBJECT_CACHE_TTL * 1000);
DWORD g_dwObjectCacheCookie = 0;

# define MIN_CACHE_SCAVENGE_TIME (5*1000) // 5 seconds


//
// Disables Tsunami Caching
//

BOOL DisableTsunamiCaching = FALSE;

//
// DisableSPUD
//

BOOL DisableSPUD = FALSE;

//
// Allows us to mask the invalid flags
//

DWORD TsValidCreateFileOptions = TS_IIS_VALID_FLAGS;

//
// from globals.cxx
//
CONFIGURATION Configuration;
BOOL          g_fDisableCaching = FALSE;


//
// Initialization and cleanup
//


BOOL
Tsunami_Initialize(
            VOID
            )
/*++
Routine Description:

    Sets up all the core caches.  Call this before using any
    cache routines.

Arguments:

    None.

Return Values:

    TRUE on success
--*/
{
    HRESULT hr;
    HKEY  hKey;
    DWORD dwType;
    DWORD nBytes;
    DWORD dwValue;
    DWORD dwMaxFile;
    DWORD err;

#if TSUNAMI_REF_DEBUG
    RefTraceLog = CreateRefTraceLog(
                      256,              // LogSize
                      0                 // ExtraBytesInHeader
                      );
#endif  // TSUNAMI_REF_DEBUG

    //
    // Initialize global events
    //

    g_hQuit = IIS_CREATE_EVENT(
                  "g_hQuit",
                  &g_hQuit,
                  TRUE,
                  FALSE
                  );

    g_hNewItem = IIS_CREATE_EVENT(
                     "g_hNewItem",
                     &g_hNewItem,
                     FALSE,
                     FALSE
                     );

    if ( (g_hQuit == NULL) || (g_hNewItem == NULL) ) {
        goto Failure;
    }

    //
    // Set defaults
    //

    MEMORYSTATUS ms;
    ms.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus( &ms );

    //
    // default is 1K files per 32MB of physical memory after the 1st 8MB,
    // minimum INETA_MIN_DEF_FILE_HANDLE
    //

    if ( ms.dwTotalPhys > 8 * 1024 * 1024 )
    {
        dwMaxFile = (DWORD)(ms.dwTotalPhys - 8 * 1024 * 1024) / ( 32 * 1024 );
        if ( dwMaxFile < INETA_MIN_DEF_FILE_HANDLE )
        {
            dwMaxFile = INETA_MIN_DEF_FILE_HANDLE;
        }
    }
    else
    {
        dwMaxFile = INETA_MIN_DEF_FILE_HANDLE;
    }

    //
    // If this is not a NTS, disable tsunami caching by default
    //

    DisableSPUD = !AtqSpudInitialized();


    if ( !TsIsNtServer() ) {
        DisableTsunamiCaching = TRUE;
        DisableSPUD = TRUE;
    }

    DisableSPUD = FALSE;

    //
    // no overlapped i/o in win95.
    //

    if ( TsIsWindows95() ) {
        TsCreateFileFlags = FILE_FLAG_SEQUENTIAL_SCAN;
        TsCreateFileShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
        TsNoDirOpenSupport = TRUE;
        // |FILE_FLAG_BACKUP_SEMANTICS;
    }

    //
    // Read the registry key to see whether tsunami caching is enabled
    //

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                INETA_PARAMETERS_KEY,
                0,
                KEY_READ,
                &hKey
                );

    if ( err == ERROR_SUCCESS ) {

        //
        // This cannot be overridded in win95
        //

        if ( !TsIsWindows95() ) {
            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                        hKey,
                        INETA_DISABLE_TSUNAMI_CACHING,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwValue,
                        &nBytes
                        );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                DisableTsunamiCaching = (BOOL)dwValue;
            }

            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                        hKey,
                        INETA_DISABLE_TSUNAMI_SPUD,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwValue,
                        &nBytes
                        );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                DisableSPUD = (BOOL)dwValue;
                if ( DisableSPUD ) {
                    DbgPrint("DisableCacheOplocks set to TRUE in Registry.\n");
                } else {
                    DbgPrint("DisableCacheOplocks set to FALSE in Registry.\n");
                }
                DbgPrint("The Registry Setting will override the default.\n");
            }

            //
            // How big do files have to be before we stop caching them
            //

            err = RegQueryValueEx(
                hKey,
                INETA_MAX_CACHED_FILE_SIZE,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &nBytes
                );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {

                g_liFileCacheByteThreshold.LowPart = dwValue;
            } else {

                g_liFileCacheByteThreshold.LowPart = INETA_DEF_MAX_CACHED_FILE_SIZE;
            }
            
            g_liFileCacheByteThreshold.HighPart = 0;    // Sorry Mr. > 4gb file.


            //
            // How big is the memory cache in megabytes
            //
            err = RegQueryValueEx(
                hKey,
                INETA_MEM_CACHE_SIZE,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &nBytes
                );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {

                //
                // set the size in megabytes
                //
                g_dwMemCacheSize = dwValue * (1024 * 1024);
            } else {

                g_dwMemCacheSize = INETA_DEF_MEM_CACHE_SIZE;
            }
            
            //
            // Do we use the sequential read flag to read files?
            //
            err = RegQueryValueEx(
                hKey,
                INETA_ENABLE_SEQUENTIAL_READ,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &nBytes
                );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {

                g_bEnableSequentialRead = dwValue ? 1 : 0;
            } else {

                g_bEnableSequentialRead = INETA_DEF_ENABLE_SEQUENTIAL_READ;
            }

        }

        if ( g_fW3OnlyNoAuth )
        {
            //
            // TODO: investigate is security descriptor caching
            // can be used in the non-SYSTEM account case.
            //

            g_fCacheSecDesc = FALSE;
        }
        else
        {
            //
            // read the enable cache sec desc flag
            //

            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                            hKey,
                            INETA_CACHE_USE_ACCESS_CHECK,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &nBytes
                            );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                g_fCacheSecDesc = !!dwValue;
            }
            else {
                 g_fCacheSecDesc = INETA_DEF_CACHE_USE_ACCESS_CHECK;
            }
        }

        //
        // Read the maximum # of files in cache
        //

        nBytes = sizeof(dwValue);
        if ( RegQueryValueEx(
                            hKey,
                            INETA_MAX_OPEN_FILE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwValue,
                            &nBytes
                            ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            dwMaxFile = dwValue;
        }

        RegCloseKey( hKey );

    }

    //
    // if tsunami caching is disabled, set the flags accordingly
    //

    if ( DisableTsunamiCaching ) {
        g_fDisableCaching = TRUE;
        TsValidCreateFileOptions = TS_PWS_VALID_FLAGS;
        g_fCacheSecDesc = FALSE;
    }

    //
    // Initialize the ETag Metabase Change Number
    //

    hr = ETagChangeNumber::Create();
    if ( FAILED(hr) ) {
        goto Failure;
    }

    //
    // Initialize the directory change manager
    //
    if ( !DcmInitialize( ) ) {
        goto Failure;
    }

    //
    // Initialize the tsunami cache manager
    //

    if ( !FileCache_Initialize( dwMaxFile )) {
        goto Failure;
    }


    if ( !MetaCache_Initialize() ) {
        goto Failure;
    }

    if ( !BlobCache_Initialize() ) {
        goto Failure;
    }

    return( TRUE );

Failure:

    IIS_PRINTF( ( buff, "Tsunami_Initialize() Failed. Error = %d\n",
                GetLastError()));

    if ( g_hQuit )
    {
        CloseHandle( g_hQuit );
        g_hQuit = NULL;
    }

    if ( g_hNewItem )
    {
        CloseHandle( g_hNewItem );
        g_hNewItem = NULL;
    }

    return FALSE;
} // Tsunami_Initialize

VOID
Tsunami_Terminate(
    VOID
    )
/*++
Routine Description:

    Cleans up all the core caches.

Arguments:

    None.

Return Values:

    None.
--*/
{
    DWORD dwResult;

    if ( !SetEvent( g_hQuit ) ) {
        IIS_PRINTF((buff,
                "No Quit event posted for Tsunami. No Cleanup\n"));
        return;
    }

    //
    //  Flush all items from the cache
    //

    TsCacheFlush( 0 );

    //
    //  Synchronize with our thread so we don't leave here before the
    //  thread has finished cleaning up
    //


    CloseHandle( g_hQuit );
    CloseHandle( g_hNewItem );


    BlobCache_Terminate();
    MetaCache_Terminate();
    FileCache_Terminate();
    DcmTerminate();

    ETagChangeNumber::Destroy();
    
#if TSUNAMI_REF_DEBUG
    if( RefTraceLog != NULL ) {
        DestroyRefTraceLog( RefTraceLog );
        RefTraceLog = NULL;
    }
#endif  // TSUNAMI_REF_DEBUG

} // Tsunami_Terminate


//
// Scavenger routines
//


BOOL
FileFlushFilterTTL(
    TS_OPEN_FILE_INFO * pFileInfo,
    PVOID               pv
    )
{
    if (pFileInfo->GetIORefCount()) {
        //
        // Try not to time out entries which are in use for I/O.
        //
        return FALSE;
    }

    if (pFileInfo->GetTTL() == 0) {
        pFileInfo->TraceCheckpointEx(TS_MAGIC_TIMEOUT, 0, 0);
        return TRUE;
    } else {
        if (pFileInfo->IsInitialized()) {
            pFileInfo->DecrementTTL();
        }
        return FALSE;
    }
}

BOOL
BlobFlushFilterTTL(
    PBLOB_HEADER pBlob,
    PVOID        pv
    )
{
    if (pBlob->TTL == 0) {
        pBlob->TraceCheckpointEx(TS_MAGIC_TIMEOUT, 0, 0);
        return TRUE;
    } else {
        pBlob->TTL--;
        return FALSE;
    }
}


VOID
WINAPI
CacheScavenger(
    VOID * pContext
    )
{
    FilteredFlushFileCache(FileFlushFilterTTL, NULL);
    FilteredFlushBlobCache(BlobFlushFilterTTL, NULL);
}


BOOL
InitializeCacheScavenger(
    VOID
    )
/*++
Routine Description:

    This function kicks off the scheduled tsunami object cache scavenger

Arguments:

    None.

Return Values:

    TRUE on success
--*/
{
    HKEY hkey;

    //
    //  Schedule a scavenger to close all of the objects that haven't been
    //  referenced in the last ttl
    //

    if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        INETA_PARAMETERS_KEY,
                        0,
                        KEY_READ,
                        &hkey ))
    {
        DWORD dwType;
        DWORD nBytes;
        DWORD dwValue;

        nBytes = sizeof(dwValue);
        if ( RegQueryValueEx(
                            hkey,
                            INETA_OBJECT_CACHE_TTL,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwValue,
                            &nBytes
                            ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            g_cmsecObjectCacheTTL = dwValue;
        } else {
            g_cmsecObjectCacheTTL = 0;
        }


        //
        //  Don't schedule anything if the scavenger should be disabled
        //

        if ( g_cmsecObjectCacheTTL == 0xffffffff )
        {
            RegCloseKey( hkey );
            return TRUE;
        }

        //
        //  The registry setting is in seconds, convert to milliseconds
        //

        g_cmsecObjectCacheTTL *= 1000;

        //
        //  Supply the default if no value was specified
        //

        if ( !g_cmsecObjectCacheTTL )
        {
            g_cmsecObjectCacheTTL = INETA_DEF_OBJECT_CACHE_TTL * 1000;
        }

        RegCloseKey( hkey );
    }

    //
    //  Require a minimum of thirty seconds
    //

    g_cmsecObjectCacheTTL = max( g_cmsecObjectCacheTTL,
                                 MIN_CACHE_SCAVENGE_TIME );

    g_dwObjectCacheCookie = ScheduleWorkItem(
                                        CacheScavenger,
                                        NULL,
                                        g_cmsecObjectCacheTTL,
                                        TRUE );     // Periodic

    if ( !g_dwObjectCacheCookie )
    {
        return FALSE;
    }

    return TRUE;
}

VOID
TerminateCacheScavenger(
    VOID
    )
/*++
Routine Description:

    Stops the cache scavenger
Arguments:

    None.

Return Values:

    None.
--*/
{
    if ( g_dwObjectCacheCookie )
    {
        RemoveWorkItem( g_dwObjectCacheCookie );
        g_dwObjectCacheCookie = 0;
    }
}


//
// Blob memory management
//


BOOL
TsAllocate(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN OUT  PVOID *         ppvNewBlock
    )
{
    return( TsAllocateEx(  TSvcCache,
                           cbSize,
                           ppvNewBlock,
                           NULL ) );
}

BOOL
TsAllocateEx(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN OUT  PVOID *         ppvNewBlock,
    OPTIONAL PUSER_FREE_ROUTINE pfnFreeRoutine
    )
/*++

  Routine Description:

      This function allocates a memory block for the calling server.

      The returned block is suitable for use as a parameter to
      TsCacheDirectoryBlob().  Blocks allocated by this function
      must either be cached or freed with TsFree().  Freeing of
      cached blocks will be handled by the cache manager.

      Anything allocated with this routine MUST be derived from
      BLOB_HEADER!

  Arguments:

      TSvcCache      - An initialized TSVC_CACHE structure.

      cbSize         - Number of bytes to allocate.  (Must be strictly
                       greater than zero.)

      ppvNewBlock    - Address of a pointer to store the new block's
                       address in.

      pfnFreeRoutine - pointer to a routine that will be called to
                       clean up the block when it is decached.

  Return Value:

      TRUE  - The allocation succeeded, and *ppvNewBlock points to
              at least cbSize accessable bytes.

      FALSE - The allocation failed.

--*/
{
    CBlobKey *   pBlobKey;
    PBLOB_HEADER pbhNewBlock;

    DBG_ASSERT( cbSize > 0 );
    DBG_ASSERT( ppvNewBlock != NULL );

    //
    // allocate the blob and the key while we're at it.
    //
    pBlobKey = (CBlobKey *) ALLOC(cbSize + sizeof(CBlobKey));

    if ( pBlobKey != NULL )
    {
        //
        //  If the allocation succeeded, we return a pointer to
        //  the new structure which is directly preceded by it's key.
        //

        pbhNewBlock = (PBLOB_HEADER) (pBlobKey + 1);
        *ppvNewBlock = ( PVOID )( pbhNewBlock );

        //
        //  Set up the BLOB_HEADER: Normal flags and stored allocation
        //  size.
        //

        pbhNewBlock->Signature      = TS_BLOB_SIGNATURE;
        pbhNewBlock->pBlobKey       = pBlobKey;

        pbhNewBlock->IsCached       = FALSE;
        pbhNewBlock->pfnFreeRoutine = pfnFreeRoutine;
        pbhNewBlock->lRefCount      = 0;
        pbhNewBlock->TTL            = 1;
        pbhNewBlock->pSecDesc       = NULL;
        pbhNewBlock->hLastSuccessAccessToken = INVALID_HANDLE_VALUE;

        pBlobKey->m_pszPathName = NULL;
        pBlobKey->m_cbPathName  = 0;
        pBlobKey->m_dwService   = TSvcCache.GetServiceId();
        pBlobKey->m_dwInstance  = TSvcCache.GetInstanceId();
        pBlobKey->m_dwDemux     = 0;

        pbhNewBlock->TraceCheckpointEx(TS_MAGIC_ALLOCATE, (PVOID) (ULONG_PTR) cbSize, pfnFreeRoutine);
    }
    else
    {
        //
        //  The allocation failed, and we need to return NULL
        //

        *ppvNewBlock = NULL;
        return FALSE;
    }

return TRUE;

}

BOOL
TsFree(
    IN const TSVC_CACHE &TSvcCache,
    IN      PVOID           pvOldBlock
    )
/*++

Routine Description:

    This function frees a memory block allocated with TsAllocate().

    Blocks that are currently cached cannot be freed with this
    function.

Arguments:

    TSvcCache      - An initialized TSVC_CACHE structure.


    pvOldBlock   - The address of the block to free.  (Must be
                   non-NULL.)

Return Value:

    TRUE  - The block was freed.  The pointer pvOldBlock is no longer
            valid.

    FALSE - The block was not freed.  Possible reasons include:

             -  pvOldBlock does not point to a block allocated with
                TsAllocate().

             -  pvOldBlock points to a block that has been cached
                with CacheDirectoryBlob().

             -  pServiceInfo does not point to a valid SERVICE_INFO
                structure.

--*/
{
    BOOL         bSuccess;
    PBLOB_HEADER pbhOldBlock;
    CBlobKey *   pRealOldBlock;

    DBG_ASSERT( pvOldBlock != NULL );

    //
    //  Adjust the input pointer to refer to the BLOB_HEADER.
    //

    pbhOldBlock = (( PBLOB_HEADER )pvOldBlock );

    DBG_ASSERT( TS_BLOB_SIGNATURE == pbhOldBlock->Signature );

    //
    // Track memory corruption in free builds.
    //

    if ( TS_BLOB_SIGNATURE != pbhOldBlock->Signature ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  If the Blob is currently in the cache, we can't free it.
    //  Check for this in the Blob's flags, and fail if it
    //  occurs.
    //

    if ( pbhOldBlock->IsCached )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "A service (%d) has attempted to TsFree a BLOB that it put in the cache.",
                    TSvcCache.GetServiceId() ));
        BREAKPOINT();

        bSuccess = FALSE;
    }
    else
    {
        pbhOldBlock->Signature = TS_FREE_BLOB_SIGNATURE;

        if ( pbhOldBlock->pfnFreeRoutine )
        {
            bSuccess = pbhOldBlock->pfnFreeRoutine( pvOldBlock );
        }
        else
        {
            bSuccess = TRUE;
        }

        if ( bSuccess )
        {
            //
            //  Free the memory used by the Blob.
            //
            pRealOldBlock = ((CBlobKey *) pvOldBlock) - 1;

            DBG_ASSERT( NULL == pRealOldBlock->m_pszPathName );

            pbhOldBlock->TraceCheckpointEx(TS_MAGIC_DELETE_NC,
                                           (PVOID) (ULONG_PTR) (pRealOldBlock->m_dwDemux),
                                           pbhOldBlock->pfnFreeRoutine);

            bSuccess = !!FREE( pRealOldBlock );


/*
            DEC_COUNTER( TSvcCache.GetServiceId(),
                         CurrentObjects );
 */
        }

    }

    return( bSuccess );
} // TsFree


//
// Standard cache operations
//

BOOL
TsCacheDirectoryBlob(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      ULONG                   cchDirectoryName,
    IN      ULONG                   iDemultiplexor,
    IN      PVOID                   pvBlob,
    IN      BOOLEAN                 bKeepCheckedOut,
    IN      PSECURITY_DESCRIPTOR    pSecDesc
    )
/*++

Routine Description:

    This function associates the Blob given as input with the specified
    directory and demultiplexing number.  Services should use this
    function to add a Blob to the cache.

    Callers must not cache the same Blob twice.  Once a Blob is cached,
    its contents must not be modified, and it must not be freed or re-cached.

Arguments:

    TSvcCache        - An initialized TSVC_CACHE structure.
    pszDirectoryName - The name that will be used as a key in the cache.
    iDemultiplexor   - Identifies the type of the object to be stored
    pvBlob           - Pointer to the actual object to be stored
    bKeepCheckedOut  - If TRUE, the caller can keep a reference to the cached object.
    pSecDesc         - An optional SECURITY_DESCRIPTOR that goes along with the object

Return Values:

    TRUE  - The block successfully added to the cache
    FALSE - The block could not be added to the cache

--*/
{
    BOOL bSuccess;
    PBLOB_HEADER pBlob = (PBLOB_HEADER)pvBlob;
    DBG_ASSERT( TS_BLOB_SIGNATURE == pBlob->Signature );

    //
    // set up the key
    //
    CBlobKey * pbk = pBlob->pBlobKey;
    DBG_ASSERT( NULL != pbk );

    pbk->m_cbPathName = cchDirectoryName;
    pbk->m_pszPathName = (PCHAR) ALLOC(pbk->m_cbPathName + 1);
    if (NULL != pbk->m_pszPathName) {
        memcpy(pbk->m_pszPathName, pszDirectoryName, pbk->m_cbPathName + 1);
    } else {
        pbk->m_cbPathName = 0;
        pbk->m_pszPathName = NULL;
        return FALSE;
    }

    IISstrupr( (PUCHAR)pbk->m_pszPathName );

    pbk->m_dwService = TSvcCache.GetServiceId();
    pbk->m_dwInstance = TSvcCache.GetInstanceId();
    pbk->m_dwDemux = iDemultiplexor;

    //
    // try to cache
    //

    bSuccess = CacheBlob(pBlob);

    if (bSuccess && !bKeepCheckedOut) {
        CheckinBlob(pBlob);
    }

    if (!bSuccess) {
        FREE(pbk->m_pszPathName);
        pbk->m_pszPathName = NULL;
        pbk->m_cbPathName = 0;
    }

    return bSuccess;
} // TsCacheDirectoryBlob


BOOL
TsDeCacheCachedBlob(
    PVOID   pBlobPayload
    )
/*++
Description:

    This function removes a blob payload object from the cache

Arguments:

    pCacheObject - Object to decache

Return Values:

    TRUE on success
--*/
{
    DecacheBlob( (PBLOB_HEADER)pBlobPayload );
    return TRUE;
}


BOOL
TsCheckOutCachedBlob(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      ULONG                   cchDirectoryName,
    IN      ULONG                   iDemultiplexor,
    IN      PVOID *                 ppvBlob,
    IN      HANDLE                  ,
    IN      BOOL                    ,
    IN      PSECURITY_DESCRIPTOR*   )
/*++
Routine Description:

    Searches the cache for a named cache entry. If the entry is found,
    it is checked out and returned to the caller.

Arguments:

    TSvcCache            - An initialized TSVC_CACHE structure.
    pszDirectoryName     - The name used as a key in the cache.
    iDemultiplexor       - Identifies the type of the object to be stored
    ppvBlob              - If the entry is found, a pointer to it will be
                           placed here.
    hAccessToken         - Optional parameter used to determine if the
                           caller is allowed to access the cached object.
    fMayCacheAccessToken - If this is TRUE, and the caller succesfully gains
                           access to the cached object, the hAccessToken will
                           be saved with the object in the cache.
    ppSecDesc            - If this is non-NULL, the caller will be given a
                           copy of the objects security descriptor.

Return Values:

    None.
--*/
{
    CHAR achUpName[MAX_PATH+1];
    BOOL bSuccess;

    //  People really do use this.
    //  DBG_ASSERT( ppSecDesc == NULL );

    //
    // Make sure the path is upper case
    //
    IISstrncpy(achUpName, pszDirectoryName, MAX_PATH);
    achUpName[MAX_PATH] = 0;
    cchDirectoryName = min(cchDirectoryName, MAX_PATH);

    IISstrupr( reinterpret_cast<PUCHAR>(achUpName) );

    bSuccess = CheckoutBlob(achUpName,
                            cchDirectoryName,
                            TSvcCache.GetServiceId(),
                            TSvcCache.GetInstanceId(),
                            iDemultiplexor,
                            (PBLOB_HEADER *) ppvBlob);

    if (bSuccess) {
        //
        // Security handled by the caller
        //
        ((PBLOB_HEADER)*ppvBlob)->TTL = 1;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
TsCheckInCachedBlob(
    IN      PVOID           pvBlob
    )
/*++
Routine Description:

    When a client is done with a blob it must check it back into the cache.

Arguments:

    pvBlob - The object to be checked in

Return Values:

    TRUE for success
--*/
{
    CheckinBlob((PBLOB_HEADER) pvBlob);

    return( TRUE );
} // TsCheckInCachedBlob


BOOL
TsCheckInOrFree(
    IN      PVOID           pvOldBlock
    )
/*++

Routine Description:

    This function checks in a cached memory block or
    frees a non-cached memory block allocated with TsAllocate().

Arguments:

    pvOldBlock   - The address of the block to free.  (Must be
                   non-NULL.)

Return Value:

    TRUE  - The block was freed.  The pointer pvOldBlock is no longer
            valid.

    FALSE - The block was not freed.  Possible reasons include:

             -  pvOldBlock does not point to a block allocated with
                TsAllocate().

--*/
{
    PBLOB_HEADER pBlob = (PBLOB_HEADER) pvOldBlock;
    TSVC_CACHE dummy;

    if (pBlob->IsCached) {
        CheckinBlob(pBlob);
    } else {
        TsFree(dummy, (PVOID)pBlob);
    }
    return( TRUE );
} // TsCheckInOrFree



BOOL
TsCacheFlushDemux(
    IN ULONG            iDemux
    )
/*++

  Routine Description:

    Flush all cache items whose demultiplexor matches that specified.

  Arguments:

    iDemux - Value of demux whose cache items are to be flushed.

--*/
{
    if (RESERVED_DEMUX_OPEN_FILE == iDemux) {
        FlushFileCache();
    } else {
        //
        // Only place where this function is called from is from odbc with
        // a demux of RESERVED_DEMUX_QUERY_CACHE.  We do not need to worry
        // about other cases
        //
        FlushBlobCache();
    }

    return TRUE;
} // TsCacheFlushDemux


BOOL
FlushFilterService(
    PBLOB_HEADER pBlob,
    PVOID        pv
    )
{
    DWORD dwServerMask = * (DWORD *)pv;
    return (pBlob->pBlobKey->m_dwService == dwServerMask);
}



BOOL
TsCacheFlush(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    This function flushes the blob cache of all items for the specified service
    or for all services if dwServerMask is zero.

--*/
{
    if (dwServerMask) {
        FilteredFlushBlobCache(FlushFilterService, &dwServerMask);
    } else {
        FlushBlobCache();
    }

    return TRUE;
} // TsCacheFlush


BOOL
FlushFilterUser(
    TS_OPEN_FILE_INFO *pOpenFile,
    PVOID              pv
    )
{
    HANDLE hUser = * (HANDLE *)pv;
    return (pOpenFile->QueryUser() == hUser);
}


BOOL
TsCacheFlushUser(
    IN  HANDLE      hUserToken,
    IN  BOOL        fDefer
    )
/*++

  Routine Description:

    This function flushes all file handles associated the passed user context

  Arguments:

    hUserToken - User token to flush from the cache
    fDefer - Build list but close handles later in worker thread (Not supported)

--*/
{
    FilteredFlushFileCache(FlushFilterUser, &hUserToken);

    return TRUE;
} // TsCacheFlushUser


typedef struct _FLUSH_URL_PARAM {
    PCSTR pszURL;
    DWORD cbURL;
    DWORD dwService;
    DWORD dwInstance;
} FLUSH_URL_PARAM;


BOOL
FlushFilterURL(
    PBLOB_HEADER pBlob,
    PVOID        pv
    )
{
    DBG_ASSERT( pBlob );
    DBG_ASSERT( pBlob->pBlobKey );

    FLUSH_URL_PARAM * fup = (FLUSH_URL_PARAM *)pv;
    CBlobKey * pbk = pBlob->pBlobKey;
    BOOL bAtRoot;

    //
    // If we're flushing everything, then don't bother
    // with the string comparison
    //
    bAtRoot = (fup->cbURL == 1) && (fup->pszURL[0] == '/');

    //
    // If the service, instance, and URL prefixes match then we flush.
    //
    return ( (pbk->m_dwService == fup->dwService)
             && (pbk->m_dwInstance == fup->dwInstance)
             && (bAtRoot
                || ((pbk->m_cbPathName >= fup->cbURL)
                   && (memcmp(pbk->m_pszPathName, fup->pszURL, fup->cbURL) == 0))) );
}


VOID
TsFlushURL(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszURL,
    IN      DWORD                   dwURLLength,
    IN      ULONG                   iDemultiplexor
    )
/*++

  Routine Description:

    This routine takes as input a URL and removes from the cache all cached
    objects that have the input URL as their prefix. This is mostly called
    when we get a change notify for metadata.

  Arguments

    TSvcCache               - Service cache
    pszURL                  - The URL prefix to be flushed.
    iDemultiplexor          - The demultiplexor for the caller's entries.

  Returns

    Nothing

--*/
{
    FLUSH_URL_PARAM fuparam;
    CHAR achUpName[MAX_PATH+1];

    //
    // It really only makes sense to flush the URI cache
    // with this function.
    //
    DBG_ASSERT( RESERVED_DEMUX_URI_INFO == iDemultiplexor );

    DBG_ASSERT( MAX_PATH >= dwURLLength );

    //
    // Make sure the path is upper case
    //
    IISstrncpy(achUpName, pszURL, MAX_PATH);
    achUpName[dwURLLength] = 0;

    IISstrupr( (PUCHAR) achUpName );

    fuparam.pszURL     = achUpName;
    fuparam.cbURL      = dwURLLength;
    fuparam.dwService  = TSvcCache.GetServiceId();
    fuparam.dwInstance = TSvcCache.GetInstanceId();

    FilteredFlushURIBlobCache(FlushFilterURL, &fuparam);
}


BOOL
TsExpireCachedBlob(
    IN const TSVC_CACHE &TSvcCache,
    IN      PVOID           pvBlob
    )
{
    DecacheBlob((PBLOB_HEADER) pvBlob);

    return TRUE;
} // TsExpireCachedBlob

//
// Misc cache management
//


BOOL
TsCacheQueryStatistics(
    IN  DWORD       Level,
    IN  DWORD       dwServerMask,
    IN  INETA_CACHE_STATISTICS * pCacheCtrs
    )
/*++

  Routine Description:

    This function returns the statistics for the global cache or for the
    individual services

  Arguments:

    Level - Only valid value is 0
    dwServerMask - Server mask to retrieve statistics for or 0 for the sum
        of the services
    pCacheCtrs - Receives the statistics for cache

  Notes:
    CacheBytesTotal and CacheBytesInUse are not kept on a per-server basis
        so they are only returned when retrieving summary statistics.

  Returns:

    TRUE on success, FALSE on failure
--*/
{
    if ( dwServerMask > LAST_PERF_CTR_SVC )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( g_pFileCacheStats
         && g_pURICacheStats
         && g_pBlobCacheStats
         && (dwServerMask == 0) ) {

        pCacheCtrs->FilesCached        = g_pFileCacheStats->GetFilesCached();
        pCacheCtrs->TotalFilesCached   = g_pFileCacheStats->GetTotalFilesCached();
        pCacheCtrs->FileHits           = g_pFileCacheStats->GetHits();
        pCacheCtrs->FileMisses         = g_pFileCacheStats->GetMisses();
        pCacheCtrs->FileFlushes        = g_pFileCacheStats->GetFlushes();
        pCacheCtrs->FlushedEntries     = g_pFileCacheStats->GetFlushedEntries();
        pCacheCtrs->TotalFlushed       = g_pFileCacheStats->GetTotalFlushed();

        pCacheCtrs->URICached          = g_pURICacheStats->GetBlobsCached();
        pCacheCtrs->TotalURICached     = g_pURICacheStats->GetTotalBlobsCached();
        pCacheCtrs->URIHits            = g_pURICacheStats->GetHits();
        pCacheCtrs->URIMisses          = g_pURICacheStats->GetMisses();
        pCacheCtrs->URIFlushes         = g_pURICacheStats->GetFlushes();
        pCacheCtrs->TotalURIFlushed    = g_pURICacheStats->GetTotalFlushed();

        pCacheCtrs->BlobCached         = g_pBlobCacheStats->GetBlobsCached();
        pCacheCtrs->TotalBlobCached    = g_pBlobCacheStats->GetTotalBlobsCached();
        pCacheCtrs->BlobHits           = g_pBlobCacheStats->GetHits();
        pCacheCtrs->BlobMisses         = g_pBlobCacheStats->GetMisses();
        pCacheCtrs->BlobFlushes        = g_pBlobCacheStats->GetFlushes();
        pCacheCtrs->TotalBlobFlushed   = g_pBlobCacheStats->GetTotalFlushed();

        QueryMemoryCacheStatistics( pCacheCtrs, FALSE ); 

    } else {
        //
        // Either we're reporting for a specific service
        // or stats are not set up. Set all cache
        // counters to zero.
        //
        pCacheCtrs->FilesCached = 0;
        pCacheCtrs->TotalFilesCached = 0;
        pCacheCtrs->FileHits = 0;
        pCacheCtrs->FileMisses = 0;
        pCacheCtrs->FileFlushes = 0;
        pCacheCtrs->FlushedEntries = 0;
        pCacheCtrs->TotalFlushed = 0;

        pCacheCtrs->URICached = 0;
        pCacheCtrs->TotalURICached = 0;
        pCacheCtrs->URIHits = 0;
        pCacheCtrs->URIMisses = 0;
        pCacheCtrs->URIFlushes = 0;
        pCacheCtrs->TotalURIFlushed = 0;

        pCacheCtrs->BlobCached = 0;
        pCacheCtrs->TotalBlobCached = 0;
        pCacheCtrs->BlobHits = 0;
        pCacheCtrs->BlobMisses = 0;
        pCacheCtrs->BlobFlushes = 0;
        pCacheCtrs->TotalBlobFlushed = 0;
        
        QueryMemoryCacheStatistics( pCacheCtrs, TRUE );
    }

    return TRUE;
}

BOOL
TsCacheClearStatistics(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    Clears the the specified service's statistics

--*/
{
    if ( dwServerMask > LAST_PERF_CTR_SVC )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Currently this function isn't supported
    //

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
} // TsCacheClearStatistics



const char * g_IISAuxCounterNames[] =
{
    "Aac Open URI Files",
    "Cac Calls to TsOpenURI()",
    "Cac Calls to TsCloseURI()",
    "Max Counters"
};



extern "C"
VOID
TsDumpCacheCounters( OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer )
{
    DWORD  cb = 0;

    *lpcbBuffer = cb;
    return ;
} // TsDumpCacheCounters()






VOID
TsDumpHashTableStats( IN OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer )
{
    CLKRHashTableStats hts;

    if (!g_pFileInfoTable) {
        *lpcbBuffer = 0;
        return;
    }

    hts = g_pFileInfoTable->GetStatistics();

    *lpcbBuffer = sprintf( pchBuffer,
                           "<TABLE>"
                           "<TR><TD>Record Count</TD><TD>%d</TD></TR>"
                           "<TR><TD>Table Size</TD><TD>%d</TD></TR>"
                           "<TR><TD>Directory Size</TD><TD>%d</TD></TR>"
                           "<TR><TD>Longest Chain</TD><TD>%d</TD></TR>"
                           "<TR><TD>Empty Slots</TD><TD>%d</TD></TR>"
                           "<TR><TD>Split Factor</TD><TD>%f</TD></TR>"
                           "<TR><TD>Average Search Length</TD><TD>%f</TD></TR>"
                           "<TR><TD>Expected Search Length</TD><TD>%f</TD></TR>"
                           "<TR><TD>Average Unsuccessful Search Length</TD><TD>%f</TD></TR>"
                           "<TR><TD>Expected Unsuccessful Search Length</TD><TD>%f</TD></TR>"
                           "</TABLE>",
                           hts.RecordCount,
                           hts.TableSize,
                           hts.DirectorySize,
                           hts.LongestChain,
                           hts.EmptySlots,
                           hts.SplitFactor,
                           hts.AvgSearchLength,
                           hts.ExpSearchLength,
                           hts.AvgUSearchLength,
                           hts.ExpUSearchLength );

}

VOID
TsDumpCacheToHtml( OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer )
{
    LIST_ENTRY * pEntry;
    DWORD        cItemsOnBin = 0;
    DWORD        cTotalItems = 0;
    DWORD        i, c, cb;
    DWORD        cbTable;

    cb = wsprintf( pchBuffer,
                   " <h4>File Hash Table Stats</h4> " );

    TsDumpHashTableStats( pchBuffer + cb, &cbTable );
    cb += cbTable;

    cb += wsprintf( pchBuffer + cb,
                    " <h4>Some other stats</h4> ");

    if (g_pFileCacheStats) {
        g_pFileCacheStats->DumpToHtml(pchBuffer + cb, &cbTable);
        cb += cbTable;
    }
    
    DumpMemoryCacheToHtml( pchBuffer + cb, &cbTable );
    cb += cbTable;
    
    *lpcbBuffer = cb;

    return;
}  // TsDumpCacheToHtml()


//
// tsunami.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\capiutil.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    capiutil.cxx

Abstract:

    Utility functions for dealing with IIS-CAPI integration

Author:

    Alex Mallet (amallet)    02-Dec-1997

--*/

#include "tcpdllp.hxx"
#pragma hdrstop

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

//
// Local includes
//
#include "iiscert.hxx"
#include "capiutil.hxx"



BOOL RetrieveBlobFromMetabase(MB *pMB,
                              LPTSTR pszKey IN,
                              PMETADATA_RECORD pMDR OUT,
                              DWORD dwSizeHint OPTIONAL)
/*++

Routine Description:

    Tries to retrieve a value of variable length from the metabase

Arguments:

    pMB - pointer to open MB object
    pszKey - key whose value is to be read
    pMDR - pointer to metadata record to be used when reading the value. The pbMDData member
    will be updated on success
    dwSizeHint - if caller has idea of how big value might be, can set this to number of 
    bytes to try first retrieval call with

Returns:

   BOOL indicating whether value was read successfully

--*/
{
    BOOL fSuccess = FALSE;

    //
    // If caller has a clue, let's use it
    //
    if ( dwSizeHint )
    {
        pMDR->pbMDData = new UCHAR[dwSizeHint];

        if ( !(pMDR->pbMDData) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    pMDR->dwMDDataLen = (dwSizeHint ? dwSizeHint : 0);

    fSuccess = pMB->GetData( pszKey,
                             pMDR->dwMDIdentifier,
                             pMDR->dwMDUserType,
                             pMDR->dwMDDataType,
                             (VOID *) pMDR->pbMDData,
                             &(pMDR->dwMDDataLen),
                             pMDR->dwMDAttributes );
                             
                             
    if ( !fSuccess )
    {
        //
        // If buffer wasn't big enough, let's try again ...
        //
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            // We were brought up well, so we'll clean stuff up
            //
            if ( dwSizeHint )
            {
                delete [] pMDR->pbMDData;
            }

            pMDR->pbMDData = new UCHAR[pMDR->dwMDDataLen];

            if ( !(pMDR->pbMDData) )
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }

            fSuccess = pMB->GetData( pszKey,
                                     pMDR->dwMDIdentifier,
                                     pMDR->dwMDUserType,
                                     pMDR->dwMDDataType,
                                     (VOID *) pMDR->pbMDData,
                                     &(pMDR->dwMDDataLen),
                                     pMDR->dwMDAttributes );

            if ( !fSuccess )
            {
                //ah, sod it, can't do anymore
                delete [] pMDR->pbMDData;
                return FALSE;
            }
        }
    }

    if ( !fSuccess )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "RetrieveBlobFromMB failed, 0x%x\n", GetLastError()));
    }

    return fSuccess;

} //RetrieveBlobFromMetabase


BOOL CopyString( OUT LPTSTR *ppszDest,
                 IN LPTSTR pszSrc )
/*++

Routine Description:

   String-copy that uses "new" for memory allocation

Arguments:

   ppszDest - pointer to pointer to dest string
   pszSrc - pointer to source string

--*/

{
    if ( !pszSrc )
    {
        *ppszDest = NULL;
        return TRUE;
    }

    *ppszDest = new char[strlen(pszSrc) + 1];

    if ( !*ppszDest )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    memcpy( *ppszDest, pszSrc, strlen(pszSrc) + 1 );

    return TRUE;
}


OPEN_CERT_STORE_INFO* ReadCertStoreInfoFromMB( IN IMDCOM *pMDObject,
                                               IN LPTSTR pszMBPath,
                                               IN BOOL fCTL )
/*++

Routine Description:

    Read all the information necessary to open a CAPI store out of the metabase

Arguments:

    pMDObject - pointer to metabase object 
    pszMBPath - full path in metabase where cert store info is stored, starting from /
    fCTL - bool indicating whether info is to be used to reconstruct a CTL or a cert 

Returns:

   Pointer to filled out OPEN_CERT_STORE_INFO structure on success, NULL on failure.
   Note that only some of the OPEN_CERT_STORE_INFO fields are -required-; currently,
   only the store name is required. 

--*/

{
    DBG_ASSERT( pMDObject );
    DBG_ASSERT( pszMBPath );

    MB mb( pMDObject );
    BOOL fSuccess = FALSE;
    OPEN_CERT_STORE_INFO *pCertStoreInfo = NULL;

    pCertStoreInfo = AllocateCertStoreInfo();

    if ( !pCertStoreInfo )
    {
        return NULL;
    }

    //
    // Try to open the key for reading
    //
    if ( mb.Open( pszMBPath,
                  METADATA_PERMISSION_READ ))
    {
        DWORD dwReqDataLen = 0;
        METADATA_RECORD mdr;
     
        //
        //Try to retrieve container
        //
        MD_SET_DATA_RECORD(&mdr, 
                           (fCTL ? MD_SSL_CTL_CONTAINER : MD_SSL_CERT_CONTAINER), 
                           METADATA_NO_ATTRIBUTES, 
                           IIS_MD_UT_SERVER, STRING_METADATA, 
                           NULL,
                           0);
        
        if ( RetrieveBlobFromMetabase(&mb,
                                      NULL,
                                      &mdr) )

        {
            //
            // Metabase will return empty string if NULL string is stored
            //
            if ( !strcmp( (LPTSTR) mdr.pbMDData, TEXT("")) )
            {
                delete [] mdr.pbMDData;
                pCertStoreInfo->pszContainer = NULL;
            }
            else
            {
                pCertStoreInfo->pszContainer = (LPTSTR) mdr.pbMDData;
            }
        }

        //
        //Try to retrieve cert provider
        //
        MD_SET_DATA_RECORD(&mdr, 
                           (fCTL ? MD_SSL_CTL_PROVIDER : MD_SSL_CERT_PROVIDER), 
                           METADATA_NO_ATTRIBUTES, 
                           IIS_MD_UT_SERVER, STRING_METADATA, 
                           NULL,
                           0);
        
        if ( RetrieveBlobFromMetabase(&mb,
                                      NULL,
                                      &mdr) )


        {
            //
            // Metabase will return empty string if NULL string is stored
            //
            if ( !strcmp( (LPTSTR) mdr.pbMDData, TEXT("")) )
            {
                delete [] mdr.pbMDData;
                pCertStoreInfo->pszProvider = NULL;
            }
            else
            {
                pCertStoreInfo->pszProvider = (LPTSTR) mdr.pbMDData;
            }
        }

        //
        //Try to retrieve provider type
        //
        mb.GetDword( NULL,
                     (fCTL ? MD_SSL_CTL_PROVIDER_TYPE : MD_SSL_CERT_PROVIDER_TYPE),
                     IIS_MD_UT_SERVER,
                     &(pCertStoreInfo->dwProvType),
                     METADATA_NO_ATTRIBUTES );

        //
        //Retrieve open flags
        //
        mb.GetDword( NULL,
                     (fCTL ? MD_SSL_CTL_OPEN_FLAGS : MD_SSL_CERT_OPEN_FLAGS),
                     IIS_MD_UT_SERVER,
                     &(pCertStoreInfo->dwFlags),
                     METADATA_NO_ATTRIBUTES ) ;

        //
        //Try to retrieve store name
        //
        MD_SET_DATA_RECORD(&mdr, 
                           (fCTL ? MD_SSL_CTL_STORE_NAME : MD_SSL_CERT_STORE_NAME), 
                           METADATA_NO_ATTRIBUTES, 
                           IIS_MD_UT_SERVER, STRING_METADATA, 
                           NULL,
                           0);

        if ( !RetrieveBlobFromMetabase(&mb,
                                       NULL,
                                       &mdr) )

        {
            goto EndReadStoreInfo;
        }
        else
        {
            //
            // Metabase will return empty string if NULL string is stored, but
            // empty name is -NOT- valid !
            //
            if ( !strcmp( (LPTSTR) mdr.pbMDData, TEXT("")) )
            {
                delete [] mdr.pbMDData;
                goto EndReadStoreInfo;
            }
            else
            {
                pCertStoreInfo->pszStoreName = (LPTSTR) mdr.pbMDData;
            }
        }

        //
        // Everything succeeded
        //
        fSuccess = TRUE;
    }

EndReadStoreInfo:

    if ( !fSuccess )
    {
        DeallocateCertStoreInfo( pCertStoreInfo );
        pCertStoreInfo = NULL;
    }

    return ( pCertStoreInfo );
}


OPEN_CERT_STORE_INFO* AllocateCertStoreInfo()
/*++

Routine Description:

   Allocate and initialize the structure used to hold info about cert stores

Arguments:

   None

Returns:

   Allocated and initialized structure that should be cleaned up with a call to 
   DeallocateCertStoreInfo()

--*/
{
    OPEN_CERT_STORE_INFO *pStoreInfo = new OPEN_CERT_STORE_INFO;

    if ( pStoreInfo )
    {
        memset(pStoreInfo, 0, sizeof(OPEN_CERT_STORE_INFO));
    }

    return pStoreInfo;
}

VOID DeallocateCertStoreInfo( OPEN_CERT_STORE_INFO *pInfo )
/*++

Routine Description:

    Clean up the structure used to track information about a cert store

Arguments:

    pInfo - pointer to OPEN_CERT_STORE_INFO structure to be cleaned up

Returns:

   Nothing

--*/

{
    if ( !pInfo )
    {
        return ;
    }

    if ( pInfo->pszContainer )
    {
        delete [] pInfo->pszContainer;
        pInfo->pszContainer = NULL;
    }

    if ( pInfo->pszProvider )
    {
        delete pInfo->pszProvider;
        pInfo->pszProvider = NULL;
    }

    if ( pInfo->pszStoreName )
    {
        delete [] pInfo->pszStoreName;
        pInfo->pszStoreName = NULL;
    }

    if ( pInfo->hCertStore )
    {
        CertCloseStore( pInfo->hCertStore,
                        0 );
        pInfo->hCertStore = NULL;
    }

    delete pInfo;

}


BOOL
DuplicateCertStoreInfo( OUT OPEN_CERT_STORE_INFO **ppDestStoreInfo,
                        IN OPEN_CERT_STORE_INFO *pSrcStoreInfo )
/*++

Routine Description:

    Make a copy of cert store info

Arguments:

   ppDestStoreInfo - pointer to where copy of pSrcStoreInfo is to be placed
   pSrcStoreInfo - information to be copied

Returns:

   TRUE if copy was successful, FALSE if not

--*/


{
    *ppDestStoreInfo = NULL;
    OPEN_CERT_STORE_INFO *pNewStore = AllocateCertStoreInfo();

    if ( !pNewStore )
    {
        SetLastError( ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    //
    // Copy the relevant items
    //
    if ( pSrcStoreInfo->pszContainer && 
         !CopyString( &pNewStore->pszContainer,
                      pSrcStoreInfo->pszContainer ) )
    {
        goto EndDuplicateInfo;
    }

    if ( pSrcStoreInfo->pszProvider && 
         !CopyString( &pNewStore->pszProvider,
                      pSrcStoreInfo->pszProvider ) )
    {
        goto EndDuplicateInfo;
    }

    //
    // Store name -cannot- be NULL
    //
    if ( !pSrcStoreInfo->pszStoreName )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Null store name !\n"));
        goto EndDuplicateInfo;
    }
    else if ( !CopyString( &pNewStore->pszStoreName,
                           pSrcStoreInfo->pszStoreName ) )
    {
        goto EndDuplicateInfo;
    }

    pNewStore->dwFlags = pSrcStoreInfo->dwFlags;
    pNewStore->dwProvType = pSrcStoreInfo->dwProvType;

    //
    // Duplicate the handle to the store
    //
    if ( !( pNewStore->hCertStore = CertDuplicateStore(pSrcStoreInfo->hCertStore) ))
    {
        goto EndDuplicateInfo;
    }


    //
    // Everything is happy, fill in the pointer
    //
    *ppDestStoreInfo = pNewStore;

EndDuplicateInfo:


    if ( !(*ppDestStoreInfo) )
    {
        DeallocateCertStoreInfo( pNewStore );
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


BOOL ServerAddressHasCAPIInfo( IN MB *pMB,
                               IN LPTSTR pszCredPath,
                               IN DWORD *adwProperties,
                               IN DWORD cProperties )
/*++

Routine Description:

    Checks whether the given MB path has info associated with it necessary to 
    reconstruct a particular CAPI structure eg certificate context, CTL context

Arguments:

     pMB - pointer to metabase object open for reading
     pszCredPath - path to where CAPI info would be stored, relative to pMB object
     adwProperties - array of metabase properties that must exist and be readable for the
     given CAPI object 
     cProperties - number of elements in pdwProperties array [ = 2 * # of properties]
Returns:

    TRUE if cert info exists, FALSE if not

--*/
{

    DBG_ASSERT( pMB );
    DBG_ASSERT( pszCredPath );

    BOOL fAllocated = FALSE;
    BOOL fAllData = TRUE;


    //
    // Iterate through each property, trying to retrieve it with a buffer size of zero;
    // If retrieving a property fails for any reason other than a buffer that's too 
    // small, assume the property doesn't exist
    //
    for (DWORD i = 0; i < cProperties/2; i++)
    {
        DWORD dwSize = 0;

        pMB->GetData( pszCredPath,
                      adwProperties[2*i],
                      IIS_MD_UT_SERVER,
                      adwProperties[2*i + 1],
                      NULL,
                      &dwSize,
                      METADATA_NO_ATTRIBUTES );
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER  )
        {
            fAllData = FALSE;
            break;
        }
    }

    return fAllData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\virtroot.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

       virtroot.cxx

   Abstract:

       This module defines functions for managing virtual roots.

   Author:

      ???                  ( ???)      ??-??-1994/5

   Environment:

      User Mode -- Win32
   Project:

       TSunami DLL for Internet Services

   Functions Exported:



   Revision History:

       MuraliK         Added File System type to information stored about
                          each virtual root.
       MuraliK         Modified TsLookupVirtualRoot() to support variable
                          length buffer and hence check for invalid writes

       MuraliK    22-Jan-1996  Cache & return UNC virtual root impersonation
                                   token.
       MCourage   05-Jan-1997  Moved to cache2 directory for cache rewrite

       SaurabN    07-Oct-1998  Reimplement using LKRHash.
--*/



/************************************************************
 *     Include Headers
 ************************************************************/

#include <tsunami.hxx>
#include "TsunamiP.Hxx"
#pragma hdrstop

#include <mbstring.h>
#include <rpc.h>
#include <rpcndr.h>
#include "dbgutil.h"
#include <string.h>
#include <refb.hxx>
#include <imd.h>
#include <mb.hxx>
#include <iiscnfg.h>
#include <malloc.h>


IIS_VROOT_TABLE::IIS_VROOT_TABLE(
                            VOID
                            )
:
    CLKRHashTable("IISVRootTable",
                  ExtractKey,
                  CalcKeyHash,
                  EqualKeys,
                  AddRefRecord,
                  DFLT_LK_INITSIZE,
                  LK_SMALL_TABLESIZE),
    m_nVroots           (0 )
{

} // IIS_VROOT_TABLE::IIS_VROOT_TABLE



IIS_VROOT_TABLE::~IIS_VROOT_TABLE(
                            VOID
                            )
{
    RemoveVirtualRoots( );
    DBG_ASSERT( m_nVroots == 0 );

} // IIS_VROOT_TABLE::~IIS_VROOT_TABLE




BOOL
IIS_VROOT_TABLE::AddVirtualRoot(
    PCHAR                  pszRoot,
    PCHAR                  pszDirectory,
    DWORD                  dwAccessMask,
    PCHAR                  pszAccountName,
    HANDLE                 hImpersonationToken,
    DWORD                  dwFileSystem,
    BOOL                   fDoCache
    )
/*++
    Description:

        This function adds a symbolic link root and directory mapping
        part to the virtual root list

        We always strip trailing slashes from the root and directory name.

        If the root is "\" or "/", then the effective root will be zero
        length and will always be placed last in the list.  Thus if a lookup
        can't find a match, it will always match the last entry.

    Arguments:
        pszRoot - Virtual symbolic link root
        pszDirectory - Physical directory
        dwAccessMask - Type of access allowed on this virtual root
        pszAccountName - User name to impersonate if UNC (only gets stored
            for RPC apis)
        hImpersonationToken - Impersonation token to use for UNC
                                directory paths
        dwFileSystem - DWORD containing the file system type
                      ( symbolic constant)
        fDoCache - Should we cache the vdir

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    PVIRTUAL_ROOT_MAPPING   pVrm, pVrmOld;
    PLIST_ENTRY             pEntry;
    BOOL                    fRet = FALSE;
    BOOL                    fUNC;
    DWORD                   cchRoot;

    if ( !pszRoot || !pszDirectory || !*pszDirectory )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Disallow allow UNC roots if we don't have an impersonation token and
    //  this isn't a placeholder
    //

    fUNC = (BOOL)((pszDirectory[0] == '\\') && (pszDirectory[1] == '\\'));

    //
    //  Strip the trailing '/' from the virtual root
    //

    cchRoot = strlen( pszRoot );

    if ( IS_CHAR_TERM_A( pszRoot, cchRoot - 1))
    {
        pszRoot[--cchRoot] = '\0';
    }

    //
    //  Look in the current list and see if the root is already there.
    //  If the directory is the same, we just return success.  If the
    //  directory is different, we remove the old item and add the new one.
    //

    LockShared();

    if (LK_SUCCESS == FindKey((DWORD_PTR) pszRoot, (const void **)&pVrm))
    {
        //
        // Key exists
        //
        
        if ( !lstrcmpi( pszDirectory, pVrm->pszDirectoryA ) &&
             IS_CHAR_TERM_A( pszDirectory, pVrm->cchDirectoryA ))
        {
            //
            //  This root is already in the list
            //

            Unlock();
            return TRUE;

        } 
        else
        {

            //
            //  A root is having its directory entry changed
            //

            Unlock();
            SetLastError( ERROR_NOT_SUPPORTED );
            return FALSE;
        }
    }

    //
    // Add a new key
    //
    
    pVrm = ( PVIRTUAL_ROOT_MAPPING )ALLOC( sizeof( VIRTUAL_ROOT_MAPPING ) );

    if ( pVrm == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        Unlock();
        return FALSE;
    }

    //
    //  Initialize the new root item
    //

    pVrm->Signature     = VIRT_ROOT_SIGNATURE;
    pVrm->cchRootA      = strlen( pszRoot );

    if (pVrm->cchRootA > MAX_LENGTH_VIRTUAL_ROOT)
    {
       SetLastError( ERROR_BAD_PATHNAME );
       Unlock();
       return FALSE;
    }
      
    pVrm->cchDirectoryA = strlen( pszDirectory );
    if (pVrm->cchDirectoryA > MAX_PATH)
    {
       SetLastError( ERROR_BAD_PATHNAME );
       Unlock();
       return FALSE;
    }
    
    pVrm->dwFileSystem  = dwFileSystem;
    pVrm->dwAccessMask  = dwAccessMask;

    pVrm->fUNC                = (BOOLEAN)fUNC;
    pVrm->hImpersonationToken = hImpersonationToken;

    //
    //  The old cache design used APCs to do change notification, the new cache 
    //  uses the CDirMon class so we don't need any refcounting.
    //

    strcpy( pVrm->pszRootA, pszRoot );
    strcpy( pVrm->pszDirectoryA, pszDirectory );
    strcpy( pVrm->pszAccountName, pszAccountName ? pszAccountName : "" );

    //
    //  Strip trailing slashes from the root and directory
    //

    if ( (pVrm->cchRootA != 0) &&
         IS_CHAR_TERM_A( pVrm->pszRootA, pVrm->cchRootA - 1 ))
    {
        pVrm->pszRootA[--pVrm->cchRootA] = '\0';
    }

    if ( IS_CHAR_TERM_A( pVrm->pszDirectoryA, pVrm->cchDirectoryA - 1))
    {
        //
        //  Note we assume virtual directories always begin with a '/...' to
        //  provide the necessary path separator between the root directory
        //  path and the remaining virtual directory
        //

        pVrm->pszDirectoryA[--pVrm->cchDirectoryA] = '\0';
    }

    //
    //  Add the item to the list
    //

    LockConvertExclusive();
    
    fRet = (LK_SUCCESS == InsertRecord(pVrm));
    
    if (fRet)
    {
        fRet = fDoCache ? DcmAddRoot( pVrm ) : TRUE;

        if (!fRet)
        {
            DeleteRecord(pVrm);
        }
    }
    
    if ( fRet)
    {
        m_nVroots++;
        
        IF_DEBUG( VIRTUAL_ROOTS )
                DBGPRINTF(( DBG_CONTEXT,
                        "Successfully added Vroot - %s => %s\n",
                        pVrm->pszRootA,
                        pVrm->pszDirectoryA ));
    }
    else
    {
        FREE( pVrm );
/*      
        //
        // this memory was already released!
        //
        DBGPRINTF(( DBG_CONTEXT,
                    " Error %d adding Vroot - %s => %s\n",
                    GetLastError(),
                    pVrm->pszRootA,
                    pVrm->pszDirectoryA ));
 */
    }

    Unlock();
    return fRet;
    
} // IIS_VROOT_TABLE::AddVirtualRoot



BOOL
IIS_VROOT_TABLE::LookupVirtualRoot(
    IN     const CHAR *       pszVirtPath,
    OUT    CHAR *             pszDirectory,
    IN OUT LPDWORD            lpcbSize,
    OUT    LPDWORD            lpdwAccessMask,        // Optional
    OUT    LPDWORD            pcchDirRoot,           // Optional
    OUT    LPDWORD            pcchVRoot,             // Optional
    OUT    HANDLE   *         phImpersonationToken,  // Optional
    OUT    LPDWORD            lpdwFileSystem         // Optional
    )
/*++
    Description:

        This function looks in the map list for the specified root
        and returns the corresponding directory

    Arguments:
        pszVirtPath - Virtual symbolic link path
        pszDirectory - receives Physical directory.
                    This is of the size specified by lpcbSize
        lpcbSize - pointer to DWORD containing the size of buffer pszDirectory
                     On retur contains the number of bytes written
        lpdwAccessMask - The access mask for this root
        pcchDirRoot - Number of characters of the directory this virtual
            root maps to (i.e., /foo/ ==> c:\root, lookup "/foo/bar/abc.htm"
            this value returns the length of "c:\root")
        pcchVRoot - Number of characters that made up the found virtual root
            (i.e., returns the lenght of "/foo/")
        phImpersonationToken - pointer to handle object that will contain
           the handle to be used for impersonation for UNC/secure virtual roots
        lpdwFileSystem - on successful return will contain the file system
                        type for the directory matched with root specified.

    Returns:
        TRUE on success and FALSE if any failure.

    History:
        MuraliK     28-Apr-1995   Improved robustness
        MuraliK     18-Jan-1996   Support imperonstaion token

    Note:
       This function is growing in the number of parameters returned.
       Maybe we should expose the VIRTUAL_ROOT_MAPPING structure
         and return a pointer to this object and allow the callers to
         extract all required pieces of data.

--*/
{
    DWORD    dwError = NO_ERROR;
    PVIRTUAL_ROOT_MAPPING   pVrm = NULL;

    DBG_ASSERT( pszDirectory != NULL);
    DBG_ASSERT( lpcbSize != NULL);

    DWORD cchPath = strlen( pszVirtPath );

    char * pszPath = (char *)_alloca(cchPath);  // make local copy that we can modify

    strcpy(pszPath, pszVirtPath);

    //
    //  Strip the trailing '/' from the virtual path
    //

    if ( IS_CHAR_TERM_A( pszPath, cchPath - 1))
    {
        pszPath[--cchPath] = '\0';
    }

    char * pCh = pszPath;

    LockShared();
            
    while(pCh != NULL)
    {
        if (LK_SUCCESS == FindKey((DWORD_PTR) pszPath, (const void **)&pVrm))
        {
            break;
        }
        else
        {
            //
            // Trim the VRoot path from the right to the next /
            //

            pCh = (char *)IISstrrchr( (const UCHAR *)pszPath, '/');

            if (pCh)
            {
                *pCh = '\0';    // truncate search string
            }
        }
    }

    if (pVrm)
    {

        //
        //  we found a match. return all requested parameters.
        //
        
        DBG_ASSERT( pVrm->Signature == VIRT_ROOT_SIGNATURE );

        DWORD cbReqd = ( pVrm->cchDirectoryA +
                         strlen(pszVirtPath + pVrm->cchRootA));

        if ( cbReqd <= *lpcbSize) 
        {

            PCHAR pathStart = pszDirectory + pVrm->cchDirectoryA;

            //
            //  Copy the physical directory base then append the rest of
            //  the non-matching virtual path
            //

            CopyMemory(
                pszDirectory,
                pVrm->pszDirectoryA,
                pVrm->cchDirectoryA
                );

            strcpy( pathStart,
                    pszVirtPath + pVrm->cchRootA );

            if ( lpdwFileSystem != NULL) {
                *lpdwFileSystem = pVrm->dwFileSystem;
            }

            if ( pcchDirRoot ) {
                *pcchDirRoot = pVrm->cchDirectoryA;
            }

            if ( pcchVRoot ) {
                *pcchVRoot = pVrm->cchRootA;
            }

            if ( lpdwAccessMask != NULL) {
                *lpdwAccessMask = pVrm->dwAccessMask;
            }

            if ( phImpersonationToken != NULL) {

                // Should we increment refcount of the impersonation token?
                *phImpersonationToken = pVrm->hImpersonationToken;
            }

            Unlock();
            
            FlipSlashes( pathStart );
            *lpcbSize = cbReqd;

            return(TRUE);

        } else {

            dwError = ERROR_INSUFFICIENT_BUFFER;
        }

        *lpcbSize = cbReqd;
    }

    if ( lpdwAccessMask ) {
        *lpdwAccessMask = 0;
    }

    if ( lpdwFileSystem != NULL) {
        *lpdwFileSystem  = FS_ERROR;
    }

    if ( phImpersonationToken != NULL) {
        *phImpersonationToken = NULL;
    }

    if ( dwError == NO_ERROR) {
        dwError = ERROR_PATH_NOT_FOUND;
    }
    SetLastError( dwError );

    Unlock();
    return FALSE;
    
} // IIS_VROOT_TABLE::LookupVirtualRoot




BOOL
IIS_VROOT_TABLE::RemoveVirtualRoots(
    VOID
    )
/*++
    Description:

        Removes all of the virtual roots for the instance

    Arguments:
        None.

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    PVIRTUAL_ROOT_MAPPING   pVrm;

    CIterator               iter;
    DWORD                   dwValue;

    LockExclusive();
    
    LK_RETCODE  lkrc = InitializeIterator(&iter);

    while (LK_SUCCESS == lkrc)
    {
        pVrm = (PVIRTUAL_ROOT_MAPPING) iter.Record();
        
        DBG_ASSERT( pVrm->Signature == VIRT_ROOT_SIGNATURE );

        //
        // Increment the iterator before removing the record from the Hash 
        // Table else we hit an Assert in the increment.
        //
        
        lkrc = IncrementIterator(&iter);
        
        DeleteVRootEntry(pVrm);    // Removes from Hash Table Also
    }

    CloseIterator(&iter);

    Clear();
    
    Unlock();
    return TRUE;
    
} // TsRemoveVirtualRoots



BOOL 
IIS_VROOT_TABLE::RemoveVirtualRoot(
    IN  PCHAR              pszVirtPath
    )
/*++
    Description:

        Removes the virtual roots named pszVirtPath for the instance.

    Arguments:
        pszVirtPath - Name of the virtual root to remove.

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    PVIRTUAL_ROOT_MAPPING   pVrm;
    BOOL                    bSuccess = FALSE;

    DWORD cchPath = strlen( pszVirtPath );

    //
    //  Strip the trailing '/' from the virtual path
    //

    if ( IS_CHAR_TERM_A( pszVirtPath, cchPath - 1))
    {
        pszVirtPath[--cchPath] = '\0';
    }

    LockExclusive();
    
   if (LK_SUCCESS == FindKey((DWORD_PTR) pszVirtPath, (const void **)&pVrm))
   {
        //
        // Found a match
        //

        DeleteRecord(pVrm);       // Remove Entry from Hash Table
        DeleteVRootEntry(pVrm);  
        
        bSuccess = TRUE;
   }

    Unlock();
   return bSuccess;
}


VOID
IIS_VROOT_TABLE::DeleteVRootEntry(
    IN PVOID   pEntry
)
{

    DBG_ASSERT(NULL != pEntry);
    
    PVIRTUAL_ROOT_MAPPING pVrm = (PVIRTUAL_ROOT_MAPPING)pEntry;

    DBG_ASSERT(pVrm->Signature == VIRT_ROOT_SIGNATURE );

    m_nVroots--;

    IF_DEBUG( DIRECTORY_CHANGE )
        DBGPRINTF(( DBG_CONTEXT,
                    "Removing root %s\n",
                     pVrm->pszDirectoryA ));

    //
    // Remove reference to Dir Monitor
    //

    DcmRemoveRoot( pVrm );

    //
    // We need to close the impersonation token, if one exists.
    //

    if ( pVrm->hImpersonationToken != NULL) 
    {
        DBG_REQUIRE( CloseHandle( pVrm->hImpersonationToken ));
        pVrm->hImpersonationToken = NULL;
    }

    pVrm->Signature = 0;
    FREE( pVrm );
}


const DWORD_PTR
IIS_VROOT_TABLE::ExtractKey(const void* pvRecord)
{
    PVIRTUAL_ROOT_MAPPING   pVrm = (PVIRTUAL_ROOT_MAPPING)pvRecord;
    return (DWORD_PTR)pVrm->pszRootA;
}

DWORD
IIS_VROOT_TABLE::CalcKeyHash(const DWORD_PTR pnKey)
{
    return HashStringNoCase((LPCSTR)pnKey);
}

bool
IIS_VROOT_TABLE::EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
{
    return ( IISstricmp((UCHAR *)pnKey1, (UCHAR *)pnKey2) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\dynodbc.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    dynodbc.c

Abstract:

    This module provides functions for dynamically loading the ODBC
       functions.

Author:

    Murali R. Krishnan  (MuraliK)  3-Nov-1995

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
# include "dynodbc.h"


//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

pfnSQLAllocConnect        pSQLAllocConnect   ;
pfnSQLAllocEnv            pSQLAllocEnv       ;
pfnSQLAllocStmt           pSQLAllocStmt      ;
pfnSQLBindCol             pSQLBindCol        ;
pfnSQLCancel              pSQLCancel         ;
pfnSQLColAttributes       pSQLColAttributes  ;
pfnSQLConnect             pSQLConnect        ;
pfnSQLDescribeCol         pSQLDescribeCol    ;
pfnSQLDisconnect          pSQLDisconnect     ;
pfnSQLError               pSQLError          ;
pfnSQLExecDirect          pSQLExecDirect     ;
pfnSQLExecute             pSQLExecute        ;
pfnSQLFetch               pSQLFetch          ;
pfnSQLFreeConnect         pSQLFreeConnect    ;
pfnSQLFreeEnv             pSQLFreeEnv        ;
pfnSQLFreeStmt            pSQLFreeStmt       ;
pfnSQLGetCursorName       pSQLGetCursorName  ;
pfnSQLNumResultCols       pSQLNumResultCols  ;
pfnSQLPrepare             pSQLPrepare        ;
pfnSQLRowCount            pSQLRowCount       ;
pfnSQLSetCursorName       pSQLSetCursorName  ;
pfnSQLTransact            pSQLTransact       ;

pfnSQLSetConnectOption    pSQLSetConnectOption;
pfnSQLDrivers             pSQLDrivers         ;
pfnSQLDataSources         pSQLDataSources     ;
pfnSQLBindParameter       pSQLBindParameter   ;
pfnSQLGetInfo             pSQLGetInfo        ;
pfnSQLMoreResults         pSQLMoreResults    ;



# define ODBC_MODULE_NAME             "odbc32.dll"

#define LOAD_ENTRY( hMod, Name )  \
   (p##Name = (pfn##Name) GetProcAddress( (hMod), #Name ))


static BOOL  s_fODBCLoaded = FALSE;



BOOL
DynLoadODBC(
    VOID
    )
{
    HMODULE hMod;

    if ( s_fODBCLoaded )
      return TRUE;

    if ( (hMod = (HMODULE) LoadLibrary( ODBC_MODULE_NAME ))) {

        if (LOAD_ENTRY( hMod, SQLAllocConnect   )  &&
            LOAD_ENTRY( hMod, SQLAllocEnv       )  &&
            LOAD_ENTRY( hMod, SQLAllocStmt      )  &&
            LOAD_ENTRY( hMod, SQLBindCol        )  &&
            LOAD_ENTRY( hMod, SQLCancel         )  &&
            LOAD_ENTRY( hMod, SQLColAttributes  )  &&
            LOAD_ENTRY( hMod, SQLConnect        )  &&
            LOAD_ENTRY( hMod, SQLDescribeCol    )  &&
            LOAD_ENTRY( hMod, SQLDisconnect     )  &&
            LOAD_ENTRY( hMod, SQLError          )  &&
            LOAD_ENTRY( hMod, SQLExecDirect     )  &&
            LOAD_ENTRY( hMod, SQLExecute        )  &&
            LOAD_ENTRY( hMod, SQLFetch          )  &&
            LOAD_ENTRY( hMod, SQLFreeConnect    )  &&
            LOAD_ENTRY( hMod, SQLFreeEnv        )  &&
            LOAD_ENTRY( hMod, SQLFreeStmt       )  &&
            LOAD_ENTRY( hMod, SQLNumResultCols  )  &&
            LOAD_ENTRY( hMod, SQLPrepare        )  &&
            LOAD_ENTRY( hMod, SQLRowCount       )  &&
            LOAD_ENTRY( hMod, SQLTransact       )  &&
            LOAD_ENTRY( hMod, SQLSetConnectOption )  &&
            LOAD_ENTRY( hMod, SQLDrivers        )  &&
            LOAD_ENTRY( hMod, SQLDataSources    )  &&
            LOAD_ENTRY( hMod, SQLGetInfo        )  &&
            LOAD_ENTRY( hMod, SQLBindParameter  )  &&
            LOAD_ENTRY( hMod, SQLMoreResults    )
            ) {

            s_fODBCLoaded = TRUE;
        }
    }

    return (s_fODBCLoaded);

} // DynLoadODBC()


/****************************** End Of File ******************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\iisassoc.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iisassoc.cxx

Abstract:

    This module implements the IIS_ASSOCIATION class.

Author:

    Keith Moore (keithmo)        16-Jan-1997

Revision History:

--*/


#include "tcpdllp.hxx"
#pragma hdrstop
#include <iisassoc.hxx>


//
// Private constants.
//

#define HASH_FROM_CONTEXT(ctx)                                      \
            (                                                       \
                (m_HashIpAddress ? ctx->IpAddressHash : 0) +        \
                (m_HashHostName ? ctx->HostNameHash : 0)            \
            )


//
// Private types.
//

typedef struct _HASH_ENTRY {

    LIST_ENTRY HashBucketListEntry;
    DWORD IpAddress;
    DWORD Hash;
    LPVOID Context;
    CHAR HostName[1];   // Expands as needed. MUST BE LAST FIELD IN STRUCTURE!

} HASH_ENTRY, *PHASH_ENTRY;


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_ASSOCIATION::IIS_ASSOCIATION(
    IN BOOL HashIpAddress,
    IN BOOL HashHostName,
    IN INT NumHashBuckets
    ) :
    m_HashIpAddress( HashIpAddress ),
    m_HashHostName( HashHostName ),
    m_NumHashBuckets( NumHashBuckets ),
    m_HashBuckets( NULL )
/*++

Routine Description:

    IIS_ASSOCIATION constructor.

Arguments:

    HashIpAddress - TRUE if this association should hash the IP address.

    HashHostName - TRUE if this association should hash the host name.

    NumHashBuckets - The number of hash buckets to create for this
        association.

Return Value:

    None.

--*/
{

    //
    // Sanity check.
    //

    DBG_ASSERT( HashIpAddress || HashHostName );
    DBG_ASSERT( NumHashBuckets > 0 );

    //
    // Initialize the hash buckets.
    //

    m_HashBuckets = new LIST_ENTRY[m_NumHashBuckets];

    if( m_HashBuckets == NULL ) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );

    } else {

        for( INT i = 0 ; i < m_NumHashBuckets ; i++ ) {

            InitializeListHead( &m_HashBuckets[i] );

        }

    }

}   // IIS_ASSOCIATION::IIS_ASSOCIATION


IIS_ASSOCIATION::~IIS_ASSOCIATION()
/*++

Routine Description:

    IIS_ASSOCIATION destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

    INT i;
    PLIST_ENTRY hashBucket;
    PLIST_ENTRY listEntry;
    PHASH_ENTRY hashEntry;

    //
    // Purge the hash bucket entries.
    //

    for( i = 0, hashBucket = m_HashBuckets ;
         i < m_NumHashBuckets ;
         i++, hashBucket++ ) {

        while( !IsListEmpty( hashBucket ) ) {

            listEntry = RemoveHeadList( hashBucket );

            hashEntry = CONTAINING_RECORD(
                            listEntry,
                            HASH_ENTRY,
                            HashBucketListEntry
                            );

            delete hashEntry;

        }

    }

    //
    // Delete the hash bucket array.
    //

    delete m_HashBuckets;

}   // IIS_ASSOCIATION::~IIS_ASSOCIATION


DWORD
IIS_ASSOCIATION::AddDescriptor(
    IN DWORD IpAddress,
    IN const CHAR * HostName,
    IN LPVOID Context,
    IN OUT PHASH_CONTEXT HashContext OPTIONAL
    )
/*++

Routine Description:

    Adds a new descriptor to the association.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    Context - A context to associate with the descriptor.

    HashContext - An optional hash context from a previous call to one
        of the association functions. This is used to avoid redundant
        hash calculations. If NULL, then a temporary hash context is
        created and used.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    HASH_CONTEXT localContext;
    PHASH_ENTRY hashEntry;

    //
    // If a hash context was specified, use it. Otherwise, initialize a
    // local context and use it instead.
    //

    if( HashContext == NULL ) {

        HashContext = &localContext;
        InitializeHashContext( &localContext );

    }

    //
    // Get the hash.
    //

    CalculateHash(
        IpAddress,
        HostName,
        HashContext
        );

    //
    // Try to find the descriptor in the hash table. If it's there, then
    // fail the request. Otherwise, create a new hash entry and stick it
    // in the table.
    //

    hashEntry = FindDescriptor(
                    IpAddress,
                    HostName,
                    HashContext
                    );

    if( hashEntry == NULL ) {

        hashEntry = CreateHashEntry(
                        IpAddress,
                        HostName,
                        HashContext
                        );

        if( hashEntry != NULL ) {

            InsertHeadList(
                &m_HashBuckets[hashEntry->Hash % m_NumHashBuckets],
                &hashEntry->HashBucketListEntry
                );

            hashEntry->Context = Context;
            return NO_ERROR;

        }

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    return ERROR_DUP_NAME;

}   // IIS_ASSOCIATION::AddDescriptor


DWORD
IIS_ASSOCIATION::LookupDescriptor(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    OUT LPVOID *Context,
    IN OUT PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Searches the association for the specified descriptor.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    Context - Recieves the context associated with the descriptor if
        successful.

    HashContext - An optional hash context from a previous call to one
        of the association functions. This is used to avoid redundant
        hash calculations. If NULL, then a temporary hash context is
        created and used.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    HASH_CONTEXT localContext;
    PHASH_ENTRY hashEntry;

    //
    // If a hash context was specified, use it. Otherwise, initialize a
    // local context and use it instead.
    //

    if( HashContext == NULL ) {

        HashContext = &localContext;
        InitializeHashContext( &localContext );

    }

    //
    // Get the hash.
    //

    CalculateHash(
        IpAddress,
        HostName,
        HashContext
        );

    //
    // Try to find the descriptor in the hash table. If it's there, then
    // return the context to the caller. Otherwise, fail the request.
    //

    hashEntry = FindDescriptor(
                    IpAddress,
                    HostName,
                    HashContext
                    );

    if( hashEntry != NULL ) {

        *Context = hashEntry->Context;
        return NO_ERROR;

    }

    return ERROR_INVALID_PARAMETER;

}   // IIS_ASSOCIATION::LookupDescriptor


DWORD
IIS_ASSOCIATION::RemoveDescriptor(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    OUT LPVOID *Context,
    IN OUT PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Removes a descriptor from the association.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    Context - Receives the context associated with the descriptor if
        successful.

    HashContext - An optional hash context from a previous call to one
        of the association functions. This is used to avoid redundant
        hash calculations. If NULL, then a temporary hash context is
        created and used.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    HASH_CONTEXT localContext;
    PHASH_ENTRY hashEntry;

    //
    // If a hash context was specified, use it. Otherwise, initialize a
    // local context and use it instead.
    //

    if( HashContext == NULL ) {

        HashContext = &localContext;
        InitializeHashContext( &localContext );

    }

    //
    // Get the hash.
    //

    CalculateHash(
        IpAddress,
        HostName,
        HashContext
        );

    //
    // Try to find the descriptor in the hash table. If it's there, then
    // remove it from the hash table and return the context to the caller.
    // Otherwise, fail the request.
    //

    hashEntry = FindDescriptor(
                    IpAddress,
                    HostName,
                    HashContext
                    );

    if( hashEntry != NULL ) {

        *Context = hashEntry->Context;
        RemoveEntryList(
            &hashEntry->HashBucketListEntry
            );
        delete hashEntry;

        return NO_ERROR;

    }

    return ERROR_INVALID_PARAMETER;

}   // IIS_ASSOCIATION::RemoveDescriptor


VOID
IIS_ASSOCIATION::EnumDescriptors(
    IN LPFN_ASSOCIATION_CALLBACK Callback,
    IN LPVOID CallbackContext
    )
/*++

Routine Description:

    Enumerates the descriptors in the association.

Arguments:

    Callback - A function to call for every descriptor.

    CallbackContext - A context to pass back to the callback.

Return Value:

    None.

--*/
{

    INT i;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY hashBuckets;
    PHASH_ENTRY hashEntry;

    DBG_ASSERT( Callback != NULL );

    for( i = 0, hashBuckets = m_HashBuckets ;
         i < m_NumHashBuckets ;
         i++, hashBuckets++ ) {

        listEntry = hashBuckets->Flink;

        while( listEntry != hashBuckets ) {

            hashEntry = CONTAINING_RECORD(
                            listEntry,
                            HASH_ENTRY,
                            HashBucketListEntry
                            );

            listEntry = listEntry->Flink;

            if( !(Callback)(
                    CallbackContext,
                    hashEntry->Context,
                    hashEntry->IpAddress,
                    hashEntry->HostName
                    ) ) {

                break;

            }

        }

    }

}   // IIS_ASSOCIATION::EnumDescriptors

//
// Private functions.
//


VOID
IIS_ASSOCIATION::CalculateHash(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    OUT PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Calculates the hash of the IP address (if HashIpAddress == TRUE) and/or
    the host name (if HashHostName == TRUE).

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    HashContext - Will receive the updated hash.

Return Value:

    None.

--*/
{

    //
    // Calculate the IP address hash if needed and not already calculated.
    //

    if( HashContext->IpAddressHash == 0 && m_HashIpAddress ) {

        HashContext->IpAddressHash = IpAddress;

        if( HashContext->IpAddressHash == 0 ) {
            HashContext->IpAddressHash++;
        }

    }

    //
    // Calculate the host name hash if needed and not already calculated.
    //

    if( HashContext->HostNameHash == 0 && m_HashHostName ) {

        DWORD hash = 0;

        DBG_ASSERT( HostName != NULL );

        while( *HostName ) {
            CHAR ch;

            ch = *HostName++;

            //
            // This is basically toupper() for 7-bit ASCII. This is
            // OK for DNS names.
            //

            if( ch >= 'a' && ch <= 'z' ) {
                ch -= ( 'a' - 'A' );
            }

            hash = ( hash * 5 ) + (DWORD)ch;
        }

        if( hash == 0 ) {
            hash++;
        }

        HashContext->HostNameHash = hash;

    }

}   // IIS_ASSOCIATION::CalculateHash


PHASH_ENTRY
IIS_ASSOCIATION::FindDescriptor(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    IN PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Finds a descriptor in the association.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    HashContext - The current hash value.

Return Value:

    PHASH_ENTRY - Pointer to the hash entry if successful, NULL otherwise.

--*/
{

    DWORD hash;
    PLIST_ENTRY bucket;
    PLIST_ENTRY scan;
    PHASH_ENTRY entry;

    //
    // Get the correct bucket based on the hash value.
    //

    hash = HASH_FROM_CONTEXT(HashContext);
    bucket = &m_HashBuckets[hash % m_NumHashBuckets];

    //
    // Scan the bucket, looking for a match.
    //

    for( scan = bucket->Flink ; scan != bucket ; scan = scan->Flink ) {

        entry = CONTAINING_RECORD(
                    scan,
                    HASH_ENTRY,
                    HashBucketListEntry
                    );

        if( entry->Hash != hash ) {

            continue;

        }

        if( m_HashIpAddress &&
            entry->IpAddress != IpAddress ) {

            continue;

        }

        if( m_HashHostName ) {

            DBG_ASSERT( HostName != NULL );

            if( _stricmp(
                    entry->HostName,
                    HostName
                    ) ) {

                continue;

            }

        }

        //
        // Success!
        //

        return entry;

    }

    //
    // If we made it this far, then the item is not in the hash table.
    //

    return NULL;

}   // IIS_ASSOCIATION::FindDescriptor


PHASH_ENTRY
IIS_ASSOCIATION::CreateHashEntry(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    IN PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Creats a new hash entry.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    HashContext - The current hash value.

Return Value:

    PHASH_ENTRY - Pointer to the newly created hash entry if successful,
        NULL otherwise.

--*/
{

    PHASH_ENTRY entry;

    entry = (PHASH_ENTRY)( new BYTE[sizeof(*entry) + strlen(HostName)] );

    if( entry != NULL ) {

        entry->IpAddress = IpAddress;
        entry->Hash = HASH_FROM_CONTEXT(HashContext);
        strcpy( entry->HostName, HostName );

    }

    return entry;

}   // IIS_ASSOCIATION::CreateHashEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\iisadmin.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        iisadmin.cxx

   Abstract:

        Contains the admin functions of the IIS_SERVICE class

   Author:

        Johnson Apacible            (JohnsonA)      24-June-1996

--*/

#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"

BOOL
PopulateSiteArray(
    LPINET_INFO_SITE_LIST * ppSites,
    PVOID    pvUnused,
    IN IIS_SERVER_INSTANCE * pInst
    );

PIIS_SERVICE
IIS_SERVICE::FindFromServiceInfoList(
                IN DWORD dwServiceId
                )
/*++
    Description:

        Finds a given Services Info object from the global list.

    Arguments:

        dwServiceId - Service id of service to look for.

    Returns:
        pointer to service object, if found.
        NULL, otherwise.

--*/
{
    PLIST_ENTRY  listEntry;
    PIIS_SERVICE pInetSvc;

    //
    //  Loop through the list of running internet servers and call the callback
    //  for each server that has one of the service id bits set
    //

    AcquireGlobalLock( );
    for ( listEntry  = sm_ServiceInfoListHead.Flink;
          listEntry != &sm_ServiceInfoListHead;
          listEntry  = listEntry->Flink ) {

        pInetSvc = CONTAINING_RECORD(
                                listEntry,
                                IIS_SERVICE,
                                m_ServiceListEntry );

        if ( dwServiceId == pInetSvc->QueryServiceId() &&
             (pInetSvc->QueryCurrentServiceState() == SERVICE_RUNNING ||
             pInetSvc->QueryCurrentServiceState() == SERVICE_PAUSED ) ) {

            //
            // reference and return
            //

            if ( !pInetSvc->CheckAndReference( ) ) {
                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((DBG_CONTEXT,
                        "Failed to reference service %d\n", dwServiceId));
                }
                pInetSvc = NULL;
            }

            ReleaseGlobalLock( );
            return pInetSvc;
        }
    }

    ReleaseGlobalLock( );

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "FindFromServiceList cannot find service %d\n", dwServiceId));
    }

    return NULL;

} // IIS_SERVICE::FindFromServiceInfoList



BOOL
IIS_SERVICE::SetServiceAdminInfo(
        IN DWORD        dwLevel,
        IN DWORD        dwServiceId,
        IN DWORD        dwInstance,
        IN BOOL         fCommonConfig,
        IN INETA_CONFIG_INFO * pConfigInfo
        )
/*++
    Description:

        Sets the service configuration.

    Arguments:

        dwLevel - Info level
        dwServiceId - ID of service to set
        dwInstance - ID of instance to set
        fCommonConfig - Determines if we should set the common or the service
            configuration
        pConfigInfo - Configuration structure

    Returns:
        TRUE on sucess and FALSE if there is a failure

--*/
{
    BOOL          fRet = TRUE;
    PIIS_SERVICE  pInetSvc;

    DBG_ASSERT( IIS_SERVICE::sm_fInitialized);

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "SetServiceAdmin called for svc %d inst %d\n",
                dwServiceId, dwInstance));
    }

    pInetSvc = FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        SetLastError( ERROR_SERVICE_NOT_ACTIVE);
        fRet = FALSE;
        goto exit;
    }

    //
    // Set the parameters and update
    //

    fRet = pInetSvc->SetInstanceConfiguration(
                                    dwInstance,
                                    dwLevel,
                                    fCommonConfig,
                                    pConfigInfo );

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );
exit:
    return fRet;
}  // IIS_SERVICE::SetServiceAdminInfo





BOOL
IIS_SERVICE::GetServiceAdminInfo(
        IN DWORD        dwLevel,
        IN DWORD        dwServiceId,
        IN DWORD        dwInstance,
        IN BOOL         fCommonConfig,
        OUT PDWORD      nRead,
        OUT LPINETA_CONFIG_INFO * ppConfigInfo
        )
/*++
    Description:

        Gets the service configuration.

    Arguments:

        dwLevel - Info level of this operation
        dwServiceId - ID of service to get
        dwInstance - ID of instance to get
        fCommonConfig - Determines if we should get the common or the service
            configuration
        pBuffer     - on return, will contains a pointer to
            the configuration block

    Returns:
        TRUE on sucess and FALSE if there is a failure

--*/
{
    BOOL fRet = FALSE;
    PIIS_SERVICE  pInetSvc;

    DBG_ASSERT( IIS_SERVICE::sm_fInitialized);

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "GetServiceAdmin called for svc %d inst %x\n",
                dwServiceId, dwInstance));
    }

    pInetSvc = FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        SetLastError( ERROR_SERVICE_NOT_ACTIVE);
        goto exit;
    }

    //
    // Get the params
    //

    fRet = pInetSvc->GetInstanceConfiguration(
                                        dwInstance,
                                        dwLevel,
                                        fCommonConfig,
                                        nRead,
                                        ppConfigInfo
                                        );

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

exit:
    return fRet;
}  // IIS_SERVICE::GetServiceAdminInfo



BOOL
IIS_SERVICE::GetServiceSiteInfo(
                    IN  DWORD                   dwServiceId,
                    OUT LPINET_INFO_SITE_LIST * ppSites
                    )
/*++
    Description:

        Gets the list of service instances.

    Arguments:

        dwServiceId - ID of service to get
        ppSites     - on return, will contain a pointer to
                      the array of sites

    Returns:
        TRUE on sucess and FALSE if there is a failure

--*/
{
    BOOL fRet = FALSE;
    PIIS_SERVICE  pInetSvc;
    DWORD cInstances = 0;
    LPINET_INFO_SITE_LIST pSites;
    
    DBG_ASSERT( IIS_SERVICE::sm_fInitialized);

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "GetServiceSiteInfo called for svc %d\n",
                dwServiceId));
    }

    pInetSvc = FindFromServiceInfoList( dwServiceId );
    
    if ( pInetSvc == NULL ) {
        SetLastError( ERROR_SERVICE_NOT_ACTIVE);
        return FALSE;
    }

    //
    // Get the params
    //

    pInetSvc->AcquireServiceLock(TRUE);

    cInstances = pInetSvc->QueryInstanceCount();

    //allocate enough memory to hold the Site Info Arrary
    
    pSites = (LPINET_INFO_SITE_LIST) 
                midl_user_allocate (sizeof(INET_INFO_SITE_LIST) + sizeof(INET_INFO_SITE_ENTRY)*cInstances);

    if (!pSites) {
    
        pInetSvc->ReleaseServiceLock(TRUE);

    	//This was referenced in Find
        pInetSvc->Dereference( );    
        
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
        
    *ppSites = pSites;
    
    pSites->cEntries = 0;
    
    fRet = pInetSvc->EnumServiceInstances(
                                        (PVOID) ppSites,
                                        NULL,
                                        (PFN_INSTANCE_ENUM) PopulateSiteArray
                                        );
                                        
    if (!fRet) {
    
        for (DWORD i=0; i<pSites->cEntries; i++) {
            midl_user_free(pSites->aSiteEntry[i].pszComment);
        }
        
        midl_user_free(pSites);

        *ppSites = NULL;
    }
    
    pInetSvc->ReleaseServiceLock(TRUE);

    //This was referenced in Find
    
    pInetSvc->Dereference( );
                                        
    return fRet;
}  // IIS_SERVICE::GetServiceSiteInfo



BOOL
PopulateSiteArray(
    LPINET_INFO_SITE_LIST * ppSites,
    PVOID    pvUnused,
    IN IIS_SERVER_INSTANCE * pInst
    )
/*++
    Description:

        Fills the ppSites array with the instance id and site comment.

    Arguments:
        pvUnused    - not used
        pInst       - pointer to service instance
        ppSites     - on return, will contain a pointer to
                      the array of sites

    Returns:
        TRUE on sucess and FALSE if there is a failure

--*/
{
    DWORD cbComment = 0;
    LPINET_INFO_SITE_LIST pSites = *ppSites;



    //Set the instance ID
    pSites->aSiteEntry[pSites->cEntries].dwInstance = pInst->QueryInstanceId();


    //allocate memory for the site name
    cbComment = (strlen(pInst->QuerySiteName())+1) * sizeof(WCHAR);
    
    pSites->aSiteEntry[pSites->cEntries].pszComment = (LPWSTR)midl_user_allocate(cbComment);

    
    if (!(pSites->aSiteEntry[pSites->cEntries].pszComment)) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    //  Need unicode conversion here
    //

    if (!MultiByteToWideChar(  CP_ACP,                                      // code page
                        MB_PRECOMPOSED,                                     // character-type options
                        pInst->QuerySiteName(),                             // address of string to map
                        -1,                                                 // number of bytes in string
                        pSites->aSiteEntry[pSites->cEntries].pszComment,    // address of wide-character buffer
                        cbComment / sizeof(WCHAR)                           // size of buffer
                      )) 
    {
        pSites->aSiteEntry[pSites->cEntries].pszComment[0] = L'\0';
    }

    pSites->cEntries++;

    return TRUE;

} //PopulateSiteArray


DWORD
IIS_SERVICE::GetNewInstanceId(
            VOID
            )
/*++
    Description:

        Returns a new instance ID.

    Arguments:

        None.

    Returns:

        A non zero dword containing the instance ID.
        0 if there was an error.

--*/
{
    DWORD  dwId;
    CHAR   regParamKey[MAX_PATH+1];
    MB     mb( (IMDCOM*) QueryMDObject()  );

    AcquireServiceLock( );

    for (; ; ) {

        dwId = ++m_maxInstanceId;

        if ( m_maxInstanceId > INET_INSTANCE_MAX ) {
            m_maxInstanceId = INET_INSTANCE_MIN;
        }

        //
        // Make sure the metapath does not exist
        //

        GetMDInstancePath( dwId, regParamKey );
        if ( !mb.Open( regParamKey ) ) {

            DBG_ASSERT(GetLastError() == ERROR_FILE_NOT_FOUND);
            if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
                DBGPRINTF((DBG_CONTEXT,
                    "Error %d trying to open %s.\n", GetLastError(), regParamKey ));

                dwId = 0;
            }
            break;
        }

    }

    ReleaseServiceLock( );

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT, "GetNewInstanceId returns %d\n", dwId));
    }

    return dwId;

} // IIS_SERVICE::GetNewInstanceId




BOOL
IIS_SERVICE::SetInstanceConfiguration(
    IN DWORD            dwInstance,
    IN DWORD            dwLevel,
    IN BOOL             fCommonConfig,
    IN LPINETA_CONFIG_INFO pConfig
    )
/*++
    Description:

        Set the configuration for the instance.

    Arguments:

        dwInstance - Instance number to find - IGNORED FOR SET!!
        dwLevel - level of information to set
        pCommonConfig - Whether info is common or service specific
        pConfig - pointer to the configuration block

    Returns:

        A dword containing the instance ID.
--*/
{
    BOOL fRet = FALSE;
    PLIST_ENTRY  listEntry;
    PIIS_SERVER_INSTANCE pInstance;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "SetInstanceConfiguration called for instance %d\n", dwInstance));
    }

    //
    // Try to find this instance
    //

    AcquireServiceLock( TRUE );

    //
    //  Find the instance in the instance list
    //

    if ( dwInstance == INET_INSTANCE_ROOT ) {
        DBG_ASSERT( !"Explicit default instance no longer supported inherited from metabase)\n" );
        pInstance = NULL;
    } else {
        pInstance = FindIISInstance( QueryDownLevelInstance() );
    }

    if ( pInstance != NULL ) {
        goto found;
    }

    SetLastError(ERROR_FILE_NOT_FOUND);
    DBG_ASSERT(!fRet);
    goto exit;

found:

    if ( fCommonConfig ) {

        fRet = pInstance->SetCommonConfig( pConfig, TRUE);

    } else {

        fRet = pInstance->SetServiceConfig( (CHAR *) pConfig);
    }

exit:
    ReleaseServiceLock( TRUE );
    return fRet;

} // IIS_SERVICE::SetInstanceConfiguration


BOOL
IIS_SERVICE::GetInstanceConfiguration(
        IN DWORD dwInstance,
        IN DWORD dwLevel,
        IN BOOL fCommonConfig,
        OUT PDWORD nRead,
        OUT LPINETA_CONFIG_INFO * pBuffer
        )
/*++
    Description:

        Get the configuration for the instance.

    Arguments:

        dwInstance - Instance number to find - IGNORED!!
        dwLevel - level of information to get
        pCommonConfig - Whether info is common or service specific
        nRead - pointer to a DWORD where the number of entries to be
            returned is set.
        pBuffer - pointer to the configuration block

    Returns:

        A dword containing the instance ID.
--*/
{

    PLIST_ENTRY  listEntry;
    PIIS_SERVER_INSTANCE pInstance;
    DWORD nInstances = 1;
    DWORD nSize;
    PCHAR pConfig;

    //
    // Set and Get only work against the default instance
    //

    dwInstance = QueryDownLevelInstance();

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "GetInstanceConfiguration [%x][%d] called for instance %x L%d\n",
            this, fCommonConfig, dwInstance, dwLevel));
    }

    //
    // We support only 1
    //

    *nRead = 0;
    *pBuffer = NULL;

    if ( fCommonConfig ) {

        DBG_ASSERT( dwLevel == 1 );

        nSize = sizeof( INETA_CONFIG_INFO );

    } else {

        DWORD err;

        nSize = GetServiceConfigInfoSize(dwLevel);
        if ( nSize == 0 ) {
            SetLastError(ERROR_INVALID_LEVEL);
            return(FALSE);
        }
    }

    //
    // Try to find this instance
    //

    AcquireServiceLock( );

    if ( dwInstance == INET_INSTANCE_ALL ) {
        nInstances = QueryInstanceCount( );
        if ( nInstances == 0 ) {
            goto exit;
        }
        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT,"%d instances found\n",nInstances));
        }
    }

    *pBuffer = (LPINETA_CONFIG_INFO) MIDL_user_allocate(nInstances * nSize);
    if ( *pBuffer == NULL ) {
        goto error_exit;
    }

    ZeroMemory( *pBuffer, nInstances * nSize );

    //
    //  Loop through the list of running internet servers and call the callback
    //  for each server that has one of the service id bits set
    //

    pConfig = (CHAR *) *pBuffer;

    if ( dwInstance != INET_INSTANCE_ROOT ) {

        for ( listEntry  = m_InstanceListHead.Flink;
              listEntry != &m_InstanceListHead;
              listEntry  = listEntry->Flink ) {

            pInstance = CONTAINING_RECORD(
                                    listEntry,
                                    IIS_SERVER_INSTANCE,
                                    m_InstanceListEntry );

            if ( (dwInstance == pInstance->QueryInstanceId()) ||
                 (dwInstance == INET_INSTANCE_ALL)   ||
                 (dwInstance == INET_INSTANCE_FIRST) ) {

                if ( fCommonConfig ) {
                    if ( !pInstance->GetCommonConfig(pConfig,dwLevel) ) {
                        goto error_exit;
                    }
                } else {
                    if ( !pInstance->GetServiceConfig(pConfig,dwLevel) ) {
                        goto error_exit;
                    }
                }

                //
                // if not get all, return.
                //

                (*nRead)++;
                pConfig += nSize;

                if ( dwInstance != INET_INSTANCE_ALL ) {
                    break;
                }
            }
        }
    } else {

        DBG_ASSERT( !"Default instance no longer supported!\n" );
    }

exit:

    if ( *nRead == 0 ) {
        if ( dwInstance != INET_INSTANCE_ALL ) {
            SetLastError(ERROR_FILE_NOT_FOUND);
            goto error_exit;
        }
    }

    ReleaseServiceLock( );

    DBG_ASSERT(nInstances == *nRead);
    return TRUE;

error_exit:

    ReleaseServiceLock( );

    IF_DEBUG(ERROR) {
        DBGPRINTF((DBG_CONTEXT,"Error %x in GetInstanceConfiguration\n",
            GetLastError()));
    }

    if ( *pBuffer != NULL ) {
        MIDL_user_free(*pBuffer);
        *pBuffer = NULL;
    }
    *nRead = 0;
    return(FALSE);

} // IIS_SERVICE::GetInstanceConfiguration




PIIS_SERVER_INSTANCE
IIS_SERVICE::FindIISInstance(
    IN DWORD            dwInstance
    )
/*++
    Description:

        Find the instance
        *** Service lock assumed held ***

    Arguments:

        dwInstance - Instance number to find

    Returns:

        Pointer to the instance.
        NULL if not found.
--*/
{
    BOOL fRet = TRUE;
    PLIST_ENTRY  listEntry;
    PIIS_SERVER_INSTANCE pInstance;

    //
    //  Find the instance in the instance list
    //

    for ( listEntry  = m_InstanceListHead.Flink;
          listEntry != &m_InstanceListHead;
          listEntry  = listEntry->Flink ) {

        pInstance = CONTAINING_RECORD(
                                listEntry,
                                IIS_SERVER_INSTANCE,
                                m_InstanceListEntry );

        if ( (dwInstance == pInstance->QueryInstanceId()) ||
             (dwInstance == INET_INSTANCE_FIRST) ) {

            return pInstance;
        }
    }

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "FindIISInstance: Cannot find instance %d\n", dwInstance));
    }

    SetLastError(ERROR_FILE_NOT_FOUND);
    return(NULL);

} // IIS_SERVICE::FindIISInstance



BOOL
IIS_SERVICE::DeleteInstanceInfo(
                IN DWORD    dwInstance
                )
{
    PIIS_SERVER_INSTANCE pInstance;
    DWORD err = NO_ERROR;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "DeleteInstanceInfo called for %d\n", dwInstance));
    }

    //
    // Find the instance and close it
    //

    AcquireServiceLock( TRUE );

    //
    //  Find the instance in the instance list
    //

    pInstance = FindIISInstance( dwInstance );

    if( pInstance == NULL ) {

        err = ERROR_FILE_NOT_FOUND;

    } else {

        //
        // Remove it from the list
        //

        RemoveEntryList( &pInstance->m_InstanceListEntry );
        m_nInstance--;

        //
        // Shut it down
        //

        pInstance->CloseInstance();

        //
        // Dereference it
        //

        pInstance->Dereference( );

    }

    ReleaseServiceLock( TRUE );

    if( err == NO_ERROR ) {

        return TRUE;

    }

    SetLastError( err );
    return FALSE;

} // IIS_SERVICE::DeleteInstanceInfo


BOOL
IIS_SERVICE::EnumerateInstanceUsers(
                    IN DWORD dwInstance,
                    OUT PDWORD nRead,
                    OUT PCHAR* pBuffer
                    )
{

    PIIS_SERVER_INSTANCE pInstance;
    BOOL    fRet;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "EnumerateInstanceUsers called for service %x (Instance %d)\n",
                this, dwInstance ));
    }

    //
    // Find the instance
    //

    AcquireServiceLock( );

    //
    //  Find the instance in the instance list
    //

    pInstance = FindIISInstance( dwInstance );
    if ( pInstance != NULL ) {
        goto found;
    }

    ReleaseServiceLock( );
    SetLastError(ERROR_FILE_NOT_FOUND);
    return(FALSE);

found:

    fRet = pInstance->EnumerateUsers( pBuffer, nRead );
    ReleaseServiceLock( );

    return(fRet);

} // IIS_SERVICE::EnumerateInstanceUsers




BOOL
IIS_SERVICE::DisconnectInstanceUser(
                    IN DWORD dwInstance,
                    IN DWORD dwIdUser
                    )
{

    PIIS_SERVER_INSTANCE pInstance;
    BOOL    fRet;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "DisconnectInstanceUsers called for service %x (Instance %d)\n",
                this, dwInstance ));
    }

    //
    // Find the instance
    //

    AcquireServiceLock( );

    //
    //  Find the instance in the instance list
    //

    pInstance = FindIISInstance( dwInstance );
    if ( pInstance != NULL ) {
        goto found;
    }

    ReleaseServiceLock( );
    SetLastError(ERROR_FILE_NOT_FOUND);
    return(FALSE);

found:

    fRet = pInstance->DisconnectUser( dwIdUser );
    ReleaseServiceLock( );

    return(fRet);

} // IIS_SERVICE::DisconnectInstanceUsers




BOOL
IIS_SERVICE::GetInstanceStatistics(
                IN DWORD    dwInstance,
                IN DWORD    dwLevel,
                OUT PCHAR*  pBuffer
                )
{

    PIIS_SERVER_INSTANCE pInstance;
    BOOL                 fRet;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "GetInstanceStats called for service %x (Instance %d)\n",
                this, dwInstance ));
    }

    //
    // Find the instance and close it
    //

    AcquireServiceLock( TRUE);

    if (dwInstance == 0 ) 
    {
        fRet = GetGlobalStatistics(dwLevel,pBuffer);
    }
    else if ( dwInstance == INET_INSTANCE_GLOBAL)
    {
        //
        // We need to aggregate statistics across all instances
        //
        
        PLIST_ENTRY listEntry;
        PCHAR       pStats;
        BOOL        fFirst = TRUE;

        fRet        = FALSE;
        *pBuffer    = NULL;
        
        //
        // Loop through all the instances and add their counters
        //
            
        for ( listEntry  = m_InstanceListHead.Flink;
              listEntry != &m_InstanceListHead;
              listEntry  = listEntry->Flink) 
        {
        
            pInstance = CONTAINING_RECORD(
                                    listEntry,
                                    IIS_SERVER_INSTANCE,
                                    m_InstanceListEntry );

            pInstance->LockThisForRead();
            fRet = pInstance->GetStatistics(dwLevel, &pStats);
            pInstance->UnlockThis();
            
            if (fRet)
            {
                if (fFirst)
                {
                    //
                    // This is the first successful retrieval.
                    //

                    *pBuffer = pStats;
                    fFirst = FALSE;
                }
                else
                {
                    AggregateStatistics(*pBuffer, pStats);
                    MIDL_user_free(pStats);
                }
            }
        } 
    }
    else 
    {

        //
        //  Find the instance in the instance list
        //

        pInstance = FindIISInstance( dwInstance );
        if ( pInstance != NULL ) 
        {
            fRet = pInstance->GetStatistics(dwLevel,pBuffer);
        }
        else
        {
            SetLastError(ERROR_FILE_NOT_FOUND);
            fRet = FALSE;
        }
    }

    ReleaseServiceLock( TRUE);

    return(fRet);


} // IIS_SERVICE::GetInstanceStatistics


BOOL 
IIS_SERVICE::GetGlobalStatistics(
    IN DWORD dwLevel, 
    OUT PCHAR *pBuffer
    )
{
    return FALSE;
}   // IIS_SERVICE::GetGlobalStatistics


BOOL
IIS_SERVICE::ClearInstanceStatistics(
                IN DWORD    dwInstance
                )
{

    PIIS_SERVER_INSTANCE pInstance;
    BOOL    fRet;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "ClearInstanceStats called for service %x (instance %d)\n",
                this, dwInstance ));
    }

    //
    // Find the instance and close it
    //

    AcquireServiceLock( );

    //
    //  Find the instance in the instance list
    //

    pInstance = FindIISInstance( dwInstance );
    if ( pInstance != NULL ) {
        goto found;
    }

    ReleaseServiceLock( );
    SetLastError(ERROR_FILE_NOT_FOUND);
    return(FALSE);

found:

    fRet = pInstance->ClearStatistics( );
    ReleaseServiceLock( );

    return(fRet);

} // IIS_SERVICE::ClearInstanceStatistics



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\fcache.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name:
      fcache.cxx

   Abstract:
      This module supports functions for file caching for servers

   Author:

       Murali R. Krishnan    ( MuraliK )     11-Oct-1995

   Environment:

       Win32 Apps

   Project:

       Internet Services Common  DLL

   Functions Exported:



   Revision History:
     Obtained from old inetsvcs.dll

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include <tcpdllp.hxx>
#include <issched.hxx>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <festrcnv.h>

# include "inetreg.h"

//
//  Prototypes
//



//
//  Globals
//

/************************************************************
 *    Functions
 ************************************************************/



//
// We need a wrapper class for the file data because
// everything in the blob cache must be derived from
// BLOB_HEADER.
//
class FILE_DATA : public BLOB_HEADER
{
public:
    BYTE * pbData;
};


BOOL
CheckOutCachedFile(
    IN     const CHAR *             pchFile,
    IN     TSVC_CACHE *             pTsvcCache,
    IN     HANDLE                   hToken,
    OUT    BYTE * *                 ppbData,
    OUT    DWORD *                  pcbData,
    IN     BOOL                     fMayCacheAccessToken,
    OUT    PCACHE_FILE_INFO         pCacheFileInfo,
    IN     int                      nCharset,
    OUT    PSECURITY_DESCRIPTOR*    ppSecDesc,
    IN     BOOL                     fUseWin32Canon
    )
/*++
    Description:

        Attempts to retrieve the passed file from the cache.  If it's not
        cached, then we read the file and add it to the cache.

    Arguments:

        pchFile - Fully qualified file to retrieve
        pTsvcCache - Cache object to charge memory against
        hToken - Impersonation token to open the file with
        pcbData - Receives pointer to first byte of data, used as handle to
            free data
        pcbSize - Size of output buffer
        pCacheFileInfo - File cache information
        nCharset - Charset (if this isn't SJIS, we convert it to SJIS
            before Check-In)
        ppSecDesc - Returns security descriptor if not null
        fUseWin32Canon - The resource has not been canonicalized and it's ok
            to use the win32 canonicalization code

    Returns:
        TRUE if successful, FALSE otherwise

    Notes:

        The file is extended by two bytes and is appended with two zero bytes,
        thus callers are guaranteed of a zero terminated text file.

--*/
{
    TS_OPEN_FILE_INFO *     pFile = NULL;
    DWORD                   cbLow, cbHigh;
    BYTE *                  pbData = NULL;
    FILE_DATA *             pFileData = NULL;
    BOOL                    fCached = TRUE;
    PSECURITY_DESCRIPTOR    pSecDesc;
    BYTE *                  pbBuff = NULL;
    int                     cbSJISSize;
    const ULONG             cchFile = strlen(pchFile);

    //
    //  Is the file already in the cache?
    //

    if ( !TsCheckOutCachedBlob( *pTsvcCache,
                                pchFile,
                                cchFile,
                                RESERVED_DEMUX_FILE_DATA,
                                (VOID **) &pFileData,
                                hToken,
                                fMayCacheAccessToken,
                                ppSecDesc ))
    {
        DWORD dwOptions;

        if ( GetLastError() == ERROR_ACCESS_DENIED )
        {
            return FALSE;
        }

        //
        //  The file isn't in the cache so open the file and get its size
        //

        fCached = FALSE;

        dwOptions = (fMayCacheAccessToken ? TS_CACHING_DESIRED :
                     TS_DONT_CACHE_ACCESS_TOKEN) |
                    (fUseWin32Canon ? TS_USE_WIN32_CANON : 0);



        if ( !(pFile = TsCreateFile( *pTsvcCache,
                                     pchFile,
                                     hToken,
                                     dwOptions )) ||
             !pFile->QuerySize( &cbLow, &cbHigh ))
        {
            goto ErrorExit;
        }

        //
        //  Limit the file size to 128k
        //

        if ( cbHigh || cbLow > 131072L )
        {
            SetLastError( ERROR_NOT_SUPPORTED );
            goto ErrorExit;
        }

        if ( CODE_ONLY_SBCS != nCharset )
        {
            if ( !( pbBuff = pbData = (BYTE *)LocalAlloc( LPTR, cbLow ) ) )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
                goto ErrorExit;
            }
        }
        else {
            if ( !TsAllocate( *pTsvcCache,
                              cbLow + sizeof(WCHAR) + sizeof(FILE_DATA),
                              (VOID **) &pFileData ))
            {
                goto ErrorExit;
            }
            
            pbData = pFileData->pbData = (BYTE *) (pFileData + 1);
        }        

        //
        //  Read the file data
        //

        if ( !DoSynchronousReadFile(
                        pFile->QueryFileHandle(),
                        (PCHAR)pbData,
                        cbLow,
                        pcbData,
                        NULL ))
        {
            goto ErrorExit;
        }

        if ( CODE_ONLY_SBCS != nCharset )
        {
            pbData = NULL;

            //
            //  get the length after conversion
            //

            cbSJISSize = UNIX_to_PC( GetACP(),
                                     nCharset,
                                     pbBuff,
                                     *pcbData,
                                     NULL,
                                     0 );
            DBG_ASSERT( cbSJISSize <= (int)cbLow );

            if ( !TsAllocate( *pTsvcCache,
                              cbSJISSize + sizeof(WCHAR) + sizeof(FILE_DATA),
                              (VOID **) &pFileData ))
            {
                goto ErrorExit;
            }
            pbData = pFileData->pbData = (BYTE *) (pFileData + 1);

            //
            //  conversion
            //

            UNIX_to_PC( GetACP(),
                        nCharset,
                        pbBuff,
                        *pcbData,
                        pbData,
                        cbSJISSize );
            *pcbData = cbLow = cbSJISSize;
        }

        DBG_ASSERT( *pcbData <= cbLow );

        //
        //  Zero terminate the file for both ANSI and Unicode files
        //

        *((WCHAR UNALIGNED *)(pbData + cbLow)) = L'\0';

        *pcbData += sizeof(WCHAR);

        //
        //  Add this blob to the cache manager and check it out, if it fails,
        //  we just free it below
        //

        if ( TsCacheDirectoryBlob( *pTsvcCache,
                                   pchFile,
                                   cchFile,
                                   RESERVED_DEMUX_FILE_DATA,
                                   pFileData,
                                   TRUE,
                                   pSecDesc = TsGetFileSecDesc( pFile ) ) )
        {
            fCached = TRUE;
        }
        else
        {
            if ( pSecDesc )
            {
                LocalFree( pSecDesc );
            }
        }

        if ( ppSecDesc )
        {
            *ppSecDesc = TsGetFileSecDesc( pFile );
        }

        DBG_REQUIRE( TsCloseHandle( *pTsvcCache,
                                    pFile ));
        pFile = NULL;
    }
    else
    {
        //
        // File was in the cache
        //

        pbData = pFileData->pbData;
        
        //
        // Calculate the length to return, including the double null
        // Note: assuming no nulls in the middle of the file here
        //
        

        *pcbData = strlen( (CHAR *) pbData ) + sizeof(WCHAR);
    }


    pCacheFileInfo->pbData = *ppbData = pbData;
    pCacheFileInfo->dwCacheFlags = fCached;
    pCacheFileInfo->pFileData = pFileData;

    if ( pbBuff )
    {
        LocalFree( pbBuff );
    }

    return TRUE;

ErrorExit:
    if ( pFile )
    {
        DBG_REQUIRE( TsCloseHandle( *pTsvcCache,
                                    pFile ));
    }

    if ( pbBuff )
    {
        if ( pbBuff == pbData )
        {
             pbData = NULL;
        }
        LocalFree( pbBuff );
    }

    if ( pbData )
    {
        if ( fCached )
        {
            DBG_REQUIRE( TsCheckInCachedBlob( pFileData ));

        }
        else
        {
            DBG_REQUIRE( TsFree( *pTsvcCache,
                                 pFileData ));
        }
    }

    return FALSE;
}



BOOL
CheckOutCachedFileFromURI(
    IN     PVOID                    URIFile,
    IN     const CHAR *             pchFile,
    IN     TSVC_CACHE *             pTsvcCache,
    IN     HANDLE                   hToken,
    OUT    BYTE * *                 ppbData,
    OUT    DWORD *                  pcbData,
    IN     BOOL                     fMayCacheAccessToken,
    OUT    PCACHE_FILE_INFO         pCacheFileInfo,
    IN     int                      nCharset,
    OUT    PSECURITY_DESCRIPTOR*    ppSecDesc,
    IN     BOOL                     fUseWin32Canon
    )
/*++
    Description:

        Attempts to retrieve the passed file from the cache.  If it's not
        cached, then we read the file and add it to the cache.

    Arguments:

        pchFile - Fully qualified file to retrieve
        pTsvcCache - Cache object to charge memory against
        hToken - Impersonation token to open the file with
        pcbData - Receives pointer to first byte of data, used as handle to
            free data
        pcbSize - Size of output buffer
        pCacheFileInfo - File cache information
        nCharset - Charset (if this isn't SJIS, we convert it to SJIS
            before Check-In)
        ppSecDesc - Returns security descriptor if not null
        fUseWin32Canon - The resource has not been canonicalized and it's ok
            to use the win32 canonicalization code

    Returns:
        TRUE if successful, FALSE otherwise

    Notes:

        The file is extended by two bytes and is appended with two zero bytes,
        thus callers are guaranteed of a zero terminated text file.

--*/
{
    DWORD                   cbLow, cbHigh;
    BYTE *                  pbData = NULL;
    FILE_DATA *             pFileData = NULL;
    BOOL                    fCached = TRUE;
    PSECURITY_DESCRIPTOR    pSecDesc;
    BYTE *                  pbBuff = NULL;
    int                     cbSJISSize;
    const ULONG             cchFile = strlen(pchFile);

    TS_OPEN_FILE_INFO *     pFile = (LPTS_OPEN_FILE_INFO)URIFile;

    //
    //  Is the file already in the cache?
    //

    if ( !TsCheckOutCachedBlob( *pTsvcCache,
                                pchFile,
                                cchFile,
                                RESERVED_DEMUX_FILE_DATA,
                                (VOID **) &pFileData,
                                hToken,
                                fMayCacheAccessToken,
                                ppSecDesc ))
    {

        if ( GetLastError() == ERROR_ACCESS_DENIED )
        {
            return FALSE;
        }

        //
        //  The file isn't in the cache so open the file and get its size
        //

        fCached = FALSE;

        if ( !pFile->QuerySize( &cbLow, &cbHigh ))
        {
            goto ErrorExit;
        }

        //
        //  Limit the file size to 128k
        //

        if ( cbHigh || cbLow > 131072L )
        {
            SetLastError( ERROR_NOT_SUPPORTED );
            goto ErrorExit;
        }

        if ( CODE_ONLY_SBCS != nCharset )
        {
            if ( !( pbBuff = pbData = (BYTE *)LocalAlloc( LPTR, cbLow ) ) )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
                goto ErrorExit;
            }
        }
        else {
            if ( !TsAllocate( *pTsvcCache,
                              cbLow + sizeof(WCHAR) + sizeof(FILE_DATA),
                              (VOID **) &pFileData ))
            {
                goto ErrorExit;
            }
            pbData = pFileData->pbData = (BYTE *) (pFileData + 1);
        }
        
        //
        //  Read the file data
        //

        if ( !DoSynchronousReadFile(
                        pFile->QueryFileHandle(),
                        (PCHAR)pbData,
                        cbLow,
                        pcbData,
                        NULL ))
        {
            goto ErrorExit;
        }

        if ( CODE_ONLY_SBCS != nCharset )
        {
            pbData = NULL;

            //
            //  get the length after conversion
            //

            cbSJISSize = UNIX_to_PC( GetACP(),
                                     nCharset,
                                     pbBuff,
                                     *pcbData,
                                     NULL,
                                     0 );
            DBG_ASSERT( cbSJISSize <= (int)cbLow );

            if ( !TsAllocate( *pTsvcCache,
                              cbSJISSize + sizeof(WCHAR) + sizeof(FILE_DATA),
                              (VOID **) &pFileData ))
            {
                goto ErrorExit;
            }
            pbData = pFileData->pbData = (BYTE *) (pFileData + 1);

            //
            //  conversion
            //

            UNIX_to_PC( GetACP(),
                        nCharset,
                        pbBuff,
                        *pcbData,
                        pbData,
                        cbSJISSize );
            *pcbData = cbLow = cbSJISSize;
        }

        DBG_ASSERT( *pcbData <= cbLow );

        //
        //  Zero terminate the file for both ANSI and Unicode files
        //

        *((WCHAR UNALIGNED *)(pbData + cbLow)) = L'\0';

        *pcbData += sizeof(WCHAR);

        //
        //  Add this blob to the cache manager and check it out, if it fails,
        //  we just free it below
        //

        if ( TsCacheDirectoryBlob( *pTsvcCache,
                                   pchFile,
                                   cchFile,
                                   RESERVED_DEMUX_FILE_DATA,
                                   pFileData,
                                   TRUE,
                                   pSecDesc = TsGetFileSecDesc( pFile ) ) )
        {
            fCached = TRUE;
        }
        else
        {
            if ( pSecDesc )
            {
                LocalFree( pSecDesc );
            }
        }

        if ( ppSecDesc )
        {
            *ppSecDesc = TsGetFileSecDesc( pFile );
        }

    }
    else
    {
        //
        // File was in the cache
        //

        pbData = pFileData->pbData;
        
        //
        // Calculate the length to return, including the double null
        // Note: assuming no nulls in the middle of the file here
        //
        
        *pcbData = strlen( (CHAR *) pbData ) + sizeof(WCHAR);
    }

    pCacheFileInfo->pbData = *ppbData = pbData;
    pCacheFileInfo->dwCacheFlags = fCached;
    pCacheFileInfo->pFileData = pFileData;

    if ( pbBuff )
    {
        LocalFree( pbBuff );
    }

    return TRUE;

ErrorExit:

    if ( pbBuff )
    {
        if ( pbBuff == pbData )
        {
             pbData = NULL;
        }
        LocalFree( pbBuff );
    }

    if ( pbData )
    {
        if ( fCached )
        {
            DBG_REQUIRE( TsCheckInCachedBlob( pFileData ));

        }
        else
        {
            DBG_REQUIRE( TsFree( *pTsvcCache,
                                 pFileData ));
        }
    }

    return FALSE;
}

BOOL
CheckInCachedFile(
    IN     TSVC_CACHE *     pTsvcCache,
    IN     PCACHE_FILE_INFO pCacheFileInfo
    )
/*++
    Description:

        Checks in or frees a cached file

    Arguments:

        pTsvcCache - Cache object to charge memory against
        pCacheFileInfo - Pointer to file cache information

    Returns:
        TRUE if successful, FALSE otherwise

    Notes:

--*/
{
    BOOL fRet;

    DBG_ASSERT( (pCacheFileInfo->dwCacheFlags == FALSE) || (
                 pCacheFileInfo->dwCacheFlags == TRUE) );

    //
    //  If we cached the item, check it back in to the cache, otherwise
    //  free the associated memory
    //

    if ( pCacheFileInfo->dwCacheFlags )
    {
        DBG_REQUIRE( fRet = TsCheckInCachedBlob( pCacheFileInfo->pFileData ));

    }
    else
    {
        DBG_REQUIRE( fRet = TsFree( *pTsvcCache,
                                    pCacheFileInfo->pFileData ));
    }

    return fRet;
}

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !pbuffdecoded->Resize( nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded->QueryPtr();

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded->QueryPtr())[nbytesdecoded] = '\0';

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}


//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage].
//

BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 )
{
   unsigned char *outptr;
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !pbuffEncoded->Resize( nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) pbuffEncoded->QueryPtr();

   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}

/************************ End of File ***********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\igateway.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      igateway.cxx

   Abstract:
   
      This module defines the functions for Internet Services related
       gateway processing ( spawning process and thread for i/o).

   Author:

       Murali R. Krishnan    ( MuraliK )     25-Jan-1995 

   Environment:

      User Mode - Win32
       
   Project:

      Internet Services Common DLL

   Functions Exported:

      BOOL TsProcessGatewayRequest( 
               IN LPVOID pClientContext,
               IN PIGATEWAY_REQUEST  pigRequest,
               IN PFN_GATEWAY_READ_CALLBACK pfnReadCallBack);

   Revision History:

--*/

/*++

   A service may require gateway call to process special 
     requests received from the clients. 
   Such requests are processed by spawning a special process and communicating
     with the special process. The process takes the client supplied data as 
     input and sends its output to  be sent to the client.
   Since the service module is aware of the details of input and output,
     a special thread is created in the service process to deal with the
     input and output. A two-way pipe is established b/w the spawned process
     and the service thread.
   Once the "special gateway process" completes processing the input and 
    terminates, the thread doing I/O proceeds to munging.
   During munging state, the thread calls upon a callback function for
     munging and data transfer. The call-back function is  responsible 
     for altering the data if need be and sending the data to client.
     After this the service thread terminates its work.


--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <tcpdllp.hxx>
# include "igateway.hxx"


# define MAX_CB_DATA_FROM_GATEWAY         ( 4096)


/************************************************************
 *    Type Definitions
 ************************************************************/


class IGATEWAY_PROCESSOR {

  public:
    
    inline 
      IGATEWAY_PROCESSOR( 
        IN LPVOID    pClientContext, 
        IN PFN_IGATEWAY_READ_CALLBACK  pfnReadCallBack,
        IN LPBYTE     pbDataToGateway = NULL,
        IN DWORD      cbDataToGateway = 0
        )
      : m_pClientContext         ( pClientContext),
        m_pfnReadCallBack        ( pfnReadCallBack),
        m_pbDataToGateway        ( pbDataToGateway),
        m_cbDataToGateway        ( cbDataToGateway),
        m_hStdIn                 ( INVALID_HANDLE_VALUE),
        m_hStdOut                ( INVALID_HANDLE_VALUE)
          {
              m_fCompleted = 0;
              m_fValid = ( m_pfnReadCallBack   != NULL);
          }
                           
    
    inline virtual ~IGATEWAY_PROCESSOR( VOID);
    
    BOOL IsValid( VOID) const
      { return ( m_fValid); }

    VOID
      SetProcessingCompleted( IN BOOL fValue = TRUE) 
        { m_fCompleted = ( fValue) ? 1 : 0; }

    BOOL
      IsProcessingCompleted( VOID) const
        { return ( m_fCompleted == 1); }

    HANDLE
      QueryStdInHandle( VOID) const
        { return ( m_hStdIn); }
    
    HANDLE
      QueryStdOutHandle( VOID) const
        { return ( m_hStdOut); }

    BOOL
      StartGatewayProcess( 
         IN LPCTSTR  pszCmdLine,
         IN LPCTSTR  pszWorkingDir,
         IN LPVOID   lpvEnvironment,
         IN HANDLE   hUserToken);


    //
    // the worker thread for gateway request processing
    //
    DWORD
      GatewayIOWorker( VOID); 


# if DBG

    VOID Print( VOID) const;

# endif // DBG

  private:

    DWORD        m_fValid : 1;
    DWORD        m_fCompleted : 1;
    

    PVOID        m_pClientContext;       // client context information
    PFN_IGATEWAY_READ_CALLBACK m_pfnReadCallBack;
    
    HANDLE       m_hStdIn;
    HANDLE       m_hStdOut;

    LPBYTE       m_pbDataToGateway;
    DWORD        m_cbDataToGateway;

    BOOL
      SetupChildPipes( IN STARTUPINFO * pStartupInfo);
    

};  // class IGATEWAY_PROCESSOR


typedef  IGATEWAY_PROCESSOR * PIGATEWAY_PROCESSOR;


inline IGATEWAY_PROCESSOR::~IGATEWAY_PROCESSOR( VOID)
{
    DBG_ASSERT( IsProcessingCompleted());
    
    if ( m_hStdIn != INVALID_HANDLE_VALUE &&
         !CloseHandle( m_hStdIn)) {
        
        IF_DEBUG( GATEWAY) {
            
            DBGPRINTF( ( DBG_CONTEXT,
                        "IGATEWAY_PROCESSOR:CloseHandle( StdIn %08x) failed."
                        " Error = %d.\n",
                        m_hStdIn, GetLastError()));
        }
    }
    
    if ( m_hStdOut != INVALID_HANDLE_VALUE &&
         !CloseHandle( m_hStdOut)) {
        
        IF_DEBUG( GATEWAY) {
            
            DBGPRINTF( ( DBG_CONTEXT,
                        "IGATEWAY_PROCESSOR:CloseHandle( StdOut %08x) failed."
                        " Error = %d.\n",
                        m_hStdOut, GetLastError()));
        }
    }

} // IGATEWAY_PROCESSOR::~IGATEWAY_PROCESSOR()




# if DBG

static inline VOID
PrintStartupInfo( IN const STARTUPINFO * pStartInfo)
{

    IF_DEBUG( GATEWAY) {
        DBGPRINTF( ( DBG_CONTEXT,
                    " Startup Info = %08x. cb = %d."
                    " hStdInput = %08x. hStdOutput = %08x."
                    " hStdError = %08x.\n",
                    pStartInfo, pStartInfo->cb,
                    pStartInfo->hStdInput,
                    pStartInfo->hStdOutput,
                    pStartInfo->hStdError));
    }

} // PrintStartupInfo()


static inline VOID
PrintProcessInfo( IN const PROCESS_INFORMATION * pProcInfo)
{
    IF_DEBUG( GATEWAY) {
        DBGPRINTF( ( DBG_CONTEXT, 
                    " ProcessInfo = %08x."
                    " hProcess = %08x. hThread = %08x."
                    " dwProcessId = %08x. dwThreadId = %08x",
                    pProcInfo, pProcInfo->hProcess,
                    pProcInfo->hThread, 
                    pProcInfo->dwProcessId,
                    pProcInfo->dwThreadId));
    }

} // PrintProcessInfo()

# endif // DBG


/************************************************************
 *    Functions 
 ************************************************************/


static 
DWORD
WINAPI
GatewayRequestIOThreadFunction(
   IN LPVOID  pThreadParam)
/*++
   The function is called when the thread for Gateway request I/O is created.
   This function calls the GatewayIOWorker member function to process I/O
     from the gateway process.

  In addition this function also deletes the IGATEWAY_PROCESSOR object, at 
   the end. Memory deallocation is done here, since this thread will die
   at the end of this procedure and no other thread has knowledge about this
   object to perform cleanup.

  Arguments:
     pThreadParam        pointer to thread parameter. This function is called
                          with the parameter as the pointer to 
                          IGATEWAY_PROCESSOR object.

  Returns:
    Win32 error code resulting from gateway I/O processing.
 
--*/
{
    PIGATEWAY_PROCESSOR pigProcessor = (PIGATEWAY_PROCESSOR ) pThreadParam;
    DWORD dwError;
    
    DBG_ASSERT( pigProcessor != NULL);

    dwError =  pigProcessor->GatewayIOWorker();

    IF_DEBUG( GATEWAY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Freeing the IGATEWAY_PROCESSOR object ( %08x)\n",
                    pigProcessor));
    }

    delete pigProcessor;

    return ( dwError);
} // GatewayRequestIOThreadFunction()





dllexp BOOL
TsProcessGatewayRequest( 
   IN LPVOID                     pClientContext,
   IN PIGATEWAY_REQUEST          pigRequest,
   IN PFN_IGATEWAY_READ_CALLBACK pfnReadCallBack)
/*++

  Description:
    This function creates a gateway processor object responsible for processing
    gateway requests. It extracts the parameters required from input request
    package ( IGATEWAY_REQUEST structure). It creates a separate process for 
    gateway request and a separate thread for handling I/O for the 
    gateway request. The thread uses buffers supplied for i/o in pigRequest.
    On a completion of read, the thread calls the callback function for 
    processing the data retrieved. If the call back function returns any error
    further procecssing in the thread is halted and the thread dies.
    The process also will eventually die, since the pipes are broken.


  Arguments:
      pClientContext        context information supplied by client
      pigRequest            pointer to IGATEWAY_REQUEST object.
      pfnReadCallBack       pointer to callback function for read completions.

  Returns:
      TRUE on success and FALSE if there is any failure.
      Use GetLastError() to retrieve Win32 error code.
--*/
{
    BOOL fReturn = FALSE;
    PIGATEWAY_PROCESSOR  pigProcessor = NULL;


    DBG_ASSERT( pigRequest != NULL && pfnReadCallBack != NULL);

    IF_DEBUG( GATEWAY) {

        DBGPRINTF( ( DBG_CONTEXT, 
                    "TsProcessGatewayRequest() called. pigRequest = %08x.\n",
                    pigRequest));
    }


    //
    // create a new gateway processor object for handling the gateway request.
    //
    
    pigProcessor = new IGATEWAY_PROCESSOR( pClientContext,
                                           pfnReadCallBack,
                                           pigRequest->pbDataToGateway,
                                           pigRequest->cbDataToGateway);
    
    fReturn = ( pigProcessor != NULL) && pigProcessor->IsValid();

    if ( fReturn) {
        
        IF_DEBUG( GATEWAY) {

            DBGPRINTF( ( DBG_CONTEXT, 
                        " Created a new IGATEWAY_PROCESSOR object.\n"));
            DBG_CODE( pigProcessor->Print());
            
            DBGPRINTF( ( DBG_CONTEXT,
                        " Starting a process for the gateway command\n"));
        }

        fReturn = pigProcessor->StartGatewayProcess( pigRequest->pszCmdLine,
                                                    pigRequest->pszWorkingDir,
                                                    pigRequest->lpvEnvironment,
                                                    pigRequest->hUserToken);
        if ( fReturn) {

            HANDLE hThread;
            DWORD  dwThreadId;

            IF_DEBUG( GATEWAY) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Creating a new thread to handle gateway I/O\n"));
            }

            //
            // Create a new thread to handle I/O with the process spawned.
            //

            hThread = CreateThread( NULL,         // lpSecurityAttributes,
                                    0,            // stack size in Bytes,
                                    GatewayRequestIOThreadFunction,
                                    (LPVOID )pigProcessor,  // params
                                    0,            // Creation flags
                                    &dwThreadId);
            
            if ( ( fReturn = ( hThread != NULL)))  {
                
                IF_DEBUG( GATEWAY) {
                    
                    DBGPRINTF( ( DBG_CONTEXT,
                                " Created Gateway I/O thread. Hdl=%d. Id=%d\n",
                                hThread, dwThreadId));
                }

                //
                // Close thread handle, since we are not bothered about its
                //  termination and there is no special cleanup required.
                //
                DBG_REQUIRE( CloseHandle( hThread));
                
            } else {

                IF_DEBUG( GATEWAY) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                "Creation of gateway I/O thread failed."
                                " Error = %d\n",
                                GetLastError()));
                }
            } // creation of IO thread
        } // successful start of process for gateway.
    } // creation of pigProcessor



    if ( !fReturn) {

        IF_DEBUG( GATEWAY) {
            
            DBGPRINTF( ( DBG_CONTEXT,
                        " Failure to set up gateway request processiong."
                        " Deleting the IGATEWAY_PROCESSOR object( %08x)."
                        " Error = %d.\n",
                        pigProcessor,
                        GetLastError()));
        }

        if ( pigProcessor != NULL) {

            DBG_ASSERT( !pigProcessor->IsValid());
            delete pigProcessor;
        }
    }

    return ( fReturn);
} // TsProcessGatewayRequest()



/************************************************************
 *   IGATEWAY_PROCESSOR member functions
 ************************************************************/



BOOL
IGATEWAY_PROCESSOR::StartGatewayProcess(
    IN LPCTSTR  pszCmdLine,
    IN LPCTSTR  pszWorkingDir,
    IN LPVOID   lpvEnvironment,               // optional
    IN HANDLE   hUserToken)
/*++
  Description:
    This function sets up pipes for communication with gateway
     and starts a process for gateway application.

  Arguments:
    pszCmdLine     pointer to null-terminated string containing the 
                    command line for the gateway call.
                   The first word ( seq of chars) in pszCmdLine, specifies
                    the gateway application to be used.

    pszWorkingDir  pointer to working directory for the gateway call.
    hUserToken    handle for the user accessing gateway for secure access.
    lpvEnvironment pointer to Environment Block for CreateProcess to pass
                      environment information to the gateway application.
    
  Returns:
  TRUE on success; and FALSE if there is any failure.
    Use GetLastError() for Win32 error code.
--*/
{
    BOOL                fReturn;
    STARTUPINFO         startInfo;
    PROCESS_INFORMATION procInfo;

    DBG_ASSERT( pszCmdLine != NULL && pszWorkingDir != NULL);
    DBG_ASSERT( hUserToken != INVALID_HANDLE_VALUE);

    memset( (PVOID ) &procInfo,  0, sizeof( procInfo));
    memset( (PVOID ) &startInfo, 0, sizeof( startInfo));
    startInfo.cb = sizeof( startInfo);

    
    if ( ( fReturn = SetupChildPipes( &startInfo))) {

        //
        // Successfully setup the child pipes. Proceed to create the process.
        //

        fReturn = CreateProcessAsUser(  hUserToken,
                                       NULL,         // pszImageName
                                       (TCHAR *) pszCmdLine, // pszCommandLine
                                       NULL,         // process security
                                       NULL,         // thread security
                                       TRUE,         // inherit handles,
                                       DETACHED_PROCESS,
                                       lpvEnvironment,
                                       pszWorkingDir,
                                       &startInfo,
                                       &procInfo);


        DBG_CODE( PrintStartupInfo( &startInfo));
        DBG_CODE( PrintProcessInfo( &procInfo));

        //
        //  Had already set up the stderror to be same as stdoutput
        //  in SetupChildPipes(). Verify the same.
        //
        
        if ( fReturn) {

            DBG_REQUIRE( startInfo.hStdError == startInfo.hStdOutput);

            DBG_REQUIRE( CloseHandle( startInfo.hStdOutput));
            DBG_REQUIRE( CloseHandle( startInfo.hStdInput));
            DBG_REQUIRE( CloseHandle( procInfo.hProcess));
            DBG_REQUIRE( CloseHandle( procInfo.hThread));
        }
        
        IF_DEBUG( GATEWAY) {
            
            DBGPRINTF( ( DBG_CONTEXT,
                        "StartGatewayProcess: CreateProcessAsUser( %s)"
                        " returns %d. Error = %d.\n",
                        pszCmdLine, fReturn, GetLastError()));
        }
                                      
    } else {

        IF_DEBUG( GATEWAY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "StartGatewayProcess(). Unable to setup child Pipes."
                        " Error = %d\n",
                        GetLastError()));
        }
    }

    return ( fReturn);
} // IGATEWAY_PROCESSOR::StartGatewayProcess()





BOOL
IGATEWAY_PROCESSOR::SetupChildPipes( IN LPSTARTUPINFO lpStartupInfo)
/*++
  Description:
    Creates pipe and duplicates handles for redirecting stdin and stdout
      to child process.

  Arguments:
     pStartupInfo       pointer to startup information structure used by
                        CreateProcess().
                        This receives the child stdin and stdout.

  Returns:
     TRUE on success and FALSE if there is any error.
--*/
{
    BOOL fReturn;
    SECURITY_ATTRIBUTES  securityAttributes;

    DBG_ASSERT( lpStartupInfo != NULL);

    securityAttributes.nLength              = sizeof( securityAttributes);
    securityAttributes.bInheritHandle       = TRUE;
    securityAttributes.lpSecurityDescriptor = NULL;

    m_hStdIn  = m_hStdOut  = NULL;
    lpStartupInfo->dwFlags = STARTF_USESTDHANDLES;
    
    //
    // create pipes for communication and duplicate handles.
    // mark the duplicates handles as non-inherited to avoid handle leaks
    //
    
    fReturn  = ( CreatePipe( &m_hStdIn,                // parent read pipe
                            &lpStartupInfo->hStdOutput,// child write pipe
                            &securityAttributes,
                            0) &&                      // nSize
                DuplicateHandle( GetCurrentProcess(),  // hSourceProcess
                                 m_hStdIn,             // hSourceHandle
                                 GetCurrentProcess(),  // hTargetProcess
                                 &m_hStdIn,            // lphTargetHandle
                                 0,                    // desired access
                                 FALSE,                // bInheritHandle
                                 DUPLICATE_SAME_ACCESS | 
                                  DUPLICATE_CLOSE_SOURCE) &&
                CreatePipe( &lpStartupInfo->hStdInput, // parent read pipe
                           &m_hStdOut,                 // child write pipe
                           &securityAttributes,
                           0) &&                       // nSize
                DuplicateHandle( GetCurrentProcess(),  // hSourceProcess
                                m_hStdOut,             // hSourceHandle
                                GetCurrentProcess(),   // hTargetProcess
                                &m_hStdOut,            // lphTargetHandle
                                0,                     // desired access
                                FALSE,                 // bInheritHandle
                                DUPLICATE_SAME_ACCESS | 
                                 DUPLICATE_CLOSE_SOURCE)
                );


    //
    // stdout and stderr share the same handle. In the worst case 
    //  clients close stderr before closing stdout, then we need to duplicate
    //  stderr too. For now dont duplicate stdout.
    //
    lpStartupInfo->hStdError = lpStartupInfo->hStdOutput;


    IF_DEBUG( GATEWAY) {
        
        DBGPRINTF( ( DBG_CONTEXT,
                    "Handles. ChildProcess. In= %08x. Out= %08x. Err= %08x.\n",
                    lpStartupInfo->hStdInput,
                    lpStartupInfo->hStdOutput,
                    lpStartupInfo->hStdError));

        DBGPRINTF( ( DBG_CONTEXT,
                    " IO Thread. In= %08x. Out= %08x.\n",
                    m_hStdIn,
                    m_hStdOut));
    }

    if ( !fReturn) {

        IF_DEBUG( GATEWAY) {

            DBGPRINTF( ( DBG_CONTEXT, 
                        " SetupChildPipes failed. Error = %d.\n",
                        GetLastError()));
        }

        //
        //   Free up the handles if any allocated.
        //
        
        if ( m_hStdIn != NULL) {
            
            DBG_REQUIRE( CloseHandle( m_hStdIn));
            m_hStdIn = INVALID_HANDLE_VALUE;
        }

        if ( m_hStdOut != NULL) {
            
            DBG_REQUIRE( CloseHandle( m_hStdOut));
            m_hStdOut = INVALID_HANDLE_VALUE;
        }
    }

    return ( fReturn);
} // IGATEWAY_PROCESSOR::SetupChildPipes()





DWORD
IGATEWAY_PROCESSOR::GatewayIOWorker( VOID)
/*++
  Description:
    This is the core function that performs the I/O with the gateway process.
    I/O is performed using the pipes created by cross-linking 
    the stdout and stdin of gateway process to duplicated handles in the I/O
     thread.

    First, this function writes any data to be sent to the gateway process
       on the read pipe of the process
       ( to m_hStdOut of the IGATEWAY_PROCESSOR object).
    
    Subsequently it loops receiving data from the gateway process and passing
       it onto the client ( meaning service that requested gateway processing).
       It uses the read callback function to make the client perform necessary
         work.
    At the least the client should copy the data returned during in  callback.
    ( Otherwise, there is a danger of the data getting lost in subsequent 
      read from the gateway process.)

  Arguments:
     None

  Returns:
     Win32 error code.
--*/
{
    DWORD  dwError = NO_ERROR;
    BOOL   fDoneWaitingForGateway;
    BYTE   pbDataFromGateway[ MAX_CB_DATA_FROM_GATEWAY];
    DWORD  cbRead = 0;
    
    IF_DEBUG( GATEWAY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering IGATEWAY_PROCESSOR( %08x)::GatewayIOWorker()\n",
                    this));
    }

    //
    // 1. Write any data to the gateway process's stdin
    //
    
    if ( m_cbDataToGateway != 0) {

        DWORD cbWritten;
        BOOL  fWritten;

        DBG_ASSERT( m_pbDataToGateway != NULL);

        IF_DEBUG( GATEWAY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "GatewayIOWorker( %08x)."
                        " Writing %u bytes to gateway ( child) process's"
                        " stdin ( %08x)\n",
                        this, m_cbDataToGateway, m_hStdOut));
        }

        fWritten = WriteFile( m_hStdOut,
                              m_pbDataToGateway,
                              m_cbDataToGateway, 
                              &cbWritten,
                             NULL);

        IF_DEBUG( GATEWAY) { 

            DBGPRINTF( ( DBG_CONTEXT,
                        "GatewayIOWorker( %08x). WriteFile() returns %d."
                        " written %u bytes of %u bytes. Error = %d.\n",
                        this, fWritten, cbWritten, m_cbDataToGateway, 
                        GetLastError()));
        }

        //
        // The error if any during WriteFile() is ignored.
        //


    }  // data written to gateway process


    //
    //  2.  Loop for data from gateway.
    //

    DBG_ASSERT( m_pfnReadCallBack != NULL);
    for( fDoneWaitingForGateway = FALSE; !fDoneWaitingForGateway; ) {

        BOOL fCallBack;
        
        //
        //  3. Wait for data from gateway process.
        //

        dwError = WaitForSingleObject( m_hStdIn, INFINITE);

        //
        // 4. Depending on return code, either read data or get error code
        //

        switch( dwError) {

          case WAIT_OBJECT_0:
            {
                
                BOOL   fRead;
                
                //
                // 4.a  Got something to read. Read the data into buffer.
                //
                
                fRead = ReadFile( m_hStdIn, 
                                 pbDataFromGateway,
                                 MAX_CB_DATA_FROM_GATEWAY,
                                 &cbRead,
                                 NULL);
                
                dwError = ( fRead) ? NO_ERROR: GetLastError();
                
                IF_DEBUG( GATEWAY) {
                    
                    DBGPRINTF( ( DBG_CONTEXT, 
                                " GatewayIOWorker( %08x). ReadDataFromGateway"
                                " returns %d. Read %d bytes. Error = %d.\n",
                                this, fRead, cbRead, dwError));
                }
                
                if ( dwError == ERROR_BROKEN_PIPE) {

                    fDoneWaitingForGateway = TRUE;
                }
                
                break;
                
            } // case WAIT_OBJECT_0
            
            
          case WAIT_FAILED:
          default: {
              //
              // Unknown error.
              // 

              IF_DEBUG( GATEWAY) {

                  DBGPRINTF( ( DBG_CONTEXT, 
                              " GatewayIOWorker(). WaitForReading Gateway"
                              " data failed. Error = %d\n",
                              dwError));
              }

              fDoneWaitingForGateway = TRUE; 
              break;
          }
            
        } // switch

        //
        // 5. send data or error code back to the callback function.
        //
        
        fCallBack = ( *m_pfnReadCallBack)( m_pClientContext,
                                          dwError,
                                          pbDataFromGateway,
                                          cbRead);

        if ( !fCallBack) {

            dwError = GetLastError();

            IF_DEBUG( GATEWAY) {
                DBGPRINTF( ( DBG_CONTEXT, 
                            " GatewayIOWorker( %08x). ReadCallback failed."
                            " Exiting the gateway processing. Error = %d\n",
                            dwError));
            }

            fDoneWaitingForGateway = TRUE;
        }
        
    } // for


    IF_DEBUG( GATEWAY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " GatewayIOWorker( %08x). Exiting the IO thread."
                    " Error = %d.\n",
                    this, dwError));
    }
    
    SetProcessingCompleted( TRUE);

    return ( dwError);
} // IGATEWAY_PROCESSOR::GatewayIOWorker()




# if DBG

VOID
IGATEWAY_PROCESSOR::Print( VOID) const
{
    
    DBGPRINTF( ( DBG_CONTEXT, 
                " Printing IGATEWAY_PROCESSOR object ( %08x)\n",
                this));
    
    DBGPRINTF( ( DBG_CONTEXT,
                "IsValid = %d. IsIOCompleted = %d.\n",
                m_fValid, m_fCompleted));

    DBGPRINTF( ( DBG_CONTEXT, 
                " Client Context = %08x\tIO call back function = %08x\n",
                m_pClientContext, m_pfnReadCallBack));
    
    DBGPRINTF( ( DBG_CONTEXT,
                " Child StdIn handle = %08x\t Child StdOut handle = %08x\n",
                m_hStdIn, m_hStdOut));
    
    DBGPRINTF( ( DBG_CONTEXT,
                " Buffer for Data to Gateway = %08x, %u bytes\n",
                m_pbDataToGateway, m_cbDataToGateway));
    
    return;
} // IGATEWAY_PROCESSOR::Print()



dllexp VOID
PrintIGatewayRequest( IN const IGATEWAY_REQUEST * pigRequest)
{
    
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing IGATEWAY_REQUEST object ( %08x)\n",
                pigRequest));
    
    if ( pigRequest != NULL) {

        DBGPRINTF( ( DBG_CONTEXT, 
                    " CommandLine = %s.\n WorkingDir = %s\n",
                    pigRequest->pszCmdLine, pigRequest->pszWorkingDir));
        DBGPRINTF( ( DBG_CONTEXT,
                    " UserHandle = %08x. lpvEnvironment = %08x\n",
                    pigRequest->hUserToken, pigRequest->lpvEnvironment));

        DBGPRINTF( ( DBG_CONTEXT,
                    " pbDataToGateway = %08x. cbDataToGateway = %u.\n",
                    pigRequest->pbDataToGateway, pigRequest->cbDataToGateway));
    }

    return;
} // PrintIGatewayRequest()



# endif // DBG



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\iisbind.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iisbind.cxx

Abstract:

    This module implements the IIS_SERVER_BINDING class.

Author:

    Keith Moore (keithmo)        16-Jan-1997

Revision History:

--*/


#include "tcpdllp.hxx"
#pragma hdrstop
#include <iisbind.hxx>


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_SERVER_BINDING::IIS_SERVER_BINDING(
    IN DWORD IpAddress,
    IN USHORT IpPort,
    IN const CHAR * HostName,
    IN PIIS_ENDPOINT Endpoint
    ) :
    m_IpAddress( IpAddress ),
    m_IpPort( IpPort ),
    m_HostName( HostName ),
    m_Endpoint( Endpoint )
/*++

Routine Description:

    IIS_SERVER_BINDING constructor.

Arguments:

    IpAddress - The IP address for this binding. May be INADDR_ANY.

    IpPort - The IP port for this binding. Required.

    HostName - The host name for this binding. May be empty ("").

    Endpoint - The IIS_ENDPOINT to associate with this binding.

Return Value:

    None.

--*/
{

    //
    // Sanity check.
    //

    DBG_ASSERT( HostName != NULL );
    DBG_ASSERT( Endpoint != NULL );

}   // IIS_SERVER_BINDING::IIS_SERVER_BINDING


IIS_SERVER_BINDING::~IIS_SERVER_BINDING()
/*++

Routine Description:

    IIS_SERVER_BINDING destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

    //
    // This space intentionally left blank.
    //

}   // IIS_SERVER_BINDING::~IIS_SERVER_BINDING()


DWORD
IIS_SERVER_BINDING::ParseDescriptor(
    IN const CHAR * Descriptor,
    OUT LPDWORD IpAddress,
    OUT PUSHORT IpPort,
    OUT const CHAR ** HostName
    )
/*++

Routine Description:

    Parses a descriptor string of the form "ip_address:ip_port:host_name"
    into its component parts.

Arguments:

    Descriptor - The descriptor string.

    IpAddress - Receives the IP address component if present, or
        INADDR_ANY if not.

    IpPort - Recieves the IP port component.

    HostName - Receives a pointer to the host name component.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    const CHAR * ipAddressString;
    const CHAR * ipPortString;
    const CHAR * hostNameString;
    const CHAR * end;
    CHAR temp[sizeof("123.123.123.123")];
    INT length;
    LONG tempPort;

    //
    // Sanity check.
    //

    DBG_ASSERT( Descriptor != NULL );
    DBG_ASSERT( IpAddress != NULL );
    DBG_ASSERT( IpPort != NULL );
    DBG_ASSERT( HostName != NULL );

    //
    // Find the various parts of the descriptor;
    //

    ipAddressString = Descriptor;

    ipPortString = strchr( ipAddressString, ':' );

    if( ipPortString == NULL ) {
        goto fatal;
    }

    ipPortString++;

    hostNameString = strchr( ipPortString, ':' );

    if( hostNameString == NULL ) {
        goto fatal;
    }

    hostNameString++;

    //
    // Validate and parse the IP address portion.
    //

    if( *ipAddressString == ':' ) {

        *IpAddress = INADDR_ANY;

    } else {

        length = DIFF(ipPortString - ipAddressString) - 1;

        if( length > sizeof(temp) ) {
            goto fatal;
        }

        memcpy(
            temp,
            ipAddressString,
            length
            );

        temp[length] = '\0';

        *IpAddress = (DWORD)inet_addr( temp );

        if( *IpAddress == INADDR_NONE ) {
            goto fatal;
        }

    }

    //
    // Validate and parse the port.
    //

    if( *ipPortString == ':' ) {
        goto fatal;
    }

    length = DIFF(hostNameString - ipPortString);

    if( length > sizeof(temp) ) {
        goto fatal;
    }

    memcpy(
        temp,
        ipPortString,
        length
        );

    temp[length] = '\0';

    tempPort = strtol(
                   temp,
                   (CHAR **)&end,
                   0
                   );

    if( tempPort <= 0 || tempPort > 0xFFFF ) {
        goto fatal;
    }

    if( *end != ':' ) {
        goto fatal;
    }

    *IpPort = (USHORT)tempPort;

    //
    // Validate and parse the host name.
    //

    if( *hostNameString == ' ' || *hostNameString == ':' ) {
        goto fatal;
    }

    *HostName = hostNameString;

    return NO_ERROR;

fatal:

    return ERROR_INVALID_PARAMETER;

}   // IIS_SERVER_BINDING::ParseDescriptor


DWORD
IIS_SERVER_BINDING::Compare(
    IN const CHAR * Descriptor,
    OUT LPBOOL Result
    )
/*++

Routine Description:

    Compares the current binding with the descriptor string.

Arguments:

    Descriptor - The descriptor to compare against.

    Result - Receives the result of the comparison (TRUE if they match,
        FALSE otherwise).

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    DWORD ipAddress;
    USHORT ipPort;
    const CHAR * hostName;
    DWORD status;

    //
    // Sanity check.
    //

    DBG_ASSERT( Descriptor != NULL );
    DBG_ASSERT( Result != NULL );

    //
    // Parse the descriptor.
    //

    status = ParseDescriptor(
                 Descriptor,
                 &ipAddress,
                 &ipPort,
                 &hostName
                 );

    if( status == NO_ERROR ) {

        *Result = Compare(
                      ipAddress,
                      ipPort,
                      hostName
                      );

    }

    return status;

}   // IIS_SERVER_BINDING::Compare


BOOL
IIS_SERVER_BINDING::Compare(
    IN DWORD IpAddress,
    IN USHORT IpPort,
    IN const CHAR * HostName
    )
/*++

Routine Description:

    Compares the current binding with the specified IP address, IP port,
    and host name.

Arguments:

    IpAddress - The IP address to compare against.

    IpPort - The IP port to compare against.

    HostName - The host name to compare against.

Return Value:

    BOOL - TRUE if they match, FALSE otherwise.

--*/
{

    //
    // Sanity check.
    //

    DBG_ASSERT( HostName != NULL );

    //
    // Compare the components.
    //

    if( IpAddress == QueryIpAddress() &&
        IpPort == QueryIpPort() &&
        !_stricmp(
            HostName,
            QueryHostName()
            ) ) {

        return TRUE;

    }

    return FALSE;

}   // IIS_SERVER_BINDING::Compare


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\iiscert.cxx ===
/*++





Copyright (c) 1997  Microsoft Corporation

Module Name:

    iiscert.cxx

Abstract:

    Code to handle retrieving/storing/using CAPI2 certificate contexts for IIS server 
    certificates.

Author:

    Alex Mallet (amallet)    02-Dec-1997

--*/

#include "tcpdllp.hxx"
#pragma hdrstop

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>


//
// Local includes
//
#include "iiscert.hxx"
#include "capiutil.hxx"


#define SHA1_HASH_SIZE 20 //size of SHA1 hash 

HCRYPTPROV IIS_SERVER_CERT::m_hFortezzaCSP = NULL;
HCRYPTDEFAULTCONTEXT IIS_SERVER_CERT::m_hFortezzaCtxt = NULL;

IIS_SERVER_CERT::IIS_SERVER_CERT( IN IMDCOM *pMDObject,
                                  IN LPTSTR pszMBPath ) :
m_strMBPath( pszMBPath ),
m_pStoreInfo( NULL ), 
m_hCryptProv( NULL ),
m_pCertContext( NULL ),
m_fIsFortezzaCert( FALSE )
/*++

Routine Description:

    Constructor for server cert that reads all necessary info out of metabase

Arguments:

    pMDObject - pointer to metabase object 
    pszMBPath - full path in metabase to information for this virtual server instance

Returns:

   Nothing

--*/
{
    DBG_ASSERT( pMDObject );
    DBG_ASSERT( pszMBPath );

    DWORD dwSize = 0;
    METADATA_HANDLE hInstanceInfoHandle = NULL;
    int iLengthNeeded = 0;
    PBYTE pbCertHash = NULL;
    DWORD dwHashSize = 0;
    DWORD dwPathLength = 0;
    MB mb( pMDObject );
    LPTSTR pszCSPString = NULL;
    LPTSTR pszCSPStringCopy = NULL;
    BOOL fProgPINEntry = FALSE;

    m_dwStatus = CERT_ERR_NONE;

    if ( !m_strMBPath.IsValid() )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        goto EndRetrieveCertContext;
    }

    if ( mb.Open( m_strMBPath.QueryStr(),
                  METADATA_PERMISSION_READ ))
    {
        DWORD dwReqDataLen = 0;
        METADATA_RECORD mdr;
        DWORD dwFortezza = 0;

        //
        // Retrieve cert hash
        //
        MD_SET_DATA_RECORD(&mdr, MD_SSL_CERT_HASH, METADATA_NO_ATTRIBUTES,
                           IIS_MD_UT_SERVER, BINARY_METADATA, NULL,
                           0);


        if ( !RetrieveBlobFromMetabase(&mb,
                                       NULL,
                                       &mdr,
                                       SHA1_HASH_SIZE ) ) 

        {
            m_dwStatus = CERT_ERR_MB;
            goto EndRetrieveCertContext;
        }
        else
        {
            DBG_ASSERT( mdr.dwMDDataLen == SHA1_HASH_SIZE );

            pbCertHash = mdr.pbMDData;
            dwHashSize = mdr.dwMDDataLen;
        }

        //
        // Retrieve flag indicating whether it's a Fortezza cert or not
        //
        if ( !mb.GetDword( NULL,
                           MD_SSL_CERT_IS_FORTEZZA,
                           IIS_MD_UT_SERVER,
                           &(dwFortezza),
                           METADATA_NO_ATTRIBUTES ) )
        {
            if ( GetLastError() != MD_ERROR_DATA_NOT_FOUND )
            {
                m_dwStatus = CERT_ERR_MB;
                goto EndRetrieveCertContext;
            }
            else
            {
                m_fIsFortezzaCert = FALSE;
            }
        }
        else
        {
            m_fIsFortezzaCert = (BOOL) dwFortezza;
        }

        //
        // If it's a Fortezza cert and we're supposed to do programmatic PIN entry,
        // we need to get a handle to the CSP ourselves by providing the 
        // PIN in the call to CryptAcquireContext(), to avoid the "Enter PIN" dialog 
        //
        if ( m_fIsFortezzaCert && ( fProgPINEntry = UseProgrammaticPINEntry( &mb ) ) )
        {
            LPTSTR pszPIN = NULL;
            LPTSTR pszSerialNumber = NULL;
            LPTSTR pszPersonality = NULL;
            DWORD cbPIN = 0;
            DWORD cbSerialNumber = 0;
            DWORD cbPersonality = 0;
            DWORD cbLen = 0;
            DWORD iPos = 0;
            
            if ( !RetrievePINInfo( &mb,
                                   &pszPIN,
                                   &pszSerialNumber,
                                   &pszPersonality ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Couldn't retrieve PIN info for Fortezza card\n"));
                m_dwStatus = CERT_ERR_MB;
                goto EndRetrieveCertContext;
            }
            DBG_ASSERT( pszPIN && pszSerialNumber && pszPersonality );
            
            //
            // Construct string to be passed to CryptAcquireContext - it's
            // <card serial #>\n<personality>\n<PIN>. 
            //
            cbPIN = strlen( pszPIN );
            cbSerialNumber = strlen( pszSerialNumber );
            cbPersonality = strlen( pszPersonality );
            cbLen = cbPIN + cbSerialNumber + cbPersonality + 10; //add a few bytes for CR
                                                                 //and null terminating char
            
            pszCSPString = new CHAR[cbLen];
            pszCSPStringCopy = new CHAR[cbLen];

            if ( !pszCSPString || !pszCSPStringCopy )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Couldn't allocate memory for CSP string\n"));
                
                //
                // Clean out the PIN info - the less time we leave it lying around,
                // the better
                //
                memset( pszPIN, 0, cbPIN );
                delete [] pszPIN;
                
                memset( pszSerialNumber, 0, cbSerialNumber );
                delete [] pszSerialNumber;
                
                memset( pszPersonality, 0, cbPersonality );
                delete [] pszPersonality;
                
                m_dwStatus = CERT_ERR_INTERNAL;
                
                goto EndRetrieveCertContext;
            }
            
            //
            // Build the magic string that will unlock the Fortezza secret ...
            //
            strcpy( pszCSPString, pszSerialNumber );
            strcat( pszCSPString, "\n" );
            strcat( pszCSPString, pszPersonality );
            strcat( pszCSPString, "\n" );
            strcat( pszCSPString, pszPIN );
            
            //
            // Make a copy we can reuse later
            //
            strcpy( pszCSPStringCopy, pszCSPString );

            //
            // Clean out the PIN & serial number - the less time we leave it lying around,
            // the better
            //
            memset( pszPIN, 0, cbPIN );
            delete [] pszPIN;
            
            memset( pszSerialNumber, 0, cbSerialNumber );
            delete [] pszSerialNumber;
            
            memset( pszPersonality, 0, cbPersonality );
            delete [] pszPersonality;
            
            //
            // Get a handle to the CSP, passing in the serial # etc and the 
            // CRYPT_SILENT flag to avoid any UI
            //
            if ( !CryptAcquireContext( &m_hCryptProv,
                                       pszCSPString,
                                       NULL,
                                       PROV_FORTEZZA,
                                       CRYPT_SILENT | CRYPT_MACHINE_KEYSET ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Couldn't get handle to Fortezza CSP : 0x%d\n",
                           GetLastError()));

                m_dwStatus = CERT_ERR_CAPI;
                goto EndRetrieveCertContext;
            }

            if ( !IIS_SERVER_CERT::m_hFortezzaCSP )
            {
                //
                // There's apparently no way to duplicate an HCRYPTPROV handle,
                // so we have to call CryptAcquireContext again. Also, rumour
                // has it that the Fortezza CSP nulls out the string passed to it,
                // so we have to use a copy of it 
                //
                if ( !CryptAcquireContext( &IIS_SERVER_CERT::m_hFortezzaCSP,
                                           pszCSPStringCopy,
                                           NULL,
                                           PROV_FORTEZZA,
                                           CRYPT_SILENT | CRYPT_MACHINE_KEYSET ) )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Couldn't get handle to Fortezza CSP : 0x%d\n",
                               GetLastError()));

                    m_dwStatus = CERT_ERR_CAPI;
                    goto EndRetrieveCertContext;
                }
                
                //
                // Install the handler used to verify Fortezza signatures.
                //
                CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA CDCMOP;
                LPSTR rgszOID[2];

                CDCMOP.cOID = 2;
                CDCMOP.rgpszOID = rgszOID;
                CDCMOP.rgpszOID[0] = szOID_INFOSEC_mosaicUpdatedSig;
                CDCMOP.rgpszOID[1] = szOID_INFOSEC_mosaicKMandUpdSig;

                if (!CryptInstallDefaultContext( IIS_SERVER_CERT::m_hFortezzaCSP,
                                                 CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID,
                                                 &CDCMOP,
                                                 CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG,
                                                 NULL,
                                                 &IIS_SERVER_CERT::m_hFortezzaCtxt ) )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to install Fortezza context : 0x%d\n",
                               GetLastError()));
                    m_dwStatus = CERT_ERR_CAPI;
                    goto EndRetrieveCertContext;
                }
            }
        }
    }
    mb.Close();

    //
    // Read store name etc out of MB
    //
    m_pStoreInfo = ReadCertStoreInfoFromMB( pMDObject,
                                            m_strMBPath.QueryStr(),
                                            FALSE );

    if ( !m_pStoreInfo )
    {
        m_dwStatus = CERT_ERR_MB;
        goto EndRetrieveCertContext;
    }

    //
    // Open store in which to look for the cert
    //
    if ( !(m_pStoreInfo->hCertStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                                     0,
                                                     (fProgPINEntry ? m_hCryptProv : NULL ),
                                                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                                     m_pStoreInfo->pszStoreName ) ) )

    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndRetrieveCertContext;
    }

    //
    // Try to find the cert in the store
    //
    CRYPT_HASH_BLOB HashBlob;
    HashBlob.cbData = dwHashSize;
    HashBlob.pbData = pbCertHash;
    
    m_pCertContext = CertFindCertificateInStore( m_pStoreInfo->hCertStore,
                                                 X509_ASN_ENCODING,
                                                 0,
                                                 CERT_FIND_SHA1_HASH,
                                                 (VOID *) &HashBlob,
                                                 NULL );
    
    if ( !m_pCertContext )
    {
        m_dwStatus = CERT_ERR_CERT_NOT_FOUND;
        goto EndRetrieveCertContext;
    }
    else
    {
#if DBG
        CHAR szSubjectName[1024];
        if ( CertGetNameString( m_pCertContext,
                                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                0,
                                NULL,
                                szSubjectName,
                                1024 ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Retrieved cert for %s \n", 
                       szSubjectName));
        }
#endif
    }
    
    if ( fProgPINEntry )
    {
        //
        // If this is a Fortezza cert, then we should set the 
        // CERT_KEY_PROV_HANDLE_PROP_ID property of the context to point to
        // the HCRYPTPROV retrieved by CryptAcquireContext().  Why?  Because
        // if we don't set this property, Schannel will try to acquire the 
        // provider handle itself, and will NOT set the CRYPT_MACHINE_KEY
        // flag when doing the call to CryptAcquireContext() and thus we
        // will not be able to acquire the credential handle in SSPIFILT.
        //
        // Fortezza rocks
        //
    
        if ( !CertSetCertificateContextProperty( m_pCertContext,
                                                 CERT_KEY_PROV_HANDLE_PROP_ID,
                                                 CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                                 (VOID*) m_hCryptProv ) )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndRetrieveCertContext;
        }
    }

    //
    // If we got this far, everything is happy
    //
    m_dwStatus = CERT_ERR_NONE;

EndRetrieveCertContext:

    //
    // This is where all the cleanup that takes place only if we fail needs to
    // happen
    //

    DBG_ASSERT( m_dwStatus < CERT_ERR_END );

    if ( m_dwStatus != CERT_ERR_NONE )
    {
        DBGPRINTF((DBG_CONTEXT,
                    "IIS_SERVER cert constructor, Error occurred : 0x%x\n", 
                    GetLastError()));

        if ( m_pCertContext != NULL )
        {
            CertFreeCertificateContext( m_pCertContext );
            m_pCertContext = NULL;
        }

        if ( m_pStoreInfo )
        {
            DeallocateCertStoreInfo( m_pStoreInfo );
            m_pStoreInfo = NULL;
        }


        if ( m_hCryptProv != NULL )
        {
            CryptReleaseContext( m_hCryptProv,
                                 0 );
            m_hCryptProv = NULL;
        }
    }

    //
    // Cleanup we do regardless of success/failure
    //
    //
    // clean out memory holding PIN
    //
    if ( pszCSPString )
    {
        memset( pszCSPString, 0, strlen( pszCSPString ) );
        delete [] pszCSPString;
    }

    if ( pszCSPStringCopy )
    {
        memset( pszCSPStringCopy, 0, strlen( pszCSPStringCopy ) );
        delete [] pszCSPStringCopy;
    }

    mb.Close();

} //IIS_SERVER_CERT::IIS_SERVER_CERT

IIS_SERVER_CERT::~IIS_SERVER_CERT()
/*++

Routine Description:
 
    Destructor

Arguments :
  
    None

Returns :

    Nothing
--*/
{
    if ( m_pCertContext )
    {
        CertFreeCertificateContext( m_pCertContext );
        m_pCertContext = NULL;
    }

    if ( m_pStoreInfo )
    {
        DeallocateCertStoreInfo( m_pStoreInfo );
        m_pStoreInfo = NULL;
    }

    if ( m_hCryptProv )
    {
        CryptReleaseContext( m_hCryptProv,
                             0 );
        m_hCryptProv = NULL;
    }
} //~IIS_SERVER_CERT::IIS_SERVER_CERT

BOOL IIS_SERVER_CERT::RetrievePINInfo( IN MB *pMB,
                                       OUT LPTSTR *ppszPIN,
                                       OUT LPTSTR *ppszSerialNumber,
                                       OUT LPTSTR *ppszPersonality )
/*++

Routine Description:

     Retrieve PIN information for Fortezza certificates 

Arguments:

    pMB - pointer to MB object, open for reading 
    ppszPIN - pointer to pointer to PIN for Fortezza card, updated on success
    ppszSerialNumber - pointer to pointer to card serial number, updated on success
    ppszPersonality - pointer to pointer to Fortezza "personality", updated on sucess

Returns:

   BOOL indicating success/failure

--*/
{
    DBG_ASSERT( pMB && 
                ppszPIN && 
                ppszSerialNumber && 
                ppszPersonality );

    DWORD cbLen = 0;
    BOOL fSuccess = FALSE;
    DWORD dwReqDataLen = 0;
    METADATA_RECORD mdr;

    //
    // Retrieve PIN
    //
    cbLen = 0;
    if ( ( !pMB->GetString( NULL,
                            MD_SSL_CERT_FORTEZZA_PIN,
                            IIS_MD_UT_SERVER,
                            NULL,
                            &cbLen,
                            METADATA_SECURE ) &&
           GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ||
         !cbLen )
    {
        goto end_pin_info;
    }
    
    *ppszPIN = new CHAR[cbLen + 1];
    
    if ( !*ppszPIN ||
         !pMB->GetString( NULL,
                          MD_SSL_CERT_FORTEZZA_PIN,
                          IIS_MD_UT_SERVER,
                          *ppszPIN,
                          &cbLen,
                          METADATA_SECURE ) )
    {
        goto end_pin_info;
    }
    
        
    //
    // Retrieve serial #
    //
    cbLen = 0;
    if ( ( !pMB->GetString( NULL,
                            MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
                            IIS_MD_UT_SERVER,
                            NULL,
                            &cbLen,
                            METADATA_SECURE ) &&
           GetLastError() != ERROR_INSUFFICIENT_BUFFER ) || 
         !cbLen )
    {
        goto end_pin_info;
    }
    
    *ppszSerialNumber = new CHAR[cbLen + 1];

    if ( !*ppszSerialNumber ||
         !pMB->GetString( NULL,
                          MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
                          IIS_MD_UT_SERVER,
                          *ppszSerialNumber,
                          &cbLen,
                          METADATA_SECURE ) )
    {
        goto end_pin_info;
    }


    //
    // Retrieve personality
    //
    cbLen = 0;
    if ( ( !pMB->GetString( NULL,
                            MD_SSL_CERT_FORTEZZA_PERSONALITY,
                            IIS_MD_UT_SERVER,
                            NULL,
                            &cbLen,
                            METADATA_SECURE ) &&
           GetLastError() != ERROR_INSUFFICIENT_BUFFER ) || 
         !cbLen )
    {
        goto end_pin_info;
    }
    
    *ppszPersonality = new CHAR[cbLen + 1];
    
    if ( !*ppszPersonality ||
         !pMB->GetString( NULL,
                          MD_SSL_CERT_FORTEZZA_PERSONALITY,
                          IIS_MD_UT_SERVER,
                          *ppszPersonality,
                          &cbLen,
                          METADATA_SECURE ) )
    {
        goto end_pin_info;
    }
    
    fSuccess = TRUE;

end_pin_info:

    if ( !fSuccess )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "RetrievePINInfo failed : 0x%x\n",
                   GetLastError()));

        //
        // Clean out all the PIN info, making sure to erase the memory
        //
        if ( *ppszPIN )
        {
            /* INTRINSA suppress = uninitialized */
            memset( *ppszPIN, 0, strlen(*ppszPIN) );
            delete [] *ppszPIN;
        }

        if ( *ppszSerialNumber )
        {
            memset( *ppszSerialNumber, 0, strlen(*ppszSerialNumber) );
            delete [] *ppszSerialNumber;
        }

        if ( *ppszPersonality )
        {
            memset( *ppszPersonality, 0, strlen(*ppszPersonality) );
            delete [] *ppszPersonality;
        }
    }

    return fSuccess;
}


inline
BOOL IIS_SERVER_CERT::IsValid()
{
 return ( m_dwStatus == CERT_ERR_NONE ? TRUE : FALSE ) ; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\globals.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        globals.c

   Abstract:
        Defines global variables for the common tcpsvcs.dll
    ( It is defined separately because the debug variable should be
        "C" variable.)

   Author:

           Murali R. Krishnan    ( MuraliK )     18-Nov-1994

   Revision History:
          MuraliK         21-Feb-1995  Added Debugging Variables definitions

--*/


#include <tcpdllp.hxx>
#pragma hdrstop
#include <isplat.h>

//
// private routines
//

BOOL
DummySvclocFn(
    VOID
    );

BOOL
LoadNTSecurityEntryPoints(
    VOID
    );

BOOL
LoadW95SecurityEntryPoints(
    VOID
    );

BOOL
GetSecurityDllEntryPoints(
    IN HINSTANCE hInstance
    );

BOOL
GetLogonDllEntryPoints(
    IN HINSTANCE hInstance
    );


//
//  Declare all the debugging related variables
//

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
#endif
#define DEFAULT_DEBUG_FLAGS_VALUE     ( 0)

//
// inetsloc entry points
//

HINSTANCE                   g_hSvcLocDll = NULL;
INET_REGISTER_SVC_FN        pfnInetRegisterSvc = NULL;
INET_DEREGISTER_SVC_FN      pfnInetDeregisterSvc = NULL;
INET_INIT_CONTROL_SVC_FN    pfnInitSvcLoc = NULL;
INET_INIT_CONTROL_SVC_FN    pfnTerminateSvcLoc = NULL;

//  UNDONE remove?  schannel no longer needed???
//
// schannel entrypoints
//

HINSTANCE                   g_hSchannel = NULL;
SSL_CRACK_CERTIFICATE_FN    fnCrackCert = NULL;
SSL_FREE_CERTIFICATE_FN     fnFreeCert = NULL;


//
// crypt32 entrypoints
//

HINSTANCE                           g_hCrypt32Dll = NULL;
CRYPT32_FREE_CERTCTXT_FN            pfnFreeCertCtxt = NULL;
CRYPT32_GET_CERTCTXT_PROP_FN        pfnGetCertCtxtProp = NULL;
CRYPT32_CERT_VERIFY_REVOCATION_FN   pfnCertVerifyRevocation = NULL;
CRYPT32_CERT_VERIFY_TIME_VALIDITY   pfnCertVerifyTimeValidity = NULL;
CRYPT32_CERT_NAME_TO_STR_A_FN       pfnCertNameToStrA = NULL;

//
// sspi entrypoints
//

HINSTANCE                       g_hSecurityDll = NULL;
ACCEPT_SECURITY_CONTEXT_FN      pfnAcceptSecurityContext = NULL;
ACQUIRE_CREDENTIALS_HANDLE_FN   pfnAcquireCredentialsHandle = NULL;
COMPLETE_AUTH_TOKEN_FN          pfnCompleteAuthToken = NULL;
DELETE_SECURITY_CONTEXT_FN      pfnDeleteSecurityContext = NULL;
ENUMERATE_SECURITY_PACKAGES_FN  pfnEnumerateSecurityPackages = NULL;
IMPERSONATE_SECURITY_CONTEXT_FN pfnImpersonateSecurityContext = NULL;
INITIALIZE_SECURITY_CONTEXT_FN  pfnInitializeSecurityContext = NULL;
FREE_CONTEXT_BUFFER_FN          pfnFreeContextBuffer = NULL;
FREE_CREDENTIALS_HANDLE_FN      pfnFreeCredentialsHandle = NULL;
QUERY_CONTEXT_ATTRIBUTES_FN     pfnQueryContextAttributes = NULL;
QUERY_SECURITY_CONTEXT_TOKEN_FN pfnQuerySecurityContextToken = NULL;
QUERY_SECURITY_PACKAGE_INFO_FN  pfnQuerySecurityPackageInfo = NULL;
REVERT_SECURITY_CONTEXT_FN      pfnRevertSecurityContext = NULL;

//
// logon entry points
//

LOGON32_INITIALIZE_FN           pfnLogon32Initialize = NULL;
LOGON_NET_USER_A_FN             pfnLogonNetUserA = NULL;
LOGON_NET_USER_W_FN             pfnLogonNetUserW = NULL;
NET_USER_COOKIE_A_FN            pfnNetUserCookieA = NULL;
LOGON_DIGEST_USER_A_FN          pfnLogonDigestUserA = NULL;
GET_DEFAULT_DOMAIN_NAME_FN      pfnGetDefaultDomainName = NULL;

//
// advapi32
//

DUPLICATE_TOKEN_EX_FN           pfnDuplicateTokenEx = NULL;

LSA_OPEN_POLICY_FN              pfnLsaOpenPolicy = NULL;
LSA_RETRIEVE_PRIVATE_DATA_FN    pfnLsaRetrievePrivateData = NULL;
LSA_STORE_PRIVATE_DATA_FN       pfnLsaStorePrivateData = NULL;
LSA_FREE_MEMORY_FN              pfnLsaFreeMemory = NULL;
LSA_CLOSE_FN                    pfnLsaClose = NULL;
LSA_NT_STATUS_TO_WIN_ERROR_FN   pfnLsaNtStatusToWinError = NULL;

//
// kernel32
//
#if _WIN64
LONG
INET_InterlockedIncrement(
    IN OUT LPLONG lpAddend
    )
{
    return InterlockedIncrement(lpAddend);
}

LONG
INET_InterlockedCompareExchange (
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    )
{
    return InterlockedCompareExchange(Destination, ExChange, Comperand);
}

LONG
INET_InterlockedExchangeAdd(
    IN OUT LPLONG Addend,
    IN LONG Value
    )
{
    return InterlockedExchangeAdd(Addend, Value);
}

LONG
__cdecl
INET_InterlockedDecrement(
    IN OUT LPLONG lpAddend
    )
{
    return InterlockedDecrement(lpAddend);
}

INTERLOCKED_EXCHANGE_ADD_FN     pfnInterlockedExchangeAdd = INET_InterlockedExchangeAdd;
INTERLOCKED_COMPARE_EXCHANGE_FN pfnInterlockedCompareExchange = (INTERLOCKED_COMPARE_EXCHANGE_FN)INET_InterlockedCompareExchange;
INTERLOCKED_INCREMENT_FN        pfnInterlockedIncrement = INET_InterlockedIncrement;
INTERLOCKED_DECREMENT_FN        pfnInterlockedDecrement = INET_InterlockedDecrement;
READ_DIR_CHANGES_W_FN           pfnReadDirChangesW = ReadDirectoryChangesW;
#else
INTERLOCKED_EXCHANGE_ADD_FN     pfnInterlockedExchangeAdd = NULL;
INTERLOCKED_COMPARE_EXCHANGE_FN pfnInterlockedCompareExchange = NULL;
INTERLOCKED_INCREMENT_FN        pfnInterlockedIncrement = NULL;
INTERLOCKED_DECREMENT_FN        pfnInterlockedDecrement = NULL;
READ_DIR_CHANGES_W_FN           pfnReadDirChangesW;
#endif
//
// lonsi
//

HINSTANCE                       g_hLonsiNT = NULL;
HINSTANCE                       g_hLonsiW95 = NULL;

//
// rpcref
//

HINSTANCE                       g_hRpcRef = NULL;
PFN_INETINFO_START_RPC_SERVER   pfnInetinfoStartRpcServer = NULL;
PFN_INETINFO_STOP_RPC_SERVER    pfnInetinfoStopRpcServer  = NULL;


BOOL
GetDynamicEntryPoints(
    VOID
    )
{
    HINSTANCE   hTemp;

    DBG_ASSERT(IISIsValidPlatform());

    if ( TsIsWindows95() ) {
        goto win95_only;
    }

    //
    // advapi32
    //

    hTemp = LoadLibrary("advapi32.dll");
    if ( hTemp != NULL ) {

        pfnDuplicateTokenEx = (DUPLICATE_TOKEN_EX_FN)
            GetProcAddress(hTemp,"DuplicateTokenEx");

        pfnLsaOpenPolicy = (LSA_OPEN_POLICY_FN)
            GetProcAddress(hTemp,"LsaOpenPolicy");

        pfnLsaRetrievePrivateData = (LSA_RETRIEVE_PRIVATE_DATA_FN)
                GetProcAddress(hTemp,"LsaRetrievePrivateData");

        pfnLsaStorePrivateData = (LSA_STORE_PRIVATE_DATA_FN)
                GetProcAddress(hTemp,"LsaStorePrivateData");

        pfnLsaFreeMemory = (LSA_FREE_MEMORY_FN)
                GetProcAddress(hTemp,"LsaFreeMemory");

        pfnLsaClose = (LSA_CLOSE_FN)
                GetProcAddress(hTemp,"LsaClose");

        pfnLsaNtStatusToWinError = (LSA_NT_STATUS_TO_WIN_ERROR_FN)
                GetProcAddress(hTemp,"LsaNtStatusToWinError");

        FreeLibrary(hTemp);

        if ( !pfnDuplicateTokenEx ||
             !pfnLsaOpenPolicy    ||
             !pfnLsaRetrievePrivateData ||
             !pfnLsaFreeMemory      ||
             !pfnLsaClose           ||
             !pfnLsaNtStatusToWinError ) {

            DBGPRINTF((DBG_CONTEXT,
                "Unable to obtain an advapi32 entry point\n"));
            goto error_exit;
        }

    } else {
        DBGPRINTF((DBG_CONTEXT, "Error %d loading advapi32.dll\n",
            GetLastError() ));
        goto error_exit;
    }

    //
    // kernel32
    //
#ifndef _WIN64
    hTemp = LoadLibrary("kernel32.dll");
    if ( hTemp != NULL ) {

        pfnInterlockedExchangeAdd = (INTERLOCKED_EXCHANGE_ADD_FN)
            GetProcAddress(hTemp,"InterlockedExchangeAdd");

        pfnInterlockedCompareExchange = (INTERLOCKED_COMPARE_EXCHANGE_FN)
            GetProcAddress(hTemp,"InterlockedCompareExchange");

        pfnInterlockedIncrement = (INTERLOCKED_INCREMENT_FN)
            GetProcAddress(hTemp,"InterlockedIncrement");

        pfnInterlockedDecrement = (INTERLOCKED_DECREMENT_FN)
            GetProcAddress(hTemp,"InterlockedDecrement");

        pfnReadDirChangesW = (READ_DIR_CHANGES_W_FN)
            GetProcAddress(hTemp,"ReadDirectoryChangesW");

        FreeLibrary(hTemp);

        if ( !pfnInterlockedExchangeAdd ||
             !pfnInterlockedCompareExchange ||
             !pfnInterlockedIncrement ||
             !pfnInterlockedDecrement ||
             !pfnReadDirChangesW ) {

            DBGPRINTF((DBG_CONTEXT,
                "Unable to obtain NT kernel32 entry point\n"));
            goto error_exit;
        }

    } else {
        DBGPRINTF((DBG_CONTEXT,"Error %d loading kernel32.dll\n",
            GetLastError()));
        goto error_exit;
    }
#endif

    //
    // load the service locator entry points. Not fatal on failure.
    //

    // Loading of the inetsloc.dll service is disabled
    //    g_hSvcLocDll = LoadLibrary("inetsloc.dll");
    g_hSvcLocDll = NULL;
    if ( g_hSvcLocDll != NULL ) {

        pfnInetRegisterSvc = (INET_REGISTER_SVC_FN)
                GetProcAddress( g_hSvcLocDll, "INetRegisterService" );

        pfnInetDeregisterSvc = (INET_DEREGISTER_SVC_FN)
                GetProcAddress( g_hSvcLocDll, "INetDeregisterService" );

        pfnInitSvcLoc = (INET_INIT_CONTROL_SVC_FN)
                GetProcAddress( g_hSvcLocDll, "InitSvcLocator" );

        pfnTerminateSvcLoc = (INET_INIT_CONTROL_SVC_FN)
                GetProcAddress( g_hSvcLocDll, "TerminateSvcLocator" );

        if ( !pfnInetRegisterSvc ||
             !pfnInetDeregisterSvc ||
             !pfnInitSvcLoc ||
             !pfnTerminateSvcLoc ) {

            DBGPRINTF((DBG_CONTEXT,"Unable to find an inetsloc entrypoint\n"));
            FreeLibrary( g_hSvcLocDll );
            g_hSvcLocDll = NULL;
        }
    }

    if ( g_hSvcLocDll == NULL ) {
        DBGPRINTF((DBG_CONTEXT,
            "Unable to find an inetsloc.dll entrypoints!!!. Ignore if NTW.\n"));
        pfnInitSvcLoc = (INET_INIT_CONTROL_SVC_FN)DummySvclocFn;
        pfnTerminateSvcLoc = (INET_INIT_CONTROL_SVC_FN)DummySvclocFn;
    }

    //
    // rpcref
    //

    g_hRpcRef = LoadLibrary("rpcref.dll");
    if ( g_hRpcRef != NULL ) {

        pfnInetinfoStartRpcServer = (PFN_INETINFO_START_RPC_SERVER)
            GetProcAddress(g_hRpcRef,"InetinfoStartRpcServerListen");

        pfnInetinfoStopRpcServer = (PFN_INETINFO_STOP_RPC_SERVER)
            GetProcAddress(g_hRpcRef,"InetinfoStopRpcServerListen");
    } else {
        DBGPRINTF((DBG_CONTEXT, "Error %d loading rpcref.dll\n",
            GetLastError() ));
        goto error_exit;
    }

    if ( !LoadNTSecurityEntryPoints( ) ) {
        goto error_exit;
    }

    return(TRUE);

win95_only:

    g_hLonsiW95 = LoadLibrary( "lonsiw95.dll" );
    if ( g_hLonsiW95 == NULL ) {
        DBGPRINTF((DBG_CONTEXT,"Error %d loading lonsiw95.dll\n",
            GetLastError()));
        goto error_exit;
    }

    //
    // kernel32
    //

    pfnInterlockedExchangeAdd = (INTERLOCKED_EXCHANGE_ADD_FN)
        GetProcAddress(g_hLonsiW95,"FakeInterlockedExchangeAdd");

    pfnInterlockedCompareExchange = (INTERLOCKED_COMPARE_EXCHANGE_FN)
        GetProcAddress(g_hLonsiW95,"FakeInterlockedCompareExchange");

    pfnInterlockedIncrement = (INTERLOCKED_INCREMENT_FN)
        GetProcAddress(g_hLonsiW95,"FakeInterlockedIncrement");

    pfnInterlockedDecrement = (INTERLOCKED_DECREMENT_FN)
        GetProcAddress(g_hLonsiW95,"FakeInterlockedDecrement");

    if ( !pfnInterlockedExchangeAdd ||
         !pfnInterlockedCompareExchange ||
         !pfnInterlockedIncrement ||
         !pfnInterlockedDecrement ) {

        DBGPRINTF((DBG_CONTEXT,
            "Unable to obtain Win95 kernel32 entry points\n"));
        goto error_exit;
    }

    //
    // svcloc
    //

    pfnInitSvcLoc = (INET_INIT_CONTROL_SVC_FN)DummySvclocFn;
    pfnTerminateSvcLoc = (INET_INIT_CONTROL_SVC_FN)DummySvclocFn;

    //
    // security/schannel/lsa
    //

    if ( !LoadW95SecurityEntryPoints( ) ) {
        goto error_exit;
    }

    return(TRUE);

error_exit:
    return(FALSE);

} // GetDynamicEntryPoints



VOID
FreeDynamicLibraries(
    VOID
    )
{
    if ( g_hSchannel != NULL ) {
        FreeLibrary( g_hSchannel );
        g_hSchannel = NULL;
    }

    if ( g_hCrypt32Dll != NULL ) {
        FreeLibrary( g_hCrypt32Dll );
        g_hCrypt32Dll = NULL;
    }

    if ( g_hSecurityDll != NULL ) {
        FreeLibrary( g_hSecurityDll );
        g_hSecurityDll = NULL;
    }

    if ( g_hSvcLocDll != NULL ) {
        FreeLibrary( g_hSvcLocDll );
        g_hSvcLocDll = NULL;
    }

    if ( g_hRpcRef != NULL ) {
        FreeLibrary( g_hRpcRef );
        g_hRpcRef = NULL;
    }

    if ( g_hLonsiNT != NULL ) {
        FreeLibrary( g_hLonsiNT );
        g_hLonsiNT = NULL;
    }

    if ( g_hLonsiW95 != NULL ) {
        FreeLibrary( g_hLonsiW95 );
        g_hLonsiW95 = NULL;
    }

    return;

} // FreeDynamicLibraries



BOOL
LoadNTSecurityEntryPoints(
    VOID
    )
{
    IF_DEBUG(DLL_SECURITY) {
        DBGPRINTF((DBG_CONTEXT,"Entering LoadNTSecurityEntryPoints\n"));
    }

    //
    // Load Schannel
    //

    g_hSchannel = LoadLibrary( "schannel.dll" );

    if ( g_hSchannel != NULL ) {
        fnCrackCert = (SSL_CRACK_CERTIFICATE_FN)
                GetProcAddress( g_hSchannel, "SslCrackCertificate" );
        fnFreeCert = (SSL_FREE_CERTIFICATE_FN)
                GetProcAddress( g_hSchannel, "SslFreeCertificate" );
    } else {
        DBGPRINTF((DBG_CONTEXT,
            "Unable to load schannel.dll[err %d]\n", GetLastError() ));
    }


    //
    // Load Crypt32
    //

    g_hCrypt32Dll = LoadLibrary( "crypt32.dll" );

    if ( g_hCrypt32Dll != NULL ) {
        pfnFreeCertCtxt = (CRYPT32_FREE_CERTCTXT_FN)
                GetProcAddress( g_hCrypt32Dll, "CertFreeCertificateContext" );
        pfnGetCertCtxtProp = (CRYPT32_GET_CERTCTXT_PROP_FN)
                GetProcAddress( g_hCrypt32Dll, "CertGetCertificateContextProperty" );
        pfnCertVerifyRevocation = (CRYPT32_CERT_VERIFY_REVOCATION_FN)
                GetProcAddress( g_hCrypt32Dll, "CertVerifyRevocation" );
        pfnCertVerifyTimeValidity = (CRYPT32_CERT_VERIFY_TIME_VALIDITY)
                GetProcAddress( g_hCrypt32Dll, "CertVerifyTimeValidity" );
        pfnCertNameToStrA = (CRYPT32_CERT_NAME_TO_STR_A_FN)
                GetProcAddress( g_hCrypt32Dll, "CertNameToStrA" );

    } else {
        DBGPRINTF((DBG_CONTEXT,
            "Unable to load crypt32.dll[err %d]\n", GetLastError() ));
    }

    DBG_ASSERT( pfnFreeCertCtxt );
    DBG_ASSERT( pfnGetCertCtxtProp );
    DBG_ASSERT( pfnCertVerifyRevocation );
    DBG_ASSERT( pfnCertVerifyTimeValidity );
    DBG_ASSERT( pfnCertNameToStrA );

    //
    // Load security.dll
    //

    g_hSecurityDll = LoadLibrary( "security.dll" );
    if ( g_hSecurityDll == NULL ) {
        DBGPRINTF((DBG_CONTEXT,"Error %d loading security.dll\n",
            GetLastError()));
        return(FALSE);
    }

    if ( !GetSecurityDllEntryPoints( g_hSecurityDll ) ) {
        return(FALSE);
    }

    //
    // Load lsa stuff from lonsint.dll
    //

    g_hLonsiNT = LoadLibrary( "lonsint.dll" );
    if ( g_hLonsiNT == NULL ) {
        DBGPRINTF((DBG_CONTEXT,"Error %d loading lonsint.dll\n",
            GetLastError()));
        return(FALSE);
    }

    if ( !GetLogonDllEntryPoints( g_hLonsiNT ) ) {
        return FALSE;
    }

    return(TRUE);

} // LoadNTSecurityEntryPoints



BOOL
LoadW95SecurityEntryPoints(
    VOID
    )
{
    IF_DEBUG(DLL_SECURITY) {
        DBGPRINTF((DBG_CONTEXT,"Entering LoadW95SecurityEntryPoints\n"));
    }

    //
    // Load Schannel
    //

    fnCrackCert = NULL;
    fnFreeCert = NULL;

    //
    // Load security.dll
    //

    DBG_ASSERT(g_hLonsiW95 != NULL);

    if ( !GetSecurityDllEntryPoints( g_hLonsiW95 ) ) {
        return(FALSE);
    }

    if ( !GetLogonDllEntryPoints( g_hLonsiW95 ) ) {
        return FALSE;
    }

    return(TRUE);

} // LoadNTSecurityEntryPoints


BOOL
GetSecurityDllEntryPoints(
    IN HINSTANCE    hInstance
    )
{

    pfnAcceptSecurityContext = (ACCEPT_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "AcceptSecurityContext" );

    pfnAcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)
                GetProcAddress( hInstance, "AcquireCredentialsHandleA" );

    pfnCompleteAuthToken = (COMPLETE_AUTH_TOKEN_FN)
                GetProcAddress( hInstance, "CompleteAuthToken" );

    pfnDeleteSecurityContext = (DELETE_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "DeleteSecurityContext" );

    pfnEnumerateSecurityPackages = (ENUMERATE_SECURITY_PACKAGES_FN)
                GetProcAddress( hInstance, "EnumerateSecurityPackagesA" );

    pfnImpersonateSecurityContext = (IMPERSONATE_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "ImpersonateSecurityContext" );

    pfnInitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "InitializeSecurityContextA" );

    pfnFreeContextBuffer = (FREE_CONTEXT_BUFFER_FN)
                GetProcAddress( hInstance, "FreeContextBuffer" );

    pfnFreeCredentialsHandle = (FREE_CREDENTIALS_HANDLE_FN)
                GetProcAddress( hInstance, "FreeCredentialsHandle" );

    pfnQueryContextAttributes = (QUERY_CONTEXT_ATTRIBUTES_FN)
                GetProcAddress( hInstance, "QueryContextAttributesA" );

    pfnQuerySecurityContextToken = (QUERY_SECURITY_CONTEXT_TOKEN_FN)
                GetProcAddress( hInstance, "QuerySecurityContextToken" );

    pfnQuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN)
                GetProcAddress( hInstance, "QuerySecurityPackageInfoA" );

    pfnRevertSecurityContext = (REVERT_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "RevertSecurityContext" );

    if ( !pfnAcceptSecurityContext      ||
         !pfnAcquireCredentialsHandle   ||
         !pfnCompleteAuthToken          ||
         !pfnDeleteSecurityContext      ||
         !pfnEnumerateSecurityPackages  ||
         !pfnImpersonateSecurityContext ||
         !pfnInitializeSecurityContext  ||
         !pfnFreeContextBuffer          ||
         !pfnFreeCredentialsHandle      ||
         !pfnQueryContextAttributes     ||
         !pfnQuerySecurityContextToken  ||
         !pfnQuerySecurityPackageInfo   ||
         !pfnRevertSecurityContext ) {

        DBGPRINTF((DBG_CONTEXT,"Unable to get security entry points\n"));
        SetLastError(ERROR_PROC_NOT_FOUND);
        DBG_ASSERT(FALSE);
        return FALSE;
    }

    return(TRUE);

} // GetSecurityDllEntryPoints


BOOL
GetLogonDllEntryPoints(
    IN HINSTANCE    hInstance
    )
{
    pfnLogon32Initialize = (LOGON32_INITIALIZE_FN)
                GetProcAddress( hInstance, "IISLogon32Initialize" );

    pfnLogonNetUserA = (LOGON_NET_USER_A_FN)
                GetProcAddress( hInstance, "IISLogonNetUserA" );

    pfnLogonNetUserW = (LOGON_NET_USER_W_FN)
                GetProcAddress( hInstance, "IISLogonNetUserW" );

    pfnNetUserCookieA = (NET_USER_COOKIE_A_FN)
                GetProcAddress( hInstance, "IISNetUserCookieA" );

    pfnLogonDigestUserA = (LOGON_DIGEST_USER_A_FN)
                GetProcAddress( hInstance, "IISLogonDigestUserA" );

    pfnGetDefaultDomainName = (GET_DEFAULT_DOMAIN_NAME_FN)
                GetProcAddress( hInstance, "IISGetDefaultDomainName" );

    if ( !pfnLogon32Initialize      ||
         !pfnLogonNetUserA          ||
         !pfnLogonNetUserW          ||
         !pfnNetUserCookieA         ||
         !pfnLogonDigestUserA       ||
         !pfnGetDefaultDomainName ) {

        DBGPRINTF((DBG_CONTEXT,"Unable to get an entry point on lonsint.dll\n"));
        SetLastError( ERROR_PROC_NOT_FOUND );
        DBG_ASSERT(FALSE);
        return FALSE;
    }

    return(TRUE);

} // GetLogonDllEntryPoints

#ifdef _NO_TRACING_
DWORD
GetDebugFlagsFromReg(IN LPCTSTR pszRegEntry)
{
    HKEY hkey = NULL;
    DWORD err;
    DWORD dwDebug = DEFAULT_DEBUG_FLAGS_VALUE;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       pszRegEntry,
                       0,
                       KEY_READ,
                       &hkey);

    if ( hkey != NULL) {

        DBG_CODE(
                 dwDebug =
                 LOAD_DEBUG_FLAGS_FROM_REG(hkey, DEFAULT_DEBUG_FLAGS_VALUE)
                 );
        RegCloseKey(hkey);
    }

    return ( dwDebug);
} // GetDebugFlagsFromReg()
#endif


BOOL
DummySvclocFn(
    VOID
    )
{
    return(TRUE);
} // DummySvclocFn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\iisctl.cxx ===
/*++



Copyright (c) 1995  Microsoft Corporation

Module Name:

   iisctl.cxx

Abstract:

    This module contains the code for the class to deal with Certificate Trust Lists

Author:

    Alex Mallet [amallet] 01-09-98

Revision History:
--*/

#include "tcpdllp.hxx"
#pragma hdrstop


#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

#include <iiscert.hxx>
#include <capiutil.hxx>
#include <iisctl.hxx>


IIS_CTL::IIS_CTL( IN IMDCOM *pMBObject,
                  IN LPTSTR pszMBPath ) :
m_strMBPath( pszMBPath ),
m_pwszListIdentifier( NULL ),
m_hMemoryStore( NULL ),
m_pCTLContext( NULL ),
m_hCryptProv( NULL ),
m_fFoundCerts( FALSE ),
m_pCTLCerts( NULL ),
m_cCertsFound( 0 ),
m_hMyStore( NULL ),
m_hCAStore( NULL ),
m_hRootStore( NULL ),
m_pSignerCert( NULL )
/*++

Routine Description:

    Constructor for CTL

Arguments:

    pMDObject - pointer to metabase object 
    pszMBPath - fully qualified path in metabase where CTL identifier is stored

Returns:

   Nothing

--*/
{
    DBG_ASSERT( pMBObject );
    DBG_ASSERT( pszMBPath );

    MB mb( pMBObject );
    METADATA_HANDLE hInfoHandle = NULL;
    POPEN_CERT_STORE_INFO pCertStoreInfo = NULL;
    DWORD dwIdentifierSize = 0;
    HCRYPTPROV hCryptProv = NULL;
    HCERTSTORE hStore = NULL;

    m_dwStatus = CERT_ERR_INTERNAL;

    if ( !m_strMBPath.IsValid() )
    {
        m_dwStatus = CERT_ERR_INTERNAL;
        SetLastError(ERROR_OUTOFMEMORY);
        goto EndCTLConstructor;
    }

    //
    // Read CTL identifier out of MB 
    //
    if ( mb.Open( m_strMBPath.QueryStr(),
                  METADATA_PERMISSION_READ ))
    {
        METADATA_RECORD mdr;
        
        MD_SET_DATA_RECORD( &mdr, 
                            MD_SSL_CTL_IDENTIFIER,
                            METADATA_NO_ATTRIBUTES,
                            IIS_MD_UT_SERVER, 
                            STRING_METADATA, 
                            NULL,
                            0 );

        if ( !RetrieveBlobFromMetabase( &mb,
                                        NULL,
                                        &mdr,
                                        0 ) )
        {
            m_dwStatus = CERT_ERR_MB;
            goto EndCTLConstructor;
        }
        else
        {
#if DBG
            DBGPRINTF((DBG_CONTEXT,
                       "List identifier : %s\n", 
                       (LPSTR) mdr.pbMDData));
#endif

            //
            // Need to convert the list identifier to a wide-char string
            //
            dwIdentifierSize = 0;
            
            if ( dwIdentifierSize = MultiByteToWideChar( CP_ACP,
                                                         0,
                                                         (LPCSTR) mdr.pbMDData,
                                                         mdr.dwMDDataLen,
                                                         NULL,
                                                         0 ) )
            {
                m_pwszListIdentifier = new WCHAR[dwIdentifierSize];                    
                
                if ( !m_pwszListIdentifier || 
                     !MultiByteToWideChar( CP_ACP,
                                           0,
                                           (LPCSTR) mdr.pbMDData,
                                           mdr.dwMDDataLen,
                                           m_pwszListIdentifier, 
                                           dwIdentifierSize ) )
                {
                    delete [] mdr.pbMDData;
                    m_dwStatus = CERT_ERR_INTERNAL;
                    goto EndCTLConstructor;
                }
            }
            else
            {
                delete [] mdr.pbMDData;
                m_dwStatus = CERT_ERR_INTERNAL;
                goto EndCTLConstructor;
            }

            delete [] mdr.pbMDData;
        }
    }        
    mb.Close();

    //
    // Read cert store info out of MB, and try to reconstruct CTL context
    //
    if ( (pCertStoreInfo = ReadCertStoreInfoFromMB( pMBObject,
                                                    pszMBPath,
                                                    TRUE ) ) )
    {
#if 0
        if ( !CryptAcquireContext( &m_hCryptProv,
                                   pCertStoreInfo->pszContainer,
                                   pCertStoreInfo->pszProvider,
                                   pCertStoreInfo->dwProvType,
                                   pCertStoreInfo->dwFlags ) )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndCTLConstructor;
        }

        if ( !( hStore = CertOpenSystemStore( m_hCryptProv,
                                              pCertStoreInfo->pszStoreName ) ) )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndCTLConstructor;
        }
#else
        if ( !( hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                        0,
                                        NULL,
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                        pCertStoreInfo->pszStoreName ) ) )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndCTLConstructor;
        }
        else
        {
            if ( ! m_strStoreName.Copy( pCertStoreInfo->pszStoreName ) )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                goto EndCTLConstructor;
            }
        }
#endif

        CTL_FIND_USAGE_PARA CtlFindUsagePara;
        memset(&CtlFindUsagePara, 0, sizeof(CtlFindUsagePara));

        CtlFindUsagePara.cbSize = sizeof(CtlFindUsagePara);
        CtlFindUsagePara.ListIdentifier.cbData = dwIdentifierSize * sizeof(WCHAR);
        CtlFindUsagePara.ListIdentifier.pbData = (PBYTE) m_pwszListIdentifier;


        //
        // Try to find CTL in specified store
        //
        m_pCTLContext = CertFindCTLInStore( hStore,
                                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                            0,
                                            CTL_FIND_USAGE,
                                            (LPVOID) &CtlFindUsagePara,
                                            NULL );

        if ( !m_pCTLContext )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndCTLConstructor;
        }
    }
    else
    {
        m_dwStatus = CERT_ERR_MB;
        goto EndCTLConstructor;
    }


    //
    // Construct the in-memory store that will only contain this CTL, to be passed to
    // WinVerifyTrust and add the CTL to the created store
    //
    m_hMemoryStore = NULL;
    m_hMemoryStore = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                    0,
                                    0,
                                    0,
                                    0 );

    if ( !m_hMemoryStore )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }        

    if ( !CertAddCTLContextToStore( m_hMemoryStore,
                                    m_pCTLContext,
                                    CERT_STORE_ADD_NEW,
                                    NULL ) )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }


    if ( !( m_hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                        0,
                                        NULL,
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                        MY_STORE_NAME ) ) )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }

    if ( !(m_hCAStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                       0,
                                       NULL,
                                       CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                       CA_STORE_NAME ) ) )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }

    if ( !( m_hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                          0,
                                          NULL,
                                          CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                          ROOT_STORE_NAME ) ) )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }

    m_dwStatus = CERT_ERR_NONE;

EndCTLConstructor:

    DBG_ASSERT( m_dwStatus< CERT_ERR_END );

    //
    // Cleanup done only on failure
    //
    if ( m_dwStatus != CERT_ERR_NONE )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error in CTL constructor : 0x%x\n",
                   GetLastError()));

        if ( m_pwszListIdentifier )
        {
            delete [] m_pwszListIdentifier;
            m_pwszListIdentifier = NULL;
        }

        if ( m_pCTLContext )
        {
            CertFreeCTLContext( m_pCTLContext );
            m_pCTLContext = NULL;
        }

        if ( hStore )
        {
            CertCloseStore( hStore,
                            0 );
            hStore = NULL;
        }
        
        if ( m_hMemoryStore )
        {
            CertCloseStore( m_hMemoryStore,
                            0 );
            m_hMemoryStore = NULL;
        }

        if ( m_hRootStore )
        {
            CertCloseStore( m_hRootStore,
                            0 );
            m_hRootStore = NULL;
        }

        if ( m_hCAStore )
        {
            CertCloseStore( m_hCAStore,
                            0 );
            m_hCAStore = NULL;
        }

        if ( m_hMyStore )
        {
            CertCloseStore( m_hMyStore,
                            0 );
            m_hMyStore = NULL;
        }

        if ( m_hCryptProv )
        {
            CryptReleaseContext ( m_hCryptProv,
                                  0 );
            m_hCryptProv = NULL;
        }
    }

    //
    //Cleanup done regardless of success/failure
    //
    DeallocateCertStoreInfo( pCertStoreInfo );
    pCertStoreInfo = NULL;

} //IIS_CTL:IIS_CTL



IIS_CTL::~IIS_CTL()
/*++

Routine Description:

    Destructor for CTL

Arguments:

   None

Returns:

   Nothing

--*/
{
    if ( m_pwszListIdentifier )
    {
        delete [] m_pwszListIdentifier;
        m_pwszListIdentifier = NULL;
    }
    
    if ( m_pCTLContext )
    {
        CertFreeCTLContext( m_pCTLContext );
        m_pCTLContext = NULL;
    }

    if ( m_hMemoryStore )
    {
        CertCloseStore( m_hMemoryStore,
                        0 );
        m_hMemoryStore = NULL;
    }

    if ( m_hRootStore )
    {
        CertCloseStore( m_hRootStore,
                        0 );
        m_hRootStore = NULL;
    }
    
    if ( m_hCAStore )
    {
        CertCloseStore( m_hCAStore,
                        0 );
        m_hCAStore = NULL;
    }
    
    if ( m_hMyStore )
    {
        CertCloseStore( m_hMyStore,
                        0 );
        m_hMyStore = NULL;
    }
    
    if ( m_hCryptProv )
    {
        CryptReleaseContext ( m_hCryptProv,
                              0 );
        m_hCryptProv = NULL;
    }

    if ( m_cCertsFound && m_pCTLCerts )
    {
        for ( DWORD i = 0; i < m_cCertsFound; i++ )
        {
            CertFreeCertificateContext( m_pCTLCerts[i] );
        }
        delete [] m_pCTLCerts;

        m_pCTLCerts = NULL;
        m_cCertsFound = 0;
    }
}

HCERTSTORE IIS_CTL::GetMemoryStore()
/*++

Routine Description:

    Returns a handle to an in-memory store that contains the CTL

Arguments:

    None

Returns:

     Handle to in-memory store
--*/

{
    DBG_ASSERT( m_hMemoryStore );

    if ( m_hMemoryStore )
    {
        return CertDuplicateStore( m_hMemoryStore );
    }

    return NULL;
}
    
                                   
BOOL IIS_CTL::QuerySignerCert( OUT PCCERT_CONTEXT *ppcSigner )
/*++

Routine Description:

    Retrieves the cert that signed this CTL

Arguments:

    ppcSigner - pointer to pointer to cert context, updated if successful. Caller's
    responsibility to clean it up

Returns:

    TRUE if there were no errors encountered in retrieving the signer
--*/
{
    DWORD dwNumSigners = 3;
    HCERTSTORE ahStores[3];
    BOOL fGotRoot = TRUE;
    BOOL fGotCA = TRUE;
    BOOL fOk = TRUE;

    if ( !m_pSignerCert )
    {
        //
        // Look in 3 stores to find signer : store the cert came from, CA and ROOT stores
        // for Local Machine
        //
        ahStores[0] = m_pCTLContext->hCertStore;
        ahStores[1] = m_hRootStore;
        ahStores[2] = m_hCAStore;

        CryptMsgGetAndVerifySigner( (HCRYPTMSG) m_pCTLContext->hCryptMsg,
                                    dwNumSigners,
                                    ahStores,
                                    CMSG_TRUSTED_SIGNER_FLAG,
                                    &m_pSignerCert,
                                    0 );
    }
    
    //
    // If we don't have a signer cert at this point, we're just not happy
    //
    if ( m_pSignerCert )
    {
        *ppcSigner = CertDuplicateCertificateContext( m_pSignerCert );
    }
    else
    {
        fOk = FALSE;
    }

    return fOk;
}


BOOL IIS_CTL::VerifySignature( IN OPTIONAL HCERTSTORE *phSignerStores,
                               IN DWORD cSignerStores,
                               LPBOOL pfTrusted )

/*++

Routine Description:

    Verify that this CTL was signed by a certificate in a trusted store.

Arguments:

    phSignerStores - optional array of store handles to be used in searching for a cert used
    to sign this CTL. If NULL, the stores tried are the CA and ROOT stores for the local machine, 
    as well as the store the CTL came from.

    cSignerStores - number of stores in phSignerStores. Should be zero if phSignerStores == NULL

    pfTrusted - pointer to bool, updated with TRUE if CTL signature was verified, FALSE if not.

Returns:

    TRUE if there were no errors encountered in checking the CTL, FALSE if not 
    NB : TRUE does -NOT- mean the CTL signature was verified !!!

--*/
{
    DBG_ASSERT( m_pCTLContext );

    DWORD dwNumSigners = cSignerStores;
    HCERTSTORE *phStores = phSignerStores;
    HCERTSTORE ahStores[3];
    BOOL fGotRoot = TRUE;
    BOOL fGotCA = TRUE;


    if ( !phSignerStores )
    {
        dwNumSigners = 3;

        ahStores[0] = m_pCTLContext->hCertStore;
        ahStores[1] = m_hRootStore;
        ahStores[2] = m_hCAStore;

        phStores = ahStores;
    }

    *pfTrusted = CryptMsgGetAndVerifySigner( (HCRYPTMSG) m_pCTLContext->hCryptMsg,
                                             dwNumSigners,
                                             phStores,
                                             CMSG_TRUSTED_SIGNER_FLAG,
                                             NULL,
                                             0 );
    if ( !*pfTrusted )
    {
        DBGPRINTF((DBG_CONTEXT, "CTL wasn't verified b'cos 0x%x\n",
                   GetLastError()));
    }

    return TRUE;
}
                                             
BOOL IIS_CTL::GetContainedCertificates( OUT PCCERT_CONTEXT **pppCertContext,
                                        OUT DWORD *pcCertsFound,
                                        OUT DWORD *pcCertsInCTL )

/*++

Routine Description:

    Tries to retrieve CERT_CONTEXT pointers for the certs contained in the Certificate
    Trust List.

Arguments:

    pppCertContext - pointer to array of CERT_CONTEXT pointers, filled out with the found 
    CERT_CONTEXTS.
    Caller is responsible for releasing the contexts when done with them and deleting
    the array used to hold them.

    pcCertsFound - pointer to number of cert contexts returned in ppCertContext

    pcCertsInCTL - pointer to number of certs in CTL; may differ from *pccCertsFound
    if some certificates couldn't be found
    
Returns:

    TRUE if no internal errors occurred, FALSE if NOT
--*/
{
    PCTL_INFO pCtlInfo = m_pCTLContext->pCtlInfo;
    HCERTSTORE ahStores[3];
    DWORD dwNumStores = 3;


    DBG_ASSERT( pCtlInfo->cCTLEntry );

    //
    // Let's be optimistic and allocate as much space as we can possibly 
    // need
    //
    *pppCertContext = new PCCERT_CONTEXT[pCtlInfo->cCTLEntry];
        
    if ( !*pppCertContext )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    *pcCertsFound  = 0;
    *pcCertsInCTL = pCtlInfo->cCTLEntry;
    
    //
    // If we haven't searched the stores yet, do so now
    //
    if ( !m_fFoundCerts )
    {
        m_pCTLCerts = new PCCERT_CONTEXT[pCtlInfo->cCTLEntry];
        m_cCertsFound = 0;
        
        if ( !m_pCTLCerts )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            /* INTRINSA suppress = leaks */
            return FALSE;
        }
        
        ahStores[0] = m_hMyStore;
        ahStores[1] = m_hCAStore;
        ahStores[2] = m_hRootStore;

        //
        // Iterate through the certs in the CTL. For each cert, try to find it
        // by SHA1 hash in the supplied stores. 
        //
        DWORD dwIndex = 0;
        DWORD dwStoreIndex = 0;
        PCCERT_CONTEXT pcCert = NULL;
        
        for ( dwIndex = 0; dwIndex < pCtlInfo->cCTLEntry; dwIndex++ )
        {
            for ( dwStoreIndex = 0; dwStoreIndex < dwNumStores; dwStoreIndex++ )
            {
                
                if ( pcCert = CertFindCertificateInStore( ahStores[dwStoreIndex],
                                                          X509_ASN_ENCODING,
                                                          0,
                                                          CERT_FIND_SHA1_HASH,
                                      (VOID *) &(pCtlInfo->rgCTLEntry[dwIndex].SubjectIdentifier),
                                                          NULL ) )
                {
                    m_pCTLCerts[m_cCertsFound] = pcCert;
                    
                    (*pppCertContext)[m_cCertsFound] = 
                        CertDuplicateCertificateContext( pcCert );
                    
                    m_cCertsFound++;
                    
                    break;
                }
            }
        }
        
        *pcCertsFound = m_cCertsFound;
        m_fFoundCerts = TRUE;
    } // if ( !m_fFounCerts
    //
    // Already have the list of certs in the CTL
    //
    else
    {
        *pppCertContext = new PCCERT_CONTEXT[m_cCertsFound];
        if ( !*pppCertContext )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }
        
        for ( DWORD i = 0; i < m_cCertsFound; i++ )
        {
            (*pppCertContext)[i] = CertDuplicateCertificateContext( m_pCTLCerts[i] );
        }
        
        *pcCertsInCTL = pCtlInfo->cCTLEntry;
        *pcCertsFound = m_cCertsFound;
    }

    return TRUE;
}

inline 
BOOL IIS_CTL::IsValid()
{
 return ( m_dwStatus == CERT_ERR_NONE ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\iisendp.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        iisendp.cxx

   Abstract:

        This module defines the IIS_ENDPOINT class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996

--*/

#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <iisassoc.hxx>
#include "inetreg.h"
#include <tcpcons.h>
#include <apiutil.h>
#include <issched.hxx>

#include "..\atq\atqtypes.hxx"

#if IE_REF_TRACKING

//
//  Ref count trace log size
//
#define C_IIS_ENDP_REFTRACES      4000
#define C_LOCAL_ENDP_REFTRACES         40

//
//  Ref trace log for IIS_ENDPOINT objects
//  NOTE we make this global so other classes can get at it
//
PTRACE_LOG   g_pDbgIERefTraceLog = NULL;

#endif

/*******************************************************************

    Macro support for IIS_ENDPOINT::Reference/Dereference

    HISTORY:
        MCourage       31-Oct-1997 Added ref trace logging

********************************************************************/

#if IE_REF_TRACKING
#define IE_LOG_REF_COUNT( cRefs )                               \
                                                                \
    IE_SHARED_LOG_REF_COUNT(                                       \
        cRefs                                                   \
        , (PVOID) this                                          \
        , m_state                                               \
        , m_atqEndpoint                                                \
        , 0xffffffff                                                \
        );                                                      \
    IE_LOCAL_LOG_REF_COUNT(                                        \
        cRefs                                                   \
        , (PVOID) this                                          \
        , m_state                                               \
        , m_atqEndpoint                                                \
        , 0xffffffff                                                \
        );
#else
#define IE_LOG_REF_COUNT( cRefs )
#endif



PVOID
I_IISAddListenEndpoint(
        IN PATQ_ENDPOINT_CONFIGURATION Configuration,
        IN PVOID                EndpointContext
        );


BOOL
IIS_SERVICE::AssociateInstance(
    IN PIIS_SERVER_INSTANCE pInstance
    )
/*++

Routine Description:

    Associates an instance with an endpoint.  It also activates the endpoint.

Arguments:

    pInstance - instance to associate.

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{

    DWORD err = NO_ERROR;
    BOOL shouldStart = FALSE;

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,
            "AssociateInstance %p called\n",
            pInstance));
    }

    //
    // Lock the service.
    //

    AcquireServiceLock( TRUE );

    //
    // if service is closing, abort
    //

    if ( !IsActive() ) {
        err = ERROR_NOT_READY;
        goto exit;
    }

    if ( pInstance->QueryServerState( ) != MD_SERVER_STATE_STOPPED ) {
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,"Server not in stopped (%d) state\n",
                    pInstance->QueryServerState()));
        }
        err = ERROR_INVALID_FUNCTION;
        goto exit;
    }

    //
    // Start the server instance.
    //

    shouldStart = TRUE;
    err = pInstance->DoStartInstance();

    if( err != NO_ERROR ) {
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT, "BindInstance() failed, %lu\n", err));
        }
    }

exit:

    if( shouldStart ) {

        //
        // We're up and running. Note that the StartInstance() method will
        // set the instance state appropriately if successful, so we only
        // need to set it if the start failed.
        //

        if( err != NO_ERROR ) {
            pInstance->SetServerState( MD_SERVER_STATE_STOPPED, err );
        }

        ReleaseServiceLock( TRUE );
        return TRUE;

    } else {

        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,"AssociateInstace: Error %d\n",
                err));
        }

        pInstance->SetServerState( MD_SERVER_STATE_STOPPED, err );
        ReleaseServiceLock( TRUE );
        SetLastError(err);
        return FALSE;

    }

} // IIS_SERVICE::AssociateInstance



BOOL
IIS_SERVICE::DisassociateInstance(
    IN PIIS_SERVER_INSTANCE pInstance
    )
/*++

Routine Description:

    Removes an instance from an endpoint.

Arguments:

    pInstance - instance to associate.

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{

    //
    // if it's running, stop it
    //

    AcquireServiceLock( TRUE );

    if ( pInstance->QueryServerState( ) == MD_SERVER_STATE_STOPPED ) {
        ReleaseServiceLock( TRUE );
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,
                "Cannot disassociate stopped server %p\n",pInstance));
        }
        return(TRUE);
    }

    pInstance->SetServerState( MD_SERVER_STATE_STOPPED, NO_ERROR );
    ReleaseServiceLock( TRUE );

    //
    // Blow away any users still clinging to this instance,
    // then unbind the instance.
    //

    pInstance->Reference();
    DisconnectUsersByInstance( pInstance );
    pInstance->UnbindInstance();
    pInstance->Dereference();

    return TRUE;

} // IIS_SERVICE::DisassociateInstance



BOOL
IIS_SERVICE::ShutdownService(
    VOID
    )
/*++

Routine Description:

    Shuts down all endpoints.

Arguments:

    None.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{

    //
    // Walk the list and close the instances
    //

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT, "ShutdownService called\n"));
    }

    //
    // Update the service state.
    //

    AcquireServiceLock( );
    m_state = BlockStateClosed;
    ReleaseServiceLock( );

    //
    // Blow away all instances.
    //

    DestroyAllServerInstances();

    return TRUE;

} // IIS_SERVICE::ShutdownService




IIS_ENDPOINT::IIS_ENDPOINT(
    IN PIIS_SERVICE pService,
    IN USHORT Port,
    IN DWORD IpAddress,
    IN BOOL fIsSecure
    )
:
    m_signature                     ( IIS_ENDPOINT_SIGNATURE),
    m_state                         ( BlockStateIdle),
    m_atqEndpoint                   ( NULL),
    m_isSecure                      ( fIsSecure),
    m_fAtqEpStopped                 ( FALSE),
    m_service                       ( NULL),
    m_reference                     ( 1),
    m_NumQualifiedInstances         ( 0),
    m_WildcardInstance              ( NULL),
    m_nAcceptExOutstanding          ( 0),
    m_AcceptExTimeout               ( 0),
    m_nInstances                    ( 0)
{

    //
    // initialize the lock
    //

    INITIALIZE_CRITICAL_SECTION(&m_endpointLock);

    //
    // initialize the association info
    //

    ZeroMemory(
        m_QualifiedInstances,
        sizeof(m_QualifiedInstances)
        );

    //
    // reference the service
    //

    if ( !pService->CheckAndReference( ) ) {
        m_state = BlockStateInvalid;
        return;
    }

    m_service = pService;

    //
    // use the service name as the advertised name
    //

    m_Port = Port;
    m_IpAddress = IpAddress;

#if IE_REF_TRACKING
    _pDbgIERefTraceLog = CreateRefTraceLog( C_LOCAL_ENDP_REFTRACES, 0 );
#endif

} // IIS_ENDPOINT::IIS_ENDPOINT


IIS_ENDPOINT::~IIS_ENDPOINT(
    VOID
    )
{
    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,"IIS Endpoint %p freed\n",this));
    }

    DBG_ASSERT( m_signature == IIS_ENDPOINT_SIGNATURE );

    //
    // Delete the instance association objects.
    //

    for( INT qualifier = (INT)FullyQualified ;
         qualifier < (INT)NumInstanceQualifiers ;
         qualifier++ ) {

        delete m_QualifiedInstances[qualifier];

    }

    //
    // Dereference the owning service.
    //

    if ( m_service != NULL ) {
        m_service->Dereference();
        m_service = NULL;
    }

    m_signature = IIS_ENDPOINT_SIGNATURE_FREE;
    DeleteCriticalSection(&m_endpointLock);

#if IE_REF_TRACKING
    DestroyRefTraceLog( _pDbgIERefTraceLog );
#endif

} // IIS_ENDPOINT::~IIS_ENDPOINT



BOOL
IIS_ENDPOINT::AddInstance(
    IN PIIS_SERVER_INSTANCE pInstance,
    IN DWORD IpAddress,
    IN const CHAR * HostName
    )
/*++

Routine Description:

    Adds an instance to an existing endpoint.

Arguments:

    pInstance - instance to add.

    IpAddress - The IP address for this instance; may be INADDR_ANY;.

    HostName - The host name for this instance; may be empty ("").

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{
    INSTANCE_QUALIFIER qualifier;
    DWORD status;

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,
            "IIS_ENDPOINT::AddInstance %p called\n", pInstance));
    }

    //
    // Determine the proper qualifier based on the presence of the
    // IP address and host name.
    //

    qualifier = CalcQualifier( IpAddress, HostName );

    LockEndpoint();

    //
    // Put instance into proper association.
    //

    if( qualifier == WildcardInstance ) {

        if( m_WildcardInstance == NULL ) {
            m_WildcardInstance = pInstance;
        } else {
            DBGPRINTF((
                DBG_CONTEXT,
                "AddInstance: endpoint %p already has a wildcard instance\n",
                this
                ));

            status = ERROR_INVALID_PARAMETER;
            goto unlock_and_fail;
        }

    } else {

        PIIS_ASSOCIATION association;

        //
        // Create a new instance association object if necessary.
        //

        association = m_QualifiedInstances[qualifier];

        if( association == NULL ) {
            association = new IIS_ASSOCIATION(
                                  ( qualifier == FullyQualified ) ||
                                      ( qualifier == QualifiedByIpAddress ),
                                  ( qualifier == FullyQualified ) ||
                                      ( qualifier == QualifiedByHostName )
                                  );

            if( association == NULL ) {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "AddInstance: cannot create new association\n"
                    ));

                status = ERROR_NOT_ENOUGH_MEMORY;
                goto unlock_and_fail;
            }

            m_QualifiedInstances[qualifier] = association;
        }

        //
        // Add the instance to the association.
        //

        status = association->AddDescriptor(
                     IpAddress,
                     HostName,
                     (LPVOID)pInstance
                     );

        if( status != NO_ERROR ) {
            goto unlock_and_fail;
        }

        //
        // Update the number of qualified instances on this endpoint.
        // We use this to "short circuit" the instance lookup in the
        // common case of a single wildcard instance per endpoint.
        //

        m_NumQualifiedInstances++;

    }

    //
    // Setup the necessary references, update the server state.
    //

    Reference();
    pInstance->Reference();
    InterlockedIncrement( (LPLONG)&m_nInstances );

    //
    // Aggregate the AcceptEx outstanding parameter.
    //

    m_nAcceptExOutstanding += pInstance->QueryAcceptExOutstanding();
    m_nMaximumAcceptExOutstanding = pInstance->QueryMaxEndpointConnections();

    //
    // Activate the endpoint if necessary.
    //

    if ( !ActivateEndpoint() ) {
        status = GetLastError();
        RemoveInstance( pInstance, IpAddress, HostName );
        goto unlock_and_fail;
    }

    UnlockEndpoint();
    return TRUE;

unlock_and_fail:

    DBG_ASSERT( status != NO_ERROR );
    UnlockEndpoint();
    SetLastError( status );
    return FALSE;

} // IIS_ENDPOINT::AddInstance


BOOL
IIS_ENDPOINT::RemoveInstance(
    IN PIIS_SERVER_INSTANCE pInstance,
    IN DWORD IpAddress,
    IN const CHAR * HostName
    )
/*++

Routine Description:

    Removes an instance to an existing endpoint.

Arguments:

    pInstance - instance to remove

    IpAddress - The IP address for this instance; may be INADDR_ANY;.

    HostName - The host name for this instance; may be empty ("").

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{
    INSTANCE_QUALIFIER qualifier;
    DWORD status;

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,
            "RemoveInstance called endpoint %p instance %p\n",
            this, pInstance ));
    }

    DBG_ASSERT( m_signature == IIS_ENDPOINT_SIGNATURE );

    //
    // Determine the proper qualifier based on the presence of the
    // IP address and host name.
    //

    qualifier = CalcQualifier( IpAddress, HostName );

    LockEndpoint();

    m_nAcceptExOutstanding -= pInstance->QueryAcceptExOutstanding();

    if( qualifier == WildcardInstance ) {

        DBG_ASSERT( m_WildcardInstance == pInstance );
        m_WildcardInstance->Dereference();
        m_WildcardInstance = NULL;

    } else {

        LPVOID Context;

        DBG_ASSERT( m_QualifiedInstances[qualifier] != NULL );
        status = m_QualifiedInstances[qualifier]->RemoveDescriptor(
                        IpAddress,
                        HostName,
                        &Context
                        );

        if( status == NO_ERROR ) {

            DBG_ASSERT( Context == (LPVOID)pInstance );
            pInstance->Dereference();
            m_NumQualifiedInstances--;

        }

    }

    UnlockEndpoint();

    //
    // If this was the last instance, then remove ourselves from
    // the service's endpoint list and initiate shutdown.
    //

    if ( InterlockedDecrement( (LPLONG ) &m_nInstances) == 0 ) {
        RemoveEntryList( &m_EndpointListEntry );
        ShutdownEndpoint( );
    }

    //
    // Remove the reference added in AddInstance().
    //

    Dereference();
    return TRUE;

} // IIS_ENDPOINT::RemoveInstance




BOOL
IIS_ENDPOINT::ActivateEndpoint(
    VOID
    )
/*++

Routine Description:

    Starts an idle endpoint.

Arguments:

    None.

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{
    PVOID atqEndpoint = NULL;
    ATQ_ENDPOINT_CONFIGURATION config;

    //
    // Make sure this is idle
    //

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,"Calling activate on %p\n",this));
    }

    LockEndpoint( );
    if ( m_state == BlockStateActive ) {
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF(( DBG_CONTEXT,
                "Activate called on %p is not in idle state(%d)\n",
                this, (DWORD)m_state ));
        }

        DBG_ASSERT(m_atqEndpoint != NULL);

        AtqEndpointSetInfo(
                m_atqEndpoint,
                EndpointInfoAcceptExOutstanding,
                min(
                    m_nAcceptExOutstanding,
                    m_nMaximumAcceptExOutstanding
                    )
                );

        UnlockEndpoint();
        return(TRUE);
    }

    config.cbAcceptExRecvBuffer = m_service->m_cbRecvBuffer;
    config.pfnConnect = m_service->m_pfnConnect;
    config.pfnConnectEx = m_service->m_pfnConnectEx;
    config.pfnIoCompletion = m_service->m_pfnIoCompletion;

    config.ListenPort = m_Port;
    config.IpAddress = m_IpAddress;
    config.nAcceptExOutstanding = min( m_nAcceptExOutstanding,
                                       m_nMaximumAcceptExOutstanding );
    config.AcceptExTimeout = m_AcceptExTimeout;

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,"%d %d %d\n",
            config.ListenPort,
            config.nAcceptExOutstanding, config.AcceptExTimeout ));
    }

    atqEndpoint = I_IISAddListenEndpoint(
                                         &config,
                                         (PVOID)this
                                         );

    if ( atqEndpoint == NULL ) {
        UnlockEndpoint();
        DBGPRINTF(( DBG_CONTEXT,
            "Activate failed, error %d\n",GetLastError()));
        return(FALSE);
    }

    //
    // Update the state
    //

    m_state = BlockStateActive;
    m_atqEndpoint = atqEndpoint;
    Reference( );
    UnlockEndpoint();

    return(TRUE);

} // IIS_ENDPOINT::ActivateEndpoint



BOOL
IIS_ENDPOINT::StopEndpoint( VOID)
/*++

Routine Description:

    Stops the ATQ endpoint structure stored inside the IIS_ENDPOINT
    This will prevent us from accepting new connection. This function
    should be called only when are preparing ourselves to shut this
    endpoint down entirely.

Arguments:

    None.

Return Value:

    None.

History:
    MuraliK    7/8/97
--*/
{
    BOOL fReturn = TRUE;

    //
    // lock, check the state and
    //  then, stop any Atq Endpoint, if any.
    //

    LockEndpoint( );

    //
    // NYI: We mayhave to use an intermediate state for STopped endpoint.
    // Unfortunately the state machine usage in IIS_SERVICE/INSTANCE/ENDPOINT
    //   is not setup for doing so. For now I will just assert that this
    //   object is in an Active State
    //  - muralik  7/8/97
    //
    DBG_ASSERT( m_state == BlockStateActive);

    if ( m_atqEndpoint != NULL ) {
        
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT, 
                       "IIS_ENDPOINT(%08p) Stopping ATQ Endpoint %p\n",
                       this, m_atqEndpoint));
        }
        
        if ( !m_fAtqEpStopped ) {
            
            fReturn = AtqStopEndpoint( m_atqEndpoint);
            if ( fReturn ) {
                m_fAtqEpStopped = TRUE;
            }
        }
    }

    UnlockEndpoint();

    return (fReturn);
} // IIS_ENDPOINT::StopEndpoint()



VOID
IIS_ENDPOINT::ShutdownEndpoint(
    VOID
    )
/*++

Routine Description:

    Shuts down an endpoint.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // lock, check the state and mark it closed.
    //  then, shutdown any Atq Endpoint, if any.
    //

    LockEndpoint( );

    DBG_ASSERT(m_nInstances == 0);

    if ( m_state == BlockStateActive ) {

        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,"Shutting down endpoint %p\n",this));
        }
        m_state = BlockStateClosed;
        UnlockEndpoint();

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "IIS_ENDPOINT(%08p)::ShutdownEndpoint() for "
                        " AtqEndpoint  %08p\n",
                        this, m_atqEndpoint ));
        }

        if ( m_atqEndpoint != NULL ) {

            // I replaced AtqStopAndCloseEndpoint() here 

            if ( !m_fAtqEpStopped ) {

                DBG_REQUIRE( AtqStopEndpoint( m_atqEndpoint));
                m_fAtqEpStopped = TRUE;
            }
            
/*
 * Moved this to IIS_ENDPOINT::Dereference for shutdown thread hack
 *
            AtqCloseEndpoint( m_atqEndpoint);
            m_atqEndpoint = NULL;
 */
        }

        Dereference( );
    } else {
        UnlockEndpoint();
    }

    return;
} // IIS_ENDPOINT::ShutdownEndpoint



PIIS_SERVER_INSTANCE
IIS_ENDPOINT::FindAndReferenceInstance(
                   IN LPCSTR pszDomainName,
                   IN const DWORD   IPAddress,
                   OUT LPBOOL pbMaxConnExceeded
                   )
/*++

Routine Description:

    Finds the appropriate instance given domain name and
    socket information.  The instance is referenced if found.

Arguments:

    pszDomainName - Domain name of request.
    IPAddress - Local IP Address of the connection.
    pbMaxConnExceeded - Receives TRUE if the maximum number of connections
        for this endpoint has been exceeded. It is still the caller's
        responsibility to properly dispose of the instance.

Return Value:

    if successful, returns the pointer to the instance.
    NULL, otherwise.

--*/
{

    PIIS_SERVER_INSTANCE instance;
    DWORD status;
    INT qualifier;
    IIS_ASSOCIATION::HASH_CONTEXT context;

    IF_DEBUG(ENDPOINT) {

        LPCSTR tmp = pszDomainName;
        if ( tmp == NULL ) {
            tmp = "";
        }
        DBGPRINTF((DBG_CONTEXT,"Finding %s %x\n", tmp, IPAddress));
    }

    LockEndpoint( );
    DBG_CODE( instance = NULL );

    if( m_NumQualifiedInstances == 0 ) {

        //
        // Fast path: only the wildcard instance.
        //

        instance = m_WildcardInstance;
        status = NO_ERROR;

    } else {

        //
        // Less-fast path: we'll need to go hunt for it.
        //

        if( pszDomainName == NULL ) {
            pszDomainName = "";
        }

        IIS_ASSOCIATION::InitializeHashContext( &context );

        for( qualifier = FullyQualified ;
             qualifier < NumInstanceQualifiers ;
             qualifier++ ) {

            if( m_QualifiedInstances[qualifier] != NULL ) {

                status = m_QualifiedInstances[qualifier]->LookupDescriptor(
                             IPAddress,
                             pszDomainName,
                             (LPVOID *)&instance,
                             &context
                             );

                if( status == NO_ERROR ) {

                    goto FoundInstance;

                }

                DBG_ASSERT( instance == NULL );

            }

        }

        //
        // If we made it this far, then no qualified instances will
        // take the request, so use the wildcard (if available).
        //

        instance = m_WildcardInstance;

        //
        // Reset the status so that we may continue.
        //

        status = NO_ERROR;

    }

    if( instance == NULL ) {

        status = ERROR_BAD_NET_NAME;

    }

FoundInstance:

    if( status == NO_ERROR ) {

        DBG_ASSERT( instance != NULL );

        if( instance->QueryServerState() != MD_SERVER_STATE_STARTED ) {
            status = ERROR_FILE_NOT_FOUND;
        }

    }

    if( status == NO_ERROR ) {

        //
        // Reference this
        //

        instance->Reference( );
        UnlockEndpoint( );

        //
        // Make sure that we have not exceeded the max
        //

        instance->IncrementCurrentConnections();

        *pbMaxConnExceeded = ( instance->QueryCurrentConnections() >
                               instance->QueryMaxConnections() );

        if( *pbMaxConnExceeded ) {

            IF_DEBUG(ERROR) {
                DBGPRINTF((DBG_CONTEXT,
                  "Too many connected users (%d) max %d, refusing connection\n",
                   instance->QueryCurrentConnections(),
                   instance->QueryMaxConnections() ));
            }
        }

        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,
                "Found and referenced instance %p\n",instance));
        }

        return instance;

    }

    UnlockEndpoint();
    SetLastError( status );
    return NULL;

} // IIS_ENDPOINT::FindInstance




PVOID
I_IISAddListenEndpoint(
        IN PATQ_ENDPOINT_CONFIGURATION Configuration,
        IN PVOID                EndpointContext
        )
/*++

    Description:

        Adds a TCPIP ATQ endpoint.

    Arguments:

        Configuration - contains the endpoint configuration
        EndpointContext - context to return during completion

    Returns:

        TRUE if successful,
        FALSE, otherwise

--*/
{
    PVOID   atqEndpoint;
    BOOL    fReturn = FALSE;
 
    IF_DEBUG( INSTANCE ) {
        DBGPRINTF(( DBG_CONTEXT, "I_IISAddListenEndpoint called\n"));
    }

    //
    // Create the endpoint
    //

    atqEndpoint = AtqCreateEndpoint(
                            Configuration,
                            EndpointContext
                            );

    if ( atqEndpoint == NULL ) {
        goto error_exit;
    }

    //
    // Activate the endpoint
    //

    if ( !AtqStartEndpoint(atqEndpoint) ) {
        goto error_exit;
    }

    return (atqEndpoint);

error_exit:

    DWORD dwError = GetLastError();

    DBG_ASSERT( NO_ERROR != dwError );

    if ( atqEndpoint != NULL ) {

        AtqCloseEndpoint( atqEndpoint);
        atqEndpoint = NULL;
    }

    SetLastError(dwError);
    
    return(NULL);

} // I_IISAddListenEndpoint()



VOID
IIS_ENDPOINT::Reference( VOID )
/*++

Routine Description:

    Increments the reference count for the endpoint
    
Arguments:

    None
    
Return Value:

    None
    
--*/
{
    InterlockedIncrement( &m_reference );

    IE_LOG_REF_COUNT( m_reference );
}



typedef struct _ENDPOINT_HACK_PARAM {
    PIIS_ENDPOINT piisEndpoint;
    PVOID         patqEndpoint;
} ENDPOINT_HACK_PARAM, *PENDPOINT_HACK_PARAM;


VOID
WINAPI
EndpointHackFunc( PVOID pv );


VOID
IIS_ENDPOINT::Dereference( )
/*++

Routine Description:

    Decrements the reference count for the endpoint and cleans up if the refcount
    reaches zero.
    
Arguments:

    None
    
Return Value:

    None
    
--*/
{

    ASSERT( m_signature == IIS_ENDPOINT_SIGNATURE );
    ASSERT( m_reference > 0 );

    //
    // Write the trace log BEFORE the decrement operation :(
    // If we write it after the decrement, we will run into potential
    // race conditions in this object getting freed up accidentally
    // by another thread
    //
    // NOTE we write (_cRef - 1) == ref count AFTER decrement happens
    //
    LONG cRefsAfter = (m_reference - 1);
    IE_LOG_REF_COUNT( cRefsAfter );


    if ( InterlockedDecrement( &m_reference ) == 0 ) {
        DWORD dwCookie;
        PENDPOINT_HACK_PARAM pParam;


        DBGPRINTF((DBG_CONTEXT,"deleting endpoint %p\n",this));

        if ( m_atqEndpoint != NULL ) {
            ASSERT( ((PATQ_ENDPOINT)m_atqEndpoint)->Signature == ATQ_ENDPOINT_SIGNATURE );
        
            //
            // Because the ATQ endpoint has an uncounted reference to this object, we can't
            // go away until the ATQ endpoint is closed.  Since it may be bad to block our
            // own thread while waiting for the ATQ endpoint, we create a new thread to do
            // it.
            //
            pParam = new ENDPOINT_HACK_PARAM;
            if (pParam == NULL) {
                goto threadfail;
            }

            pParam->piisEndpoint = this;
            pParam->patqEndpoint = m_atqEndpoint;

            dwCookie = ScheduleWorkItem( EndpointHackFunc, pParam, 0 );
            
            if ( dwCookie == 0 ) {
                goto threadfail;
            }
        } else {
            //
            // If we couldn't activate the endpoint we will not have an ATQ_ENDPOINT
            // to close.  In this case we can clean up immediately
            //
            delete this;
        }

    } else {
        //DBGPRINTF((DBG_CONTEXT,"endpoint deref count %d\n",m_reference));
    }

    return;

threadfail:
    
    if ( AtqCloseEndpoint( m_atqEndpoint ) ) {

        ASSERT( m_signature == IIS_ENDPOINT_SIGNATURE );
            
        delete this;
    } else {
        //
        // There could still be some connections to us, so we can't free the memory.
        // However we have to dereference the IIS_SERVICE, which is waiting for us
        // during shutdown.  Normally this deref occurs during the IIS_ENDPOINT destructor.
        //
        m_service->Dereference();
        m_service = NULL;

        DBGPRINTF((DBG_CONTEXT,
                   "AtqCloseEndpoint returned FALSE! "
                   "Leaking endpoints: iisEndpoint = %p, atqEndpoint = %p\n",
                   this, m_atqEndpoint));
    }
    
}


VOID
WINAPI
EndpointHackFunc(
    PVOID pv
    )
/*++

Routine Description:

    This function is a work item scheduled by IIS_ENDPOINT::Dereference.  When the IIS_ENDPOINT
    refcount hits zero, there is still a reference to the structure from the ATQ_ENDPOINT.
    We call AtqCloseEndpoint, which returns when the reference is gone, and then clean up
    when it is safe to do so.
    
Arguments:

    pv - a parameter block containing pointers to the IIS_ENDPOINT and it's ATQ_ENDPOINT.
    
Return Value:

    None
    
--*/
{
    PENDPOINT_HACK_PARAM pParam = (PENDPOINT_HACK_PARAM) pv;
    
    ASSERT( pParam->piisEndpoint->CheckSignature(IIS_ENDPOINT_SIGNATURE) );
    ASSERT( ((PATQ_ENDPOINT)pParam->patqEndpoint)->Signature == ATQ_ENDPOINT_SIGNATURE );

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT, "EndpointHackFunc: iis=%p atq=%p\n", 
                   pParam->piisEndpoint, pParam->patqEndpoint));
    }

    //
    // if AtqCloseEndpoint fails we can't clean up, because someone could
    // still have a pointer to us!
    //
    if ( AtqCloseEndpoint( pParam->patqEndpoint ) ) {

        ASSERT( pParam->piisEndpoint->CheckSignature(IIS_ENDPOINT_SIGNATURE) );
            
        delete pParam->piisEndpoint;
    } else {
        //
        // There could still be some connections to us, so we can't free the memory.
        // However we have to dereference the IIS_SERVICE, which is waiting for us
        // during shutdown.  Normally this deref occurs during the IIS_ENDPOINT destructor.
        //
        pParam->piisEndpoint->QueryService()->Dereference();
        pParam->piisEndpoint->SetService( NULL );

        DBGPRINTF((DBG_CONTEXT,
                   "AtqCloseEndpoint returned FALSE! "
                   "Leaking endpoints: iisEndpoint = %p, atqEndpoint = %p\n",
                   pParam->piisEndpoint, pParam->patqEndpoint));
    }
    
    delete pParam;    
}

BOOL
InitializeEndpointUtilities(
    VOID
)
/*++

Routine Description:

    Called during infocomm initialization.  This sets up a global debug trace
    log object

Arguments:

    None
    
Return Value:

    TRUE if successful
    
--*/
{
#if IE_REF_TRACKING
    if ( g_pDbgIERefTraceLog == NULL ) 
    {
        g_pDbgIERefTraceLog = CreateRefTraceLog( C_IIS_ENDP_REFTRACES, 0 );
        return g_pDbgIERefTraceLog != NULL;
    }
#endif
    return TRUE;
}

BOOL
TerminateEndpointUtilities(
    VOID
)
/*++

Routine Description:

    Called during infocomm cleanup.  This cleans up the global debug trace
    log object 

Arguments:

    None
    
Return Value:

    TRUE if successful
    
--*/
{
#if IE_REF_TRACKING
    if ( g_pDbgIERefTraceLog )
    {
         DestroyRefTraceLog( g_pDbgIERefTraceLog );
         g_pDbgIERefTraceLog = NULL;
    }
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\logon32.cxx ===
/*++


Copyright (c) 1996  Microsoft Corporation

Module Name:

    logon32.cxx

Abstract:

    Provide a replacement for LogonUser to login a user
    as a net logon. Also support sub-authentication DLL IDs

Author:

    Philippe Choquier (phillich)    10-january-1996
    Created from base\advapi\logon32.c

--*/


#include "tcpdllp.hxx"

#pragma hdrstop

#include <lmjoin.h>
#include <lonsi.hxx>
#include <infosec.hxx>

//
// externs
//

extern LOGON32_INITIALIZE_FN           pfnLogon32Initialize;
extern LOGON_NET_USER_A_FN             pfnLogonNetUserA;
extern LOGON_NET_USER_W_FN             pfnLogonNetUserW;
extern NET_USER_COOKIE_A_FN            pfnNetUserCookieA;
extern LOGON_DIGEST_USER_A_FN          pfnLogonDigestUserA;

BOOL
Logon32Initialize(
    IN PVOID    hMod,
    IN ULONG    Reason,
    IN PCONTEXT Context)
/*++

Routine Description:

    Initializes the critical section

Arguments:

    hMod -- reserved, must be NULL
    Reason -- DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH
    Context -- reserved, must be NULL

Returns:

    TRUE if initialization success, else FALSE

--*/
{
    DBG_ASSERT( pfnLogon32Initialize != NULL );
    return pfnLogon32Initialize(
                            hMod,
                            Reason,
                            Context );
} // Logon32Initialize


BOOL
WINAPI
LogonNetUserW(
    PWSTR           lpszUsername,
    PWSTR           lpszDomain,
    PSTR            lpszPassword,
    PWSTR           lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT( pfnLogonNetUserW != NULL );
    return pfnLogonNetUserW(
                    lpszUsername,
                    lpszDomain,
                    lpszPassword,
                    lpszWorkstation,
                    dwSubAuth,
                    dwLogonType,
                    dwLogonProvider,
                    phToken,
                    pExpiry
                    );
} // LogonNetUserW


dllexp
BOOL
WINAPI
LogonNetUserA(
    PSTR            lpszUsername,
    PSTR            lpszDomain,
    PSTR            lpszPassword,
    PSTR            lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT( pfnLogonNetUserA != NULL );
    return pfnLogonNetUserA(
                    lpszUsername,
                    lpszDomain,
                    lpszPassword,
                    lpszWorkstation,
                    dwSubAuth,
                    dwLogonType,
                    dwLogonProvider,
                    phToken,
                    pExpiry);

} // LogonNetUserA


dllexp
BOOL
WINAPI
NetUserCookieA(
    LPSTR       lpszUsername,
    DWORD       dwSeed,
    LPSTR       lpszCookieBuff,
    DWORD       dwBuffSize
    )
/*++

Routine Description:

    Compute logon validator ( to be used as password )
    for IISSuba

Arguments:

    lpszUsername -- user name
    dwSeed -- start value of cookie

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT(pfnNetUserCookieA != NULL);
    return pfnNetUserCookieA(
                    lpszUsername,
                    dwSeed,
                    lpszCookieBuff,
                    dwBuffSize
                    );
} // NetUserCookieA


dllexp
BOOL
WINAPI
LogonDigestUserA(
    VOID *                  pDigestBuffer,
    DWORD                   dwAlgo,
    HANDLE *                phToken
    )
/*++

Routine Description:

    Logs a user on via username and domain name via the LSA using Digest authentication.
    AMallet, 5/11/98 - This function is currently only called by the Digest Auth filter.

Arguments:

    pDigestBuffer - Digest parameters
    dwAlgo - Logon type
    phToken -- created access token

Returns:

    TRUE if success, FALSE if error

--*/
{
    PDIGEST_LOGON_INFO pDigestLogonInfo = (PDIGEST_LOGON_INFO) pDigestBuffer;

    static CHAR achDefaultDomain[IIS_DNLEN + 1];
    
    //
    // [See comment above about where this function is called from]
    // The digest filter will do what it can to pass in a non-empty domain [it'll try the
    // domain specified by the user, the metabase-configured domain and the domain the computer
    // is a part of, in that order], but if everything fails, we'll just have to use the
    // "default" domain name, which is usually the name of the machine itself
    //

    if ( !pDigestLogonInfo->pszDomain || 
         pDigestLogonInfo->pszDomain[ 0 ] == '\0' )
    {
        if ( achDefaultDomain[0] == '\0' )
        {
            if ( !pfnGetDefaultDomainName( achDefaultDomain,
                                           sizeof(achDefaultDomain) ) )
            {
                return FALSE;
            }
        }
        pDigestLogonInfo->pszDomain = achDefaultDomain;
    }
    else if ( pDigestLogonInfo->pszDomain[ 0 ] == '\\' )
    {
        pDigestLogonInfo->pszDomain[ 0 ] = '\0';
    }
    
    return pfnLogonDigestUserA( pDigestLogonInfo,
                                dwAlgo,
                                phToken );

} // LogonDigestUserA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\isrpc.cxx ===
/*++


Copyright (c) 1999  Microsoft Corporation

Module Name:

    isrpc.cxx

Abstract:

    Contains ISRPC class implementation.

Author:

    Murali R. Krishnan         11-Dec-1995

Environment:

    User Mode - Win32

Revision History:

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#include <tcpdllp.hxx>
#include <isplat.h>
#include "dbgutil.h"
#include "isrpc.hxx"

extern PFN_INETINFO_START_RPC_SERVER pfnInetinfoStartRpcServer;
extern PFN_INETINFO_STOP_RPC_SERVER  pfnInetinfoStopRpcServer;

/************************************************************
 *  Functions
 ************************************************************/


ISRPC::ISRPC(IN LPCTSTR  pszServiceName)
/*++

  This function constructs a new ISRPC object, initializing the
   members to proper state.
  Always the ISRPC members will use RPC_C_AUTHN_WINNT.

  Arguments:

    pszServiceName -  pointer to string containing the name of the service
    dwServiceAuthId - DWORD containing the service Authentication Identifier.

  Returns:
    A valid initialized ISRPC object on success.

--*/
:  m_dwProtocols         ( 0),
   m_fInterfaceAdded     ( FALSE),
   m_fEpRegistered       ( FALSE),
   m_fServerStarted      ( FALSE),
   m_hRpcInterface       ( NULL),
   m_pszServiceName      ( pszServiceName),
   m_pBindingVector      ( NULL)
{

    DBG_REQUIRE( SetSecurityDescriptor() == NO_ERROR);

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Created new ISRPC object for %s at %08p\n",
                   m_pszServiceName, this));
    }

} // ISRPC::ISRPC()




ISRPC::~ISRPC(VOID)
/*++

  This function cleans up the ISRPC object and releases any dynamic memory or
  state associated with this object.

--*/
{
    if( m_hRpcInterface != NULL ) {
        // CleanupData() should not be called twice
        CleanupData();
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Destroyed ISRPC object for %s at %p\n",
                   m_pszServiceName, this));
    }

} // ISRPC::~ISRPC()




DWORD
ISRPC::CleanupData(VOID)
/*++

Routine Description:

    This member function cleans up the ISRPC object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " ISRPC(%p)::Cleaning up for %s\n",
                   this, m_pszServiceName));
    }

    if ( m_fServerStarted) {

        rpcStatus = StopServer( );
    }

    DBG_ASSERT( rpcStatus == RPC_S_OK);

    rpcStatus = UnRegisterInterface();

    m_dwProtocols     = 0;
    m_hRpcInterface   = NULL;

    return (rpcStatus);
} // ISRPC::CleanupData()




DWORD
ISRPC::RegisterInterface( IN RPC_IF_HANDLE  hRpcInterface)
/*++

  This function registers the RPC inteface in the object.
  If there is already a valid instance present in the object,
   this function fails and returns error.
  If this is the new interface specified, the function registers the
    interface both for dynamic and static bindings.

   Should be called after calling AddProtocol() and before StartServer()

  Arguments:
    hRpcInteface - RPC inteface handle.

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( m_dwProtocols == 0) {

        // No protocol added. Return failure.
        return ( ERROR_INVALID_PARAMETER);
    }

    if ( m_hRpcInterface != NULL) {

        dwError =  ( RPC_S_DUPLICATE_ENDPOINT);
    } else {

        //
        // since there is no duplicate, just set the new value and return.
        //

        if ( hRpcInterface == NULL) {

            dwError = ERROR_INVALID_PARAMETER;
        } else {

            m_hRpcInterface = hRpcInterface;
        }
    }


    if ( dwError == RPC_S_OK) {

        dwError = RpcServerRegisterIf(m_hRpcInterface,
                                      0,   // MgrUuid
                                      0    // MgrEpv (Entry Point Vector)
                                      );

        if ( dwError == RPC_S_OK ) {

            m_fInterfaceAdded = TRUE;

            //
            //  Establish the dynamic bindings if any.
            //

            if ( (m_dwProtocols & (ISRPC_OVER_TCPIP | ISRPC_OVER_SPX)) != 0) {

                dwError = RpcServerInqBindings( &m_pBindingVector);

                if ( dwError == RPC_S_OK) {

                    DBG_ASSERT( m_pBindingVector != NULL);

                    dwError = RpcEpRegister(m_hRpcInterface,
                                            m_pBindingVector,
                                            NULL,
                                            (unsigned char *) "" );

                    if ( dwError == RPC_S_OK) {

                        m_fEpRegistered = TRUE;
                    }
                } // Ep registering
            } // dynamic bindings
        } // registration successful
    }


    IF_DEBUG(DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%p)::RegisterInterface(%08x)"
                   " returns %ld\n",
                   this, hRpcInterface, dwError));
    }

    return ( dwError);

} // ISRPC::RegisterInterface()



DWORD
ISRPC::UnRegisterInterface( VOID)
/*++

  This function unregisters the RPC inteface in the object.

   Should be called after after StopServer() and before cleanup.

  Arguments:
    None

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( m_fEpRegistered) {

        DBG_ASSERT( m_hRpcInterface != NULL && m_pBindingVector != NULL);
        rpcStatus = RpcEpUnregister(m_hRpcInterface,
                                    m_pBindingVector,
                                    NULL              // pUuidVector
                                    );
        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                       "%p::RpcEpUnregister(%s) returns %d\n",
                       this, m_pszServiceName, rpcStatus));
        }

        if( rpcStatus == EPT_S_CANT_PERFORM_OP )
        {
            // This error can be returned in cases such as system
            // shutdown that are not severe errors. So we don't
            // want to assert.
            DBGWARN(( DBG_CONTEXT,
                      "%p::RpcEpUnregister(%s) failed with EPT_S_CANT_PERFORM_OP\n",
                      this, m_pszServiceName
                      ));
        }
        else
        {
            DBG_ASSERT( rpcStatus == RPC_S_OK );
            m_fEpRegistered = FALSE;
        }
    }

    if ( m_pBindingVector != NULL) {

        rpcStatus = RpcBindingVectorFree( &m_pBindingVector);

        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                       "%p::RpcBindingVectorFree(%s, %p) returns %d\n",
                       this, m_pszServiceName,
                       m_pBindingVector, rpcStatus));
        }

        DBG_ASSERT( rpcStatus == RPC_S_OK);

        m_pBindingVector = NULL;
    }

    if ( m_fInterfaceAdded != NULL) {

        rpcStatus = RpcServerUnregisterIf(m_hRpcInterface,
                                          NULL,      // MgrUuid
                                          TRUE  // wait for calls to complete
                                          );

        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                       "%p::RpcServerUnregisterIf(%s, %08x) returns %d\n",
                       this, m_pszServiceName, m_hRpcInterface, rpcStatus));
        }
    }

    IF_DEBUG(DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%p)::UnRegisterInterface(%08x)"
                   " returns %ld\n",
                   this, m_hRpcInterface, rpcStatus));
    }

    return ( rpcStatus);
} // ISRPC::UnRegisterInterface()




DWORD
ISRPC::AddProtocol( IN DWORD Protocol)
/*++

Routine Description:

    This member function adds another protocol to the binding list.

Arguments:

    protocol - protocol binding opcode.

    fDynamic - Boolean indicating if the call should do dynamic or static
                RPC binding for the protocol specified.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_LPC ) {

        // Currently we only support static binding
        rpcStatus = BindOverLpc( FALSE);
    }

#ifndef CHICAGO

    //
    // Enable all remote bindings
    //

    if ( rpcStatus == RPC_S_OK ) {

        if ( Protocol & ISRPC_OVER_TCPIP ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverTcp( TRUE);
        }

        if ( rpcStatus == RPC_S_OK && Protocol & ISRPC_OVER_NP ) {

            // Currently we only support static binding
            rpcStatus = BindOverNamedPipe( FALSE);
        }

        if ( rpcStatus == RPC_S_OK &&  Protocol & ISRPC_OVER_SPX  ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverSpx( TRUE);
        }
    }

#else // CHICAGO
    rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_TCPIP ) {

        // Currently we only support dynamic binding
        rpcStatus = BindOverTcp( TRUE);
    }

    if ( Protocol & ISRPC_OVER_NB ) {

        // Currently we only support dynamic binding
        // Ignore status for NB for now
        (VOID)BindOverNetBios(TRUE);
    }
#endif // CHICAGO

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%p)::AddProtocol(%08x) returns %ld.\n",
                   this, Protocol, rpcStatus ));
    }

    return( rpcStatus );

} // ISRPC::AddProtocol()

DWORD
ISRPC::RemoveProtocol(IN DWORD Protocol)
/*++

Routine Description:

    This member function removes a protocol from the binding list.

Arguments:

    protocol - protocol binding opcode.

Return Value:

    RPC error code.

Note:
    As a side effect, this function removes the dynamic endpoing on
     TCPIP when SPX binding is removed and vice-versa.

--*/
{

    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%p)::RemoveProtocol(%s) is not implemented\n",
               this, m_pszServiceName));
    DBG_ASSERT( FALSE);

    return ( ERROR_CALL_NOT_IMPLEMENTED);
} // ISRPC::RemoveProtocol()




DWORD
ISRPC::StartServer(
            VOID
            )
/*++

Routine Description:

    This member function start RPC server.

Arguments:

    None.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus;

    //
    // add the interface.
    //

    if ( m_hRpcInterface == NULL) {

        return (ERROR_INVALID_PARAMETER);
    }

    //
    // start rpc server.
    //

#ifndef SERVICE_AS_EXE

    rpcStatus =  pfnInetinfoStartRpcServer();

#else

    rpcStatus = RpcServerListen(
                                1,          // minimum num threads.
                                1,          // max concurrent calls.
                                TRUE );     // don't wait

#endif // SERVICE_AS_EXE

    if ( rpcStatus == RPC_S_OK ) {
        m_fServerStarted = TRUE;
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%p)::StartServer(%s) returns %ld\n",
                   this, m_pszServiceName, rpcStatus));
    }

    return( rpcStatus );

} // ISRPC::StartServer()




DWORD
ISRPC::StopServer(
            VOID
            )
{
    DWORD  rpcStatus = RPC_S_OK;

    if( m_fServerStarted ) {

#ifndef SERVICE_AS_EXE

        rpcStatus = pfnInetinfoStopRpcServer();
#else

        //
        // stop server listen.
        //

        rpcStatus = RpcMgmtStopServerListening(0);

        //
        // wait for all RPC threads to go away.
        //

        if( rpcStatus == RPC_S_OK) {

            rpcStatus = RpcMgmtWaitServerListen();
        }

#endif // SERVICE_AS_EXE

        m_fServerStarted = FALSE;
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%p)::StopServer( %s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }

    return ( rpcStatus);
} // ISRPC::StopServer()



DWORD
ISRPC::EnumBindingStrings(
    IN OUT LPINET_BINDINGS pBindings
    )
/*++

Routine Description:

    This member function enumurates the binding strings of the protocols
    bound to the server.

Arguments:

    pBindings : pointer to a binding strings structure. The caller
        should call FreeBindingStrings member function to free the string
        after use.

Return Value:

    Windows Error Code;

--*/
{
   DWORD dwError;
   RPC_BINDING_VECTOR * pBindingVector = NULL;
   LPINET_BIND_INFO pBindingsInfo;
   DWORD  dwCount = 0;
   DWORD i;

   //
   // query RPC for RPC_BINDING_VECTORS.
   //

   dwError =   RpcServerInqBindings( &pBindingVector );

   if( dwError != NO_ERROR ) {

       goto Cleanup;
   }

   DBG_ASSERT( pBindingVector->Count > 0 );

   //
   // alloc memory for  INET_RPC_BINDING_STRINGS.
   //

   pBindingsInfo = (LPINET_BIND_INFO)
     LocalAlloc( GPTR, sizeof(INET_BIND_INFO) * pBindingVector->Count );

   if( pBindingsInfo == NULL ) {

       dwError = ERROR_NOT_ENOUGH_MEMORY;
       goto Cleanup;
   }

   //
   // convert binding handle to binding vectors.
   //

   pBindings->NumBindings  = 0;
   pBindings->BindingsInfo = pBindingsInfo;

   for( i = 0; i < pBindingVector->Count; i++ ) {

       LPSTR BindingString;

       BindingString = NULL;
       dwError = RpcBindingToStringBindingA(pBindingVector->BindingH[i],
                                            (LPBYTE *)&BindingString );

       if( dwError != NO_ERROR ) {
           goto Cleanup;
       }

       IF_DEBUG( DLL_RPC) {
           DBGPRINTF(( DBG_CONTEXT, "Binding Handle[%d] = %08x. String = %s\n",
                      i, pBindingVector->BindingH[i], BindingString));
       }


       //
       // check to we get only our named-pipe endpoint.
       //

       if ( ( strstr( BindingString, "ncacn_np" ) == NULL ) ||
            ( strstr(BindingString, m_pszServiceName ) == NULL ) ) {

           RpcStringFreeA( (LPBYTE *)&BindingString );

       } else {

           //
           // found a named-pipe binding string with service name.
           //

           IF_DEBUG( DLL_RPC) {
               DBGPRINTF(( DBG_CONTEXT, "Binding String Chosen = %s\n",
                          BindingString));
           }

           pBindings->BindingsInfo[dwCount].Length =
             (strlen(BindingString) + 1) * sizeof(CHAR);
           pBindings->BindingsInfo[dwCount].BindData = BindingString;
           dwCount++;
       }

   } // for

   dwError = NO_ERROR;
   pBindings->NumBindings = dwCount;

   IF_DEBUG( DLL_RPC) {

       DBGPRINTF(( DBG_CONTEXT, "Binding Vectors chosen"
                  " Service = %s, NumBindings = %d of Total = %d\n",
                  m_pszServiceName, dwCount, pBindingVector->Count));
   }

 Cleanup:

   if( pBindingVector != NULL ) {

       DWORD LocalError;
       LocalError = RpcBindingVectorFree( &pBindingVector );
       DBG_ASSERT( LocalError == NO_ERROR );
   }

   if( dwError != NO_ERROR ) {
       FreeBindingStrings( pBindings );
       pBindings->NumBindings = 0;

       IF_DEBUG( DLL_RPC) {

           DBGPRINTF(( DBG_CONTEXT,
                      "ISRPC(%p)::EnumBindingStrings(%s) failed, %ld.",
                      this, m_pszServiceName, dwError ));
       }
   }

   return( dwError );

} // ISRPC::EnumBindingStrings()




VOID
ISRPC::FreeBindingStrings(
     IN OUT LPINET_BINDINGS pInetBindings
    )
/*++

Routine Description:

    This member function deletes a binding vector that was returned by the
    EnumBindingStrings member function.

Arguments:

    pBindings : pointer to a binding vector.

Return Value:

    Windows Error Code;

--*/
{
    DWORD dwError;
    DWORD i;


    //
    // free binding strings.
    //

    for( i = 0; i < pInetBindings->NumBindings; i++) {
        dwError = RpcStringFreeA( ((LPBYTE *)&pInetBindings
                                 ->BindingsInfo[i].BindData ));
        DBG_ASSERT( dwError == NO_ERROR );
    }

    pInetBindings->NumBindings = 0;

    //
    // free bindings info array.
    //

    if( pInetBindings->BindingsInfo != NULL ) {
        LocalFree( (LPWSTR)pInetBindings->BindingsInfo );
        pInetBindings->BindingsInfo = NULL;
    }

    return;

} // ISRPC::FreeBindingStrings()




DWORD
ISRPC::BindOverTcp(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_TCPIP) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ( ISRPC::DynamicBindOverTcp());
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_TCPIP;
    }

    if (rpcStatus == RPC_S_PROTSEQ_NOT_SUPPORTED) {

        //
        // This error gets written to the event log by the service controller,
        // so give it something the user is more likely to understand.
        //

        rpcStatus = DNS_ERROR_NO_TCPIP;


        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                        "(%p)::BindOverTcp(%s) mapping error %d to error %d\n",
                        this,
                        m_pszServiceName,
                        RPC_S_PROTSEQ_NOT_SUPPORTED,
                        DNS_ERROR_NO_TCPIP));
        }

    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%p)::BindOverTcp(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }

    return ( rpcStatus);
} // ISRPC::BindOverTcpIp()

#ifdef CHICAGO
DWORD
ISRPC::BindOverNetBios(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NB) == 0);

    if ( !fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    // We will use Dynamic endpoint for the NetBios binding.

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_ipx",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid );           // security

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_tcp",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid );           // security

    switch (rpcStatus) {

      case RPC_S_OK:

        //
        // set the protocol bit.
        //

        m_dwProtocols |= ISRPC_OVER_NB;
        break;

      case RPC_S_DUPLICATE_ENDPOINT:

        DBGPRINTF(( DBG_CONTEXT,
                   "(%p) ncacn_nb is already added for %s\n",
                   this,
                   m_pszServiceName));
        rpcStatus = RPC_S_OK;
        break;

      case RPC_S_PROTSEQ_NOT_SUPPORTED:
      case RPC_S_CANT_CREATE_ENDPOINT:

        DBGPRINTF(( DBG_CONTEXT,
                   "(%p) ncacn_nb is not supported for %s (%ld).\n",
                   this, m_pszServiceName, rpcStatus ));
        rpcStatus = RPC_S_OK;
        break;

      default:
        break;
    } // switch()

    //
    // if the security support provider is not enabled, do so.
    //

    if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

        rpcStatus = AddSecurity();

    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%p)::BindOverNetBios(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }

    return ( rpcStatus);
} // ISRPC::BindOverNetBios()
#endif // CHICAGO

DWORD
ISRPC::BindOverNamedPipe(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NP) == 0);


    //
    // On Named Pipe, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_NP) == 0 ) {

        WCHAR  rgchNp[1024];

        wsprintfW( rgchNp,
#ifdef UNICODE
                  L"%ws%s"
#else
                  L"%ws%S"
#endif // UNICODE
                  ,
                  ISRPC_NAMED_PIPE_PREFIX_W,
                  m_pszServiceName);

        //
        // Establish a static Named pipe binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncacn_np",        // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchNp,             // end point!
                                 &sm_sid );          // security

        IF_DEBUG( DLL_RPC) {

            CHAR pszBuff[100];
            wsprintfA( pszBuff, "%S", rgchNp);
            DBGPRINTF(( DBG_CONTEXT,
                       " RpcServerUseProtseqEpW( %s, %d, %s, %p) returns"
                       " %d\n",
                       "ncacn_np", ISRPC_PROTSEQ_MAX_REQS,
                       pszBuff, &sm_sid, rpcStatus));
        }

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_NP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            DBGPRINTF(( DBG_CONTEXT,
                       "(%p) ncacn_np is already added for %s\n",
                       this,
                       m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_NP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "(%p) ncacn_np is not supported for %s (%ld).\n",
                       this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverNamedPipe()





DWORD
ISRPC::BindOverLpc(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_LPC) == 0);


    //
    // On LPC, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_LPC) == 0 ) {

        WCHAR  rgchLpc[1024];

        // LPC Endpoint string is:   <InterfaceName>_LPC
        wsprintfW( rgchLpc,
#ifdef UNICODE
                  L"%s_%ws"
#else
                  L"%S_%ws"
#endif // UNICODE
                  ,
                  m_pszServiceName,
                  ISRPC_LPC_NAME_SUFFIX_W);

        //
        // Establish a static Lpc binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncalrpc",         // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchLpc,            // end point!
                                 &sm_sid );          // security

        IF_DEBUG( DLL_RPC) {

            CHAR pszBuff[100];
            wsprintfA( pszBuff, "%S", rgchLpc);
            DBGPRINTF(( DBG_CONTEXT,
                       " RpcServerUseProtseqEpW( %s, %d, %s, %p) returns"
                       " %d\n",
                       "ncalrpc", ISRPC_PROTSEQ_MAX_REQS,
                       pszBuff, &sm_sid, rpcStatus));
        }

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_LPC;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            DBGPRINTF(( DBG_CONTEXT,
                       "(%p) ncalrpc is already added for %s\n",
                       this,
                       m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_LPC;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "(%p) ncalrpc is not supported for %s (%ld).\n",
                       this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverLpc()




DWORD
ISRPC::BindOverSpx(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_SPX) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ISRPC::DynamicBindOverSpx();
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_SPX;
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%p)::BindOverSpx(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }

    return ( rpcStatus);
} // ISRPC::BindOverSpx()


# if DBG

VOID
ISRPC::Print(VOID) const
{
    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%p). SvcName=%s\n"
               " Protocols = %d.\n"
               " RPC Interface = %08x. Binding Vector = %p\n"
               " InterfaceAdded = %d.\n"
               " EpRegistered = %d. ServerStarted = %d.\n"
               ,
               this, m_pszServiceName,
               m_dwProtocols,
               m_hRpcInterface, m_pBindingVector,
               m_fInterfaceAdded,
               m_fEpRegistered, m_fServerStarted
               ));

} // ISRPC::Print()

# endif // DBG



/******************************
 * STATIC Member Definitions
 ******************************/

DWORD ISRPC::sm_dwProtocols = 0;

SECURITY_DESCRIPTOR ISRPC::sm_sid;
PACL ISRPC::sm_pACL;
BOOL  ISRPC::sm_fSecurityEnabled = FALSE;


DWORD
ISRPC::Initialize(VOID)
{
    sm_dwProtocols  = 0;

    return SetSecurityDescriptor();

} // ISRPC::Initialize()



DWORD
ISRPC::Cleanup(VOID)
{
    //
    // Free up the memory holding the ACL for the security descriptor
    //
    delete [] ((BYTE *) sm_pACL);
    sm_pACL = NULL;

    //
    // Free up the security descriptor
    //

    ZeroMemory( (PVOID) &sm_sid, sizeof(sm_sid));

    //
    // For now nothing to do. Just a place holder.
    //

    return ( NO_ERROR);

} // ISRPC::Cleanup()


DWORD
ISRPC::DynamicBindOverTcp(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over TCP/IP, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_TCPIP) == 0 ) {

        //
        // Not already present. Add dynamic endpoint over TCP/IP
        //

        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_ip_tcp",    // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //

            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "ncacn_ip_tcp is already added.\n"));
            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "ncacn_ip_tcp is not supported. Error = %ld\n",
                       rpcStatus));

            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

            rpcStatus = AddSecurity();

        }
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverTcp() returns %d\n",
                   rpcStatus));
    }

    return ( rpcStatus);

} // ISRPC::DynamicBindOverTcp()




DWORD
ISRPC::DynamicBindOverSpx(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over SPX, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_SPX) == 0 ) {

        // Use dynamic end point for the server.
        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_spx",       // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            sm_dwProtocols |= ISRPC_OVER_SPX;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "ncacn_spx is already added.\n"
                       ));
            sm_dwProtocols |= ISRPC_OVER_SPX;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "ncacn_spx is not supported. Error (%ld).\n",
                       rpcStatus ));
            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled()) {

            rpcStatus = AddSecurity();
        }
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverSpx() returns %d\n",
                   rpcStatus));
    }

    return ( rpcStatus);

} // ISRPC::DynamicBindOverSpx()





DWORD
ISRPC::SetSecurityDescriptor( VOID)
/*++

Routine Description:

    This member function builds the security descriptor used by RPC module.
    The security descriptor denies everybody the ability to change/see anything
    connected to the DACL and allows everybody to read from/write to the pipe.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD dwError = NO_ERROR;
    BOOL  fSuccess = FALSE;
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID psidWorld = NULL;
    PSID psidLocalSystem = NULL;
    BYTE *pbBuffer = NULL;
    DWORD cbAcl = 0;

    InitializeSecurityDescriptor(&sm_sid,
                                 SECURITY_DESCRIPTOR_REVISION );

    //
    // Create the "WORLD" sid
    //
    if ( !AllocateAndInitializeSid( &siaWorld,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0,0,0,0,0,0,0,
                                    &psidWorld ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "AllocateAndInitializeSid failed : 0x%x\n",
                   GetLastError()));
        goto cleanup;
    }

    //
    // Calculate the size of the ACL that will hold the the ACESS_DENIED and ACCESS_ALLOW ace
    // [ripped off from MSDN docs]
    //
   cbAcl = sizeof(ACL) +
           sizeof( ACCESS_ALLOWED_ACE ) +
           sizeof( ACCESS_DENIED_ACE )  +
           2*GetLengthSid(psidWorld) -
           2*sizeof(DWORD) ;

    if ( ! ( pbBuffer = new BYTE[cbAcl] ) )
    {
        goto cleanup;
    }

    sm_pACL = (PACL) pbBuffer;

    //
    // Initialize the ACL
    //
    if ( !InitializeAcl( sm_pACL,
                         cbAcl,
                         ACL_REVISION ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "InitializeAcl failed : 0x%x\n",
                   GetLastError()));
        goto cleanup;
    }

    //
    // Add the Access Denied ACE; this has to be first in the list to make sure
    // that any attempt to muck with the DACL will be disallowed
    //
    if ( !AddAccessDeniedAce( sm_pACL,
                              ACL_REVISION,
                              WRITE_DAC | DELETE | WRITE_OWNER,
                              psidWorld ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "AddAccessDeniedAce failed : 0x%x\n",
                   GetLastError()));
        goto cleanup;
    }

    //
    // Add the Access Allowed ACE
    //
    if ( !AddAccessAllowedAce( sm_pACL,
                               ACL_REVISION,
                               FILE_ALL_ACCESS,
                               psidWorld ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "AddAccessAllowedAce failed : 0x%x\n",
                   GetLastError()));
        goto cleanup;
    }

    //
    // Set (no) group & owner for the security descriptor
    //
    if ( !SetSecurityDescriptorOwner( &sm_sid,
                                      NULL,
                                      FALSE ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "SetsecurityDescriptorOwner failed : 0x%x\n",
                   GetLastError()));
        goto cleanup;
    }


    if ( !SetSecurityDescriptorGroup( &sm_sid,
                                      NULL,
                                      FALSE ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "SetsecurityDescriptorGroup failed : 0x%x\n",
                   GetLastError()));
        goto cleanup;
    }

    if ( !( fSuccess = SetSecurityDescriptorDacl ( &sm_sid,
                                                   TRUE,          // Dacl present
#if 1
                                                   sm_pACL,
#else
                                                   NULL,          // NULL Dacl
#endif
                                                   FALSE ) ) )    // Not defaulted
    {
        DBGPRINTF((DBG_CONTEXT,
                   "SetSecurityDescriptorDacl failed : 0x%x\n",
                   GetLastError()));
    }


cleanup:


    if ( psidWorld )
    {
        FreeSid( psidWorld );
    }

    if (!fSuccess)
    {

        dwError = GetLastError();

        if ( pbBuffer )
        {
            delete [] pbBuffer;
            sm_pACL = NULL;
        }

        //
        // free up security discriptor memory and set it to NULL.
        //
        memset( (PVOID ) &sm_sid,  0, sizeof(sm_sid));
    }

    return( dwError );

} // ISRPC::SetSecurityDescriptor()




DWORD
ISRPC::AddSecurity(
    VOID
    )
/*++

Routine Description:

    This member function adds security support provider over RPC.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD rpcStatus;

    //
    // Register for authentication using WinNT.
    //

    rpcStatus = RpcServerRegisterAuthInfo(
                    (unsigned char * ) NULL, // app name to security provider
                    RPC_C_AUTHN_WINNT,       // Auth package ID.
                    NULL,                    // RPC_C_AUTHN_WINNT ==> NULL
                    NULL                     // args ptr for authn function.
                    );

    if ( rpcStatus == RPC_S_OK) {

        sm_fSecurityEnabled = TRUE;
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "AddSecurity() returns Error %u\n",
                   rpcStatus));
    }

    //
    // Hide the failure that occurs when the server is locked 
    // down and does not have the network client installed. This will
    // cause performance counters to fail.
    //
    if( rpcStatus == RPC_S_UNKNOWN_AUTHN_SERVICE )
    {
        DBGWARN(( DBG_CONTEXT,
                  "RpcServerRegisterAuthInfo failed with "
                  "RPC_S_UNKNOWN_AUTHN_SERVICE. Some features, such as "
                  "performance counters, may not function.\n"
                  ));

        rpcStatus = RPC_S_OK;
    }

    return (rpcStatus);
} // ISRPC::AddSecurity()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\iissvc.cxx ===
/*++


   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        iissvc.cxx

   Abstract:

        Defines the IIS_SERVICE class

    FILE HISTORY:
           MuraliK       15-Nov-1994 Created.
           CezaryM       11-May-2000 Added events:
                           started/stopped/paused/resumed
--*/



#include "tcpdllp.hxx"

#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"
#include <imd.h>
#include <ole2.h>
#include <inetsvcs.h>
#include <issched.hxx>
#include <pwsdata.hxx>

#include "reftrce2.h"

/************************************************************
 *    Symbolic Constants
 ************************************************************/


//
//  What we assume to be the last winsock error
//
#define WSA_MAX_ERROR   (WSABASEERR + 3000)

//
//  For socket errors, we return the numeric socket error
//

#define SOCK_ERROR_STR_W        L"Socket error %d"
#define SOCK_ERROR_STR_A        "Socket error %d"

#define LM_PREFIX               "/" IIS_MD_LOCAL_MACHINE_PATH "/"
#define LM_PREFIX_CCH           sizeof(LM_PREFIX) - sizeof(CHAR)


//
// The time indicating how long it will take for IIS to start up a service
//  <-- Service controller will wait for this duration before telling user
//  that there is some problem.
// For PDC 1996, a hacked value of 90 seconds used.
// The new value of 30 seconds is plugged in on 7/7/97
//

# define IIS_SERVICE_START_WAIT_HINT_SECONDS            (30) // 30 seconds
# define IIS_SERVICE_START_WAIT_HINT                    (IIS_SERVICE_START_WAIT_HINT_SECONDS * 1000) // 30 seconds
# define IIS_SERVICE_START_WAIT_HINT_EXTENDED           (IIS_SERVICE_START_WAIT_HINT * 4) // 2 minutes

# define IIS_SERVICE_START_INDICATOR_INTERVAL           (IIS_SERVICE_START_WAIT_HINT_EXTENDED / 2) // 1 minute
# define IIS_SERVICE_START_INDICATOR_INTERVAL_SECONDS   (IIS_SERVICE_START_INDICATOR_INTERVAL / 1000)

# define MAX_NUMBER_OF_START_HINT_REPETITIONS 200  // 50 minutes

//
// MS_SERVICE_SHUTDOWN_INDICATOR_TIME_INTERVAL
//  - specifies the time interval in milli-seconds for the interval
//    to notify the service controller that a service is shutting down.
//
# define MS_SERVICE_SHUTDOWN_INDICATOR_TIME_INTERVAL \
            (SERVICE_STOP_WAIT_HINT/2)



#ifdef _KNFOCOMM
//
//  List of "known" services that use knfocomm -
//  This is needed to break deadlocks between infocomm & knfocomm..
//

static char* rgKnfoServices[] = {
    TEXT("pop3svc"),
    TEXT("imap4svc")
};

static DWORD gNumKnfoServices = 3;
#endif // _KNFOCOMM


//
//  Deferred metabase change notify
//

VOID
WINAPI
DeferredMDChange(
    PVOID pv
    );

BOOL
I_StopInstanceEndpoint( PVOID                 pvContext1,
                        PVOID                 pvContext2,
                        IIS_SERVER_INSTANCE * pInstance );

VOID
WINAPI
ServiceShutdownIndicator( VOID * pSvcContext);


//
// Critical section used for locking the list of IIS_SERVICE objects
//      during insertion and deletion
//

CRITICAL_SECTION  IIS_SERVICE::sm_csLock;
LIST_ENTRY        IIS_SERVICE::sm_ServiceInfoListHead;
BOOL              IIS_SERVICE::sm_fInitialized = FALSE;
PISRPC            IIS_SERVICE::sm_isrpc = NULL;
IUnknown *        IIS_SERVICE::sm_MDObject = NULL;
IUnknown *        IIS_SERVICE::sm_MDNseObject = NULL;

#if SERVICE_REF_TRACKING
//
//  Ref count trace log size
//
#define C_SERVICE_REFTRACES         400
#define C_LOCAL_SERVICE_REFTRACES    40
#endif // SERVICE_REF_TRACKING

//
PTRACE_LOG IIS_SERVICE::sm_pDbgRefTraceLog = NULL;


/************************************************************
 *    Functions
 ************************************************************/

DWORD
InitMetadataDCom(
    PVOID Context,
    PVOID NseContext
    );

//
// LOCAL Functions
//

extern MIME_MAP * g_pMimeMap;
#define MAX_ADDRESSES_SUPPORTED           20
#define SIZEOF_IP_SEC_LIST( IPList )      (sizeof(INET_INFO_IP_SEC_LIST) + \
                                           (IPList)->cEntries *        \
                                           sizeof(INET_INFO_IP_SEC_ENTRY))

BOOL    g_fIgnoreSC = FALSE;


/************************************************************
 *    Functions
 ************************************************************/

//
// These 2 functions cannot be inline as they reference sm_csLock
// which is a static non-exported member of IIS_SERVICE
// Having them inline causes build to break when compiled with /Od
//

VOID
IIS_SERVICE::AcquireGlobalLock( )
{
    EnterCriticalSection(&sm_csLock);
}


VOID
IIS_SERVICE::ReleaseGlobalLock( )
{
    LeaveCriticalSection(&sm_csLock);
}


IIS_SERVICE::IIS_SERVICE(
    IN  LPCSTR                           pszServiceName,
    IN  LPCSTR                           pszModuleName,
    IN  LPCSTR                           pszRegParamKey,
    IN  DWORD                            dwServiceId,
    IN  ULONGLONG                        SvcLocId,
    IN  BOOL                             MultipleInstanceSupport,
    IN  DWORD                            cbAcceptExRecvBuffer,
    IN  ATQ_CONNECT_CALLBACK             pfnConnect,
    IN  ATQ_COMPLETION                   pfnConnectEx,
    IN  ATQ_COMPLETION                   pfnIoCompletion
    )
/*++
    Description:

        Contructor for IIS_SERVICE class.
        This constructs a new service info object for the service specified.

    Arguments:

        pszServiceName - name of the service to be created.

        pszModuleName - name of the module for loading string resources.

        pszRegParamKey - fully qualified name of the registry key that
            contains the common service data for this server

        dwServiceId - DWORD containing the bitflag id for service.

        SvcLocId - Service locator id

        MultipleInstanceSupport - Does this service support multiple instances

        cbAcceptExRecvBuffer, pfnConnect, pfnConnectEx, pfnIoCompletion
             - parameters for ATQ Endpoint

    On success it initializes all the members of the object,
     inserts itself to the global list of service info objects and
     returns with success.

    Note:
        The caller of this function should check the validity by
        invoking the member function IsValid() after constructing
        this object.

--*/
:
    m_state               ( BlockStateInvalid),  // state is invalid at start
    m_pMimeMap            ( g_pMimeMap),
    m_dwServiceId         ( dwServiceId),
    m_strServiceName      ( pszServiceName),
    m_strServiceComment   ( ),
    m_strModuleName       ( pszModuleName),
    m_strParametersKey    ( pszRegParamKey),
    m_SvcLocId            ( SvcLocId ),
    m_EventLog            ( pszServiceName ),
    m_fSocketsInitialized ( FALSE ),
    m_fIpcStarted         ( FALSE ),
    m_fSvcLocationDone    ( FALSE ),
    m_nInstance           ( 0),
    m_nStartedInstances   ( 0),
    m_maxInstanceId       ( 1),
    m_dwDownlevelInstance ( 1),
    m_reference           ( 1),
    m_pDbgRefTraceLog     ( NULL),
    m_hShutdownEvent      ( NULL),
    m_fMultiInstance      ( MultipleInstanceSupport ),
    m_fEnableSvcLocation  ( INETA_DEF_ENABLE_SVC_LOCATION ),
    m_fIsDBCS             ( FALSE ),
    //
    // Initialize ATQ callbacks
    //
    m_pfnConnect         ( pfnConnect),
    m_pfnConnectEx       ( pfnConnectEx),
    m_pfnIoCompletion    ( pfnIoCompletion),
    m_cbRecvBuffer       ( cbAcceptExRecvBuffer),
    m_dwShutdownScheduleId( 0),
    m_nShutdownIndicatorCalls  (0)
{
    MB    mb( (IMDCOM*) QueryMDObject() );
    DWORD errInit = NO_ERROR;

    //
    // Initialize endpoint list
    //

    InitializeListHead( &m_EndpointListHead );
    InitializeListHead( &m_InstanceListHead );

    INITIALIZE_CRITICAL_SECTION( &m_lock );

#if SERVICE_REF_TRACKING
    m_pDbgRefTraceLog = CreateRefTraceLog(C_LOCAL_SERVICE_REFTRACES, 0);
#endif // SERVICE_REF_TRACKING

    //
    //  Initialize the service metapath
    //

    strcpy( m_achServiceMetaPath, "/" IIS_MD_LOCAL_MACHINE_PATH "/" );
    strcat( m_achServiceMetaPath, QueryServiceName() );
    strcat( m_achServiceMetaPath, "/" );

    DBG_ASSERT( strlen(m_achServiceMetaPath) < sizeof(m_achServiceMetaPath) );

    //
    //  Read the downlevel instance
    //

    if ( mb.Open( QueryMDPath() ) )
    {
        mb.GetDword( "",
                     MD_DOWNLEVEL_ADMIN_INSTANCE,
                     IIS_MD_UT_SERVER,
                     0xffffffff,                // default value
                     &m_dwDownlevelInstance
                     );
        mb.Close( );
    }
    else
    {
        errInit = GetLastError();
    }

    //
    //  Is this a DBCS locale?
    //

    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    m_fIsDBCS =  ((wPrimaryLangID == LANG_JAPANESE) ||
                  (wPrimaryLangID == LANG_CHINESE)  ||
                  (wPrimaryLangID == LANG_KOREAN) );


    if ( !m_EventLog.Success() ) {

        DBGPRINTF(( DBG_CONTEXT,
                    " Eventlog not initialized\n"));

        if ( GetLastError() != ERROR_ACCESS_DENIED )
        {
            DBG_ASSERT( m_state != BlockStateActive);
            errInit = GetLastError();

            //
            //  Skip anything else that might fail since we don't have an
            //  event log object
            //

            goto Exit;
        }
    }

    //
    //  If we failed to open the service path in the metabase above, bail
    //  out of the initialization
    //

    if ( errInit )
    {
        const CHAR * apsz[1];
        apsz[0] = QueryMDPath();

        LogEvent( INET_SVC_INVALID_MB_PATH,
                  1,
                  (const CHAR **) apsz,
                  errInit );

        goto Exit;
    }

    //
    // Get module name
    //

    m_hModule = GetModuleHandle( pszModuleName);
    if ( m_hModule == NULL ) {

        CHAR * apsz[1];

        errInit = GetLastError();

        apsz[0] = (PCHAR)pszModuleName;
        m_EventLog.LogEvent( INET_SVC_GET_MODULE_FAILED,
                           1,
                           (const CHAR**)apsz,
                           errInit );
        DBG_ASSERT( m_state != BlockStateActive);

        goto Exit;
    }

    //
    // Init others
    //

    if ( MultipleInstanceSupport ) {
        m_strServiceComment.Copy(DEF_MULTI_SERVER_COMMENT_A);
    }

    //
    // Create pending shutdown event
    //
    
    m_hPendingShutdownEvent = CreateEvent( NULL,
                                           FALSE,
                                           FALSE,
                                           NULL );
    if ( m_hPendingShutdownEvent == NULL )
    {
        errInit = GetLastError();
        goto Exit;
    }

Exit:
    //
    // Add ourself to the list - Note we must always get on this list as the
    // destructor assumes this.
    //

    AcquireGlobalLock( );

    InsertHeadList( & sm_ServiceInfoListHead, &m_ServiceListEntry );

    if ( errInit == NO_ERROR )
    {
        //
        // put service information into metabase
        //

        AdvertiseServiceInformationInMB( );

        //
        // we're on. now set the state to be active!
        //

        m_state = BlockStateActive;
    }

    ReleaseGlobalLock( );

    //
    //  Initialize the service status structure.
    //

    m_svcStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    m_svcStatus.dwCurrentState            = SERVICE_STOPPED;
    m_svcStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                              | SERVICE_ACCEPT_PAUSE_CONTINUE
                                              | SERVICE_ACCEPT_SHUTDOWN;
    m_svcStatus.dwWin32ExitCode           = errInit;
    m_svcStatus.dwServiceSpecificExitCode = errInit;
    m_svcStatus.dwCheckPoint              = 0;
    m_svcStatus.dwWaitHint                = 0;

    return;

} // IIS_SERVICE::IIS_SERVICE()



IIS_SERVICE::~IIS_SERVICE( VOID)
/*++

    Description:

        Cleanup the TsvcInfo object. If the service is not already
         terminated, it terminates the service before cleanup.

    Arguments:
        None

    Returns:
        None


--*/
{

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((DBG_CONTEXT,"~IIS_SERVICE: nRef %d nInstances %d\n",
            m_reference, m_nInstance));
    }

    DBG_ASSERT( m_reference == 0 );
    DBG_ASSERT( IsListEmpty(&m_InstanceListHead) );
    DBG_ASSERT( IsListEmpty(&m_EndpointListHead) );
    DBG_ASSERT( m_dwShutdownScheduleId == 0);

    if ( m_hShutdownEvent != NULL ) {
        DBG_REQUIRE(CloseHandle(m_hShutdownEvent));
        m_hShutdownEvent = NULL;
    }

    if ( m_hPendingShutdownEvent != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_hPendingShutdownEvent ) );
        m_hPendingShutdownEvent = NULL;
    }

    //
    // remove from global list
    //

    AcquireGlobalLock( );
    RemoveEntryList( &m_ServiceListEntry );
    ReleaseGlobalLock( );

#if SERVICE_REF_TRACKING
    DestroyRefTraceLog( m_pDbgRefTraceLog );
#endif // SERVICE_REF_TRACKING

    DeleteCriticalSection( &m_lock );
} // IIS_SERVICE::~IIS_SERVICE()



DWORD
IIS_SERVICE::StartServiceOperation(
    IN  PFN_SERVICE_CTRL_HANDLER         pfnCtrlHandler,
    IN  PFN_SERVICE_SPECIFIC_INITIALIZE  pfnInitialize,
    IN  PFN_SERVICE_SPECIFIC_CLEANUP     pfnCleanup
    )
/*++
    Description:

        Starts the operation of service instantiated in the given
           Service Info Object.


    Arguments:

        pfnCtrlHandler
            pointer to a callback function for handling dispatch of
            service controller requests. A separate function is required
            since Service Controller call back function does not send
            context information.

        pfnInitialize
            pointer to a callback function implemented by the service DLL;
            the callback is responsible for all ServiceSpecific initializations

        pfnCleanup
            pointer to a callback function implemented by the service DLL;
            the callback is responsible for all ServiceSpecific Cleanups

    Returns:

        NO_ERROR on success and Win32 error code if any failure.
--*/
{

    DWORD err;
    DWORD cbBuffer;
    BOOL  fInitCalled = FALSE;

    DBG_ASSERT((pfnInitialize != NULL) && (pfnCleanup != NULL));

    if ( !IsActive()) {

        //
        // Not successfully initialized.
        //

        DBGPRINTF((DBG_CONTEXT,
            "Service not ready. Failing StartServiceOperation\n"));
        return ( ERROR_NOT_READY );
    }

    //
    //  Create shutdown event.
    //

    DBG_ASSERT(m_hShutdownEvent == NULL);
    m_hShutdownEvent = CreateEvent( NULL,           //  lpsaSecurity
                                    TRUE,           //  fManualReset
                                    FALSE,          //  fInitialState
                                    TsIsWindows95() ?
                                        PWS_SHUTDOWN_EVENT : NULL
                                    );

    if( m_hShutdownEvent == NULL ) {

        err = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
                    "InitializeService(): Cannot create shutdown event,"
                     " error %lu\n", err ));

        goto Cleanup;
    }

    if ( !g_fIgnoreSC ) {
        m_hsvcStatus = RegisterServiceCtrlHandler(
                            QueryServiceName(),
                            pfnCtrlHandler
                            );

        //
        //  Register the Control Handler routine.
        //

        if( m_hsvcStatus == NULL_SERVICE_STATUS_HANDLE ) {

            err = GetLastError();

            DBGPRINTF( ( DBG_CONTEXT,
                        "cannot connect to register ctrl handler, error %lu\n",
                         err )
                     );


            goto Cleanup;
        }

    }

    //
    //  Indicate to the service that we are starting up,
    //  Update the service status.
    //

    err = UpdateServiceStatus( SERVICE_START_PENDING,
                               NO_ERROR,
                               1,
                               IIS_SERVICE_START_WAIT_HINT
                               );

    if( err != NO_ERROR ) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "StartServiceOperation(): cannot update service status,"
                    " error %lu\n",
                    err )
                  );

        goto Cleanup;
    }

    //
    //  Initialize the various service specific components.
    //

    m_dwNextSCMUpdateTime = GetCurrentTimeInSeconds() + IIS_SERVICE_START_WAIT_HINT_SECONDS / 2;
    m_dwStartUpIndicatorCalls = 0;
    m_dwClientStartActivityIndicator = 1;
    
    if ( pfnInitialize != NULL ) {

        err = ( *pfnInitialize)( this);
        fInitCalled = TRUE;

        if( err != NO_ERROR ) {

            DBGPRINTF( ( DBG_CONTEXT,
                       " Initialization of service failed with %d\n",
                        err));

            goto Cleanup;
        }
    }

    //
    //  We are done with all initializatios, Update the service status.
    //


    err = UpdateServiceStatus( SERVICE_RUNNING,
                               NO_ERROR,
                               0,
                               0 );

    if( err != NO_ERROR ) {
        DBGPRINTF( ( DBG_CONTEXT, "cannot update service status, error %lu\n",
                     err )
                );

        goto Cleanup;
    }

    //
    //  Wait for the shutdown event.
    //

    DBGPRINTF( ( DBG_CONTEXT,
                 "IIS_SERVICE(%08p) %s - Waiting for ShutDown Event ...\n",
                 this, QueryServiceName()
                 ));

#if 0
    err = WaitForSingleObject( m_hShutdownEvent,
                               INFINITE );

    if ( err != WAIT_OBJECT_0) {

        //
        // Error. Unable to wait for single object.
        //

        DBGPRINTF( ( DBG_CONTEXT,
                    "Wait for single object failed with Error %lu\n",
                    err )
                 );
    }
#else

    while ( TRUE ) {

        MSG msg;

        //
        // Need to do MsgWait instead of WaitForSingleObject
        // to process windows msgs.  We now have a window
        // because of COM.
        //

        err = MsgWaitForMultipleObjects( 1,
                                         &m_hShutdownEvent,
                                         FALSE,
                                         INFINITE,
                                         QS_ALLINPUT );

        if ( err == WAIT_OBJECT_0 ) {
            break;
        }

        while ( PeekMessage( &msg,
                             NULL,
                             0,
                             0,
                             PM_REMOVE ))
        {
            DispatchMessage( &msg );
        }
    }
    
#endif

    err = NO_ERROR;

    //
    //  Stop time.  Tell the Service Controller that we're stopping,
    //  then terminate the various service components.
    //

    UpdateServiceStatus( SERVICE_STOP_PENDING,
                         0,
                         1,
                         SERVICE_STOP_WAIT_HINT );

Cleanup:

    if ( fInitCalled && (pfnCleanup != NULL) ) {

        //
        // 1. Register a scheduled work item for periodic update to the
        //    Service Controller while shutdown is happening in this thread
        //    (Reason: Shutdown takes far longer time
        //          than SERVICE_STOP_WAIT_HINT)
        //

        m_nShutdownIndicatorCalls = 0;

        DBG_ASSERT( m_dwShutdownScheduleId == 0);
        m_dwShutdownScheduleId =
            ScheduleWorkItem( ServiceShutdownIndicator,
                              this,
                              MS_SERVICE_SHUTDOWN_INDICATOR_TIME_INTERVAL,
                              TRUE );     // Periodic

        if ( m_dwShutdownScheduleId == 0) {
            DBGPRINTF(( DBG_CONTEXT,
                        "ScheduleShutdown for Service(%s) failed."
                        " Error = %d\n",
                        QueryServiceName(),
                        GetLastError()
                        ));
        }

        //
        // 2. Stop all endpoints for the service
        //

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "IIS_SERVICE(%08p) Stopping all endpoints for %s\n",
                        this, QueryServiceName()
                        ));
        }

        DBG_REQUIRE( EnumServiceInstances( NULL, NULL,
                                           I_StopInstanceEndpoint)
                     );

        //
        // 3. Cleanup partially initialized modules
        //

        DWORD err1 = ( *pfnCleanup)( this);


        // calls MB.Save so that next MB.Save will be fast
        // and will not cause delay during shutdown
        {
            DBGPRINTF(( DBG_CONTEXT,"[IIS_SERVICE::StartServiceOperation] Pre-Saving Metabase\n" ));

            MB     mb( (IMDCOM*) IIS_SERVICE::QueryMDObject() );
            mb.Save();
        }

        DBGPRINTF((DBG_CONTEXT,"Cleanup done\n"));

        if ( err1 != NO_ERROR )
        {
            if ( err1 != ERROR_IO_PENDING )
            {
                //
                // Compound errors possible
                //

                if ( err != NO_ERROR) {
    
                    DBGPRINTF( ( DBG_CONTEXT,
                               " Error %d occured during cleanup of service %s\n",
                               err1, QueryServiceName()));
                }
            }
        }
        
        if ( err1 == ERROR_IO_PENDING )
        {
            //
            // Shutdown is not complete yet.  Wait for it to complete
            //
            
            WaitForSingleObject( m_hPendingShutdownEvent, INFINITE );
        }

        //
        // 4. If present, remove the scheduled work item
        //
        if ( m_dwShutdownScheduleId != 0) {
            RemoveWorkItem( m_dwShutdownScheduleId);
            m_dwShutdownScheduleId = 0;
        }
    }

    //
    //  If we managed to actually connect to the Service Controller,
    //  then tell it that we're stopped.
    //

    if( m_hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
        UpdateServiceStatus( SERVICE_STOPPED,
                             err,
                             0,
                             0 );
    }

    return ( err);

} // IIS_SERVICE::StartServiceOperation()

VOID
IIS_SERVICE::IndicateShutdownComplete(
    VOID
)
/*++

Routine Description:

    Used by services which return ERROR_IO_PENDING in their TerminateService
    routines.  In this case, they should use this method to indicate
    that shutdown is complete.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( m_hPendingShutdownEvent )
    {
        SetEvent( m_hPendingShutdownEvent );
    }
}


DWORD
IIS_SERVICE::UpdateServiceStatus(
        IN DWORD dwState,
        IN DWORD dwWin32ExitCode,
        IN DWORD dwCheckPoint,
        IN DWORD dwWaitHint
        )
/*++
    Description:

        Updates the local copy status of service controller status
         and reports it to the service controller.

    Arguments:

        dwState - New service state.

        dwWin32ExitCode - Service exit code.

        dwCheckPoint - Check point for lengthy state transitions.

        dwWaitHint - Wait hint for lengthy state transitions.

    Returns:

        NO_ERROR on success and returns Win32 error if failure.
        On success the status is reported to service controller.

--*/
{
    m_svcStatus.dwCurrentState  = dwState;
    m_svcStatus.dwWin32ExitCode = dwWin32ExitCode;
    m_svcStatus.dwCheckPoint    = dwCheckPoint;
    m_svcStatus.dwWaitHint      = dwWaitHint;

    return ReportServiceStatus();

} // IIS_SERVICE::UpdateServiceStatus()



DWORD
IIS_SERVICE::ReportServiceStatus( VOID)
/*++
    Description:

        Wraps the call to SetServiceStatus() function.
        Prints the service status data if need be

    Arguments:

        None

    Returns:

        NO_ERROR if successful. other Win32 error code on failure.
        If successfull the new status has been reported to the service
         controller.
--*/
{
    DWORD err = NO_ERROR;

    IF_DEBUG( DLL_SERVICE_INFO)   {

          DBGPRINTF(( DBG_CONTEXT, "dwServiceType             = %08lX\n",
                     m_svcStatus.dwServiceType ));

          DBGPRINTF(( DBG_CONTEXT, "dwCurrentState            = %08lX\n",
                     m_svcStatus.dwCurrentState ));

          DBGPRINTF(( DBG_CONTEXT, "dwControlsAccepted        = %08lX\n",
                     m_svcStatus.dwControlsAccepted ));

          DBGPRINTF(( DBG_CONTEXT, "dwWin32ExitCode           = %08lX\n",
                     m_svcStatus.dwWin32ExitCode ));

          DBGPRINTF(( DBG_CONTEXT, "dwServiceSpecificExitCode = %08lX\n",
                     m_svcStatus.dwServiceSpecificExitCode ));

          DBGPRINTF(( DBG_CONTEXT, "dwCheckPoint              = %08lX\n",
                     m_svcStatus.dwCheckPoint ));

          DBGPRINTF(( DBG_CONTEXT, "dwWaitHint                = %08lX\n",
                     m_svcStatus.dwWaitHint ));
    }

    if ( !g_fIgnoreSC ) {

        IF_DEBUG(DLL_SERVICE_INFO) {
            DBGPRINTF(( DBG_CONTEXT,
                   " Setting Service Status for %s to %d\n",
                   QueryServiceName(), m_svcStatus.dwCurrentState)
                  );
        }

        if( !SetServiceStatus( m_hsvcStatus, &m_svcStatus ) ) {

            err = GetLastError();
        }

    } else {

        err = NO_ERROR;
    }

    return err;
}   // IIS_SERVICE::ReportServiceStatus()



VOID
IIS_SERVICE::ServiceCtrlHandler (
                    IN DWORD dwOpCode
                    )
/*++
    Description:

        This function received control requests from the service controller.
        It runs in the context of service controller's dispatcher thread and
        performs the requested function.
        ( Note: Avoid time consuming operations in this function.)

    Arguments:

        dwOpCode
            indicates the requested operation. This should be
            one of the SERVICE_CONTROL_* manifests.


    Returns:
        None. If successful, then the state of the service might be changed.

    Note:
        if an operation ( especially SERVICE_CONTROL_STOP) is very lengthy,
         then this routine should report a STOP_PENDING status and create
         a worker thread to do the dirty work. The worker thread would then
         perform the necessary work and for reporting timely wait hints and
         final SERVICE_STOPPED status.

    History:
        KeithMo     07-March-1993  Created
        MuraliK     15-Nov-1994    Generalized it for all services.
--*/
{
    //
    //  Interpret the opcode and let the worker functions update the state.
    //  Also let the workers to update service state as appropriate
    //

    switch( dwOpCode ) {

    case SERVICE_CONTROL_INTERROGATE :
        InterrogateService();
        break;

    case SERVICE_CONTROL_STOP :
    case SERVICE_CONTROL_SHUTDOWN :
        StopService();
        break;

    case SERVICE_CONTROL_PAUSE :
        PauseService();
        break;

    case SERVICE_CONTROL_CONTINUE :
        ContinueService();
        break;


    default :
        DBGPRINTF(( DBG_CONTEXT, "Unrecognized Service Opcode %lu\n",
                     dwOpCode ));
        break;
    }

    return;
}   // IIS_SERVICE::ServiceCtrlHandler()



VOID
IIS_SERVICE::InterrogateService( VOID )
/*++
    Description:

        This function interrogates with the service status.
        Actually, nothing needs to be done here; the
        status is always updated after a service control.
        We have this function here to provide useful
        debug info.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     15-Nov-1994 Ported to Tcpsvcs.dll
--*/
{
    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "Interrogating service status for %s\n",
                   QueryServiceName())
                 );
    }

    ReportServiceStatus();

    return;

}   // IIS_SERVICE::InterrogateService()


VOID
IIS_SERVICE::PauseService( VOID )
/*++
    Description:

        This function pauses the service. When the service is paused,
        no new user sessions are to be accepted, but existing connections
        are not effected.

        This function must update the SERVICE_STATUS::dwCurrentState
         field before returning.

    Returns:

        None. If successful the service is paused.

--*/
{
    PLIST_ENTRY entry;
    IIS_SERVER_INSTANCE *instance;
    DWORD status;

    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "pausing service %s\n",
                   QueryServiceName())
                 );
    }

    //
    // Scan all installed instances. For each instance, save its current
    // state (so we can retrieve it in ContinueService()) and, if the
    // current state is "started", then pause the instance.
    //

    AcquireServiceLock( TRUE );

    for( entry = m_InstanceListHead.Flink ;
         entry != &m_InstanceListHead ;
         entry = entry->Flink ) {

        instance = CONTAINING_RECORD(
                       entry,
                       IIS_SERVER_INSTANCE,
                       m_InstanceListEntry
                       );

        instance->SaveServerState();

        if( instance->QueryServerState() == MD_SERVER_STATE_STARTED ) {
            status = instance->PauseInstance();
            DBG_ASSERT( status == NO_ERROR );
        }

    }

    ReleaseServiceLock( TRUE );

    //
    // Set the *service* state to paused.
    //

    m_svcStatus.dwCurrentState = SERVICE_PAUSED;
    ReportServiceStatus();

    return;
}   // IIS_SERVICE::PauseService()



VOID
IIS_SERVICE::ContinueService( VOID )
/*++

    Description:
        This function restarts ( continues) a paused service. This
        will return the service to the running state.

        This function must update the m_svcStatus.dwCurrentState
         field to running mode before returning.

    Returns:
        None. If successful then the service is running.

--*/
{
    PLIST_ENTRY entry;
    IIS_SERVER_INSTANCE *instance;
    DWORD status;

    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "continuing service %s\n",
                   QueryServiceName())
                 );
    }

    //
    // Scan all installed instances. For each instance, if its current
    // state is "paused" and its saved state is "running", then we know
    // the instanced was paused in PauseService(), so continue it.
    //

    AcquireServiceLock( TRUE );

    for( entry = m_InstanceListHead.Flink ;
         entry != &m_InstanceListHead ;
         entry = entry->Flink ) {

        instance = CONTAINING_RECORD(
                       entry,
                       IIS_SERVER_INSTANCE,
                       m_InstanceListEntry
                       );

        if( instance->QueryServerState() == MD_SERVER_STATE_PAUSED &&
            instance->QuerySavedState() == MD_SERVER_STATE_STARTED ) {
            status = instance->ContinueInstance();
            DBG_ASSERT( status == NO_ERROR );
        }

    }

    ReleaseServiceLock( TRUE );

    //
    // Set the *service* state to running.
    //

    m_svcStatus.dwCurrentState = SERVICE_RUNNING;
    ReportServiceStatus();

    return;
}   // IIS_SERVICE::ContinueService()



VOID
IIS_SERVICE::StopService( VOID )
/*++
    Description:

        This function performs the shutdown on a service.
        This is called during system shutdown.

        This function is time constrained. The service controller gives a
        maximum of 20 seconds for shutdown for all active services.
         Only timely operations should be performed in this function.

        What we really do in IIS is, this thread sets the Shutdown Event
         inside the IIS_SERVICE structure. The shutdown event will wake
         the intial thread that started this service (see
          IIS_SERVICE::StartServiceOperation()) => some other thread does
          the bulk of cleanup operations.

    Returns:

        None. If successful, the service is shutdown.
--*/
{
    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "shutting down service %s\n",
                   QueryServiceName())
                 );
    }

    m_svcStatus.dwCurrentState = SERVICE_STOP_PENDING;
    m_svcStatus.dwCheckPoint   = 0;

    //
    // Update state before setting the event to wake up the waiting thread
    //

    ReportServiceStatus();
    
    DBG_REQUIRE( SetEvent( m_hShutdownEvent ));

    return;
} // IIS_SERVICE::StopService()



DWORD
IIS_SERVICE::InitializeSockets( VOID )
/*++

    Initializes Socket access.
    It is responsible for connecting to WinSock.

    Returns:

       NO_ERROR on success
       Otherwise returns a Win32 error code.

    Limitations:
       This is for a single thread and not mult-thread safe.
       This function should be called after initializing globals.

--*/
{

#ifndef ATQ_FORGOT_TO_CALL_WSASTARTUP
    return ( NO_ERROR);
#else

    DWORD dwError = NO_ERROR;

    WSADATA   wsaData;
    INT       serr;

    //
    //  Connect to WinSock
    //

    serr = WSAStartup( MAKEWORD( 2, 0), & wsaData);

    if( serr != 0 ) {

        SetServiceSpecificExitCode( ( DWORD) serr);
        dwError =  ( ERROR_SERVICE_SPECIFIC_ERROR);
        m_EventLog.LogEvent( INET_SVC_WINSOCK_INIT_FAILED,
                            0,
                            (const CHAR **) NULL,
                            serr);
    }

    m_fSocketsInitialized = ( dwError == NO_ERROR);

    return  ( dwError);
#endif //  ATQ_FORGOT_TO_CALL_WSASTARTUP
} // IIS_SERVICE::InitializeSockets()




DWORD
IIS_SERVICE::CleanupSockets( VOID)
/*++

    Cleansup the static information of sockets

    Returns:

       0 if no errors,
       non-zero error code for any socket errors

    Limitations:
       This is for a single thread and not mult-thread safe.
       This function should be called after initializing globals.

    Note:
       This function should be called after shutting down all
        active socket connections.

--*/
{
#ifndef ATQ_FORGOT_TO_CALL_WSASTARTUP
    return ( NO_ERROR);
#else
    DWORD  dwError = NO_ERROR;

    if ( m_fSocketsInitialized ) {

        INT serr = WSACleanup();

        if ( serr != 0) {

            SetServiceSpecificExitCode( ( DWORD) serr);
            dwError =  ( ERROR_SERVICE_SPECIFIC_ERROR);
        }
    }

    m_fSocketsInitialized = FALSE;

    return (dwError);
#endif //  ATQ_FORGOT_TO_CALL_WSASTARTUP

} // IIS_SERVICE::CleanupSockets()



# if 0

VOID
IIS_SERVICE::Print( VOID) const
{
    IIS_SERVICE::Print();

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing IIS_SERVICE object ( %08p) \n"
                " State = %u. SocketsInitFlag = %u\n"
                " ServiceStatusHandle = %08p. ShutDownEvent = %08p\n"
                " MimeMap = %08p\n"
             /* " InitFunction = %08x. CleanupFunction = %08x.\n" */
                ,
                this,
                m_state, m_fSocketsInitialized,
                m_hsvcStatus, m_hShutdownEvent,
                m_pMimeMap
                ));

    DBGPRINTF(( DBG_CONTEXT,
               " Printing IIS_SERVICE object (%08p)\n"
               " IpcStarted = %u\n"
               " EnableSvcLoc = %u; SvcLocationDone = %u\n"
               " Service Id = %u. Service Name = %s\n"
               " Module handle = %08p.  ModuleName = %s\n"
               " Reg Parameters Key = %s\n"
               ,
               this,
               m_fIpcStarted,
               m_fEnableSvcLocation, m_fSvcLocationDone,
               m_dwServiceId, m_strServiceName.QueryStr(),
               m_hModule, m_strModuleName.QueryStr(),
               m_strParametersKey.QueryStr()
               ));

    DBGPRINTF(( DBG_CONTEXT,
               " Eventlog      = %08p\n",
               &m_EventLog
               ));

    return;
}   // IIS_SERVICE::Print()

#endif // DBG



// Former inline functions that make of class static variables

BOOL
IIS_SERVICE::CheckAndReference(  )
{
    AcquireServiceLock( );
    if ( m_state == BlockStateActive ) {
        InterlockedIncrement( &m_reference );
        ReleaseServiceLock( );
        LONG lEntry = SHARED_LOG_REF_COUNT();
        LOCAL_LOG_REF_COUNT();
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT,"IIS_SERVICE ref count %ld (%ld)\n",
                       m_reference, lEntry));
        return(TRUE);
    }
    ReleaseServiceLock( );
    return(FALSE);
}


VOID
IIS_SERVICE::Dereference( )
{
    LONG lEntry = SHARED_EARLY_LOG_REF_COUNT();
    LOCAL_EARLY_LOG_REF_COUNT();

    LONG Reference = InterlockedDecrement( &m_reference );
    if ( 0 == Reference) {
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT,"deleting IIS_SERVICE %p (%ld)\n",
                       this, lEntry));
        delete this;
    } else {
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT,"IIS_SERVICE deref count %ld (%ld)\n",
                       Reference, lEntry));
    }
}


PISRPC
IIS_SERVICE::QueryInetInfoRpc( VOID )
{
    return sm_isrpc;
}


//
//  Static Functions belonging to IIS_SERVICE class
//

BOOL
IIS_SERVICE::InitializeServiceInfo( VOID)
/*++
    Description:

        This function initializes all necessary local data for IIS_SERVICE class

        Only the first initialization call does the initialization.
        Others return without any effect.

        Should be called from the entry function for DLL.

    Arguments:
        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( !IIS_SERVICE::sm_fInitialized) {

        //
        // The static data was Not Already initialized
        //

#if SERVICE_REF_TRACKING
        sm_pDbgRefTraceLog = CreateRefTraceLog(C_SERVICE_REFTRACES, 0);
        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((DBG_CONTEXT,"IIS_SERVICE RefTraceLog=%p\n",
                       sm_pDbgRefTraceLog));
        }
#endif // SERVICE_REF_TRACKING

        INITIALIZE_CRITICAL_SECTION( & IIS_SERVICE::sm_csLock);
        InitializeListHead( & IIS_SERVICE::sm_ServiceInfoListHead);
        IIS_SERVICE::sm_fInitialized = TRUE;

        IIS_SERVER_INSTANCE::Initialize();

        dwError = ISRPC::Initialize();

        if ( dwError != NO_ERROR) {
            SetLastError( dwError);
        }
    }

    return ( dwError == NO_ERROR);
} // IIS_SERVICE::InitializeServiceInfo()



VOID
IIS_SERVICE::CleanupServiceInfo(
                        VOID
                        )
/*++
    Description:

        Cleanup the data stored and services running.
        This function should be called only after freeing all the
         services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        None

    Returns:
        None

--*/
{
    RPC_STATUS rpcerr;

    DBG_REQUIRE( ISRPC::Cleanup() == NO_ERROR);

    //
    // Should we walk down the list of all services and stop them?
    //  Are should we expect the caller to have done that?  NYI
    //

    DBG_ASSERT( IsListEmpty(&sm_ServiceInfoListHead) );

    IIS_SERVER_INSTANCE::Cleanup();

    //
    //  The DLL is going away so make sure all of the threads get terminated
    //  here
    //

    DeleteCriticalSection( & sm_csLock);

#if SERVICE_REF_TRACKING
    if (sm_pDbgRefTraceLog != NULL)
    {
        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((DBG_CONTEXT,
                       "IIS_SERVICE: Closing RefTraceLog=%p\n",
                       sm_pDbgRefTraceLog));
        }
        DestroyRefTraceLog( sm_pDbgRefTraceLog );
    }
    sm_pDbgRefTraceLog = NULL;
#endif // SERVICE_REF_TRACKING

    IIS_SERVICE::sm_fInitialized = FALSE;

} // IIS_SERVICE::CleanupServiceInfo()



BOOL
IIS_SERVICE::InitializeServiceRpc(
                       IN LPCSTR        pszServiceName,
                       IN RPC_IF_HANDLE hRpcInterface
                       )
/*++
    Description:

        Initializes the rpc endpoint for the infocomm service.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.

    Returns:
        Win32 Error Code.

--*/
{

    DWORD dwError = NO_ERROR;
    PISRPC  pIsrpc = NULL;

    if(TsIsWindows95()) {
        DBGPRINTF( ( DBG_CONTEXT,
                    "IPC Win95 :  RPC servicing disabled \n"
                    ));

        dwError = NO_ERROR;
        goto exit;
    }

    DBG_ASSERT( pszServiceName != NULL);
    DBG_ASSERT( sm_isrpc == NULL );

    pIsrpc = new ISRPC( pszServiceName);

    if ( pIsrpc == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    //  bind over Named pipe only.
    //  If needed to bind over TCP, bind with bit flag ISRPC_OVER_TCPIP on.
    //

    dwError = pIsrpc->AddProtocol( ISRPC_OVER_TCPIP
                                  | ISRPC_OVER_NP | ISRPC_OVER_LPC
                                  );

    if( (dwError == RPC_S_DUPLICATE_ENDPOINT) ||
       (dwError == RPC_S_OK)
       ) {

        dwError = pIsrpc->RegisterInterface(hRpcInterface);
    }

    if ( dwError != RPC_S_OK ) {
        goto exit;
    }

    //
    //  Start the RPC listen thread
    //

    dwError = pIsrpc->StartServer( );

exit:

    if ( dwError != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "Cannot start RPC Server for %s, error %lu\n",
                   pszServiceName, dwError ));

        delete pIsrpc;
        SetLastError(dwError);
        return(FALSE);
    }

    sm_isrpc = pIsrpc;
    return(TRUE);

} // IIS_SERVICE::InitializeServiceRpc




IIS_SERVICE::CleanupServiceRpc(
                       VOID
                       )
/*++
    Description:

        Cleanup the data stored and services running.
        This function should be called only after freeing all the
         services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.


    Returns:
        Win32 Error Code.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( sm_isrpc == NULL ) {
        DBGPRINTF((DBG_CONTEXT,
            "no isrpc object to cleanup. Returning success\n"));
        return(TRUE);
    }

    (VOID) sm_isrpc->StopServer( );
    dwError = sm_isrpc->CleanupData();

    if( dwError != RPC_S_OK ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%08p) Cleanup returns %lu\n", sm_isrpc, dwError ));
        DBG_ASSERT( !"RpcServerUnregisterIf failure" );
        SetLastError( dwError);
    }

    delete sm_isrpc;
    sm_isrpc = NULL;

    return TRUE;
} // CleanupServiceRpc


BOOL
IIS_SERVICE::InitializeMetabaseComObject(
    VOID
    )
/*++
    Description:

        This function initializes the metabase object

    Arguments:
        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    HANDLE      hThreadHandle = NULL;
    DWORD       dwTemp;
    BOOL        fRet = FALSE;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Initializing metabase object\n"));
    }

    fRet = InitMetadataDCom( (PVOID)&IIS_SERVICE::sm_MDObject,
                             (PVOID)&IIS_SERVICE::sm_MDNseObject );

    if ( fRet )
    {
        fRet = InitializeMetabaseSink( sm_MDObject );
    }

    return(fRet);

} // IIS_SERVICE::InitializeMetabaseComObject



BOOL
IIS_SERVICE::CleanupMetabaseComObject(
    VOID
    )
/*++
    Description:

        This function initializes the metabase object

    Arguments:
        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Cleaning up metabase object %p\n",
            IIS_SERVICE::sm_MDObject));
    }

    TerminateMetabaseSink();

    if ( IIS_SERVICE::sm_MDObject != NULL ) {
        ((IMDCOM*)IIS_SERVICE::sm_MDObject)->ComMDTerminate(TRUE);
        IIS_SERVICE::sm_MDObject = NULL;
    }
    if ( IIS_SERVICE::sm_MDNseObject != NULL ) {
        ((IMDCOM*)IIS_SERVICE::sm_MDNseObject)->ComMDTerminate(TRUE);
        ((IMDCOM*)IIS_SERVICE::sm_MDNseObject)->Release();
        IIS_SERVICE::sm_MDNseObject = NULL;
    }

    return(TRUE);

} // IIS_SERVICE::CleanupMetabaseComObject


VOID
IIS_SERVICE::MDChangeNotify(
    DWORD            dwMDNumElements,
    MD_CHANGE_OBJECT pcoChangeList[]
    )
/*++

  This method handles the metabase change notification for the running
  services. Note that since we're not allowed to reenter the metabase from
  this notification, we do not directly notify the running services here.
  Rather, we capture the state of this notification and queue the request
  to a worker thread.

  Arguments:

    hMDHandle - Metabase handle generating the change notification
    dwMDNumElements - Number of change elements in pcoChangeList
    pcoChangeList - Array of paths and ids that have changed

--*/
{

    DWORD totalLength;
    DWORD i;
    LPDWORD nextIdArray;
    LPBYTE prevString;
    PMD_CHANGE_OBJECT mdScan;
    PMD_CHANGE_OBJECT nextObject;
    PDEFERRED_MD_CHANGE pdeferredChange;

#if DO_NOTIFICATION_DEFERRED
    //
    // First off, we need to calculate the size of the buffer required
    // to capture the change data. We'll start off with the known
    // fixed-size data.
    //

    totalLength = sizeof(DEFERRED_MD_CHANGE) +
                  ( sizeof(MD_CHANGE_OBJECT) * dwMDNumElements );

    //
    // Now, we'll scan the change list and accumulate the lengths
    // of the metadata paths and the ID arrays.
    //

    for( i = dwMDNumElements, mdScan = pcoChangeList ;
         i > 0 ;
         i--, mdScan++ ) {

        totalLength += (DWORD)strlen( (CHAR *)mdScan->pszMDPath ) + 1;
        totalLength += mdScan->dwMDNumDataIDs * sizeof(DWORD);

    }

    //
    // Now we can actually allocate the work item.
    //

    pdeferredChange = (PDEFERRED_MD_CHANGE) TCP_ALLOC( totalLength );

    if( pdeferredChange == NULL ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "MDChangeNotify: Cannot allocate work item (%lu)\n",
            totalLength
            ));

    } else {

        //
        // Capture the change information.
        //

        nextObject = (PMD_CHANGE_OBJECT)( pdeferredChange + 1 );
        prevString = (LPBYTE)pdeferredChange + totalLength;
        nextIdArray = (LPDWORD)( (LPBYTE)nextObject +
                          ( sizeof(MD_CHANGE_OBJECT) * dwMDNumElements ) );

        for( i = 0, mdScan = pcoChangeList ;
             i < dwMDNumElements ;
             i++, mdScan++, nextObject++ ) {

            DWORD cchPath;

            //
            // Initialize the object.
            //

            cchPath = (DWORD)strlen( (CHAR *)mdScan->pszMDPath ) + 1;
            prevString -= cchPath;

            nextObject->pszMDPath = prevString;
            memcpy(
                nextObject->pszMDPath,
                mdScan->pszMDPath,
                cchPath
                );

            nextObject->dwMDChangeType = mdScan->dwMDChangeType;
            nextObject->dwMDNumDataIDs = mdScan->dwMDNumDataIDs;

            nextObject->pdwMDDataIDs = nextIdArray;
            memcpy(
                nextObject->pdwMDDataIDs,
                mdScan->pdwMDDataIDs,
                nextObject->dwMDNumDataIDs * sizeof(DWORD)
                );

            nextIdArray += nextObject->dwMDNumDataIDs;

        }

        //
        // Ensure we didn't mess up the buffer.
        //

        DBG_ASSERT( (LPBYTE)nextIdArray == prevString );

        //
        // Now, just enqueue the request.
        //

        pdeferredChange->dwMDNumElements = dwMDNumElements;

        if( !ScheduleWorkItem( DeferredMDChange,
                               pdeferredChange,
                                0 ) ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "MDChangeNotify: cannot queue work item\n"
                ));

            TCP_FREE( pdeferredChange );
        }

    }
#else
    IIS_SERVICE::DeferredMDChangeNotify( dwMDNumElements,
                                         pcoChangeList );

    IIS_SERVICE::DeferredGlobalConfig( dwMDNumElements,
                                       pcoChangeList );
#endif

}   // IIS_SERVICE::MDChangeNotify

#if DO_NOTIFICATION_DEFERRED
VOID
WINAPI
DeferredMDChange(
    PVOID pv
    )
{
    PDEFERRED_MD_CHANGE pdmc = (PDEFERRED_MD_CHANGE) pv;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"DeferredMDChange(%p)\n", pdmc));
    }

    IIS_SERVICE::DeferredMDChangeNotify( pdmc->dwMDNumElements,
                                         (PMD_CHANGE_OBJECT)(pdmc + 1) );

    IIS_SERVICE::DeferredGlobalConfig( pdmc->dwMDNumElements,
                                       (PMD_CHANGE_OBJECT)(pdmc + 1 ) );

    TCP_FREE( pdmc );
}
#endif

VOID
IIS_SERVICE::DeferredGlobalConfig(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]
)
/*++

    Update configuration of options that are above the service name in the
    metabase (global to all services).  For example, global Bandwidth
    Throttling

  Arguments:

    dwMDNumElements - Number of change elements in pcoChangeList
    pcoChangeList - Array of paths and ids that have changed

--*/
{
    DWORD               i;
    BOOL                fUpdateGlobalConfig = FALSE;

    for ( i = 0; i < dwMDNumElements; i++ )
    {
        if ( !_stricmp( (CHAR*) pcoChangeList[i].pszMDPath, LM_PREFIX ) )
        {
            fUpdateGlobalConfig = TRUE;
            break;
        }
    }

    if ( fUpdateGlobalConfig )
    {
        DWORD           dwVal;

        AcquireGlobalLock();

        MB mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );

        if (!mb.Open("/lm", METADATA_PERMISSION_READ) ||
            !mb.GetDword("", MD_MAX_BANDWIDTH, IIS_MD_UT_SERVER, &dwVal))
        {
            dwVal = INETA_DEF_BANDWIDTH_LEVEL;
        }

        AtqSetInfo( AtqBandwidthThrottle, (ULONG_PTR)dwVal);

        if ( mb.GetDword("", MD_MAX_BANDWIDTH_BLOCKED, IIS_MD_UT_SERVER, &dwVal))
        {
            AtqSetInfo( AtqBandwidthThrottleMaxBlocked, (ULONG_PTR)dwVal );
        }

        ReleaseGlobalLock();
    }
}


VOID
IIS_SERVICE::DeferredMDChangeNotify(
    DWORD            dwMDNumElements,
    MD_CHANGE_OBJECT pcoChangeList[]
    )
/*++

  This method handles the metabase change notification for the running services
  and notifies the appropriate service.  This is a static method, invoked by
  the deferred worker thread.

  Arguments:

    dwMDNumElements - Number of change elements in pcoChangeList
    pcoChangeList - Array of paths and ids that have changed

--*/
{
    LIST_ENTRY *        pEntry;

#ifdef _KNFOCOMM
    //
    //  Knfocomm sink will only process MB notifications whose path
    //  corresponds to services that use knfocomm...
    //
    const CHAR *  pszKnfoSvcName;
    DWORD         cchKnfoSvcName;
    DWORD         i,j;
    BOOL          fMatch = FALSE;

    for( j=0; j < gNumKnfoServices; j++ )
    {
        pszKnfoSvcName = rgKnfoServices[j];
        cchKnfoSvcName = strlen( pszKnfoSvcName );

        for ( i = 0; i < dwMDNumElements; i++ )
        {
            if ( !_strnicmp( (CHAR *) pcoChangeList[i].pszMDPath + LM_PREFIX_CCH,
                             pszKnfoSvcName,
                             cchKnfoSvcName ))
            {
                //  MB change list contains a path that matches one of the known
                //  knfocomm services.
                fMatch = TRUE;
            }
        }
    }

    if( !fMatch ) {
        //  Knfocomm has nothing to do with this notification...
        return;
    }
#endif

    //
    //  Walk the list of services and change notifications looking for a match
    //

    AcquireGlobalLock();

    for ( pEntry =  sm_ServiceInfoListHead.Flink;
          pEntry != &sm_ServiceInfoListHead;
          pEntry =  pEntry->Flink )
    {
        const CHAR *  pszSvcName;
        DWORD         cchSvcName;
        DWORD         i;
        IIS_SERVICE * pService = CONTAINING_RECORD( pEntry,
                                                    IIS_SERVICE,
                                                    m_ServiceListEntry );

        pszSvcName = pService->QueryServiceName();
        cchSvcName = strlen( pszSvcName );

        for ( i = 0; i < dwMDNumElements; i++ )
        {
            if ( !_strnicmp( (CHAR *) pcoChangeList[i].pszMDPath + LM_PREFIX_CCH,
                             pszSvcName,
                             cchSvcName ))
            {
                if( pService->CheckAndReference() ) {
                    pService->MDChangeNotify( &pcoChangeList[i] );
                    pService->Dereference();
                }
            }
        }
    }

    ReleaseGlobalLock();

}   // IIS_SERVICE::DeferredMDChangeNotify


VOID
IIS_SERVICE::MDChangeNotify(
    MD_CHANGE_OBJECT * pco
    )
/*++

  This method handles the metabase change notification for this server instance

  Arguments:

    pco - path and id that has changed

--*/
{
    LIST_ENTRY * pEntry;
    LPSTR serviceName;
    DWORD serviceNameLength;
    DWORD instanceId;
    LPSTR instanceIdString;
    LPSTR stringEnd;
    BOOL parentChange;
    BOOL didAddOrDelete;
    DWORD i;

    //
    //  Find the instance ID in the path.
    //

    serviceName = (LPSTR)QueryServiceName();
    serviceNameLength = (DWORD)strlen( serviceName );

    DBG_ASSERT( !_strnicmp(
                     (CHAR *)pco->pszMDPath,
                     LM_PREFIX,
                     LM_PREFIX_CCH
                     ) );

    DBG_ASSERT( !_strnicmp(
                     (CHAR *)pco->pszMDPath + LM_PREFIX_CCH,
                     serviceName,
                     (size_t)serviceNameLength
                     ) );

    instanceIdString = (LPSTR)pco->pszMDPath + LM_PREFIX_CCH + serviceNameLength;

    //
    //  Lock the service before we start mucking with things too much.
    //

    parentChange = TRUE;
    didAddOrDelete = FALSE;

    AcquireServiceLock();

    if( instanceIdString[0] == '/' &&
        instanceIdString[1] != '\0' ) {

        parentChange = FALSE;
        instanceId = strtoul( instanceIdString + 1, &stringEnd, 10 );

        //
        //  If this is an "instance add" or "instance delete", then Do The
        //  Right Thing. Note that strtoul() will set stringEnd to point to
        //  the character that "stopped" the conversion. This will point to
        //  the string terminator ('\0') if the converted ulong is at the end
        //  of the string. In our case, this would indicate the string is of
        //  the form:
        //
        //      /LM/{service_name}/{instance_id}/
        //
        //  Note there are no path components beyond the instance ID. This is
        //  our indication that an instance is getting created/deleted.
        //

        if( ( pco->dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT ) &&
            stringEnd[0] == '/' &&
            stringEnd[1] == '\0' ) {

            didAddOrDelete = TRUE;

            if( !AddInstanceInfo( instanceId ) ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "MDChangeNotify: cannot add instance %lu, error %lu\n",
                    instanceId,
                    GetLastError()
                    ));

            }

        } else
        if( ( pco->dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT ) &&
            stringEnd[0] == '/' &&
            stringEnd[1] == '\0' ) {

            didAddOrDelete = TRUE;

            if( !DeleteInstanceInfo( instanceId ) ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "MDChangeNotify: cannot delete instance %lu, error %lu\n",
                    instanceId,
                    GetLastError()
                    ));

            }

        }

    }

    if( !didAddOrDelete ) {

        //
        //  Walk the list of instances and change notifications looking
        //  for a match on the metabase path or a path that is above the
        //  instance (to make sure any inherited changes are picked up).
        //

        DWORD pathLength = strlen( (CHAR *)pco->pszMDPath );

        for ( pEntry  = m_InstanceListHead.Flink;
              pEntry != &m_InstanceListHead;
              pEntry  = pEntry->Flink )
        {
            IIS_SERVER_INSTANCE * pInstance = CONTAINING_RECORD( pEntry,
                                                                 IIS_SERVER_INSTANCE,
                                                                 m_InstanceListEntry );

            if ( parentChange ||
                 ( pInstance->QueryMDPathLen() <= pathLength &&
                   !_strnicmp( (CHAR *) pco->pszMDPath,
                               pInstance->QueryMDPath(),
                               pInstance->QueryMDPathLen() ) &&
                   ( pco->pszMDPath[pInstance->QueryMDPathLen()] == '\0' ||
                     pco->pszMDPath[pInstance->QueryMDPathLen()] == '/' ) ) )
            {
                pInstance->MDChangeNotify( pco );

                if ( !parentChange )
                    break;
            }
        }

    }

    //
    //  Watch for the downlevel instance changing
    //

    for ( i = 0; i < pco->dwMDNumDataIDs; i++ )
    {
        switch ( pco->pdwMDDataIDs[i] )
        {
        case MD_DOWNLEVEL_ADMIN_INSTANCE:
            {
                MB                    mb( (IMDCOM*) QueryMDObject() );
                IIS_SERVER_INSTANCE * pInst;

                if ( mb.Open( QueryMDPath() ) )
                {
                    if ( !mb.GetDword( "",
                                       MD_DOWNLEVEL_ADMIN_INSTANCE,
                                       IIS_MD_UT_SERVER,
                                       &m_dwDownlevelInstance ))
                    {
                        m_dwDownlevelInstance = 0xffffffff;
                    }
                }

                //
                //  Mirror the new vroots to the registry
                //

                if ( pInst = FindIISInstance( m_dwDownlevelInstance ))
                {
                    pInst->MDMirrorVirtualRoots();
                }
            }

        default:
            break;
        }
    }


    ReleaseServiceLock();

} // IIS_SERVICE::MDChangeNotify


BOOL
IIS_SERVICE::LoadStr(
            OUT STR & str,
            IN DWORD dwResId,
            IN BOOL fForceEnglish ) const
/*++

  This function loads the string, whose resource id is ( dwResId), into
   the string str passed.

  Arguments:
    str      reference to string object into which the string specified
             by resource id is loaded
    dwResId  DWORD containing the resource id for string to be loaded.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;

    if ( (dwResId >= WSABASEERR) && (dwResId <  WSA_MAX_ERROR) ) {

        if (( fReturn  = str.Resize((sizeof(SOCK_ERROR_STR_A) + 11) *
                                     sizeof( WCHAR )))) {

            wsprintfA( str.QueryStr(), SOCK_ERROR_STR_A, dwResId );

        } // if ( Resize()

    } else {

        //
        // Try to load the string from current module or system table
        //  depending upon if the Id < STR_RES_ID_BASE.
        // System table contains strings for id's < STR_RES_ID_BASE.
        //

        if ( dwResId < STR_RES_ID_BASE)  {

            // Use English strings for System table
            fReturn = str.LoadString( dwResId, (LPCTSTR ) NULL,
                                      ( m_fIsDBCS && fForceEnglish ) ? 0x409 : 0);

        } else {

            fReturn = str.LoadString( dwResId, m_hModule );
        }
    }

    if ( !fReturn ) {
        DBGPRINTF((DBG_CONTEXT,"Error %d in load string[%d]\n",
            GetLastError(), dwResId ));
    }

    return ( fReturn);

} // IIS_SERVICE::LoadStr()




DWORD
IIS_SERVICE::InitializeDiscovery(
            VOID
            )
/*++

    Register this server and service with service discoverer.
    It will discover us using these information for administering us.

  Arguments:

    None.

  Return Value:
    Win32 Error Code;

--*/
{
    DWORD           dwError = NO_ERROR;
    PISRPC          pIsrpc;

    //
    // Only enable on server as we don't have remove admin on
    // the PWS.  -jra  !!! of course, we could change our minds again.
    //

    if ( g_hSvcLocDll == NULL ) {
        m_fEnableSvcLocation = FALSE;
        return(NO_ERROR);
    }

    INET_BINDINGS   TotalBindings = { 0, NULL};
    HKEY  hkey = NULL;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           QueryRegParamKey(),
                           0,
                           KEY_READ,
                           &hkey );

    if ( dwError != NO_ERROR )
    {
        IF_DEBUG( ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "IIS_SERVICE::InitializeDiscovery() "
                       " RegOpenKeyEx returned error %d\n",
                       dwError ));
        }

        return (dwError);
    }

    m_fEnableSvcLocation = !!ReadRegistryDword( hkey,
                                               INETA_ENABLE_SVC_LOCATION,
                                               INETA_DEF_ENABLE_SVC_LOCATION);

    if ( hkey != NULL) {

        RegCloseKey( hkey);
    }

    if ( !m_fEnableSvcLocation ) {

        //
        // Service Location is not enabled (by admin presumably).
        // So Let us not register ourselves now.
        //
        return ( NO_ERROR);
    }

    //
    // Form the global binding information
    //

    pIsrpc = QueryInetInfoRpc( );
    dwError = pIsrpc->EnumBindingStrings( &TotalBindings);

    if ( dwError == NO_ERROR) {

        dwError = pfnInetRegisterSvc(
                      m_SvcLocId,
                      INetServiceRunning,
                      m_strServiceComment.QueryStr(),
                      &TotalBindings
                      );

        IF_DEBUG( DLL_RPC) {
            DBGPRINTF(( DBG_CONTEXT,
                       "INetRegisterService( %u), Running, returns %u\n",
                       QueryServiceId(),
                       dwError));
        }
    }

    //
    //  Log the error then ignore it as it only affects service discovery
    //

    if ( dwError != NO_ERROR ) {

        m_EventLog.LogEvent( INET_SVC_SERVICE_REG_FAILED,
                            0,
                            (const CHAR **) NULL,
                            dwError );

        dwError = NO_ERROR;  // Ignore the error .....
    } else {

        m_fSvcLocationDone = TRUE;
    }

    pIsrpc->FreeBindingStrings( &TotalBindings);

    return( dwError);

}  // IIS_SERVICE::InitializeDiscovery()



DWORD
IIS_SERVICE::TerminateDiscovery(
                        VOID
                        )
{
    DWORD           dwError = NO_ERROR;

    //
    //  Deregister the service from the Discovery Service. This will
    //  prevent admins from picking up our machine for administration.
    //

    if ( m_fEnableSvcLocation && m_fSvcLocationDone) {

        dwError = pfnInetDeregisterSvc(m_SvcLocId);

        DBG_ASSERT( dwError == NO_ERROR);
        m_fSvcLocationDone = FALSE;
    }

    return( dwError);

} // IIS_SERVICE::TerminateDiscovery()



VOID
IIS_SERVICE::DestroyAllServerInstances(
        VOID
        )
/*++

    Description:

        Destroys all server instanes of this service.

    Arguments:

        None.

    Returns:

        None.
--*/
{

    PLIST_ENTRY listEntry;
    PIIS_SERVER_INSTANCE pInstance;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF(( DBG_CONTEXT, "DestroyAllServerInstances called\n"));
    }

    //
    // Loop and delete all instances
    //

    AcquireServiceLock( );

    while ( !IsListEmpty(&m_InstanceListHead) ) {

        listEntry = RemoveHeadList( &m_InstanceListHead );
        m_nInstance--;
        ReleaseServiceLock( );

        pInstance = CONTAINING_RECORD(
                                listEntry,
                                IIS_SERVER_INSTANCE,
                                m_InstanceListEntry
                                );

        //
        // Close and dereference the instance.
        //

        pInstance->CloseInstance();
        pInstance->Dereference();

        AcquireServiceLock( );

    }

    ReleaseServiceLock( );

} // IIS_SERVICE::DestroyAllServerInstances



BOOL
IIS_SERVICE::EnumServiceInstances(
    PVOID             pvContext,
    PVOID             pvContext2,
    PFN_INSTANCE_ENUM pfnEnum
    )
/*++

    Description:

        Enumerates all instances on this service

    Arguments:

        pvContext - Context to pass back to the caller
        pvContext2 - 2nd context to pass back to the caller
        pfnEnum - Callback to make for each instance

    Returns:

        TRUE if no errors were returned, FALSE if a callback returned
        an error
--*/
{

    PLIST_ENTRY          listEntry;
    PIIS_SERVER_INSTANCE pInstance;
    BOOL                 fRet = TRUE;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF(( DBG_CONTEXT, "EnumServiceInstances called\n"));
    }

    //
    // Loop and delete all instances
    //

    AcquireServiceLock( TRUE );

    for ( listEntry  = m_InstanceListHead.Flink;
          listEntry != &m_InstanceListHead;
          listEntry  = listEntry->Flink ) {

        pInstance = CONTAINING_RECORD(
                                listEntry,
                                IIS_SERVER_INSTANCE,
                                m_InstanceListEntry
                                );

        if ( !(fRet = pfnEnum( pvContext,
                               pvContext2,
                               pInstance )))
        {
            break;
        }
    }

    ReleaseServiceLock( TRUE );
    return fRet;

} // IIS_SERVICE::EnumServerInstances




VOID
IIS_SERVICE::CloseService(
    VOID
    )
/*++

  Description:
     This function cleans up the service object.

  Returns:
     None.
--*/
{

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF(( DBG_CONTEXT,
            "IIS_SERVICE:Destroy service object %p ref %d\n",this,m_reference));
    }

    DBG_ASSERT(m_state != BlockStateActive);

    DestroyAllServerInstances( );

    //
    // We can't return from this function before the refcount hits zero, because
    // after we return TerminateGlobals will destroy structures that the other
    // threads might need while cleaning up.  To prevent this we busy wait here
    // until the reference count reaches 1.
    //

#if DBG
    int cRetries = 0;
    const int nDelay = 1000;
#else
    const int nDelay =  200;
#endif

    while ( m_reference > 1 )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "IIS_SERVICE:Destroy service object %p ref %d\n",this,m_reference ));

#if DBG
        ++cRetries;
#endif

        Sleep(nDelay);
    }

    Dereference( );

} // IIS_SERVICE::CloseService





BOOL
IIS_SERVICE::AddServerInstance(
        IN PIIS_SERVER_INSTANCE pInstance
        )
/*++
    Description:

        References a new instane of this service

    Arguments:

        pInstance - instance to link.

    Returns:

        NO_ERROR on success and Win32 error code if any failure.
--*/
{
    DWORD err;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,"AddServerInstance called with %p\n",
            pInstance ));
    }

    //
    // Insert instance into service list
    //

    AcquireServiceLock( );

    if ( !IsActive() ) {
        err = ERROR_NOT_READY;
        goto error_exit;
    }

    //
    // reference the instance since we now have a link to it.
    //

    pInstance->Reference();

    InsertTailList( &m_InstanceListHead, &pInstance->m_InstanceListEntry );
    m_nInstance++;
    ReleaseServiceLock( );
    return(TRUE);

error_exit:
    ReleaseServiceLock( );
    SetLastError(err);
    return(FALSE);

} // AddServerInstance



BOOL
IIS_SERVICE::RemoveServerInstance(
        IN PIIS_SERVER_INSTANCE pInstance
        )
/*++
    Description:

        References a new instane of this service

    Arguments:

        pInstance - instance to link.

    Returns:

        NO_ERROR on success and Win32 error code if any failure.
--*/
{

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,"RemoveServerInstance called with %p\n",
            pInstance ));
    }

    //
    // Remove instance from service list
    //

    AcquireServiceLock( );
    RemoveEntryList( &pInstance->m_InstanceListEntry );
    m_nInstance--;
    ReleaseServiceLock( );

    pInstance->Dereference( );

    return(TRUE);

} // RemoveServerInstance


IIS_ENDPOINT *
IIS_SERVICE::FindAndReferenceEndpoint(
    IN USHORT   Port,
    IN DWORD    IpAddress,
    IN BOOL     CreateIfNotFound,
    IN BOOL     IsSecure,
    IN BOOL     fDisableSocketPooling

    )
/*++

    Description:

        Searches the service's endpoint list looking for one bound to
        the specified port.

    Arguments:

        Port - The port to search for.

        IpAddress - The IP Address to search for.

        CreateIfNotFound - If TRUE, and the port cannot be found in
            the endpoint list, then a new endpoint is created and
            attached to the list.

        IsSecure - TRUE for secure ports. Only used when a new
            endpoint is created.

        fDisableSocketPooling - Used only if CreateIfNotFound is TRUE.
            If TRUE, create an endpoint qualified by both Port & IP.
            Else create an endpoint qualified only by Port.

    Returns:

        IIS_ENDPOINT * - Pointer to the endpoint if successful, NULL
            otherwise. If !NULL, then the endpoint is referenced and it
            is the caller's responsibility to dereference the endpoint
            at a later time.

--*/
{

    PLIST_ENTRY     listEntry;
    PIIS_ENDPOINT   endpoint = NULL;
    DWORD           searchIpAddress = IpAddress;

    //
    // Walk the list looking for a matching port. Note that the endpoints
    // are stored in ascending port order.
    //
    // Initially we search for an endpoint that is qualified by both IpAddress
    // and Port.

    AcquireServiceLock();

SearchEndpointList:

    for( listEntry = m_EndpointListHead.Flink ;
         listEntry != &m_EndpointListHead ;
         listEntry = listEntry->Flink ) {

        endpoint = CONTAINING_RECORD(
                       listEntry,
                       IIS_ENDPOINT,
                       m_EndpointListEntry
                       );

        if( endpoint->m_Port > Port ) {
            break;
        }

        if( endpoint->m_Port == Port &&
            endpoint->m_IpAddress == searchIpAddress
          )
        {
            endpoint->Reference();
            goto done;
        }
    }

    //
    //  The search failed. If this was a search qualified by IpAddress,
    //  we need to re-search using INADDR_ANY as the IP Address
    //

    if (INADDR_ANY != searchIpAddress)
    {
        searchIpAddress = INADDR_ANY;
        goto SearchEndpointList;
    }

    //
    // The port is not in the list. Create a new endpoint if required.
    //

    if( CreateIfNotFound ) {

        //
        // CODEWORK: It may be necessary in the future to move this
        // endpoint creation to a virtual method so that classes derived
        // from IIS_SERVICE can create specific types of endpoints.
        //

        endpoint = new IIS_ENDPOINT(
                           this,
                           Port,
                           fDisableSocketPooling ? IpAddress : INADDR_ANY,
                           IsSecure
                           );

        if( endpoint != NULL ) {

            //
            // Insert it into the list.
            //

            listEntry = listEntry->Blink;
            InsertHeadList(
                listEntry,
                &endpoint->m_EndpointListEntry
                );

            goto done;
        }
    }

    //
    // If we made it this far, then we could not find the endpoint and
    // either could not create a new one OR were not asked to create one.
    //

    endpoint = NULL;

done:

    ReleaseServiceLock();
    return endpoint;

}   // IIS_SERVICE::FindAndReferenceEndpoint


BOOL
IIS_SERVICE::AddInstanceInfoHelper(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Description:

        Helper routine called by the service-specific AddInstanceInfo()
        virtual routine. This helper just commonizes some startup code
        that all services need to do.

    Arguments:

        pInstance - The instance to associate with the service.

    Returns:

        BOOL - TRUE if successful, FALSE otherwise.

    Notes:

        If this routine returns FALSE, then the instance object passed in
        is properly destroyed and extended error information is available
        via GetLastError().

--*/
{

    DWORD status;

    if( pInstance == NULL ) {

        status = ERROR_NOT_ENOUGH_MEMORY;

        DBGPRINTF((
            DBG_CONTEXT,
            "AddInstanceInfoHelper: cannot create new instance, error %lu\n",
            status
            ));

        //
        // The memory allocation failed, so we've nothing to delete.
        //

    } else
    if( pInstance->QueryServerState() == MD_SERVER_STATE_INVALID ) {

        //
        // Unfortunately, I don't think we can depend on "last error"
        // getting set correctly on a constructor failure, so we'll
        // just kludge up an error code.
        //

        status = ERROR_NOT_ENOUGH_MEMORY;

        DBGPRINTF((
            DBG_CONTEXT,
            "AddInstanceInfoHelper: constructor failed, error %lu\n",
            status
            ));

        //
        // The constructor failed. The instance may or may not be on
        // the service's instance list. If the base constructor failed,
        // then the instance is NOT on the list. If the derived constructor
        // failed, then the instance IS on the list.
        //
        // CleanupAfterConstructorFailure() will Do The Right Thing
        // to properly destroy the partially constructed instance.
        //

        pInstance->CleanupAfterConstructorFailure();

    } else
    if( pInstance->IsAutoStart() && !AssociateInstance( pInstance ) ) {

        status = GetLastError();

        DBGPRINTF((
            DBG_CONTEXT,
            "AddInstanceInfoHelper: cannot associate instance, error %lu\n",
            status
            ));

        //
        // The constructor succeeded, but the instance could not be
        // associated with the service. The reference count should be
        // exactly one. We can't just delete the object as the destructor
        // will assert because the reference count is non-zero, so we'll
        // call RemoveServerInstance(), which will remove the instance from
        // the service's list and then dereference the instance.
        //

        RemoveServerInstance( pInstance );

    } else {
        return TRUE;
    }

    SetLastError( status );
    return FALSE;

}   // IIS_SERVICE::AddInstanceInfoHelper


BOOL
IIS_SERVICE::IsService()
{
    return !g_fIgnoreSC;
}


VOID
IIS_SERVICE::AdvertiseServiceInformationInMB(
    VOID
    )
{

    MB          mb( (IMDCOM*) QueryMDObject() );
    CHAR        szServiceKey[MAX_PATH+1];
    DWORD       capabilities = 0;
    DWORD       version = 0;
    DWORD       productType = 0;
    HKEY        hkey;

    strcpy( szServiceKey, IIS_MD_LOCAL_MACHINE_PATH "/" );
    strcat( szServiceKey, QueryServiceName() );

    if ( !mb.Open( szServiceKey,
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[AddCapabilityFlag] Cannot open path %s, error %lu\n",
                    szServiceKey, GetLastError() ));
        return;
    }

    //
    // set version
    //

    if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                       MD_SERVER_VERSION_MAJOR,
                       IIS_MD_UT_SERVER,
                       IIS_VERSION_MAJOR,
                       0 ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "Error %d setting major version %x\n",
            GetLastError(), IIS_VERSION_MAJOR));
    }

    if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                       MD_SERVER_VERSION_MINOR,
                       IIS_MD_UT_SERVER,
                       IIS_VERSION_MINOR,
                       0 ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "Error %d setting minor version %x\n",
            GetLastError(), IIS_VERSION_MINOR));
    }

    //
    // set platform type
    //

    switch (IISGetPlatformType()) {

        case PtNtServer:
            productType = INET_INFO_PRODUCT_NTSERVER;
            capabilities = IIS_CAP1_NTS;
            break;
        case PtNtWorkstation:
            productType = INET_INFO_PRODUCT_NTWKSTA;
            capabilities = IIS_CAP1_NTW;
            break;
        case PtWindows95:
            productType = INET_INFO_PRODUCT_WINDOWS95;
            capabilities = IIS_CAP1_W95;
            break;
        default:
            productType = INET_INFO_PRODUCT_UNKNOWN;
            capabilities = IIS_CAP1_W95;
    }

    if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                       MD_SERVER_PLATFORM,
                       IIS_MD_UT_SERVER,
                       productType,
                       0 ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "Error %d setting platform type %x\n",
            GetLastError(), productType));

    }

    //
    //  Check to see if FrontPage is installed
    //

    if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        REG_FP_PATH,
                        0,
                        KEY_READ,
                        &hkey ))
    {
        capabilities |= IIS_CAP1_FP_INSTALLED;

        DBG_REQUIRE( !RegCloseKey( hkey ));
    }

    //
    // We also need to determine the IIS_CAP1_DIGEST_SUPPORT and IIS_CAP1_NT_CERTMAP_SUPPORT
    // bits but we don't do it here because Net Api calls take forever resulting in Service Control
    // Manager timeouts. Hence we do that check in the InitializeService method (only for W3C).
    //

    //
    // Set the capabilities flag
    //

    if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                       MD_SERVER_CAPABILITIES,
                       IIS_MD_UT_SERVER,
                       capabilities,
                       0 ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "Error %d setting capabilities flag %x\n",
            GetLastError(), capabilities));

    }

    mb.Close();
    return;

} // IIS_SERVICE::AdvertiseServiceInformationInMB



IUnknown *
IIS_SERVICE::QueryMDObject(
    VOID
    )
{
    return IIS_SERVICE::sm_MDObject;

} // IIS_SERVICE::QueryMDObject


IUnknown *
IIS_SERVICE::QueryMDNseObject(
    VOID
    )
{
    return IIS_SERVICE::sm_MDNseObject;

} // IIS_SERVICE::QueryMDObject


DWORD
InitMetadataDCom(
    PVOID Context,
    PVOID NseContext
    )
/*++

    Routine:
        A dummy thread, used only to create the Metadata DCOM object in
            the right fashion.

    Arguments:
        Context - Pointer to the global md object pointer
        NseContext - Pointer to the global md NSE object pointer


    Returns:
        TRUE if we initialized DCOM properly, FALSE otherwise.

--*/
{
    HRESULT     hRes;
    IMDCOM*     pcCom;
    IMDCOM*     pcNseCom;
    BOOL        fRet = FALSE;
    IMDCOM **   pMetaObject = (IMDCOM**)Context;
    IMDCOM **   pNseMetaObject = (IMDCOM**)NseContext;

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes) && (hRes != E_INVALIDARG) ) {
        DBGPRINTF((DBG_CONTEXT,"CoInitializeEx failed %x\n", hRes));
        DBG_ASSERT(FALSE);
        return FALSE;
    }

    hRes = CoCreateInstance(
#ifndef _KETADATA
                        GETMDCLSID(!g_fIgnoreSC),
#else
                        GETMDPCLSID(!g_fIgnoreSC),
#endif
                        NULL,
                        CLSCTX_SERVER,
                        IID_IMDCOM,
                        (void**) &pcCom
                        );

    if (!FAILED(hRes)) {

        hRes = CoCreateInstance(CLSID_NSEPMCOM, NULL, CLSCTX_INPROC_SERVER, IID_NSECOM, (void**) &pcNseCom);

        if (FAILED(hRes)) {

            // non-fatal error
            DBGPRINTF((DBG_CONTEXT,"QueryInterface for NSE failed with %x\n", hRes));
            pcNseCom = NULL;
        }

        hRes = pcCom->ComMDInitialize();

        if (FAILED(hRes)) {

            DBGPRINTF((DBG_CONTEXT,"MDInitialize failed with %x\n", hRes));
            pcCom->Release();
            goto exit;

        }

        if ( pcNseCom ) {
            hRes = pcNseCom->ComMDInitialize();

            if (FAILED(hRes)) {

                DBGPRINTF((DBG_CONTEXT,"NSEMDInitialize failed with %x\n", hRes));
                pcNseCom->Release();
                pcCom->Release();
                goto exit;
            }
        }

        *pMetaObject = pcCom;
        *pNseMetaObject = pcNseCom;
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"CoCreateInstance returns %x\n", pcCom));
        }
        fRet = TRUE;
        goto exit;

    } else {
        DBGPRINTF((DBG_CONTEXT,"CoCreateInstance failed with %x\n", hRes));
    }

exit:

    CoUninitialize( );
    return(fRet);

} // InitMetadataDCom


BOOL
IIS_SERVICE::RecordInstanceStart( VOID )
/*++

    Description:

        Records that an instance is starting.

    Arguments:

        None.

    Returns:

        BOOL - TRUE if it's OK to start the instance, FALSE if it
            must not be started.

--*/
{

    LONG result;

    result = InterlockedIncrement( &m_nStartedInstances );

    if( !TsIsNtServer() && result > 1 ) {
        InterlockedDecrement( &m_nStartedInstances );
        return FALSE;
    }

    return TRUE;

}   // IIS_SERVICE::RecordInstanceStart


VOID
IIS_SERVICE::RecordInstanceStop( VOID )
/*++

    Description:

        Records that an instance is stopping.

    Arguments:

        None.

    Returns:

        None.

--*/
{

    LONG result;

    result = InterlockedDecrement( &m_nStartedInstances );
    DBG_ASSERT( result >= 0 );

}   // IIS_SERVICE::RecordInstanceStop


BOOL
I_StopInstanceEndpoint( PVOID                 pvContext1,
                        PVOID                 pvContext2,
                        IIS_SERVER_INSTANCE * pInstance )
{
    IF_DEBUG( INSTANCE) {

        DBGPRINTF(( DBG_CONTEXT,
                    "I_StopInstanceEndpoint( %p, %p, %08p)\n",
                    pvContext1, pvContext2, pInstance));
    }

    DBG_ASSERT( NULL == pvContext1);
    DBG_ASSERT( NULL == pvContext2);

    return ( pInstance->StopEndpoints());
} // I_StopInstanceEndpoint()




VOID
WINAPI
ServiceShutdownIndicator( VOID * pSvcContext)
{
    IIS_SERVICE * pIisService = (IIS_SERVICE * ) pSvcContext;

    IF_DEBUG( INSTANCE) {
        DBGPRINTF(( DBG_CONTEXT,
                    "ServiceShutdownIndicator(%p)\n", pSvcContext));
    }

    if ( pSvcContext == NULL) {

        DBGPRINTF(( DBG_CONTEXT,
                    " ServiceShutdownIndicator() called with NULL service\n"));
    }

    // Do Shutdown processing work ...
    DBG_ASSERT( pIisService->QueryShutdownScheduleId() != 0);
    pIisService->ShutdownScheduleCallback();

    return;

} // ServiceShutdownIndicator()


DWORD
IIS_SERVICE::ShutdownScheduleCallback(VOID)
/*++
  Description:
    This function is the periodic callback from scheduler for IIS_SERVICE to
    tell the Service Control Manager that we are shutting down
    and need more time.

    Problem: IIS_SERVICE shutdown operation takes long time. The time is
    highly dependent on the number of components to be shutdown, number
    of IO operations to be cancelled and cleaned up, etc.
    Service Control Manager(SCM) in NT allows the Service shutdown to
    happen within a specified time limit - usually less than 20 seconds.
    If the shutdown did not happen within this window, NT SCM will report
    shutdown failure.

    This function will indicate to SCM that we will need more time to shutdown.

  Arguments:
    None

  Returns:
    NO_ERROR on success. DWORD on error.

--*/
{

    m_nShutdownIndicatorCalls++;

# define NUM_SHUTDOWN_INDICATOR_CALLS_FOR_ONE_MINUTE \
    ( (60 * 1000) / MS_SERVICE_SHUTDOWN_INDICATOR_TIME_INTERVAL)

    if ( (m_nShutdownIndicatorCalls %
          NUM_SHUTDOWN_INDICATOR_CALLS_FOR_ONE_MINUTE)
         == 0) {

        char rgchShutdown[256];

        //
        // Generate a message telling that shutdown is in progress
        //

        wsprintf( rgchShutdown,
                  "[%d]Service (%s) shutting down for %d minutes ... \n",
                  GetCurrentThreadId(),
                  QueryServiceName(),
                  (m_nShutdownIndicatorCalls /
                   NUM_SHUTDOWN_INDICATOR_CALLS_FOR_ONE_MINUTE
                   )
                  );

        OutputDebugString( rgchShutdown);
    }

    DBG_ASSERT( m_dwShutdownScheduleId);

    //
    // Indicate to the SCM that we are in shutdown
    //

    DBG_REQUIRE( NO_ERROR ==
                DelayCurrentServiceCtrlOperation( SERVICE_STOP_WAIT_HINT)
                );

    return (NO_ERROR);
} // IIS_SERVICE::ShutdownScheduleCallback()



VOID  
IIS_SERVICE::StartUpIndicateClientActivity(VOID)
{
    DWORD dwCurrentTime;

    if ( m_svcStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        m_dwClientStartActivityIndicator++;

        dwCurrentTime = GetCurrentTimeInSeconds();
        if (dwCurrentTime > m_dwNextSCMUpdateTime) 
        {
            m_dwNextSCMUpdateTime = dwCurrentTime + IIS_SERVICE_START_INDICATOR_INTERVAL_SECONDS;
            m_dwStartUpIndicatorCalls++;
            if (m_dwStartUpIndicatorCalls < MAX_NUMBER_OF_START_HINT_REPETITIONS)
            {
                UpdateServiceStatus( SERVICE_START_PENDING, 
                                     NO_ERROR, 
                                     m_dwClientStartActivityIndicator,
                                     IIS_SERVICE_START_WAIT_HINT_EXTENDED + IIS_SERVICE_START_INDICATOR_INTERVAL);
            }
            else
            {
                DBGPRINTF(( DBG_CONTEXT," StartUpIndicateClientActivity max startup extension periods exceeded\n"));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\inetreg.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      inetreg.h

   Abstract:

      This file consists of the registry entries used by Internet Services
       common dll.

   Author:

       Murali R. Krishnan    ( MuraliK )    31-July-1995

   Environment:

       Win32 - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

#ifndef _INETREG_H_
#define _INETREG_H_


/************************************************************
 *   Symbolic Constants
 ************************************************************/


//
//  Common service configuration value names.
//

//  common for all objects

#define INETA_BANDWIDTH_LEVEL           TEXT("BandwidthLevel")
#define INETA_OBJECT_CACHE_TTL          TEXT("ObjectCacheTTL")

//
// per instance
//

//#define INETA_ADMIN_NAME               TEXT("AdminName")
//#define INETA_ADMIN_NAME_W             L"AdminName"
//#define INETA_ADMIN_EMAIL              TEXT("AdminEmail")
//#define INETA_ADMIN_EMAIL_W            L"AdminEmail"
#define INETA_SERVER_COMMENT           TEXT("ServerComment")
#define INETA_SERVER_COMMENT_W         L"ServerComment"
#define INETA_AUTHENTICATION           TEXT("Authorization")
#define INETA_LOG_ANONYMOUS            TEXT("LogAnonymous")
#define INETA_LOG_NONANONYMOUS         TEXT("LogNonAnonymous")
#define INETA_ANON_USER_NAME           TEXT("AnonymousUserName")
#define INETA_ANON_USER_NAME_W         L"AnonymousUserName"
//#define INETA_MAX_CONNECTIONS          TEXT("MaxConnections")
//#define INETA_CONNECTION_TIMEOUT       TEXT("ConnectionTimeout")
#define INETA_DEBUG_FLAGS              TEXT("DebugFlags")
//#define INETA_PORT                     TEXT("Port")
//#define INETA_PORT_SECURE              TEXT("SecurePort")
#define INETA_DEFAULT_LOGON_DOMAIN     TEXT("DefaultLogonDomain")
#define INETA_DEFAULT_LOGON_DOMAIN_W   L"DefaultLogonDomain"
#define INETA_LOGON_METHOD             TEXT("LogonMethod")
//#define INETA_SERVER_NAME              TEXT("ServerName")
//#define INETA_SERVER_NAME_W            L"ServerName"
//#define INETA_IP_ADDRESS               TEXT("IPAddress")
//#define INETA_HOST_NAME                TEXT("HostName")
//#define INETA_HOST_NAME_W              L"HostName"
#define INETA_LOGON_ANON_SUBAUTH       TEXT("LogonAnonymousUsingSubAuth")
#define INETA_DEF_LEVELS_TO_SCAN       2
//
// per service
//

#define INETA_ENABLE_SVC_LOCATION      TEXT("EnableSvcLoc")

//
//  The registry parameter key names for the grant list and deny
//  list.  We use the kludgemultisz thing for Chicago
//

#define IPSEC_DENY_LIST             "Deny IP List"
#define IPSEC_GRANT_LIST            "Grant IP List"

//
//  Size of the server.  0 - small, 1 - medium, 2 - big
//

#define INETA_SERVER_SIZE              TEXT("ServerSize")

//
//  Determines the number of outstanding AcceptEx sockets that should always
//  be available
//

#define INETA_ACCEPTEX_OUTSTANDING     TEXT("AcceptExOutstanding")

//
//  Determines the time (in seconds) we'll allow an AcceptEx socket to be
//  in the initial "Receive" state before timing it out
//

#define INETA_ACCEPTEX_TIMEOUT         TEXT("AcceptExTimeout")

//
//  Default values for the above parameters
//
#define INETA_DEF_BANDWIDTH_LEVEL                   (INFINITE)
#define INETA_DEF_OBJECT_CACHE_TTL                  (30)   // 30 seconds

//
// Timeouts are high to prevent async ios from being cancelled if a thread
// goes away.
//

#define INETA_DEF_THREAD_TIMEOUT                    (24*60*60) // 24 hours
#define INETA_DEF_THREAD_TIMEOUT_PWS                (30*60)    // 30 mins
#define INETA_DEF_ENABLE_SVC_LOCATION               (TRUE)

//
// fake xmit file buffer size
//

#define INETA_DEF_NONTF_BUFFER_SIZE                 (4096)
#define INETA_MIN_NONTF_BUFFER_SIZE                 (512)
#define INETA_MAX_NONTF_BUFFER_SIZE                 (64 * 1024)


#define INETA_DEF_ADMIN_NAME            ""
#define INETA_DEF_ADMIN_EMAIL           ""
#define INETA_DEF_SERVER_COMMENT        ""

#define INETA_LOGM_INTERACTIVE          0
#define INETA_LOGM_BATCH                1
#define INETA_LOGM_NETWORK              2

#define INETA_DEF_AUTHENTICATION        INET_INFO_AUTH_ANONYMOUS
#define INETA_DEF_LOG_ANONYMOUS         FALSE
#define INETA_DEF_LOG_NONANONYMOUS      FALSE
#define INETA_DEF_ANON_USER_NAME        "Guest"
#define INETA_DEF_MAX_CONNECTIONS       (DWORD)(0x77359400)
#define INETA_DEF_MAX_ENDPOINT_CONNECTIONS (DWORD)(0x77359400)
#define INETA_DEF_CONNECTION_TIMEOUT    600
#define INETA_DEF_DEBUG_FLAGS           0
#define INETA_DEF_PORT                  0
#define INETA_DEF_ACCEPTEX_OUTSTANDING  40
#define INETA_DEF_ACCEPTEX_TIMEOUT      120
#define INETA_DEF_SERVER_SIZE           MD_SERVER_SIZE_MEDIUM
#define INETA_DEF_MIN_KB_SEC            1000
#define INETA_DEF_DEFAULT_LOGON_DOMAIN  ""
#define INETA_DEF_LOGON_METHOD          INETA_LOGM_INTERACTIVE
#define INETA_DEF_SERVER_NAME           ""
#define INETA_DEF_AUTO_START            TRUE
#define INETA_DEF_IP_ADDRESS            INADDR_ANY
#define INETA_DEF_HOST_NAME             ""
#define INETA_DEF_LOGON_ANON_SUBAUTH    FALSE

//
// PWS connection limit
//

#define INETA_DEF_MAX_CONNECTIONS_PWS   10
#define INETA_MAX_MAX_CONNECTIONS_PWS   40
#define INETA_DEF_MAX_ENDPOINT_CONNECTIONS_PWS   10
#define INETA_MAX_MAX_ENDPOINT_CONNECTIONS_PWS   40

//
//  The key name the list of virtual roots is stored under
//

#define VIRTUAL_ROOTS_SEC_KEY   L"Virtual Roots\\Security"
#define VIRTUAL_ROOTS_KEY_A     "Virtual Roots"
#define HTTP_EXT_MAPS           "Script Map"

//
// begin -  Windows 95 specific
// Nb: Those settings should be correlated to content of inetsvcs.adm file
//

#define INETA_DISABLE_INET_SERVICES         "DisableAllServices"
#define INETA_DISABLE_SERVICE               "DisableService"
#define INETA_DISABLE_NO_SECURITY           "DisableNoSecuritySet"
#define INETA_DISABLE_NET_DRIVES_SHARING    "DisableNetDrivesSharing"
#define INETA_DISABLE_CLEARTEXT_AUTH        "DisableClearTextAuthentication"

#define INETA_DISABLE_NET_DRIVES_SHARING_DEF    1
#define INETA_DISABLE_CLEARTEXT_AUTH_DEF        0

//
// end - Win95 specific
//

#endif // _INETREG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\instance.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        instance.cxx

   Abstract:

        Defines the functions for TCP services Info class.
        This module is intended to capture the common scheduler
            code for the tcp services ( especially internet services)
            which involves the Service Controller dispatch functions.
        Also this class provides an interface for common dll of servers.

   Author:

           Murali R. Krishnan    ( MuraliK )     15-Nov-1994

   Project:

          Internet Servers Common DLL

--*/


#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisbind.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"
#include <imd.h>
#include <mb.hxx>

#include "reftrce2.h"

/************************************************************
 *    Symbolic Constants
 ************************************************************/

//
// LOCAL Functions
//

static ULONGLONG InetServiceIdForService( IN DWORD serviceId);

#define MAX_ADDRESSES_SUPPORTED           20
#define SIZEOF_IP_SEC_LIST( IPList )      (sizeof(INET_INFO_IP_SEC_LIST) + \
                                           (IPList)->cEntries *        \
                                           sizeof(INET_INFO_IP_SEC_ENTRY))


#if SERVICE_REF_TRACKING
//
//  Ref count trace log size
//
#define C_INSTANCE_REFTRACES        4000
#define C_LOCAL_INSTANCE_REFTRACES    40

#endif // SERVICE_REF_TRACKING
//
PTRACE_LOG IIS_SERVER_INSTANCE::sm_pDbgRefTraceLog = NULL;


IIS_SERVER_INSTANCE::IIS_SERVER_INSTANCE(
        IN PIIS_SERVICE pService,
        IN DWORD  dwInstanceId,
        IN USHORT sPort,
        IN LPCSTR lpszRegParamKey,
        IN LPWSTR lpwszAnonPasswordSecretName,
        IN LPWSTR lpwszVirtualRootsSecretName,
        IN BOOL   fMigrateVroots
        )
/*++
    Desrcription:

        Contructor for IIS_SERVER_INSTANCE class.
        This constructs a new service info object for the service specified.

    Arguments:

        pService - pointer to the service object.

        dwInstanceId - Instance number of this instance.

        sPort - Default port number

        lpszRegParamKey
            fully qualified name of the registry key that contains the
            common service data for this server

        lpszAnonPasswordSecretName
            The name of the LSA secret the anonymous password is stored under

        lpszVirtualRootsSecretName
            The name of the LSA secret the virtual root passwords are stored
            under

    On success it initializes all the members of the object,
     inserts itself to the global list of service info objects and
     returns with success.

    Note:
        The caller of this function should check the validity by
        invoking the member function IsValid() after constructing
        this object.

--*/
:
    m_tslock              ( ),
    m_fZapRegKey          ( FALSE),
    m_fDoServerNameCheck  ( FALSE),
    m_reference           ( 0),
    m_pDbgRefTraceLog     ( NULL),
    m_sDefaultPort        ( sPort ),
    m_dwServerState       ( MD_SERVER_STATE_STOPPED),
    m_dwSavedState        ( MD_SERVER_STATE_STOPPED),
    m_Service             ( pService),
    m_instanceId          ( dwInstanceId),
    m_strParametersKey    ( lpszRegParamKey),
    m_cReadLocks          ( 0),
    m_lpwszAnonPasswordSecretName( lpwszAnonPasswordSecretName ),
    m_lpwszRootPasswordSecretName( lpwszVirtualRootsSecretName ),
    m_strMDPath           ( ),
    m_strSiteName         ( ),
    m_strMDVirtualRootPath( ),
    m_dwMaxConnections    ( INETA_DEF_MAX_CONNECTIONS),
    m_dwMaxEndpointConnections( INETA_DEF_MAX_ENDPOINT_CONNECTIONS ),
    m_dwCurrentConnections( 0),
    m_dwConnectionTimeout ( INETA_DEF_CONNECTION_TIMEOUT),
    m_dwServerSize        ( INETA_DEF_SERVER_SIZE),
    m_nAcceptExOutstanding( INETA_DEF_ACCEPTEX_OUTSTANDING),
    m_AcceptExTimeout     ( INETA_DEF_ACCEPTEX_TIMEOUT),
    m_dwLevelsToScan      ( INETA_DEF_LEVELS_TO_SCAN ),
    m_fAddedToServerInstanceList( FALSE ),
    m_pBandwidthInfo      ( NULL )
{

    BOOL                    fReferenced = FALSE;

    DBG_ASSERT( lpszRegParamKey != NULL );

    IF_DEBUG(INSTANCE) {
        DBGPRINTF( ( DBG_CONTEXT,"Creating iis instance %p [%u]. \n",
                     this, dwInstanceId));
    }

    //
    // Limit PWS connections
    //

    if ( !TsIsNtServer() ) {
        m_dwMaxConnections = INETA_DEF_MAX_CONNECTIONS_PWS;
    }

    //
    // initialize locks
    //

    INITIALIZE_CRITICAL_SECTION(&m_csLock);

    //
    // initialize binding support
    //

    InitializeListHead( &m_NormalBindingListHead );
    InitializeListHead( &m_SecureBindingListHead );

#if SERVICE_REF_TRACKING
    m_pDbgRefTraceLog = CreateRefTraceLog(C_LOCAL_INSTANCE_REFTRACES, 0);
#endif // SERVICE_REF_TRACKING

    //
    // reference the service
    //

    if ( !pService->CheckAndReference( )) {
        goto error_exit;
    }
    
    //
    // remember if we referenced the service
    //
    
    fReferenced = TRUE;

    m_Service = pService;

    //
    // Set the metabase path
    //

    if ( QueryInstanceId() == INET_INSTANCE_ROOT ) {

        DBG_ASSERT( FALSE );

    } else {

        CHAR szTemp[64];

        wsprintf(szTemp,"/%s/%s/%d",
            IIS_MD_LOCAL_MACHINE_PATH,
            pService->QueryServiceName(),
            QueryInstanceId());

        m_strMDPath.Copy(szTemp);

        wsprintf(szTemp,"/%s/%s/%d/%s/",
            IIS_MD_LOCAL_MACHINE_PATH,
            pService->QueryServiceName(),
            QueryInstanceId(),
            IIS_MD_INSTANCE_ROOT );

        m_strMDVirtualRootPath.Copy(szTemp);

        /* This doesn't do anything.

        if ( fMigrateVroots ) {
            MoveVrootFromRegToMD();
        }

        */
    }

    //
    // Initialize the bare minimum parameters needed to start.
    //

    if ( !RegReadCommonParams( FALSE, FALSE))
    {
        goto error_exit;
    }

    //
    // Set a reasonable initial state.
    //

    SetServerState(
        MD_SERVER_STATE_STOPPED,
        NO_ERROR
        );

    //
    // link this to the service
    //

    if ( dwInstanceId != INET_INSTANCE_ROOT ) {
        if ( !pService->AddServerInstance( this ) ) {
            DBG_ASSERT(m_reference == 0);
            goto error_exit;
        }
        DBG_ASSERT(m_reference == 1);
    }

    m_fAddedToServerInstanceList = TRUE;
    return;

error_exit:

    if ( fReferenced )
    {
        m_Service->Dereference();
    }

    m_dwServerState = MD_SERVER_STATE_INVALID;
    DBG_ASSERT(m_reference == 0);
    return;

} // IIS_SERVER_INSTANCE::IIS_SERVER_INSTANCE()



IIS_SERVER_INSTANCE::~IIS_SERVER_INSTANCE( VOID)
/*++

    Description:

        Cleanup the instance object. If the service is not already
         terminated, it terminates the service before cleanup.

    Arguments:
        None

    Returns:
        None

--*/
{
    DBG_ASSERT(m_dwServerState != MD_SERVER_STATE_STARTED);
    DBG_ASSERT(m_reference == 0);

    //
    //  If we failed to create this instance or it's getting deleted, remove
    //  the configuration tree
    //

    if ( m_fZapRegKey ) {
        DBGPRINTF((DBG_CONTEXT,"Zapping reg key for %p\n",this));
        ZapRegistryKey( NULL, QueryRegParamKey() );
        ZapInstanceMBTree( );
    }

    //
    // endpoints should have been dereferenced
    //

    DBG_ASSERT(IsListEmpty( &m_NormalBindingListHead ));
    DBG_ASSERT(IsListEmpty( &m_SecureBindingListHead ));

    //
    // dereference the service
    //

    if ( m_fAddedToServerInstanceList && m_Service != NULL ) {
        m_Service->Dereference( );
    }

    //
    // destroy bandwidth throttling descriptor
    //

    if ( m_pBandwidthInfo != NULL )
    {
        AtqFreeBandwidthInfo( m_pBandwidthInfo );
        m_pBandwidthInfo = NULL;
    }

#if SERVICE_REF_TRACKING
    DestroyRefTraceLog( m_pDbgRefTraceLog );
#endif // SERVICE_REF_TRACKING

    DeleteCriticalSection(&m_csLock);

} // IIS_SERVER_INSTANCE::~IIS_SERVER_INSTANCE()




//
//  Static Functions belonging to IIS_SERVICE class
//

BOOL
IIS_SERVER_INSTANCE::Initialize( VOID)
/*++
    Description:

        This function initializes all necessary local data for
        IIS_SERVER_INSTANCE class

        Only the first initialization call does the initialization.
        Others return without any effect.

        Should be called from the entry function for DLL.

    Arguments:
        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
#if SERVICE_REF_TRACKING
    if (sm_pDbgRefTraceLog == NULL)
    {
        sm_pDbgRefTraceLog = CreateRefTraceLog(C_INSTANCE_REFTRACES, 0);
        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((DBG_CONTEXT,"IIS_SERVER_INSTANCE RefTraceLog=%p\n",
                       sm_pDbgRefTraceLog));
        }
    }
#endif // SERVICE_REF_TRACKING

    return TRUE;
}



VOID
IIS_SERVER_INSTANCE::Cleanup(
                        VOID
                        )
/*++
    Description:

        Cleanup the data stored.
        This function should be called only after freeing all the
        services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        None

    Returns:
        None

--*/
{
#if SERVICE_REF_TRACKING
    if (sm_pDbgRefTraceLog != NULL)
    {
        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((DBG_CONTEXT,
                       "IIS_SERVER_INSTANCE: Closing RefTraceLog=%p\n",
                       sm_pDbgRefTraceLog));
        }
        DestroyRefTraceLog( sm_pDbgRefTraceLog );
    }
    sm_pDbgRefTraceLog = NULL;
#endif // SERVICE_REF_TRACKING
}



# if 0

VOID
IIS_SERVER_INSTANCE::Print( VOID) const
{
    IIS_SERVER_INSTANCE::Print();

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing IIS_SERVER_INSTANCE object ( %08p) \n"
                " State = %u.\n"
                ,
                this, m_dwServerState
                ));

    DBGPRINTF(( DBG_CONTEXT,
               " Server Admin Params: \n"
               " Log Anon = %u. Log NonAnon = %u.\n"
               ,
               m_fLogAnonymous, m_fLogNonAnonymous
               ));

    DBGPRINTF(( DBG_CONTEXT,
               " Printing IIS_SERVER_INSTANCE object (%08p)\n"
               " Readers # = %u.\n"
               " Reg Parameters Key = %s\n"
               " MaxConn = %d. ConnTimeout = %u secs.\n"
               ,
               this,
               m_cReadLocks,
               m_strParametersKey.QueryStr(),
               m_dwMaxConnections, m_dwConnectionTimeout
               ));
    return;
}   // IIS_SERVER_INSTANCE::Print()

#endif // DBG


VOID
IIS_SERVER_INSTANCE::Reference(  )
{
    InterlockedIncrement( &m_reference );
    LONG lEntry = SHARED_LOG_REF_COUNT();
    LOCAL_LOG_REF_COUNT();
    IF_DEBUG( INSTANCE )
        DBGPRINTF((DBG_CONTEXT, "IIS_SERVER_INSTANCE ref count %ld\n (%ld)",
                   m_reference, lEntry));
}

VOID
IIS_SERVER_INSTANCE::Dereference( )
{
    LONG lEntry = SHARED_EARLY_LOG_REF_COUNT();
    LOCAL_EARLY_LOG_REF_COUNT();

    LONG Reference = InterlockedDecrement( &m_reference );
    if ( 0 == Reference) {
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT, "deleting IIS_SERVER_INSTANCE %p (%ld)\n",
                       this, lEntry));
        delete this;
    } else {
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT, "IIS_SERVER_INSTANCE deref count %ld (%ld)\n",
                       Reference, lEntry));
    }
}


VOID
IIS_SERVER_INSTANCE::ZapInstanceMBTree(
    VOID
    )
{

    MB  mb( (IMDCOM*) m_Service->QueryMDObject()  );

    //
    // Do the metabase
    //

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Deleting metabase node %s\n",
                  QueryMDPath()));
    }

    if ( !mb.Open( "/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Open MD instance root %s returns %d\n",
                      "/", GetLastError() ));
        }
        return;
    }

    //
    // Delete the instance tree
    //

    if ( !mb.DeleteObject( QueryMDPath() ))
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,
                      "Deleting instance node %s returns %d\n",
                      QueryMDPath(),
                      GetLastError()));
        }
    }

    return;

} // IIS_SERVER_INSTANCE::ZapInstanceMBTree


DWORD
IIS_SERVER_INSTANCE::BindInstance(
    VOID
    )
/*++

Routine Description:

    Binds an instance to all configured endpoints (normal & secure).

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    DWORD err;

    //
    // Update the "normal" (i.e. non-secure) bindings.
    //

    err = UpdateNormalBindings();

    if( err != NO_ERROR ) {

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT, "UpdateNormalBindings() failed, %lu\n", err));
        }

        return err;

    }

    //
    // Update the secure bindings.
    //

    err = UpdateSecureBindings();

    if( err != NO_ERROR ) {

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT, "UpdateSecureBindings() failed, %lu\n", err));
        }

        //
        // The main port(s) are OK, but the SSL port(s) failed,
        // so start anyway.
        //

        err = NO_ERROR;

    }

    //
    // Success!
    //

    DBG_ASSERT( err == NO_ERROR );
    return NO_ERROR;

}   // IIS_SERVER_INSTANCE::BindInstance


DWORD
IIS_SERVER_INSTANCE::UnbindInstance(
    VOID
    )
/*++

Routine Description:

    Removes all bindings from an instance.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    LockThisForWrite();
    DBG_REQUIRE( RemoveNormalBindings() == NO_ERROR );
    DBG_REQUIRE( RemoveSecureBindings() == NO_ERROR );
    UnlockThis();

    return NO_ERROR;

}   // IIS_SERVER_INSTANCE::UnbindInstance


DWORD
IIS_SERVER_INSTANCE::UnbindHelper(
    IN PLIST_ENTRY BindingListHead
    )
/*++

Routine Description:

    Helper routine for UnbindInstance().

Arguments:

    BindingListHead - The binding list to remove.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    PLIST_ENTRY listEntry;
    PIIS_SERVER_BINDING binding;

    //
    // Walk the list of bindings and destroy them.
    //

    while( !IsListEmpty( BindingListHead ) ) {

        listEntry = RemoveHeadList( BindingListHead );

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "unbinding %p from %p, binding %p (%lx:%d:%s)\n",
                binding->QueryEndpoint(),
                this,
                binding,
                binding->QueryIpAddress(),
                binding->QueryEndpoint()->QueryPort(),
                binding->QueryHostName()
                ));
        }

        binding->QueryEndpoint()->RemoveInstance(
            this,
            binding->QueryIpAddress(),
            binding->QueryHostName()
            );

        binding->QueryEndpoint()->Dereference();
        delete binding;

    }

    //
    // Success!
    //

    return NO_ERROR;

}   // IIS_SERVER_INSTANCE::UnbindHelper


DWORD
IIS_SERVER_INSTANCE::UpdateBindingsHelper(
    IN BOOL IsSecure
    )
/*++

Routine Description:

    Helper routine for UpdateNormalBindings() and UpdateSecureBindings().

Arguments:

    IsSecure - TRUE if we're to update the secure bindings, FALSE for
        the normal bindings.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    MB mb( (IMDCOM*)m_Service->QueryMDObject() );
    MULTISZ msz;
    DWORD status = NO_ERROR;
    const CHAR * scan;
    DWORD ipAddress;
    USHORT ipPort;
    const CHAR * hostName;
    PIIS_SERVER_BINDING binding;
    LIST_ENTRY createdBindings;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY targetBindingListHead;
    USHORT targetDefaultPort;
    DWORD targetMetadataId;
    DWORD numBindings = 0;
    const CHAR * apszSubStrings[2];
    CHAR instanceIdString[sizeof("4294967295")];
    DWORD fDisableSocketPooling;

    //
    // Setup locals.
    //

    InitializeListHead( &createdBindings );

    if( IsSecure ) {
        targetBindingListHead = &m_SecureBindingListHead;
        targetDefaultPort = 0;
        targetMetadataId = MD_SECURE_BINDINGS;
    } else {
        targetBindingListHead = &m_NormalBindingListHead;
        targetDefaultPort = m_sDefaultPort;
        targetMetadataId = MD_SERVER_BINDINGS;
    }

    //
    // Open the metabase and get the current binding list.
    //

    if( mb.Open( QueryMDPath() ) ) {

        if( !mb.GetMultisz(
                "",
                targetMetadataId,
                IIS_MD_UT_SERVER,
                &msz
                ) ) {

            status = GetLastError();

        }

        //
        // Get socket pooling flag.
        //

        mb.GetDword( "",
                     MD_DISABLE_SOCKET_POOLING,
                     IIS_MD_UT_SERVER,
                     FALSE,
                     &fDisableSocketPooling
                     );
        //
        // Close the metabase before continuing, as anyone that needs
        // to update the service status will need write access.
        //

        mb.Close();

    } else {

        status = GetLastError();

    }

    //
    // Lock the instance.
    //

    LockThisForWrite();

    if ( status == MD_ERROR_DATA_NOT_FOUND ) {
        //
        // if the bindings just don't exist (as happens on service creation)
        // don't log an error.
        //
        goto fatal_nolog;
    } else if( status != NO_ERROR ) {
        goto fatal;
    }

    //
    // Scan the multisz and look for instances we'll need to create.
    //

    for( scan = msz.First() ;
         scan != NULL ;
         scan = msz.Next( scan ) ) {

        //
        // Parse the descriptor (in "ip_address:port:host_name" form)
        // into its component parts.
        //

        status = IIS_SERVER_BINDING::ParseDescriptor(
                                         scan,
                                         &ipAddress,
                                         &ipPort,
                                         &hostName
                                         );

        if( status == NO_ERROR ) {

            if( IsSecure ) {

                //
                // Secure bindings cannot key off the hostname, as
                // the hostname is encrypted in the header.
                //

                if( *hostName != '\0' ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "Secure bindings cannot have host name! %s\n",
                        scan
                        ));

                    wsprintfA(
                        instanceIdString,
                        "%lu",
                        QueryInstanceId()
                        );

                    apszSubStrings[0] = (const CHAR *)instanceIdString;
                    apszSubStrings[1] = (const CHAR *)scan;

                    m_Service->LogEvent(
                        INET_SVC_INVALID_SECURE_BINDING,
                        2,
                        apszSubStrings
                        );

                    //
                    // Press on regardless, but ignore the hostname.
                    //

                    hostName = "";

                }

            }

            //
            // See if the descriptor is in our current binding list.
            //

            if( IsInCurrentBindingList(
                    targetBindingListHead,
                    ipAddress,
                    ipPort,
                    hostName
                    ) ) {

                //
                // It is, so remember that we have a binding.
                //

                numBindings++;

            } else {

                //
                // It's not, so we need to create a new binding.
                //

                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "Adding %lx:%d:%s\n",
                        ipAddress,
                        ipPort,
                        hostName
                        ));
                }

                DBG_CODE( binding = NULL );

                status = CreateNewBinding(
                             ipAddress,
                             ipPort,
                             hostName,
                             IsSecure,
                             fDisableSocketPooling,
                             &binding
                             );

                if( status == NO_ERROR ) {

                    //
                    // Add the new binding to the local list of
                    // newly created bindings.
                    //

                    DBG_ASSERT( binding != NULL );

                    InsertTailList(
                        &createdBindings,
                        &binding->m_BindingListEntry
                        );

                    numBindings++;

                } else {

                    //
                    // Could not create the new binding.
                    //
                    // Press on regardless.
                    //

                }

            }

        } else {

            //
            // Could not parse the descriptor.
            //

            DBGPRINTF((
                DBG_CONTEXT,
                "UpdateNormalBindings: could not parse %s, error %lu\n",
                scan,
                status
                ));

            wsprintfA(
                instanceIdString,
                "%lu",
                QueryInstanceId()
                );

            apszSubStrings[0] = (const CHAR *)instanceIdString;
            apszSubStrings[1] = (const CHAR *)scan;

            m_Service->LogEvent(
                INET_SVC_INVALID_BINDING,
                2,
                apszSubStrings
                );

            //
            // Press on regardless.
            //

        }

    }

    if( status != NO_ERROR ) {

        if( numBindings == 0 ) {

            //
            // All bindings failed, so fail the request.
            //

            goto fatal;

        }

        //
        // At least one binding succeeded, so succeed the request.
        //

        status = NO_ERROR;

    }

    //
    // Scan the existing bindings and look for those that need to
    // be deleted.
    //

    listEntry = targetBindingListHead->Flink;

    while( listEntry != targetBindingListHead ) {

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        listEntry = listEntry->Flink;

        if( !IsBindingInMultiSz(
                binding,
                msz
                ) ) {

            //
            // Got one. Remove it from the instance list, dereference
            // the corresponding endpoint, then delete the binding.
            //

            IF_DEBUG( INSTANCE ) {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "zapping %p from %p, binding %p (%lx:%d:%s)\n",
                    binding->QueryEndpoint(),
                    this,
                    binding,
                    binding->QueryIpAddress(),
                    binding->QueryEndpoint()->QueryPort(),
                    binding->QueryHostName()
                    ));
            }

            binding->QueryEndpoint()->RemoveInstance(
                this,
                binding->QueryIpAddress(),
                binding->QueryHostName()
                );

            RemoveEntryList(
                &binding->m_BindingListEntry
                );

            binding->QueryEndpoint()->Dereference();
            delete binding;

        }

    }

    //
    // Move the newly created bindings over to the current binding
    // list.
    //

    targetBindingListHead->Blink->Flink = createdBindings.Flink;
    createdBindings.Flink->Blink = targetBindingListHead->Blink;
    createdBindings.Blink->Flink = targetBindingListHead;
    targetBindingListHead->Blink = createdBindings.Blink;

    UnlockThis();

    DBG_ASSERT( status == NO_ERROR );
    return NO_ERROR;

fatal:

    //
    // An unrecoverable binding error occured. Log an event.
    //

    DBG_ASSERT( status != NO_ERROR );

    wsprintfA(
        instanceIdString,
        "%lu",
        QueryInstanceId()
        );

    apszSubStrings[0] = (const CHAR *)instanceIdString;

    //
    // OK.  Let's avoid a change in the UI by mapping 
    // ERROR_INVALID_PARAMETER to ERROR_DUP_NAME so that the eventlog
    // message is more useful.
    //

    m_Service->LogEvent(
        INET_SVC_FATAL_BINDING_ERROR,
        1,
        apszSubStrings,
        status == ERROR_INVALID_PARAMETER ? ERROR_DUP_NAME : status
        );

fatal_nolog:

    //
    // Loop through the local list of newly created bindings and delete them.
    //

    while( !IsListEmpty( &createdBindings ) ) {

        listEntry = RemoveHeadList(
                        &createdBindings
                        );

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "zapping %p from %p, binding %p (%lx:%d:%s) (ERROR)\n",
                binding->QueryEndpoint(),
                this,
                binding,
                binding->QueryIpAddress(),
                binding->QueryEndpoint()->QueryPort(),
                binding->QueryHostName()
                ));
        }

        binding->QueryEndpoint()->RemoveInstance(
            this,
            binding->QueryIpAddress(),
            binding->QueryHostName()
            );

        binding->QueryEndpoint()->Dereference();
        delete binding;

    }

    UnlockThis();
    return status;

}   // IIS_SERVER_INSTANCE::UpdateBindingsHelper


DWORD
IIS_SERVER_INSTANCE::CreateNewBinding(
    IN DWORD        IpAddress,
    IN USHORT       IpPort,
    IN const CHAR * HostName,
    IN BOOL         IsSecure,
    IN BOOL         fDisableSocketPooling,
    OUT IIS_SERVER_BINDING ** NewBinding
    )
/*++

Routine Description:

    Creates a new binding object for the specified ip address, port, and
    host name, and creates/references the appropriate endpoint object.

Arguments:

    IpAddress - The binding IP address. May be INADDR_ANY.

    IpPort - The binding IP port. Required.

    HostName - The binding host name. May be empty ("").

    IsSecure - TRUE for secure endpoints. Only used if a new endpoint
        is created.

    fDisableSocketPooling - TRUE to create unique endpoints based on both
        port & IP. Only used if a new endpoint is created.

    NewBinding - Receives a pointer to the new binding object if successful.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    PIIS_ENDPOINT endpoint;
    PIIS_SERVER_BINDING binding;
    DWORD status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IpPort != 0 );
    DBG_ASSERT( HostName != NULL );
    DBG_ASSERT( NewBinding != NULL );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    endpoint = NULL;
    binding = NULL;

    //
    // Try to find an endpoint for the specified port.
    //

    endpoint = m_Service->FindAndReferenceEndpoint(
                   IpPort,
                   IpAddress,
                   TRUE,                    // CreateIfNotFound
                   IsSecure,
                   fDisableSocketPooling
                   );

    if( endpoint != NULL ) {

        //
        // Create a new binding.
        //

        binding = new IIS_SERVER_BINDING(
                          IpAddress,
                          IpPort,
                          HostName,
                          endpoint
                          );

        if( binding != NULL ) {

            if( endpoint->AddInstance(
                    this,
                    IpAddress,
                    HostName
                    ) ) {

                endpoint->Reference();
                *NewBinding = binding;
                status = NO_ERROR;

            } else {

                //
                // Could not associate the instance with the endpoint.
                //

                status = GetLastError();
                ASSERT( status != NO_ERROR );

                //
                // if we didn't get an error code back for some reason
                // we choose this one since resource shortages are
                // the most likely failure case.
                //
                if ( NO_ERROR == status ) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                }

            }

        } else {

            //
            // Could not create new binding object.
            //

            status = ERROR_NOT_ENOUGH_MEMORY;

        }

    } else {

        //
        // Could not find & reference endpoint.
        //

        status = ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // Remove the reference added in FindAndReferenceEndpoint().
    //

    if( endpoint != NULL ) {

        endpoint->Dereference();

    }

    //
    // Cleanup if necessary.
    //

    if( status != NO_ERROR ) {

        if( binding != NULL ) {

            delete binding;

        }

    }

    return status;

}   // IIS_SERVER_INSTANCE::CreateNewBinding


BOOL
IIS_SERVER_INSTANCE::IsInCurrentBindingList(
    IN PLIST_ENTRY BindingListHead,
    IN DWORD IpAddress OPTIONAL,
    IN USHORT IpPort,
    IN const CHAR * HostName OPTIONAL
    )
/*++

Routine Description:

    Scans the current binding list looking for the specified IP address,
    port, and host name.

Arguments:

    BindingListHead - The binding list to scan.

    IpAddress - The IP address to search for. May be INADDR_ANY.

    IpPort - The IP port to search for. Required.

    HostName - The host name to search for. May be empty ("").

Return Value:

    BOOL - TRUE if the binding was found, FALSE otherwise.

--*/
{

    PLIST_ENTRY listEntry;
    PIIS_SERVER_BINDING binding;

    //
    // Sanity check.
    //

    DBG_ASSERT( IpPort != 0 );
    DBG_ASSERT( HostName != NULL );

    //
    // Scan the bindings.
    //

    for( listEntry = BindingListHead->Flink ;
         listEntry != BindingListHead ;
         listEntry = listEntry->Flink ) {

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        if( binding->Compare(
                IpAddress,
                IpPort,
                HostName
                ) ) {

            return TRUE;

        }

    }

    return FALSE;

}   // IIS_SERVER_INSTANCE::IsInCurrentBindingList


BOOL
IIS_SERVER_INSTANCE::IsBindingInMultiSz(
    IN PIIS_SERVER_BINDING Binding,
    IN const MULTISZ &msz
    )
/*++

Routine Description:

    Scans the specified MULTISZ object to see if it contains a descriptor
    matching the specified binding object.

Arguments:

    Binding - The binding to search for.

    msz - The MULTISZ to search.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    const CHAR * scan;
    DWORD status;
    BOOL result;

    //
    // Sanity check.
    //

    DBG_ASSERT( Binding != NULL );

    //
    // Scan the MULTISZ.
    //

    for( scan = msz.First() ;
         scan != NULL ;
         scan = msz.Next( scan ) ) {

        status = Binding->Compare( scan, &result );

        if( status == NO_ERROR && result ) {

            return TRUE;

        }

    }

    return FALSE;

}   // IIS_SERVER_INSTANCE::IsBindingInMultiSz

DWORD
IIS_SERVER_INSTANCE::PerformClusterModeChange(
    VOID
    )
/*++

Routine Description:

    Reads the server cluster mode from the metabase and performs any
    necessary changes.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{
    MB      mb( (IMDCOM *)m_Service->QueryMDObject() );
    DWORD   status;
    DWORD   currentState;
    DWORD   serviceState;
    BOOL    fPreviousClusterEnabled;

    //
    // Setup locals.
    //

    status = NO_ERROR;
    fPreviousClusterEnabled = m_fClusterEnabled;
    serviceState = m_Service->QueryCurrentServiceState();
    currentState = QueryServerState();

    //
    // Open the metabase and query the cluster enabled flag
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ ) )
    {
        if( !mb.GetDword(
                "",
                MD_CLUSTER_ENABLED,
                IIS_MD_UT_SERVER,
                (LPDWORD)&m_fClusterEnabled
                ) )
        {
            m_fClusterEnabled = FALSE;

            status = GetLastError();

            IF_DEBUG( INSTANCE )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformClusterModeChange: cannot read server command, error %lu\n",
                    status
                    ));
            }

        }

        //
        // Close it so that code needed to update the metabase when
        // changing state can indeed open the metabase.
        //

        mb.Close();
    }
    else
    {
        status = GetLastError();

        IF_DEBUG( INSTANCE )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "PerformClusterModeChange: cannot open metabase for READ, error %lu\n",
                status
                ));
        }

    }

    //
    // If cluster mode transition from non-cluster to cluster
    // then must make sure that instance is stopped.
    // instance will be started as required by cluster manager.
    //

    if ( status == NO_ERROR &&
         m_fClusterEnabled &&
         !fPreviousClusterEnabled )
    {
        if( ( serviceState == SERVICE_RUNNING ||
              serviceState == SERVICE_PAUSED ) &&
            ( currentState == MD_SERVER_STATE_STARTED ||
              currentState == MD_SERVER_STATE_PAUSED ) ) {

            LockThisForWrite();

            status = StopInstance();

            if( status != NO_ERROR ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformClusterModeChange: cannot stop instance, error %lu\n",
                    status
                    ));

            }

            UnlockThis();
        }

        //
        // Restore the state to the previous value if the state change failed.
        //

        if( status != NO_ERROR ) {
            SetServerState( currentState, status );
        }
    }

    return status;
}

DWORD
IIS_SERVER_INSTANCE::PerformStateChange(
    VOID
    )
/*++

Routine Description:

    Reads the server instance state from the metabase and performs any
    necessary state changes.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    MB mb( (IMDCOM *)m_Service->QueryMDObject() );
    DWORD status;
    DWORD command;
    DWORD currentState;
    DWORD serviceState;

    //
    // Setup locals.
    //

    status = NO_ERROR;
    serviceState = m_Service->QueryCurrentServiceState();
    currentState = QueryServerState();

    //
    // Open the metabase and query the state change command.
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {

        if( !mb.GetDword(
                "",
                IsClusterEnabled() ? MD_CLUSTER_SERVER_COMMAND : MD_SERVER_COMMAND,
                IIS_MD_UT_SERVER,
                &command
                ) ) {

            status = GetLastError();

            IF_DEBUG( INSTANCE ) {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: cannot read server command, error %lu\n",
                    status
                    ));
            }

        }

        //
        //  Update the instance AutoStart value so the instance state is
        //  persisted across service restarts
        //

        if( status == NO_ERROR ) {

            switch( command ) {
            case MD_SERVER_COMMAND_START :

                mb.SetDword(
                   "",
                   MD_SERVER_AUTOSTART,
                   IIS_MD_UT_SERVER,
                   TRUE );
                break;

            case MD_SERVER_COMMAND_STOP :

                mb.SetDword(
                   "",
                   MD_SERVER_AUTOSTART,
                   IIS_MD_UT_SERVER,
                   FALSE );
                break;

            default:
                break;
            }
        }

        //
        // Close it so that code needed to update the metabase when
        // changing state can indeed open the metabase.
        //

        mb.Close();

    } else {

        status = GetLastError();

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "PerformStateChange: cannot open metabase for READ, error %lu\n",
                status
                ));
        }

    }

    //
    // Lock the instance.
    //

    LockThisForWrite();

    //
    // Interpret the command. Note that the StartInstance(), StopInstance(),
    // PauseInstance(), and ContinueInstance() methods will set the instance
    // state if they complete successfully, but it is this routine's
    // responsibility to reset the state to the original value if the
    // methods fail.
    //

    if( status == NO_ERROR ) {

        switch( command ) {

        case MD_SERVER_COMMAND_START :

            //
            // Start the instance.
            //
            // If it's stopped, then start it. If it's in any other state,
            // this is an invalid state transition.
            //
            // Note that the *service* must be running before an instance
            // can be started.
            //

            if( serviceState == SERVICE_RUNNING &&
                currentState == MD_SERVER_STATE_STOPPED ) {

                status = DoStartInstance();

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot start instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid command %lu for state %lu\n",
                    command,
                    currentState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_COMMAND_STOP :

            //
            // Stop the instance.
            //
            // If it's running or paused, then start it. If it's in any
            // other state, this is an invalid state transition.
            //
            // Note that the *service* must be either running or paused
            // before an instance can be paused.
            //

            if( ( serviceState == SERVICE_RUNNING ||
                  serviceState == SERVICE_PAUSED ) &&
                ( currentState == MD_SERVER_STATE_STARTED ||
                  currentState == MD_SERVER_STATE_PAUSED ) ) {

                status = StopInstance();

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot stop instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid command %lu for state %lu\n",
                    command,
                    currentState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_COMMAND_PAUSE :

            //
            // Pause the instance.
            //
            // If it's running, then pause it. If it's in any other state,
            // this is an invalid state transition.
            //
            // Note that the *service* must be running before an instance
            // can be paused.
            //

            if( serviceState == SERVICE_RUNNING &&
                currentState == MD_SERVER_STATE_STARTED ) {

                status = PauseInstance();

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot pause instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid command %lu for state %lu\n",
                    command,
                    currentState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_COMMAND_CONTINUE :

            //
            // Continue the instance.
            //
            // If it's paused, then continue it. If it's in any other
            // state, this is an invalid state transition.
            //
            // Note that the *service* must be running before an instance
            // can be continued.
            //

            if( serviceState == SERVICE_RUNNING &&
                currentState == MD_SERVER_STATE_PAUSED ) {

                status = ContinueInstance();

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot continue instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid command %lu for state %lu\n",
                    command,
                    currentState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        default :
            DBGPRINTF((
                DBG_CONTEXT,
                "PerformStateChange: invalid command %lu\n",
                command
                ));

            status = ERROR_INVALID_SERVICE_CONTROL;
            break;

        }

    } else {

        DBGPRINTF((
            DBG_CONTEXT,
            "PerformStateChange: cannot read metabase, error %lu\n",
            status
            ));

    }

    //
    // Unlock the instance before trying to reopen the metabase.
    //

    UnlockThis();

    //
    // Restore the state to the previous value if the state change failed.
    //

    if( status != NO_ERROR ) {
        SetServerState( currentState, status );
    }

    return status;

}   // IIS_SERVER_INSTANCE::PerformStateChange


VOID
IIS_SERVER_INSTANCE::SetServerState(
    IN DWORD NewState,
    IN DWORD Win32Error
    )
/*++

Routine Description:

    Sets the new server state, storing it locally and also storing the
    new state in the metabase.

Arguments:

    NewState - The new server state.

    Win32Error - New Win32 error value.

Return Value:

    None.

--*/
{

    DWORD status = NO_ERROR;
    MB mb( (IMDCOM *)m_Service->QueryMDObject() );

    //
    // Open the metabase and save the new state. Note that we map
    // MD_SERVER_STATE_INVALID to MD_SERVER_STATE_STOPPED in the metabase.
    // Client applications would probably be confused by the _INVALID state.
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {

        if( !mb.SetDword(
                "",
                MD_WIN32_ERROR,
                IIS_MD_UT_SERVER,
                Win32Error,
                0
                ) ||
            !mb.SetDword(
                "",
                MD_SERVER_STATE,
                IIS_MD_UT_SERVER,
                NewState == MD_SERVER_STATE_INVALID
                    ? MD_SERVER_STATE_STOPPED
                    : NewState,
                0
                ) ) {

            status = GetLastError();

        }

    } else {

        status = GetLastError();

    }

    if( status != NO_ERROR ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "SetServerState: cannot write metabase (%lu), error %lu\n",
            NewState,
            status
            ));

    }

    //
    // Save it in the object also.
    //

    m_dwServerState = NewState;

}   // IIS_SERVER_INSTANCE::SetServerState



BOOL
IIS_SERVER_INSTANCE::StopEndpoints( VOID)
/*++

Routine Description:

    Walks down the list of Endpoints held by the Server instance and
    calls IIS_ENDPOINT::StopEndpoint for the endpoints.

Arguments:

    None

Return Value:

    TRUE if stop is successful,
    FALSE otherwise
--*/
{
    BOOL  fReturn = TRUE;

    //
    // Inside the locked section walk the normal & secure bindings
    //  to stop all relevant endpoints
    //

    LockThisForWrite();

    if (!StopEndpointsHelper( &m_NormalBindingListHead)) {
        fReturn = FALSE;
    }

    if (!StopEndpointsHelper( &m_SecureBindingListHead)) {
        fReturn = FALSE;
    }

    UnlockThis();

    return ( fReturn);

} // IIS_SERVER_INSTANCE::StopEndpoints()


BOOL
IIS_SERVER_INSTANCE::StopEndpointsHelper( PLIST_ENTRY pBindingListHead)
/*++

Routine Description:

    Helper routine for StopEndpoints().
    This function should be called with the Endpoints lock held

Arguments:

    pBindingListHead - pointer to the binding list for endpoints to be stopped

Return Value:

    BOOL  - TRUE on success and FALSE on failure

--*/
{
    BOOL fReturn = TRUE;
    PLIST_ENTRY plBindingScan;
    PIIS_SERVER_BINDING binding;

    //
    // Walk the list of bindings and destroy them.
    //

    for( plBindingScan = pBindingListHead->Flink;
         plBindingScan != pBindingListHead;
         plBindingScan = plBindingScan->Flink
         ) {

        binding = CONTAINING_RECORD(
                      plBindingScan,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "stop ATQ EP of %p from instance %p, "
                " binding %p (%lx:%d:%s)\n",
                binding->QueryEndpoint(),
                this,
                binding,
                binding->QueryIpAddress(),
                binding->QueryEndpoint()->QueryPort(),
                binding->QueryHostName()
                ));
        }

        if ( !binding->QueryEndpoint()->StopEndpoint()) {
            fReturn = FALSE;
        }
    } // for

    //
    // Success!
    //

    return ( fReturn);

}   // IIS_SERVER_INSTANCE::StopEndpointsHelper()




BOOL
IIS_SERVER_INSTANCE::CloseInstance(
    VOID
    )
/*++

Routine Description:

    Shuts down instance

Arguments:

    None

Return Value:

    TRUE if Shutdown successful,
    FALSE otherwise

--*/
{

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::Close called for %p\n",
            this
            ));
    }

    (VOID)m_Service->DisassociateInstance( this );
    return TRUE;

} // IIS_SERVER_INSTANCE::CloseInstance


DWORD
IIS_SERVER_INSTANCE::StartInstance()
/*++

Routine Description:

    Sets instance to RUNNING

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD status;

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::StartInstance called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_STOPPED );

    //
    // Set the transient state.
    //

    SetServerState( MD_SERVER_STATE_STARTING, NO_ERROR );

    //
    // Set cache parameters
    //

    m_tsCache.SetParameters(
                m_Service->QueryServiceId(),
                QueryInstanceId(),
                this );

    if (( QueryInstanceId() != INET_INSTANCE_ROOT ) && IsDownLevelInstance() )
    {
        MoveMDVroots2Registry();
        // no longer supporting migrating VRoots back from the registry
        //PdcHackVRReg2MD( );
    }

    //
    // Read all common parameters and initialize VDirs
    //

    if ( !RegReadCommonParams( TRUE, TRUE)  ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Start logging
    //

    m_Logging.ActivateLogging(
                    m_Service->QueryServiceName(),
                    QueryInstanceId(),
                    m_strMDPath.QueryStr(),
                    m_Service->QueryMDObject() );

    //
    // Verify the service can handle another instance.
    //

    if( !m_Service->RecordInstanceStart() ) {

        m_Logging.ShutdownLogging();
        QueryVrootTable()->RemoveVirtualRoots();

        return ERROR_NOT_SUPPORTED;
    }

    //
    // Bind the instance.
    //

    status = BindInstance();

    if ( status != NO_ERROR ) {

        m_Logging.ShutdownLogging();
        QueryVrootTable()->RemoveVirtualRoots();

        //
        // Tell the service that we failed to start the instance.
        //

        m_Service->RecordInstanceStop();

    }

    return status;

} // IIS_SERVER_INSTANCE::StartInstance


DWORD
IIS_SERVER_INSTANCE::StopInstance()
/*++

Routine Description:

    Sets instance to STOPPED

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD status;

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::StopInstance called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_STARTED ||
                QueryServerState() == MD_SERVER_STATE_PAUSED );

    Reference();

    //
    // Set the transient state.
    //

    SetServerState( MD_SERVER_STATE_STOPPING, NO_ERROR );

    m_Service->StopInstanceProcs( this );

    //
    // Note that we call DisconnectUsersByInstance() before *and* after
    // unbinding the instance. This is to prevent a potential race condition
    // that can occur if another thread is already in IIS_ENDPOINT::
    // FindAndReferenceInstance(), has found the instance, checked its state,
    // and found it to be MD_SERVER_STATE_STARTED. The call to UnbindInstance()
    // will lock any affected endpoints, ensuring that there are no other
    // threads in the midst of a FindAndReferenceInstance(). The second
    // (seemingly redundant) call to DisconnectUsersByInstance() will catch
    // any threads that "snuck in" under these conditions.
    //

    status = m_Service->DisconnectUsersByInstance( this );

    if( status == NO_ERROR ) {
        status = UnbindInstance();
    }

    if( status == NO_ERROR ) {
        status = m_Service->DisconnectUsersByInstance( this );
    }

    if( status == NO_ERROR ) {
        SetServerState( MD_SERVER_STATE_STOPPED, NO_ERROR );
        m_dwSavedState = MD_SERVER_STATE_STOPPED;
        m_Service->RecordInstanceStop();
    }

    //
    // logging cleanup
    //

    DBG_REQUIRE( m_Logging.ShutdownLogging());
    DBG_REQUIRE( QueryVrootTable()->RemoveVirtualRoots());

    Dereference();
    return status;

} // IIS_SERVER_INSTANCE::StopInstance


DWORD
IIS_SERVER_INSTANCE::PauseInstance()
/*++

Routine Description:

    Sets instance to PAUSE

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::Pause called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    //
    // Just set the paused state (no need for a transient state).
    // Setting the instance to paused will prevent new incoming
    // connections on the instance.
    //

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_STARTED );
    SetServerState( MD_SERVER_STATE_PAUSED, NO_ERROR );

    //
    // Success!
    //

    return NO_ERROR;

} // IIS_SERVER_INSTANCE::PauseInstance


DWORD
IIS_SERVER_INSTANCE::ContinueInstance()
/*++

Routine Description:

    Sets instance to STARTED.

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::Continue called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    //
    // Just set the stated state (no need for a transient state).
    // Setting the instance to started will allow new incoming
    // connections on the instance.
    //

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_PAUSED );
    SetServerState( MD_SERVER_STATE_STARTED, NO_ERROR );

    //
    // Success!
    //

    return NO_ERROR;

} // IIS_SERVER_INSTANCE::ContinueInstance


VOID
IIS_SERVER_INSTANCE::SetWin32Error(
    DWORD err
    )
{

    MB mb( (IMDCOM *)m_Service->QueryMDObject() );
    DWORD status = NO_ERROR;

    //
    // Open the metabase and save the error code.
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {

        if( !mb.SetDword(
                "",
                MD_WIN32_ERROR,
                IIS_MD_UT_SERVER,
                err,
                0
                ) ) {

            status = GetLastError();

        }

    } else {

        status = GetLastError();

    }

    if( status != NO_ERROR ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "SetWin32Error: cannot save error %lu (%lx), error %lx\n",
            err,
            err,
            status
            ));

    }

}   // IIS_SERVER_INSTANCE::SetWin32Error

BOOL
IIS_SERVER_INSTANCE::SetBandwidthThrottle(
    IN MB *              pMB
)
/*++

Routine Description:

    Set the bandwidth throttle threshold for this instance

Arguments:

    pMB - pointer to metabase handle

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    DWORD       dwBandwidth;

    if ( !TsIsNtServer() )
    {
        return TRUE;
    }

    DBG_ASSERT( pMB != NULL );

    if ( !pMB->GetDword( "",
                         MD_MAX_BANDWIDTH,
                         IIS_MD_UT_SERVER,
                         &dwBandwidth,
                         0 ) )
    {
        VOID * pTemp;

        pTemp = InterlockedExchangePointer( (PVOID *) &m_pBandwidthInfo, NULL );

        if ( pTemp )
        {
            DBG_REQUIRE( AtqFreeBandwidthInfo( pTemp ) );
        }
    }
    else
    {
        if ( m_pBandwidthInfo == NULL )
        {
            VOID * pTemp = AtqCreateBandwidthInfo();
            if ( pTemp != NULL )
            {
                AtqBandwidthSetInfo( pTemp,
                                     ATQ_BW_BANDWIDTH_LEVEL,
                                     dwBandwidth );

                AtqBandwidthSetInfo( pTemp,
                                     ATQ_BW_DESCRIPTION,
                                     (ULONG_PTR) m_strMDPath.QueryStr() );

                InterlockedExchangePointer( (PVOID *) &m_pBandwidthInfo, (PVOID) pTemp );
            }
        }
        else
        {
            AtqBandwidthSetInfo( m_pBandwidthInfo,
                                 ATQ_BW_BANDWIDTH_LEVEL,
                                 (ULONG_PTR)dwBandwidth );
        }
    }

    return TRUE;
}

BOOL
IIS_SERVER_INSTANCE::SetBandwidthThrottleMaxBlocked(
    IN MB *             pMB
)
{
    DWORD               dwMaxBlocked = INFINITE;

    if ( !TsIsNtServer() )
    {
        return TRUE;
    }

    DBG_ASSERT( pMB != NULL );

    if ( pMB->GetDword( "",
                        MD_MAX_BANDWIDTH_BLOCKED,
                        IIS_MD_UT_SERVER,
                        &dwMaxBlocked,
                        0 ) )
    {
        if ( m_pBandwidthInfo )
        {
            AtqBandwidthSetInfo( m_pBandwidthInfo,
                                 ATQ_BW_MAX_BLOCKED,
                                 dwMaxBlocked );
        }
    }
    return TRUE;
}

DWORD
IIS_SERVER_INSTANCE::DoStartInstance(
    VOID
)
/*++

Routine Description:

    Start an instance.  This call encompasses the IIS_SERVER_INSTANCE and
    inherited invocations of StartInstance

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{
    DWORD               dwError;

    dwError = StartInstance();
    if ( dwError == NO_ERROR )
    {
        if( m_Service->QueryCurrentServiceState() == SERVICE_PAUSED )
        {
            SetServerState( MD_SERVER_STATE_PAUSED, NO_ERROR );
        }
        else
        {
            SetServerState( MD_SERVER_STATE_STARTED, NO_ERROR );
        }
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\mbsink.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      mbsink.cxx

   Abstract:

      This module implements the metabase notification support

   Author:

      Johnl         01-Nov-1996

   Project:

      Internet Services Common DLL

   Functions Exported:


   Revision History:

--*/


#include <tcpdllp.hxx>
#include <objbase.h>
#include <initguid.h>
#include <ole2.h>
#include <imd.h>
#include <iistypes.hxx>
#include <issched.hxx>

//
//  Constants
//

//
//  Derived metadata sink object
//

class CImpIMDCOMSINK : public IMDCOMSINK {

public:

    CImpIMDCOMSINK();
    ~CImpIMDCOMSINK();


    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    HRESULT STDMETHODCALLTYPE ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

    HRESULT STDMETHODCALLTYPE ComMDShutdownNotify()
    {
        return RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
    }

private:
    ULONG m_dwRefCount;
};


//
//  Globals
//

DWORD               g_dwSinkCookie = 0;
CImpIMDCOMSINK *    g_pEventSink = NULL;
IConnectionPoint *  g_pConnPoint = NULL;



//
//  Functions
//


BOOL
InitializeMetabaseSink(
    IUnknown * pmb
    )
{

    IConnectionPointContainer * pConnPointContainer = NULL;
    HRESULT                     hRes;
    BOOL                        fSinkConnected = FALSE;

    g_pEventSink = new CImpIMDCOMSINK();

    if ( !g_pEventSink )
    {
        return FALSE;
    }

    //
    // First query the object for its Connection Point Container. This
    // essentially asks the object in the server if it is connectable.
    //

    hRes = pmb->QueryInterface( IID_IConnectionPointContainer,
                                (PVOID *)&pConnPointContainer);
    if SUCCEEDED(hRes)
    {
        // Find the requested Connection Point. This AddRef's the
        // returned pointer.

        hRes = pConnPointContainer->FindConnectionPoint( IID_IMDCOMSINK,
                                                         &g_pConnPoint);

        if (SUCCEEDED(hRes))
        {
            hRes = g_pConnPoint->Advise( (IUnknown *)g_pEventSink,
                                          &g_dwSinkCookie);

            if (SUCCEEDED(hRes))
            {
                fSinkConnected = TRUE;
            }
        }

        if ( pConnPointContainer )
        {
            pConnPointContainer->Release();
            pConnPointContainer = NULL;
        }
    }

    if ( !fSinkConnected )
    {
        delete g_pEventSink;
        g_pEventSink = NULL;
    }

    return fSinkConnected;
}



VOID
TerminateMetabaseSink(
    VOID
    )
{
    HRESULT hRes;

    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateMetabaseSink] Cleaning up sinc notification\n" ));

    if ( g_dwSinkCookie )
    {
        hRes = g_pConnPoint->Unadvise( g_dwSinkCookie );
    }

    g_pEventSink = NULL;
}




CImpIMDCOMSINK::CImpIMDCOMSINK()
{
    m_dwRefCount=0;
}

CImpIMDCOMSINK::~CImpIMDCOMSINK()
{
}




HRESULT
CImpIMDCOMSINK::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK) {
        *ppObject = (IMDCOMSINK *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIMDCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIMDCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINK::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;


    IIS_SERVICE::MDChangeNotify( dwMDNumElements,
                                 pcoChangeList );
#if 0
    DBGPRINTF(( DBG_CONTEXT,
                "Recieved callback for handle 0x%08x, NumElements = %d\n",
                hMDHandle,
                dwMDNumElements ));

    for (i = 0; i < dwMDNumElements; i++)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Change Type = %X, Path = %s, NumIDs = %d\n",
                    pcoChangeList[i].dwMDChangeType,
                    pcoChangeList[i].pszMDPath,
                    pcoChangeList[i].dwMDNumDataIDs ));

        for ( j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++ )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\tid[j] = %6d  ",
                        pcoChangeList[i].pdwMDDataIDs[j] ));
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "\n" ));
    }
#endif

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\mimeutil.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mimeutil.cxx

   Abstract:

      This module defines MIME utility functions: Initialize and Cleanup
        of global MimeMap. Also provides function for obtaining the MimeType
        for given file extension

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Jan-1995

   Environment:

       Win32

   Project:

       TCP Internet services common dll

   Functions Exported:

       BOOL InitializeMimeMap( VOID)
       BOOL CleanupMimeMap( VOID)


   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include <tcpdllp.hxx>

# include <tchar.h>
# include "mimemap.hxx"
# include <iistypes.hxx>

# define   PSZ_MIME_MAP       TEXT( "MimeMap")

PMIME_MAP     g_pMimeMap = NULL;


/************************************************************
 *    Functions
 ************************************************************/


BOOL
InitializeMimeMap(
    IN LPCTSTR  pszRegEntry
    )
/*++

  Creates a new mime map object and loads the registry entries from
    under this entry from  \\MimeMap.


--*/
{
    BOOL fReturn = FALSE;

    DBG_ASSERT( g_pMimeMap == NULL);

    g_pMimeMap = new MIME_MAP();

    if ( g_pMimeMap != NULL) {


        DWORD dwError;

        dwError = g_pMimeMap->InitMimeMap( );

        if ( dwError == NO_ERROR ) {
            fReturn = TRUE;
        } else {

            DBGPRINTF((DBG_CONTEXT,"InitMimeMap failed with %d\n",
                dwError));

            SetLastError( dwError);
        }
    }

    IF_DEBUG( MIME_MAP ) {

        DBGPRINTF( ( DBG_CONTEXT, "InitializeMimeMap() from Reg %s. returns %d."
                    " Error = %d\n",
                     PSZ_MIME_MAP, fReturn, GetLastError()));
    }

    return ( fReturn);
} // InitializeMimeMap()


BOOL
CleanupMimeMap( VOID)
{
    BOOL fReturn = TRUE;

    if ( g_pMimeMap != NULL) {

         delete g_pMimeMap;
         g_pMimeMap = NULL;
   }

   return ( fReturn);
} // CleanupMimeMap()




BOOL
SelectMimeMappingForFileExt(
    IN const PIIS_SERVICE pInetSvc,
    IN const TCHAR *       pchFilePath,
    OUT STR *              pstrMimeType,          // optional
    OUT STR *              pstrIconFile)          // optional
/*++
   Locks and obtains the mime type and/or icon file
    for file based on the file extension.

  pTsvcInfo       pointer to service's tsvcinfo object
  pchFilePath     pointer to path for the given file
  pstrMimeType    pointer to string to store the mime type on return
                   ( if ! NULL)
  pstrIconFile    pointer to string to store the icon file name on return
                   ( if ! NULL)

  Returns:
     TRUE on success and
     FALSE if there is any error.

--*/
{
    BOOL  fReturn = TRUE;

    if ( pstrIconFile != NULL || pstrMimeType != NULL) {

        PMIME_MAP  pMm;
        PCMIME_MAP_ENTRY   pMmeMatch;

        DBG_ASSERT( pInetSvc);
        pMm = pInetSvc->QueryMimeMap();

        DBG_ASSERT( pMm != NULL);

        pMmeMatch = pMm->LookupMimeEntryForFileExt( pchFilePath);
        DBG_ASSERT( pMmeMatch != NULL);

        if ( pstrIconFile != NULL) {

            fReturn = fReturn &&
                    pstrIconFile->Copy( pMmeMatch->QueryIconFile());
        }

        if ( pstrMimeType != NULL) {

            fReturn = fReturn &&
                    pstrMimeType->Copy( pMmeMatch->QueryMimeType());
        }
    }

    return ( fReturn);
} // SelectMimeMappingForFileExt()



/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\mimemap.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        mimemap.cxx

   Abstract:

        This module defines the member functions for MIME_MAP class
            and MIME_MAP_ENTRY class

   Author:

           Murali R. Krishnan    ( MuraliK )     10-Jan-1995

   Functions Exported:

        MIME_MAP_ENTRY::MIME_MAP_ENTRY()

        MIME_MAP::MIME_MAP()
        MIME_MAP::~MIME_MAP()
        MIME_MAP::CleanupThis()
        MIME_MAP::InitFromRegistry()
        MIME_MAP::LookupMimeEntryForFileExt()
        MIME_MAP::LookupMimeEntryForMimeType()

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <tchar.h>
# include <tcpdllp.hxx>

# include "mimemap.hxx"
# include "hashtab.hxx"

# include "iistypes.hxx"
# include <imd.h>
# include <mb.hxx>
#if 1 // DBCS
# include <mbstring.h>
#endif


//
// Hard coded defaults for MimeEntries.
//

static const TCHAR  sg_rgchDefaultFileExt[] =  TEXT( "*");

static const TCHAR  sg_rgchDefaultMimeType[] =  TEXT("application/octet-stream");
static TCHAR  sg_rgchDefaultMimeEntry[] =
                        TEXT( "*,application/octet-stream");

/************************************************************
 *    Functions
 ************************************************************/

static LPTSTR
MMNextField( IN OUT LPTSTR *  ppchFields);

static BOOL
ReadMimeMapFromMetabase( MULTISZ *pmszMimeMap );


/************************************************************
 *    MIME_MAP_ENTRY member functions
 ************************************************************/

MIME_MAP_ENTRY::MIME_MAP_ENTRY(
    IN LPCTSTR pchMimeType,
    IN LPCTSTR pchFileExt)
: m_strFileExt      ( pchFileExt),
  m_strMimeType     ( pchMimeType),
  HT_ELEMENT        (),
  m_nRefs           ( 1)
/*++
    This function constructs a new MIME_MAP_ENTRY object.
    After initializing  various fields, it also sets the m_fValid flag.
    The user needs to check MIME_MAP_ENTRY::IsValid() for the newly
     constructed object.
--*/
{
    m_fValid = ( m_strFileExt.IsValid()  &&
                 m_strMimeType.IsValid());

} // MIME_MAP_ENTRY::MIME_MAP_ENTRY()



# if DBG

VOID
MIME_MAP_ENTRY::Print( VOID) const
{

    DBGPRINTF( ( DBG_CONTEXT,
                 "MIME_MAP_ENTRY( %08x)\tRefs=%d\tFileExt=%s\tMimeType=%s\t",
                 this,
                 m_nRefs,
                 m_strFileExt.QueryStr(),
                 m_strMimeType.QueryStr()
                 ));

    return;
} // MIME_MAP_ENTRY::Print()

# endif // DBG



/************************************************************
 *    MIME_MAP member functions
 ************************************************************/

# define NUM_MIME_BUCKETS      (7)

MIME_MAP::MIME_MAP( VOID)
/*++
    This function constructs a new MIME_MAP container object for
     containing the MIME_MAP_ENTRY objects.

    The MIME_MAP object is dummy constructed.
    It is set valid when we initialize the elements and
      create the MmeDefault entry.
--*/
:   m_fValid        ( FALSE),
    m_pMmeDefault   ( NULL),
    m_htMimeEntries ( NUM_MIME_BUCKETS, "MimeMapper", 0)
{
} // MIME_MAP::MIME_MAP()



VOID
MIME_MAP::CleanupThis( VOID)
/*++
    This function cleans up the MIME_MAP object, freeing all
     dynamically allocated space and reinitiallizing the list head.

    Returns:
        None
--*/
{

    if ( m_fValid) {

        // The mime entries in the hash table are cleaned when the hash
        // object is deleted.
        m_htMimeEntries.Cleanup();
        m_pMmeDefault = NULL;
        m_fValid = FALSE;
    }

    return;
} // MIME_MAP::CleanupThis()



static LPTSTR
MMNextField( IN OUT LPTSTR *  ppchFields)
/*++
    This function separates and terminates the next field and returns a
        pointer to the same.
    Also it updates the incoming pointer to point to start of next field.

    The fields are assumed to be separated by commas.

--*/
{
    LPTSTR pchComma;
    LPTSTR pchField = NULL;

    DBG_ASSERT( ppchFields != NULL);

    //
    // Look for a comma in the input.
    // If none present, assume that rest of string
    //  consists of the next field.
    //

    pchField  = *ppchFields;

    if ( ( pchComma = _tcschr( *ppchFields, TEXT(','))) != NULL) {

        //
        // Terminate current field. Store current field name in pchComma and
        //  update *ppchFields to contain the next field.
        //
        *pchComma = TEXT( '\0');    // terminate this field with a NULL.
        *ppchFields = pchComma + 1; // goto next field.

    } else {

        //
        // Assume everything till end of string is the current field.
        //

        *ppchFields = *ppchFields + _tcslen( *ppchFields) + 1;
    }

    pchField = ( *pchField == TEXT( '\0')) ? NULL : pchField;
    return ( pchField);
} // MMNextField()



static PMIME_MAP_ENTRY
ReadAndParseMimeMapEntry( IN OUT LPTSTR * ppszValues)
/*++
    This function parses the string containing next mime map entry and
        related fields and if successful creates a new MIME_MAP_ENTRY
        object and returns it.
    Otherwise it returns NULL.
    In either case, the incoming pointer is updated to point to next entry
     in the string ( past terminating NULL), assuming incoming pointer is a
     multi-string ( double null terminated).

    Arguments:
        ppszValues    pointer to string containing the MimeEntry values.

    Returns:
        On successful MIME_ENTRY being parsed, a new MIME_MAP_ENTRY object.
        On error returns NULL.
--*/
{
    PMIME_MAP_ENTRY  pMmeNew = NULL;
    DBG_ASSERT( ppszValues != NULL);
    LPTSTR pszMimeEntry = *ppszValues;


    IF_DEBUG( MIME_MAP) {

        DBGPRINTF( ( DBG_CONTEXT, "ReadAndParseMimeMapEntry( %s)\n",
                     *ppszValues));
    }

    if ( pszMimeEntry != NULL && *pszMimeEntry != TEXT( '\0')) {

        LPTSTR pchMimeType;
        LPTSTR pchFileExt;

        pchFileExt      = MMNextField( ppszValues);
        pchMimeType     = MMNextField( ppszValues);

        if ( pchMimeType  == NULL  ||
             pchFileExt   == NULL
            )  {

            DBGPRINTF( ( DBG_CONTEXT,
                        " ReadAndParseMimeEntry()."
                        " Invalid Mime String ( %s)."
                        "MimeType( %08x): %s, FileExt( %08x): %s,",
                        pszMimeEntry,
                        pchMimeType, pchMimeType,
                        pchFileExt,  pchFileExt
                        ));

            DBG_ASSERT( pMmeNew == NULL);

        } else {


            // Strip leading dot.

            if (*pchFileExt == '.')
            {
                pchFileExt++;
            }

            pMmeNew = new MIME_MAP_ENTRY( pchMimeType, pchFileExt);

            if ( pMmeNew != NULL && !pMmeNew->IsValid()) {

                //
                // unable to create a new MIME_MAP_ENTRY object. Delete it.
                //
                delete pMmeNew;
                pMmeNew = NULL;
            }
        }
    }

    return ( pMmeNew);
} // ReadAndParseMimeMapEntry()


DWORD
MIME_MAP::InitMimeMap( VOID )
/*++
  This function reads the mimemap stored either as a MULTI_SZ or as a sequence
   of REG_SZ and returns a double null terminated sequence of mime types on
   success. If there is any failure, the failures are ignored and it returns
   a NULL.

  Arguments:

  Returns:
     NULL on failure to open/read metabase entries
     non-NULL string allocated using TCP_ALLOC containing double null
      terminated sequence of strings with MimeMapEntries.
     If non-NULL the pointer should be freed using TCP_FREE by caller.
--*/

{
    DWORD   dwError  = NO_ERROR;
    DWORD   dwErrorChicago  = NO_ERROR;


    if ( IsValid()) {

        //
        //  There is some mime mapping already present. Cleanup first
        //

        CleanupThis();
    }

    DBG_ASSERT( !IsValid());

    // First read INETSERVICES MIME database ( common types will have priority)
    dwError = InitFromMetabase( );

    if (dwError == NO_ERROR ) {
        m_fValid = TRUE;
    }

    //  Now read Chicago shell registration database
    dwErrorChicago = InitFromRegistryChicagoStyle( );

    // If at least one succeeded - return success
    if (dwErrorChicago == NO_ERROR ||
        dwError == NO_ERROR ) {
        m_fValid = TRUE;
        return NO_ERROR;
    }

    return dwError;
}


static VOID
GetFileExtension( IN CONST TCHAR *  pchPathName,
                  OUT LPCTSTR *     ppstrExt,
                  OUT LPCTSTR *     ppstrLastSlash)
{
    LPCTSTR   pchExt  = sg_rgchDefaultFileExt;

    DBG_ASSERT( ppstrExt != NULL && ppstrLastSlash != NULL );

    *ppstrLastSlash = NULL;

    if ( pchPathName ) {

        LPCTSTR   pchLastDot;

        pchLastDot = _tcsrchr( pchPathName, TEXT( '.'));

        if ( pchLastDot != NULL) {

            LPCTSTR   pchLastWhack;

#if 1 // DBCS enabling for document path and file name
            pchLastWhack = (PCHAR)_mbsrchr( (PUCHAR)pchPathName, TEXT( '\\'));
#else
            pchLastWhack = _tcsrchr( pchPathName, TEXT( '\\'));
#endif

            if ( pchLastWhack == NULL) {

                pchLastWhack = pchPathName;  // only file name specified.
            }

            if ( pchLastDot >= pchLastWhack) {
                // if the dot comes only in the last component, then get ext
                pchExt = pchLastDot + 1;  // +1 to skip last dot.
                *ppstrLastSlash = pchLastWhack;
            }
        }

    }
    *ppstrExt = pchExt;
} // GetFileExtension()




DWORD
MIME_MAP::LookupMimeEntryForMimeType(
    IN const STR &                 strMimeType,
    OUT PCMIME_MAP_ENTRY  *        prgMme,
    IN OUT LPDWORD                 pnMmeEntries)
/*++
    This function maps MimeType to an array of MimeMapEntry objects that match
        the given MimeType.

    Before calling this function,
       ensure that you had already locked this object.
    After completing use of the array, unlock the MIME_MAP.
    The reason is:
       To avoid changes in the data while using the read only members of
            MIME_MAP.

    Arguments:
        strMimeType         string containing the MimeType used in search
        prgpMme             pointer to an array of pointers to Mme.
                            The array is initialized to contain the
                              read only pointers to the MIME_MAP_ENTRY objects.
                            If prgpMme is NULL, then
                              number of matches is counted and returned.
        pnMmeEntries        pointer to count of entries in the array
                             ( when called).
                            On successful return contains total numb of entries
                             present in the array or count of entries required.

    Returns:

        NO_ERROR on success.
        ERROR_INSUFFICIENT_BUFFER  if the prgMme does not have enough space for
                copying all the read-only pointers to matched entries.
        other Win32 errors if any.
--*/
{
    DWORD nMaxMme   = 0;
    DWORD iMmeFound = 0;   // index into array for MmeFound
    HT_ITERATOR   hti;
    HT_ELEMENT * phte;

    DBG_ASSERT( IsValid());

    if ( pnMmeEntries != NULL) {

        nMaxMme = *pnMmeEntries;   // max that we can store.
        *pnMmeEntries = 0;         // number found. set to default value
    }

    if ( strMimeType.IsEmpty() || nMaxMme == 0) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( ERROR_INVALID_PARAMETER);
    }

    DWORD dwErr;
    dwErr = m_htMimeEntries.InitializeIterator( &hti);

    if ( NO_ERROR == dwErr) {
        DWORD iMmeFound = 0;

        while ( (dwErr =  m_htMimeEntries.FindNextElement( &hti, &phte))
                == NO_ERROR) {


            PMIME_MAP_ENTRY pMme = (PMIME_MAP_ENTRY ) phte;
            DBG_ASSERT( pMme!= NULL);

            if ( !_tcsicmp( pMme->QueryMimeType(),
                            strMimeType.QueryStr())) {

                //
                // We found the matching Mme. Add it to array of found.
                //

                if ( prgMme != NULL && iMmeFound < nMaxMme) {

                    // store the pointer to found match

                    prgMme[iMmeFound] = pMme;
                }

                iMmeFound++;
            } // found a match

            //
            // release the element foind before fetching the next one
            //
            phte->Dereference();
        } // while
    }

    DBG_REQUIRE( NO_ERROR == m_htMimeEntries.CloseIterator( &hti));

    dwErr = ( iMmeFound > nMaxMme) ? ERROR_INSUFFICIENT_BUFFER : NO_ERROR;

    *pnMmeEntries = iMmeFound;

    return ( dwErr);
} // MIME_MAP::LookupMimeEntryForMimeType()



PCMIME_MAP_ENTRY
MIME_MAP::LookupMimeEntryForFileExt(
    IN const TCHAR *     pchPathName)
/*++
    This function mapes FileExtension to MimeEntry.
    The function returns a single mime entry for given file's extension.
    If no match is found, the default mime entry is returned.
     The returned entry is a readonly pointer and should not be altered.

    The file extension is the key field in the Hash table for mime entries.
    We can use the hash table lookup function to find the entry.

    Arguments:
        pchPathName     pointer to string containing the path for file.
                    ( either full path or just the file name)
                    If NULL, then the default MimeMapEntry is returned.

    Returns:
        If a matching mime entry is found,
               a const pointer to MimeMapEntry object is returned.
        Otherwise the default mime map entry object is returned.

--*/
{
    PMIME_MAP_ENTRY pMmeMatch = m_pMmeDefault;

    DBG_ASSERT( IsValid());

    if ( pchPathName != NULL && *pchPathName ) {

        LPCTSTR         pchExt;
        LPCTSTR         pchLastSlash;

        GetFileExtension( pchPathName, &pchExt, &pchLastSlash );
        DBG_ASSERT( pchExt);
        DWORD cchExt = strlen( pchExt);

        for ( ;; )
        {
            //
            // Successfully got extension. Search in the list of MimeEntries.
            //

            pMmeMatch = (PMIME_MAP_ENTRY ) m_htMimeEntries.Lookup( pchExt, cchExt);

            pchExt--;

            if ( NULL == pMmeMatch)
            {
                pMmeMatch = m_pMmeDefault;

                // Look backwards for another '.' so we can support extensions
                // like ".xyz.xyz" or ".a.b.c".

                if ( pchExt > pchLastSlash )
                {
                    pchExt--;
                    while ( ( pchExt > pchLastSlash ) && ( *pchExt != '.' ) )
                    {
                        pchExt--;
                    }

                    if ( *(pchExt++) != '.' )
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }
            else
            {
                // mime map table is special - we do not handle ref counts
                // at all outside the mime-map object. Neither is there
                // deletion till the program ends. Just deref it here.

                DBG_REQUIRE( pMmeMatch->Dereference() > 0);
                break;
            }
        }
    }

    return ( pMmeMatch);
} // MIME_MAP::LookupMimeEntryForFileExt()



BOOL
MIME_MAP::AddMimeMapEntry( IN PMIME_MAP_ENTRY  pMmeNew)
/*++

    This function adds the new MIME_MAP_ENTRY to the list of entries
     maintained in MIME_MAP

    Arguments:
        pMmeNew      poitner to newly created MimeMapEntry object.

    Returns:
        Win32 error codes. NO_ERROR on success.
--*/
{
    BOOL fReturn = FALSE;

    if ( pMmeNew == NULL || !pMmeNew->IsValid()) {

        SetLastError( ERROR_INVALID_PARAMETER);
        DBG_ASSERT( !fReturn);
    } else {

        DBG_ASSERT( m_htMimeEntries.IsValid());

        fReturn = m_htMimeEntries.Insert( (HT_ELEMENT * ) pMmeNew);

        if ( !_tcscmp( pMmeNew->QueryFileExt(), sg_rgchDefaultFileExt)) {

            m_pMmeDefault = pMmeNew;    // Use this as default
        }
    }

    return ( fReturn);
} // MIME_MAP::AddMimeMapEntry()



# if DBG

VOID
MIME_MAP::Print( VOID)
{
    DBGPRINTF( ( DBG_CONTEXT,
                "MIME_MAP ( %08x). \tIsValid() = %d\n",
                this,  IsValid())
              );


#if 0
    HT_ITERATOR hti;
    HT_ELEMENT * phte;

    DWORD dwErr;

    dwErr = m_htMimeEntries.InitializeIterator( &hti);

    if ( NO_ERROR == dwErr) {

        while ( (dwErr = m_htMimeEntries.FindNextElement( &hti, &phte))
                == NO_ERROR) {

            DBG_ASSERT( NULL != phte);
            phte->Print();
        } // while()
    }

    DBG_REQUIRE( NO_ERROR == m_htMimeEntries.CloseIterator( &hti));
# endif // 0

    m_htMimeEntries.Print( 1);

    if ( m_pMmeDefault != NULL) {

        DBGPRINTF( ( DBG_CONTEXT, "Default MimeMapEntry is: \n"));
        m_pMmeDefault->Print();
    } else {

        DBGPRINTF( ( DBG_CONTEXT, "Default MimeMapEntry is NULL\n"));
    }

    return;

} // MIME_MAP::Print()


# endif // DBG




static BOOL
ReadMimeMapFromMetabase( MULTISZ *pmszMimeMap )
/*++
  This function reads the mimemap stored either as a MULTI_SZ or as a sequence
   of REG_SZ and returns a double null terminated sequence of mime types on
   success. If there is any failure, the failures are ignored and it returns
   a NULL.

  Arguments:
     pszRegKey   pointer to NULL terminated string containing  registry entry.

  Returns:
     NULL on failure to open/read registry entries
     non-NULL string allocated using TCP_ALLOC containing double null
      terminated sequence of strings with MimeMapEntries.
     If non-NULL the pointer should be freed using TCP_FREE by caller.
--*/
{
    MB      mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );

    if ( !mb.Open( "/LM/MimeMap", METADATA_PERMISSION_READ))
    {
        //
        // if this fails, we're hosed.
        //

        DBGPRINTF((DBG_CONTEXT,"Open MD /LM/MimeMap returns %d\n",GetLastError() ));
        return FALSE;
    }

    if (!mb.GetMultisz("", MD_MIME_MAP, IIS_MD_UT_FILE, pmszMimeMap))
    {
        DBGPRINTF((DBG_CONTEXT,"Unable to read mime map from metabase: %d\n",GetLastError() ));
        return FALSE;
    }

    return TRUE;

} // ReadMimeMapFromMetabase()


DWORD
MIME_MAP::InitFromMetabase( VOID )
/*++
    This function reads the MIME_MAP entries from metabase and parses
     the entry, creates MIME_MAP_ENTRY object and adds the object to list
     of MimeMapEntries.

    Arguments:

    Returns:
        Win32 error code. NO_ERROR on success.

    Format of Storage in registry:
        The entries are stored in NT in tbe metabase
          with a list of values in following format.
            file-extension,i mimetype
        It can be stored using MULTI_SZ, but above form is convenient for both
          Windows 95 ( withoug MULTI_SZ) and WindowsNT.

--*/
{
    DWORD   dwError  = NO_ERROR;


    LPTSTR  pszValueAlloc = NULL;    // to be free using TCP_FREE()
    LPTSTR  pszValue;
    MULTISZ mszMimeMap;

    //
    //  There is some registry key for Mime Entries. Try open and read.
    //

    if ( !ReadMimeMapFromMetabase( &mszMimeMap ) )
    {
        mszMimeMap.Reset();

        if (!mszMimeMap.Append(sg_rgchDefaultMimeEntry))
        {
            return GetLastError();
        }
    }

    // Ignore all errors.
    dwError  = NO_ERROR;

    pszValue = (LPTSTR)mszMimeMap.QueryPtr();

    //
    // Parse each MimeEntry in the string containing list of mime objects.
    //

    for( ; m_pMmeDefault == NULL;              // repeat until default is set
        pszValue = sg_rgchDefaultMimeEntry  // force default mapping in iter 2.
        ) {

        while ( *pszValue != TEXT( '\0')) {

            PMIME_MAP_ENTRY pMmeNew;

            pMmeNew = ReadAndParseMimeMapEntry( &pszValue);

            //
            // If New MimeMap entry found, Create a new object and update list
            //

            if ( (pMmeNew != NULL) &&
                !AddMimeMapEntry( pMmeNew)) {

                DBGPRINTF( ( DBG_CONTEXT,
                                "MIME_MAP::InitFromRegistry()."
                                " Failed to add new MIME Entry. Error = %d\n",
                                GetLastError())
                              );

                    delete pMmeNew;
                    //break;
            }
        } // while
    } // for


    return ( dwError);

} // MIME_MAP::InitFromRegistryNtStyle




DWORD
MIME_MAP::InitFromRegistryChicagoStyle( VOID )
/*++
  This function reads the list of MIME content-types available for regsitered file
  extensions. Global list of MIME objects is updated with not added yet extensions.
  This method should be invoked after server-specific map had been read, so it does not
  overwrite extensions common for two.

  Arguments:
     None.

  Returns:

     FALSE on failure to open/read registry entries
     TRUE  on success ( does not mean any objects were added)

--*/
{
    HKEY    hkeyMimeMap = NULL;
    HKEY    hkeyMimeType = NULL;
    HKEY    hkeyExtension = NULL;

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwErrorChild = ERROR_SUCCESS;
    DWORD   dwIndexSubKey;
    DWORD   dwMimeSizeAllowed ;
    DWORD   dwType;
    DWORD   cbValue;

    LPTSTR  pszMimeMap = NULL;

    TCHAR   szSubKeyName[MAX_PATH];
    TCHAR   szExtension[MAX_PATH];

    PTSTR   pszMimeType;

    //
    // Read content types from all registered extensions
    //
    dwError = RegOpenKeyEx(HKEY_CLASSES_ROOT,       // hkey
                           "",                      // reg entry string
                           0,                       // dwReserved
                           KEY_READ,                // access
                           &hkeyMimeMap);           // pHkeyReturned.

    if ( dwError != NO_ERROR) {

        DBGPRINTF( ( DBG_CONTEXT,
                "MIME_MAP::InitFromRegistry(). Cannot open RegKey %s."
                "Error = %d\n",
                "HKCR_",
                dwError) );

          goto AddDefault;
    }

    dwIndexSubKey = 0;

    *szSubKeyName = '\0';
    pszMimeType = szSubKeyName ;

    dwError = RegEnumKey(hkeyMimeMap,
                         dwIndexSubKey,
                         szExtension,
                         sizeof(szExtension));

    while (dwError == ERROR_SUCCESS ) {

        //
        // Some entries in HKEY_CLASSES_ROOT are extensions ( start with dot)
        // and others are file types. We don't need file types here .
        //
        if (!::IsDBCSLeadByte(*szExtension) &&
            TEXT('.') == *szExtension) {

            //
            // Got next eligible extension
            //
            dwErrorChild = RegOpenKeyEx( HKEY_CLASSES_ROOT, // hkey
                                         szExtension,       // reg entry string
                                         0,                 // dwReserved
                                         KEY_READ,          // access
                                         &hkeyExtension);   // pHkeyReturned.

            if ( dwErrorChild != NO_ERROR) {

                DBGPRINTF( ( DBG_CONTEXT,
                             "MIME_MAP::InitFromRegistry(). "
                             " Cannot open RegKey HKEY_CLASSES_ROOT\\%s."
                             "Ignoring Error = %d\n",
                             szExtension,
                             dwErrorChild));
                break;
            }

            //
            // Now get content type for this extension if present
            //
            *szSubKeyName = '\0';
            cbValue = sizeof(szSubKeyName);

            dwErrorChild = RegQueryValueEx(hkeyExtension,
                                         "Content Type",
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&szSubKeyName[0],
                                         &cbValue);
            if ( dwErrorChild == NO_ERROR) {

                //
                // Now we have MIME type and file extension
                // Create a new object and update list
                //

                if (!CreateAndAddMimeMapEntry(szSubKeyName,szExtension)) {
                    dwError = GetLastError();

                    DBGPRINTF( ( DBG_CONTEXT,
                                 "MIME_MAP::InitFromRegistry()."
                                 " Failed to add new MIME Entry. Error = %d\n",
                                 dwError)) ;
                }

            }

            RegCloseKey(hkeyExtension);

        }

        //
        // Attempt to read next extension
        //
        dwIndexSubKey++;

        dwError = RegEnumKey(hkeyMimeMap,
                             dwIndexSubKey,
                             szExtension,
                             sizeof(szExtension));

    } // end_while

    dwError = RegCloseKey( hkeyMimeMap);

AddDefault:

    //
    // Now after we are done with registry mapping - add default MIME type in case
    // if NT database does not exist
    //
    if (!CreateAndAddMimeMapEntry(sg_rgchDefaultMimeType,
                              sg_rgchDefaultFileExt)) {

        dwError = GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                     "MIME_MAP::InitFromRegistry()."
                     "Failed to add new MIME Entry. Error = %d\n",
                     dwError) );
    }

    return ( NO_ERROR);

} // InitFromRegistryChicagoStyle



BOOL
MIME_MAP::CreateAndAddMimeMapEntry(
    IN  LPCTSTR     pszMimeType,
    IN  LPCTSTR     pszExtension
    )
{
    DWORD                   dwError;
    PCMIME_MAP_ENTRY        pEntry = NULL;

    //
    // First check if this extension is not yet present
    //

    pEntry = LookupMimeEntryForFileExt( pszExtension );
    if ( pEntry )
    {
        if ( !_tcscmp( pszExtension, sg_rgchDefaultFileExt ) ||
             ( pEntry != m_pMmeDefault ) )
        {
            IF_DEBUG(MIME_MAP) {
                DBGPRINTF( ( DBG_CONTEXT,
                         "MIME_MAP::CreateAndAddMimeEntry."
                         " New MIME Entry already exists for extension %s .\n",
                        pszExtension)
                       );
            }
            return TRUE;
        }
    }

    //
    // File extensions, stored by OLE/shell registration UI have leading
    // dot, we need to remove it , as other code won't like it.
    //
    if (!::IsDBCSLeadByte(*pszExtension) &&
        TEXT('.') == *pszExtension) {
        pszExtension = ::CharNext(pszExtension);
    }

    PMIME_MAP_ENTRY pMmeNew;

    pMmeNew = new MIME_MAP_ENTRY(pszMimeType,    //
                                  pszExtension   //
                                  );

    if (!pMmeNew || !pMmeNew->IsValid()) {

        //
        // unable to create a new MIME_MAP_ENTRY object.
        //
        if (pMmeNew) {
            delete pMmeNew;
        }
        return FALSE;
    }

    if ( !AddMimeMapEntry( pMmeNew)) {

        dwError = GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                     "MIME_MAP::InitFromRegistry()."
                     " Failed to add new MIME Entry. Error = %d\n",
                     dwError)
                   );

        delete pMmeNew;
        return FALSE;
    }

    return TRUE;

} // MIME_MAP::CreateAndAddMimeMapEntry


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\parse.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        parse.hxx

   Abstract:

        Simple parser class for extrapolating HTTP headers information

   Author:
           John Ludeman     (JohnL)    18-Jan-1995

   Project:
           HTTP server

   Revision History:

--*/

#include <tcpdllp.hxx>
# include <parse.hxx>


INET_PARSER::INET_PARSER(
    CHAR * pszStart
    )
/*++

Routine Description:

    Sets the initial position of the buffer for parsing

Arguments:

    pszStart - start of character buffer
    pszEnd - End of buffer

Return Value:

--*/
    : m_fListMode   ( FALSE ),
      m_pszPos      ( pszStart ),
      m_pszTokenTerm( NULL ),
      m_pszLineTerm ( NULL )
{
    DBG_ASSERT( pszStart );

    //
    //  Chew up any initial white space at the beginning of the buffer
    //  and terminate the first token in the string.
    //

    EatWhite();

    TerminateToken();
}


INET_PARSER::~INET_PARSER(
    VOID
    )
/*++

Routine Description:

    Restores any changes we made to the string while parsing

Arguments:

--*/
{
    RestoreBuffer();
}


CHAR *
INET_PARSER::QueryPos(
    VOID
    )
/*++

Routine Description:

    Removes the terminators and returns the current parser position

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();
    RestoreLine();

    return m_pszPos;
}

VOID
INET_PARSER::SetPtr(
    CHAR * pch
    )
/*++

Routine Description:

    Sets the parser to point at a new location

Arguments:

    pch - New position for parser to start parsing from

Return Value:

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = pch;
}


CHAR *
INET_PARSER::QueryToken(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated token

    If list mode is on, then a comma is considered a delimiter.

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    if ( !m_pszTokenTerm )
        TerminateToken( m_fListMode ? ',' : '\0' );

    return m_pszPos;
}


CHAR *
INET_PARSER::QueryLine(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated line

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    return m_pszPos;
}


BOOL
INET_PARSER::CopyToken(
    STR * pStr,
    BOOL  fAdvanceToken
    )
/*++

Routine Description:

    Copies the token at the current position to *pStr

Arguments:

    pStr - Receives token
    fAdvanceToken - True if we should advance to the next token

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL fRet;

    DBG_ASSERT( pStr );

    if ( !m_pszTokenTerm )
        TerminateToken();

    fRet = pStr->Copy( m_pszPos );

    if ( fAdvanceToken )
        NextToken();

    return fRet;
}


BOOL
INET_PARSER::CopyToEOL(
    STR   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Copies the token at the current character position

Arguments:

--*/
{
    BOOL fRet;

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    fRet = pstr->Copy( m_pszPos );

    if ( fAdvance )
        NextLine();

    return fRet;
}

BOOL
INET_PARSER::AppendToEOL(
    STR   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Same as CopyToEOL except the text from the current line is appended to
    pstr

Arguments:

--*/
{
    BOOL fRet;

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    fRet = pstr->Append( m_pszPos );

    if ( fAdvance )
        NextLine();

    return fRet;
}


CHAR *
INET_PARSER::NextLine(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the first non-white character after the
    next '\n' (or terminating '\0').

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = AuxSkipTo( '\n' );

    if ( *m_pszPos )
        m_pszPos++;

    return EatWhite();
}

CHAR *
INET_PARSER::NextToken(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the next non-white character after the
    current token

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    //
    //  Skip the current token
    //

    EatNonWhite();

    EatWhite();

    TerminateToken();

    return m_pszPos;
}


CHAR *
INET_PARSER::NextToken(
    CHAR ch
    )
/*++

Routine Description:

    Advances the position to the next token after ch (stopping
    at the end of the line)

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    //
    //  Look for the specified character (generally ',' or ';')
    //

    SkipTo( ch );

    if ( *m_pszPos )
        m_pszPos++;

    EatWhite();

    TerminateToken( ch );

    return m_pszPos;
}


CHAR *
INET_PARSER::SkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    m_pszPos = AuxSkipTo( ch );

    return m_pszPos;
}


VOID
INET_PARSER::SetListMode(
    BOOL fListMode
    )
/*++

Routine Description:

    Resets the parser mode to list mode or non-list mode

Arguments:

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    m_fListMode = fListMode;
}

VOID
INET_PARSER::TerminateToken(
    CHAR ch
    )
/*++

Routine Description:

    Zero terminates after the white space of the current token

Arguments:

--*/
{
    DBG_ASSERT( !m_pszTokenTerm );

    m_pszTokenTerm = AuxEatNonWhite( ch );

    m_chTokenTerm = *m_pszTokenTerm;

    *m_pszTokenTerm = '\0';
}

VOID
INET_PARSER::RestoreToken(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszTokenTerm )
    {
        *m_pszTokenTerm = m_chTokenTerm;
        m_pszTokenTerm = NULL;
    }
}

VOID
INET_PARSER::TerminateLine(
    VOID
    )
/*++

Routine Description:

    Zero terminates at the end of this line

Arguments:

--*/
{
    DBG_ASSERT( !m_pszLineTerm );

    m_pszLineTerm = AuxSkipTo( '\n' );

    //
    //  Now trim any trailing white space on the line
    //

    if ( m_pszLineTerm > m_pszPos )
    {
        m_pszLineTerm--;

        while ( m_pszLineTerm >= m_pszPos &&
                ISWHITEA( *m_pszLineTerm ))
        {
            m_pszLineTerm--;
        }
    }

    //
    //  Go forward one (trimming found the last non-white
    //  character)
    //

    if ( *m_pszLineTerm &&
         *m_pszLineTerm != '\n' &&
         !ISWHITEA( *m_pszLineTerm ))
    {
        m_pszLineTerm++;
    }

    m_chLineTerm = *m_pszLineTerm;

    *m_pszLineTerm = '\0';
}

VOID
INET_PARSER::RestoreLine(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszLineTerm )
    {
        *m_pszLineTerm = m_chLineTerm;
        m_pszLineTerm = NULL;
    }
}




CHAR *
INET_PARSER::AuxEatNonWhite(
    CHAR ch
    )
/*++

Routine Description:

    In non list mode returns the first white space character after 
    the current parse position
    In list mode returns the first delimiter ( "';\n" ) character after 
    the current parse position

Arguments:

    ch - Optional character that is considered white space (such as ',' or ';'
        when doing list processing).

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'.  In list mode, comma and semi-colon
    //  are considered delimiters
    //

    if ( !m_fListMode )
    {
        while ( *psz           &&
                *psz != '\n'   &&
                !ISWHITEA(*psz)&&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
    else
    {
        while ( *psz           &&
                *psz != '\n'   &&
#if 0
                // fix #20931
                !ISWHITEA(*psz)&&
#endif
                *psz != ','    &&
                *psz != ';'    &&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
}


CHAR *
INET_PARSER::AuxEatWhite(
    VOID
    )
/*++

Routine Description:

    Returns the first non-white space character after the current parse
    position

Arguments:

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'
    //

    while ( *psz           &&
            *psz != '\n'   &&
            ISWHITEA(*psz))
    {
        psz++;
    }

    return psz;
}


CHAR *
INET_PARSER::AuxSkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    CHAR * psz = m_pszPos;

    while ( *psz           &&
            *psz != '\n'   &&
            *psz != ch )
    {
        psz++;
    }

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\nsistubs.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        nsistubs.cxx

   Abstract:
        non standard interface stubs

   Author:

        Johnson R Apacible  (johnsona)          15-Nov-1996

--*/


#include <tcpdllp.hxx>
#pragma hdrstop
#include <isplat.h>
#include <lonsi.hxx>


dllexp
BOOL
IISDuplicateTokenEx(
    IN  HANDLE hExistingToken,
    IN  DWORD dwDesiredAccess,
    IN  LPSECURITY_ATTRIBUTES lpTokenAttributes,
    IN  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN  TOKEN_TYPE TokenType,
    OUT PHANDLE phNewToken
    )
/*++
    Description:

        Stub for DuplicateTokenEx

    Arguments:

        same as DuplicateTokenEx

    Returns:

        ditto
--*/
{

    DBG_ASSERT( !TsIsWindows95() );
    DBG_ASSERT( pfnDuplicateTokenEx != NULL );

    return(pfnDuplicateTokenEx(
                        hExistingToken,
                        dwDesiredAccess,
                        lpTokenAttributes,
                        ImpersonationLevel,
                        TokenType,
                        phNewToken
                        ) );

} // IISDuplicateTokenEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved



#include <nt.h>
#define UINT4   ULONG

#include "md5.h"


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#if CT_COMPILER == CT_MPW

/* MPW doesn't compile the macro correctly, so use a procedure. */
static UINT4 RotateLeft (UINT4, unsigned int);
#define ROTATE_LEFT RotateLeft

#else
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#endif

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

__declspec(dllexport)
void IISMD5Init (mdContext)
IISMD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

__declspec(dllexport)
void IISMD5Update (mdContext, inBuf, inLen)
IISMD5_CTX *mdContext;
unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

__declspec(dllexport)
void IISMD5Final (mdContext)
IISMD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  IISMD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

#if CT_COMPILER == CT_MPW
static UINT4 RotateLeft (x, n)
UINT4 x;
unsigned int n;
{
  return (((x) << (n)) | ((x) >> (32-(n))));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\odbcconn.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

       odbcconn.cxx

   Abstract:

       This module defines member functions for ODBC_CONNECTION object.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Feb-1995

   Environment:

       User Mode - Win32.

   Project:

       Internet Services Common DLL

   Functions Exported:

       ODBC_PARAMETER::CopyValue( IN LPCWSTR pwszValue);
       ODBC_PARAMETER::Bind( IN HSTMT hstmt);

       ODBC_STATEMENT::~ODBC_STATEMENT()
       ODBC_STATEMENT::PrepareStatement( IN LPCSTR  pszStatement)
       ODBC_STATEMENT::PrepareStatement( IN LPCWSTR pwszStatement)
       ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParam)
       ODBC_STATEMENT::ExecuteStatement( VOID)
       ODBC_STATEMENT::ExecDirect( IN LPCSTR pwszSqlCommand,  IN DWORD cch)
       ODBC_STATEMENT::ExecDirect( IN LPCWSTR pwszSqlCommand, IN DWORD cch)
       ODBC_STATEMENT::QueryColNames( OUT STR * *  apstrCols,
                                      OUT DWORD *  cCols,
                                      IN  DWORD    cchMaxFieldSize = 0 );
       ODBC_STATEMENT::QueryValuesAsStr( OUT STR * *   apstrValues,
                                         OUT DWORD * * apcbValues,
                                         OUT BOOL *    pfLast );


       ODBC_CONNECTION::~ODBC_CONNECTION();
       ODBC_CONNECTION::Open();
       ODBC_CONNECTION::Close();
       ODBC_CONNECTION::GetLastErrorCode();
       ODBC_CONNECTION::AllocStatement();


   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <tcpdllp.hxx>            // for debugging macros & Unicode functions
# include "odbcconn.hxx"


//
// Since the ODBC does not support UNICODE APIs, we convert unicode to ANSI
//   to call the APIs. This will have to go away once we find some other
//   better way to do manage the same.
//


//
//  Constants for display widths
//

#define MAX_NUM_PRECISION 15

//
//  Constant for all non string and non binary data.  40 is chosen to account
//  for things such as Oracle's numeric types, which can have up to 38 digits
//  of precision
//

#define MAX_NONCHAR_DATA_LEN        40

//
//  If no default maximum field size is specified, then use this value
//  as the maximum
//

#define DEFAULT_MAX_FIELD_SIZE      8192



/************************************************************
 *  Local Functions
 ************************************************************/

static inline VOID
CheckAndPrintErrorMessage( IN ODBC_CONNECTION * poc,
                           IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        poc->GetLastErrorText( &str, NULL, rc );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()


static inline VOID
CheckAndPrintErrorMessage( IN ODBC_STATEMENT * pos,
                           IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        pos->GetLastErrorText( &str );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()


// 
// 64BIT
// Not 64 Bit Compatible
//
// SQLPOINTER is treated here as a 32 bit value. To make this work for
// sundown this needs to be reconciled.
//
# if 0  


static VOID
PrintMultiString( IN char * pszMsg, IN DWORD cbLen, IN char * pmsz)
{

    DBGPRINTF( ( DBG_CONTEXT,
                "Values of %s. %d bytes.\n", pszMsg, cbLen));
    for( char * psz = pmsz; *psz != '\0'; psz += (strlen( psz) + 1)) {

        DBGPRINTF( ( DBG_CONTEXT, "%s\n", psz));
    }

    return;
} // PrintMultiString()



static VOID
AuxOdbcFunctions( IN HENV henv, IN HDBC hdbc)
/*++

  Function useful in walking throug a few additional ODBC functions
    to find out the ODBC setup information.
  Not to be part of the shipped code. Useful for development purposes.
  - MuraliK
--*/
{
    RETCODE rc;

    //
    // Set the trace file to a standard file.
    //
    rc = pSQLSetConnectOption( hdbc, SQL_OPT_TRACE, SQL_OPT_TRACE_ON);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    rc = pSQLSetConnectOption( hdbc, SQL_OPT_TRACEFILE,
                             (unsigned long )  //64BIT
                             "%systemroot%\\system32\\gophsql.log");
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    UCHAR szDriverDesc[ 300];
    UCHAR szDriverAttrib[ 300];
    SWORD cbDD = 300;
    SWORD cbDA = 300;
    SWORD cbDDCur = 0;
    SWORD cbDACur = 0;

    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    rc = pSQLDrivers( henv, SQL_FETCH_FIRST,
                    szDriverDesc, cbDD, &cbDDCur,
                    szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDrivers( %08x) ==> RetCode = %d."
                " Driver Desc. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Driver Attributes", cbDACur, (char *) szDriverAttrib);


    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    cbDDCur = cbDACur = 0;
    rc = pSQLDataSources( henv, SQL_FETCH_FIRST,
                        szDriverDesc, cbDD, &cbDDCur,
                        szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDataSources( %08x) ==> RetCode = %d."
                " Data Sources. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Data Source Description", cbDACur,
                     (char *) szDriverAttrib);

    return;
} // AuxOdbcFunctions()


# endif // 0



/************************************************************
 *    Member Functions of ODBC_PARAMETER
 ************************************************************/


BOOL
ODBC_PARAMETER::CopyValue( IN LPCWSTR  pwszValue)
/*++
  Description:
    This function copies the given Unicode string as the value into
      current parameter marker to be used for future insertion.

  Arguments:
    pwszValue   pointer to null-terminated string containing Unicode value to
                    be copied into the parameter marker.

  Returns:
    TRUE on success and FALSE if there is any error.

  Note:
    Since ODBC does not support Unicode directly right now, we convert
      string value to be ANSI before copying the value over.
--*/
{
    BOOL fReturn = FALSE;

    CHAR * pszValue = ConvertUnicodeToAnsi( pwszValue, NULL, 0 );

    //
    // If successful then Copy ASCII value to buffer in the parameter block.
    //

    if ( pszValue != NULL) {

        fReturn = this->CopyValue( pszValue);

        TCP_FREE( pszValue);
    }

    return ( fReturn);
} // ODBC_PARAMETER::CopyValue()



BOOL
ODBC_PARAMETER::CopyValue( IN LPSYSTEMTIME lpst)
/*++
  Description:
    This function copies the given system time into the ODBC timestamp
     structure for the current parameter marker to be used for
     future insertion.

  Arguments:
   lpSystemTime   pointer to System Time structure containing current time.

  Returns:
    TRUE on success and FALSE if there is any error.

--*/
{
    TIMESTAMP_STRUCT * ptsOdbc;

    DBG_ASSERT( lpst != NULL);
    DBG_ASSERT( m_CType == SQL_C_TIMESTAMP);
    DBG_ASSERT( m_SqlType == SQL_TIMESTAMP);
    DBG_ASSERT( m_cbValueMax >= sizeof(TIMESTAMP_STRUCT));

    ptsOdbc = (TIMESTAMP_STRUCT * ) m_pValue;

    DBG_ASSERT( m_pValue != NULL);

    //
    // Copy the individual fields over properly
    // The types used in ODBC/Win32 are different
    //  So do a type specific copy of the values.
    //

    ptsOdbc->year   = (SWORD ) lpst->wYear;
    ptsOdbc->month  = (UWORD ) lpst->wMonth;
    ptsOdbc->day    = (UWORD ) lpst->wDay;
    ptsOdbc->hour   = (UWORD ) lpst->wHour;
    ptsOdbc->minute = (UWORD ) lpst->wMinute;
    ptsOdbc->second = (UWORD ) lpst->wSecond;
    ptsOdbc->fraction = (UDWORD ) lpst->wMilliseconds;

    return ( TRUE);
} // ODBC_PARAMETER::CopyValue()





RETCODE
ODBC_PARAMETER::Bind( IN HSTMT hStmt)
/*++
  Description:

    This functions binds the data about the parameter marker 'this'
     ( this object) represents to the statement provided.

  Arguments:
    hStmt        HANDLE for the statement to which this parameter
                  is to be bound.

  Returns:
    RETCODE value returned by SQLBindParamater().
--*/
{
    RETCODE  rc;
    DBG_ASSERT( hStmt != SQL_NULL_HSTMT);

    rc = pSQLBindParameter( hStmt,              // statement
                            QueryParamNumber(),
                            QueryParamType(),
                            QueryCType(),
                            QuerySqlType(),
                            QueryPrecision(),
                            QueryScale(),
                            QueryValue(),
                            QueryMaxCbValue(),
                            &(QueryCbValueRef())
                            );

    return ( rc);
} // ODBC_STATEMENT::BindParameter()





# if DBG

VOID
ODBC_PARAMETER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_PARAMETER ( %08x).\n"
                " Num=%u; Type=%d; CType=%d; SqlType=%d; Prec=%u; Scale=%d;"
                " CbMax=%d; Cb=%d.\n",
                this,
                QueryParamNumber(),
                QueryParamType(),
                QueryCType(),
                QuerySqlType(),
                QueryPrecision(),
                QueryScale(),
                QueryMaxCbValue(),
                QueryCbValue()));

    switch ( QuerySqlType()) {

      case SQL_INTEGER:
        {
            DWORD  dwValue = *(DWORD *) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " Integer Value = %u\n", dwValue));
            break;
        }

      case SQL_CHAR:
        {
            LPCSTR pszValue = (LPCSTR ) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " String Value( %08x) = %s\n",
                         pszValue, pszValue));
            break;
        }

      default:
        {
            DBGPRINTF( ( DBG_CONTEXT, " Type=%d. Unknown value at %08x\n",
                        QuerySqlType(), QueryValue()));
            break;
        }

    } // switch

    return;
} // ODBC_PARAMETER::Print()


# endif // DBG



/************************************************************
 * ODBC_STATEMENT  member functions
 ************************************************************/


ODBC_STATEMENT::~ODBC_STATEMENT( VOID)
{
    //
    // Free the statement handle
    //
    if ( m_hStmt != SQL_NULL_HSTMT) {

        m_rc = pSQLFreeStmt( m_hStmt, SQL_DROP);
        m_hStmt = SQL_NULL_HSTMT;

        // Ignore the error code here.
        DBG_ASSERT( ODBC_CONNECTION::Success( m_rc));


        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SqlFreeStmt() return code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    FreeColumnMemory();

} // ODBC_STATEMENT::~ODBC_STATEMENT()





BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn;

    IF_DEBUG( ODBC) {
        DBGPRINTF( ( DBG_CONTEXT,
                    " Executing the SQL command (%d bytes) %s.\n",
                    cchSqlCommand * sizeof( CHAR),
                    pszSqlCommand));
    }

    //
    //  SQLExecDirect only likes Unsigned chars !
    //
    m_rc = pSQLExecDirect( m_hStmt, (UCHAR FAR *) pszSqlCommand, cchSqlCommand);
    fReturn = ODBC_CONNECTION::Success( m_rc);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLExecDirect() returns code %d\n",
                    m_rc));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()



BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCWSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn = FALSE;
    char * pszCommand;

    if ( ( pszCommand = ConvertUnicodeToAnsi( pszSqlCommand, NULL, 0))
        != NULL ) {

        fReturn = ExecDirect( pszCommand, strlen( pszCommand));

        TCP_FREE( pszCommand);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()






BOOL
ODBC_STATEMENT::PrepareStatement(IN LPCSTR    pszStatement)
/*++

  This function prepares the SQL statement for future execution.

  Arguments:
     pszStatement    pointer to null terminated string containing the
                        statement.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn;

    DBG_ASSERT( QueryErrorCode() == SQL_SUCCESS && pszStatement != NULL);

    m_rc = pSQLPrepare( m_hStmt, (UCHAR FAR *) pszStatement, SQL_NTS);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLPrepare( %s) returns ErrorCode = %d.\n",
                     pszStatement, m_rc));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( m_fPreparedStmt = ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::PrepareStatment()




BOOL
ODBC_STATEMENT::PrepareStatement( IN LPCWSTR   pwszCommand)
/*++
  This function prepares an ODBC statement for execution.
  Since ODBC does not support UNICODE, we convert the statement into ANSI
   before calling the APIs.

  Arguments:
     pwszCommand      pointer to null-terminated string containing the
                       statement to be prepared.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;
    CHAR * pszCommand = NULL;

    DBG_ASSERT( pwszCommand != NULL);

    pszCommand = ConvertUnicodeToAnsi( pwszCommand, NULL, 0);

    if ( pszCommand != NULL) {

        fReturn = PrepareStatement( pszCommand);

        TCP_FREE( pszCommand);

    } // pszCommand != NULL

    return ( fReturn);
} // ODBC_STATEMENT::PrepareStatement()





BOOL
ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParameter)
{

    DBG_ASSERT( ODBC_CONNECTION::Success( m_rc) && pOdbcParameter != NULL);

    m_rc = pOdbcParameter->Bind( m_hStmt);

    IF_DEBUG( ODBC) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::BindParameter()





BOOL
ODBC_STATEMENT::ExecuteStatement( VOID)
/*++

  This function executes a prepared ODBC statement. At the end of execution,
   the transaction is also committed to ensure that the record is automatically
   written to the database.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DBG_ASSERT( m_fPreparedStmt != FALSE);

    if ( !ODBC_CONNECTION::Success( QueryErrorCode()) ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "!!WARNING!! - Attempting to use Invalid ODBC Connection!\n" ));
    }

    m_rc = pSQLExecute( m_hStmt);

    IF_DEBUG( ODBC) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::ExecuteStatement()

BOOL
ODBC_STATEMENT::QueryRowCount(
    OUT DWORD * pcRows
    )
/*++

  Calls SQLRowCount on the current result set.

  NOTE: Not all database implementations support this!!

  Arguments:

    pcRows - Receives count of rows

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    m_rc = pSQLRowCount( m_hStmt,
                         (SDWORD *) pcRows );

    return ( ODBC_CONNECTION::Success( m_rc));
}


BOOL
ODBC_STATEMENT::QueryColNames(
    STR * *  pastrCols,
    DWORD  * cCols,
    DWORD    cchMaxFieldSize,
    BOOL *   pfHaveResultSet
    )
/*++

  This method returns the list of column names from the result table

  Arguments:

    pastrCols - Receives an array of STRs containing the column names
    cCols - Count of columns returned (zero for no result set)
    cchMaxFieldSize - Maximum buffer size to allocate for any data fields,
        zero means use the default value.
    pfHaveResultSet - Set to TRUE if the current query was a SELECT and thus has
        rows that can be enumerated

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    SWORD   nresultcols;
    SWORD   i;
    CHAR    achColName[64];
    SWORD   cchColName;
    SWORD   ColType;
    DWORD   cchColLength;
    SWORD   scale;
    SWORD   nullable;

    *pastrCols       = NULL;
    *cCols           = 0;
    *pfHaveResultSet = TRUE;

    //
    //  Return the old binding info if we already have it
    //

    if ( m_astrColNames )
    {
        *pastrCols = m_astrColNames;
        *cCols = m_cCols;

        return TRUE;
    }

    //
    //  Provide a default maximum field size if none was specified
    //

    if ( !cchMaxFieldSize )
        cchMaxFieldSize = DEFAULT_MAX_FIELD_SIZE;

    //
    //  See what kind of statement it was.  If there are no result
    //  columns, the statement is not a SELECT statement.
    //

    m_rc = pSQLNumResultCols( m_hStmt,
                              &nresultcols);

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    if ( nresultcols > 0 )
    {
        //
        //  Allocate an array of strings for the column names and the column
        //  values
        //

        m_cCols = nresultcols;
        *cCols  = m_cCols;

        m_astrColNames = new STR[m_cCols];
        m_astrValues   = new STR[m_cCols];
        m_acbValue     = new LONG[m_cCols];

        //
        //  Otherwise, get the column names of the result set and use the
        //  display_size() function to compute the length needed by each data
        //  type.  Next, bind the columns and specify all data will be
        //  converted to char.
        //

        for (i = 0; i < m_cCols; i++)
        {
            m_rc = pSQLDescribeCol( m_hStmt,
                                    i + 1,
                                    (UCHAR *) achColName,
                                    (SWORD)sizeof(achColName),
                                    &cchColName,
                                    &ColType,
                                    &cchColLength,
                                    &scale,
                                    &nullable);

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            //
            //  Select the buffer size for the retrieved data for this column
            //

            cchColLength = ODBC_CONNECTION::DisplaySize( ColType,
                                        min( cchColLength, cchMaxFieldSize) );

            //
            //  Copy the column name and set the column data size
            //

            if ( !m_astrColNames[i].Copy( achColName ) ||
                 !m_astrValues[i].Resize( cchColLength + 1 ))
            {
                return FALSE;
            }

            m_rc = pSQLBindCol( m_hStmt,
                                i + 1,
                                SQL_C_CHAR,
                                m_astrValues[i].QueryPtr(),
                                cchColLength,
                                &m_acbValue[i] );

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;
        }

        *pastrCols = m_astrColNames;
        *cCols     = m_cCols;
    }
    else
    {
        *pfHaveResultSet = FALSE;
    }

    return TRUE;
}


BOOL
ODBC_STATEMENT::QueryValuesAsStr(
    STR * *       pastrValues,
    OUT DWORD * * pacbValues,
    BOOL *  pfLast
    )
/*++

  This method gets the data at the current position.

  Arguments:

    pastrValues - Receives a pointer to an array of strings that contains
        the alphanumeric representation of that field
    pacbValues - Receives pointer to array of DWORDs that contain the length
        of the field
    pfLast - Set to TRUE if there are no more values to retrieve

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    *pastrValues = NULL;

    //
    //  Build the bindings if we haven't already
    //

    if ( !m_astrColNames )
    {
        STR * astrCols;
        DWORD cCols;
        BOOL  fHaveResultSet;

        if ( !QueryColNames( &astrCols,
                             &cCols,
                             0,
                             &fHaveResultSet ))
        {
            return FALSE;
        }
    }

    //
    //  If there are columns to enumerate, get them now
    //

    if ( m_astrColNames )
    {
        DWORD i;

        //
        //  Zero terminate the columns as some drivers don't write anything
        //  for NULL fields
        //

        for ( i = 0; i < m_cCols; i++ )
        {
            *((CHAR *) m_astrValues[i].QueryPtr()) = '\0';
            m_acbValue[i] = 0;
        }

        //
        //  Fill in the binding values
        //

        m_rc = pSQLFetch( m_hStmt );

        if ( m_rc == SQL_NO_DATA_FOUND )
        {
            *pfLast = TRUE;
        }
        else
        {
            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            *pfLast = FALSE;
        }

        *pastrValues = m_astrValues;
        *pacbValues  = (DWORD *) m_acbValue;
    }
    else
    {
        *pfLast = TRUE;
    }

    return TRUE;
}

BOOL
ODBC_STATEMENT::MoreResults(
    BOOL * pfMoreResults
    )
/*++

    Determines if there are any more results sets to return to the user

    pfMoreResults - Set to TRUE if there are more results in the result set

--*/
{
    *pfMoreResults = TRUE;

    m_rc = pSQLMoreResults( m_hStmt );

    if ( m_rc == SQL_NO_DATA_FOUND )
    {
        *pfMoreResults = FALSE;
        return TRUE;
    }

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    return TRUE;
}


VOID
ODBC_STATEMENT::FreeColumnMemory(
    VOID
    )
/*++
    This method frees memory allocated by the QueryColNames and
    QueryValuesAsStr methods.

--*/
{
    if ( m_astrColNames ) delete [] m_astrColNames;
    if ( m_astrValues )   delete [] m_astrValues;
    if ( m_acbValue )     delete [] m_acbValue;

    m_astrColNames = NULL;
    m_astrValues = NULL;
    m_acbValue = NULL;

}

# if DBG


VOID
ODBC_STATEMENT::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ODBC_STATEMENT( %08x)."
                " HStmt = %08x. OdbcConn=%08x. RetCode = %d\n",
                m_hStmt, m_pOdbcConnection, m_rc));

} // ODBC_STATEMENT::Print()

# endif // DBG


/**************************************************
 *  Member Functions of class ODBC_CONNECTION
 **************************************************/


ODBC_CONNECTION::~ODBC_CONNECTION( VOID)
/*++
   This function closes the odbc connection ( if open) and cleans up.

--*/
{
    DBG_REQUIRE( Close());
    return;
} // ODBC_CONNECTION::~ODBC_CONNECTION()





BOOL
ODBC_CONNECTION::Open(
    IN LPCSTR   pszDataSource,
    IN LPCSTR   pszUserName,
    IN LPCSTR   pszPassword)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pszUserName      pointer to null-terminated string containing UserName
    pszPassword      pointer to null-terminated string containing Password

  Returns:

    TRUE on success and FALSE if there is an error.
--*/
{
    BOOL fReturn = FALSE;

    DBG_ASSERT( pszDataSource != NULL &&
                pszUserName != NULL &&
                pszPassword != NULL);

    //
    //  Allocate an ODBC environment
    //

    m_rc = pSQLAllocEnv( &m_henv);
    fReturn = Success( m_rc);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SQLAllocEnv() returned ErrorCode %d. henv = %08x\n",
                    m_rc, m_henv));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( fReturn) {

        //
        // Establish memory for connection handle within the environment
        //

        m_rc = pSQLAllocConnect( m_henv, &m_hdbc);
        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLAllocConnect() returns code %d. hdbc = %08x\n",
                        m_rc, m_hdbc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    if ( fReturn) {

        //
        // Use Following call to just printout the dynamic values for ODBC
        //
        // AuxOdbcFunctions( m_henv, m_hdbc);

#if 0
        {
            STR str;
            STR strOut;
            SWORD swStrOut;

            if ( !str.Append( pszDataSource )   ||
                 !str.Append( ";UID=" )         ||
                 !str.Append( pszUserName )     ||
                 !str.Append( ";PWD=" )         ||
                 !str.Append( pszPassword )     ||
                 !str.Append( ";APP=Internet Services") ||
                 !strOut.Resize( 255 ))
            {
                return FALSE;
            }

            m_rc = pSQLDriverConnect( m_hdbc,
                                      NULL,
                                      (UCHAR *) str.QueryStr(),
                                      SQL_NTS,
                                      (UCHAR *) strOut.QueryStr(),
                                      strOut.QuerySize(),
                                      &swStrOut,
                                      SQL_DRIVER_NOPROMPT );
        }
#else
        {
            m_rc = pSQLConnect( m_hdbc,
                               (UCHAR FAR *) pszDataSource, SQL_NTS,
                               (UCHAR FAR *) pszUserName,   SQL_NTS,
                               (UCHAR FAR *) pszPassword,   SQL_NTS);
        }
#endif

        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLConnect( %s, %s, %s) returns code %d.\n",
                        pszDataSource,
                        pszUserName,
                        pszPassword,
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    m_fValid = fReturn;

    if ( !fReturn) {
        SetLastError( ERROR_GEN_FAILURE );
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()





BOOL
ODBC_CONNECTION::Open(
    IN LPCWSTR  pwszDataSource,
    IN LPCWSTR  pwszUserName,
    IN LPCWSTR  pwszPassword)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pwszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pwszUserName      pointer to null-terminated string containing UserName
    pwszPassword      pointer to null-terminated string containing Password

  Returns:
    TRUE on success and FALSE if there is an error.

  Note:
     Poor me.  ODBC Does not take UNICODE strings :(. 2/15/95
     So we will explicitly convert parameters to ANSI on stack.
--*/
{
    BOOL   fReturn;
    DWORD  dwError = NO_ERROR;
    CHAR * pszDataSource;
    CHAR * pszUserName;
    CHAR * pszPassword;

    //
    // Convert all parameters from UNICODE to ANSI
    //
    pszDataSource = ConvertUnicodeToAnsi( pwszDataSource, NULL, 0);
    pszUserName   = ConvertUnicodeToAnsi( pwszUserName, NULL, 0);
    pszPassword   = ConvertUnicodeToAnsi( pwszPassword, NULL, 0);

    //
    // Make an ANSI open call.
    //
    fReturn = Open( pszDataSource, pszUserName, pszPassword);

    if ( !fReturn)  {

        dwError = GetLastError();
    }

    //
    //  Freeup the space allocated.
    //
    if ( pszDataSource != NULL) {

        TCP_FREE( pszDataSource);
        pszDataSource = NULL;
    }

    if ( pszUserName != NULL) {

        TCP_FREE( pszUserName);
        pszUserName = NULL;
    }

    if ( pszPassword != NULL) {

        //
        // Zero the password for security reasons.
        //
        memset( pszPassword, 0, strlen( pszPassword));

        TCP_FREE( pszPassword);
        pszPassword = NULL;
    }

    if ( !fReturn) {

        SetLastError( dwError);
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()




BOOL
ODBC_CONNECTION::Close( VOID)
/*++
  This function closes the connection established with the ODBC
   and frees up and dynamic memory used.

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:
    Intermediate failures are ignored. Normally they should not occur.

--*/
{
    BOOL fReturn = TRUE;


    //
    // Disconnect and free the connection.
    //
    if ( m_hdbc != SQL_NULL_HDBC) {

        m_rc = pSQLDisconnect( m_hdbc );

        //
        //  Disconnect is allowed to fail w/o being fatal so don't set
        //  fReturn
        //

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Warning: SQLDisconnect() returns code %d.\n",
                        m_rc));
            CheckAndPrintErrorMessage( this, m_rc);
        }

        m_rc = pSQLFreeConnect( m_hdbc);

        m_hdbc = SQL_NULL_HDBC;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeConnect() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    //
    //  Free the ODBC environment handle.
    //
    if ( m_henv != SQL_NULL_HENV) {

        m_rc = pSQLFreeEnv( m_henv);
        m_henv = SQL_NULL_HENV;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeEnv() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    return ( fReturn);
} // ODBC_CONNECTION::Close()





PODBC_STATEMENT
ODBC_CONNECTION::AllocStatement( VOID)
/*++
  Description:
    This function allocates a new ODBC statement object and also calls
     SQLAllocStatement to create the state required for establishing the
     statement in the ODBC Manager.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    PODBC_STATEMENT pOdbcStmt = NULL;
    HSTMT   hstmt = SQL_NULL_HSTMT;

    DBG_ASSERT( Success( m_rc));

    //
    // Allocate a statement handle and associate it with the connection.
    //
    m_rc = pSQLAllocStmt( m_hdbc, &hstmt);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SqlAllocStmt() returns code %d."
                    " New Hstmt is : %08x\n",
                    m_rc, hstmt));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( ODBC_CONNECTION::Success( m_rc)) {

        pOdbcStmt = new ODBC_STATEMENT( this, hstmt);
    }

    return ( pOdbcStmt);
} // ODBC_CONNECTION::AllocStatement()


BOOL
ODBC_CONNECTION::SetConnectOption(
    IN UWORD        Option, 
    IN SQLPOINTER   Param
    )
/*++

  Sets various options on this connection

  Arguments:

    Option - Option to set
    Param - Option value (32 bit dword or pointer to null terminated string)

  Returns:
    TRUE on success and FALSE if there are any failures.  Failures are
    considered to be soft errors as the problem may be the driver doesn't
    support the option etc.

  Note:

--*/
{
    BOOL    fReturn = TRUE;
    RETCODE rc;

    if ( m_hdbc != SQL_NULL_HDBC)
    {
        rc = pSQLSetConnectOption( m_hdbc, Option, Param);

        fReturn = Success( rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLSetConnectOption( %d, %d ) returns code %d.\n",
                        Option,
                        Param,
                        rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    }
    else
    {
        DBGPRINTF( ( DBG_CONTEXT,
                     "[SetConnectOption] Warning: Setting option on closed connection\n" ));
    }

    return fReturn;
}



BOOL
ODBC_CONNECTION::GetLastErrorText(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        pstrError->Reset();

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = pSQLError( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                             "[State=%s][Error=%d]%s\n",
                             achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorText()



BOOL
ODBC_CONNECTION::GetLastErrorTextAsHtml(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        if ( !pstrError->Copy( "<UL>" ))
        {
            return FALSE;
        }

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = pSQLError( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                          "<LI>[State=%s][Error=%d]%s\n",
                          achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    if ( !pstrError->Append( "</UL>" )) {
                        return FALSE;
                    }

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorTextAsHtml()



BOOL
ODBC_CONNECTION::GetInfo(IN DWORD fInfoType,
                         IN PVOID rgbInfoValue,
                         IN DWORD cbInfoValueMax,
                         IN OUT DWORD * pcbInfoValue)
/*++
  This function obtains the value of the fInfoType for a specific
   ODBC Connection. It mimicks the SQLGetInfo() and uses it to obtain
   this value. On successful return the pointer rgbInfoValue contains
   the requested value and pcbInfoValue contains the size in bytes of
   data.

  Arguments:
    fInfoType - flag containing the Information Type (name) to be fetched.
    rgbInfoValue - pointer to buffer which will contain the return data.
    cbInfoValue  - size of rgbInfoValue in bytes.
    pcbInfoValue - pointer to location that will contain the size of
                    information stored in rgbInfoValue, on successful return.
                   If buffer is insufficient, this location will contain the
                    required number of bytes.

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fReturn = FALSE;

    if ( m_hdbc != SQL_NULL_HDBC) {

        RETCODE rc;

        rc = pSQLGetInfo( m_hdbc, (UWORD ) fInfoType,
                         (PTR)   rgbInfoValue,
                         (SWORD) cbInfoValueMax,
                         (SWORD FAR *) pcbInfoValue);

        fReturn = Success( rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLGetInfo( %08x, %d, %08x, %d, %08x) returns %d.\n",
                        m_hdbc, fInfoType, rgbInfoValue, cbInfoValueMax,
                        pcbInfoValue, rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    } else {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[SQLGetInfo] Invalid Connection to ODBC\n"));
    }

    return (fReturn);
} // ODBC_CONNECTION::GetInfo()



DWORD
ODBC_CONNECTION::DisplaySize(
    SWORD coltype,
    DWORD collen
    )
{
    DWORD cbSize = MAX_NONCHAR_DATA_LEN;

    //
    //  Note that we always set the size to at least four bytes.  This prevents
    //  any possible problems if the column to be bound is NULLable, which can
    //  cause a NULL to be written for the data during a fetch
    //

    switch (coltype)
    {
      case SQL_CHAR:
      case SQL_VARCHAR:
      case SQL_LONGVARCHAR:
      case SQL_BINARY:
      case SQL_VARBINARY:
      case SQL_LONGVARBINARY:
        cbSize = max(collen + sizeof(CHAR), sizeof(PVOID));
        break;

      default:
        break;
    }

    return ( cbSize);
} // ODBC_CONNECTION::DisplaySize()




# if DBG
VOID
ODBC_CONNECTION::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_CONNECTION ( %08x). fValid = %d\n"
                " HENV = %08x. HDBC = %08x. ReturnCode =%d\n",
                this, m_fValid,
                m_henv, m_hdbc, m_rc));
    return;
} // ODBC_CONNECTION::Print()


# endif // DBG

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\reftrce2.h ===
#ifndef __REFTRCE2_H__
#define __REFTRCE2_H__

#if SERVICE_REF_TRACKING

# include <reftrace.h>

# define SHARED_LOG_REF_COUNT()     \
    ( sm_pDbgRefTraceLog != NULL ) ?        \
        WriteRefTraceLog(                   \
            sm_pDbgRefTraceLog              \
            , m_reference                   \
            , this                          \
        )                                   \
    : -1                                    \

//
//  This macro logs the IIS_SERVICE-specific ref trace log
//

# define LOCAL_LOG_REF_COUNT()      \
    ( m_pDbgRefTraceLog != NULL ) ?         \
        WriteRefTraceLog(                   \
            m_pDbgRefTraceLog               \
            , m_reference                   \
            , this                          \
        )                                   \
    : -1                                    \

//
//  Usage of above macros AFTER we decremented reference count
//  was unsafe.  Under stress we would sometimes hit assert
//  in WriteTraceLog() because IIS_SERVICE::m_pDbgRefTraceLog
//  was no longer valid.  This was due to a race condition where
//  another thread deletes IIS_SERVICE object while we are still
//  doing the log.
//  So, instead of using original macros AFTER the decrement
//  use modified macros BEFORE the decrement.  This should
//  result in identical logs most of the time (subject to
//  race conditions and our guessing of what post decrement
//  reference count will be).
//

# define SHARED_EARLY_LOG_REF_COUNT()       \
    ( sm_pDbgRefTraceLog != NULL ) ?        \
        WriteRefTraceLog(                   \
            sm_pDbgRefTraceLog              \
            , m_reference - 1               \
            , this                          \
        )                                   \
    : -1                                    \

# define LOCAL_EARLY_LOG_REF_COUNT()        \
    ( m_pDbgRefTraceLog != NULL ) ?         \
        WriteRefTraceLog(                   \
            m_pDbgRefTraceLog               \
            , m_reference - 1               \
            , this                          \
        )                                   \
    : -1                                    \

#else  // !SERVICE_REF_TRACKING
# define SHARED_LOG_REF_COUNT() (-1)
# define LOCAL_LOG_REF_COUNT()  (-1)
# define SHARED_EARLY_LOG_REF_COUNT() (-1)
# define LOCAL_EARLY_LOG_REF_COUNT()  (-1)
#endif // !SERVICE_REF_TRACKING

#endif // __REFTRCE2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\refb.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refb.cxx

Abstract:

    Reference counting blob class

Author:

    Philippe Choquier (phillich)    11-sep-1996

--*/

#include "tcpdllp.hxx"

#pragma hdrstop

#include <refb.hxx>


RefBlob::RefBlob(
    ) 
/*++
    Description:

        Constructor for RefBlob

    Arguments:
        None

    Returns:
        Nothing

--*/
{ 
    m_lRef = 0; 
    m_pvBlob = 0; 
    m_dwSize = 0; 
    m_pfnFree = NULL;
}


RefBlob::~RefBlob(
    ) 
/*++
    Description:

        Destructor for RefBlob

    Arguments:
        None

    Returns:
        Nothing

--*/
{
}


BOOL 
RefBlob::Init( 
    LPVOID          pv, 
    DWORD           sz,
    PFN_FREE_BLOB   pFn
    ) 
/*++
    Description:

        Initialize a RefBlob
        ownership of buffer pointed to by pv is transferred
        to this object. buffer must have been allocated using
        LocalAlloc( LMEM_FIXED, )

    Arguments:
        pv - pointer to blob
        sz - size of blob
        pFn - ptr to function to call to free blob

    Returns:
        TRUE if success, otherwise FALSE

--*/
{ 
    m_pvBlob = pv; 
    m_dwSize = sz; 
    m_pfnFree = pFn;
    AddRef(); 
    return TRUE; 
}


VOID 
RefBlob::AddRef(
    VOID
    ) 
/*++
    Description:

        Add a reference to this object

    Arguments:
        None

    Returns:
        Nothing

--*/
{ 
    InterlockedIncrement( &m_lRef ); 
}


VOID 
RefBlob::Release(
    VOID
    )
/*++
    Description:

        Remove a reference to this object
        When the reference count drops to zero
        the object is destroyed, blob memory freed

    Arguments:
        None

    Returns:
        Nothing

--*/
{
    if ( !InterlockedDecrement( &m_lRef ) )
    {
        if ( m_pfnFree )
        {
            (m_pfnFree)( m_pvBlob );
        }
        else
        {
            LocalFree( m_pvBlob );
        }
        delete this;
    }
}


LPVOID 
RefBlob::QueryPtr(
    ) 
/*++
    Description:

        Returns a ptr to blob

    Arguments:
        None

    Returns:
        ptr to blob

--*/
{ 
    return m_pvBlob; 
}


DWORD
RefBlob::QuerySize(
    ) 
/*++
    Description:

        Returns a blob size

    Arguments:
        None

    Returns:
        size of blob

--*/
{ 
    return m_dwSize; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\sslinfo.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sslinfo.cxx

Abstract:

    Implementation of IIS_SSL_INFO class

Author:

    Alex Mallet (amallet)    03-Feb-1997

--*/


#include "tcpdllp.hxx"
#pragma hdrstop

#include <wincrypt.h>

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include <eventlog.hxx>
#include <reftrace.h>

#include "iiscert.hxx"
#include "capiutil.hxx"
#include "iisctl.hxx"
#include "certnotf.hxx"
#include "sslinfo.hxx"

#if DBG
#define VALIDATE_HEAP() DBG_ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) )
#else
#define VALIDATE_HEAP() 
#endif 

IIS_SSL_INFO::IIS_SSL_INFO( IN LPTSTR pszMBPath,
                            IN IMDCOM *pMDObject ) :
m_pCert( NULL ),
m_fDefaultCert( FALSE ),
m_fCertOK( FALSE ),
m_pCTL( NULL ),
m_fDefaultCTL ( FALSE ),
m_fCTLOK( FALSE ),
m_strMBPath( pszMBPath ),
m_pMDObject(pMDObject),
m_hTrustedIssuerStore( NULL ),
m_hRestrictedRoot( NULL ),
m_hRestrictedTrust( NULL ),
m_dwRefCount( 0 ),
m_dwSignature( IIS_SSL_INFO_SIGNATURE ),
m_fUseDSMapper( FALSE ),
m_fCheckedDSMapper( FALSE ),
m_hChainEngine( NULL ),
m_hMyStore( NULL ),
m_hCAStore( NULL ),
m_hRootStore( NULL ),
m_acRootCerts( NULL ),
m_cRootCerts( 0 ),
m_dwCertChainStatus( -1 )
/*++

   Description

      Constructor; doesn't do anything, really

   Arguments:

      pszMBPath - path in metabase where SSL-related information is to be found
      pMDObject - metabase object to be used for metabase operations
      pNotifFnc - function to be called when object destructor is called. May be NULL.
      pvArg - argument to pNotifFnc. Ignored if pNotifFnc == NULL

   Returns:

      Nothing

--*/
{
    DBG_ASSERT( pszMBPath );
    DBG_ASSERT( pMDObject );

    INITIALIZE_CRITICAL_SECTION( &m_CritSec );

    m_hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                MY_STORE_NAME );

    m_hCAStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                CA_STORE_NAME );

    m_hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                  0,
                                  NULL,
                                  CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                  ROOT_STORE_NAME );


#if SSLINFO_REF_COUNT 

    m_pRefTraceLog = CreateRefTraceLog( C_SSLINFO_REFTRACES, 0 );
    DBGPRINTF((DBG_CONTEXT,
               "Created ref trace object %p for SSL object %p\n",
               m_pRefTraceLog, this));

#endif 

}


IIS_SSL_INFO::~IIS_SSL_INFO( VOID )
/*++

   Description

     Destructor

   Arguments:

      None

   Returns:

      Nothing

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_dwRefCount == 0 );

    if ( m_pCert )
    {
        delete m_pCert;
        m_pCert = NULL;
    }

    if ( m_pCTL )
    {
        delete m_pCTL;
        m_pCTL = NULL;
    }

    if ( m_hChainEngine )
    {
        CertFreeCertificateChainEngine( m_hChainEngine );
        m_hChainEngine = NULL;
    }

    if ( m_hTrustedIssuerStore )
    {
        CertCloseStore( m_hTrustedIssuerStore,
                        0 );
        m_hTrustedIssuerStore = NULL;
    }

    if ( m_hRestrictedRoot )
    {
        CertCloseStore( m_hRestrictedRoot,
                        0 );
        m_hRestrictedRoot = NULL;
    }

    if ( m_hRestrictedTrust )
    {
        CertCloseStore( m_hRestrictedTrust,
                        0 );
        m_hRestrictedTrust = NULL;
    }

    if ( m_hRootStore )
    {
        CertCloseStore( m_hRootStore,
                        0 );
        m_hRootStore = NULL;
    }

    if ( m_hCAStore )
    {
        CertCloseStore( m_hCAStore,
                        0 );
        m_hCAStore = NULL;
    }

    if ( m_hMyStore )
    {
        CertCloseStore( m_hMyStore,
                        0 );
        m_hMyStore = NULL;
    }

    if ( m_acRootCerts )
    {
        for ( DWORD i = 0; i < m_cRootCerts; i++ )
        {
            CertFreeCertificateContext( m_acRootCerts[i] );
        }
        delete [] m_acRootCerts;
        m_acRootCerts = NULL;
        m_cRootCerts = 0;
    }

    DeleteCriticalSection( &m_CritSec );

    m_dwSignature = IIS_SSL_INFO_SIGNATURE_FREE;

#if SSLINFO_REF_COUNT

    if ( m_pRefTraceLog )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Deleting ref trace object %p for ssl object %p\n",
                   m_pRefTraceLog, this));
        DestroyRefTraceLog( m_pRefTraceLog );
    }

#endif //SSLINFO_REF_COUNT 
}

IIS_SSL_INFO *
IIS_SSL_INFO::CreateSSLInfo(
    IN LPTSTR                       pszMBPath,
    IN IMDCOM *                     pMDObject 
)
{
    return new IIS_SSL_INFO( pszMBPath, pMDObject );
}

IIS_SERVER_CERT* IIS_SSL_INFO::GetCertificate( VOID )
/*++

   Description

      Returns server certificate for this instance of the server

   Arguments:

      None 

   Returns:

       ptr to IIS_SERVER_CERT object for this instance, NULL if none can be found/constructed

--*/

{
    DBG_ASSERT( CheckSignature() );

    BOOL fDefault = FALSE;
    LPTSTR pszMDPath = NULL;
    BOOL fHasCert = FALSE;

    Lock();

    if ( !m_pCert )
    {
        if ( HasCertificate( &fHasCert,
                             &m_fDefaultCert ) &&
              //
              // server has cert
              //
             fHasCert )
        {
            if ( m_fDefaultCert )
            {
                pszMDPath = DEFAULT_SERVER_CERT_MD_PATH;
            }
            else
            {
                pszMDPath = m_strMBPath.QueryStr();
            }
            
            m_pCert = new IIS_SERVER_CERT( m_pMDObject,
                                           pszMDPath );

            if ( !m_pCert || !m_pCert->IsValid() )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Failed to construct cert from path %s, error 0x%x\n",
                           pszMDPath, GetLastError()));
            }
        }
    }

    Unlock();

    return m_pCert;
}

IIS_CTL*
IIS_SSL_INFO::GetCTL( VOID )
/*++

   Description

      Returns Certificate Trust List [CTL] for this instance of the server

   Arguments:

      None 

   Returns:

       ptr to IIS_CTL  object for this instance, NULL if none can be found/constructed

--*/

{
    DBG_ASSERT( CheckSignature() );

    BOOL fDefault = FALSE;
    LPTSTR pszMDPath = NULL;
    BOOL fHasCTL = FALSE;

    Lock();

    if ( !m_pCTL )
    {
        if ( HasCTL( &fHasCTL,
                     &m_fDefaultCTL ) &&
             //
             // instance has CTL
             //
             fHasCTL )
        {
            if ( m_fDefaultCTL )
            {
                pszMDPath = DEFAULT_CTL_MD_PATH;
            }
            else
            {
                pszMDPath = m_strMBPath.QueryStr();
            }
            
            m_pCTL = new IIS_CTL( m_pMDObject,
                                  pszMDPath );
            
            if ( !m_pCTL || !m_pCTL->IsValid() )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Failed to construct CTL from path %s, error 0x%x\n",
                           pszMDPath, GetLastError()));
            }
        }
    }

    Unlock();

    return (m_pCTL);
}



BOOL IIS_SSL_INFO::HasCertificate( OUT PBOOL pfHasCert,
                                   OUT PBOOL pfIsDefaultCert )
/*++

   Description

      Check whether this instance has certificate info in the metabase 

   Arguments:

      pfHasCert - pointer to bool set to TRUE if server has a cert, FALSE if not 
      pfIsDefaultCert  - Pointer to bool that is set to true if the server has a cert and 
      that cert is the default [global] cert. Not set if the server doesn't have a cert

   Returns:

      TRUE if check succeeds, FALSE if not 

--*/
{
    DBG_ASSERT( CheckSignature() );

    return CheckCAPIInfo( pfHasCert,
                          pfIsDefaultCert,
                          DEFAULT_SERVER_CERT_MD_PATH,
                          adwMetabaseCertProperties,
                          cNumCertMetabaseProperties );
}




BOOL IIS_SSL_INFO::HasCTL( OUT PBOOL pfHasCTL,
                           OUT PBOOL pfIsDefaultCTL )
/*++

   Description

      Check whether this instance has CTL info in the metabase 

   Arguments:

      pfHasCTL - pointer to bool set to TRUE if server has a CTL, FALSE if not 
      pfIsDefaultCTL  - Pointer to bool that is set to true if the server has a CTL
      and that CTL is the default [global] CTL. Not set if the server doesn't have a CTL

   Returns:

      TRUE if check succeeds, FALSE if not 

--*/
{
    DBG_ASSERT( CheckSignature() );

    return CheckCAPIInfo( pfHasCTL,
                          pfIsDefaultCTL,
                          DEFAULT_CTL_MD_PATH,
                          adwMetabaseCTLProperties,
                          cNumCTLMetabaseProperties);
}


BOOL IIS_SSL_INFO::CheckCAPIInfo( OUT PBOOL pfHasInfo,
                                  OUT PBOOL pfIsDefaultInfo,
                                  IN LPTSTR pszDefaultPath,
                                  IN DWORD  *adwMetabaseProperties, 
                                  IN DWORD  cProperties )
/*++

   Description

      Check whether this instance has CAPI info in the metabase 

   Arguments:

      pfHasInfo - pointer to bool set to TRUE if server has CAPI info, FALSE if not 

      pfIsDefaultInfo  - Pointer to bool that is set to true if the server doesn't have 
      its own copy of the CTL info but is to use the default [global] info. Not set if there 
      is no CAPI info. 

      pszDefaultPath - metabase path to default info

      adwMetabaseProperties - metabase properties to be checked

      cProperties - number of entries in adwMetabaseProperties 

   Returns:

      TRUE if check for info succeeds, FALSE if not 
      NB : TRUE doesn't mean CAPI info was found, it means there were no internal errors 
      looking for the info
--*/
{
    DBG_ASSERT( CheckSignature() );

    MB mb( m_pMDObject );
    BOOL fGotCertInfo = FALSE;
    m_fDefaultCert = FALSE;

    if ( !mb.Open( "/" ) )
    {
       return FALSE;
    }

    if ( !( *pfHasInfo = ServerAddressHasCAPIInfo( &mb,
                                                   m_strMBPath.QueryStr(),
                                                   adwMetabaseProperties,
                                                   cProperties ) ) )
    {
        *pfHasInfo = ServerAddressHasCAPIInfo( &mb,
                                               pszDefaultPath,
                                               adwMetabaseProperties,
                                               cProperties );
        if ( *pfHasInfo )
        {
            *pfIsDefaultInfo = TRUE;
        }
    }
    else
    {
        *pfIsDefaultInfo = FALSE;
    }

    mb.Close();

    return (TRUE);
}

BOOL IIS_SSL_INFO::GetTrustedIssuerCerts( OUT PCCERT_CONTEXT **ppcCertContext,
                                          OUT DWORD *pdwCertsFound )
/*++

Routine Description:

    Tries to retrieve CERT_CONTEXT pointers for the trusted CA certs for the given object.
    Trusted CA certs are either retrieved from the appropriate Certificate Trust List or
    from the Local Machine Root store.


Arguments:

    pppCertContext - pointer to array of CERT_CONTEXT pointers, filled out with the found 
    CERT_CONTEXTS.
    Caller is responsible for releasing the contexts when done with them and deleting
    the array used to hold them.

    pdwCertsFound - pointer to number of cert contexts returned in ppCertContext

Returns:

    TRUE if no internal errors occurred, FALSE if NOT
--*/

{
    DBG_ASSERT( CheckSignature() );

    BOOL fOk = TRUE;

    Lock();

    //
    // Use the certs in the CTL, if we have metabase information for one, else get the certs 
    // from the Root store
    //
    if ( GetCTL() )
    {
        if ( m_pCTL->IsValid() )
        {
            DWORD dwCertsInCTL = 0;

            fOk = QueryCTL()->GetContainedCertificates( ppcCertContext,
                                                        pdwCertsFound,
                                                        &dwCertsInCTL );
        }
        else
        {
            fOk = FALSE;
        }
    }
    else
    {
        fOk = GetRootStoreCertificates( ppcCertContext,
                                        pdwCertsFound );
    }

    Unlock();

    return fOk;
}

BOOL IIS_SSL_INFO::GetTrustedIssuerStore( OUT HCERTSTORE *phCertStore )
/*++

Routine Description:

    Returns a pointer to a handle to a cert store that contains the certs for all the
    trusted CAs for this server instance. If there is a CTL, the store will contain
    the certs in the CTL, else it will be a handle to the Local Machine Root store.

Arguments:

    phCertStore - pointer to handle to cert store containing trusted issuers. Updated on
    success. Caller has to call CertCloseStore() when done with the store handle.

Returns:

    TRUE if no internal errors occurred, FALSE if NOT
--*/
{
    DBG_ASSERT( CheckSignature() );

    Lock();

    BOOL fSuccess = FALSE;
    DWORD dwIndex = 0;
    PCCERT_CONTEXT *rgContexts = NULL;
    DWORD cCertsFound = 0;

    *phCertStore = NULL;

    //
    // If there is no CTL configurated, then return NULL for trusted store to
    // be used by schannel.  When NULL, schannel will use the root store +
    // the trusted store to determine trusted CAs (the desired effect)
    //

    if ( !GetCTL() )
    {
        Unlock();
        return TRUE;
    }

    if ( !m_hTrustedIssuerStore )
    {
        //
        // If there's no CTL configured, the store that holds our trusted issuers is the 
        // Root store;
        // we could just fall through and call GetTrustedIssuerCerts() [which will read all
        // the certs out of the Root store], but that's unnecessary because we can just
        // hand back a handle to the Root store.
        //

        {
            if ( !m_pCTL->IsValid() )
            {
                goto clean_up;
            }

            //
            // Get an in-memory store that will hold all the trusted issuer certs 
            //
            if ( !( m_hTrustedIssuerStore = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                                           0,
                                                           0,
                                                           0,
                                                           0 ) ) )
            {
                goto clean_up;
            }


            //
            // Try to retrieve all the certs in it and stuff them 
            // into the in-memory store
            //
            if ( !GetTrustedIssuerCerts( &rgContexts,
                                         &cCertsFound ) )
            {
                goto clean_up;
            }
            
            
            for ( dwIndex = 0; dwIndex < cCertsFound ; dwIndex++ )
            {
                if ( !CertAddCertificateContextToStore( m_hTrustedIssuerStore,
                                                        rgContexts[dwIndex],
                                                        CERT_STORE_ADD_ALWAYS,
                                                        NULL ) )
                {
                    goto clean_up;
                }
            }

            //
            // And finally make a copy of the store handle; note that the store will be empty if 
            // we don't have a valid CTL or we couldn't retrieve the certs in the CTL 
            //
            if ( !(*phCertStore = CertDuplicateStore( m_hTrustedIssuerStore ) ) )
            {
                goto clean_up;
            }
        }

        fSuccess = TRUE;

    clean_up:
        
        //
        // cleanup done only on failure
        //
        if ( !fSuccess )
        {
            if ( *phCertStore )
            {
                CertCloseStore( *phCertStore,
                                0 );
            }
            
            if ( m_hTrustedIssuerStore )
            {
                CertCloseStore( m_hTrustedIssuerStore,
                                0 );
                m_hTrustedIssuerStore = NULL;
            }
        }
        
        //
        // cleanup done regardless of success/failure
        //
        
        //
        // clean up all the cert contexts, because the store has a copy of them
        //
        if ( rgContexts )
        {
            for ( dwIndex = 0; dwIndex < cCertsFound; dwIndex++ )
            {
                if ( rgContexts[dwIndex] )
                {
                    CertFreeCertificateContext( rgContexts[dwIndex] );
                }
            }
            
            delete [] rgContexts;
        }
    }
    else
    {
        if ( *phCertStore = CertDuplicateStore(m_hTrustedIssuerStore) )
        {
            fSuccess = TRUE;
        }
    }
    
    Unlock();

    return fSuccess;
}

BOOL IIS_SSL_INFO::CreateEngineRootStore()
/*++

   Description

      Sets up the "Restricted Root" store that is passed to the cert chain engine used to
      verify client certificates. If there's a CTL attached to this object, the store contains
      only the self-signed cert that is at the top of the chain for the cert that signed 
      the CTL. If there's no CTL, the store is the Local Machine Root store.

   Arguments:

      None

   Returns:

      TRUE if successful, FALSE if not

--*/
{
    DBG_ASSERT( CheckSignature() );

    BOOL fOk = TRUE;

    Lock();

    if ( !m_hRestrictedRoot )
    {
        //
        // No CTL, we'll just use the Root store
        //
        if ( !GetCTL() )
        {
            if ( m_hRootStore )
            {
                m_hRestrictedRoot = CertDuplicateStore( m_hRootStore );
            }
            else
            {
                fOk = FALSE;
            }
        }
        else
        {
            if ( !m_pCTL->IsValid() )
            {
                Unlock();
                return FALSE;
            }
                 
            //
            // If we're signing our CTLs, the restricted root store should contain the
            // top of the chain for the cert that signed the CTL and this cert should be 
            // in the ROOT store
            //
            // If we're not signing our CTLs, the restricted root store is just an empty
            // store
            //
#if SIGNED_CTL
            PCCERT_CONTEXT pSigner = NULL;
            PCCERT_CONTEXT pIssuerCert = NULL;
            DWORD cCerts = 0;
            BOOL fTrustedRoot = FALSE;
            
            //
            // Get the cert that signed the CTL and try to find the issuers up to a self-signed
            // cert in the ROOT store
            //
            if ( m_pCTL->QuerySignerCert( &pSigner ) &&
                 pSigner )
            {
                if ( FindTopOfChain( pSigner,
                                     &pIssuerCert ) &&
                     IsTrustedRoot( pIssuerCert,
                                    &fTrustedRoot) &&
                     fTrustedRoot )
                {
                    //
                    // Create in memory store, put top of chain into it - this is the
                    // restricted-root store to use.
                    //
                    if ( m_hRestrictedRoot = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                                            0,
                                                            0,
                                                            0,
                                                            0 ) )
                    {
                        fOk = CertAddCertificateContextToStore( m_hRestrictedRoot,
                                                                pIssuerCert,
                                                                CERT_STORE_ADD_ALWAYS,
                                                                NULL );
                    }
                    else
                    {
                        fOk = FALSE;
                    }
                }
                else
                {
                    fOk = FALSE;
                }
            } // if ( QueryCTL()->QuerySigner
            else
            {
                fOk = FALSE;
            }
#else //SIGNED_CTL
            if ( !( m_hRestrictedRoot = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                                       0,
                                                       0,
                                                       0,
                                                       0 ) ) )
            {
                fOk = FALSE;
            }
            
#endif //SIGNED_CTL
        } //else clause for if ( !GetCTL() )
    }

    Unlock();

    return fOk;
}

BOOL IIS_SSL_INFO::CreateEngineTrustStore()
/*++

   Description

      Sets up the "Restricted Trust" store that is passed to the cert chain engine used to
      verify client certificates. If there is a CTL associated with this object, this store 
      contains only the CTL associated with this object. Else, we'll just leave it as
      NULL so that the chain engine uses the default. 


   Arguments:

      None

   Returns:

      TRUE if successful, FALSE if not

--*/
{
    DBG_ASSERT( CheckSignature() );

    BOOL fOk = TRUE;

    Lock();

    if ( !m_hRestrictedTrust )
    {
        if ( GetCTL() )
        {
            if ( !m_pCTL->IsValid() )
            {
                Unlock();
                return FALSE;
            }

            m_hRestrictedTrust = m_pCTL->GetMemoryStore();
            
            if ( !m_hRestrictedTrust )
            {
                fOk = FALSE;
            }
        }
        else
        {
            m_hRestrictedTrust = NULL;
        }
    }
    
    Unlock();

    return fOk;
}
        

DWORD IIS_SSL_INFO::Reference()
/*++

   Description

      Increases ref count

   Arguments:

   Returns:

       # of outstanding references

--*/
{
    DBG_ASSERT( CheckSignature() );

    DWORD dwRefCount = 0;

    Lock();

    dwRefCount = InterlockedIncrement( (LONG *) &m_dwRefCount );

#if SSLINFO_REF_COUNT

    if ( m_pRefTraceLog )
    {
        WriteRefTraceLogEx( m_pRefTraceLog,
                            dwRefCount,
                            (PVOID) this,
                            (PVOID) -1,
                            (PVOID) -1,
                            (PVOID) -1 );
    }

#endif //SSLINFO_REF_COUNT 
         
    Unlock();

    return dwRefCount;

}
                                   
DWORD IIS_SSL_INFO::Release( PVOID pvParam )
/*++

   Description

      Decreases ref count; deletes object if zero. Changed to static function to
      avoid not-quite-kosher "delete this" call.

   Arguments:

      pvParam - pointer to IIS_SSL_INFO 

   Returns:

       # of outstanding references

--*/

{
    IIS_SSL_INFO *pInfo = (IIS_SSL_INFO *) pvParam;

    pInfo->Lock();

    DBG_ASSERT( pInfo->m_dwRefCount > 0 );

    DWORD dwRefCount = InterlockedDecrement( (LONG *) &(pInfo->m_dwRefCount)  );


#if SSLINFO_REF_COUNT

    if ( pInfo->m_pRefTraceLog )
    {
        WriteRefTraceLogEx( pInfo->m_pRefTraceLog,
                            dwRefCount,
                            (PVOID) pInfo,
                            (PVOID) -1,
                            (PVOID) -1,
                            (PVOID) -1 );
    }

#endif //SSLINFO_REF_COUNT 

    if ( !dwRefCount )
    {
        pInfo->Unlock();
        delete pInfo;
    }
    else
    {
        pInfo->Unlock();
    }

    return dwRefCount;
}



BOOL IIS_SSL_INFO::UseDSMapper( VOID )
/*++

   Description

      Checks whether the NT 5 DS mapper is to be used for client certificate mapping

   Arguments:

      None 

   Returns:

      TRUE if mapper is to be used, false otherwise
--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( m_pMDObject );
    BOOL fUseMapper = FALSE;
    MB mb( m_pMDObject );

    if ( !mb.Open("/LM/W3SVC") )
    {
        return FALSE;
    }
   
    Lock();

    if ( !m_fCheckedDSMapper )
    {
        DWORD dwUseMapper = 0;

        if ( mb.GetDword( NULL,
                          MD_SSL_USE_DS_MAPPER,
                          IIS_MD_UT_SERVER,
                          &dwUseMapper,
                          METADATA_NO_ATTRIBUTES ) )
        {
            m_fUseDSMapper = (BOOL) dwUseMapper;
            m_fCheckedDSMapper = TRUE;
        }
    }

    fUseMapper = m_fUseDSMapper;
    
    Unlock();

    mb.Close();

    return fUseMapper;
}
                                 

BOOL IIS_SSL_INFO::GetCertChainEngine( OUT HCERTCHAINENGINE *phEngine )
/*++

   Description

      Returns a handle to an initialized cert chain engine

   Arguments:

      pEngine - pointer to engine handle, updated on success

   Returns:

      TRUE if engine was constructed successfully, FALSE if not
--*/
{
    DBG_ASSERT( CheckSignature() );

    *phEngine = NULL;
    
    Lock();

    if ( !m_hChainEngine )
    {
        DBG_ASSERT( !m_hRestrictedRoot && !m_hRestrictedTrust );

        //
        // Set up the "Restricted Root" store, which contains all the certs to be accepted as the
        // top of a cert chain for this instance
        //
        if ( !CreateEngineRootStore() )
        {
            Unlock();

            DBGPRINTF((DBG_CONTEXT,
                       "Failed to get engine root store : 0x%x\n",
                       GetLastError()));

            return FALSE;
        }
        //
        // Trust store to be used for CTLs
        //
        if ( !CreateEngineTrustStore() )
        {
            CertCloseStore( m_hRestrictedRoot,
                            0 );

            m_hRestrictedRoot = NULL;

            Unlock();

            DBGPRINTF((DBG_CONTEXT,
                       "Failed to get engine trust store : 0x%x\n",
                       GetLastError()));

            return FALSE;
        }

        //
        // Initialize cert chain config
        //
        CERT_CHAIN_ENGINE_CONFIG CCEC;

        memset( &CCEC, 0, sizeof(CCEC) );

        CCEC.cbSize = sizeof(CCEC);
        CCEC.hRestrictedRoot = m_hRestrictedRoot;
        CCEC.hRestrictedTrust = m_hRestrictedTrust;
        CCEC.dwFlags = CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE;

        if( m_hRootStore )
        {
            //
            // Include the root store in the collection of stores
            // to search.
            //
            CCEC.cAdditionalStore = 1;
            CCEC.rghAdditionalStore = &m_hRootStore;
        }

        //
        // Get us a chain engine, will you, Jeeves ...
        //
        if ( !CertCreateCertificateChainEngine( &CCEC,
                                                &m_hChainEngine ) )
        {
            CertCloseStore( m_hRestrictedRoot,
                            0 );
            m_hRestrictedRoot = NULL;

            CertCloseStore( m_hRestrictedTrust,
                            0 );
            m_hRestrictedTrust = NULL;

            Unlock();

            DBGPRINTF((DBG_CONTEXT,
                       "Failed to create chain engine : 0x%d\n",
                       GetLastError()));

            return FALSE;
        }

    }

    //
    // Got this far, everything is cool
    //
    *phEngine = m_hChainEngine;
        
    Unlock();    

    return TRUE;
}


BOOL IIS_SSL_INFO::FindTopOfChain( PCCERT_CONTEXT pcLeafCert,
                                   PCCERT_CONTEXT *ppcTopCert )
/*++

   Description

      Finds the top of the chain for a given cert

   Arguments:

      pcLeafCert - cert whose chain is to be built
      ppcTopCert - pointer to pointer to as far up as we could go in pcLeafCert's hierarchy. 
      Updated on success. Caller is responsible for cleaning it up.

   Returns:

      TRUE if search proceeded with no errors, FALSE otherwise
--*/

{
    DBG_ASSERT( CheckSignature() );

    *ppcTopCert = NULL;

    DBG_ASSERT( pcLeafCert );
    if( !pcLeafCert )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "NULL cert context passed to IIS_SSL_INFO::FindTopOfChain\n" 
                   ));
        return FALSE;
    }

    //
    // To build the chain, look for issuers in 4 stores : the store the cert came from,
    // and the "MY", "CA" and "ROOT" stores, cycling through the stores as necessary
    //

    PCCERT_CONTEXT pcIssuer = NULL;
    PCCERT_CONTEXT pcPresentLeaf = CertDuplicateCertificateContext( pcLeafCert );
    DWORD dwFlags = 0;
    DWORD dwStoresTried = 0;
    BOOL fCompleteChain = FALSE;
    HCERTSTORE hPresentStore = pcPresentLeaf->hCertStore;
    DWORD cNumCerts = 0;

    while ( 1 )
    {
        //
        // Bail when we get to the top of a chain
        //
        if ( IsSelfSignedCert( pcPresentLeaf ) )
        {
            fCompleteChain = TRUE;
            break;
        }

        pcIssuer = CertGetIssuerCertificateFromStore( hPresentStore,
                                                      pcPresentLeaf,
                                                      NULL,
                                                      &dwFlags );

        //
        // Got an issuer in this store
        //
        if ( pcIssuer )
        {
            //
            // Set up for next round
            //
            CertFreeCertificateContext( pcPresentLeaf );

            pcPresentLeaf = pcIssuer;

            dwStoresTried = 0;

            cNumCerts++;
        }
        //
        // No issuer in this store, switch to next store to look in
        //
        else
        {

            dwStoresTried++;

            if ( dwStoresTried == 4 ) //we've tried all the stores, time to bail
            {
                break;
            }

            if ( hPresentStore == m_hMyStore )
            {
                hPresentStore = m_hCAStore;
            }
            else if ( hPresentStore == m_hCAStore )
            {
                hPresentStore = m_hRootStore;
            }
            else if ( hPresentStore == m_hRootStore )
            {
                hPresentStore = pcPresentLeaf->hCertStore;
            }
            else
            {
                hPresentStore = m_hMyStore;
            }
        }
    } //while ( 1 )

    *ppcTopCert = pcPresentLeaf;

    return TRUE;
}


BOOL IIS_SSL_INFO::IsTrustedRoot( IN PCCERT_CONTEXT pcCert,
                                  OUT BOOL *pfTrustedRoot )
/*++

   Description

     Checks whether a cert is a trusted root ie in the Local Machine Root store and 
     self-signed

   Arguments:

      pcCert - cert to be checked
      pfTrustedRoot - pointer to bool that is updated on success

   Returns:

      TRUE if no errors occured, FALSE otherwise
--*/
{
    DBG_ASSERT( CheckSignature() );

    //
    // if cert isn't self-signed, it's not a trusted root
    //
    if ( !IsSelfSignedCert( pcCert ) )
    {
        *pfTrustedRoot = FALSE;
        return TRUE;
    }

    //
    // Check if cert can be found in ROOT store
    //
#define SHA1_HASH_SIZE 20

    BYTE rgbHash[SHA1_HASH_SIZE];
    DWORD cbHash = SHA1_HASH_SIZE;

    if ( !CertGetCertificateContextProperty( pcCert,
                                             CERT_SHA1_HASH_PROP_ID,
                                             (VOID *) rgbHash,
                                             &cbHash ) )
    {
        return FALSE;
    }

    CRYPT_HASH_BLOB HashBlob;
    HashBlob.cbData = cbHash;
    HashBlob.pbData = rgbHash;
        
    if ( !m_hRootStore ||
         !CertFindCertificateInStore( m_hRootStore,
                                      X509_ASN_ENCODING,
                                      0,
                                      CERT_FIND_SHA1_HASH,
                                      (VOID *) &HashBlob,
                                      NULL ) )
    {
        if ( !m_hRootStore || 
             GetLastError() != CRYPT_E_NOT_FOUND )
        {
            return FALSE;
        }
        else
        {
            *pfTrustedRoot = FALSE;
        }
    }
    else
    {
        *pfTrustedRoot = TRUE;
    }

    return TRUE;
}

BOOL IIS_SSL_INFO::GetRootStoreCertificates( OUT PCCERT_CONTEXT **ppcCertContext,
                                             OUT DWORD *pdwCerts )
/*++

Routine Description:

    Reads all the certificates out of the Local Machine Root store.
Arguments:

    pppCertContext - pointer to array of CERT_CONTEXT pointers, filled out with the found 
    CERT_CONTEXTS.
    Caller is responsible for releasing the contexts when done with them and deleting
    the array used to hold them.

    pdwCertsFound - pointer to number of cert contexts returned in ppCertContext

Returns:

    TRUE if no internal errors occurred, FALSE if NOT
--*/
{
    DBG_ASSERT( CheckSignature() );

    DWORD i = 0;

    Lock();

    //
    // Whatever the case, make sure we don't accidentally return garbage
    //
    *pdwCerts = 0;
    *ppcCertContext = NULL;

    if ( !m_acRootCerts )
    {
        if ( m_hRootStore )
        {
            *pdwCerts = 0;
            PCCERT_CONTEXT pCert = NULL;
            PCCERT_CONTEXT pPrevCert = NULL;
            m_cRootCerts = 0;

            //
            // In an ideal world, we'd know how many certs there are in the store, but it's not
            // an ideal world, so we have to count them ourselves
            //
            while ( pCert = CertEnumCertificatesInStore( m_hRootStore,
                                                         pPrevCert ) )
            {
                m_cRootCerts++;
                pPrevCert = pCert;
            }

            if ( GetLastError() != CRYPT_E_NOT_FOUND )
            {
                Unlock();
                return FALSE;
            }
                
            //
            // Guard against nothing being in the Root store. Unlikely, but we're
            // paranoid
            //
            if ( m_cRootCerts == 0 )
            {
                Unlock();
                return TRUE;
            }

            m_acRootCerts = new PCCERT_CONTEXT[m_cRootCerts];
            
            if ( !m_acRootCerts )
            {
                Unlock();
                return FALSE;
            }

            //
            // Make a copy of all the certs in the root store
            //
            pCert = NULL;
            pPrevCert = NULL;
            
            while ( pCert = CertEnumCertificatesInStore( m_hRootStore,
                                                         pPrevCert ) )
            {
                m_acRootCerts[i++] = CertDuplicateCertificateContext( pCert );
                pPrevCert = pCert;
            }

            DBG_ASSERT( i == m_cRootCerts );

            if ( GetLastError() != CRYPT_E_NOT_FOUND )
            {
                for ( i = 0; i < m_cRootCerts; i++ )
                {
                    CertFreeCertificateContext( m_acRootCerts[i] );
                }
                delete [] m_acRootCerts;

                m_acRootCerts = NULL;
                m_cRootCerts = 0;

                Unlock();
                return FALSE;
            }
        }
        else
        {
            Unlock();
            return FALSE;
        }
    }

    //
    // By this time, m_acRootCerts should have been allocated
    //
    *ppcCertContext = new PCCERT_CONTEXT[m_cRootCerts];

    if ( !*ppcCertContext )
    {
        Unlock();
        return FALSE;
    }

    //
    // Copy the certs 
    //
    for ( i = 0; i < m_cRootCerts; i++ )
    {
        (*ppcCertContext)[(*pdwCerts)++] = CertDuplicateCertificateContext( m_acRootCerts[i] );
    }

    Unlock();

    return TRUE;
}

BOOL IsSelfSignedCert( IN PCCERT_CONTEXT pCertContext )
/*++

Routine Description:

    Determines whether a cert is self-signed ie the top of a hierarchy

Arguments:

    pCertContext - cert to be checked

Returns:

    TRUE if cert is self-signed, FALSE otherwise

--*/

{
    //
    // Compare subject and issuer.
    //
    if(pCertContext->pCertInfo->Subject.cbData == pCertContext->pCertInfo->Issuer.cbData)
    {
        if(memcmp(pCertContext->pCertInfo->Subject.pbData,
                  pCertContext->pCertInfo->Issuer.pbData,  
                  pCertContext->pCertInfo->Issuer.cbData) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IIS_SSL_INFO::QueryCertValidity( DWORD *pdwStatus )
/*++

Routine Description:

    Retrieves status bits for server certificate ie ie not expired, whether 
    it's possible to construct a full chain up to a trusted root, whether it's 
    signature-valid etc and writes an entry to the system log if necessary.

Arguments:

     pdwStatus - pointer to status, updated on success

Returns:

    TRUE if status check was successful, FALSE if not

--*/
{
    *pdwStatus = 0;

    Lock();

    if ( !GetCertificate() || !m_pCert->IsValid() )
    {
        Unlock();
        return FALSE;
    }

    //
    // Should have a valid cert at this point
    //
    DBG_ASSERT( m_pCert );

    if ( m_pCert->IsFortezzaCert() )
    {
        m_dwCertChainStatus = 0;
    }

    if ( m_dwCertChainStatus == -1 )
    {
        //
        // Use the default per-process chain engine to try to build a chain
        //
        CERT_CHAIN_PARA CCP;
        PCCERT_CHAIN_CONTEXT pCertChain = NULL;
        memset( &CCP, 0, sizeof(CCP) );
        CCP.cbSize = sizeof(CCP);

        if ( CertGetCertificateChain( NULL,
                                      m_pCert->QueryCertContext(),
                                      NULL,
                                      m_pCert->QueryCertContext()->hCertStore,
                                      &CCP,
                                      0,
                                      NULL,
                                      &pCertChain ) )
        {
            m_dwCertChainStatus = pCertChain->TrustStatus.dwErrorStatus;
            
            CertFreeCertificateChain( pCertChain );
            pCertChain = NULL;

        }
        else
        {
            Unlock();

            return FALSE;
        }
    }

    *pdwStatus = m_dwCertChainStatus;

    Unlock();

    return TRUE;
}


VOID IIS_SSL_INFO::ReleaseFortezzaHandlers( VOID )
/*++
    Description:

       Uninstalls the context used to verify signatures on Fortezza certs.
       (The context is installed in the IIS_SERVER_CERT constructor)

    Arguments:

       None

    Returns:

       Nothing
--*/

{
    if ( IIS_SERVER_CERT::m_hFortezzaCtxt )
    {
        CryptUninstallDefaultContext( IIS_SERVER_CERT::m_hFortezzaCtxt,
                                      0,
                                      NULL );
        
        IIS_SERVER_CERT::m_hFortezzaCtxt = NULL;
    }

    if ( IIS_SERVER_CERT::m_hFortezzaCSP )
    {
        CryptReleaseContext( IIS_SERVER_CERT::m_hFortezzaCSP,
                             0 );
        
        IIS_SERVER_CERT::m_hFortezzaCSP = NULL;
    }

}                                          



BOOL IIS_SSL_INFO::CTLContainsCert( IN PCCERT_CONTEXT pCert,
                                    OUT BOOL* pfContains )
/*++
    Description:

       Checks whether a given cert is in the CTL for this object 

    Arguments:

        pCert - certificate to check for in CTL
        pfContains - flag that is set to true/false, if cert is/is not in CTL respectively
        
    Returns:

        BOOL indicating success/failure of attempt to check 
--*/
{
    DBG_ASSERT( CheckSignature() );

    PCCERT_CONTEXT *ppCertContext = NULL;
    DWORD dwCertsFound = 0;
    DWORD dwCertsInCTL = 0;
    BOOL fOK = TRUE;

    *pfContains = FALSE;


    if ( GetCTL() &&
         m_pCTL->IsValid() &&
         m_pCTL->GetContainedCertificates( &ppCertContext,
                                           &dwCertsFound,
                                           &dwCertsInCTL ) )
    {
#define SHA1_HASH_SIZE 20
        BYTE rgbCert1Hash[SHA1_HASH_SIZE];
        BYTE rgbCert2Hash[SHA1_HASH_SIZE];
        DWORD cbSize = SHA1_HASH_SIZE;

        if ( !CertGetCertificateContextProperty( pCert,
                                                 CERT_SHA1_HASH_PROP_ID,
                                                 rgbCert1Hash,
                                                 &cbSize ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Failed to get cert hash : 0x%d\n",
                       GetLastError()));

            fOK = FALSE;
            goto cleanup;
        }

        //
        // Iterate through all the certs in the CTL and compare hashes
        // This is a bit simple-minded
        //
        // CODEWORK : ask the CAPI people how to be smarter about this
        //
        for ( DWORD i = 0; i < dwCertsFound; i++ )
        {
            if ( !CertGetCertificateContextProperty( ppCertContext[i],
                                                     CERT_SHA1_HASH_PROP_ID,
                                                     rgbCert2Hash,
                                                     &cbSize ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Failed to get cert hash : 0x%d\n",
                           GetLastError()));

                fOK = FALSE;
                goto cleanup;
            }
            
            if ( !memcmp( rgbCert1Hash, rgbCert2Hash, SHA1_HASH_SIZE ) )
            {
                *pfContains = TRUE;
                break;
            }
        }
    }
    else
    {
        fOK = FALSE;
    }

cleanup:
    
    if ( ppCertContext )
    {
        for ( DWORD i = 0; i < dwCertsFound; i++ )
        {
            CertFreeCertificateContext( ppCertContext[i] );
        }

        delete [] ppCertContext;
    }

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\tcputil.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        tcputil.cxx

   Abstract:

        This module contains common utility routines for the TCP services

   Author:

        Johnl       09-Oct-1994     Created.
--*/


#include "tcpdllp.hxx"
#include <isplat.h>
#include <datetime.hxx>

LPSTR
ConvertUnicodeToAnsi(
    IN LPCWSTR  lpszUnicode,
    IN LPSTR    lpszAnsi,
    IN DWORD    cbAnsi
    )
/*++
    Description:
        Converts given null-terminated string into ANSI in the buffer supplied.

    Arguments:
        lpszUnicode         null-terminated string in Unicode
        lpszAnsi            buffer supplied to copy  string after conversion.
                    if ( lpszAnsi == NULL), then this module allocates space
                      using TCP_ALLOC, which should be freed calling TCP_FREE
                      by user.
        cbAnsi              number of bytes in lpszAnsi if specified

    Returns:
        pointer to converted ANSI string. NULL on errors.

    History:
        MuraliK     12-01-1994      Created.
--*/
{

    DWORD cchLen;
    DWORD nBytes;
    LPSTR lpszAlloc = NULL;

    if ( lpszUnicode == NULL) {
        return (NULL);
    }

    if ( lpszAnsi == NULL) {

        //
        // multiply by 2 to accomodate DBCS
        //

        cchLen = wcslen( lpszUnicode);
        nBytes = (cchLen+1) * sizeof(CHAR) * 2;
        lpszAlloc = (LPSTR ) TCP_ALLOC( nBytes );

    } else {

        lpszAlloc = lpszAnsi;
        nBytes = cbAnsi;
        DBG_ASSERT(nBytes > 0);
    }

    if ( lpszAlloc != NULL) {

        cchLen = WideCharToMultiByte( CP_ACP,
                                      WC_COMPOSITECHECK,
                                      lpszUnicode,
                                      -1,
                                      lpszAlloc,
                                      nBytes,
                                      NULL,  // lpszDefaultChar
                                      NULL   // lpfDefaultUsed
                                     );

        DBG_ASSERT(cchLen == (strlen(lpszAlloc)+1) );

        if ( cchLen == 0 ) {

            //
            // There was a failure. Free up buffer if need be.
            //

            DBGPRINTF((DBG_CONTEXT,"WideCharToMultiByte failed with %d\n",
                GetLastError()));

            if ( lpszAnsi == NULL) {
                TCP_FREE( lpszAlloc);
                lpszAlloc = NULL;
            } else {
                lpszAlloc[cchLen] = '\0';
            }

        } else {

            DBG_ASSERT( cchLen <= nBytes );
            DBG_ASSERT(lpszAlloc[cchLen-1] == '\0');

            lpszAlloc[cchLen-1] = '\0';
        }
    }

    return ( lpszAlloc);

} // ConvertUnicodeToAnsi



/*******************************************************************

    NAME:       ReadRegistryDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

********************************************************************/
DWORD ReadRegistryDwordA( HKEY    hkey,
                         LPCSTR   pszValueName,
                         DWORD    dwDefaultValue )
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL )
    {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDefaultValue = dwBuffer;
        }
    }
    return dwDefaultValue;
}   // ReadRegistryDwordA()


DWORD
WriteRegistryDwordA(
    IN HKEY hkey,
    IN LPCSTR pszValueName,
    IN DWORD   dwValue)
/*++
    Description:
        Writes the given DWORD value into registry entry specified
        by hkey\pszValueName

    Arguments:
        hkey            handle to registry key
        pszValueName    name of the value
        dwValue         new value for write

    Returns:
        Win32 error codes. NO_ERROR if successful.

    History:
        MuraliK     12-01-1994  Created.
--*/
{
    DWORD err;

    if ( (hkey == NULL) || (pszValueName == NULL) ) {

        err = ( ERROR_INVALID_PARAMETER);

    } else {
        err = RegSetValueExA( hkey,
                             pszValueName,
                             0,
                             REG_DWORD,
                             (LPBYTE ) &dwValue,
                             sizeof( dwValue));
    }

    return ( err);
} // WriteRegistryDwordA()





DWORD
WriteRegistryStringA(
    IN HKEY hkey,
    IN LPCSTR  pszValueName,
    IN LPCSTR  pszValue,
    IN DWORD   cbValue,
    IN DWORD   dwType
    )
/*++
    Description:
        Writes the given ANSI String into registry entry specified
        by hkey\pszValueName.

    Arguments:
        hkey            handle to registry key
        pszValueName    name of the value
        pszValue        new value for write
        cbValue         count of bytes of value written.
                        Should include terminating null characters.
         dwType         type of the value being written
                            ( REG_SZ, REG_MULTI_SZ etc)

    Returns:
        Win32 error codes. NO_ERROR if successful.

--*/
{
    DWORD err;

    DBG_ASSERT(dwType != REG_MULTI_SZ);
    DBG_ASSERT( (dwType == REG_SZ) || (dwType == REG_EXPAND_SZ) );

    if ( (hkey == NULL) ||
         (pszValueName == NULL) ||
         (cbValue == 0) ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        err = RegSetValueExA(
                    hkey,
                    pszValueName,
                    0,
                    dwType,
                    (LPBYTE ) pszValue,
                    cbValue);      // + 1 for null character
    }

    return ( err);
} // WriteRegistryStringA()


DWORD
WriteRegistryStringW(
    IN HKEY     hkey,
    IN LPCWSTR  pszValueName,
    IN LPCWSTR  pszValue,
    IN DWORD    cbValue,
    IN DWORD    dwType)
/*++
    Description:
        Writes the given ANSI String into registry entry specified
        by hkey\pszValueName.

    Arguments:
        hkey            handle to registry key
        pszValueName    name of the value
        pszValue        new value for write
        cbValue         count of bytes of value written.
                        Should include terminating null characters.
         dwType         type of the value being written
                            ( REG_SZ, REG_MULTI_SZ etc)

    Returns:
        Win32 error codes. NO_ERROR if successful.

--*/
{
    DWORD err;

    LPSTR ansiValue = NULL;
    LPSTR ansiName = NULL;

    if ( (hkey == NULL) ||
         (pszValueName == NULL) ||
         (cbValue == 0) ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        //
        // Convert to ansi
        //

        ansiName = ConvertUnicodeToAnsi( pszValueName, NULL, 0 );
        ansiValue = ConvertUnicodeToAnsi( pszValue, NULL, 0 );

        if ( (ansiName != NULL) && (ansiValue != NULL) ) {

            err = WriteRegistryStringA(hkey,
                                       ansiName,
                                       ansiValue,
                                       strlen(ansiValue)+1,
                                       dwType
                                       );
        } else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( ansiName != NULL ) {
        TCP_FREE(ansiName);
    }

    if ( ansiValue != NULL ) {
        TCP_FREE(ansiValue);
    }

    return ( err);
} // WriteRegistryStringW()


/*******************************************************************

    NAME:       ReadRegistryString

    SYNOPSIS:   Allocates necessary buffer space for a registry
                    string, then reads the string into the buffer.

    ENTRY:      pszValueName - The name of the value.

                pszDefaultValue - The default value to use if the
                    value cannot be read.

                fExpand - Expand environment strings if TRUE.

    RETURNS:    TCHAR * - The string, NULL if error.

    NOTES:      I always allocate one more character than actually
                necessary.  This will ensure that any code expecting
                to read a REG_MULTI_SZ will not explode if the
                registry actually contains a REG_SZ.

                This function cannot be called until after
                InitializeGlobals().

    HISTORY:
        KeithMo     15-Mar-1993 Created.

********************************************************************/
TCHAR * ReadRegistryString( HKEY     hkey,
                            LPCTSTR  pszValueName,
                            LPCTSTR  pszDefaultValue,
                            BOOL     fExpand )
{
    TCHAR   * pszBuffer1;
    TCHAR   * pszBuffer2;
    DWORD     cbBuffer;
    DWORD     dwType;
    DWORD     err;

    //
    //  Determine the buffer size.
    //

    pszBuffer1 = NULL;
    pszBuffer2 = NULL;
    cbBuffer   = 0;

    if( hkey == NULL )
    {
        //
        //  Pretend the key wasn't found.
        //

        err = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        err = RegQueryValueEx( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               NULL,
                               &cbBuffer );

        if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) )
        {
            if( ( dwType != REG_SZ ) &&
                ( dwType != REG_MULTI_SZ ) &&
                ( dwType != REG_EXPAND_SZ ) )
            {
                //
                //  Type mismatch, registry data NOT a string.
                //  Use default.
                //

                err = ERROR_FILE_NOT_FOUND;
            }
            else
            {
                //
                //  Item found, allocate a buffer.
                //

                pszBuffer1 = (TCHAR *) TCP_ALLOC( cbBuffer+sizeof(TCHAR) );

                if( pszBuffer1 == NULL )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    //
                    //  Now read the value into the buffer.
                    //

                    err = RegQueryValueEx( hkey,
                                           pszValueName,
                                           NULL,
                                           NULL,
                                           (LPBYTE)pszBuffer1,
                                           &cbBuffer );
                }
            }
        }
    }

    if( err == ERROR_FILE_NOT_FOUND )
    {
        //
        //  Item not found, use default value.
        //

        err = NO_ERROR;

        if( pszDefaultValue != NULL )
        {
            pszBuffer1 = (TCHAR *)TCP_ALLOC( (_tcslen(pszDefaultValue)+1) * sizeof(TCHAR) );

            if( pszBuffer1 == NULL )
            {   
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                _tcscpy( pszBuffer1, pszDefaultValue );
            }
        }
    }

    if( err != NO_ERROR )
    {
        //
        //  Tragic error reading registry, abort now.
        //

        goto ErrorCleanup;
    }

    //
    //  pszBuffer1 holds the registry value.  Now expand
    //  the environment strings if necessary.
    //

    if( !fExpand || TsIsWindows95() )
    {
        return pszBuffer1;
    }

    //
    //  Returns number of characters
    //
    cbBuffer = ExpandEnvironmentStrings( pszBuffer1,
                                         NULL,
                                         0 );

    //
    // The ExpandEnvironmentStrings() API is kinda poor.  In returning the
    // number of characters, we have no clue how large to make the buffer
    // in the case of DBCS characters.  Lets assume that each character is
    // 2 bytes. 
    //

    pszBuffer2 = (TCHAR *) TCP_ALLOC( (cbBuffer+1)*sizeof(WCHAR) );

    if( pszBuffer2 == NULL )
    {
        goto ErrorCleanup;
    }

    if( ExpandEnvironmentStrings( pszBuffer1,
                                  pszBuffer2,
                                  cbBuffer ) > cbBuffer )
    {
        goto ErrorCleanup;
    }

    //
    //  pszBuffer2 now contains the registry value with
    //  environment strings expanded.
    //

    TCP_FREE( pszBuffer1 );
    pszBuffer1 = NULL;

    return pszBuffer2;

ErrorCleanup:

    //
    //  Something tragic happend; free any allocated buffers
    //  and return NULL to the caller, indicating failure.
    //

    if( pszBuffer1 != NULL )
    {
        TCP_FREE( pszBuffer1 );
        pszBuffer1 = NULL;
    }

    if( pszBuffer2 != NULL )
    {
        TCP_FREE( pszBuffer2 );
        pszBuffer2 = NULL;
    }

    return NULL;

}   // ReadRegistryString


//
//  Chicago does not support the REG_MULTI_SZ registry value.  As
//  a hack (er, workaround), we'll create *keys* in the registry
//  in place of REG_MULTI_SZ *values*.  We'll then use the names
//  of any values under the key as the REG_MULTI_SZ entries.  So,
//  instead of this:
//
//      ..\Control\ServiceProvider
//          ProviderOrder = REG_MULTI_SZ "MSTCP"
//                                       "NWLINK"
//                                       "FOOBAR"
//
//  We'll use this:
//
//      ..\Control\Service\Provider\ProviderOrder
//          MSTCP = REG_SZ ""
//          NWLINK = REG_SZ ""
//          FOOBAR = REG_SZ ""
//
//  This function takes an open registry key handle, enumerates
//  the names of values contained within the key, and constructs
//  a REG_MULTI_SZ string from the value names.
//
//  Note that this function is not multithread safe; if another
//  thread (or process) creates or deletes values under the
//  specified key, the results are indeterminate.
//
//  This function returns NULL on error.  It returns non-NULL
//  on success, even if the resulting REG_MULTI_SZ is empty.
//

TCHAR *
KludgeMultiSz(
    HKEY hkey,
    LPDWORD lpdwLength
    )
{
    LONG  err;
    DWORD iValue;
    DWORD cchTotal;
    DWORD cchValue;
    TCHAR szValue[MAX_PATH];
    LPTSTR lpMultiSz;
    LPTSTR lpTmp;
    LPTSTR lpEnd;

    //
    //  Enumerate the values and total up the lengths.
    //

    iValue = 0;
    cchTotal = 0;

    for( ; ; )
    {
        cchValue = sizeof(szValue)/sizeof(TCHAR);

        err = RegEnumValue( hkey,
                            iValue,
                            szValue,
                            &cchValue,
                            NULL,
                            NULL,
                            NULL,
                            NULL );

        if( err != NO_ERROR )
        {
            break;
        }

        //
        //  Add the length of the value's name, plus one
        //  for the terminator.
        //

        cchTotal += _tcslen( szValue ) + 1;

        //
        //  Advance to next value.
        //

        iValue++;
    }

    //
    //  Add one for the final terminating NULL.
    //

    cchTotal++;
    *lpdwLength = cchTotal;

    //
    //  Allocate the MULTI_SZ buffer.
    //

    lpMultiSz = (TCHAR *) TCP_ALLOC( cchTotal * sizeof(TCHAR) );

    if( lpMultiSz == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    memset( lpMultiSz, 0, cchTotal * sizeof(TCHAR) );

    //
    //  Enumerate the values and append to the buffer.
    //

    iValue = 0;
    lpTmp = lpMultiSz;
    lpEnd = lpMultiSz + cchTotal;

    for( ; ; )
    {
        cchValue = sizeof(szValue)/sizeof(TCHAR);

        err = RegEnumValue( hkey,
                            iValue,
                            szValue,
                            &cchValue,
                            NULL,
                            NULL,
                            NULL,
                            NULL );

        if( err != NO_ERROR )
        {
            break;
        }

        //
        //  Compute the length of the value name (including
        //  the terminating NULL).
        //

        cchValue = _tcslen( szValue ) + 1;

        //
        //  Determine if there is room in the array, taking into
        //  account the second NULL that terminates the string list.
        //

        if( ( lpTmp + cchValue + 1 ) > lpEnd )
        {
            break;
        }

        //
        //  Append the value name.
        //

        _tcscpy( lpTmp, szValue );
        lpTmp += cchValue;

        //
        //  Advance to next value.
        //

        iValue++;
    }

    //
    //  Success!
    //

    return (LPTSTR)lpMultiSz;

}   // KludgeMultiSz



BOOL
ReadRegistryStr(
    IN HKEY hkeyReg,
    OUT STR & str,
    IN LPCTSTR lpszValueName,
    IN LPCTSTR lpszDefaultValue,
    IN BOOL  fExpand )
/*++

  Reads the registry string into the string buffer supplied.
  If there is no value in the registry the default value is set to
  be the value of the string.

  If an environment expansion is requested, it is also performed.

  Arguments:

    hkeyReg     handle for registry entry
    str         string to contain the result of read operation
    lpszValueName
                pointer to string containing the key name whose
                    value needs to be fetched.
    lpszDefaultValue
                pointer to string containing a value which is used if no
                     value exists in the registry.
    fExpand     boolean flag indicating if an expansion is desired.

  Returns:
    FALSE if there is any error.
    TRUE when the string is successfully set.
--*/
{
    BOOL fReturn = FALSE;
    LPTSTR pszValueAlloc;

    pszValueAlloc = ReadRegistryString( hkeyReg, lpszValueName,
                                       lpszDefaultValue, fExpand);

    if ( pszValueAlloc != NULL) {

        fReturn = str.Copy( pszValueAlloc);
        TCP_FREE( pszValueAlloc);
    } else {

        DBG_ASSERT( fReturn == FALSE);
    }

    if ( !fReturn) {

        IF_DEBUG( ERROR) {

            DWORD err = GetLastError();

            DBGPRINTF(( DBG_CONTEXT,
                       " Error %u in ReadRegistryString( %08x, %s).\n",
                       err, hkeyReg, lpszValueName));

            SetLastError(err);
        }
    }

    return ( fReturn);
} // ReadRegistryStr

/*******************************************************************

    NAME:       FlipSlashes

    SYNOPSIS:   Flips the Unix-ish forward slashes ('/') into Dos-ish
                back slashes ('\').

    ENTRY:      pszPath - The path to munge.

    RETURNS:    TCHAR * - pszPath.

    HISTORY:
        KeithMo     04-Jun-1993 Created.

********************************************************************/
TCHAR * FlipSlashes( TCHAR * pszPath )
{
    TCHAR   ch;
    TCHAR * pszScan = pszPath;

    while( ( ch = *pszScan ) != TEXT('\0') )
    {
        if( ch == TEXT('/') )
        {
            *pszScan = TEXT('\\');
        }

        pszScan++;
    }

    return pszPath;

}   // FlipSlashes





/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    i_ntoa.c

Abstract:

    This module implements a routine to convert a numerical IP address
    into a dotted-decimal character string Internet address.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     9-20-91     created
    davidtr     9-19-95     completely rewritten for performance
    muralik     3-Oct-1995  massaged it for Internet services

Notes:

    Exports:
        InetNtoa()

--*/


#define UC(b)   (((int)b)&0xff)

//
// This preinitialized array defines the strings to be used for
// inet_ntoa.  The index of each row corresponds to the value for a byte
// in an IP address.  The first three bytes of each row are the
// char/string value for the byte, and the fourth byte in each row is
// the length of the string required for the byte.  This approach
// allows a fast implementation with no jumps.
//

static BYTE NToACharStrings[][4] = {
    '0', 'x', 'x', 1,
    '1', 'x', 'x', 1,
    '2', 'x', 'x', 1,
    '3', 'x', 'x', 1,
    '4', 'x', 'x', 1,
    '5', 'x', 'x', 1,
    '6', 'x', 'x', 1,
    '7', 'x', 'x', 1,
    '8', 'x', 'x', 1,
    '9', 'x', 'x', 1,
    '1', '0', 'x', 2,
    '1', '1', 'x', 2,
    '1', '2', 'x', 2,
    '1', '3', 'x', 2,
    '1', '4', 'x', 2,
    '1', '5', 'x', 2,
    '1', '6', 'x', 2,
    '1', '7', 'x', 2,
    '1', '8', 'x', 2,
    '1', '9', 'x', 2,
    '2', '0', 'x', 2,
    '2', '1', 'x', 2,
    '2', '2', 'x', 2,
    '2', '3', 'x', 2,
    '2', '4', 'x', 2,
    '2', '5', 'x', 2,
    '2', '6', 'x', 2,
    '2', '7', 'x', 2,
    '2', '8', 'x', 2,
    '2', '9', 'x', 2,
    '3', '0', 'x', 2,
    '3', '1', 'x', 2,
    '3', '2', 'x', 2,
    '3', '3', 'x', 2,
    '3', '4', 'x', 2,
    '3', '5', 'x', 2,
    '3', '6', 'x', 2,
    '3', '7', 'x', 2,
    '3', '8', 'x', 2,
    '3', '9', 'x', 2,
    '4', '0', 'x', 2,
    '4', '1', 'x', 2,
    '4', '2', 'x', 2,
    '4', '3', 'x', 2,
    '4', '4', 'x', 2,
    '4', '5', 'x', 2,
    '4', '6', 'x', 2,
    '4', '7', 'x', 2,
    '4', '8', 'x', 2,
    '4', '9', 'x', 2,
    '5', '0', 'x', 2,
    '5', '1', 'x', 2,
    '5', '2', 'x', 2,
    '5', '3', 'x', 2,
    '5', '4', 'x', 2,
    '5', '5', 'x', 2,
    '5', '6', 'x', 2,
    '5', '7', 'x', 2,
    '5', '8', 'x', 2,
    '5', '9', 'x', 2,
    '6', '0', 'x', 2,
    '6', '1', 'x', 2,
    '6', '2', 'x', 2,
    '6', '3', 'x', 2,
    '6', '4', 'x', 2,
    '6', '5', 'x', 2,
    '6', '6', 'x', 2,
    '6', '7', 'x', 2,
    '6', '8', 'x', 2,
    '6', '9', 'x', 2,
    '7', '0', 'x', 2,
    '7', '1', 'x', 2,
    '7', '2', 'x', 2,
    '7', '3', 'x', 2,
    '7', '4', 'x', 2,
    '7', '5', 'x', 2,
    '7', '6', 'x', 2,
    '7', '7', 'x', 2,
    '7', '8', 'x', 2,
    '7', '9', 'x', 2,
    '8', '0', 'x', 2,
    '8', '1', 'x', 2,
    '8', '2', 'x', 2,
    '8', '3', 'x', 2,
    '8', '4', 'x', 2,
    '8', '5', 'x', 2,
    '8', '6', 'x', 2,
    '8', '7', 'x', 2,
    '8', '8', 'x', 2,
    '8', '9', 'x', 2,
    '9', '0', 'x', 2,
    '9', '1', 'x', 2,
    '9', '2', 'x', 2,
    '9', '3', 'x', 2,
    '9', '4', 'x', 2,
    '9', '5', 'x', 2,
    '9', '6', 'x', 2,
    '9', '7', 'x', 2,
    '9', '8', 'x', 2,
    '9', '9', 'x', 2,
    '1', '0', '0', 3,
    '1', '0', '1', 3,
    '1', '0', '2', 3,
    '1', '0', '3', 3,
    '1', '0', '4', 3,
    '1', '0', '5', 3,
    '1', '0', '6', 3,
    '1', '0', '7', 3,
    '1', '0', '8', 3,
    '1', '0', '9', 3,
    '1', '1', '0', 3,
    '1', '1', '1', 3,
    '1', '1', '2', 3,
    '1', '1', '3', 3,
    '1', '1', '4', 3,
    '1', '1', '5', 3,
    '1', '1', '6', 3,
    '1', '1', '7', 3,
    '1', '1', '8', 3,
    '1', '1', '9', 3,
    '1', '2', '0', 3,
    '1', '2', '1', 3,
    '1', '2', '2', 3,
    '1', '2', '3', 3,
    '1', '2', '4', 3,
    '1', '2', '5', 3,
    '1', '2', '6', 3,
    '1', '2', '7', 3,
    '1', '2', '8', 3,
    '1', '2', '9', 3,
    '1', '3', '0', 3,
    '1', '3', '1', 3,
    '1', '3', '2', 3,
    '1', '3', '3', 3,
    '1', '3', '4', 3,
    '1', '3', '5', 3,
    '1', '3', '6', 3,
    '1', '3', '7', 3,
    '1', '3', '8', 3,
    '1', '3', '9', 3,
    '1', '4', '0', 3,
    '1', '4', '1', 3,
    '1', '4', '2', 3,
    '1', '4', '3', 3,
    '1', '4', '4', 3,
    '1', '4', '5', 3,
    '1', '4', '6', 3,
    '1', '4', '7', 3,
    '1', '4', '8', 3,
    '1', '4', '9', 3,
    '1', '5', '0', 3,
    '1', '5', '1', 3,
    '1', '5', '2', 3,
    '1', '5', '3', 3,
    '1', '5', '4', 3,
    '1', '5', '5', 3,
    '1', '5', '6', 3,
    '1', '5', '7', 3,
    '1', '5', '8', 3,
    '1', '5', '9', 3,
    '1', '6', '0', 3,
    '1', '6', '1', 3,
    '1', '6', '2', 3,
    '1', '6', '3', 3,
    '1', '6', '4', 3,
    '1', '6', '5', 3,
    '1', '6', '6', 3,
    '1', '6', '7', 3,
    '1', '6', '8', 3,
    '1', '6', '9', 3,
    '1', '7', '0', 3,
    '1', '7', '1', 3,
    '1', '7', '2', 3,
    '1', '7', '3', 3,
    '1', '7', '4', 3,
    '1', '7', '5', 3,
    '1', '7', '6', 3,
    '1', '7', '7', 3,
    '1', '7', '8', 3,
    '1', '7', '9', 3,
    '1', '8', '0', 3,
    '1', '8', '1', 3,
    '1', '8', '2', 3,
    '1', '8', '3', 3,
    '1', '8', '4', 3,
    '1', '8', '5', 3,
    '1', '8', '6', 3,
    '1', '8', '7', 3,
    '1', '8', '8', 3,
    '1', '8', '9', 3,
    '1', '9', '0', 3,
    '1', '9', '1', 3,
    '1', '9', '2', 3,
    '1', '9', '3', 3,
    '1', '9', '4', 3,
    '1', '9', '5', 3,
    '1', '9', '6', 3,
    '1', '9', '7', 3,
    '1', '9', '8', 3,
    '1', '9', '9', 3,
    '2', '0', '0', 3,
    '2', '0', '1', 3,
    '2', '0', '2', 3,
    '2', '0', '3', 3,
    '2', '0', '4', 3,
    '2', '0', '5', 3,
    '2', '0', '6', 3,
    '2', '0', '7', 3,
    '2', '0', '8', 3,
    '2', '0', '9', 3,
    '2', '1', '0', 3,
    '2', '1', '1', 3,
    '2', '1', '2', 3,
    '2', '1', '3', 3,
    '2', '1', '4', 3,
    '2', '1', '5', 3,
    '2', '1', '6', 3,
    '2', '1', '7', 3,
    '2', '1', '8', 3,
    '2', '1', '9', 3,
    '2', '2', '0', 3,
    '2', '2', '1', 3,
    '2', '2', '2', 3,
    '2', '2', '3', 3,
    '2', '2', '4', 3,
    '2', '2', '5', 3,
    '2', '2', '6', 3,
    '2', '2', '7', 3,
    '2', '2', '8', 3,
    '2', '2', '9', 3,
    '2', '3', '0', 3,
    '2', '3', '1', 3,
    '2', '3', '2', 3,
    '2', '3', '3', 3,
    '2', '3', '4', 3,
    '2', '3', '5', 3,
    '2', '3', '6', 3,
    '2', '3', '7', 3,
    '2', '3', '8', 3,
    '2', '3', '9', 3,
    '2', '4', '0', 3,
    '2', '4', '1', 3,
    '2', '4', '2', 3,
    '2', '4', '3', 3,
    '2', '4', '4', 3,
    '2', '4', '5', 3,
    '2', '4', '6', 3,
    '2', '4', '7', 3,
    '2', '4', '8', 3,
    '2', '4', '9', 3,
    '2', '5', '0', 3,
    '2', '5', '1', 3,
    '2', '5', '2', 3,
    '2', '5', '3', 3,
    '2', '5', '4', 3,
    '2', '5', '5', 3
};



DWORD
InetNtoa(
    IN  struct in_addr  inaddr,
    OUT CHAR * pchBuffer
    )

/*++

Routine Description:

    This function takes an Internet address structure specified by the
    in parameter.  It returns an ASCII string representing the address
    in ".'' notation as "a.b.c.d".

Arguments:

    inaddr - A structure which represents an Internet host address.
    pchBuffer - pointer to at least 16 character buffer for storing
                 the result of conversion.
Return Value:

    If no error occurs, InetNtoa() returns NO_ERROR with the buffer containing
     the text address in standard "." notation.
    Otherwise, it returns Win32 error code.


--*/

{
    PUCHAR p;
    PUCHAR buffer = (PUCHAR ) pchBuffer;
    PUCHAR b = buffer;

    if ( pchBuffer == NULL) {

        return ( ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // We do not check for sufficient length of the buffer yet. !!
    //

    //
    // In an unrolled loop, calculate the string value for each of the four
    // bytes in an IP address.  Note that for values less than 100 we will
    // do one or two extra assignments, but we save a test/jump with this
    // algorithm.
    //

    p = (PUCHAR) &inaddr;

    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b = '\0';

    return ( NO_ERROR);

} // InetNtoa()


BOOL
TcpSockSend(
    IN SOCKET      sock,
    IN LPVOID      pBuffer,
    IN DWORD       cbBuffer,
    OUT PDWORD     pcbTotalSent,
    IN DWORD       nTimeout
    )
/*++

    Description:
        Do async socket send

    Arguments:
        sock - socket
        pBuffer - buffer to send
        cbBuffer - size of buffer
        pcbTotalSent - bytes sent
        nTimeout - timeout in seconds to use

    Returns:
        FALSE if there is any error.
        TRUE otherwise

--*/
{
    INT         serr = 0;
    INT         cbSent;
    DWORD       dwBytesSent = 0;
    ULONG       one;
    PCHAR       pWin95Buffer = NULL;

    DBG_ASSERT( pBuffer != NULL );

    //
    // On windows95, setup i/o handle to blocking mode,
    // as blocking I/O is requested
    //

    if ( TsIsWindows95() ) {

        one = 0;
        ioctlsocket( sock, FIONBIO, &one );

        //
        // Probe for writability, if r/o, copy the buffer.
        // This is a workaround for a win95 bug where static pages
        // are getting dirtied when used for sends.
        //

        if ( IsBadWritePtr( pBuffer, 1 ) ) {

            DBGPRINTF((DBG_CONTEXT,
                "TcpSockSend RO[%x] detected. Doing copy.\n",pBuffer));

            pWin95Buffer = (PCHAR)LocalAlloc(LMEM_FIXED, cbBuffer);

            if ( pWin95Buffer != NULL ) {

                CopyMemory(pWin95Buffer, pBuffer, cbBuffer);
                pBuffer = pWin95Buffer;
            } else {

                serr = WSAENOBUFS;
                goto exit;
            }
        }
    }

    //
    //  Loop until there's no more data to send.
    //

    while( cbBuffer > 0 ) {

        //
        //  Wait for the socket to become writeable.
        //

        serr = 0;

        if ( TsIsWindows95() ) {

            BOOL  fWrite = FALSE;
            serr = WaitForSocketWorker(
                        INVALID_SOCKET,
                        sock,
                        NULL,
                        &fWrite,
                        nTimeout
                        );
        }

        if( serr == 0 ) {

            //
            //  Write a block to the socket.
            //

            cbSent = send( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

            if( cbSent < 0 ) {

                //
                //  Socket error.
                //

                serr = WSAGetLastError();
                DBGPRINTF((DBG_CONTEXT, "TcpSockSend error %d\n",serr));

            } else {

                dwBytesSent += (DWORD)cbSent;

                IF_DEBUG( ERROR ) {
                    DBGPRINTF(( DBG_CONTEXT,
                       "HTTP: Synchronous send %d bytes @%p to socket %d\n",
                       cbSent, pBuffer, sock ));
                }
            }
        }

        if( serr != 0 ) {
            break;
        }

        pBuffer   = (LPVOID)( (LPBYTE)pBuffer + cbSent );
        cbBuffer -= (DWORD)cbSent;
    }

exit:

    if (pcbTotalSent) {
        *pcbTotalSent = dwBytesSent;
    }

    //
    // Set up i/o handle to non-blocking mode , default for ATQ
    //

    if ( TsIsWindows95() ) {
        one = 1;
        ioctlsocket( sock, FIONBIO, &one );

        if ( pWin95Buffer != NULL ) {
            LocalFree(pWin95Buffer);
        }
    }

    if ( serr == 0 ) {
        return(TRUE);
    } else {

        IF_DEBUG( ERROR ) {
            DBGPRINTF(( DBG_CONTEXT,
                "HTTP: Synchronous send socket error %d on socket %d.\n",
                 serr, sock));
        }

        SetLastError(serr);
        return(FALSE);
    }

}   // SockSend



BOOL
TcpSockRecv(
    IN SOCKET       sock,
    IN LPVOID       pBuffer,
    IN DWORD        cbBuffer,
    OUT LPDWORD     pbReceived,
    IN DWORD        nTimeout
    )
/*++

    Description:
        Do async socket recv

    Arguments:
        sock - The target socket.
        pBuffer - Will receive the data.
        cbBuffer - The size (in bytes) of the buffer.
        pbReceived - Will receive the actual number of bytes
        nTimeout - timeout in seconds

    Returns:
        TRUE, if successful

--*/
{
    INT         serr = 0;
    DWORD       cbTotal = 0;
    INT         cbReceived;
    DWORD       dwBytesRecv = 0;

    ULONG       one;
    BOOL fRead = FALSE;

    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( pbReceived != NULL );

    //
    // Set up i/o handle to blocking mode , as blocking I/O is requested
    //

    if ( TsIsWindows95() ) {
        one = 0;
        ioctlsocket( sock, FIONBIO, &one );
    }

    //
    //  Wait for the socket to become readable.
    //

    serr = WaitForSocketWorker(
                        sock,
                        INVALID_SOCKET,
                        &fRead,
                        NULL,
                        nTimeout
                        );

    if( serr == 0 )
    {
        //
        //  Read a block from the socket.
        //
        DBG_ASSERT( fRead);

        cbReceived = recv( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

        if( cbReceived < 0 )
        {
            //
            //  Socket error.
            //

            serr = WSAGetLastError();
        }
        else {
            cbTotal = cbReceived;
        }
    }

    if( serr == 0 )
    {
        //
        //  Return total byte count to caller.
        //

        *pbReceived = cbTotal;
    }
    else
    {
        IF_DEBUG( ERROR )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "HTTP: Syncronous rcv socket error %d during recv on socket %d\n",
                        serr,
                        sock ));
        }
    }

    //
    // Set up i/o handle to blocking mode , as blocking I/O is requested
    //

    if ( TsIsWindows95() ) {
        one = 0;
        ioctlsocket( sock, FIONBIO, &one );
    }

    if ( serr == 0 ) {
        return(TRUE);
    } else {
        SetLastError(serr);
        return(FALSE);
    }

}   // SockRecv


INT
WaitForSocketWorker(
    IN SOCKET   sockRead,
    IN SOCKET   sockWrite,
    IN LPBOOL   pfRead,
    IN LPBOOL   pfWrite,
    IN DWORD    nTimeout
    )
/*++

    Description:
        Wait routine
        NOTES:      Any (but not all) sockets may be INVALID_SOCKET.  For
                    each socket that is INVALID_SOCKET, the corresponding
                    pf* parameter may be NULL.

    Arguments:
        sockRead - The socket to check for readability.
        sockWrite - The socket to check for writeability.
        pfRead - Will receive TRUE if sockRead is readable.
        pfWrite - Will receive TRUE if sockWrite is writeable.
        nTimeout - timeout in seconds

    Returns:
        SOCKERR - 0 if successful, !0 if not.  Will return
            WSAETIMEDOUT if the timeout period expired.

--*/
{
    INT       serr = 0;
    TIMEVAL   timeout;
    LPTIMEVAL ptimeout;
    fd_set    fdsRead;
    fd_set    fdsWrite;
    INT       res;

    //
    //  Ensure we got valid parameters.
    //

    if( ( sockRead  == INVALID_SOCKET ) &&
        ( sockWrite == INVALID_SOCKET ) ) {

        return WSAENOTSOCK;
    }

    timeout.tv_sec = (LONG )nTimeout;

    if( timeout.tv_sec == 0 ) {

        //
        //  If the connection timeout == 0, then we have no timeout.
        //  So, we block and wait for the specified conditions.
        //

        ptimeout = NULL;

    } else {

        //
        //  The connectio timeout is > 0, so setup the timeout structure.
        //

        timeout.tv_usec = 0;

        ptimeout = &timeout;
    }

    for( ; ; ) {

        //
        //  Setup our socket sets.
        //

        FD_ZERO( &fdsRead );
        FD_ZERO( &fdsWrite );

        if( sockRead != INVALID_SOCKET ) {

            FD_SET( sockRead, &fdsRead );
            DBG_ASSERT( pfRead != NULL );
            *pfRead = FALSE;
        }

        if( sockWrite != INVALID_SOCKET ) {

            FD_SET( sockWrite, &fdsWrite );
            DBG_ASSERT( pfWrite != NULL );
            *pfWrite = FALSE;
        }

        //
        //  Wait for one of the conditions to be met.
        //

        res = select( 0, &fdsRead, &fdsWrite, NULL, ptimeout );

        if( res == 0 ) {

            //
            //  Timeout.
            //

            serr = WSAETIMEDOUT;
            break;

        } else if( res == SOCKET_ERROR ) {

            //
            //  Bad news.
            //

            serr = WSAGetLastError();
            break;
        } else {

            BOOL fSomethingWasSet = FALSE;

            if( pfRead != NULL ) {

                *pfRead   = FD_ISSET( sockRead,   &fdsRead   );
                fSomethingWasSet = TRUE;
            }

            if( pfWrite != NULL ) {
                *pfWrite  = FD_ISSET( sockWrite,  &fdsWrite  );
                fSomethingWasSet = TRUE;
            }

            if( fSomethingWasSet ) {

                //
                //  Success.
                //

                serr = 0;
                break;
            } else {
                //
                //  select() returned with neither a timeout, nor
                //  an error, nor any bits set.  This feels bad...
                //

                DBG_ASSERT( FALSE );
                continue;
            }
        }
    }

    return serr;

} // WaitForSocketWorker()


BOOL
TcpSockTest(
    IN SOCKET      sock
    )
/*++

    Description:
        Test the socket if still connected.
        Use select, and if readable, use recv

    Arguments:
        sock - socket

    Returns:
        TRUE if the socket most likely is still connected
        FALSE if the socket is disconnected or an error occured

--*/
{
    TIMEVAL   timeout;
    fd_set    fdsRead;
    INT       res;
    CHAR      bOneByte;

    // select for read with zero timeout

    FD_ZERO( &fdsRead );
    FD_SET( sock, &fdsRead );

    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
   
    res = select( 0, &fdsRead, NULL, NULL, &timeout );

    if ( res == 0 ) {
    
        // No data to be read -- 
        //   have to assume socket is still connected
        return TRUE;

    } else if ( res == SOCKET_ERROR ) {
    
        // Something went wrong during select -- assume disconnected
        return FALSE;
    }

    DBG_ASSERT( res == 1 );

    // recv 1 byte (PEEK)
    // select returning 1 above guarantees recv will not block

    res = recv( sock, &bOneByte, 1, MSG_PEEK );

    if ( res == 0 || res == SOCKET_ERROR ) {
        // Socket closed or an error -- socket is disconnected
        return FALSE;
    }
    
    DBG_ASSERT( res == 1 );

    // Read one byte successfully -- assume still connected
    return TRUE;
    
}   // SockTest



BOOL
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    )
/*++

    Description:
        Does Asynchronous file reads.  Assumes that NT handles are
        opened for OVERLAPPED I/O, win95 handles are not.

    Arguments:
        hFile - Handle to use for the read
        Buffer - Buffer to read with
        nBuffer - size of buffer
        nRead - returns the number of bytes read
        Overlapped - user supplied overlapped structure

    Returns:
        TRUE/FALSE
--*/
{
    BOOL        fNewEvent = FALSE;
    OVERLAPPED  ov;
    BOOL        fRet = FALSE;

    if ( Overlapped == NULL ) {

        Overlapped = &ov;
        ov.Offset = 0;
        ov.OffsetHigh = 0;
        ov.hEvent = IIS_CREATE_EVENT(
                        "OVERLAPPED::hEvent",
                        &ov,
                        TRUE,
                        FALSE
                        );

        if ( ov.hEvent == NULL ) {
            DBGPRINTF((DBG_CONTEXT,"CreateEvent failed with %d\n",
                GetLastError()));
            goto ErrorExit;
        }

        fNewEvent = TRUE;
    }

    if ( !TsIsWindows95() ) {

        DWORD err = NO_ERROR;

        if ( !ReadFile( hFile,
                        Buffer,
                        nBuffer,
                        nRead,
                        Overlapped )) {

            err = GetLastError();

            if ( (err != ERROR_IO_PENDING) &&
                 (err != ERROR_HANDLE_EOF) ) {

                DBGPRINTF((DBG_CONTEXT,"Error %d in ReadFile\n",
                    err));

                goto ErrorExit;
            }
        }

        if ( err == ERROR_IO_PENDING ) {

            if ( !GetOverlappedResult( hFile,
                                       Overlapped,
                                       nRead,
                                       TRUE )) {

                err = GetLastError();

                DBGPRINTF((DBG_CONTEXT,"Error %d in GetOverlappedResult\n",
                    err));

                if ( err != ERROR_HANDLE_EOF ) {
                    goto ErrorExit;
                }
            }
        }

    } else {

        //
        // No async file i/o for win95
        //

        if ( !ReadFile( hFile,
                        Buffer,
                        nBuffer,
                        nRead,
                        NULL )) {

            DBGPRINTF((DBG_CONTEXT,"Error %d in ReadFile\n",
                GetLastError()));

            goto ErrorExit;
        }
    }

    fRet = TRUE;

ErrorExit:

    if ( fNewEvent ) {
        DBG_REQUIRE(CloseHandle( ov.hEvent ));
    }

    return(fRet);

} // DoSynchronousReadFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\tokenacl.cxx ===
/*===================================================================
Microsoft Internet Information Server

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

File: TokenAcl.cxx

Owner: AndrewS

This file contains code related to NT security on impersonation tokens
===================================================================*/
#include "tcpdllp.hxx"
#pragma hdrstop


// Local Defines


// Local functions
HRESULT ExpandAcl(PACL paclOld, ULONG cbAclOld, PACL *ppAclNew, PSID psid);
HRESULT AddSidToTokenAcl(HANDLE hToken, PSID pSid, ACCESS_MASK amDesiredAccess);
HRESULT GetEveryoneSid(PSID *ppSidEveryone);


/*===================================================================
GrantAllAccessToToken

Given an impersonation token, grant "Everyone" permissions to that
token so that Out Of Proc ISAPIs will be able to do a GetThreadToken call.

Parameters:
    HANDLE hToken - handle to impersonation token for a user

Returns:
    HRESULT        NOERROR on success
===================================================================*/
HRESULT GrantAllAccessToToken
(
HANDLE hToken
)
    {
    HRESULT hr = NOERROR;
    DWORD err;
    PSID pSidEveryone;

    hr = GetEveryoneSid(&pSidEveryone);
    if (FAILED(hr))
        goto LExit;
        
    hr = AddSidToTokenAcl(hToken, pSidEveryone, TOKEN_ALL_ACCESS);

    FreeSid( pSidEveryone );

LExit:
    DBG_ASSERT(SUCCEEDED(hr));

    return(hr);
    }
    
/*===================================================================
AddSidToTokenAcl

When creating Local server objects (e.g. EXE's) we have some problems because of DCOM security.
The user creating the object must have appropriate permissions on the IIS process WindowStation (bug 549)
and the Desktop.

Add ACE's on the ACL for our WindowStation & Desktop for the current user.

Parameters:
    HANDLE hImpersonate - handle to impersonation token for the current user

Returns:
    HRESULT        NOERROR on success
===================================================================*/
HRESULT AddSidToTokenAcl
(
HANDLE hToken,
PSID pSid,
ACCESS_MASK amDesiredAccess
)
    {
    HRESULT hr;
    DWORD err;
    PSECURITY_DESCRIPTOR psdRelative = NULL;
    SECURITY_DESCRIPTOR sdAbsolute;
    ULONG cbSdPost;
    PACL pDacl = NULL;
    PACL pDaclNew = NULL;
    ULONG cbSD;
    ULONG cbDacl;
    ULONG cbSacl;
    ULONG cbOwner;
    ULONG cbGroup;
    ACL_SIZE_INFORMATION AclSize;

    //
    // Get the SD of the token.
    // Call this twice; once to get the size, then again to get the info
    //
    GetKernelObjectSecurity(hToken,
                            DACL_SECURITY_INFORMATION,
                            NULL,
                            0,
                            &cbSD);

    psdRelative = (PSECURITY_DESCRIPTOR) new BYTE[cbSD];
    if (psdRelative == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    if (!GetKernelObjectSecurity(hToken,
                                 DACL_SECURITY_INFORMATION,
                                 psdRelative,
                                 cbSD,
                                 &cbSD))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

    //
    // Allocate a new Dacl
    //
    pDacl = (PACL) new BYTE[cbSD];
    if (pDacl == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    //
    // Make an absolute SD from the relative SD we have, and get the Dacl at the same time
    //
    cbSdPost = sizeof(sdAbsolute);
    cbDacl = cbSD;
    cbSacl = 0;
    cbOwner = 0;
    cbGroup = 0;
    if (!MakeAbsoluteSD(psdRelative,
                        &sdAbsolute,
                        &cbSdPost,
                        pDacl,
                        &cbDacl,
                        NULL,
                        &cbSacl,
                        NULL,
                        &cbOwner,
                        NULL,
                        &cbGroup))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

    //
    // Copy ACEs over
    //
    hr = ExpandAcl(pDacl, cbSD, &pDaclNew, pSid);
    if (FAILED(hr))
        goto LExit;
    
    //
    // Add ACE to allow access
    //
    if (!AddAccessAllowedAce(pDaclNew, ACL_REVISION, amDesiredAccess, pSid))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

    //
    // Set the new DACL in the SD
    //
    if (!SetSecurityDescriptorDacl(&sdAbsolute, TRUE, pDaclNew, FALSE))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

    //
    // Set the new SD on the token object
    //
    if (!SetKernelObjectSecurity(hToken, DACL_SECURITY_INFORMATION, &sdAbsolute))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

LExit:
    delete pDacl;
    delete pDaclNew;
    delete psdRelative;

    return hr;
    }

/*===================================================================
GetEveryoneSid

Get a sid for "Everyone"

Parameters:
    PSID pSidEveryone
    
Returns:
    HRESULT        NOERROR on success
===================================================================*/
HRESULT GetEveryoneSid
(
PSID *ppSidEveryone
)
    {
    BOOL fT;
    SID_IDENTIFIER_AUTHORITY sidWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    fT = AllocateAndInitializeSid(
                 &sidWorldAuthority,    // pIdentifierAuthority
                 1,                     // nSubAuthorityCount
                 SECURITY_WORLD_RID,    // nSubAuthority0
                 0,                     // nSubAuthority1
                 0,                     // nSubAuthority2
                 0,                     // nSubAuthority3
                 0,                     // nSubAuthority4
                 0,                     // nSubAuthority5
                 0,                     // nSubAuthority6
                 0,                     // nSubAuthority7
                 ppSidEveryone          // pSid
                 );
    if( !fT )
        return HRESULT_FROM_WIN32(GetLastError());
    else
        return NOERROR;
    }

/*===================================================================
ExpandAcl

Support routine for AddWindowStationSecurity.

Expands the given ACL so that there is room for an additional ACE

Parameters:
    paclOld    - the old ACL to expand
    ppAclNew   - the newly allocated expanded acl
    psid       - the sid to use

Returns:
    HRESULT        NOERROR on success
===================================================================*/
HRESULT ExpandAcl
(
PACL paclOld,
ULONG cbAclOld,
PACL *ppAclNew,
PSID psid
)
    {
    HRESULT                 hr;
    DWORD                   err;
    PACL                    pAclNew = NULL;
    ACL_SIZE_INFORMATION    asi;
    int                     dwAclSize;
    DWORD                   iAce;
    LPVOID                  pAce;

    DBG_ASSERT(paclOld != NULL);
    DBG_ASSERT(ppAclNew != NULL);
    
    //
    // Create a new ACL to play with
    //
    if (!GetAclInformation (paclOld, (LPVOID) &asi, (DWORD) sizeof (asi), AclSizeInformation))
        goto LExit;

    dwAclSize = cbAclOld + GetLengthSid(psid) + (8 * sizeof(DWORD));

    pAclNew = (PACL) new BYTE[dwAclSize];
    if (pAclNew == NULL)
        {
        return(E_OUTOFMEMORY);
        }
        
    if (!InitializeAcl(pAclNew, dwAclSize, ACL_REVISION))
        goto LExit;

    //
    // Copy all of the ACEs to the new ACL
    //
    for (iAce = 0; iAce < asi.AceCount; iAce++)
        {
        //
        // Get the ACE and header info
        //
        if (!GetAce(paclOld, iAce, &pAce))
            goto LExit;

        //
        // Add the ACE to the new list
        //
        if (!AddAce(pAclNew, ACL_REVISION, iAce, pAce, ((ACE_HEADER *)pAce)->AceSize))
            goto LExit;
        }

    *ppAclNew = pAclNew;
    return(NOERROR);
    
LExit:
    if (pAclNew != NULL)
        delete pAclNew;
    
    DBG_ASSERT(FALSE);

    err = GetLastError();
    hr = HRESULT_FROM_WIN32(err);
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\security.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    security.c

    This module manages security for the Internet Services.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     05-Jan-1995 Enable statistics query on RPC to go free.

*/


#include "tcpdllp.hxx"
#pragma hdrstop
#include <string.h>
#if 1 // DBCS
#include <mbstring.h>
#endif
#include <limits.h>

#include "infosec.hxx"
#include <inetsvcs.h>
#include "TokenAcl.hxx"

//
//  Token Cache lock.  Controls access to the token cache list
//

#define LockTokenCache()        EnterCriticalSection( &csTokenCacheLock )
#define UnlockTokenCache()      LeaveCriticalSection( &csTokenCacheLock )


//
//  The check period for how long a token can be in the cache.  Tokens can
//  be in the cache for up to two times this value (in seconds)
//

#define DEFAULT_CACHED_TOKEN_TTL        (15 * 60)

//
// Globals
//

CRITICAL_SECTION    csTokenCacheLock;
HANDLE              g_hProcessImpersonationToken = NULL;
HANDLE              g_hProcessPrimaryToken = NULL;
BOOL                g_fUseSingleToken = FALSE;
BOOL                g_fAlwaysCheckForDuplicateLogon = FALSE;
BOOL                g_fUseAdvapi32Logon = FALSE;
BOOL                g_fCertCheckForRevocation = FALSE;
TS_TOKEN            g_pctProcessToken;
BOOL                g_fCertCheckCA = TRUE;
HINSTANCE           g_hWinTrust = NULL;
PFN_WinVerifyTrust  g_pfnWinVerifyTrust = NULL;

//
//  Well-known SIDs.
//

PSID                    psidWorld;
PSID                    psidLocalSystem;
PSID                    psidAdmins;
PSID                    psidServerOps;
PSID                    psidPowerUsers;
PSID                    g_psidGuestUser;
PSID                    g_psidProcessUser;

# define GUEST_USER_SID_BUFFER_LEN   (200)

BYTE    g_GuestUserSidBuffer[GUEST_USER_SID_BUFFER_LEN];

//
// NT Security
//

BOOL    g_fUseNTSecurity = TRUE;

//
//  The API security object.  Client access to the TCP Server APIs
//  are validated against this object.
//

PSECURITY_DESCRIPTOR    sdApiObject;

LUID g_ChangeNotifyPrivilegeTcbValue;
PTOKEN_PRIVILEGES g_pTokPrev = NULL;

//
//  This table maps generic rights (like GENERIC_READ) to
//  specific rights (like TCP_QUERY_SECURITY).
//

GENERIC_MAPPING         TCPApiObjectMapping = {
                            TCP_GENERIC_READ,          // generic read
                            TCP_GENERIC_WRITE,         // generic write
                            TCP_GENERIC_EXECUTE,       // generic execute
                            TCP_ALL_ACCESS             // generic all
                        };

//
//  List of cached tokens, the token list lock and the cookie to the token
//  scavenger schedule item.  The token cache TTL gets converted to msecs
//  during startup
//

BOOL IsTokenCacheInitialized = FALSE;
LIST_ENTRY       TokenCacheList;
DWORD            dwScheduleCookie   = 0;
DWORD            cmsecTokenCacheTTL = DEFAULT_CACHED_TOKEN_TTL;
CHAR             g_achComputerName[DNLEN+1];

LIST_ENTRY       CredentialCacheList;
CRITICAL_SECTION csCredentialCacheLock;


//
//  Private prototypes.
//

DWORD
CreateWellKnownSids(
        HINSTANCE hDll
        );

VOID
FreeWellKnownSids(
    VOID
    );

DWORD
CreateApiSecurityObject(
    VOID
    );

VOID
DeleteApiSecurityObject(
    VOID
    );

TS_TOKEN
ValidateUser(
    PCHAR   pszDomainName,
    PCHAR   pszUserName,
    PCHAR   pszPassword,
    BOOL    fAnonymous,
    BOOL *  pfAsGuest,
    DWORD   dwLogonMethod,
    TCHAR * pszWorkstation,
    LARGE_INTEGER * pExpiry,
    BOOL          * pfExpiry,
    BOOL    fUseSubAuthIfAnonymous
    );


VOID EnableTcbPrivilege(
    VOID
    );

BOOL
BuildAcctDesc(
    IN  const CHAR *     pszUser,
    IN  const CHAR *     pszDomain,
    IN  const CHAR *     pszPwd,
    IN  BOOL             fUseSubAuth,
    OUT CHAR  *          pchAcctDesc,       // must be MAX_ACCT_DESC_LEN
    OUT LPDWORD          pdwAcctDescLen
    );

BOOL
AddTokenToCache(
    IN const CHAR *      pszUser,
    IN const CHAR *      pszDomain,
    IN const CHAR *      pszPwd,
    IN BOOL              fUseSubAuth,
    IN HANDLE            hToken,
    IN DWORD             dwLogonMethod,
    OUT CACHED_TOKEN * * ppct,
    BOOL                 fCheckAlreadyExist,
    LPBOOL               pfAlreadyExist
    );


BOOL
FindCachedToken(
    IN  const CHAR *     pszUser,
    IN  const CHAR *     pszDomain,
    IN  const CHAR *     pszPwd,
    IN  BOOL             fResetTTL,
    IN  BOOL             fUseSubAuth,
    IN  DWORD            dwLogonMethod,
    OUT CACHED_TOKEN * * ppct
    );

VOID
WINAPI
TokenCacheScavenger(
    IN VOID * pContext
    );

extern BOOL g_fIgnoreSC;

//
//  Public functions.
//

/*******************************************************************

    NAME:       InitializeSecurity

    SYNOPSIS:   Initializes security authentication & impersonation
                routines.

    RETURNS:    DWORD - NO_ERROR if successful, otherwise a Win32
                    error code.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
DWORD
InitializeSecurity(
    IN HINSTANCE hDll
    )
{
    NTSTATUS ntStatus;
    HANDLE   hAsExe;
    DWORD    err;
    DWORD    nName;
    HANDLE   hAccToken;
    HKEY     hKey;
    DWORD    dwType;
    DWORD    dwValue;
    DWORD    nBytes;

    //
    // Read the registry key to see whether tsunami caching is enabled
    //

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                INETA_PARAMETERS_KEY,
                0,
                KEY_READ,
                &hKey
                );

    if ( err == ERROR_SUCCESS ) {
        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    INETA_W3ONLY_NO_AUTH,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fW3OnlyNoAuth = (BOOL)!!dwValue;
            if ( g_fW3OnlyNoAuth ) {
                DbgPrint("W3OnlyNoAuth set to TRUE in Registry.\n");
            } else {
                DbgPrint("W3OnlyNoAuth set to FALSE in Registry.\n");
            }
        }

        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    INETA_ALWAYS_CHECK_FOR_DUPLICATE_LOGON,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fAlwaysCheckForDuplicateLogon = (BOOL)dwValue;
        }

        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    INETA_USE_ADVAPI32_LOGON,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fUseAdvapi32Logon = (BOOL)dwValue;
        }


        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    INETA_CHECK_CERT_REVOCATION,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fCertCheckForRevocation = (BOOL)dwValue;
        }

        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    "CertCheckCA",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fCertCheckCA = (BOOL)dwValue;
        }

        RegCloseKey( hKey );
    }

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT, "Initializing security\n" ));
    }

    IsTokenCacheInitialized = TRUE;
    InitializeListHead( &TokenCacheList );
    INITIALIZE_CRITICAL_SECTION( &csTokenCacheLock );

    InitializeListHead( &CredentialCacheList );
    INITIALIZE_CRITICAL_SECTION( &csCredentialCacheLock );

    if ( g_fW3OnlyNoAuth  ) {
        DBGPRINTF((DBG_CONTEXT,
            "InitializeSecurity: NT Security disabled for W3OnlyNoAuth\n"));

        g_fUseSingleToken = TRUE;

        if ( !(g_pctProcessToken = new CACHED_TOKEN) )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_pctProcessToken->_cRef = INT_MAX/2;
        InitializeListHead( &g_pctProcessToken->_ListEntry );

        if ( !OpenProcessToken (
                     GetCurrentProcess(),
                     TOKEN_DUPLICATE|TOKEN_IMPERSONATE|TOKEN_QUERY,
                     &hAccToken
                     ) )
        {
            DBGPRINTF((DBG_CONTEXT, "fail OpenProcessToken\n"));
            return GetLastError();
        }

        if ( !pfnDuplicateTokenEx( hAccToken,
                                0,
                                NULL,
                                SecurityImpersonation,
                                TokenPrimary,
                                &g_hProcessPrimaryToken ))
        {
            DBGPRINTF((DBG_CONTEXT, "fail pfnDuplicateTokenEx primary\n"));
            CloseHandle( hAccToken );
            return GetLastError();
        }

        if ( !pfnDuplicateTokenEx( hAccToken,
                                0,
                                NULL,
                                SecurityImpersonation,
                                TokenImpersonation,
                                &g_hProcessImpersonationToken ))
        {
            DBGPRINTF((DBG_CONTEXT, "fail pfnDuplicateTokenEx impersonate\n"));
            CloseHandle( hAccToken );
            CloseHandle( g_hProcessPrimaryToken );
            return GetLastError();
        }

        err = CreateWellKnownSids( hDll );

        if ( err != NO_ERROR ) {
            DBGPRINTF((DBG_CONTEXT,"CreateWellKnownSids failed with %d\n",err));
            goto exit;
        }

        //
        //  Create the API security object.
        //

        err = CreateApiSecurityObject();

        if ( err != NO_ERROR  ) {
            DBGPRINTF((DBG_CONTEXT,"CreateApiSecurityObjects failed with %d\n",err));
            goto exit;
        }

        g_pctProcessToken->_hToken = g_hProcessPrimaryToken;
        g_pctProcessToken->m_hImpersonationToken = g_hProcessImpersonationToken;

        return(NO_ERROR);
    }

    if ( TsIsWindows95() ) {
        g_fIgnoreSC = TRUE;
        g_fUseNTSecurity = FALSE;
        return(NO_ERROR);
    }

    //
    //  See if we should ignore the service controller (useful for running
    //  as an .exe).  Inetsvcs.exe creates an event with this name.  So
    //  if the semaphore creation fails, then we know we're running as an .exe.
    //

    if ( !(hAsExe = CreateSemaphore( NULL, 1, 1, IIS_AS_EXE_OBJECT_NAME )))
    {
        g_fIgnoreSC = (GetLastError() == ERROR_INVALID_HANDLE);
    }
    else
    {
        DBG_REQUIRE( CloseHandle( hAsExe ) );
    }

    if ( g_fIgnoreSC )
    {
        //
        //  If the service is running as an .exe, we need to enable
        //  the SeTcbPrivilege (Act as part of the operating system).
        //  We don't worry about disabling the privilege as this is
        //  only used in test debug code
        //

        EnableTcbPrivilege();
    }

    //
    //  Create well-known SIDs.
    //

    err = CreateWellKnownSids( hDll );

    if ( err != NO_ERROR ) {
        DBGPRINTF((DBG_CONTEXT,"CreateWellKnownSids failed with %d\n",err));
        goto exit;
    }

    //
    //  Create the API security object.
    //

    err = CreateApiSecurityObject();

    if ( err != NO_ERROR  ) {
        DBGPRINTF((DBG_CONTEXT,"CreateApiSecurityObjects failed with %d\n",err));
        goto exit;
    }

    {
        HKEY hkey;

        //
        //  Get the default token TTL, must be at least one second
        //

        if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            INETA_PARAMETERS_KEY,
                            0,
                            KEY_READ,
                            &hkey )) {

             cmsecTokenCacheTTL = ReadRegistryDword( hkey,
                                                     "UserTokenTTL",
                                                     DEFAULT_CACHED_TOKEN_TTL);

            RegCloseKey( hkey );
        }

        cmsecTokenCacheTTL = max( 1, cmsecTokenCacheTTL );
        cmsecTokenCacheTTL *= 1000;

        IF_DEBUG( DLL_SECURITY )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "Scheduling token cached scavenger to %d seconds\n",
                       cmsecTokenCacheTTL/1000 ));
        }

        //
        //  Schedule a work item for the token scavenger
        //

        dwScheduleCookie = ScheduleWorkItem( TokenCacheScavenger,
                                             NULL,
                                             cmsecTokenCacheTTL,
                                             TRUE );    // Periodic
    }

    pfnLogon32Initialize( NULL, DLL_PROCESS_ATTACH, NULL );

    if ( g_pTokPrev = (PTOKEN_PRIVILEGES)LocalAlloc( LMEM_FIXED,
            sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) )
    {
        if ( !LookupPrivilegeValue(
                     NULL,
                     "SeChangeNotifyPrivilege",
                     &g_ChangeNotifyPrivilegeTcbValue
                     ) )
        {
            g_pTokPrev->PrivilegeCount = 0;
        }
        else
        {
            g_pTokPrev->PrivilegeCount = 1;

            g_pTokPrev->Privileges[0].Luid = g_ChangeNotifyPrivilegeTcbValue;
            g_pTokPrev->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        }
    }

    nName = sizeof(g_achComputerName);
    if ( !GetComputerName( g_achComputerName, &nName ) )
    {
        g_achComputerName[0] = '\0';
    }

    g_hWinTrust = LoadLibrary( "wintrust.dll" );
    if ( g_hWinTrust != NULL )
    {
        g_pfnWinVerifyTrust = (PFN_WinVerifyTrust)GetProcAddress( g_hWinTrust, "WinVerifyTrust" );
    }

    //
    //  Success!
    //

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT, "Security initialized\n" ));
    }

exit:
    return err;

}   // InitializeSecurity

/*******************************************************************

    NAME:       TerminateSecurity

    SYNOPSIS:   Terminate security authentication & impersonation
                routines.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID
TerminateSecurity(
    VOID
    )
{
    CACHED_TOKEN * pct;
    CACHED_CREDENTIAL * pcred;

    DBGPRINTF((DBG_CONTEXT,"TerminateSecurity called\n"));

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Terminating security\n" ));
    }

    //
    //  Delete any tokens still in the cache
    //

    if ( IsTokenCacheInitialized )
    {

        LockTokenCache();

        while ( !IsListEmpty( &TokenCacheList ))
        {
            pct = CONTAINING_RECORD( TokenCacheList.Flink,
                                     CACHED_TOKEN,
                                     _ListEntry );

            RemoveEntryList( &pct->_ListEntry );
            pct->_ListEntry.Flink = NULL;

            //
            //  If the ref count isn't zero then somebody didn't delete all of
            //  their tokens
            //

            DBG_ASSERT( pct->_cRef == 1 );

            CACHED_TOKEN::Dereference( pct );
        }

        UnlockTokenCache();

        DeleteCriticalSection( &csTokenCacheLock );
    }

    //
    //  Delete any credential in the cache
    //

    EnterCriticalSection( &csCredentialCacheLock );

    while ( !IsListEmpty( &CredentialCacheList ))
    {
        pcred = CONTAINING_RECORD( CredentialCacheList.Flink,
                                   CACHED_CREDENTIAL,
                                   _ListEntry );

        RemoveEntryList( &pcred->_ListEntry );
        pcred->_ListEntry.Flink = NULL;

        delete pcred;
    }

    LeaveCriticalSection( &csCredentialCacheLock );

    DeleteCriticalSection( &csCredentialCacheLock );

    if ( g_fUseSingleToken ) {
        CloseHandle( g_hProcessImpersonationToken );
        CloseHandle( g_hProcessPrimaryToken );
        delete g_pctProcessToken;
        return;
    }

    if ( !g_fUseNTSecurity ) {
        return;
    }

    FreeWellKnownSids();
    DeleteApiSecurityObject();

    //
    //  Remove the scheduled scavenger
    //

    if ( dwScheduleCookie )
    {
        RemoveWorkItem( dwScheduleCookie );
    }

    if ( g_pTokPrev )
    {
        LocalFree( g_pTokPrev );
        g_pTokPrev = NULL;
    }

    if ( g_hWinTrust != NULL )
    {
        g_pfnWinVerifyTrust = NULL;
        FreeLibrary( g_hWinTrust );
        g_hWinTrust = NULL;
    }

    pfnLogon32Initialize( NULL, DLL_PROCESS_DETACH, NULL );

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Security terminated\n" ));
    }
} // TerminateSecurity

/*******************************************************************

    NAME:       TsLogonUser

    SYNOPSIS:   Validates a user's credentials, then sets the
                impersonation for the current thread.  In effect,
                the current thread "becomes" the user.

    ENTRY:      pUserData - The user initiating the request (NULL for
                    the default account).

                pszPassword - The user's password.  May be NULL.

                pfAsGuest - Will receive TRUE if the user was validated
                    with guest privileges.

                pfAsAnonymous - Will receive TRUE if the user received the
                    services anonymous token

                pszWorkstation - workstation name for remote user
                    can be NULL if default ( local computer) to be used

                pExpiry - updated with pwd expiration date/time

                pfExpiryAvailable - updated with TRUE if pwd expiration
                                    date/time available

    RETURNS:    HANDLE - Token handle to use for impersonation or NULL
                    if the user couldn't be validated.  Call GetLastError
                    for more information.

    HISTORY:
        KeithMo     18-Mar-1993 Created.
        Johnl       14-Oct-1994 Mutilated for TCPSvcs

********************************************************************/

TS_TOKEN
TsLogonUser(
    IN  CHAR          * pszUser,
    IN  CHAR          * pszPassword,
    OUT BOOL          * pfAsGuest,
    OUT BOOL          * pfAsAnonymous,
    IN  PIIS_SERVER_INSTANCE psi,
    PTCP_AUTHENT_INFO pTAI,
    IN  CHAR          * pszWorkstation,
    OUT LARGE_INTEGER * pExpiry,
    OUT BOOL          * pfExpiryAvailable
    )
{
    CHAR        szAnonPwd[PWLEN+1];
    CHAR        szDomainAndUser[IIS_DNLEN+UNLEN+2];
    CHAR        szAnonUser[UNLEN+1];
    CHAR   *    pszUserOnly;
    CHAR   *    pszDomain;
    TS_TOKEN    hToken;
    BOOL        fUseDefaultDomain = TRUE;
    TCP_AUTHENT_INFO InstanceAuthentInfo;

    if ( g_fUseSingleToken ) {
        *pfAsGuest = TRUE;
        *pfAsAnonymous = TRUE;
        *pfExpiryAvailable = FALSE;
        CACHED_TOKEN::Reference( g_pctProcessToken );
        return g_pctProcessToken;
    }

    //
    // if no NT Security, bail
    //

    if ( !g_fUseNTSecurity ) {
        *pfAsGuest = TRUE;
        *pfAsAnonymous = TRUE;
        *pfExpiryAvailable = FALSE;
        return((TS_TOKEN)BOGUS_WIN95_TOKEN);
    }

    // If the client didn't pass in metabase info, grab what we need from
    // the instance.
    //

    if (pTAI == NULL)
    {
        InstanceAuthentInfo.strAnonUserName.Copy( "iusr_xxx" ); //(CHAR *)psi->QueryAnonUserName();
        InstanceAuthentInfo.strAnonUserPassword.Copy( "" );
        InstanceAuthentInfo.strDefaultLogonDomain.Copy( "" ); //(CHAR *)psi->QueryDefaultLogonDomain();
        InstanceAuthentInfo.dwLogonMethod = MD_LOGON_INTERACTIVE; //psi->QueryLogonMethod();
        InstanceAuthentInfo.fDontUseAnonSubAuth = FALSE;
        pTAI = &InstanceAuthentInfo;
    }
    
    //
    //  Make a quick copy of the anonymous user for this server for later
    //  usage
    //

    memcpy( szAnonUser,
            pTAI->strAnonUserName.QueryStr(),
            pTAI->strAnonUserName.QueryCCH() + sizeof(CHAR) );

    memcpy( szAnonPwd,
            pTAI->strAnonUserPassword.QueryStr(),
            pTAI->strAnonUserPassword.QueryCCH() + sizeof(CHAR) );

    //
    //  Empty user defaults to the anonymous user
    //

    if ( !pszUser || *pszUser == '\0' )
    {
        pszUser = szAnonUser;
        pszPassword = szAnonPwd;
        fUseDefaultDomain = FALSE;
        *pfAsAnonymous = TRUE;
    }
    else
    {
        *pfAsAnonymous = FALSE;
    }

    //
    //  Validate parameters & state.
    //

    if ( strlen(pszUser) >= sizeof(szDomainAndUser) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }

    DBG_ASSERT( pfAsGuest != NULL );
    DBG_ASSERT( pfAsAnonymous != NULL );

    if( pszPassword == NULL )
    {
        pszPassword = "";
    }
    else
    {
        if ( strlen(pszPassword) >= PWLEN )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return NULL;
        }
    }

    //
    //  Save a copy of the domain\user so we can squirrel around
    //  with it a bit.
    //

    int   cL = 0;
    PCSTR pL = NULL;

    //
    // prepend default logon domain if no domain
    // and the default user name was not used
    //

    if ( fUseDefaultDomain
            && strchr( pszUser, '/' ) == NULL
#if 1 // DBCS enabling for user name
            && _mbschr( (PUCHAR)pszUser, '\\' ) == NULL )
#else
            && strchr( pszUser, '\\' ) == NULL )
#endif
    {
        PCSTR pD = pTAI->strDefaultLogonDomain.QueryStr();
        if ( pD[0] != '\0' )
        {
#if 1 // DBCS enabling for user name
            if ( !( pL = (PCHAR)_mbschr( (PUCHAR)pD, '\\' ) ) )
#else
            if ( !( pL = strchr( pD, '\\' ) ) )
#endif
            {
                cL = strlen( pD );
                memcpy( szDomainAndUser, pD, cL );
                szDomainAndUser[ cL++ ] = '\\';
            }
        }
    }

    if( pL )
    {
        //
        // Handle UPN case
        //
        pszUserOnly = pszUser;
        pszDomain = "";    
    }
    else
    {
        strcpy( szDomainAndUser + cL, pszUser );

        //
        //  Crack the name into domain/user components.
        //

        if ( !CrackUserAndDomain( szDomainAndUser,
                                  &pszUserOnly,
                                  &pszDomain ))
        {
            return NULL;
        }
    }

    //
    //  Validate the domain/user/password combo and create
    //  an impersonation token.
    //

    hToken = ValidateUser( pszDomain,
                           pszUserOnly,
                           pszPassword,
                           *pfAsAnonymous,
                           pfAsGuest,
                           pTAI->dwLogonMethod,
                           pszWorkstation,
                           pExpiry,
                           pfExpiryAvailable,
                           !pTAI->fDontUseAnonSubAuth
                          );

    ZeroMemory( szAnonPwd, strlen(szAnonPwd) );

    if( hToken == NULL )
    {
        STR          strError;
        const CHAR * psz[2];
        DWORD        dwErr = GetLastError();

        psi->LoadStr( strError, dwErr, FALSE );

        psz[0] = pszUser;
        psz[1] = strError.QueryStr();

        psi->m_Service->LogEvent(
                        INET_SVCS_FAILED_LOGON,
                        2,
                        psz,
                        dwErr );

        //
        //  Validation failure.
        //

        if ( dwErr == ERROR_LOGON_TYPE_NOT_GRANTED ||
             dwErr == ERROR_ACCOUNT_DISABLED )
        {
            SetLastError( ERROR_ACCESS_DENIED );
        }
        else
        {
            //
            // Reset LastError(), as LogEvent() may have overwritten it
            // e.g log is full
            //

            SetLastError( dwErr );
        }

        return NULL;
    }

    //
    //  Success!
    //

    return hToken;

}   // LogonUser

/*******************************************************************

    NAME:       ValidateUser

    SYNOPSIS:   Validate a given domain/user/password tuple.

    ENTRY:      pszDomainName - The user's domain (NULL = current).

                pszUserName - The user's name.

                pszPassword - The user's (plaintext) password.

                fAnonymous - TRUE if this is the anonymous user

                pfAsGuest - Will receive TRUE if the user was validated
                    with guest privileges.

                dwLogonMethod - interactive or batch

                pszWorkstation - workstation name for remote user
                    can be NULL if default ( local computer) to be used

                pExpiry - updated with pwd expiration date/time

                pfExpiryAvailable - updated with TRUE if pwd expiration
                                    date/time available

                fUseSubAuthIfAnonymous - TRUE if logon anonymous user
                                         using IIS sub-auth

    RETURNS:    HANDLE - An impersonation token, NULL if user cannot
                    be validated.  Call GetLastError for more information.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
TS_TOKEN ValidateUser(
    PCHAR  pszDomainName,
    PCHAR  pszUserName,
    PCHAR  pszPassword,
    BOOL   fAnonymous,
    BOOL * pfAsGuest,
    DWORD  dwLogonMethod,
    CHAR * pszWorkstation,
    LARGE_INTEGER * pExpiry,
    BOOL * pfExpiryAvailable,
    BOOL   fUseSubAuthIfAnonymous
    )
{
    CACHED_TOKEN * pct = NULL;
    HANDLE         hToken;
    HANDLE         hImpersonationToken = NULL;
    BOOL           fExpiry = FALSE;
    DWORD          dwSubAuth = 0;
    CHAR           achCookie[32];
    BOOL           fExist;

    if ( pfExpiryAvailable )
    {
        *pfExpiryAvailable = FALSE;
    }

    if ( fAnonymous && fUseSubAuthIfAnonymous )
    {
        if ( !pfnNetUserCookieA( pszUserName,
                              IIS_SUBAUTH_SEED,
                              achCookie,
                              sizeof(achCookie ) ) )
        {
            return FALSE;
        }

        dwSubAuth = IIS_SUBAUTH_ID;
        pszPassword = achCookie;
        dwLogonMethod = LOGON32_LOGON_IIS_NETWORK;
    }

    //
    //  Is it in the cache?  References the token if we find it
    //

    if ( FindCachedToken( pszUserName,
                          pszDomainName,
                          pszPassword,
                          fAnonymous,    // Reset the TTL if anonymous
                          fAnonymous && fUseSubAuthIfAnonymous,
                          dwLogonMethod,
                          &pct ))
    {
        *pfAsGuest = pct->IsGuest();

        if ( NULL != pExpiry) {
            memcpy( pExpiry, pct->QueryExpiry(), sizeof(LARGE_INTEGER) );
        }

        if ( pfExpiryAvailable )
        {
            *pfExpiryAvailable = TRUE;
        }

        return pct;
    }
    
    if ( (dwLogonMethod == LOGON32_LOGON_NETWORK ||
          dwLogonMethod == LOGON32_LOGON_BATCH ||
          dwLogonMethod == LOGON32_LOGON_INTERACTIVE ||
          dwLogonMethod == LOGON32_LOGON_IIS_NETWORK || 
          dwLogonMethod == LOGON32_LOGON_NETWORK_CLEARTEXT ) &&
          !g_fUseAdvapi32Logon )
    {
        if ( !pfnLogonNetUserA( pszUserName,
                             pszDomainName,
                             pszPassword,
                             pszWorkstation,
                             dwSubAuth,
                             dwLogonMethod,
                             LOGON32_PROVIDER_DEFAULT,
                             &hToken,
                             pExpiry ))
        {
            if ( fAnonymous && 
                 ( GetLastError() == ERROR_LOGON_TYPE_NOT_GRANTED ) && 
                 ( dwLogonMethod == LOGON32_LOGON_INTERACTIVE ) )
            {
                // try again
                
                dwLogonMethod = LOGON32_LOGON_BATCH;
                 
                if ( !pfnLogonNetUserA( pszUserName,
                                        pszDomainName,
                                        pszPassword,
                                        pszWorkstation,
                                        dwSubAuth,
                                        dwLogonMethod,
                                        LOGON32_PROVIDER_DEFAULT,
                                        &hToken,
                                        pExpiry ))
                {
                    return NULL;
                }
            }
            else
            {
                return NULL;
            }
        }

        fExpiry = TRUE;

        if ( pfExpiryAvailable )
        {
            *pfExpiryAvailable = TRUE;
        }
    }
    else
    {
        if ( !LogonUserA( pszUserName,
                          pszDomainName,
                          pszPassword,
                          dwLogonMethod,
                          LOGON32_PROVIDER_WINNT50,
                          &hToken ))
        {
            return NULL;
        }
    }

    if ( dwLogonMethod == LOGON32_LOGON_NETWORK ||
         dwLogonMethod == LOGON32_LOGON_IIS_NETWORK || 
         dwLogonMethod == LOGON32_LOGON_NETWORK_CLEARTEXT )
    {
        hImpersonationToken = hToken;

        if ( !pfnDuplicateTokenEx( hImpersonationToken,
                                TOKEN_ALL_ACCESS,
                                NULL,
                                SecurityDelegation,
                                TokenPrimary,
                                &hToken ))
        {
            if ( !pfnDuplicateTokenEx( hImpersonationToken,
                                    TOKEN_ALL_ACCESS,
                                    NULL,
                                    SecurityImpersonation,
                                    TokenPrimary,
                                    &hToken ))
            {
                CloseHandle( hImpersonationToken );
                return NULL;
            }
        }
    }

    *pfAsGuest = IsGuestUser(hToken);

    //
    //  Add this new token to the cache, hToken gets replaced by the
    //  cached token object
    //

    if ( !AddTokenToCache( pszUserName,
                           pszDomainName,
                           pszPassword,
                           fAnonymous && fUseSubAuthIfAnonymous,
                           hToken,
                           dwLogonMethod,
                           &pct,
                           g_fAlwaysCheckForDuplicateLogon | fAnonymous,
                           &fExist ))
    {
        if ( hImpersonationToken != NULL )
        {
            CloseHandle( hImpersonationToken );
        }
        CloseHandle( hToken );
        return NULL;
    }

    pct->SetGuest(*pfAsGuest);
    if ( fExpiry )
    {
        pct->SetExpiry( pExpiry );
    }

    //
    // DuplicateToken() apparently returns an impersonated token
    // so it is not necessary to call pfnDuplicateTokenEx
    //

    if ( !fExist )
    {
        if ( hImpersonationToken == NULL
             && !pfnDuplicateTokenEx( hToken,      // hSourceToken
                                   TOKEN_ALL_ACCESS,
                                   NULL,
                                   SecurityDelegation,  // Obtain impersonation
                                   TokenImpersonation,
                                   &hImpersonationToken)  // hDestinationToken
            ) {
            if ( !pfnDuplicateTokenEx( hToken,      // hSourceToken
                                       TOKEN_ALL_ACCESS,
                                       NULL,
                                       SecurityImpersonation,  // Obtain impersonation
                                       TokenImpersonation,
                                       &hImpersonationToken)  // hDestinationToken
                ) {
                hImpersonationToken = NULL;
            }
        }

        // Bug 86489:
        // Grant all access to the token for "Everyone" so that ISAPIs that run out of proc
        // can do an OpenThreadToken call
        if (FAILED( GrantAllAccessToToken( hImpersonationToken ) ) )
        {
            CloseHandle( hImpersonationToken );
            DBG_ASSERT( FALSE );
            return NULL;
        }

        pct->SetImpersonationToken( hImpersonationToken);
    }
    else if ( hImpersonationToken )
    {
        CloseHandle( hImpersonationToken );
    }

    return pct;

}   // ValidateUser





# define MAX_TOKEN_USER_INFO   (300)
BOOL
IsGuestUser(IN HANDLE hToken)
/*++
  Given a user token, this function determines if the token belongs
   to a guest user. It returns true if the token is a guest user token.

  Arguments:
    hToken  - handle for the Security token for a user.


  Returns:
    BOOL.

  History:
    MuraliK   22-Jan-1996   Created.
--*/
{
    BOOL fGuest = FALSE;
    BYTE rgbInfo[MAX_TOKEN_USER_INFO];
    DWORD cbTotalRequired;

    //
    // Get the user information associated with the token.
    // Using this we can then query to find out if it belongs to a guest user.
    //

    if (GetTokenInformation( hToken,
                            TokenUser,
                            (LPVOID ) rgbInfo,
                            MAX_TOKEN_USER_INFO,
                            &cbTotalRequired)
        ) {

        TOKEN_USER * pTokenUser = (TOKEN_USER *) rgbInfo;
        PSID pSid = pTokenUser->User.Sid;

        fGuest = EqualSid( pSid, g_psidGuestUser);

    } else {

        IF_DEBUG( DLL_SECURITY) {

            DBGPRINTF(( DBG_CONTEXT,
                       "GetTokenInformation(%08x) failed. Error = %d."
                       " sizeof(TOKEN_USER) = %d, cb = %d\n",
                       hToken,
                       GetLastError(),
                       sizeof(TOKEN_USER), cbTotalRequired
                       ));
        }
    }

    return ( fGuest);

} // IsGuestUser()


/*******************************************************************

    NAME:       TsImpersonateUser

    SYNOPSIS:   Causes the current thread to impersonate the user
                represented by the given impersonation token.

    ENTRY:      hToken - A handle to an impersonation token created
                    with ValidateUser.  This is actually a pointer to
                    a cached token object.

    RETURNS:    BOOL - TRUE if successful, FALSE otherwise.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     21-Feb-1996 Optimized Token caching

********************************************************************/
BOOL TsImpersonateUser( TS_TOKEN hToken )
{
    HANDLE  hTok;

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "impersonating user token %08lX : Imperonation(%08lx)\n",
                   CTO_TO_TOKEN(hToken),
                   ((CACHED_TOKEN *) hToken)->QueryImpersonationToken()
                   ));
    }

    hTok = ((CACHED_TOKEN *) hToken)->QueryImpersonationToken();
    if ( hTok == NULL) {
        // if there is no impersonation token use the normal token itself.
        hTok = CTO_TO_TOKEN(hToken);
    }

#if DBG
    if( !ImpersonateLoggedOnUser( hTok ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "cannot impersonate user token %08lX, error %08lX\n",
                    CTO_TO_TOKEN(hToken),
                    GetLastError() ));
        return FALSE;
    }

    return TRUE;

# else

    return ( ImpersonateLoggedOnUser(hTok));

# endif // DBG

}   // TsImpersonateUser

/*******************************************************************

    NAME:       TsDeleteUserToken

    SYNOPSIS:   Deletes a token created with ValidateUser.

    ENTRY:      hToken - An impersonation token created with
                    ValidateUser.

    RETURNS:    BOOL - TRUE if successful, FALSE otherwise.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
BOOL TsDeleteUserToken(
    TS_TOKEN    hToken
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if ( hToken != (TS_TOKEN)BOGUS_WIN95_TOKEN ) {

        CACHED_TOKEN::Dereference( (CACHED_TOKEN *) hToken );
    }
    return TRUE;
}   // DeleteUserToken

HANDLE
TsTokenToHandle(
    TS_TOKEN    hToken
    )
/*++
  Description:

    Converts the token object into a real impersonation handle

  Arguments:

    hToken - pointer to cached token object

  Returns:
      Handle of real impersonation token
--*/
{
    DBG_ASSERT( hToken != NULL );

    return CTO_TO_TOKEN( hToken );
}


HANDLE
TsTokenToImpHandle(
    TS_TOKEN    hToken
    )
/*++
  Description:

    Converts the token object into an impersonation handle

  Arguments:

    hToken - pointer to cached token object

  Returns:
      Handle of impersonation token
--*/
{
    DBG_ASSERT( hToken != NULL );

    return CTO_TO_IMPTOKEN( hToken );
}


BOOL
BuildAnonymousAcctDesc(
    PTCP_AUTHENT_INFO pTAI
    )
/*++

Routine Description:

    Builds the anonymous account description based on the authentication
    info structure.

Arguments:

    pTAI - Pointer to authentication info to build

Returns:

    TRUE if Success, FALSE otherwise

--*/
{
    CHAR    szDomainAndUser[IIS_DNLEN+UNLEN+2];
    PCHAR   pszUserOnly;
    PCHAR   pszDomain;
    CHAR    achAcctDesc[MAX_ACCT_DESC_LEN];
    DWORD   cbDescLen;


    if ( g_fUseSingleToken ) {
        pTAI->cbAnonAcctDesc = 0;
        return TRUE;
    }

    strncpy( szDomainAndUser,
             pTAI->strAnonUserName.QueryStr(),
             sizeof( szDomainAndUser ) );

    szDomainAndUser[sizeof(szDomainAndUser)-1] = '\0';

    if ( !CrackUserAndDomain( szDomainAndUser,
                              &pszUserOnly,
                              &pszDomain ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "BuildAnonymousAcctDesc: Call to CrackUserAndDomain failed\n"));

        return(FALSE);
    }

    if ( !BuildAcctDesc( pszUserOnly,
                         pszDomain,
                         pTAI->strAnonUserPassword.QueryStr(),
                         !pTAI->fDontUseAnonSubAuth,
                         achAcctDesc,
                         &pTAI->cbAnonAcctDesc ) ||
         !pTAI->bAnonAcctDesc.Resize( pTAI->cbAnonAcctDesc ))
    {
        return FALSE;
    }

    memcpy( pTAI->bAnonAcctDesc.QueryPtr(),
            achAcctDesc,
            pTAI->cbAnonAcctDesc );

    return TRUE;
}

BOOL
BuildAcctDesc(
    IN  const CHAR *     pszUser,
    IN  const CHAR *     pszDomain,
    IN  const CHAR *     pszPwd,
    IN  BOOL             fUseSubAuth,
    OUT CHAR  *          pchAcctDesc,
    OUT LPDWORD          pdwAcctDescLen
    )
/*++
  Description:

    Builds a cache descriptor for account cache

  Arguments:

    pszUser - User name attempting to logon
    pszDomain - Domain the user belongs to
    pszPwd - password (case sensitive)
    fUseSubAuth - TRUE if sub-authenticator used
    pchAcctDesc - updated with descriptor
    pdwAcctDescLen - updated with descriptor length

  Returns:
      TRUE on success, otherwise FALSE

--*/
{
    if ( fUseSubAuth )
    {
        pszPwd = "";
    }

    size_t lU = strlen( pszUser ) + 1;
    size_t lD = strlen( pszDomain ) + 1;
    size_t lP = strlen( pszPwd ) + 1;

    if ( lU > (UNLEN+1) ||
         lD > (IIS_DNLEN+1) ||
         lP > (PWLEN+1) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    *pdwAcctDescLen = (DWORD)(1 + lU + lD + lP);

    LPBYTE pD = (BYTE *) pchAcctDesc;

    *pD++ = (BYTE)fUseSubAuth;

    memcpy( pD, pszUser, lU );
#if 1 // DBCS enabling for user name
    CharLower( (LPSTR)pD );
#else
    _strlwr( (LPSTR)pD );
#endif

    memcpy( pD + lU, pszDomain, lD );
    _strlwr( (LPSTR)(pD+lU) );

    memcpy( pD + lU + lD, pszPwd, lP );

    DBG_ASSERT( (lU + lD + lP) < MAX_ACCT_DESC_LEN );
    return TRUE;
}


BOOL
FindCachedToken(
    IN  const CHAR *     pszUser,
    IN  const CHAR *     pszDomain,
    IN  const CHAR *     pszPwd,
    IN  BOOL             fResetTTL,
    IN  BOOL             fUseSubAuth,
    IN  DWORD            dwLogonMethod,
    OUT CACHED_TOKEN * * ppct
    )
/*++
  Description:

    Checks to see if the specified user token handle is cached

  Arguments:

    pszUser - User name attempting to logon
    pszDomain - Domain the user belongs to
    pszPwd - password (case sensitive)
    fResetTTL - Resets the TTL for this token
    fUseSubAuth - TRUE if sub-authenticator used
    dwLogonMethod - Logon method (Batch, Interactive, Network)
    ppct - Receives token object

  Returns:
      TRUE on success and FALSE if the entry couldn't be found

--*/
{
    LIST_ENTRY *   pEntry;
    CACHED_TOKEN * pct;
    CHAR           achAcctDesc[MAX_ACCT_DESC_LEN];
    DWORD          dwAcctDescLen;
    LPBYTE         pAcctDesc;

    DBG_ASSERT( pszUser != NULL );

    if ( !BuildAcctDesc( pszUser, pszDomain, pszPwd, fUseSubAuth, achAcctDesc, &dwAcctDescLen) )
    {
        return FALSE;
    }

    DBG_ASSERT( dwAcctDescLen < sizeof(achAcctDesc ));

    pAcctDesc = (LPBYTE)achAcctDesc;

    LockTokenCache();

    for ( pEntry  = TokenCacheList.Flink;
          pEntry != &TokenCacheList;
          pEntry  = pEntry->Flink )
    {
        pct = CONTAINING_RECORD( pEntry, CACHED_TOKEN, _ListEntry );

        if ( pct->m_dwAcctDescLen == dwAcctDescLen &&
             pct->m_dwLogonMethod == dwLogonMethod &&
             !memcmp( pct->_achAcctDesc, pAcctDesc, dwAcctDescLen ) )
        {
            CACHED_TOKEN::Reference( pct );
            *ppct = pct;

            //
            //  Reset the TTL if this is the anonymous user so items in the
            //  cache don't get invalidated (token handle used as a
            //  discriminator)

            if ( fResetTTL )
            {
                pct->_TTL = 2;
            }

            UnlockTokenCache();

            return TRUE;
        }
        
        if( !_stricmp( pct->m_achUserName, pszUser )     && 
            !_stricmp( pct->m_achDomainName, pszDomain ) &&
            pct->m_dwLogonMethod == dwLogonMethod )
        {
            UnlockTokenCache();

            RemoveTokenFromCache( pct );

            return FALSE;
        }
    }

    UnlockTokenCache();

    return FALSE;

} // FindCachedToken



TS_TOKEN
FastFindAnonymousToken(
    IN PTCP_AUTHENT_INFO    pTAI
    )
/*++

  Description:

    Checks to see if the specified anonymous user token handle is cached.

    Don't call this function when using the sub-authenticator!

  Arguments:

    pTAI - pointer to the anonymous authentication info

  Returns:
      Pointer to the cached object.

--*/
{
    LIST_ENTRY *   pEntry;
    CACHED_TOKEN * pct;

    LockTokenCache();

    for ( pEntry  = TokenCacheList.Flink;
          pEntry != &TokenCacheList;
          pEntry  = pEntry->Flink ) {

        pct = CONTAINING_RECORD( pEntry, CACHED_TOKEN, _ListEntry );

        DBG_ASSERT(pct->m_dwAcctDescLen > 0);

        if ( (pct->m_dwAcctDescLen == pTAI->cbAnonAcctDesc ) &&
             RtlEqualMemory(
                    pct->_achAcctDesc,
                    pTAI->bAnonAcctDesc.QueryPtr(),
                    pct->m_dwAcctDescLen ) ) {

            CACHED_TOKEN::Reference( pct );

            //
            //  Reset the TTL if this is the anonymous user so items in the
            //  cache don't get invalidated (token handle used as a
            //  discriminator)

            pct->_TTL = 2;

            UnlockTokenCache();
            return pct;
        }
    }

    UnlockTokenCache();
    return NULL;
} // FastFindAnonymousToken



BOOL
AddTokenToCache(
    IN const CHAR *      pszUser,
    IN const CHAR *      pszDomain,
    IN const CHAR *      pszPwd,
    IN BOOL              fUseSubAuth,
    IN HANDLE            hToken,
    IN DWORD             dwLogonMethod,
    OUT CACHED_TOKEN * * ppct,
    BOOL                 fCheckAlreadyExist,
    LPBOOL               pfExist
    )
/*++
  Description:

    Adds the specified token to the cache and converts the token handle
    to a cached token object

  Arguments:

    pszUser - User name attempting to logon
    pszDomain - Domain the user belongs to
    pszPwd - Cast sensitive password
    fUseSubAuth - TRUE if subauth to be used
    phToken - Contains the token handle that was just logged on
    dwLogonMethod - Logon Method
    ppct - Receives cached token object
    fCheckAlreadyExist - check if entry with same name already exist
    pfExist - updated with TRUE if acct already exists

  Returns:
      TRUE on success and FALSE if the entry couldn't be found

--*/
{
    LIST_ENTRY *    pEntry;
    CACHED_TOKEN *  pctF;
    CACHED_TOKEN *  pct;
    DWORD           dwAcctDescLen;
    BOOL            fFound = FALSE;
    CHAR            achAcctDesc[MAX_ACCT_DESC_LEN];

    DBG_ASSERT( pszUser != NULL );

    if( ( strlen( pszUser ) >= UNLEN ) || 
        ( strlen( pszDomain ) >= IIS_DNLEN ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( !BuildAcctDesc( pszUser, pszDomain, pszPwd, fUseSubAuth, achAcctDesc, &dwAcctDescLen) )
    {
        return FALSE;
    }

    pct = new CACHED_TOKEN;

    if ( !pct )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    pct->_hToken = hToken;
    pct->m_hImpersonationToken = NULL;         // initialize to invalid value
    CopyMemory( pct->_achAcctDesc, achAcctDesc, dwAcctDescLen );
    pct->m_dwAcctDescLen = dwAcctDescLen;
    pct->m_dwLogonMethod = dwLogonMethod;
   
    strcpy( pct->m_achUserName, pszUser );
    strcpy( pct->m_achDomainName, pszDomain );

    //
    //  Add the token to the list, we check for duplicates at callers's request
    //

    LockTokenCache();

    if ( fCheckAlreadyExist )
    {
        for ( pEntry  = TokenCacheList.Flink;
              pEntry != &TokenCacheList;
              pEntry  = pEntry->Flink )
        {
            pctF = CONTAINING_RECORD( pEntry, CACHED_TOKEN, _ListEntry );

            if ( pctF->m_dwAcctDescLen == dwAcctDescLen &&
                 !memcmp( pctF->_achAcctDesc, pct->_achAcctDesc, dwAcctDescLen ) && 
                 pctF->m_dwLogonMethod == dwLogonMethod )
            {
                fFound = TRUE;
                break;
            }
        }
    }

    *pfExist = fFound;

    if ( !fFound )
    {
        InsertHeadList( &TokenCacheList, &pct->_ListEntry );
    }
    else
    {
        // delete cache item ( was not yet on list )

        CACHED_TOKEN::Dereference( pct );

        pct = pctF;
    }

    CACHED_TOKEN::Reference( pct );

    UnlockTokenCache();

    *ppct = pct;

    return TRUE;
} // AddTokenToCache




VOID
RemoveTokenFromCache( IN CACHED_TOKEN *  pct)
{
    DBG_ASSERT( pct != NULL);
    LockTokenCache();

    //
    //  Remove from the list
    //

    if ( pct->_ListEntry.Flink )
    {
        RemoveEntryList( &pct->_ListEntry );
        pct->_ListEntry.Flink = NULL;

        //
        //  Free any handles this user may still have open
        //

        TsCacheFlushUser( pct->_hToken, FALSE );

        CACHED_TOKEN::Dereference( pct );
    }

    UnlockTokenCache();

    return;
} // RemoveTokenFromCache()



VOID
WINAPI
TokenCacheScavenger(
    IN VOID * /* pContext */
    )
/*++
  Description:

    Decrements TTLs and removes tokens that have timed out

  Arguments:

    pContext - Not used

--*/
{
    LIST_ENTRY *   pEntry;
    LIST_ENTRY *   pEntryNext;
    CACHED_TOKEN * pct;


    LockTokenCache();

    for ( pEntry  = TokenCacheList.Flink;
          pEntry != &TokenCacheList; )
    {
        pEntryNext = pEntry->Flink;

        pct = CONTAINING_RECORD( pEntry, CACHED_TOKEN, _ListEntry );

        if ( !(--pct->_TTL) )
        {
            IF_DEBUG( DLL_SECURITY )
            {
                DBGPRINTF(( DBG_CONTEXT,
                           "[TokenCacheScavenger] Timing out token for %s\n",
                           pct->_achAcctDesc ));
            }

            //
            //  This item has timed out, remove from the list
            //

            RemoveEntryList( &pct->_ListEntry );
            pct->_ListEntry.Flink = NULL;

            //
            //  Free any handles this user may still have open
            //

            TsCacheFlushUser( pct->_hToken, FALSE );

            CACHED_TOKEN::Dereference( pct );
        }

        pEntry = pEntryNext;
    }

    UnlockTokenCache();

} // TokenCacheScavenger


BOOL
TsGetSecretW(
    WCHAR *       pszSecretName,
    BUFFER *      pbufSecret
    )
/*++
    Description:

        Retrieves the specified unicode secret

    Arguments:

        pszSecretName - LSA Secret to retrieve
        pbufSecret - Receives found secret

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL              fResult;
    NTSTATUS          ntStatus;
    PUNICODE_STRING   punicodePassword = NULL;
    UNICODE_STRING    unicodeSecret;
    LSA_HANDLE        hPolicy;
    OBJECT_ATTRIBUTES ObjectAttributes;

    if ( pfnLsaOpenPolicy == NULL ) {
        DBGPRINTF((DBG_CONTEXT,"LsaOpenPolicy does not exist on win95\n"));
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return(FALSE);
    }

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = pfnLsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if (  !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( pfnLsaNtStatusToWinError( ntStatus ) );
        return FALSE;
    }

    InitUnicodeString( &unicodeSecret, pszSecretName );

    //
    //  Query the secret value.
    //

    ntStatus = pfnLsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    if( NT_SUCCESS(ntStatus) )
    {
        DWORD cbNeeded;

        cbNeeded = punicodePassword->Length + sizeof(WCHAR);

        if ( !pbufSecret->Resize( cbNeeded ) )
        {
            ntStatus = STATUS_NO_MEMORY;
            goto Failure;
        }

        CopyMemory(
            pbufSecret->QueryPtr(),
            punicodePassword->Buffer,
            punicodePassword->Length
            );

        *((WCHAR *) pbufSecret->QueryPtr() +
           punicodePassword->Length / sizeof(WCHAR)) = L'\0';

        ZeroMemory( punicodePassword->Buffer,
                    punicodePassword->MaximumLength );

    }

Failure:

    fResult = NT_SUCCESS(ntStatus);

    //
    //  Cleanup & exit.
    //

    if( punicodePassword != NULL )
    {
        pfnLsaFreeMemory( (PVOID)punicodePassword );
    }

    pfnLsaClose( hPolicy );

    if ( !fResult )
    {
        SetLastError( pfnLsaNtStatusToWinError( ntStatus ));
    }

    return fResult;
}   // TsGetSecretW


DWORD
TsSetSecretW(
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    )
/*++

   Description

     Sets the specified LSA secret

   Arguments:

     SecretName - Name of the LSA secret
     pSecret - Pointer to secret memory
     cbSecret - Size of pSecret memory block

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING    unicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    unicodeSecret;


    InitUnicodeString( &unicodeServer,
                       L"" );

    //
    //  Initialize the unicode string by hand so we can handle '\0' in the
    //  string
    //

    unicodePassword.Buffer        = pSecret;
    unicodePassword.Length        = (USHORT) cbSecret;
    unicodePassword.MaximumLength = (USHORT) cbSecret;

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = pfnLsaOpenPolicy( &unicodeServer,
                                 &ObjectAttributes,
                                 POLICY_ALL_ACCESS,
                                 &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        return pfnLsaNtStatusToWinError( ntStatus );

    //
    //  Create or open the LSA secret
    //

    InitUnicodeString( &unicodeSecret,
                       SecretName );

    ntStatus = pfnLsaStorePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &unicodePassword );

    pfnLsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
    {
        return pfnLsaNtStatusToWinError( ntStatus );
    }

    return NO_ERROR;
} // TsSetSecretW()

/*******************************************************************

    NAME:       ApiAccessCheck

    SYNOPSIS:   Impersonate the RPC client, then check for valid
                access against our server security object.

    ENTRY:      maskDesiredAccess - Specifies the desired access mask.
                    This mask must not contain generic accesses.

    RETURNS:    DWORD - NO_ERROR if access granted, ERROR_ACCESS_DENIED
                    if access denied, other Win32 errors if something
                    tragic happened.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/
DWORD TsApiAccessCheck( ACCESS_MASK maskDesiredAccess )
{
    DWORD          err;
    BOOL           fRet;

    if ( maskDesiredAccess == TCP_QUERY_STATISTICS) {

        //
        // Statistics query should be allowed without authentication.
        // Any body can bring up perfmon and request statistics.
        //

        return ( NO_ERROR);
    }

    //
    //  Impersonate the RPC client.
    //

    err = (DWORD)RpcImpersonateClient( NULL );

    if( err != NO_ERROR )
    {
        IF_DEBUG( DLL_SECURITY )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot impersonate rpc client, error %lu\n",
                        err ));
        }

    } else {

        BOOL           fAccessStatus;
        BOOL           fGenerateOnClose;
        ACCESS_MASK    maskAccessGranted;

        //
        //  Validate access.
        //

        if ( g_fUseSingleToken )
        {
            HANDLE  hAccToken;
            BYTE    Set[256];
            DWORD   dwSet = sizeof(Set);

            if ( OpenThreadToken( GetCurrentThread(), TOKEN_READ, TRUE, &hAccToken ) )
            {
                fRet = AccessCheck( sdApiObject,
                                    hAccToken,
                                    maskDesiredAccess,
                                    &TCPApiObjectMapping,
                                    (PPRIVILEGE_SET)&Set,
                                    &dwSet,
                                    &maskAccessGranted,
                                    &fAccessStatus );

                CloseHandle( hAccToken );
            }
            else
            {
                fRet = FALSE;
            }
        }
        else
        {
            fRet = AccessCheckAndAuditAlarmW( SUBSYSTEM_NAME,
                                             NULL,
                                             OBJECTTYPE_NAME,
                                             OBJECT_NAME,
                                             sdApiObject,
                                             maskDesiredAccess,
                                             &TCPApiObjectMapping,
                                             FALSE,
                                             &maskAccessGranted,
                                             &fAccessStatus,
                                             &fGenerateOnClose );
        }

        if ( !fRet ) {

            err = GetLastError();
        }

        //
        //  Revert to our former self.
        //

        DBG_REQUIRE( !RpcRevertToSelf() );

        //
        //  Check the results.
        //

        if( err != NO_ERROR ) {

            IF_DEBUG( DLL_SECURITY ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "cannot check access, error %lu\n",
                           err ));
            }
        } else if( !fAccessStatus ) {

            err = ERROR_ACCESS_DENIED;

            IF_DEBUG( DLL_SECURITY ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "bad access status, error %lu\n",
                           err ));
            }
        }
    }

    return (err);

}   // ApiAccessCheck

/*******************************************************************

    NAME:       CreateWellKnownSids

    SYNOPSIS:   Create some well-known SIDs used to create a security
                descriptor for the API security object.

    RETURNS:    NTSTATUS - An NT Status code.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/

DWORD CreateWellKnownSids( HINSTANCE hDll )
{
    DWORD                    error    = NO_ERROR;
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaNt    = SECURITY_NT_AUTHORITY;
    BOOL                     fRet;

    fRet = AllocateAndInitializeSid( &siaWorld,
                                     1,
                                     SECURITY_WORLD_RID,
                                     0,0,0,0,0,0,0,
                                     &psidWorld );

    if( fRet )
    {
        fRet = AllocateAndInitializeSid( &siaNt,
                                         1,
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         0,0,0,0,0,0,0,
                                         &psidLocalSystem );
    }

    if( fRet )
    {
        fRet = AllocateAndInitializeSid( &siaNt,
                                         2,
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_ADMINS,
                                         0,0,0,0,0,0,
                                         &psidAdmins );
    }

    if( fRet )
    {
        fRet = AllocateAndInitializeSid( &siaNt,
                                         2,
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_SYSTEM_OPS,
                                         0,0,0,0,0,0,
                                         &psidServerOps );
    }

    if( fRet )
    {
        fRet = AllocateAndInitializeSid( &siaNt,
                                         2,
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_POWER_USERS,
                                         0,0,0,0,0,0,
                                         &psidPowerUsers );
    }

    if( fRet )
    {
        USER_MODALS_INFO_2 * pUsrModals2 =  NULL;
        HINSTANCE   hInstance = NULL;
        NET_USER_MODALS_GET_FN pfnNetUserModalsGet = NULL;
        NET_API_BUFFER_FREE_FN pfnNetApiBufferFree = NULL;

        //
        // Construct well-known-sid for Guest User on the local computer
        //
        //  1) Obtain the sid for the local machine's domain
        //  2) copy domain sid to guest user sid
        //  3) append DOMAIN_USER_RID_GUEST to the domain sid in GuestUser sid.
        //

        g_psidGuestUser = (PSID ) g_GuestUserSidBuffer;

        hInstance = LoadLibrary("netapi32.dll");
        if ( hInstance != NULL ) {

            pfnNetUserModalsGet = (NET_USER_MODALS_GET_FN)
                GetProcAddress(hInstance,"NetUserModalsGet");
            pfnNetApiBufferFree = (NET_API_BUFFER_FREE_FN)
                GetProcAddress(hInstance,"NetApiBufferFree");
        }

        if ( (pfnNetUserModalsGet != NULL) &&
             (pfnNetApiBufferFree != NULL) ) {

            fRet = ( (pfnNetUserModalsGet(NULL,  // local computer
                                   2,      // get level 2 information
                                   (LPBYTE *) &pUsrModals2
                                   ) == 0)
                &&
                CopySid(GUEST_USER_SID_BUFFER_LEN - 4,// Buffer len
                        g_psidGuestUser,             // psidDestination
                        pUsrModals2->usrmod2_domain_id // obtain domain sid.
                        )
                );
        } else {

            DBGPRINTF((DBG_CONTEXT,"Unable to get netapi32 entrypoints\n"));
            fRet = FALSE;
        }

        //
        // if successful append the DOMAIN_USER_RID_GUEST.
        //

        if ( fRet) {

            DWORD lenSid = GetLengthSid( g_psidGuestUser);
            CHAR  nSubAuth;

            //
            //  There is no Win32 way to set a SID value.
            //  We will munge around on our own.
            //  Pretty dangerous thing to do :-(
            //

            // increment the number of sub authorities
            nSubAuth = *((UCHAR *) ((UCHAR *) g_psidGuestUser + 1));
            nSubAuth++;
            *((UCHAR *) ((UCHAR *) g_psidGuestUser + 1)) = nSubAuth;

            // Store the new sub authority (Domain User Rid for Guest).
            *((ULONG *) ((BYTE *) g_psidGuestUser + lenSid)) =
              DOMAIN_USER_RID_GUEST;
        } else {

            g_psidGuestUser = NULL;
        }

        if ( pUsrModals2 != NULL) {

            NET_API_STATUS ns = pfnNetApiBufferFree( (LPVOID )pUsrModals2);
            pUsrModals2 = NULL;
        }

        if ( hInstance != NULL ) {
            FreeLibrary(hInstance);
        }
    }

    if ( fRet && g_fUseSingleToken )
    {
        BYTE    abInfo[256];
        DWORD   dwInfo;

        if ( GetTokenInformation( g_hProcessPrimaryToken,
                                  TokenUser,
                                  abInfo,
                                  sizeof(abInfo),
                                  &dwInfo ) )
        {
            if ( !(g_psidProcessUser = (PSID)LocalAlloc( LMEM_FIXED,
                                                         GetLengthSid(((TOKEN_USER*)abInfo)->User.Sid))) )
            {
                fRet = FALSE;
            }
            else
            {
                memcpy ( g_psidProcessUser,
                         ((TOKEN_USER*)abInfo)->User.Sid,
                         GetLengthSid(((TOKEN_USER*)abInfo)->User.Sid) );
            }
        }
        else
        {
            fRet = FALSE;
        }
    }

    if ( !fRet ) {
        error = GetLastError( );
        IF_DEBUG( DLL_SECURITY ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot create well-known sids\n" ));
        }
    }

    return error;

}   // CreateWellKnownSids

/*******************************************************************

    NAME:       FreeWellKnownSids

    SYNOPSIS:   Frees the SIDs created with CreateWellKnownSids.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/
VOID FreeWellKnownSids( VOID )
{

    if( psidWorld != NULL )
    {
        FreeSid( psidWorld );
        psidWorld = NULL;
    }

    if( psidLocalSystem != NULL )
    {
        FreeSid( psidLocalSystem );
        psidLocalSystem = NULL;
    }

    if( psidAdmins != NULL )
    {
        FreeSid( psidAdmins );
        psidAdmins = NULL;
    }

    if( psidServerOps != NULL )
    {
        FreeSid( psidServerOps );
        psidServerOps = NULL;
    }

    if( psidPowerUsers != NULL )
    {
        FreeSid( psidPowerUsers );
        psidPowerUsers = NULL;
    }

    if( g_psidProcessUser != NULL )
    {
        LocalFree( g_psidProcessUser );
        g_psidProcessUser = NULL;
    }

}   // FreeWellKnownSids

/*******************************************************************

    NAME:       CreateApiSecurityObject

    SYNOPSIS:   Create an abstract security object used for validating
                user access to the TCP Server APIs.

    RETURNS:    NTSTATUS - An NT Status code.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/
DWORD CreateApiSecurityObject( VOID )
{
    DWORD err;
    ACE_DATA aces[] =
                 {
                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_ALL_ACCESS,
                         &psidLocalSystem
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_ALL_ACCESS,
                         &psidAdmins
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_ALL_ACCESS,
                         &psidServerOps
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_ALL_ACCESS,
                         &psidPowerUsers
                     },
                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_GENERIC_EXECUTE,
                         &psidWorld
                     },
                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_GENERIC_EXECUTE,
                         &g_psidProcessUser
                     },

                 };

#define NUM_ACES (sizeof(aces) / sizeof(RTL_ACE_DATA))

    err = INetCreateSecurityObject( aces,
                                    (ULONG)(g_fUseSingleToken ? NUM_ACES : NUM_ACES-1),
                                    NULL,
                                    NULL,
                                    &TCPApiObjectMapping,
                                    &sdApiObject  );


    IF_DEBUG( DLL_SECURITY )
    {
        if( err )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot create api security object, error %d\n",
                        err ));
        }
    }

    return err;

}   // CreateApiSecurityObject

/*******************************************************************

    NAME:       DeleteApiSecurityObject

    SYNOPSIS:   Frees the security descriptor created with
                CreateApiSecurityObject.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/
VOID DeleteApiSecurityObject( VOID )
{
    INetDeleteSecurityObject( &sdApiObject );

}   // DeleteApiSecurityObject



//
//  Short routine to enable the TcbPrivilege for testing services running
//  as an executable (rather then a service).  Note that the account
//  running the .exe must be added in User Manager's User Right's dialog
//  under "Act as part of the OS"
//

VOID EnableTcbPrivilege(
    VOID
    )
{
    HANDLE ProcessHandle = NULL;
    HANDLE TokenHandle = NULL;
    BOOL Result;
    LUID TcbValue;
    LUID AuditValue;
    TOKEN_PRIVILEGES * TokenPrivileges;
    CHAR buf[ 5 * sizeof(TOKEN_PRIVILEGES) ];

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of TakeOwnershipPrivilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeTcbPrivilege",
                 &TcbValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    //  Need this for RPC impersonation (calls NtAccessCheckAndAuditAlarm)
    //

    Result = LookupPrivilegeValue(
                 NULL,
                 "SeAuditPrivilege",
                 &AuditValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges = (TOKEN_PRIVILEGES *) buf;

    TokenPrivileges->PrivilegeCount = 2;
    TokenPrivileges->Privileges[0].Luid = TcbValue;
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges->Privileges[1].Luid = AuditValue;
    TokenPrivileges->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                TokenPrivileges,
                sizeof(buf),
                NULL,
                NULL
                );

Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}


BOOL CrackUserAndDomain(
    CHAR *   pszDomainAndUser,
    CHAR * * ppszUser,
    CHAR * * ppszDomain
    )
/*++

Routine Description:

    Given a user name potentially in the form domain\user, zero terminates
    the domain name and returns pointers to the domain name and the user name

Arguments:

    pszDomainAndUser - Pointer to user name or domain and user name
    ppszUser - Receives pointer to user portion of name
    ppszDomain - Receives pointer to domain portion of name

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    static CHAR szDefaultDomain[MAX_COMPUTERNAME_LENGTH+1];

    //
    //  Crack the name into domain/user components.
    //

    *ppszDomain = pszDomainAndUser;
#if 1 // DBCS enabling for user name
    *ppszUser   = (PCHAR)_mbspbrk( (PUCHAR)pszDomainAndUser, (PUCHAR)"/\\" );
#else
    *ppszUser   = strpbrk( pszDomainAndUser, "/\\" );
#endif

    if( *ppszUser == NULL )
    {
        //
        //  No domain name specified, just the username so we assume the
        //  user is on the local machine
        //

        if ( !*szDefaultDomain )
        {
            if ( !pfnGetDefaultDomainName( szDefaultDomain,
                                        sizeof(szDefaultDomain)))
            {
                return FALSE;
            }
        }

        *ppszDomain = szDefaultDomain;
        *ppszUser   = pszDomainAndUser;
    }
    else
    {
        //
        //  Both domain & user specified, skip delimiter.
        //

        **ppszUser = '\0';
        (*ppszUser)++;

        if( ( **ppszUser == '\0' ) ||
            ( **ppszUser == '\\' ) ||
            ( **ppszUser == '/' )  ||
            ( *pszDomainAndUser == '\0' ) )
        {
            //
            //  Name is of one of the following (invalid) forms:
            //
            //      "domain\"
            //      "domain\\..."
            //      "domain/..."
            //      "\username"
            //      "/username"
            //

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    return TRUE;
}


LONG
WINAPI
NullReferenceMapper(
    IN HMAPPER     *pMap
    )
/*++

Routine Description:

    Increment reference count to mapper

Arguments:

    pMap - ptr to mapper struct

Returns:

    Ref count

--*/
{
    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    return pfnInterlockedExchangeAdd( &((IisMapper*)pMap)->lRefCount, 1 ) + 1;
}


LONG
WINAPI
NullDeReferenceMapper(
    IN HMAPPER     *pMap
    )
/*++

Routine Description:

    Decrement reference count to mapper

Arguments:

    pMap - ptr to mapper struct

Returns:

    Ref count

--*/
{
    LONG l;

    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    if ( !(l = pfnInterlockedExchangeAdd( &((IisMapper*)pMap)->lRefCount, -1 ) - 1 ) )
    {
        LocalFree( pMap );
    }

    return l;
}


DWORD WINAPI NullGetIssuerList(
    HMAPPER        *phMapper,           // in
    VOID *          Reserved,           // in
    BYTE *          pIssuerList,       // out
    DWORD *         pcbIssuerList       // out
)
/*++

Routine Description:

    Called to retrieve the list of preferred cert issuers

Arguments:

    ppIssuer -- updated with ptr buffer of issuers
    pdwIssuer -- updated with issuers buffer size

Returns:

    TRUE if success, FALSE if error

--*/
{
    return SEC_E_UNSUPPORTED_FUNCTION;
}


DWORD WINAPI NullGetChallenge(
    HMAPPER         *pMap,              // in
    BYTE *          pAuthenticatorId,   // in
    DWORD           cbAuthenticatorId,  // in
    BYTE *          pChallenge,        // out
    DWORD *         pcbChallenge        // out
)
/*++

Routine Description:

    Get challenge for auth sequence

Arguments:

    Not used

Returns:

    FALSE ( not supported )

--*/
{
    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    return SEC_E_UNSUPPORTED_FUNCTION;
}


DWORD WINAPI NullMapCredential(
    HMAPPER *   phMapper,
    DWORD       dwCredentialType,
    const VOID* pCredential,        // in
    const VOID* pAuthority,         // in
    HLOCATOR *  phToken
)
/*++

Routine Description:

    Called to map a certificate to a NT account

Arguments:

    phMapper - ptr to mapper descriptor
    dwCredentialType -- type of credential
    pCredential - ptr to PCERT_CONTEXT for client cert
    pAuthority - ptr to PCERT_CONTEXT for Certifying authority
    phToken -- updated with impersonation access token

Returns:

    FALSE ( mapping always fail )

--*/
{
    DBG_ASSERT( ((IisMapper*)phMapper)->dwSignature == IIS_MAPPER_SIGNATURE );

    return SEC_E_UNSUPPORTED_FUNCTION;
}


DWORD WINAPI NullCloseLocator(
    HMAPPER  *pMap,
    HLOCATOR hLocator   //in
)
/*++

Routine Description:

    Called to close a HLOCATOR returned by MapCredential

Arguments:

    tokenhandle -- HLOCATOR

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    if (hLocator == 1) {
        return SEC_E_OK;
    }
    else {
        if (CloseHandle( (HANDLE)hLocator )) {\
            return SEC_E_OK;
        }
        else {
        }
    }
    return hLocator == 1 ? TRUE : CloseHandle( (HANDLE)hLocator );
}


DWORD WINAPI NullGetAccessToken(
    HMAPPER     *pMap,
    HLOCATOR    tokenhandle,
    HANDLE *    phToken
    )
/*++

Routine Description:

    Called to retrieve an access token from a mapping

Arguments:

    tokenhandle -- HLOCATOR returned by MapCredential
    phToken -- updated with potentially new token

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    if ( tokenhandle == 1 )
    {
        *phToken = (HANDLE)tokenhandle;
    }

    else if ( !pfnDuplicateTokenEx( (HANDLE)tokenhandle,
                            TOKEN_ALL_ACCESS,
                            NULL,
                            SecurityImpersonation,
                            TokenImpersonation,
                            phToken ))
    {
        return SEC_E_UNSUPPORTED_FUNCTION;
    }

    return SEC_E_OK;
}


DWORD WINAPI NullQueryMappedCredentialAttributes(
    HMAPPER     *phMapper,  // in
    HLOCATOR    hLocator,   // in
    ULONG       ulAttribute, // in
    PVOID       pBuffer, //out
    DWORD       *pcbBuffer // in out
    )
{
    return ( SEC_E_NOT_SUPPORTED );
}


QuerySingleAccessToken(
    VOID
    )
/*++

Routine Description:

    Query status of single access token mode

Arguments:

    None

Returns:

    TRUE if single access token mode used, otherwise FALSE

--*/
{
    return g_fUseSingleToken;
}


BOOL
CACHED_CREDENTIAL::GetCredential(
    LPSTR                   pszPackage,
    PIIS_SERVER_INSTANCE    psi,
    PTCP_AUTHENT_INFO       pTAI,
    CredHandle*             prcred,
    ULONG*                  pcbMaxToken
    )
/*++

Routine Description:

    Get SSPI credential handle from cache

Arguments:

    pszPackage - SSPI package name, e.g NTLM
    psi - pointer to server instance
    pTAI - pointer to authent info, only DomainName used
    prcred - updated with CredHandle from cache
    pcbMaxToken - updated with max token size used by this package

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LIST_ENTRY *                pEntry;
    CACHED_CREDENTIAL *         pcred;
    SEC_WINNT_AUTH_IDENTITY     AuthIdentity;
    SEC_WINNT_AUTH_IDENTITY *   pAuthIdentity;
    SecPkgInfo *                pspkg;
    TimeStamp                   Lifetime;
    STACK_STR                   ( strDefaultLogonDomain, IIS_DNLEN+1 );
    SECURITY_STATUS             ss;


    DBG_ASSERT( pszPackage != NULL );
    DBG_ASSERT( pTAI != NULL );

    EnterCriticalSection( &csCredentialCacheLock );

    for ( pEntry  = CredentialCacheList.Flink;
          pEntry != &CredentialCacheList;
          pEntry  = pEntry->Flink )
    {
        pcred = CONTAINING_RECORD( pEntry, CACHED_CREDENTIAL, _ListEntry );

        if ( !strcmp( pszPackage, pcred->_PackageName.QueryStr() ) &&
             !strcmp( pTAI->strDefaultLogonDomain.QueryStr(), pcred->_DefaultDomain.QueryStr() ) )
        {
            goto Exit;
        }
    }

    if ( (pcred = new CACHED_CREDENTIAL) == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto Exit;
    }

    if ( !pcred->_PackageName.Copy( pszPackage ) ||
         !pcred->_DefaultDomain.Copy( pTAI->strDefaultLogonDomain ) )
    {
        delete pcred;
        pcred = NULL;
        goto Exit;
    }

    //
    // provide default logon domain
    //

    if ( psi == NULL )
    {
        pAuthIdentity = NULL;
    }
    else
    {
        pAuthIdentity = &AuthIdentity;

        memset( &AuthIdentity,
                0,
                sizeof( AuthIdentity ));

        if ( pTAI->strDefaultLogonDomain.QueryCCH() <= IIS_DNLEN )
        {
            strDefaultLogonDomain.Copy( pTAI->strDefaultLogonDomain );
            AuthIdentity.Domain = (LPBYTE)strDefaultLogonDomain.QueryStr();
        }
        if ( AuthIdentity.Domain != NULL )
        {
            if ( AuthIdentity.DomainLength =
                    strlen( (LPCTSTR)AuthIdentity.Domain ) )
            {
                // remove trailing '\\' if present

                if ( AuthIdentity.Domain[AuthIdentity.DomainLength-1]
                        == '\\' )
                {
                    --AuthIdentity.DomainLength;
                }
            }
        }
        if ( AuthIdentity.DomainLength == 0 )
        {
            pAuthIdentity = NULL;
        }
        else
        {
            AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
        }
    }

    ss = pfnAcquireCredentialsHandle( NULL,             // New principal
                                   pszPackage,       // Package name
                                   SECPKG_CRED_INBOUND,
                                   NULL,             // Logon ID
                                   pAuthIdentity,    // Auth Data
                                   NULL,             // Get key func
                                   NULL,             // Get key arg
                                   &pcred->_hcred,
                                   &Lifetime );

    //
    //  Need to determine the max token size for this package
    //

    if ( ss == STATUS_SUCCESS )
    {
        pcred->_fHaveCredHandle = TRUE;
        ss = pfnQuerySecurityPackageInfo( (char *) pszPackage,
                                       &pspkg );
    }

    if ( ss == STATUS_SUCCESS )
    {
        pcred->_cbMaxToken = pspkg->cbMaxToken;
        DBG_ASSERT( pspkg->fCapabilities & SECPKG_FLAG_CONNECTION );
        pfnFreeContextBuffer( pspkg );
    }

    if ( ss != STATUS_SUCCESS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[GetCredential] AcquireCredentialsHandle or QuerySecurityPackageInfo failed, error %d\n",
                    ss ));

        SetLastError( ss );

        delete pcred;
        pcred = NULL;
    }
    else
    {
        InsertHeadList( &CredentialCacheList, &pcred->_ListEntry );
    }

Exit:

    if ( pcred )
    {
        *pcbMaxToken = pcred->_cbMaxToken;
        *prcred = pcred->_hcred;
    }

    LeaveCriticalSection( &csCredentialCacheLock );

    return pcred ? TRUE : FALSE;
}


CACHED_CREDENTIAL::~CACHED_CREDENTIAL(
    )
/*++

Routine Description:

    SSPI Credential cache entry destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( _fHaveCredHandle )
    {
        pfnFreeCredentialsHandle( &_hcred );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\rnr.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        rnr.cxx     (ripped out of tsvcinfo.cxx)

   Abstract:

        Defines the functions for TCP services Info class.
        This module is intended to capture the common scheduler
            code for the tcp services ( especially internet services)
            which involves the Service Controller dispatch functions.
        Also this class provides an interface for common dll of servers.

   Author:

           Murali R. Krishnan    ( MuraliK )     15-Nov-1994

   Project:

          Internet Servers Common DLL

--*/

#include "tcpdllp.hxx"
#include <tsunami.hxx>
#include <iistypes.hxx>


#define  MAX_SOCKETS        ( 20)

#if 0
inline
BOOL
IsConnectionOriented(
    IN PPROTOCOL_INFO  pProtocolInfo
    )
{

    return ( ( pProtocolInfo->dwServiceFlags & XP_CONNECTIONLESS) == 0);

} // IsConnectionOriented()


inline
BOOL
IsReliable(
    IN PPROTOCOL_INFO  pProtocolInfo
    )
/*++

  This should be a protocol which delivers all packets and in order in which
  they are sent.
--*/
{
    return ( ( pProtocolInfo->dwServiceFlags & XP_GUARANTEED_DELIVERY) &&
             ( pProtocolInfo->dwServiceFlags & XP_GUARANTEED_ORDER)    &&
             IsConnectionOriented( pProtocolInfo));

} // IsReliable()



INT
GetValidListenAddresses( IN LPCTSTR      pszServiceName,
                         IN LPGUID       lpServiceGuid,
                         IN PCSADDR_INFO pcsAddrInfo,
                         IN OUT LPDWORD  lpcbAddrInfo )
/*++
  This function obtains the list of valid listen addresses for the service
   specified. It uses the RNR API set to enumerate the list of protocols
   installed in a machine and queries using GetAddressByName() to obtain
   the list of valid addresses that can be used for establishing a listen
   socket.

  Arguments:
    pszServiceName  pointer to null-terminated string containing service name.
    lpServiceGuid   pointer to GUID for the service.
    pcsAddrInfo     pointer to an array of CSADDR_INFO structures which
                     on successful return contains the address information.
    lpcbAddInfo     pointer to a DWORD containing the count of bytes
                     available under pcsAddrInfo. When this function is
                     called, it contains the number of bytes pointed to by
                     pcsAddrInfo. On return contains the number of
                     bytes required.

  Returns:
     count of valid CSADDR_INFO structures found for the given service to
       establish a listen socket.

     On error returns a value <= 0.
--*/
{
    int nAddresses = 0;       // assume a safe value == failure.

    DWORD  cbBuffer;
    int    cProtocols;
    PPROTOCOL_INFO  pProtocolInfo;
    int    rgProtocols[ MAX_SOCKETS + 1];
    int *  pProtocol;
    int    i;
    BUFFER buff;

#define ENUM_PROTO_BUFF_SIZE    49152

    //
    // First Look up the protocols installed on this machine. The
    //   EnumProtocols() API returns about all the windows sockets protocols
    //   loaded on this machine. We will use this information to identify the
    //   protocols which provide the necessary semantics.
    //

    if ( !buff.Resize( ENUM_PROTO_BUFF_SIZE )) {

        return 0;
    }

    cbBuffer = buff.QuerySize();
    cProtocols = EnumProtocols( NULL, buff.QueryPtr(), &cbBuffer);

    if ( cProtocols < 0) {

        return 0;
    }


    //
    // Walk through the available protocols and pick out the ones that
    //  support the desired characteristics.
    //

    for( pProtocolInfo = (PPROTOCOL_INFO ) buff.QueryPtr(),
         pProtocol = rgProtocols,
         i = 0;
         ( i < cProtocols &&
           ( pProtocol < rgProtocols + MAX_SOCKETS));
         pProtocolInfo++, i++ ) {

        if ( IsReliable( pProtocolInfo)) {

            //
            // This protocol matches our requirement of being reliable.
            //  Make a note of the protocol.
            //

            IF_DEBUG( DLL_SERVICE_INFO) {
                DBGPRINTF( ( DBG_CONTEXT,
                            " Protocol %d ( %s) matches condition\n",
                            pProtocolInfo->iProtocol,
                            pProtocolInfo->lpProtocol));
            }

            *pProtocol++ = pProtocolInfo->iProtocol;
        }

    } // for()   : Protocol filter ()

    IF_DEBUG( DLL_SERVICE_INFO) {
        DBGPRINTF( ( DBG_CONTEXT, " Filtering yields %d of %d protocols. \n",
                    ( pProtocol - rgProtocols), cProtocols));
    }

    // terminate the protocols array.
    *pProtocol = 0;
    cProtocols = ( pProtocol - rgProtocols);

    //
    // Make sure we found at least one acceptable protocol.
    // If there is no protocol on this machine, which suit our condition,
    //   this function fails.
    //

    if ( cProtocols > 0) {

        //
        // Use GetAddressByName() to get addresses for chosen protocols.
        // We restrict the scope of the search to those protocols of interest
        //  by passing the protocols array we generated. The function
        //  returns socket addresses only for the protocols we can support.
        //

        nAddresses = GetAddressByName(
                                      NS_DEFAULT, //  lpszNameSpace
                                      lpServiceGuid,
                                      (char *) pszServiceName,
                                      rgProtocols,
                                      RES_SERVICE | RES_FIND_MULTIPLE,
                                      NULL,       // lpServiceAsyncInfo
                                      (PVOID )pcsAddrInfo,
                                      lpcbAddrInfo,
                                      NULL,       // lpAliasBuffer
                                      NULL        // lpdwAliasBufferLen
                                      );

        IF_DEBUG( DLL_SERVICE_INFO) {

            // take a copy of error code and set it back, to avoid lost errors
            DWORD dwError = GetLastError();

            DBGPRINTF( ( DBG_CONTEXT,
                        " GetAddressByName() returned %d."
                        " Bytes Written=%d. Error = %ld\n",
                        nAddresses, *lpcbAddrInfo,
                        ( nAddresses <= 0) ? dwError: NO_ERROR));

            if ( nAddresses <= 0) { SetLastError( dwError); }
        }
    }
    return ( nAddresses);
} // GetValidListenAddress()
#endif




BOOL
RegisterServiceForAdvertising(
    IN LPCTSTR pszServiceName,
    IN LPGUID  lpServiceGuid,
    IN SOCKET  s,
    IN BOOL    fRegister
    )

/*++
  This function registers a service for the purpose of advertising.
  By registering using RnR apis, we advertise the fact that this particular
   service is running on the protocols designated. Hence RnR compliant
   clients can get access to the same.

  Arguments:
    pszService      name of the service
    lpServiceGuid   pointer to GUID for the service.
    s               socket whose address needs to be advertised.
    fRegister       whether to register to deregister

  Returns:
    TRUE on success and FALSE if there is any failure.
    Use GetLastError() for further details on failure.
--*/
{
    BOOL         fReturn = TRUE;
#if 0
    BYTE *       pbAddressBuffer;
    DWORD        cbAddressBuffer;
    INT          err;
    SERVICE_INFO serviceInfo;
    SERVICE_ADDRESSES  * pServiceAddress;

    DBG_ASSERT( pszServiceName && lpServiceGuid );
    DBG_ASSERT( s != INVALID_SOCKET );

    /*++
      Advertising service involves following steps:
      1. Set up a service info structure.
      2. Allocate memory for service addresses for as many sockets need to
           be advertised.
      3. Fill in the information containing the socket addresses
      4. Execute call for advertising the service (use SetService( REGISTER)).
      --*/

    //
    // Alloc space for SERVICE_ADDRESSES and n-1 SERVICE_ADDRESS structures.
    //
    pServiceAddress = ( ( SERVICE_ADDRESSES *)
                       TCP_ALLOC( sizeof( SERVICE_ADDRESSES) )
                       );

    // Alloc space for SOCKADDR addresses returned.
    cbAddressBuffer = sizeof(SOCKADDR);
    pbAddressBuffer = (BYTE *) TCP_ALLOC(cbAddressBuffer);

    if ( pServiceAddress == NULL || pbAddressBuffer == NULL) {

        if ( pServiceAddress != NULL)   { TCP_FREE( pServiceAddress); }
        if ( pbAddressBuffer != NULL)   { TCP_FREE( pbAddressBuffer); }
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (FALSE);
    }

    //
    // set up service info structure.
    // Here the interesting fields are lpServiceType, lpServiceName,
    //  and lpServiceAddress fields.
    //
    serviceInfo.lpServiceType    = lpServiceGuid ;
    // surprisingly enough! RNR structures dont like constants
    serviceInfo.lpServiceName    = (LPTSTR ) pszServiceName ;
    // do we need better comment ? NYI
    serviceInfo.lpComment        = "Microsoft Internet Services";
    serviceInfo.lpLocale         = NULL;
    serviceInfo.lpMachineName    = NULL ;
    serviceInfo.dwVersion        = 1;
    serviceInfo.dwDisplayHint    = 0;
    serviceInfo.dwTime           = 0;
    serviceInfo.lpServiceAddress = pServiceAddress;

    serviceInfo.ServiceSpecificInfo.cbSize = 0 ;
    serviceInfo.ServiceSpecificInfo.pBlobData = NULL ;

    //
    // For each socket, get its local association and store the same.
    //

    PSOCKADDR    pSockAddr = (PSOCKADDR ) pbAddressBuffer;

    int size = (int) cbAddressBuffer;

    //
    // Call getsockname() to get the local association for the socket.
    //

    if ( getsockname( s, pSockAddr, &size) == 0 ) {

        //
        // Now setup the Addressing information for this socket.
        // Only the dwAddressType, dwAddressLength and lpAddress
        // is of any interest in this example.
        //

        pServiceAddress->Addresses[0].dwAddressType    = pSockAddr->sa_family;
        pServiceAddress->Addresses[0].dwAddressFlags   = 0;
        pServiceAddress->Addresses[0].dwAddressLength  = size ;
        pServiceAddress->Addresses[0].dwPrincipalLength= 0 ;
        pServiceAddress->Addresses[0].lpAddress        = (LPBYTE) pSockAddr;
        pServiceAddress->Addresses[0].lpPrincipal      = NULL ;

        //
        // Advance pointer and adjust buffer size. Assumes that
        // the structures are aligned.  Unaligned accesses !! NYI
        //

        cbAddressBuffer -= size;
        pSockAddr = (PSOCKADDR) ((BYTE*)pSockAddr + size);

        pServiceAddress->dwAddressCount = 1;

        //
        // If we got at least one address, go ahead and advertise it.
        //

        DWORD  dwStatusFlags;
        err =  SetService(
                   NS_DEFAULT,       // for all default name spaces
                   fRegister ? SERVICE_REGISTER : SERVICE_DEREGISTER,
                   0,                // no flags specified
                   &serviceInfo,     // SERVICE_INFO structure
                   NULL,             // no async support yet
                   &dwStatusFlags) ;   // returns status flags
        IF_DEBUG( DLL_CONNECTION ) {

            DBGPRINTF(( DBG_CONTEXT, " SetService(%s, NS_DEFAULT, Register=%d)"
                       " returns Status = %08x,"
                       " err = %d\n",
                       pszServiceName, fRegister,
                       dwStatusFlags, err));
        }

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
    }

    TCP_FREE( pbAddressBuffer);
    TCP_FREE( pServiceAddress);
#endif
    return ( fReturn);

} // RegisterServiceForAdvertising()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\tsvccfg.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        tsvccfg.cxx

   Abstract:

        Defines the functions for TCP services Info class.
        This module is intended to capture the common scheduler
            code for the tcp services ( especially internet services)
            which involves the Service Controller dispatch functions.
        Also this class provides an interface for common dll of servers.

   Author:

           Murali R. Krishnan    ( MuraliK )     15-Nov-1994

   Project:

          Internet Servers Common DLL

--*/

#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <iisbind.hxx>
#include <iisassoc.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"
#include <rdns.hxx>

#include <ole2.h>
#include <imd.h>
#include <inetreg.h>
#include <mb.hxx>

//
// Used to configure
//

typedef struct _IIS_SOCKET_CONFIG {
    DWORD nAcceptExOutstanding;
} IIS_SOCKET_CONFIG;
IIS_SOCKET_CONFIG TsSocketConfig[3] = {{5}, {40}, {100}};

//
// from security.cxx
//

BOOL
BuildAnonymousAcctDesc(
    IN  OUT PCHAR        pszAcctDesc,
    IN  const CHAR *     pszDomainAndUser,
    IN  const CHAR *     pszPwd,
    OUT LPDWORD          pdwAcctDescLen
    );

BOOL
AppendDottedDecimal(
    STR * pstr,
    DWORD dwAddress
    );

//
// private functions
//

extern VOID
CopyUnicodeStringToBuffer(
   OUT WCHAR * pwchBuffer,
   IN  DWORD   cchMaxSize,
   IN  LPCWSTR pwszSource
   );


DWORD
SetInetLogConfiguration(
        IN LOGGING *pLogging,
        IN EVENT_LOG * pEventLog,
        IN const INET_LOG_CONFIGURATION * pRpcLogConfig
        );

DWORD
GetRPCLogConfiguration(
        LOGGING *pLogging,
        OUT LPINET_LOG_CONFIGURATION * ppLogConfig
        );

BOOL
GenerateIpList(
    BOOL fIsGrant,
    ADDRESS_CHECK *pCheck,
    LPINET_INFO_IP_SEC_LIST *ppInfo
    );

BOOL
FillAddrCheckFromIpList(
    BOOL fIsGrant,
    LPINET_INFO_IP_SEC_LIST pInfo,
    ADDRESS_CHECK *pCheck
    );

BOOL
GetVrootCount(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

BOOL
GetVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

VOID
CopyUnicodeStringToBuffer(
   OUT WCHAR * pwchBuffer,
   IN  DWORD   cchMaxSize,
   IN  LPCWSTR pwszSource)
/*
   copies at most cbMaxSize-1 characters from pwszSource to pwchBuffer
*/
{
    DBG_ASSERT( pwszSource != NULL);

    DWORD cchLen = lstrlenW( pwszSource);
    if ( cchLen >= cchMaxSize) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Long String ( %d chars) %ws given."
                    " Truncating to %d chars\n",
                    cchLen, pwszSource,
                    cchMaxSize - 1));


    //  There is a bug in the lstrcpyn. hence need to work around it.
#ifndef  LSTRCPYN_DEBUGGED
        cchLen = cchMaxSize - 2;
# else
       cchLen = cchMaxSize -1;
# endif
    }

#ifndef  LSTRCPYN_DEBUGGED
    lstrcpynW( pwchBuffer, pwszSource, cchLen + 1);
# else
    lstrcpynW( pwchBuffer, pwszSource, cchLen );
# endif

    return;
} // CopyUnicodeStringToBuffer()




BOOL
IIS_SERVER_INSTANCE::GetCommonConfig(
                                IN OUT PCHAR pConfig,
                                IN DWORD dwLevel
                                )
/*++
  This function copies the current configuration for a service (IIS_SERVER_INSTANCE)
    into the given RPC object pConfig.
  In case of any failures, it deallocates any memory block that was
     allocated during the process of copy by this function alone.

  Arguments:
     pConfig  - pointer to RPC configuration object for a service.
     dwLevel  - level of our configuration.

  Returns:

     TRUE for success and FALSE for any errors.
--*/
{
    BOOL fReturn = TRUE;
    LPINETA_CONFIG_INFO pInfoConfig = (LPINETA_CONFIG_INFO)pConfig;
    ADDRESS_CHECK       acCheck;
    BOOL                fMustRel;
    MB                  mb( (IMDCOM*) m_Service->QueryMDObject() );
    DWORD               cRoots = 0;
    STR                 strAnon;
    STR                 strAnonPwd;
    STR                 strServerComment;
    DWORD               err = NO_ERROR;


    IF_DEBUG(INSTANCE) {
        DBGPRINTF((DBG_CONTEXT,"GetCommonConfig called with L%d for instance %d\n",
            dwLevel, QueryInstanceId() ));
    }

    LockThisForRead();

    //
    //  Get always retrieves all of the parameters except for the anonymous
    //  password, which is retrieved as a secret
    //

    pInfoConfig->FieldControl = (FC_INET_INFO_ALL & ~FC_INET_INFO_ANON_PASSWORD);

    pInfoConfig->dwConnectionTimeout = QueryConnectionTimeout();
    pInfoConfig->dwMaxConnections    = QueryMaxConnections();

    pInfoConfig->LangId              = GetSystemDefaultLangID();
    pInfoConfig->LocalId             = GetSystemDefaultLCID();

    //
    //  This is the PSS product ID
    //

    ZeroMemory( pInfoConfig->ProductId,sizeof( pInfoConfig->ProductId ));

    //
    //  Copy the strings
    //

    fReturn = (ConvertStringToRpc(&pInfoConfig->lpszAdminName,
                                  ""/*QueryAdminName()*/ )           &&
               ConvertStringToRpc( &pInfoConfig->lpszAdminEmail,
                                  "" /*QueryAdminEmail()*/ )
               );

    if ( !fReturn ) {

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT,"ConvertStringToRpc failed with %d\n",
                GetLastError() ));
        }

        goto Exit;
    } else {

        DWORD dwError;

        dwError = GetRPCLogConfiguration(&m_Logging,
                                         &pInfoConfig->lpLogConfig);

        if ( dwError != NO_ERROR)  {

            IF_DEBUG(INSTANCE) {
                DBGPRINTF((DBG_CONTEXT,"GetRPCLogConfiguration failed with %d\n",
                    dwError));
            }
            SetLastError( dwError);
            fReturn = FALSE;
            goto Exit;
        }
    }

    pInfoConfig->fLogAnonymous       = QueryLogAnonymous();
    pInfoConfig->fLogNonAnonymous    = QueryLogNonAnonymous();

    ZeroMemory(
        pInfoConfig->szAnonPassword,
        sizeof( pInfoConfig->szAnonPassword )
        );

    //
    //  Copy the IP security info from metabase
    //

    if ( mb.Open( QueryMDVRPath() ) )
    {
        VOID * pvData;
        DWORD  cbData;
        DWORD  dwTag;

        if ( mb.ReferenceData( "",
                               MD_IP_SEC,
                               IIS_MD_UT_FILE,
                               BINARY_METADATA,
                               &pvData,
                               &cbData,
                               &dwTag ) &&
             dwTag )
        {
            acCheck.BindCheckList( (BYTE *) pvData, cbData );
            fMustRel = TRUE;
        }
        else
        {
            fMustRel = FALSE;
        }

        fReturn = GenerateIpList( TRUE, &acCheck, &pInfoConfig->GrantIPList ) &&
                  GenerateIpList( FALSE, &acCheck, &pInfoConfig->DenyIPList );

        if ( fMustRel )
        {
            DBG_REQUIRE( mb.ReleaseReferenceData( dwTag ));
        }

        DBG_REQUIRE( mb.Close() );
    }
    else
    {
        fReturn = FALSE;
    }

    if ( !fReturn )
    {
        goto Exit;
    }

    //
    //  Copy the virtual root info, note a NULL VirtualRoots is not
    //  valid as it is for IP security.  This should be the last
    //  allocated item for the pConfig structure
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        fReturn = FALSE;
        goto Exit;
    }

    if ( TsEnumVirtualRoots( GetVrootCount, &cRoots, &mb ) )
    {
        DWORD cbSize = sizeof(INET_INFO_VIRTUAL_ROOT_LIST) +
                       cRoots * sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY)
                       ;
        pInfoConfig->VirtualRoots = (LPINET_INFO_VIRTUAL_ROOT_LIST)
                 MIDL_user_allocate( cbSize );

        memset( pInfoConfig->VirtualRoots, 0, cbSize );

        if ( pInfoConfig->VirtualRoots )
        {
            fReturn = TsEnumVirtualRoots( GetVroots, pInfoConfig->VirtualRoots, &mb );
        }

        // only used for UNC virtual directories (to store the passwords)
        err = TsSetSecretW( m_lpwszRootPasswordSecretName,
                            L"",
                            sizeof(WCHAR) );
        if ( err == ERROR_ACCESS_DENIED && g_fW3OnlyNoAuth )
        {
            err = 0;
        }
    }

    mb.Close();

    if ( !fReturn )
    {
        goto Exit;
    }

    if ( !mb.Open( QueryMDPath() ))
    {
        fReturn = FALSE;
        goto Exit;
    }

    mb.GetDword( "",
                 MD_AUTHORIZATION,
                 IIS_MD_UT_FILE,
                 MD_AUTH_ANONYMOUS,
                 &pInfoConfig->dwAuthentication );

    if ( !mb.GetStr( "",
                     MD_ANONYMOUS_USER_NAME,
                     IIS_MD_UT_FILE,
                     &strAnon,
                     METADATA_INHERIT,
                     "<>" ))
    {
        fReturn = FALSE;
        goto Exit;
    }

    if ( !mb.GetStr( "",
                     MD_SERVER_COMMENT,
                     IIS_MD_UT_SERVER,
                     &strServerComment,
                     METADATA_INHERIT,
                     INETA_DEF_SERVER_COMMENT ))
    {
        //
        // If this is a single instance service, this is also the
        // service comment
        //

        if ( !m_Service->IsMultiInstance() ) {
            m_Service->SetServiceComment( strServerComment.QueryStr() );
        }
    }

    fReturn = ConvertStringToRpc( &pInfoConfig->lpszServerComment,
                                  strServerComment.QueryStr() ) &&
              ConvertStringToRpc( &pInfoConfig->lpszAnonUserName,
                                  strAnon.QueryStr() );

    //
    //  Get the anonymous user password but store it as an LSA secret
    //

    if ( mb.GetStr( "",
                    MD_ANONYMOUS_PWD,
                    IIS_MD_UT_FILE,
                    &strAnonPwd,
                    METADATA_INHERIT | METADATA_SECURE ))
    {
        BUFFER buff;

        if ( buff.Resize( (strAnonPwd.QueryCCH() + 1) * sizeof(WCHAR )))
        {
            if ( MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      strAnonPwd.QueryStr(),
                                      strAnonPwd.QueryCCH() + 1,
                                      (LPWSTR) buff.QueryPtr(),
                                      strAnonPwd.QueryCCH() + 1 ))
            {
                err = TsSetSecretW( m_lpwszAnonPasswordSecretName,
                                    (LPWSTR) buff.QueryPtr(),
                                    wcslen( (LPWSTR) buff.QueryPtr()) * sizeof(WCHAR) );
                if ( err == ERROR_ACCESS_DENIED && g_fW3OnlyNoAuth )
                {
                    err = 0;
                }
            }
        }
    }
    else
    {
        //
        //  store an empty password if there's no anonymous user at this level
        //

        err = TsSetSecretW( m_lpwszAnonPasswordSecretName,
                            L"",
                            sizeof(WCHAR) );
        if ( err == ERROR_ACCESS_DENIED && g_fW3OnlyNoAuth )
        {
            err = 0;
        }
    }

    if ( err ) {
        SetLastError( err );
        fReturn = FALSE;
    }

    if ( !fReturn ) {
        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT,"Cannot get anonymous user name"));
        }
    }

Exit:

    if ( !fReturn ) {

        if ( pInfoConfig->lpLogConfig != NULL) {

            MIDL_user_free( pInfoConfig->lpLogConfig);
            pInfoConfig->lpLogConfig = NULL;
        }

        //
        //  FreeRpcString checks for NULL pointer
        //

        FreeRpcString( pInfoConfig->lpszAdminName );
        FreeRpcString( pInfoConfig->lpszAdminEmail );
        FreeRpcString( pInfoConfig->lpszServerComment );
        FreeRpcString( pInfoConfig->lpszAnonUserName );

        pInfoConfig->lpszAdminName     = NULL;
        pInfoConfig->lpszAdminEmail    = NULL;
        pInfoConfig->lpszServerComment = NULL;
        pInfoConfig->lpszAnonUserName  = NULL;

        if ( pInfoConfig->DenyIPList ) {

            MIDL_user_free( pInfoConfig->DenyIPList );
            pInfoConfig->DenyIPList = NULL;
        }

        if ( pInfoConfig->GrantIPList ) {
            MIDL_user_free( pInfoConfig->GrantIPList );
            pInfoConfig->GrantIPList = NULL;
        }
    }

    UnlockThis();

    return (fReturn);

} // IIS_SERVER_INSTANCE::GetConfiguration()



BOOL
IIS_SERVER_INSTANCE::RegReadCommonParams(
    BOOL fReadAll,
    BOOL fReadVirtualDirs
    )
/*++

   Description

     Reads the service common items from the registry

   Arguments:

     fReadAll - If TRUE read all parameters. 
                If FALSE read only those parameters that are necessary for initialization.

     fReadVirtualDirs - Initalize Virtual DIrectories.

   Note:

--*/
{
    MB                      mb( (IMDCOM*) m_Service->QueryMDObject()  );

    DBG_ASSERT( QueryInstanceId() != INET_INSTANCE_ROOT );

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF(( DBG_CONTEXT,
                   "IIS_SERVER_INSTANCE::ReadParamsFromRegistry() Entered. fReadAll = %d\n",
                   fReadAll));
    }

    //
    // Open the metabase and read parameters for IIS_SERVER_INSTANCE object
    // itself.
    //

    
    if ( !mb.Open( QueryMDPath(),
                   TsIsNtServer() ? METADATA_PERMISSION_READ : 
                                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )) 
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[ReadParamsFromRegistry] mb.Open returned error %d for path %s\n",
                    GetLastError(),
                    QueryMDPath() ));
    
    }

    LockThisForWrite();

    //
    // Values needed for initialization
    //
    
    mb.GetDword( "",
                 MD_SERVER_AUTOSTART,
                 IIS_MD_UT_SERVER,
                 TRUE,
                 (DWORD *) &m_fAutoStart
                 );

    mb.GetDword( "",
                 MD_CLUSTER_ENABLED,
                 IIS_MD_UT_SERVER,
                 FALSE,
                 (DWORD *) &m_fClusterEnabled
                 );

    /*
    That's a fix for a bug 367791 when restarting IIS with
    vhost sites marked for auto restart isn't bringing them online
    becuase of current disgn limitation how cluster service is checking for helth of
    vhost site it is not able to distinguish  that only one of few vhost sites are running
    and is not starting the rest. The fix is to allow to admin to set autorestart on site
    and then during startup of IIS to start that site not with cluster command but automaticcally
    Because of that the following lines are removed.

    if ( m_fClusterEnabled )
    {
        m_fAutoStart = FALSE;
    }
    */

    if ( !mb.GetStr( "",
                     MD_SERVER_COMMENT,
                     IIS_MD_UT_SERVER,
                     &m_strSiteName ) ||
         m_strSiteName.IsEmpty())
    {
        m_strSiteName.Copy(QueryMDPath());
    }

    //
    // Other values needed to run the instance
    //
    
    if ( fReadAll)
    {

        mb.GetDword( "",
                     MD_CONNECTION_TIMEOUT,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_CONNECTION_TIMEOUT,
                     &m_dwConnectionTimeout
                     );

        mb.GetDword( "",
                     MD_MAX_CONNECTIONS,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_MAX_CONNECTIONS,
                     &m_dwMaxConnections
                     );

        mb.GetDword( "",
                     MD_MAX_ENDPOINT_CONNECTIONS,
                     IIS_MD_UT_SERVER,
                     (TsIsNtServer()
                      ? TsSocketConfig[MD_SERVER_SIZE_LARGE].nAcceptExOutstanding
                      : INETA_DEF_MAX_ENDPOINT_CONNECTIONS_PWS
                      ),
                     &m_dwMaxEndpointConnections
                     );

        mb.GetDword( "",
                     MD_LEVELS_TO_SCAN,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_LEVELS_TO_SCAN,
                     &m_dwLevelsToScan
                     );

        //
        // if not NTS, limit the connections.  If reg value exceeds 40,
        // set it to 10.
        //

        if ( !TsIsNtServer() ) {

            if ( m_dwMaxConnections > INETA_MAX_MAX_CONNECTIONS_PWS ) {
                m_dwMaxConnections = INETA_DEF_MAX_CONNECTIONS_PWS;

                mb.SetDword( "",
                             MD_MAX_CONNECTIONS,
                             IIS_MD_UT_SERVER,
                             m_dwMaxConnections
                             );
            }

            if ( m_dwMaxEndpointConnections > INETA_MAX_MAX_ENDPOINT_CONNECTIONS_PWS ) {
                m_dwMaxEndpointConnections = INETA_DEF_MAX_ENDPOINT_CONNECTIONS_PWS;

                mb.SetDword( "",
                             MD_MAX_ENDPOINT_CONNECTIONS,
                             IIS_MD_UT_SERVER,
                             m_dwMaxEndpointConnections
                             );
            }
        }

        //
        //  Log anonymous and Log non-anonymous or for FTP only
        //

        mb.GetDword( "",
                     MD_LOG_TYPE,
                     IIS_MD_UT_SERVER,
                     TRUE,
                     (DWORD *) &m_fLoggingEnabled
                     );
                 
        mb.GetDword( "",
                     MD_LOG_ANONYMOUS,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_LOG_ANONYMOUS,
                     (DWORD *) &m_fLogAnonymous
                     );

        mb.GetDword( "",
                     MD_LOG_NONANONYMOUS,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_LOG_NONANONYMOUS,
                     (DWORD *) &m_fLogNonAnonymous
                     );

#if 0
        //
        // I don't believe that ServerCommand can be set to
        // started without our noticing, so I'm removing this
        // code.
        //
        if (!m_fAutoStart) {
    
            //
            // Server Command to start this instance may
            // have been written while service was stopped.
            // Need to pick it up
            //

            DWORD dwServerCommand;

            mb.GetDword( "",
                         MD_SERVER_COMMAND,
                         IIS_MD_UT_SERVER,
                         TRUE,
                         (DWORD *) &dwServerCommand
                         );

            if (dwServerCommand == MD_SERVER_COMMAND_START) {
                m_fAutoStart = TRUE;
            }

        }
#endif

        //
        //  Other fields
        //

        //
        // socket values
        //

        mb.GetDword( "",
                     MD_SERVER_SIZE,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_SERVER_SIZE,
                     &m_dwServerSize
                     );

        if ( m_dwServerSize > MD_SERVER_SIZE_LARGE ) {
            m_dwServerSize = INETA_DEF_SERVER_SIZE;
        }

        mb.GetDword( "",
                     MD_SERVER_LISTEN_BACKLOG,
                     IIS_MD_UT_SERVER,
                     TsSocketConfig[m_dwServerSize].nAcceptExOutstanding,
                     &m_nAcceptExOutstanding
                     );

        mb.GetDword( "",
                     MD_SERVER_LISTEN_TIMEOUT,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_ACCEPTEX_TIMEOUT,
                     &m_AcceptExTimeout
                     );
        //
        // Setup a bandwidth throttle descriptor if necessary (for NT server)
        //

        SetBandwidthThrottle( &mb );

        //
        // Set the maximum number of blocked requests for throttler
        //

        SetBandwidthThrottleMaxBlocked( &mb );

        // Root instance does not have VRs.  Close the metabase because the
        // virtual directories are going to be re-enumerated.
        //
    }

    mb.Close();

    if ( fReadVirtualDirs ) {
        TsReadVirtualRoots( );
    }

    UnlockThis();
    return TRUE;

} // IIS_SERVER_INSTANCE::ReadParamsFromRegistry()



BOOL
IIS_SERVER_INSTANCE::SetCommonConfig(
    IN LPINETA_CONFIG_INFO  pInfoConfig,
    IN BOOL  fRefresh
    )
/*++

   Description

     Writes the service common items to the registry

   Arguments:

      pInfoConfig - Admin items to write to the registry
      fRefresh    - Indicates whether we need to read back the data

   Note:
      We don't need to lock "this" object because we only write to the registry

      The anonymous password is set as a secret from the client side

--*/
{
    DWORD               err = NO_ERROR;
    FIELD_CONTROL       fcConfig;
    ADDRESS_CHECK       acCheck;
    BUFFER              buff;

    MB                  mb( (IMDCOM*) m_Service->QueryMDObject()  );

    //
    // Open the metabase and read parameters for IIS_SERVER_INSTANCE object
    // itself.
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )) {

        DBGPRINTF(( DBG_CONTEXT,
                   "[SetCommonConfig] mb.Open returned error %d for path %s\n",
                    GetLastError(),
                    QueryMDPath() ));


        return FALSE;
    }


    fcConfig = pInfoConfig->FieldControl;

    if ( IsFieldSet( fcConfig, FC_INET_INFO_CONNECTION_TIMEOUT ))
    {
        mb.SetDword( "",
                     MD_CONNECTION_TIMEOUT,
                     IIS_MD_UT_SERVER,
                     pInfoConfig->dwConnectionTimeout );
    }

    if ( (err == NO_ERROR) && IsFieldSet( fcConfig, FC_INET_INFO_MAX_CONNECTIONS ))
    {
        mb.SetDword( "",
                     MD_MAX_CONNECTIONS,
                     IIS_MD_UT_SERVER,
                     pInfoConfig->dwMaxConnections );
    }

    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_SERVER_COMMENT ) &&
         (pInfoConfig->lpszServerComment != NULL) )
    {
        if ( buff.Resize( 2 * (wcslen(pInfoConfig->lpszServerComment) + 1) *
                          sizeof(CHAR) ) )
        {
            (VOID) ConvertUnicodeToAnsi( pInfoConfig->lpszServerComment,
                                         (CHAR *) buff.QueryPtr(),
                                         buff.QuerySize() );

            mb.SetString( "",
                          MD_SERVER_COMMENT,
                          IIS_MD_UT_SERVER,
                          (CHAR *) buff.QueryPtr() );
        }
    }

    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_ANON_USER_NAME ) &&
         (pInfoConfig->lpszAnonUserName != NULL) )
    {
        STR strAnonPwd;

        if ( buff.Resize( 2 * (wcslen(pInfoConfig->lpszAnonUserName) + 1) *
                          sizeof(CHAR) ) )
        {
            (VOID) ConvertUnicodeToAnsi( pInfoConfig->lpszAnonUserName,
                                         (CHAR *) buff.QueryPtr(),
                                         buff.QuerySize() );

            mb.SetString( "",
                          MD_ANONYMOUS_USER_NAME,
                          IIS_MD_UT_FILE,
                          (CHAR *) buff.QueryPtr() );
        }

        //
        //  Set the anonymous password also.  The client sets it as an LSA
        //  secret
        //

        if ( TsGetSecretW( m_lpwszAnonPasswordSecretName,
                           &strAnonPwd ) &&
             mb.SetString( "",
                           MD_ANONYMOUS_PWD,
                           IIS_MD_UT_FILE,
                           strAnonPwd.QueryStr() ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to get/set anonymous secret, err %d\n",
                        GetLastError() ));
        }

    }

    if ( (err == NO_ERROR) && IsFieldSet( fcConfig, FC_INET_INFO_AUTHENTICATION ))
    {
        mb.SetDword( "",
                     MD_AUTHORIZATION,
                     IIS_MD_UT_FILE,
                     pInfoConfig->dwAuthentication );
    }

    //
    //  Write other fields
    //

    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_SITE_SECURITY ))
    {
        if ( (pInfoConfig->GrantIPList && pInfoConfig->GrantIPList->cEntries)
             || (pInfoConfig->DenyIPList && pInfoConfig->DenyIPList->cEntries) )
        {
            acCheck.BindCheckList( NULL, 0 );

            if ( FillAddrCheckFromIpList( TRUE, pInfoConfig->GrantIPList, &acCheck ) &&
                 FillAddrCheckFromIpList( FALSE, pInfoConfig->DenyIPList, &acCheck ) )
            {
                if ( !mb.SetData( IIS_MD_INSTANCE_ROOT,
                                  MD_IP_SEC,
                                  IIS_MD_UT_FILE,
                                  BINARY_METADATA,
                                  (acCheck.GetStorage()->GetAlloc()
                                         ? acCheck.GetStorage()->GetAlloc() : (LPBYTE)""),
                                  acCheck.GetStorage()->GetUsed(),
                                  METADATA_INHERIT | METADATA_REFERENCE ))
                {
                    err = GetLastError();
                }
            }

            acCheck.UnbindCheckList();
        }
        else
        {
            if ( !mb.DeleteData( IIS_MD_INSTANCE_ROOT,
                                 MD_IP_SEC,
                                 IIS_MD_UT_FILE,
                                 BINARY_METADATA ) )
            {
                // not an error : property may not exists
                //err = GetLastError();
            }
        }
    }

    DBG_REQUIRE( mb.Close() );

    if ( (err == NO_ERROR) &&
        IsFieldSet( fcConfig, FC_INET_INFO_LOG_CONFIG) &&
        (pInfoConfig->lpLogConfig != NULL) ) {

        err = SetInetLogConfiguration(&m_Logging,
                                      m_Service->QueryEventLog(),
                                      pInfoConfig->lpLogConfig);

        if ( err != NO_ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "SetConfiguration() SetInetLogConfig() failed. "
                       " Err=%u\n",
                       err));
        }
    }

    if ( (err == NO_ERROR) &&
        IsFieldSet( fcConfig, FC_INET_INFO_VIRTUAL_ROOTS )) {

        if ( QueryInstanceId() != INET_INSTANCE_ROOT ) {

            if ( !TsSetVirtualRoots(  pInfoConfig
                                     )) {

                err = GetLastError();
                DBGPRINTF(( DBG_CONTEXT,
                           "[SetConfiguration()]SetVirtualRoots "
                           " returns error %d\n",
                            err));
            }
        }
    }

    if ( err != NO_ERROR ) {

        IF_DEBUG( ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "IIS_SERVER_INSTANCE::SetCommonConfig ==> Error = %u\n",
                       err));
        }

        SetLastError( err );
        return(FALSE);
    }

    return TRUE;

} // IIS_SERVER_INSTANCE::SetCommonConfig


VOID
IIS_SERVER_INSTANCE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this service.

  Arguments:
    pcoChangeList - path and id that has changed

--*/
{
    DWORD i;
    DWORD status = NO_ERROR;
    BOOL  fVRUpdated = FALSE;
    BOOL  fReadCommon = FALSE;
    BOOL  fShouldMirror = FALSE;
    HRESULT hr;
    BOOL   fShouldCoUninitialize = FALSE;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( SUCCEEDED(hr) ) {
        fShouldCoUninitialize = TRUE;
    }
    else if (hr != E_INVALIDARG &&
             hr != RPC_E_CHANGED_MODE) {

        //
        // E_INVALIDARG and RPC_E_CHANGED_MODE could mean com was already
        // initialized with different parameters, so ignore it but don't
        // Uninit. Assert on other errors.
        //

        DBGPRINTF((DBG_CONTEXT,"CoInitializeEx failed with %x\n",hr));
        DBG_ASSERT(FALSE);
    }

    if ( (pcoChangeList->dwMDChangeType &
                (MD_CHANGE_TYPE_DELETE_OBJECT |
                 MD_CHANGE_TYPE_RENAME_OBJECT |
                 MD_CHANGE_TYPE_ADD_OBJECT) ) != 0 )
    {

        //
        // Something got added/deleted/renamed
        //

        fShouldMirror = TRUE;
    }

    LockThisForWrite();
    for ( i = 0; i < pcoChangeList->dwMDNumDataIDs; i++ )
    {
        m_Logging.NotifyChange( pcoChangeList->pdwMDDataIDs[i] );
        
        switch ( pcoChangeList->pdwMDDataIDs[i] )
        {
        case MD_SERVER_BINDINGS:
            if( QueryServerState() != MD_SERVER_STATE_STOPPED ) {
                status = UpdateNormalBindings();
                if( status != NO_ERROR ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: UpdateNormalBindings() failed,error %lu\n",
                        status
                        ));
                }
                SetWin32Error( status );
            }
            break;

        case MD_SECURE_BINDINGS:
            if( QueryServerState() != MD_SERVER_STATE_STOPPED ) {
                status = UpdateSecureBindings();
                if( status != NO_ERROR ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: UpdateSecureBindings() failed,error %lu\n",
                        status
                        ));
                }
                SetWin32Error( status );
            }
            break;

        case MD_DISABLE_SOCKET_POOLING:
            if( QueryServerState() != MD_SERVER_STATE_STOPPED ) 
            {
                if (HasNormalBindings())
                {
                    status = RemoveNormalBindings();
                    
                    if (NO_ERROR == status)
                    {   
                        status = UpdateNormalBindings();

                        if( status != NO_ERROR ) {
                            DBGPRINTF((
                                DBG_CONTEXT,
                                "MDChangeNotify: UpdateNormalBindings() failed,error %lu\n",
                                status
                            ));
                        }
                    }
                    else
                    {
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "MDChangeNotify: RemoveNormalBindings() failed,error %lu\n",
                            status
                        ));
                    }
                } 
                
                if ( (status == NO_ERROR) && HasSecureBindings())
                {
                    status = RemoveSecureBindings();
                    
                    if (NO_ERROR == status)
                    {   
                        status = UpdateSecureBindings();

                        if( status != NO_ERROR ) {
                            DBGPRINTF((
                                DBG_CONTEXT,
                                "MDChangeNotify: UpdateSecureBindings() failed,error %lu\n",
                                status
                            ));
                        }
                    }
                    else
                    {
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "MDChangeNotify: RemoveSecureBindings() failed,error %lu\n",
                            status
                        ));
                    }
                }
                                
                SetWin32Error( status );
            }
            break;
            
        case MD_CLUSTER_ENABLED:
            status = PerformClusterModeChange();
            if( status != NO_ERROR ) {
                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: PerformClusterModeChange() failed, error %lu\n",
                        status
                        ));
                }
            }
            break;

        case MD_SERVER_COMMAND:

            //
            // If cluster mode is enabled command must be specified
            // using MD_CLUSTER_SERVER_COMMAND, so that ISM cannot set the server state :
            // State management is to be done by cluster code exclusively.
            //

            if ( IsClusterEnabled() )
            {
                break;
            }

        case MD_CLUSTER_SERVER_COMMAND:
            status = PerformStateChange();
            if( status != NO_ERROR ) {
                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: ProcessStateChange() failed, error %lu\n",
                        status
                        ));
                }
            }

            //
            // if command started server then need to reload virtual roots
            // as failing-over may have enabled new file system resources
            //

            if ( QueryServerState() != MD_SERVER_STATE_STARTED )
            {
                break;
            }

            // fall-through 

        case MD_VR_PATH:
        case MD_VR_USERNAME:
        case MD_VR_PASSWORD:

            fShouldMirror = TRUE;
            if ( !fVRUpdated )
            {
                //
                //  Note individual root errors log an event
                //

                if ( !TsReadVirtualRoots(pcoChangeList) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "Error %d (0x%lx) reading virtual root info for %s\n",
                                GetLastError(), GetLastError(), pcoChangeList->pszMDPath ));
                }

                fVRUpdated = TRUE;
            }
            break;

        case MD_MAX_BANDWIDTH:
        {
            MB mb( (IMDCOM*) m_Service->QueryMDObject() );

            if ( mb.Open( QueryMDPath() ) )
            {
                if ( !SetBandwidthThrottle( &mb ) )
                {
                    DWORD dwError = GetLastError();

                    DBGPRINTF(( DBG_CONTEXT,
                                "MDChangeNotify: SetBandwidthThrottle failed, error %lu\n",
                                dwError ));

                    SetWin32Error( dwError );
                }
                DBG_REQUIRE( mb.Close() );
            }
            break;
        }

        case MD_MAX_BANDWIDTH_BLOCKED:
        {
            MB mb( (IMDCOM*) m_Service->QueryMDObject() );

            if ( mb.Open( QueryMDPath() ) )
            {
                if ( !SetBandwidthThrottleMaxBlocked( &mb ) )
                {
                    DWORD dwError = GetLastError();

                    DBGPRINTF(( DBG_CONTEXT,
                                "MDChangeNotify: SetBandwidthThrottle failed, error %lu\n",
                                dwError ));

                    SetWin32Error( dwError );
                }
                DBG_REQUIRE( mb.Close() );
            }
            break;
        }

        //
        //  Ignore state & status updates
        //

        case MD_SERVER_STATE:
        case MD_WIN32_ERROR:
            break;

        case MD_ACCESS_PERM:
            fShouldMirror = TRUE;
            break;

        case MD_LOG_TYPE:
        {
            DWORD   dwLogType;
            MB mb( (IMDCOM*) m_Service->QueryMDObject() );

            if ( mb.Open( QueryMDPath() ) &&
                 mb.GetDword("", MD_LOG_TYPE, IIS_MD_UT_SERVER, &dwLogType)
               )
            {
                m_fLoggingEnabled = (1 == dwLogType);
            }
            
            fReadCommon       = TRUE;
            break;
        }
        
        default:
            fReadCommon = TRUE;            
            break;
        }
    }

    if ( fReadCommon )
    {
        m_Logging.NotifyChange( 0 );
        RegReadCommonParams( TRUE, FALSE );
    }

    if ((MD_CHANGE_TYPE_DELETE_OBJECT == pcoChangeList->dwMDChangeType) &&
        (! _strnicmp( (LPCSTR) pcoChangeList->pszMDPath+QueryMDPathLen()+1, 
                      IIS_MD_INSTANCE_ROOT,
                      sizeof(IIS_MD_INSTANCE_ROOT)-1))
       )
    {
        if ( !TsReadVirtualRoots(pcoChangeList) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error %d (0x%lx) removing virtual root %s\n",
                         GetLastError(), GetLastError(), pcoChangeList->pszMDPath ));
        }
    }

    //
    // reflect the changes to the registry
    //

    if ( fShouldMirror && IsDownLevelInstance() )
    {
        MDMirrorVirtualRoots( );
    }

    UnlockThis();

    if ( fShouldCoUninitialize ) {
        CoUninitialize( );
    }

    return;

} // IIS_SERVER_INSTANCE::MDChangeNotify



VOID
IIS_SERVER_INSTANCE::MDMirrorVirtualRoots(
    VOID
    )
{
    DWORD err;
    HKEY hkey = NULL;

    //
    // Delete VR key
    //

    err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    m_Service->QueryRegParamKey(),
                    0,
                    KEY_ALL_ACCESS,
                    &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx for returned error %d\n",err ));
        return;
    }

    //
    //  First delete the key to remove any old values
    //

    err = RegDeleteKey( hkey, VIRTUAL_ROOTS_KEY_A );
    RegCloseKey(hkey);

    if ( err != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[MDMirrorVRoots] Unable to remove old values\n"));
        return;
    }

    //
    // Now recreate the keys
    //

    MoveMDVroots2Registry( );
    return;

} // IIS_SERVER_INSTANCE::MDMirrorVirtualRoots



DWORD
GetRPCLogConfiguration(IN LOGGING *pLogging,
                       OUT LPINET_LOG_CONFIGURATION * ppLogConfig)
/*++
  This function allocates space (using MIDL_ functions) and stores
  log configuration for the given log handle in it.

  Arguments:
    hInetLog     handle for InetLog object.
    ppLogConfig  pointer to INET_LOG_CONFIGURATION object which on return
                  contains valid log config informtion, on success.

  Returns:
    Win32 error code.
--*/
{
    DWORD  dwError = NO_ERROR;
    LPINET_LOG_CONFIGURATION pRpcConfig;
    WCHAR cBuffer[MAX_PATH];

    DBG_ASSERT( ppLogConfig != NULL);

    pRpcConfig = ((LPINET_LOG_CONFIGURATION )
                  MIDL_user_allocate( sizeof(INET_LOG_CONFIGURATION)));

    if ( pRpcConfig != NULL) {

        INETLOG_CONFIGURATIONA  ilogConfig;
        DWORD cbConfig = sizeof(ilogConfig);
        BOOL fReturn=TRUE;

        ZeroMemory( &ilogConfig, sizeof(ilogConfig ));
        pLogging->GetConfig( &ilogConfig );

        //
        // we got valid config. copy it into pRpcConfig.
        // since the enumerated values in inetlog.w are same in inetasrv.h
        //  we do no mapping, we directly copy values.

        ZeroMemory( pRpcConfig, sizeof( INET_LOG_CONFIGURATION));
        pRpcConfig->inetLogType = ilogConfig.inetLogType;

        switch ( ilogConfig.inetLogType) {

          case INET_LOG_TO_FILE:

            pRpcConfig->ilPeriod = ilogConfig.u.logFile.ilPeriod;
            pRpcConfig->cbSizeForTruncation =
              ilogConfig.u.logFile.cbSizeForTruncation;

             ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logFile.rgchLogFileDirectory, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchLogFileDirectory,
                MAX_PATH,
                cBuffer);

            *((DWORD *)&(pRpcConfig->rgchDataSource[MAX_PATH-sizeof(DWORD)]))=ilogConfig.u.logFile.ilFormat;
            *((DWORD *)&(pRpcConfig->rgchDataSource[MAX_PATH-2*sizeof(DWORD)]))=ilogConfig.u.logFile.dwFieldMask;

            break;

          case INET_LOG_TO_SQL:

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchDataSource, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchDataSource,
                MAX_PATH,
                cBuffer);

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchTableName, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchTableName,
                MAX_TABLE_NAME_LEN,
                cBuffer);

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchUserName, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchUserName,
                UNLEN,
                cBuffer);

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchPassword, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchPassword,
                PWLEN,
                cBuffer);
            break;


          case INET_LOG_DISABLED:
          default:
            // do nothing
            break;

        } // switch()
    } else {

        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppLogConfig = pRpcConfig;

    return (dwError);
} // GetRPCLogConfiguration()



DWORD
SetInetLogConfiguration(IN LOGGING       *pLogging,
                        IN EVENT_LOG *    pEventLog,
                        IN const INET_LOG_CONFIGURATION * pRpcLogConfig)
/*++
  This function modifies the logconfiguration associated with a given InetLog
  handle. It also updates the registry containing log configuration for service
  with which the inetlog handle is associated.

  Arguments:
     hInetLog        Handle to INETLOG object whose configuration needs to be
                      changed.
     pRpcLogConfig   new RPC log configuration


  Returns:
    Win32 Error code. NO_ERROR returned on success.

--*/
{
    DWORD dwError = NO_ERROR;
    INETLOG_CONFIGURATIONA  ilConfig;
    WCHAR cBuffer[MAX_PATH];

    //
    // initialize
    //

    ZeroMemory( &ilConfig, sizeof(INETLOG_CONFIGURATIONA));

    // Copy the RPC inet log configuration into local INETLOG_CONFIGURATIONW

    ilConfig.inetLogType = pRpcLogConfig->inetLogType;

    switch (ilConfig.inetLogType) {

      case INET_LOG_DISABLED:
            break;   // do nothing

      case INET_LOG_TO_FILE:

        CopyUnicodeStringToBuffer(cBuffer,
                                  MAX_PATH,
                                  pRpcLogConfig->rgchLogFileDirectory);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logFile.rgchLogFileDirectory,
                            MAX_PATH
                            );

        ilConfig.u.logFile.ilPeriod = pRpcLogConfig->ilPeriod;

        if ( ilConfig.u.logFile.ilPeriod > INET_LOG_PERIOD_MONTHLY ) {
            return (ERROR_INVALID_PARAMETER);
        }

        ilConfig.u.logFile.cbSizeForTruncation =
            pRpcLogConfig->cbSizeForTruncation;

        ilConfig.u.logFile.ilFormat =
            *((DWORD *)&(pRpcLogConfig->rgchDataSource[MAX_PATH-sizeof(DWORD)]));

        ilConfig.u.logFile.dwFieldMask =
            *((DWORD *)&(pRpcLogConfig->rgchDataSource[MAX_PATH-2*sizeof(DWORD)]));
        break;

      case INET_LOG_TO_SQL:

        CopyUnicodeStringToBuffer(cBuffer,
                                  MAX_PATH,
                                  pRpcLogConfig->rgchDataSource);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchDataSource,
                            MAX_PATH);

        CopyUnicodeStringToBuffer(cBuffer,
                                  MAX_TABLE_NAME_LEN,
                                  pRpcLogConfig->rgchTableName);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchTableName,
                            MAX_PATH);

        CopyUnicodeStringToBuffer(cBuffer,
                                  UNLEN,
                                  pRpcLogConfig->rgchUserName);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchUserName,
                            MAX_PATH);

        CopyUnicodeStringToBuffer(cBuffer,
                                  CNLEN,
                                  pRpcLogConfig->rgchPassword);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchPassword,
                            MAX_PATH);

        break;

      default:
        return (ERROR_INVALID_PARAMETER);
    } // switch()


    //
    // Now the ilConfig contains the local data related to configuration.
    //   call modify log config to modify dynamically the log handle.
    //

    pLogging->SetConfig( &ilConfig );
    return (dwError);

} // SetInetLogConfiguration()


BOOL
GenerateIpList(
    BOOL fIsGrant,
    ADDRESS_CHECK *pCheck,
    LPINET_INFO_IP_SEC_LIST *ppInfo
    )
/*++

Routine Description:

    generate an IP address list from an access check object

Arguments:

    fIsGrant - TRUE to access grant list, FALSE to access deny list
    pCheck - ptr to address check object to query from
    ppInfo - updated with ptr to IP list if success

Return:

    TRUE if success, otherwise FALSE

--*/
{
    UINT                        iM = pCheck->GetNbAddr( fIsGrant );
    LPINET_INFO_IP_SEC_LIST     pInfo;
    LPINET_INFO_IP_SEC_ENTRY    pI;
    UINT                        x;

    if ( iM == 0 )
    {
        *ppInfo = NULL;
        return TRUE;
    }

    if ( pInfo = (LPINET_INFO_IP_SEC_LIST)MIDL_user_allocate( sizeof(INET_INFO_IP_SEC_LIST) + iM * sizeof(INET_INFO_IP_SEC_ENTRY) ) )
    {
        pInfo->cEntries = 0;

        for ( x = 0, pI = pInfo->aIPSecEntry ;
              x < iM ;
              ++x )
        {
            LPBYTE pM;
            LPBYTE pA;
            DWORD dwF;

            if ( pCheck->GetAddr( fIsGrant, x, &dwF, &pM, &pA ) && dwF == AF_INET )
            {
                pI->dwMask = *(LPDWORD)pM;
                pI->dwNetwork = *(LPDWORD)pA;
                ++pI;
                ++pInfo->cEntries;
            }
        }

        *ppInfo = pInfo;

        return TRUE;
    }

    SetLastError( ERROR_NOT_ENOUGH_MEMORY );

    return FALSE;
}


BOOL
FillAddrCheckFromIpList(
    BOOL fIsGrant,
    LPINET_INFO_IP_SEC_LIST pInfo,
    ADDRESS_CHECK *pCheck
    )
/*++

Routine Description:

    Fill an access check object from an IP address list from

Arguments:

    fIsGrant - TRUE to access grant list, FALSE to access deny list
    pInfo - ptr to IP address list
    pCheck - ptr to address check object to update

Return:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    x;

    if ( pInfo )
    {
        for ( x = 0 ; x < pInfo->cEntries ; ++x )
        {
            if ( ! pCheck->AddAddr( fIsGrant,
                                    AF_INET,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwMask,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwNetwork ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL
GetVrootCount(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
/*++

Routine Description:

    Virtual directory enumerater callback that calculates the total required
    buffer size

Arguments:
    pvContext is a dword * that receives the count of virtual directories

Return:

    TRUE if success, otherwise FALSE

--*/
{
    *((DWORD *) pvContext) += 1;

    return TRUE;
}

BOOL
GetVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
/*++

Routine Description:

    Virtual directory enumerater callback that allocates and builds the
    virtual directory structure list

Arguments:
    pvContext is a pointer to the midl allocated memory

Return:

    TRUE if success, otherwise FALSE

--*/
{
    LPINET_INFO_VIRTUAL_ROOT_LIST  pvrl = (LPINET_INFO_VIRTUAL_ROOT_LIST) pvContext;
    DWORD                          i = pvrl->cEntries;
    LPINET_INFO_VIRTUAL_ROOT_ENTRY pvre = &pvrl->aVirtRootEntry[i];

    //
    //  Password doesn't go on the wire
    //

    DBG_ASSERT( pvr->pszAlias[0] == '/' );

    if ( !ConvertStringToRpc( &pvre->pszRoot,
                              pvr->pszAlias ) ||
         !ConvertStringToRpc( &pvre->pszDirectory,
                              pvr->pszPath ) ||
         !ConvertStringToRpc( &pvre->pszAddress,
                              "" ) ||
         !ConvertStringToRpc( &pvre->pszAccountName,
                              pvr->pszUserName ))
    {
        FreeRpcString( pvre->pszRoot );        pvre->pszRoot      = NULL;
        FreeRpcString( pvre->pszDirectory );   pvre->pszDirectory = NULL;
        FreeRpcString( pvre->pszAddress );     pvre->pszAddress   = NULL;
        FreeRpcString( pvre->pszAccountName ); pvre->pszAccountName = NULL;

        return FALSE;
    }

    pvre->dwMask = pvr->dwAccessPerm;

    pmb->GetDword( pvr->pszAlias,
                   MD_WIN32_ERROR,
                   IIS_MD_UT_SERVER,
                   &pvre->dwError );

    pvrl->cEntries++;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\htab\htab.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       htab.cxx

   Abstract:

       Module to test the hash table implementation

   Author:

       Murali R. Krishnan    ( MuraliK )     10-Oct-1996 

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include <windows.h>
# include "hashtab.hxx"
# include <stdio.h>
# include <stdlib.h>

# include "dbgutil.h"

# define MAX_POPULATION    ( 1000)
# define MAX_BUCKETS       ( 13)


/************************************************************
 *    Functions 
 ************************************************************/

class HTE_TEST: public HT_ELEMENT {

public:
    HTE_TEST( IN LPCSTR pszVal, IN DWORD id)
        : m_idVal ( 0),
          m_nRefs ( 1),
          HT_ELEMENT()
    { lstrcpynA( m_rgchVal, pszVal, sizeof(m_rgchVal)); }
    
    virtual ~HTE_TEST(VOID) {}

    virtual LPCSTR QueryKey(VOID) const { return ( m_rgchVal); }
    virtual LONG Reference( VOID)
    { return InterlockedIncrement( &m_nRefs); }
    virtual LONG Dereference( VOID)
    { return InterlockedDecrement( &m_nRefs); }
    virtual BOOL IsMatch( IN LPCSTR pszVal) const
    { return ( lstrcmpA( m_rgchVal, pszVal) == 0); }

    virtual VOID Print( VOID) const 
    { DBGPRINTF(( DBG_CONTEXT, 
                  " HTE_TEST(%08x): Refs = %d. Val = %ld. Id = %s.\n",
                  this, m_nRefs, m_idVal, m_rgchVal));
    }

private:
    CHAR   m_rgchVal[MAX_PATH];
    DWORD  m_idVal;
    LONG   m_nRefs;
                  
};



VOID 
PopulateHT( IN HASH_TABLE * pht, IN DWORD maxPop)
/*++
  This function creates a set of entries and popualates the hash table.

--*/
{
    CHAR rgchVal[20];
    HTE_TEST * phte;
    
    DBGPRINTF(( DBG_CONTEXT, " Populating the hash table(%08x, %d) ... \n",
                pht, maxPop));
    
    // create a new HTE_TEST object for each i and insert it
    for( DWORD i = 0; i < maxPop; i++) {

        if ( i % (maxPop / 10) == 0) { 
            DBGPRINTF(( DBG_CONTEXT, " Inserted %d objects\n", i));
        }

        wsprintfA( rgchVal, "%d", i);
        phte = new HTE_TEST( rgchVal, i);
        if ( NULL == phte) {

            DBGPRINTF(( DBG_CONTEXT, 
                        " %d: Null HTE_TEST object created. Exiting\n",
                        i));
            exit(1);
        }

        if ( !pht->Insert( phte)) {

            DBGPRINTF(( DBG_CONTEXT, 
                        " Failed to insert (%s, %d) into hash table"
                        " Error = %d\n",
                        rgchVal, i, GetLastError()));
            exit( 1);
        }
    } // for

    DBGPRINTF(( DBG_CONTEXT, " ---- Populated the hash table \n"));

    return;
} // PopulateHT()


VOID
DumpHT( IN HASH_TABLE * pht)
{
    DBGPRINTF(( DBG_CONTEXT, "\n\n Dumping the hash table %08x\n",
                pht));
    if ( NULL != pht) {
        pht->Print( 1);
    }

    return;
} // DumpHT()


VOID
LookupInHT( IN HASH_TABLE * pht, IN DWORD nIds, IN CHAR * rgchIds[])
{
    DBGPRINTF(( DBG_CONTEXT, 
                "\n\n Looking up %d identifiers in hash table %08x\n",
                nIds, pht));

    HTE_TEST * phte;

    for ( DWORD i = 0; i < nIds; i++) {
        
        phte = (HTE_TEST *) pht->Lookup( rgchIds[i]);
        
        DBGPRINTF(( DBG_CONTEXT, 
                    " Lookup(%s) returns %08x.\n",
                    rgchIds[i], phte));
        if ( phte != NULL) { 
            phte->Print();
            DerefAndKillElement( phte);
        }
        

    } // for

    return;
} // LookupInHT()


VOID
LookupAndDeleteInHT( IN HASH_TABLE * pht, IN DWORD nIds, IN CHAR * rgchIds[])
{
    DBGPRINTF(( DBG_CONTEXT, 
                "\n\n Lookup and Delete %d ids in hash table %08x\n",
                nIds, pht));

    HTE_TEST * phte;

    for ( DWORD i = 0; i < nIds; i++) {
        
        phte = (HTE_TEST *) pht->Lookup( rgchIds[i]);
        
        DBGPRINTF(( DBG_CONTEXT, 
                    " Lookup(%s) returns %08x.\n",
                    rgchIds[i], phte));
        if ( phte != NULL) { 

            DBG_REQUIRE( pht->Delete( phte));

            phte->Print();
            DerefAndKillElement( phte);
        }
    } // for

    return;
} // LookupAndDeleteInHT()


VOID
TestIterator( IN HASH_TABLE * pht)
{
    HT_ITERATOR hti;
    HT_ELEMENT * phte;

    DBG_ASSERT( NULL != pht);
    DWORD dwErr;
    
    dwErr = pht->InitializeIterator( &hti);
    
    if ( NO_ERROR == dwErr) {
        DWORD nElements = 0;
        DWORD nBucket = INFINITE;
        DWORD neb = 0;
        
        while ( (dwErr = pht->FindNextElement( &hti, &phte)) == NO_ERROR) {

            if ( nBucket != hti.nBucketNumber) {
                nBucket = hti.nBucketNumber;
                fprintf( stderr, "\n ----------\nBucket %d\n",
                         nBucket);
                nElements += neb;
                neb = 0;
            } else if ( (neb %4 ) == 0) {
                fprintf( stderr, "\n");
            }

            ++neb;
            fprintf( stderr, " %8d[%8s] ", (nElements + neb),
                     phte->QueryKey());
            
            // release the element before fetching next one
            phte->Dereference();
        } // while

        nElements += neb;
        fprintf( stderr, "\nTotal of %d elements found \n",
                 nElements);
    }

    pht->CloseIterator( &hti);
    return;
} // TestIterator()




HASH_TABLE * g_phtTest = NULL;

// IDs for lookup
CHAR * g_rgchIdList[] = {
    "1",
    "2",
    "3",
    "10",
    "11",
    "101",
    "102"
};

CHAR  g_rgchUsage[] = 
" Usage:  %s   [-p MaxPopulation] [-n NumBuckets]\n"
"    -p MaxPopulation  - number of elements to populate the hash table with\n"
"                        (default: %d)\n"
"    -n NumBuckets     - number of buckets in the hash table\n"
"                        (default: %d)\n"
"\n"
;

# define NUM_IDS_IN_LIST  ( sizeof( g_rgchIdList) / sizeof( g_rgchIdList[0]))

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();    



VOID PrintUsage( char * pszProgram) 
{
    fprintf( stderr, g_rgchUsage, pszProgram,
             MAX_POPULATION, MAX_BUCKETS);
    return;
} // PrintUsage()


int __cdecl
main(int argc, char * argv[])
{
    IN DWORD maxPop = MAX_POPULATION;
    IN DWORD nBuckets = MAX_BUCKETS;

    CREATE_DEBUG_PRINT_OBJECT( argv[0]);

    // process the command line arguments
    for ( int i = 1; i < argc; i++) {
        
        if ( '-' == *argv[i]) { 
            
            char * psz = (argv[i] + 1);
            while ( '\0' != *psz ) { 
                
                switch ( *psz++) { 
                    
                case 'h': case 'H': case '?': 
                    PrintUsage( argv[0]);
                    exit(1);
                    break;
                    
                case 'p': case 'P':
                    maxPop = atoi( argv[++i]);
                    break;
                    
                case 'n': case 'N':
                    nBuckets = atoi( argv[++i]);
                    break;
                    
                default:
                    break;
                } // switch()
            } // while
        } // args
    } // for 

    g_phtTest = new HASH_TABLE( nBuckets, "Test", 0);
    if ( g_phtTest == NULL) { 

        fprintf( stderr, " Unable to create global Hash table\n");
        exit (1);
    }


    PopulateHT( g_phtTest, maxPop);

    TestIterator( g_phtTest);

    LookupInHT( g_phtTest, NUM_IDS_IN_LIST, g_rgchIdList);

    LookupAndDeleteInHT( g_phtTest, NUM_IDS_IN_LIST, g_rgchIdList);

    DumpHT( g_phtTest);

    LookupInHT( g_phtTest, NUM_IDS_IN_LIST, g_rgchIdList);

    // Delete the Hash table
    delete g_phtTest;

    DELETE_DEBUG_PRINT_OBJECT();

    return (1);
} // main()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\vroots.cxx ===
/*++
   Copyright    (c)    1994        Microsoft Corporation

   Module Name:
        vroots.cxx

   Abstract:

        This module contains the front end to the virtual roots interface



   Author:

        John Ludeman    (johnl)     16-Mar-1995

   Project:

          Internet Servers Common Server DLL

   Revisions:

--*/

//
//  Include Headers
//

#include <tcpdllp.hxx>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <inetinfo.h>
#include <imd.h>
#include <inetreg.h>
#include <mb.hxx>
#include <w3svc.h>
#if 1 // DBCS
#include <mbstring.h>
#endif
#include <initguid.h>
#include <iwamreg.h>


BOOL
RetrieveRootPassword(
    PCHAR   pszRoot,
    PCHAR   pszPassword,
    WCHAR * pszSecret
    );

DWORD
GetFileSystemType(
    IN  LPCSTR      pszRealPath,
    OUT LPDWORD     lpdwFileSystem
    );

VOID
LogRootAddFailure(
    IN PIIS_SERVER_INSTANCE psi,
    PCHAR           pszRoot,
    PCHAR           pszDirectory,
    DWORD           err,
    IN PCHAR        pszMetaPath,
    IN MB *         pmb
    );

BOOL
TsAddVrootsWithScmUpdate(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

BOOL
TsAddVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

HANDLE
VrootLogonUser(
    IN CHAR  * pszUser,
    IN CHAR  * pszPassword
    );

BOOL
CrackUserAndDomain(
    CHAR *   pszDomainAndUser,
    CHAR * * ppszUser,
    CHAR * * ppszDomain
    );

VOID
ClearSentinelEntry(
    IN MB * pMB
    );

VOID
RemoveUnmarkedRoots(
    IN MB * pMB
    );

BOOL
ReadVrootConfig(
    LPVOID          pvMB,
    LPSTR           szVRPath,
    LPSTR           szDirectory,
    DWORD           cbDirectory,
    LPSTR           szUser,
    DWORD           cbUser,
    LPSTR           szPassword,
    DWORD           cbPassword,
    DWORD           *pdwMask,
    BOOL            *pfDoCache
    );

DWORD
hextointW(
    WCHAR * pch
    );

DWORD
hextointA(
    CHAR * pch
    );

BOOL
IIS_SERVER_INSTANCE::TsReadVirtualRoots(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++
    Description:

        NT Version

        This function is overloaded. The behavaior keys on pcoChangeList 
        being NULL or not.

        If pcoChangeList is NULL (default value), it reads the metabase 
        key pointed at by pmb and adds each root item.

        If pcoChangeList is not NULL then it only reads the necessary values.

    Arguments:

        pcoChangeList : pointer to metabase changes.

    Note:
        Failure to add a virtual root is not fatal.  An appropriate event
        will be logged listing the error and root.

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL    fRet;
    MB      mb( (IMDCOM*) m_Service->QueryMDObject() );

    //
    // Unfortunately rename doesn't give us the name of the old object.
    // So treat it as default processing
    //
    
    if ((NULL == pcoChangeList) ||
        (MD_CHANGE_TYPE_RENAME_OBJECT == pcoChangeList->dwMDChangeType)) 
    {
        //
        // Default processing. Remove & Re-Read all VRoots. Expensive.
        //
        
        if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
        {
            return FALSE;
        }

        //
        //  Remove all of the old roots for this server
        //

        fRet = QueryVrootTable()->RemoveVirtualRoots();

        if ( fRet )
        {
            QueryVrootTable()->LockExclusive();
            if (NULL == pcoChangeList)
            {
                fRet = TsEnumVirtualRoots( TsAddVrootsWithScmUpdate, this, &mb );
            }
            else
            {
                fRet = TsEnumVirtualRoots( TsAddVroots, this, &mb );
            }
            QueryVrootTable()->Unlock();            
        }
    }
    else
    {
        VIRTUAL_ROOT    vr;
    
        CHAR            szUser[UNLEN+1];
        CHAR            szPassword[PWLEN+1];
        CHAR            szDirectory[MAX_PATH + UNLEN + 3];
        DWORD           dwMask;
        BOOL            fDoCache;

        if (MD_CHANGE_TYPE_DELETE_OBJECT == pcoChangeList->dwMDChangeType)
        {
            return QueryVrootTable()->RemoveVirtualRoot(
                                        (LPSTR)pcoChangeList->pszMDPath + QueryMDPathLen() 
                                        + sizeof(IIS_MD_INSTANCE_ROOT)
                                      );
        }

        if ( !mb.Open( (LPCSTR)pcoChangeList->pszMDPath,
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
        {
            return FALSE;
        }

        if (!ReadVrootConfig( &mb, 
                              "",
                              szDirectory,
                              sizeof(szDirectory),
                              szUser, 
                              sizeof(szUser),
                              szPassword,
                              sizeof(szPassword),
                              &dwMask,
                              &fDoCache
                              ))
        {
            return FALSE;
        }

        vr.pszAlias     = (LPSTR)pcoChangeList->pszMDPath + QueryMDPathLen() 
                            + sizeof(IIS_MD_INSTANCE_ROOT);
        vr.pszMetaPath  = "";
        vr.pszPath      = szDirectory;
        vr.dwAccessPerm = dwMask;
        vr.pszUserName  = szUser;
        vr.pszPassword  = szPassword;
        vr.fDoCache     = fDoCache;

        if (pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT)
        {
            fRet = TsAddVroots(this, &mb, &vr);
        }
        else
        {
            //
            // Remove the original entry & re-read
            //

            if (!QueryVrootTable()->RemoveVirtualRoot(vr.pszAlias))
            {
                DBGPRINTF((DBG_CONTEXT,"Error %x removing vroot %s. \n",
                          GetLastError(), vr.pszMetaPath ));
            }

            fRet = TsAddVroots(this, &mb, &vr);
        }
    }
    
    return fRet;
    
}   // TsReadVirtualRoots



BOOL
TsAddVrootsWithScmUpdate(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
{
    ((IIS_SERVER_INSTANCE *) pvContext)->m_Service->StartUpIndicateClientActivity();
    return TsAddVroots(pvContext,pmb,pvr);
}



BOOL
TsAddVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
{
    DWORD           err = NO_ERROR;
    DWORD           dwFileSystem;
    BOOL            fRet = FALSE;
    HANDLE          hToken = NULL;



    //
    //  Clear this virtual directory's error status
    //

    if ( !pmb->SetDword( pvr->pszMetaPath,
                         MD_WIN32_ERROR,
                         IIS_MD_UT_SERVER,
                         NO_ERROR ))
    {
        DBGPRINTF((DBG_CONTEXT,"Error %x setting win32 status from %s. \n",
                  GetLastError(), pvr->pszMetaPath ));
        return FALSE;
    }

#if 0
    if ( (pvr->pszUserName[0] != '\0') &&
         (pvr->pszPath[0] == '\\') && (pvr->pszPath[1] == '\\') ) {

        NETRESOURCE nr;
        nr.dwScope = RESOURCE_CONNECTED;
        nr.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        nr.dwType = RESOURCETYPE_DISK;
        nr.lpLocalName = NULL;
        nr.lpRemoteName = pvr->pszPath;
        nr.lpComment = "";
        nr.lpProvider = NULL;

        //
        // try disconnecting from the distant resource 1st
        // (in case credentials have changed )
        //

        WNetCancelConnection2( pvr->pszPath, 0, TRUE );

        //
        // Connect to distant disk using specified account
        //

        if ( err = WNetAddConnection2( &nr,
                                       pvr->pszPassword,
                                       pvr->pszUserName,
                                       0 ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "Adding path %s err %d, user=%s, pwd=%d\n",
                    pvr->pszPath, err, pvr->pszUserName, pvr->pszPassword ));

            //
            //  Log error
            //

            LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                               pvr->pszAlias,
                               pvr->pszPath,
                               err,
                               pvr->pszMetaPath,
                               pmb );
        }
    }

#else

    if ( (pvr->pszUserName[0] != '\0') &&
         (pvr->pszPath[0] == '\\') && (pvr->pszPath[1] == '\\') )
        {
                if ( g_fW3OnlyNoAuth )
                {
                    hToken = NULL;
                }
                else
                {
                    hToken = VrootLogonUser( pvr->pszUserName,
                                             pvr->pszPassword );

                    if ( hToken == NULL)
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "Adding path %s err %d, user=%s, pwd=%d\n",
                                    pvr->pszPath, GetLastError(), pvr->pszUserName, pvr->pszPassword ));

                        //
                        //  Log error
                        //

                        LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                                                           pvr->pszAlias,
                                                           pvr->pszPath,
                                                           GetLastError(),
                                                           pvr->pszMetaPath,
                                                           pmb );
                    }


                    // Impersonate as user for GetFileSystemType()
                    if ( hToken != NULL && !ImpersonateLoggedOnUser(hToken))
                    {
                       err = GetLastError();
                    }
                }
        }

#endif

    if ( err == NO_ERROR )
    {

        err = GetFileSystemType( pvr->pszPath, &dwFileSystem);

        if ( err != NO_ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                        " GetFileSystemType(%s) failed.Error = %u.\n",
                        pvr->pszPath,
                        err));

            LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                               pvr->pszAlias,
                               pvr->pszPath,
                               err,
                               pvr->pszMetaPath,
                               pmb );
        }
    }

    //
    //  Don't add roots that are invalid
    //

    if ( err == NO_ERROR )
    {
        if ( !((IIS_SERVER_INSTANCE *) pvContext)->QueryVrootTable()->AddVirtualRoot(
                                    pvr->pszAlias,
                                    pvr->pszPath,
                                    pvr->dwAccessPerm,
                                    pvr->pszUserName,
                                    hToken,
                                    dwFileSystem,
                                    pvr->fDoCache ))
        {
            err = GetLastError();

            DBGPRINTF(( DBG_CONTEXT,
                        " AddVirtualRoot() failed. Error = %u.\n", err));

            LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                               pvr->pszAlias,
                               pvr->pszPath,
                               err,
                               pvr->pszMetaPath,
                               pmb );
        }
    }

    if ( hToken != NULL)
    {
        RevertToSelf();
    }

    if ( err == NO_ERROR )
    {
        fRet = TRUE;
    }

    return fRet;

} // TsAddVroots


BOOL
IIS_SERVER_INSTANCE::TsEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext,
    MB *        pmbWebSite
    )
{
    return TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    IIS_MD_INSTANCE_ROOT "/",
                    m_dwLevelsToScan,
                    (LPVOID)pmbWebSite,
                    TRUE );
}


BOOL
IIS_SERVER_INSTANCE::TsRecursiveEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext,
    LPSTR       pszCurrentPath,
    DWORD       dwLevelsToScan,
    LPVOID      pvMB,
    BOOL        fGetRoot
    )
/*++
    Description:

        Enumerates all of the virtual directories defined for this server
        instance

    Arguments:
        pfnCallback - Enumeration callback to call for each virtual directory
        pvContext - Context pfnCallback receives
        pszCurrentPath - path where to start scanning for VRoots
        dwLevelsToScan - # of levels to scan recursively for vroots
        pvMB - ptr to MB to access metabase. Is LPVOID to avoid having to include
               mb.hxx before any ref to iistypes.hxx
        fGetRoot - TRUE if pszCurrentPath is to be considered as vroot to process

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    DWORD           err;
    MB*             pMB = (MB*)pvMB;

    DWORD           cb;

    CHAR            nameBuf[METADATA_MAX_NAME_LEN+2];
    CHAR            tmpBuf[sizeof(nameBuf)];

    DWORD           cbCurrentPath;
    DWORD           i = 0;

    VIRTUAL_ROOT    vr;
    
    CHAR            szUser[UNLEN+1];
    CHAR            szPassword[PWLEN+1];
    CHAR            szDirectory[MAX_PATH + UNLEN + 3];
    DWORD           dwMask;
    BOOL            fDoCache;

    //
    //  Enumerate all of the listed items in the metabase
    //  and add them
    //

    cbCurrentPath = strlen( pszCurrentPath );
    CopyMemory( nameBuf, pszCurrentPath, cbCurrentPath + 1);

    while ( TRUE ) {

        METADATA_RECORD mdRecord;
        DWORD  dwFileSystem = FS_ERROR;

        err = NO_ERROR;

        if ( fGetRoot ) {

            fGetRoot = FALSE;

        } else {

            if ( !pMB->EnumObjects( pszCurrentPath,
                                  nameBuf + cbCurrentPath,
                                  i++ ))
            {
                break;
            }

            if ( dwLevelsToScan > 1 )
            {
                cb = strlen( nameBuf );
                nameBuf[ cb ] = '/';
                nameBuf[ cb + 1 ] = '\0';

                if ( !TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    nameBuf,
                    dwLevelsToScan - 1,
                    pMB,
                    FALSE ) )
                {
                    return FALSE;
                }

                nameBuf[ cb ] = '\0';
            }
        }

        if (!ReadVrootConfig( pvMB, 
                              nameBuf,
                              szDirectory,
                              sizeof(szDirectory),
                              szUser, 
                              sizeof(szUser),
                              szPassword,
                              sizeof(szPassword),
                              &dwMask,
                              &fDoCache
                              ))
        {
            continue;
        }

        //
        //  Now set things up for the callback
        //

        DBG_ASSERT( !_strnicmp( nameBuf, IIS_MD_INSTANCE_ROOT, sizeof(IIS_MD_INSTANCE_ROOT) - 1));

        //
        //  Add can modify the root - don't modify the working vroot path
        //

        strcpy( tmpBuf, nameBuf );

        vr.pszAlias     = tmpBuf + sizeof(IIS_MD_INSTANCE_ROOT) - 1;
        vr.pszMetaPath  = tmpBuf;
        vr.pszPath      = szDirectory;
        vr.dwAccessPerm = dwMask;
        vr.pszUserName  = szUser;
        vr.pszPassword  = szPassword;
        vr.fDoCache     = fDoCache;
        
        if ( !pfnCallback( pvContext, pMB, &vr ))
        {
            //
            // !!! so what do we do here?
            //

            DBGPRINTF((DBG_CONTEXT,"EnumCallback returns FALSE\n"));
        }

    } // while

    return TRUE;

} // Enum



VOID
LogRootAddFailure(
    IN PIIS_SERVER_INSTANCE psi,
    IN PCHAR        pszRoot,
    IN PCHAR        pszDirectory,
    IN DWORD        err,
    IN PCHAR        pszMetaPath,
    IN MB *         pmb
    )
{
    const CHAR *    apsz[3];
    STR             strError;

    psi->LoadStr( strError, err, FALSE );  // loads ANSI message. Convert to UNICODE

    apsz[0] = pszRoot;
    apsz[1] = pszDirectory;
    apsz[2] = strError.QueryStrA();

    psi->m_Service->LogEvent( INET_SVC_ADD_VIRTUAL_ROOT_FAILED,
                              3,
                              apsz,
                              err );

    //
    //  Indicate the error on this virtual directory
    //

    if ( !pmb->SetDword( pszMetaPath,
                         MD_WIN32_ERROR,
                         IIS_MD_UT_SERVER,
                         err ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LogRootAddFailure: Unable to set win32 status\n" ));
    }
} // LogRootAddFailure


BOOL
RetrieveRootPassword(
    PCHAR   pszRoot,
    PCHAR   pszPassword,
    PWCHAR  pszSecret
    )
/*++
    Description:

        This function retrieves the password for the specified root & address

    Arguments:

        pszRoot - Name of root + address in the form "/root,<address>".
        pszPassword - Receives password, must be at least PWLEN+1 characters
        pszSecret - Virtual Root password secret name

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BUFFER  bufSecret;
    WCHAR * psz;
    WCHAR * pszTerm;
    WCHAR * pszNextLine;
    WCHAR   wsRoot[MAX_PATH+1];

    DWORD   cch;

    if ( !TsGetSecretW( pszSecret,
                        &bufSecret ))
    {
        return FALSE;
    }

    //
    // Convert root to WCHAR
    //

    cch = MultiByteToWideChar( CP_ACP,
                               MB_PRECOMPOSED,
                               pszRoot,
                               -1,
                               wsRoot,
                               MAX_PATH+1 );

    wsRoot[cch] = L'\0';
    if ( cch == 0 ) {
        return FALSE;
    }

    psz = (WCHAR *) bufSecret.QueryPtr();

    //
    //  Scan the list of roots looking for a match.  The list looks like:
    //
    //     <root>,<address>=<password>\0
    //     <root>,<address>=<password>\0
    //     \0
    //

    while ( *psz )
    {
        PWCHAR pszComma;

        pszNextLine = psz + wcslen(psz) + 1;

        pszTerm = wcschr( psz, L'=' );

        if ( !pszTerm )
            goto NextLine;

        *pszTerm = L'\0';

        //
        // remove the ,
        //

        pszComma = wcschr( psz, L',' );
        if ( pszComma != NULL ) {
            *pszComma = '\0';
        }

        if ( !_wcsicmp( wsRoot, psz ) )
        {

            //
            //  We found a match, copy the password
            //

            (VOID) ConvertUnicodeToAnsi(
                               pszTerm + 1,
                               pszPassword,
                               PWLEN + sizeof(CHAR));

            return TRUE;
        }

NextLine:
        psz = pszNextLine;
    }

    //
    //  If the matching root wasn't found, default to the empty password
    //

    *pszPassword = '\0';
    return TRUE;

} // RetrieveRootPassword



BOOL
IIS_SERVER_INSTANCE::TsSetVirtualRoots(
    IN LPINETA_CONFIG_INFO  pConfig
    )
/*++
    Description:

        Writes the virtual roots specified in the config structure to the
        registry

        NOTE: This is basically legacy code for the IIS 3.0 RPC interface.

    Arguments:
        pConfig - new list of virtual

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    DWORD               err;
    DWORD               dwDummy;
    LPINET_INFO_VIRTUAL_ROOT_LIST pRootsList;
    DWORD               cch;
    DWORD               i;
    DWORD               dwMask;
    DWORD               sentinelValue = 7777777;
    IWamAdmin*          pIWamAdmin = NULL;
    MB                  mb( (IMDCOM*) m_Service->QueryMDObject()  );
    HRESULT             hr = NOERROR;
    STR                 strTmp;

    //
    // Do the metabase
    //

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Setting VR data on %s\n",
                  QueryMDPath()));
    }

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Open MD instance root %s returns %d\n",
                      QueryMDPath(), GetLastError() ));
        }
        return FALSE;
    }

    //
    //  We need to create an application for each new virtual root set via
    //  the IIS 3.0 RPC interface for ASP compatability
    //

    hr = CoCreateInstance(CLSID_WamAdmin,
                          NULL,
                          CLSCTX_SERVER,
                          IID_IWamAdmin,
                          (void **)&pIWamAdmin);

    if ( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create WamAdmin interface, error %08lx\n",
                    hr ));

        SetLastError( hr );
        return FALSE;
    }

    //
    // See if we need to delete any VRs
    //

    pRootsList = pConfig->VirtualRoots;

    if ( (pRootsList == NULL) || (pRootsList->cEntries == 0) ) {

        //
        // NO VRs.  Delete the entire VR tree
        //

        if ( !mb.DeleteObject( IIS_MD_INSTANCE_ROOT ) )
        {
            IF_DEBUG(METABASE) {
                DBGPRINTF((DBG_CONTEXT,
                          "Deleting VR root returns %d\n",GetLastError()));
            }
        }

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Empty list set on %s\n", QueryMDPath()));
        }

        goto exit;

    } else {

        //
        // Remove our secret value
        //

        ClearSentinelEntry( &mb );
    }

    for ( i = 0; i < pRootsList->cEntries; i++ ) {

        CHAR tmpRoot[MAX_PATH+1];
        CHAR tmpBuffer[MAX_PATH+1];
        BOOL fCreateApp = FALSE;

        DWORD rootLen;

        //
        // strings to ANSI
        //

#define VROOT_ROOT       IIS_MD_INSTANCE_ROOT
#define CCH_VROOT_ROOT   (sizeof(VROOT_ROOT) - 1)

        strcpy( tmpRoot, VROOT_ROOT );

        (VOID) ConvertUnicodeToAnsi(
                           pRootsList->aVirtRootEntry[i].pszRoot,
                           &tmpRoot[CCH_VROOT_ROOT],
                           MAX_PATH);

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Setting data for root %s\n",tmpRoot));
        }

        rootLen = strlen(tmpRoot);

        //
        // Create the root
        //

        if ( !mb.AddObject( tmpRoot ) &&
             (GetLastError() != ERROR_ALREADY_EXISTS) )
        {

            DBGPRINTF((DBG_CONTEXT,"AddMetaObject %s failed with %d\n",
                          tmpRoot, GetLastError() ));
            goto exit;
        }

        //
        // Set sentinel entry
        //

        if ( !mb.SetDword( tmpRoot,
                           MD_VR_UPDATE,
                           IIS_MD_UT_FILE,
                           sentinelValue,
                           0 ))
        {
            DBGPRINTF((DBG_CONTEXT,
                "Error %d setting sentinel value %x for %s\n",
                GetLastError(), sentinelValue, tmpRoot));

            goto exit;
        }

        //
        // Set Path
        //

        (VOID) ConvertUnicodeToAnsi(
                        pRootsList->aVirtRootEntry[i].pszDirectory,
                        tmpBuffer,
                        MAX_PATH+1);

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Directory path is %s\n",tmpBuffer));
        }

        //
        //  Check to see if the path property already exists - if it does
        //  then we won't create the application - only new virtual directories
        //  get an application created for them
        //

        if ( !mb.GetStr( tmpRoot,
                         MD_VR_PATH,
                         IIS_MD_UT_FILE,
                         &strTmp,
                         METADATA_NO_ATTRIBUTES ))
        {
            fCreateApp = TRUE;
        }

        if ( !mb.SetString( tmpRoot,
                            MD_VR_PATH,
                            IIS_MD_UT_FILE,
                            tmpBuffer ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting path[%s] for %s\n",
                      GetLastError(), tmpBuffer, tmpRoot));
        }

        if ( !mb.SetString( tmpRoot,
                            MD_KEY_TYPE,
                            IIS_MD_UT_SERVER,
                           "IIsWebVirtualDir" ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting ADSI type for %s\n",
                      GetLastError(), tmpRoot));
        }


        //
        // Set Username
        //

        (VOID) ConvertUnicodeToAnsi(
                           pRootsList->aVirtRootEntry[i].pszAccountName,
                           tmpBuffer,
                           MAX_PATH+1);

        if ( !mb.SetString( tmpRoot,
                            MD_VR_USERNAME,
                            IIS_MD_UT_FILE,
                            tmpBuffer ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting username for %s\n",
                      GetLastError(), tmpRoot));
        }

        //
        // Set Mask
        //

        if ( !mb.SetDword( tmpRoot,
                           MD_ACCESS_PERM,
                           IIS_MD_UT_FILE,
                           pRootsList->aVirtRootEntry[i].dwMask ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting mask for %s\n",
                      GetLastError(), tmpRoot));
        }

        if ( fCreateApp )
        {
            WCHAR wchFullPath[MAX_PATH];

            strcpy( tmpRoot, QueryMDPath() );
            strcat( tmpRoot, "/" VROOT_ROOT );

            if ( MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      tmpRoot,
                                      -1,
                                      wchFullPath,
                                      sizeof( wchFullPath ) / sizeof(WCHAR) ))
            {
                wcscat( wchFullPath, pRootsList->aVirtRootEntry[i].pszRoot );

                DBGPRINTF(( DBG_CONTEXT,
                            "Creating application at %S\n",
                            wchFullPath ));

                //
                //  We need to close our metabase handle so WAM can create
                //  the in process application
                //

                DBG_REQUIRE( mb.Close() );

                hr = pIWamAdmin->AppCreate( wchFullPath, TRUE);

                if ( FAILED( hr ))
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "Failed to create application, error %08lx\n",
                                hr ));
                }

                //
                //  Reopen the metabase for the next vroot
                //

                if ( !mb.Open( QueryMDPath(),
                               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
                {
                    IF_DEBUG(METABASE) {
                        DBGPRINTF((DBG_CONTEXT,"Open MD instance root %s returns %d\n",
                                  QueryMDPath(), GetLastError() ));
                    }
                    
                    goto exit;
                }

            }
        }
    }

    //
    // Delete entries that do not have the sentinel entry
    //

    RemoveUnmarkedRoots( &mb );

exit:

    //
    // If this is the downlevel instance, mirror it to the registry
    //

    if ( IsDownLevelInstance() ) {
        TsMirrorVirtualRoots( pConfig );
    }

    if ( pIWamAdmin ) {
        pIWamAdmin->Release();
    }

    return TRUE;

} // IIS_SERVER_INSTANCE::TsSetVirtualRoots


DWORD
GetFileSystemType(
    IN  LPCSTR      pszRealPath,
    OUT LPDWORD     lpdwFileSystem
    )
/*++
    Gets file system specific information for a given path.
    It uses GetVolumeInfomration() to query the file system type
       and file system flags.
    On success the flags and file system type are returned in
       passed in pointers.

    Arguments:

        pszRealPath    pointer to buffer containing path for which
                         we are inquiring the file system details.

        lpdwFileSystem
            pointer to buffer to fill in the type of file system.

    Returns:
        NO_ERROR  on success and Win32 error code if any error.

--*/
{
# define MAX_FILE_SYSTEM_NAME_SIZE    ( MAX_PATH)

    CHAR    rgchBuf[MAX_FILE_SYSTEM_NAME_SIZE];
    CHAR    rgchRoot[MAX_FILE_SYSTEM_NAME_SIZE];
    int     i;
    DWORD   dwReturn = ERROR_PATH_NOT_FOUND;
    DWORD   len;

    if ( (pszRealPath == NULL) || (lpdwFileSystem == NULL)) {
        return ( ERROR_INVALID_PARAMETER);
    }

    ZeroMemory( rgchRoot, sizeof(rgchRoot) );
    *lpdwFileSystem = FS_ERROR;

    //
    // Copy just the root directory to rgchRoot for querying
    //

    IF_DEBUG( DLL_VIRTUAL_ROOTS) {
        DBGPRINTF( ( DBG_CONTEXT, " GetFileSystemType(%s).\n", pszRealPath));
    }

    if ( (pszRealPath[0] == '\\') &&
         (pszRealPath[1] == '\\')) {

        PCHAR pszEnd;

        //
        // this is an UNC name. Extract just the first two components
        //
        //

        pszEnd = strchr( pszRealPath+2, '\\');

        if ( pszEnd == NULL) {

            // just the server name present

            return ( ERROR_INVALID_PARAMETER);
        }

#if 1 // DBCS enabling for share name
        pszEnd = (PCHAR)_mbschr( (PUCHAR)pszEnd+1, '\\');
#else
        pszEnd = strchr( pszEnd+1, '\\');
#endif

        len = ( ( pszEnd == NULL) ? strlen(pszRealPath)
               : (DIFF(pszEnd - pszRealPath) + 1) );

        //
        // Copy till the end of UNC Name only (exclude all other path info)
        //

        if ( len < (MAX_FILE_SYSTEM_NAME_SIZE - 1) ) {

            CopyMemory( rgchRoot, pszRealPath, len);
            rgchRoot[len] = '\0';
        } else {

            return ( ERROR_INVALID_NAME);
        }

#if 1 // DBCS enabling for share name
        if ( *CharPrev( rgchRoot, rgchRoot + len ) != '\\' ) {
#else
        if ( rgchRoot[len - 1] != '\\' ) {
#endif

            if ( len < MAX_FILE_SYSTEM_NAME_SIZE - 2 ) {
                rgchRoot[len]   = '\\';
                rgchRoot[len+1] = '\0';
            } else {

                return (ERROR_INVALID_NAME);
            }
        }
    } else {

        //
        // This is non UNC name.
        // Copy just the root directory to rgchRoot for querying
        //


        for( i = 0; i < 9 && pszRealPath[i] != '\0'; i++) {

            if ( (rgchRoot[i] = pszRealPath[i]) == ':') {

                break;
            }
        } // for


        if ( rgchRoot[i] != ':') {

            //
            // we could not find the root directory.
            //  return with error value
            //

            return ( ERROR_INVALID_PARAMETER);
        }

        rgchRoot[i+1] = '\\';     // terminate the drive spec with a slash
        rgchRoot[i+2] = '\0';     // terminate the drive spec with null char

    } // else

    IF_DEBUG( DLL_VIRTUAL_ROOTS) {
        DBGPRINTF( ( DBG_CONTEXT, " GetVolumeInformation(%s).\n",
                    rgchRoot));
    }

    //
    // The rgchRoot should end with a "\" (slash)
    // otherwise, the call will fail.
    //

    if (  GetVolumeInformation( rgchRoot,        // lpRootPathName
                                NULL,            // lpVolumeNameBuffer
                                0,               // len of volume name buffer
                                NULL,            // lpdwVolSerialNumber
                                NULL,            // lpdwMaxComponentLength
                                NULL,            // lpdwSystemFlags
                                rgchBuf,         // lpFileSystemNameBuff
                                sizeof(rgchBuf)
                                ) ) {



        dwReturn = NO_ERROR;

        if ( strcmp( rgchBuf, "FAT") == 0) {

            *lpdwFileSystem = FS_FAT;

        } else if ( strcmp( rgchBuf, "NTFS") == 0) {

            *lpdwFileSystem = FS_NTFS;

        } else if ( strcmp( rgchBuf, "HPFS") == 0) {

            *lpdwFileSystem = FS_HPFS;

        } else if ( strcmp( rgchBuf, "CDFS") == 0) {

            *lpdwFileSystem = FS_CDFS;

        } else if ( strcmp( rgchBuf, "OFS") == 0) {

            *lpdwFileSystem = FS_OFS;

        } else {

            *lpdwFileSystem = FS_FAT;
        }

    } else {

        dwReturn = GetLastError();

        IF_DEBUG( DLL_VIRTUAL_ROOTS) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " GetVolumeInformation( %s) failed with error %d\n",
                        rgchRoot, dwReturn));
        }

    }

    return ( dwReturn);
} // GetFileSystemType()


HANDLE
VrootLogonUser(
    IN CHAR  * pszUser,
    IN CHAR  * pszPassword
    )
/*++
  This function uses the given parameters and logs on to generate
   a user handle for the account.

  Arguments:
    pszUser - pointer to string containing the user name.
    pszPassword - pointer to string containing the password.

  Returns:
    Handle for the logged on user on success.
    Returns NULL for errors.

  History:
    MuraliK  18-Jan-1996  Created.
--*/
{
    CHAR        szDomainAndUser[IIS_DNLEN+UNLEN+2];
    CHAR   *    pszUserOnly;
    CHAR   *    pszDomain;
    HANDLE      hToken = NULL;
    BOOL        fReturn;

    //
    //  Validate parameters & state.
    //

    DBG_ASSERT( pszUser != NULL && *pszUser != '\0');
    DBG_ASSERT( strlen(pszUser) < sizeof(szDomainAndUser) );
    DBG_ASSERT( pszPassword != NULL);
    DBG_ASSERT( strlen(pszPassword) <= PWLEN );

    //
    //  Save a copy of the domain\user so we can squirrel around
    //  with it a bit.
    //

    strcpy( szDomainAndUser, pszUser );

    //
    //  Crack the name into domain/user components.
    //  Then try and logon as the specified user.
    //

    fReturn = ( CrackUserAndDomain( szDomainAndUser,
                                   &pszUserOnly,
                                   &pszDomain ) &&
               LogonUserA(pszUserOnly,
                          pszDomain,
                          pszPassword,
                          LOGON32_LOGON_INTERACTIVE, //LOGON32_LOGON_NETWORK,
                          LOGON32_PROVIDER_DEFAULT,
                          &hToken )
               );

    if ( !fReturn) {

        //
        //  Logon user failed.
        //

        IF_DEBUG( DLL_SECURITY) {

            DBGPRINTF(( DBG_CONTEXT,
                       " CrachUserAndDomain/LogonUser (%s) failed Error=%d\n",
                       pszUser, GetLastError()));
        }

        hToken = NULL;
    } else {
        HANDLE hImpersonation = NULL;

        // we need to obtain the impersonation token, the primary token cannot
        // be used for a lot of purposes :(
        if (!pfnDuplicateTokenEx( hToken,      // hSourceToken
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,  // Obtain impersonation
                               TokenImpersonation,
                               &hImpersonation)  // hDestinationToken
            ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "Creating ImpersonationToken failed. Error = %d\n",
                        GetLastError()
                        ));

            // cleanup and exit.
            hImpersonation = NULL;

            // Fall through for cleanup
        }

        //
        // close original token. If Duplicate was successful,
        //  we should have ref in the hImpersonation.
        // Send the impersonation token to the client.
        //
        CloseHandle( hToken);
        hToken = hImpersonation;
    }


    //
    //  Success!
    //

    return hToken;

} // VrootLogonUser()

DWORD
hextointW(
    WCHAR * pch
    )
{
    WCHAR * pchStart;
    DWORD sum = 0;
    DWORD mult = 1;

    while ( *pch == L' ' )
        pch++;

    pchStart = pch;

    while ( iswxdigit( *pch ) )
        pch++;

    while ( --pch >= pchStart )
    {
        sum += mult * ( *pch  >= L'A' ? *pch + 10 - L'A' :
                                       *pch - L'0' );
        mult *= 16;
    }

    return sum;
}



DWORD
hextointA(
    CHAR * pch
    )
{
    CHAR * pchStart;
    DWORD sum = 0;
    DWORD mult = 1;

    while ( *pch == ' ' )
        pch++;

    pchStart = pch;

    while ( isxdigit( (UCHAR)(*pch) ) )
        pch++;

    while ( --pch >= pchStart )
    {
        sum += mult * ( *pch  >= 'A' ? *pch + 10 - 'A' :
                                      *pch - '0' );
        mult *= 16;
    }

    return sum;

} // hextointA




BOOL
IIS_SERVER_INSTANCE::MoveVrootFromRegToMD(
    VOID
    )
{
    DBGPRINTF((DBG_CONTEXT,"MoveVrootFromRegToMD called!!!\n"));
    return(TRUE);

} // IIS_SERVER_INSTANCE::MoveVrootFromRegToMD


BOOL
TsCopyVrootToRegistry(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
{

    DWORD cch;
    DWORD err;
    HKEY hkey = (HKEY)pvContext;
    CHAR szValue[ MAX_PATH + UNLEN + 2 ];

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"CopyVrootToReg: Adding %s to registry\n",
            pvr->pszAlias));
    }

    cch = wsprintfA( szValue,
                     "%s,%s,%X",
                     pvr->pszPath,
                     pvr->pszUserName,
                     pvr->dwAccessPerm );

    DBG_ASSERT( cch < sizeof( szValue ) );

    err = WriteRegistryStringA(hkey,
                   pvr->pszAlias,
                   szValue,
                   strlen(szValue),
                   REG_SZ);

    DBG_ASSERT(err == NO_ERROR);

    return(TRUE);

} // TsCopyVrootToRegistry



BOOL
IIS_SERVER_INSTANCE::MoveMDVroots2Registry(
    VOID
    )
/*++

Routine Description:

    Moves MD VR entries to the registry if registry VR key
    does not exist at startup.

Arguments:

    None.

Return Value:

    None.

--*/
{

    HKEY hkey = NULL;
    HKEY hkeyRoots = NULL;
    DWORD dwDisp;
    DWORD err;
    BOOL  fMigrated = FALSE;

    MB mb( (IMDCOM*) m_Service->QueryMDObject()  );

    DBG_ASSERT(IsDownLevelInstance());

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Entering MoveMDToRegAtStartup.\n"));
    }

    //
    // see if the key exists
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        m_Service->QueryRegParamKey( ),
                        0,
                        KEY_READ|KEY_WRITE,
                        &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT,
            "RegOpenKeyEx %s returned error %d\n",
            m_Service->QueryRegParamKey(), err ));

        goto exit;
    }

    //
    // VR key?
    //

    err = RegCreateKeyEx( hkey,
                        VIRTUAL_ROOTS_KEY_A,
                        0,
                        NULL,
                        0,
                        KEY_READ|KEY_WRITE,
                        NULL,
                        &hkeyRoots,
                        &dwDisp );

    if ( err != NO_ERROR ) {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,
                "Error %d in RegCreateKeyEx\n",err));
        }

        goto exit;
    }

#if 0
    Removing this if will mean everytime the server starts we migrate the registry
    keys to the metabase.  The only side effect this has is if somebody deleted the
    a virtual directory from the metabase w/o the server started, that key will be
    migrated back from the registry.  With the server running it's not a big deal
    since the server always mirrors the metabase to the registry on vroot changes.

    if ( dwDisp == REG_OPENED_EXISTING_KEY ) {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,
                "Registry VR key found, aborting startup migration.\n"));
        }

        goto exit;
    }
#endif

    //
    // Get the MD handle to the VR root
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF((DBG_CONTEXT,"Open MD vr root returns %d\n",GetLastError()));
        goto exit;
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Opening MD path[%s]\n",QueryMDPath()));
    }

    TsRecursiveEnumVirtualRoots(
                    TsCopyVrootToRegistry,
                    hkeyRoots,
                    IIS_MD_INSTANCE_ROOT "/",
                    1,
                    (LPVOID)&mb,
                    TRUE );

    mb.Close();
    fMigrated = TRUE;

exit:

    if ( hkey != NULL ) {
        RegCloseKey(hkey);
    }

    if ( hkeyRoots != NULL ) {
        RegCloseKey(hkeyRoots);
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Leaving MoveMDToRegAtStartup.\n"));
    }
    return(fMigrated);

} // IIS_SERVER_INSTANCE::MoveMDVroots2Registry



VOID
IIS_SERVER_INSTANCE::PdcHackVRReg2MD(
    VOID
    )
/*++

Routine Description:

    Moves VR entries to the MD at startup.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD     err;
    CHAR      pszRoot[MAX_LENGTH_VIRTUAL_ROOT + MAX_LENGTH_ROOT_ADDR + 2];
    CHAR      pszDirectory[MAX_PATH + UNLEN + 3];

    CHAR *    pszUser;
    DWORD     cchRoot;
    DWORD     cchDir;
    DWORD     cch;
    BOOL      fRet = TRUE;
    DWORD     i = 0;
    DWORD     dwRegType;

    DWORD     dwMask;
    PCHAR     pszMask;
    PCHAR     tmpRoot;
    DWORD     dwAuthorization;
    MB        mb( (IMDCOM*) m_Service->QueryMDObject()  );

    HKEY      hkey = NULL;
    HKEY      hkeyRoots = NULL;

    DBG_ASSERT(IsDownLevelInstance());

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"In MoveVrootFromRegToMD\n"));
    }

    //
    // see if the key exists
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        m_Service->QueryRegParamKey( ),
                        0,
                        KEY_READ,
                        &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx returned error %d\n",err ));
        return;
    }

    //
    // VR key?
    //

    if ( err = RegOpenKeyEx( hkey,
                           VIRTUAL_ROOTS_KEY_A,
                           0,
                           KEY_READ,
                           &hkeyRoots )) {

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"RegOpenKeyEx %s failed with %d\n",
                      VIRTUAL_ROOTS_KEY_A, err));
        }
        goto exit;
    }

    //
    // Key exists. Get the authorization key
    //

    {
        HKEY instanceKey;

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            QueryRegParamKey(),
                            0,
                            KEY_ALL_ACCESS,
                            &instanceKey );

        if ( err != NO_ERROR ) {
            goto exit;
        }

        dwAuthorization = ReadRegistryDword( instanceKey,
                                         INETA_AUTHENTICATION,
                                         INET_INFO_AUTH_ANONYMOUS );

        RegCloseKey( instanceKey );
    }

    //
    // Get the MD handle to the VR root
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF((DBG_CONTEXT,"Open MD vr root returns %d\n",GetLastError()));
        goto exit;
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Adding MD path[%s]\n",QueryMDPath()));
    }

    //
    //  Enumerate all of the listed items in the registry
    //  and add them
    //

    strcpy( pszRoot, IIS_MD_INSTANCE_ROOT );
    tmpRoot = (PCHAR)pszRoot+sizeof( IIS_MD_INSTANCE_ROOT ) - 1;

    while ( TRUE ) {

        PCHAR pszComma;

        cchRoot = sizeof( pszRoot ) - 1;
        cchDir  = sizeof( pszDirectory );

        err = RegEnumValue( hkeyRoots,
                             i++,
                             tmpRoot,
                             &cchRoot,
                             NULL,
                             &dwRegType,
                             (LPBYTE) pszDirectory,
                             &cchDir );

        if ( err == ERROR_NO_MORE_ITEMS ) {
            break;
        }

        if ( dwRegType == REG_SZ ) {

            //
            //  The optional user name is kept after the directory.
            //  Only used for UNC roots, ignore for others
            //

            if ( pszUser = strchr( pszDirectory, ',' ) )
            {
                *pszUser = '\0';
                pszUser++;
            } else {
                pszUser = "";
            }

            //
            //  The optional access mask is kept after the user name.  It must
            //  appear in upper case hex.
            //

            if ( pszUser && (pszMask = strchr( pszUser, ',' )) ) {

                *pszMask = '\0';
                pszMask++;

                dwMask = hextointA( pszMask );
            } else {
                dwMask = VROOT_MASK_READ;
            }

            //
            // Remove commas from the root
            //

            pszComma = strchr(tmpRoot, ',');
            if ( pszComma != NULL ) {
                *pszComma = '\0';
                cchRoot--;
            }

            //
            // Write it out to the metabase
            //

            cchRoot++;

            //
            // This is the root
            //

            if ( !mb.AddObject( pszRoot ) )
            {
                if ( GetLastError() != ERROR_ALREADY_EXISTS )
                {
                     DBGPRINTF((DBG_CONTEXT,"AddMetaObject %s failed with %d\n",
                                pszRoot, GetLastError() ));
                }

                continue;
            }

            //
            // Set Path
            //

            mb.SetString( pszRoot,
                          MD_VR_PATH,
                          IIS_MD_UT_FILE,
                          pszDirectory );

            mb.SetString( pszRoot,
                          MD_KEY_TYPE,
                          IIS_MD_UT_SERVER,
                          "IIsWebVirtualDir" );

            //
            // Set Username
            //

            if ( pszUser && *pszUser )
            {
                mb.SetString( pszRoot,
                              MD_VR_USERNAME,
                              IIS_MD_UT_FILE,
                              pszUser );
            }

            //
            // Set Mask
            //

            mb.SetDword( pszRoot,
                         MD_ACCESS_PERM,
                         IIS_MD_UT_FILE,
                         dwMask );
        }

    } // while

    mb.Close();

exit:

    if ( hkeyRoots != NULL ) {
        RegCloseKey( hkeyRoots );
    }

    if ( hkey != NULL ) {
        RegCloseKey( hkey );
    }

    return;

} // IIS_SERVER_INSTANCE::PdcHackVRReg2MD


VOID
IIS_SERVER_INSTANCE::TsMirrorVirtualRoots(
    IN  LPINETA_CONFIG_INFO pConfig
    )
/*++
    Description:

        Writes the virtual roots specified in the config structure to the
        registry

    Arguments:
        pConfig - new list of virtual

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    DWORD               err;
    HKEY                hkey = NULL;
    HKEY                hkeyRoots = NULL;

    DWORD               dwDummy;
    LPINET_INFO_VIRTUAL_ROOT_LIST pRootsList;
    DWORD               cch;
    DWORD               i;

    DBG_ASSERT(IsDownLevelInstance());

    pRootsList = pConfig->VirtualRoots;

    //
    // Write it to the root key
    //

    err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    m_Service->QueryRegParamKey(),
                    0,
                    KEY_ALL_ACCESS,
                    &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx for returned error %d\n",err ));
        return;
    }

    //
    //  First delete the key to remove any old values
    //

    if (err = RegDeleteKey( hkey,
                            VIRTUAL_ROOTS_KEY_A ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[TsMirrorVRoots] Unable to remove old values\n"));

    }

    if ( err = RegCreateKeyEx( hkey,
                               VIRTUAL_ROOTS_KEY_A,
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hkeyRoots,
                               &dwDummy ))
    {
        goto exit;
    }

    //
    //  Permit empty list
    //

    if ( pRootsList == NULL ) {
        goto exit;
    }

    for ( i = 0; i < pRootsList->cEntries; i++ ) {

        WCHAR achValue[ MAX_PATH + UNLEN + 2 ];

        cch = wsprintfW( achValue,
                         L"%s,%s,%X",
                         pRootsList->aVirtRootEntry[i].pszDirectory,
                         pRootsList->aVirtRootEntry[i].pszAccountName,
                         pRootsList->aVirtRootEntry[i].dwMask );

        DBG_ASSERT( cch < sizeof( achValue ) / sizeof(WCHAR) );

        err = WriteRegistryStringW(hkeyRoots,
                       pRootsList->aVirtRootEntry[i].pszRoot,
                       achValue,
                       (wcslen(achValue) + 1) * sizeof(WCHAR),
                       REG_SZ);

        if ( err != NO_ERROR ) {
            goto exit;
        }
    }

exit:

    if ( hkeyRoots != NULL ) {
        RegCloseKey( hkeyRoots );
    }

    if ( hkey != NULL ) {
        RegCloseKey( hkey );
    }

    return;

} // IIS_SERVER_INSTANCE::TsMirrorVirtualRoots


VOID
ClearSentinelEntry(
    IN MB * pMB
    )
/*++
    Description:

        Removes the sentinel entry from all VR for this instance

    Arguments:
        pMD - pointer to metabase helper object that points to the
            instance metadatabase root.

    Returns:
        None.

--*/
{
    BOOL fGetRoot = TRUE;
    CHAR nameBuf[METADATA_MAX_NAME_LEN+2];
    DWORD i = 0;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Entering ClearSentinelEntry\n"));
    }

    while ( TRUE ) {

        METADATA_RECORD mdRecord;

        nameBuf[0] = nameBuf[1] = '/';

        if ( fGetRoot ) {

            fGetRoot = FALSE;
            nameBuf[2] = '\0';

        } else {

            if ( !pMB->EnumObjects( IIS_MD_INSTANCE_ROOT,
                                    &nameBuf[2],
                                    i++ ))
            {
                break;
            }
        }

        //
        // Delete sentinel value
        //

        if ( !pMB->DeleteData( nameBuf,
                            MD_VR_UPDATE,
                            IIS_MD_UT_FILE,
                            DWORD_METADATA
                            ))
        {
            IF_DEBUG(METABASE) {
                DBGPRINTF((DBG_CONTEXT,"Error %x deleting sentinel from %s\n",
                      GetLastError(), nameBuf));
            }
        }
    }

    return;

} // ClearSentinelEntry


VOID
RemoveUnmarkedRoots(
    IN MB * pMB
    )
/*++
    Description:

        Removes roots that are not marked by sentinel

    Arguments:
        pMD - pointer to metabase helper object that points to the
            instance metadatabase root.

    Returns:
        None.

--*/
{
    BOOL fGetRoot = TRUE;
    CHAR nameBuf[METADATA_MAX_NAME_LEN+2];
    CHAR szDirectory[MAX_PATH+1];
    DWORD cb;
    DWORD i = 0;
    BOOL fProcessingRoot;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Entering RemoveUnmarkedRoots\n"));
    }

    while ( TRUE ) {

        if ( fGetRoot ) {

            strcpy( nameBuf, IIS_MD_INSTANCE_ROOT );
            fProcessingRoot = TRUE;
            fGetRoot = FALSE;

        } else {

            strcpy( nameBuf, IIS_MD_INSTANCE_ROOT "/" );


            fProcessingRoot = FALSE;
            if ( !pMB->EnumObjects( IIS_MD_INSTANCE_ROOT,
                                    &nameBuf[strlen(nameBuf)],
                                    i++ ))
            {
                break;
            }
        }

        //
        // Delete sentinel value.  If delete successful, leave alone
        //

        if ( pMB->DeleteData( nameBuf,
                            MD_VR_UPDATE,
                            IIS_MD_UT_FILE,
                            DWORD_METADATA
                            ))
        {
            continue;
        }

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Error %x deleting sentinel from %s\n",
                  GetLastError(), nameBuf));
        }

        //
        // See if it has the path parameter
        //

        cb = sizeof( szDirectory );

        if ( !pMB->GetString( nameBuf,
                            MD_VR_PATH,
                            IIS_MD_UT_FILE,
                            szDirectory,
                            &cb,
                            0 ))
        {
            //
            // Not a VR
            //

            DBGPRINTF((DBG_CONTEXT,
                "Error %x reading path from %s. Not a VR.\n",
                      GetLastError(), nameBuf));
            continue;
        }

        //
        // Unmarked, delete the VR
        //

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Deleting vroot %s[%d]\n",
                nameBuf, fGetRoot));
        }

        if ( fProcessingRoot ) {

            //
            // if this is the root, just remove the path.  Deleting the
            // root is a potentially dangerous undertaking!
            //

            if ( !pMB->DeleteData( nameBuf,
                                MD_VR_PATH,
                                IIS_MD_UT_FILE,
                                STRING_METADATA
                                ))
            {
                DBGPRINTF((DBG_CONTEXT,"Error %x deleting root path\n",
                    GetLastError()));
            }

        } else {

            //
            // Delete the Vroot
            //

            if ( !pMB->DeleteObject( nameBuf ) )
            {
                DBGPRINTF((DBG_CONTEXT,"Error %x deleting %s\n",
                    GetLastError(), nameBuf));

            } else {

                //
                // the delete moved the index back by 1
                //

                DBG_ASSERT( i != 0 );

                --i;

            }
        }

        fGetRoot = FALSE;
    }

    return;

} // RemoveUnmarkedRoots


BOOL
ReadVrootConfig(
    LPVOID          pvMB,
    LPSTR           szVRPath,
    LPSTR           szDirectory,
    DWORD           cbDirectory,
    LPSTR           szUser,
    DWORD           cbUser,
    LPSTR           szPassword,
    DWORD           cbPassword,
    DWORD           *pdwMask,
    BOOL            *pfDoCache
    )
{

    DWORD           cb;
    DWORD           dwNoCache = 0;

    MB*             pMB = (MB*)pvMB;

    //
    // Get Directory path
    //

    cb = cbDirectory;

    if ( !pMB->GetString( szVRPath,
                        MD_VR_PATH,
                        IIS_MD_UT_FILE,
                        szDirectory,
                        &cb,
                        0 ))
    {
#if DBG
        if ( GetLastError() != MD_ERROR_DATA_NOT_FOUND )
        {
            DBGPRINTF((DBG_CONTEXT,"Error %x reading path from %s. Not a VR.\n",
                      GetLastError(), szVRPath));
        }
#endif

        return FALSE;
    }

    //
    // Get mask
    //

    if ( !pMB->GetDword( szVRPath,
                       MD_ACCESS_PERM,
                       IIS_MD_UT_FILE,
                       pdwMask,
                       0))
    {
        *pdwMask = VROOT_MASK_READ;

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Error %x reading mask from %s\n",
                  GetLastError(), szVRPath));
        }
    }

    //
    // Get username
    //

    cb = cbUser;

    if ( !pMB->GetString( szVRPath,
                        MD_VR_USERNAME,
                        IIS_MD_UT_FILE,
                        szUser,
                        &cb,
                        0))
    {
        szUser[0] = '\0';
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Read %s: Path[%s] User[%s] Mask[%d]\n",
                  szVRPath, szDirectory, szUser, *pdwMask));
    }

    if ( (szUser[0] != '\0') &&
         (szDirectory[0] == '\\') && (szDirectory[1] == '\\') ) {

        cb = cbPassword;

        //
        //  Retrieve the password for this address/share
        //

        if ( !pMB->GetString( szVRPath,
                            MD_VR_PASSWORD,
                            IIS_MD_UT_FILE,
                            szPassword,
                            &cb,
                            METADATA_SECURE))
        {
            szPassword[0] = '\0';
        }
    }
    else
    {
        szPassword[0] = '\0';
    }
    
    //
    // Should we cache this vdir
    //

    pMB->GetDword( szVRPath,
                   MD_VR_NO_CACHE,
                   IIS_MD_UT_FILE,
                   &dwNoCache,
                   0 );

    *pfDoCache = !dwNoCache;                   

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\beta2\vroots.cxx ===
/*++
   Copyright    (c)    1994        Microsoft Corporation

   Module Name:
        vroots.cxx

   Abstract:

        This module contains the front end to the virtual roots interface



   Author:

        John Ludeman    (johnl)     16-Mar-1995

   Project:

          Internet Servers Common Server DLL

   Revisions:

--*/

//
//  Include Headers
//

#include <tcpdllp.hxx>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iiscnfg.h>
#include <imd.h>
#include <inetreg.h>
#include <mb.hxx>
#include <w3svc.h>


BOOL
RetrieveRootPassword(
    PCHAR   pszRoot,
    PCHAR   pszPassword,
    WCHAR * pszSecret
    );

DWORD
GetFileSystemType(
    IN  LPCSTR      pszRealPath,
    OUT LPDWORD     lpdwFileSystem
    );

VOID
LogRootAddFailure(
    IN PIIS_SERVER_INSTANCE psi,
    PCHAR           pszRoot,
    PCHAR           pszDirectory,
    DWORD           err,
    IN PCHAR        pszMetaPath,
    IN MB *         pmb
    );

BOOL
TsAddVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

HANDLE
VrootLogonUser(
    IN CHAR  * pszUser,
    IN CHAR  * pszPassword
    );

BOOL
CrackUserAndDomain(
    CHAR *   pszDomainAndUser,
    CHAR * * ppszUser,
    CHAR * * ppszDomain
    );

VOID
ClearSentinelEntry(
    IN MB * pMB
    );

VOID
RemoveUnmarkedRoots(
    IN MB * pMB
    );

DWORD
hextointW(
    WCHAR * pch
    );

DWORD
hextointA(
    CHAR * pch
    );

BOOL
IIS_SERVER_INSTANCE::TsReadVirtualRoots(
    VOID
    )
/*++
    Description:

        NT Version

        Reads the metabase key pointed at by pmb and adds each root item

    Arguments:

    Note:
        Failure to add a virtual root is not fatal.  An appropriate event
        will be logged listing the error and root.

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL fRet;

    //
    //  Remove all of the old roots for this server
    //

    QueryVrootTable()->LockTable();

    fRet = QueryVrootTable()->RemoveVirtualRoots() &&
           TsEnumVirtualRoots( TsAddVroots, this );

    QueryVrootTable()->UnlockTable();

    return fRet;
}

BOOL
TsAddVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
{
    DWORD           err = NO_ERROR;
    DWORD           dwFileSystem;
    BOOL            fRet = FALSE;
    HANDLE          hToken = NULL;

    //
    //  Clear this virtual directory's error status
    //

    if ( !pmb->SetDword( pvr->pszMetaPath,
                         MD_WIN32_ERROR,
                         IIS_MD_UT_SERVER,
                         NO_ERROR ))
    {
        DBGPRINTF((DBG_CONTEXT,"Error %x setting win32 status from %s. \n",
                  GetLastError(), pvr->pszMetaPath ));
        return FALSE;
    }

#if 0
    if ( (pvr->pszUserName[0] != '\0') &&
         (pvr->pszPath[0] == '\\') && (pvr->pszPath[1] == '\\') ) {

        NETRESOURCE nr;
        nr.dwScope = RESOURCE_CONNECTED;
        nr.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        nr.dwType = RESOURCETYPE_DISK;
        nr.lpLocalName = NULL;
        nr.lpRemoteName = pvr->pszPath;
        nr.lpComment = "";
        nr.lpProvider = NULL;

        //
        // try disconnecting from the distant resource 1st
        // (in case credentials have changed )
        //

        WNetCancelConnection2( pvr->pszPath, 0, TRUE );

        //
        // Connect to distant disk using specified account
        //

        if ( err = WNetAddConnection2( &nr,
                                       pvr->pszPassword,
                                       pvr->pszUserName,
                                       0 ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "Adding path %s err %d, user=%s, pwd=%d\n",
                    pvr->pszPath, err, pvr->pszUserName, pvr->pszPassword ));

            //
            //  Log error
            //

            LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                               pvr->pszAlias,
                               pvr->pszPath,
                               err,
                               pvr->pszMetaPath,
                               pmb );
        }
    }

#else

    if ( (pvr->pszUserName[0] != '\0') &&
         (pvr->pszPath[0] == '\\') && (pvr->pszPath[1] == '\\') )
        {
                hToken = VrootLogonUser( pvr->pszUserName,
                                                                 pvr->pszPassword );

                if ( hToken == NULL)
                {
                        DBGPRINTF(( DBG_CONTEXT,
                                        "Adding path %s err %d, user=%s, pwd=%d\n",
                                        pvr->pszPath, GetLastError(), pvr->pszUserName, pvr->pszPassword ));

                        //
                        //  Log error
                        //

                        LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                                                           pvr->pszAlias,
                                                           pvr->pszPath,
                                                           GetLastError(),
                                                           pvr->pszMetaPath,
                                                           pmb );
                }


                // Impersonate as user for GetFileSystemType()
                if ( hToken != NULL && !ImpersonateLoggedOnUser(hToken))
                {

                        err = GetLastError();
                }
        }

#endif

    if ( err == NO_ERROR )
    {

        err = GetFileSystemType( pvr->pszPath, &dwFileSystem);

        if ( err != NO_ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                        " GetFileSystemType(%s) failed.Error = %u.\n",
                        pvr->pszPath,
                        err));

            LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                               pvr->pszAlias,
                               pvr->pszPath,
                               err,
                               pvr->pszMetaPath,
                               pmb );
        }
    }

    //
    //  Don't add roots that are invalid
    //

    if ( err == NO_ERROR )
    {
        if ( !((IIS_SERVER_INSTANCE *) pvContext)->QueryVrootTable()->AddVirtualRoot(
                                    pvr->pszAlias,
                                    pvr->pszPath,
                                    pvr->dwAccessPerm,
                                    pvr->pszUserName,
                                    hToken,
                                    dwFileSystem ))
        {
            err = GetLastError();

            DBGPRINTF(( DBG_CONTEXT,
                        " AddVirtualRoot() failed. Error = %u.\n", err));

            LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                               pvr->pszAlias,
                               pvr->pszPath,
                               err,
                               pvr->pszMetaPath,
                               pmb );
        }
    }

    if ( hToken != NULL)
    {
        RevertToSelf();
    }

    if ( err == NO_ERROR )
    {
        fRet = TRUE;
    }

    return fRet;

} // TsReadVirtualRoots


BOOL
IIS_SERVER_INSTANCE::TsEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext
    )
{
    MB              mb( (IMDCOM*) m_Service->QueryMDObject() );

    if ( !mb.Open( QueryMDPath(),
               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        return FALSE;
    }

    return TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    "IIS_MD_INSTANCE_ROOT/",
                    m_dwLevelsToScan,
                    (LPVOID)&mb,
                    TRUE );
}


BOOL
IIS_SERVER_INSTANCE::TsRecursiveEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext,
    LPSTR       pszCurrentPath,
    DWORD       dwLevelsToScan,
    LPVOID      pvMB,
    BOOL        fGetRoot
    )
/*++
    Description:

        Enumerates all of the virtual directories defined for this server
        instance

    Arguments:
        pfnCallback - Enumeration callback to call for each virtual directory
        pvContext - Context pfnCallback receives
        pszCurrentPath - path where to start scanning for VRoots
        dwLevelsToScan - # of levels to scan recursively for vroots
        pvMB - ptr to MB to access metabase. Is LPVOID to avoid having to include
               mb.hxx before any ref to iistypes.hxx
        fGetRoot - TRUE if pszCurrentPath is to be considered as vroot to process

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    DWORD           err;
    MB*             pMB = (MB*)pvMB;

    DWORD           dwMask;
    CHAR            szUser[UNLEN+1];
    CHAR            szPassword[PWLEN+1];
    CHAR            szDirectory[MAX_PATH + UNLEN + 3];
    DWORD           cb;

    CHAR            nameBuf[METADATA_MAX_NAME_LEN+2];
    DWORD           cbCurrentPath;
    VIRTUAL_ROOT    vr;
    DWORD           i = 0;

    //
    //  Enumerate all of the listed items in the metabase
    //  and add them
    //

    cbCurrentPath = strlen( pszCurrentPath );
    CopyMemory( nameBuf, pszCurrentPath, cbCurrentPath + 1);

    while ( TRUE ) {

        METADATA_RECORD mdRecord;
        DWORD  dwFileSystem = FS_ERROR;

        err = NO_ERROR;

        if ( fGetRoot ) {

            fGetRoot = FALSE;

        } else {

            nameBuf[cbCurrentPath-1] = '/';

            if ( !pMB->EnumObjects( pszCurrentPath,
                                  nameBuf + cbCurrentPath,
                                  i++ ))
            {
                break;
            }

            if ( dwLevelsToScan > 1 )
            {
                cb = strlen( nameBuf );
                nameBuf[ cb ] = '/';
                nameBuf[ cb + 1 ] = '\0';

                if ( !TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    nameBuf,
                    dwLevelsToScan - 1,
                    pMB,
                    FALSE ) )
                {
                    return FALSE;
                }

                nameBuf[ cb ] = '\0';
            }
        }

        //
        // Get Directory path
        //

        cb = sizeof( szDirectory );

        if ( !pMB->GetString( nameBuf,
                            MD_VR_PATH,
                            IIS_MD_UT_FILE,
                            szDirectory,
                            &cb,
                            0 ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %x reading path from %s. Not a VR.\n",
                      GetLastError(), nameBuf));
            continue;
        }

        //
        // Get mask
        //

        if ( !pMB->GetDword( nameBuf,
                           MD_ACCESS_PERM,
                           IIS_MD_UT_FILE,
                           &dwMask,
                           0))
        {
            dwMask = VROOT_MASK_READ;

            DBGPRINTF((DBG_CONTEXT,"Error %d reading mask from %s\n",
                      GetLastError(), nameBuf));
        }

        //
        // Get username
        //

        cb = sizeof( szUser );

        if ( !pMB->GetString( nameBuf,
                            MD_VR_USERNAME,
                            IIS_MD_UT_FILE,
                            szUser,
                            &cb,
                            0))
        {
//            DBGPRINTF((DBG_CONTEXT,"Error %d reading path from %s\n",
//                      GetLastError(), nameBuf));

            szUser[0] = '\0';
        }

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Reading %s: Path[%s] User[%s] Mask[%d]\n",
                      nameBuf, szDirectory, szUser, dwMask));
        }

        if ( (szUser[0] != '\0') &&
             (szDirectory[0] == '\\') && (szDirectory[1] == '\\') ) {

            cb = sizeof( szPassword );

            //
            //  Retrieve the password for this address/share
            //

            if ( !pMB->GetString( nameBuf,
                                MD_VR_PASSWORD,
                                IIS_MD_UT_FILE,
                                szPassword,
                                &cb,
                                METADATA_SECURE))
            {
                DBGPRINTF((DBG_CONTEXT,"Error %d reading path from %s\n",
                          GetLastError(), nameBuf));

                szPassword[0] = '\0';
            }
        }
        else
        {
            szPassword[0] = '\0';
        }

        //
        //  Now set things up for the callback
        //

        DBG_ASSERT( nameBuf[0] == '/' && nameBuf[1] == '/' );

        vr.pszAlias     = nameBuf + 1;
        vr.pszMetaPath  = nameBuf;
        vr.pszPath      = szDirectory;
        vr.dwAccessPerm = dwMask;
        vr.pszUserName  = szUser;
        vr.pszPassword  = szPassword;

        if ( !pfnCallback( pvContext, pMB, &vr ))
        {
            //
            // !!! so what do we do here?
            //

            DBGPRINTF((DBG_CONTEXT,"EnumCallback returns FALSE\n"));
        }

    } // while

    return TRUE;

} // Enum



VOID
LogRootAddFailure(
    IN PIIS_SERVER_INSTANCE psi,
    IN PCHAR        pszRoot,
    IN PCHAR        pszDirectory,
    IN DWORD        err,
    IN PCHAR        pszMetaPath,
    IN MB *         pmb
    )
{
    const CHAR *    apsz[3];
    STR             strError;

    psi->LoadStr( strError, err );  // loads ANSI message. Convert to UNICODE

    apsz[0] = pszRoot;
    apsz[1] = pszDirectory;
    apsz[2] = strError.QueryStrA();

    psi->m_Service->LogEvent( INET_SVC_ADD_VIRTUAL_ROOT_FAILED,
                              3,
                              apsz,
                              err );

    //
    //  Indicate the error on this virtual directory
    //

    if ( !pmb->SetDword( pszMetaPath,
                         MD_WIN32_ERROR,
                         IIS_MD_UT_SERVER,
                         err ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LogRootAddFailure: Unable to set win32 status\n" ));
    }
} // LogRootAddFailure


BOOL
RetrieveRootPassword(
    PCHAR   pszRoot,
    PCHAR   pszPassword,
    PWCHAR  pszSecret
    )
/*++
    Description:

        This function retrieves the password for the specified root & address

    Arguments:

        pszRoot - Name of root + address in the form "/root,<address>".
        pszPassword - Receives password, must be at least PWLEN+1 characters
        pszSecret - Virtual Root password secret name

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BUFFER  bufSecret;
    WCHAR * psz;
    WCHAR * pszTerm;
    WCHAR * pszNextLine;
    WCHAR   wsRoot[MAX_PATH+1];

    DWORD   cch;

    if ( !TsGetSecretW( pszSecret,
                        &bufSecret ))
    {
        return FALSE;
    }

    //
    // Convert root to WCHAR
    //

    cch = MultiByteToWideChar( CP_ACP,
                               MB_PRECOMPOSED,
                               pszRoot,
                               -1,
                               wsRoot,
                               MAX_PATH+1 );

    wsRoot[cch] = L'\0';
    if ( cch == 0 ) {
        return FALSE;
    }

    psz = (WCHAR *) bufSecret.QueryPtr();

    //
    //  Scan the list of roots looking for a match.  The list looks like:
    //
    //     <root>,<address>=<password>\0
    //     <root>,<address>=<password>\0
    //     \0
    //

    while ( *psz )
    {
        PWCHAR pszComma;

        pszNextLine = psz + wcslen(psz) + 1;

        pszTerm = wcschr( psz, L'=' );

        if ( !pszTerm )
            goto NextLine;

        *pszTerm = L'\0';

        //
        // remove the ,
        //

        pszComma = wcschr( psz, L',' );
        if ( pszComma != NULL ) {
            *pszComma = '\0';
        }

        if ( !_wcsicmp( wsRoot, psz ) )
        {

            //
            //  We found a match, copy the password
            //

            (VOID) ConvertUnicodeToAnsi(
                               pszTerm + 1,
                               pszPassword,
                               PWLEN + sizeof(CHAR));

            return TRUE;
        }

NextLine:
        psz = pszNextLine;
    }

    //
    //  If the matching root wasn't found, default to the empty password
    //

    *pszPassword = '\0';
    return TRUE;

} // RetrieveRootPassword



BOOL
IIS_SERVER_INSTANCE::TsSetVirtualRoots(
    IN LPIIS_INSTANCE_INFO_1   pConfig
    )
/*++
    Description:

        Writes the virtual roots specified in the config structure to the
        registry

    Arguments:
        pConfig - new list of virtual

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    DWORD               err;
    DWORD               dwDummy;
    LPINET_INFO_VIRTUAL_ROOT_LIST pRootsList;
    DWORD               cch;
    DWORD               i;
    DWORD               dwMask;
    DWORD               sentinelValue = 7777777;

    MB                  mb( (IMDCOM*) m_Service->QueryMDObject()  );

    //
    // Do the metabase
    //

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Setting VR data on %s\n",
                  QueryMDPath()));
    }

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Open MD instance root %s returns %d\n",
                      QueryMDPath(), GetLastError() ));
        }
        return FALSE;
    }

    //
    // See if we need to delete any VRs
    //

    pRootsList = pConfig->VirtualRoots;

    if ( (pRootsList == NULL) || (pRootsList->cEntries == 0) ) {

        //
        // NO VRs.  Delete the entire VR tree
        //

        if ( !mb.DeleteObject( "IIS_MD_INSTANCE_ROOT/" ) )
        {
            IF_DEBUG(METABASE) {
                DBGPRINTF((DBG_CONTEXT,
                          "Deleting VR root returns %d\n",GetLastError()));
            }
        }

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Empty list set on %s\n", QueryMDPath()));
        }

        goto exit;

    } else {

        //
        // Remove our secret value
        //

        ClearSentinelEntry( &mb );
    }

    for ( i = 0; i < pRootsList->cEntries; i++ ) {

        CHAR tmpRoot[MAX_PATH+1];
        CHAR tmpBuffer[MAX_PATH+1];

        DWORD rootLen;

        //
        // strings to ANSI
        //

        tmpRoot[0] = '/';

        (VOID) ConvertUnicodeToAnsi(
                           pRootsList->aVirtRootEntry[i].pszRoot,
                           &tmpRoot[1],
                           MAX_PATH);

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Setting data for root %s\n",tmpRoot));
        }

        rootLen = strlen(tmpRoot);

        //
        // Create the root
        //

        if ( !mb.AddObject( tmpRoot ) &&
             (GetLastError() != ERROR_ALREADY_EXISTS) )
        {

            DBGPRINTF((DBG_CONTEXT,"AddMetaObject %s failed with %d\n",
                          tmpRoot, GetLastError() ));
            goto exit;
        }

        //
        // Set sentinel entry
        //

        if ( !mb.SetDword( tmpRoot,
                           MD_VR_UPDATE,
                           IIS_MD_UT_FILE,
                           sentinelValue,
                           0 ))
        {
            DBGPRINTF((DBG_CONTEXT,
                "Error %d setting sentinel value %x for %s\n",
                GetLastError(), sentinelValue, tmpRoot));

            goto exit;
        }

        //
        // Set Path
        //

        (VOID) ConvertUnicodeToAnsi(
                        pRootsList->aVirtRootEntry[i].pszDirectory,
                        tmpBuffer,
                        MAX_PATH+1);

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Directory path is %s\n",tmpBuffer));
        }

        if ( !mb.SetString( tmpRoot,
                            MD_VR_PATH,
                            IIS_MD_UT_FILE,
                            tmpBuffer ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting path[%s] for %s\n",
                      GetLastError(), tmpBuffer, tmpRoot));
        }

        //
        // Set Username
        //

        (VOID) ConvertUnicodeToAnsi(
                           pRootsList->aVirtRootEntry[i].pszAccountName,
                           tmpBuffer,
                           MAX_PATH+1);

        if ( !mb.SetString( tmpRoot,
                            MD_VR_USERNAME,
                            IIS_MD_UT_FILE,
                            tmpBuffer ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting username for %s\n",
                      GetLastError(), tmpRoot));
        }

        //
        // Set Mask
        //

        if ( !mb.SetDword( tmpRoot,
                           MD_ACCESS_PERM,
                           IIS_MD_UT_FILE,
                           pRootsList->aVirtRootEntry[i].dwMask ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting mask for %s\n",
                      GetLastError(), tmpRoot));
        }
    }

    //
    // Delete entries that does not have the sentinel entry
    //

    RemoveUnmarkedRoots( &mb );

exit:
    mb.Save();

    //
    // If this is instance 1, mirror it to the registry
    //

    DBGPRINTF(( DBG_CONTEXT,
                "WARNING! Downlevel assumed to be instance 1!!! Fix it!\n" ));

    if ( QueryInstanceId() == 1 ) {
        TsMirrorVirtualRoots( pConfig );
    }

    return TRUE;

} // IIS_SERVER_INSTANCE::TsSetVirtualRoots


DWORD
GetFileSystemType(
    IN  LPCSTR      pszRealPath,
    OUT LPDWORD     lpdwFileSystem
    )
/*++
    Gets file system specific information for a given path.
    It uses GetVolumeInfomration() to query the file system type
       and file system flags.
    On success the flags and file system type are returned in
       passed in pointers.

    Arguments:

        pszRealPath    pointer to buffer containing path for which
                         we are inquiring the file system details.

        lpdwFileSystem
            pointer to buffer to fill in the type of file system.

    Returns:
        NO_ERROR  on success and Win32 error code if any error.

--*/
{
# define MAX_FILE_SYSTEM_NAME_SIZE    ( MAX_PATH)

    CHAR    rgchBuf[MAX_FILE_SYSTEM_NAME_SIZE];
    CHAR    rgchRoot[MAX_FILE_SYSTEM_NAME_SIZE];
    int     i;
    DWORD   dwReturn = ERROR_PATH_NOT_FOUND;
    DWORD   len;

    if ( (pszRealPath == NULL) || (lpdwFileSystem == NULL)) {
        return ( ERROR_INVALID_PARAMETER);
    }

    ZeroMemory( rgchRoot, sizeof(rgchRoot) );
    *lpdwFileSystem = FS_ERROR;

    //
    // Copy just the root directory to rgchRoot for querying
    //

    IF_DEBUG( DLL_VIRTUAL_ROOTS) {
        DBGPRINTF( ( DBG_CONTEXT, " GetFileSystemType(%s).\n", pszRealPath));
    }

    if ( (pszRealPath[0] == '\\') &&
         (pszRealPath[1] == '\\')) {

        PCHAR pszEnd;

        //
        // this is an UNC name. Extract just the first two components
        //
        //

        pszEnd = strchr( pszRealPath+2, '\\');

        if ( pszEnd == NULL) {

            // just the server name present

            return ( ERROR_INVALID_PARAMETER);
        }

        pszEnd = strchr( pszEnd+1, '\\');

        len = ( ( pszEnd == NULL) ? strlen(pszRealPath)
               : (pszEnd + 1 - pszRealPath));

        //
        // Copy till the end of UNC Name only (exclude all other path info)
        //

        if ( len < (MAX_FILE_SYSTEM_NAME_SIZE - 1) ) {

            CopyMemory( rgchRoot, pszRealPath, len);
            rgchRoot[len] = '\0';
        } else {

            return ( ERROR_INVALID_NAME);
        }

        if ( rgchRoot[len - 1] != '\\' ) {

            if ( len < MAX_FILE_SYSTEM_NAME_SIZE - 2 ) {
                rgchRoot[len]   = '\\';
                rgchRoot[len+1] = '\0';
            } else {

                return (ERROR_INVALID_NAME);
            }
        }
    } else {

        //
        // This is non UNC name.
        // Copy just the root directory to rgchRoot for querying
        //


        for( i = 0; i < 9 && pszRealPath[i] != '\0'; i++) {

            if ( (rgchRoot[i] = pszRealPath[i]) == ':') {

                break;
            }
        } // for


        if ( rgchRoot[i] != ':') {

            //
            // we could not find the root directory.
            //  return with error value
            //

            return ( ERROR_INVALID_PARAMETER);
        }

        rgchRoot[i+1] = '\\';     // terminate the drive spec with a slash
        rgchRoot[i+2] = '\0';     // terminate the drive spec with null char

    } // else

    IF_DEBUG( DLL_VIRTUAL_ROOTS) {
        DBGPRINTF( ( DBG_CONTEXT, " GetVolumeInformation(%s).\n",
                    rgchRoot));
    }

    //
    // The rgchRoot should end with a "\" (slash)
    // otherwise, the call will fail.
    //

    if (  GetVolumeInformation( rgchRoot,        // lpRootPathName
                                NULL,            // lpVolumeNameBuffer
                                0,               // len of volume name buffer
                                NULL,            // lpdwVolSerialNumber
                                NULL,            // lpdwMaxComponentLength
                                NULL,            // lpdwSystemFlags
                                rgchBuf,         // lpFileSystemNameBuff
                                sizeof(rgchBuf)
                                ) ) {



        dwReturn = NO_ERROR;

        if ( strcmp( rgchBuf, "FAT") == 0) {

            *lpdwFileSystem = FS_FAT;

        } else if ( strcmp( rgchBuf, "NTFS") == 0) {

            *lpdwFileSystem = FS_NTFS;

        } else if ( strcmp( rgchBuf, "HPFS") == 0) {

            *lpdwFileSystem = FS_HPFS;

        } else if ( strcmp( rgchBuf, "CDFS") == 0) {

            *lpdwFileSystem = FS_CDFS;

        } else if ( strcmp( rgchBuf, "OFS") == 0) {

            *lpdwFileSystem = FS_OFS;

        } else {

            *lpdwFileSystem = FS_FAT;
        }

    } else {

        dwReturn = GetLastError();

        IF_DEBUG( DLL_VIRTUAL_ROOTS) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " GetVolumeInformation( %s) failed with error %d\n",
                        rgchRoot, dwReturn));
        }

    }

    return ( dwReturn);
} // GetFileSystemType()


HANDLE
VrootLogonUser(
    IN CHAR  * pszUser,
    IN CHAR  * pszPassword
    )
/*++
  This function uses the given parameters and logs on to generate
   a user handle for the account.

  Arguments:
    pszUser - pointer to string containing the user name.
    pszPassword - pointer to string containing the password.

  Returns:
    Handle for the logged on user on success.
    Returns NULL for errors.

  History:
    MuraliK  18-Jan-1996  Created.
--*/
{
    CHAR        szDomainAndUser[DNLEN+UNLEN+2];
    CHAR   *    pszUserOnly;
    CHAR   *    pszDomain;
    HANDLE      hToken = NULL;
    BOOL        fReturn;

    //
    //  Validate parameters & state.
    //

    DBG_ASSERT( pszUser != NULL && *pszUser != '\0');
    DBG_ASSERT( strlen(pszUser) < sizeof(szDomainAndUser) );
    DBG_ASSERT( pszPassword != NULL);
    DBG_ASSERT( strlen(pszPassword) <= PWLEN );

    //
    //  Save a copy of the domain\user so we can squirrel around
    //  with it a bit.
    //

    strcpy( szDomainAndUser, pszUser );

    //
    //  Crack the name into domain/user components.
    //  Then try and logon as the specified user.
    //

    fReturn = ( CrackUserAndDomain( szDomainAndUser,
                                   &pszUserOnly,
                                   &pszDomain ) &&
               LogonUserA(pszUserOnly,
                          pszDomain,
                          pszPassword,
                          LOGON32_LOGON_INTERACTIVE, //LOGON32_LOGON_NETWORK,
                          LOGON32_PROVIDER_DEFAULT,
                          &hToken )
               );

    if ( !fReturn) {

        //
        //  Logon user failed.
        //

        IF_DEBUG( DLL_SECURITY) {

            DBGPRINTF(( DBG_CONTEXT,
                       " CrachUserAndDomain/LogonUser (%s) failed Error=%d\n",
                       pszUser, GetLastError()));
        }

        hToken = NULL;
    } else {
        HANDLE hImpersonation = NULL;

        // we need to obtain the impersonation token, the primary token cannot
        // be used for a lot of purposes :(
        if (!DuplicateToken( hToken,      // hSourceToken
                            SecurityImpersonation,  // Obtain impersonation
                             &hImpersonation)  // hDestinationToken
            ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "Creating ImpersonationToken failed. Error = %d\n",
                        GetLastError()
                        ));

            // cleanup and exit.
            hImpersonation = NULL;

            // Fall through for cleanup
        }

        //
        // close original token. If Duplicate was successful,
        //  we should have ref in the hImpersonation.
        // Send the impersonation token to the client.
        //
        CloseHandle( hToken);
        hToken = hImpersonation;
    }


    //
    //  Success!
    //

    return hToken;

} // VrootLogonUser()

DWORD
hextointW(
    WCHAR * pch
    )
{
    WCHAR * pchStart;
    DWORD sum = 0;
    DWORD mult = 1;

    while ( *pch == L' ' )
        pch++;

    pchStart = pch;

    while ( iswxdigit( *pch ) )
        pch++;

    while ( --pch >= pchStart )
    {
        sum += mult * ( *pch  >= L'A' ? *pch + 10 - L'A' :
                                       *pch - L'0' );
        mult *= 16;
    }

    return sum;
}



DWORD
hextointA(
    CHAR * pch
    )
{
    CHAR * pchStart;
    DWORD sum = 0;
    DWORD mult = 1;

    while ( *pch == ' ' )
        pch++;

    pchStart = pch;

    while ( isxdigit( *pch ) )
        pch++;

    while ( --pch >= pchStart )
    {
        sum += mult * ( *pch  >= 'A' ? *pch + 10 - 'A' :
                                      *pch - '0' );
        mult *= 16;
    }

    return sum;

} // hextointA




BOOL
IIS_SERVER_INSTANCE::MoveVrootFromRegToMD(
    VOID
    )
{
#if 0
    DWORD     err;
    CHAR      pszRoot[MAX_LENGTH_VIRTUAL_ROOT + MAX_LENGTH_ROOT_ADDR + 2];
    CHAR      pszDirectory[MAX_PATH + UNLEN + 3];

    CHAR *    pszUser;
    DWORD     cchRoot;
    DWORD     cchDir;
    DWORD     cch;
    BOOL      fRet = TRUE;
    DWORD     i = 0;
    DWORD     dwRegType;

    DWORD     dwMask;
    PCHAR     pszMask;
    PCHAR     tmpRoot;
    DWORD     dwAuthorization;
    DWORD     dwDirBrowse;
    STR       strFile;
    MB        mb( (IMDCOM*) m_Service->QueryMDObject()  );

    HKEY      hkey = NULL;
    HKEY      hkeyRoots = NULL;
    HKEY      hkeyExtMaps = NULL;
    BUFFER    bufTemp;
    STR       strRealm;
    STR       strLogonDomain;
    STR       strAnonUser;
    BOOL      fCreateProcessAsUser;
    BOOL      fCreateProcessWithNewConsole;
    DWORD     dwLogonMethod;
    DWORD     dwCurrentSize;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"In MoveVrootFromRegToMD\n"));
    }

    //
    // See if we need to move
    //

    if ( !mb.Open( "/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        //
        // if this fails, we're hosed.
        //

        DBGPRINTF((DBG_CONTEXT,"Open MD root returns %d\n",GetLastError() ));
        return FALSE;
    }

    //
    // This will fail if the metabase was already set up
    //

    if ( !mb.AddObject( QueryMDPath() ) &&
         GetLastError() != ERROR_ALREADY_EXISTS )
    {
        DBGPRINTF((DBG_CONTEXT,"AddMetaObject %s failed with %d\n",
                      QueryMDPath(), GetLastError() ));

        goto exit;
    }

    DBG_REQUIRE( mb.Close() );

    //
    // Our add worked, so that means that the metabase is empty
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        m_Service->QueryRegParamKey(),
                        0,
                        KEY_ALL_ACCESS,
                        &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx returned error %d\n",err ));
        goto exit;
    }

    dwAuthorization = ReadRegistryDword( hkey,
                                         INETA_AUTHENTICATION,
                                         INET_INFO_AUTH_ANONYMOUS );

    dwDirBrowse = ReadRegistryDword( hkey,
                                     "Dir Browse Control",
                                     0x4000001e );

    ReadRegistryStr( hkey,
                     strFile,
                     "Default Load File",
                     "Default.htm,Index.htm" );

    ReadRegistryStr( hkey,
                     strRealm,
                     W3_REALM_NAME,
                     "" );


    fCreateProcessAsUser = !!ReadRegistryDword( hkey,
                                                "CreateProcessAsUser",
                                                TRUE );

    fCreateProcessWithNewConsole = !!ReadRegistryDword( hkey,
            "CreateProcessWithNewConsole",
            FALSE );


    dwLogonMethod = ReadRegistryDword( hkey,
                                         INETA_LOGON_METHOD,
                                         INETA_DEF_LOGON_METHOD );

    switch ( dwLogonMethod ) {

        case INETA_LOGM_BATCH:
            dwLogonMethod = LOGON32_LOGON_BATCH;
            break;

        case INETA_LOGM_NETWORK:
            dwLogonMethod = LOGON32_LOGON_NETWORK;
            break;

        case INETA_LOGM_INTERACTIVE:
        default:
            dwLogonMethod = LOGON32_LOGON_INTERACTIVE;
            break;
    }

    ReadRegistryStr( hkey,
                strLogonDomain,
                INETA_DEFAULT_LOGON_DOMAIN,
                 INETA_DEF_DEFAULT_LOGON_DOMAIN );

    ReadRegistryStr( hkey,
                strAnonUser,
                INETA_ANON_USER_NAME,
                INETA_DEF_ANON_USER_NAME );


    if ( err = RegOpenKeyEx( hkey,
                           VIRTUAL_ROOTS_KEY_A,
                           0,
                           KEY_ALL_ACCESS,
                           &hkeyRoots )) {

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"RegOpenKeyEx %s failed with %d\n",
                      VIRTUAL_ROOTS_KEY_A, err));
        }
        goto exit;
    }

    //
    // Get the MD handle to the VR root
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF((DBG_CONTEXT,"Open MD path returns %d\n",GetLastError()));
        goto exit;
    }

    //
    // Now set all of the parameters which were previously on a per-instance
    // basis at the instance level.

    //
    // Set the default authorization requirements
    //

    mb.SetDword( "",
                 MD_AUTHORIZATION,
                 IIS_MD_UT_FILE,
                 dwAuthorization );

    //
    // Set the directory browsing control
    //

    mb.SetDword( "",
                 MD_DIRECTORY_BROWSING,
                 IIS_MD_UT_FILE,
                 dwDirBrowse );

    //
    // Set the default document
    //

    mb.SetString( "",
                  MD_DEFAULT_LOAD_FILE,
                  IIS_MD_UT_FILE,
                  strFile.QueryStr());

    // Set the realm.
    //
    if (!strRealm.IsEmpty())
    {
        mb.SetString( "",
                      MD_REALM,
                      IIS_MD_UT_FILE,
                      strRealm.QueryStr());

    }

    mb.SetDword( "",
                 MD_CREATE_PROCESS_AS_USER,
                 IIS_MD_UT_FILE,
                 (DWORD)fCreateProcessAsUser );

    mb.SetDword( "",
                 MD_CREATE_PROC_NEW_CONSOLE,
                 IIS_MD_UT_FILE,
                 (DWORD)fCreateProcessWithNewConsole );

    mb.SetDword( "",
                 MD_LOGON_METHOD,
                 IIS_MD_UT_FILE,
                 dwLogonMethod );

    mb.SetString( "",
                  MD_DEFAULT_LOGON_DOMAIN,
                  IIS_MD_UT_FILE,
                  strLogonDomain.QueryStr());

    mb.SetString( "",
                  MD_ANONYMOUS_USER_NAME,
                  IIS_MD_UT_FILE,
                  strAnonUser.QueryStr());

    //
    // Now enumerate all of the script mapping on this instance, and add them.
    //

    err = RegOpenKeyEx( hkey,
                        HTTP_EXT_MAPS,
                        0,
                        KEY_ALL_ACCESS,
                        &hkeyExtMaps );

    if (err)
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"RegOpenKeyEx %s failed with %d\n",
                      HTTP_EXT_MAPS, err));
        }
        goto exit;
    }


    dwCurrentSize = 0;

    while (TRUE)
    {
        CHAR  achExt[MAX_PATH+1];
        CHAR  achImage[MAX_PATH+1];
        DWORD cchExt   = sizeof( achExt );
        DWORD cchImage = sizeof( achImage );
        DWORD dwSizeNeeded;
        CHAR  *pszTemp;

        // Get the next script mapping.
        err = RegEnumValue( hkeyExtMaps,
                            i,
                            achExt,
                            &cchExt,
                            NULL,
                            &dwRegType,
                            (LPBYTE) achImage,
                            &cchImage );

        if ( err == ERROR_NO_MORE_ITEMS )
        {
            if (bufTemp.QuerySize() < (dwCurrentSize + 1))
            {
                if (!bufTemp.Resize(dwCurrentSize + 1))
                {
                    IF_DEBUG(METABASE) {
                        DBGPRINTF((DBG_CONTEXT,
                            "Unable to create script mapping string\n"));
                    }
                    fRet = FALSE;
                    goto exit;
                }
            }
            pszTemp = (CHAR *)bufTemp.QueryPtr() + dwCurrentSize;

            // Add the extra NULL.
            *pszTemp = '\0';
            break;
        }

        if ( dwRegType == REG_SZ )
        {

            // Figure the size we need. We need enough for the extension,
            // (cchExt, which doesn't include the trailing NULL), space
            // for the comma, space for the image name (cchImage, which
            // does include the NULL) and the trailing NULL, and enough
            // for what we already have.

            dwSizeNeeded = cchExt + sizeof(",") - 1 + cchImage + dwCurrentSize;

            if (dwSizeNeeded > bufTemp.QuerySize())
            {
                if (!bufTemp.Resize(dwSizeNeeded))
                {
                    IF_DEBUG(METABASE) {
                        DBGPRINTF((DBG_CONTEXT,
                            "Unable to create script mapping string\n"));
                    }
                    fRet = FALSE;
                    goto exit;
                }
            }


            pszTemp = (CHAR *)bufTemp.QueryPtr() + dwCurrentSize;

            // Copy the extension...
            memcpy(pszTemp, achExt, cchExt);
            pszTemp += cchExt;

            // ...and the comma...
            *pszTemp = ',';
            pszTemp++;

            // ...and the image, including the trailing NULL.
            memcpy(pszTemp, achImage, cchImage);

            // Now update our current size.
            dwCurrentSize = dwSizeNeeded;

        }

        i++;

    }

    mb.SetMultiSZ( "",
                  MD_SCRIPT_MAPS,
                  IIS_MD_UT_FILE,
                  (CHAR *)bufTemp.QueryPtr());

    //
    //  Enumerate all of the listed items in the registry
    //  and add them
    //

    *pszRoot = '/';
    tmpRoot = (PCHAR)pszRoot+1;
    i = 0;

    while ( TRUE ) {

        PCHAR pszComma;

        cchRoot = sizeof( pszRoot ) - 1;
        cchDir  = sizeof( pszDirectory );

        err = RegEnumValue( hkeyRoots,
                             i++,
                             tmpRoot,
                             &cchRoot,
                             NULL,
                             &dwRegType,
                             (LPBYTE) pszDirectory,
                             &cchDir );

        if ( err == ERROR_NO_MORE_ITEMS ) {
            break;
        }

        if ( dwRegType == REG_SZ ) {

            //
            //  The optional user name is kept after the directory.
            //  Only used for UNC roots, ignore for others
            //

            if ( pszUser = strchr( pszDirectory, ',' ) )
            {
                *pszUser = '\0';
                pszUser++;
            } else {
                pszUser = "";
            }

            //
            //  The optional access mask is kept after the user name.  It must
            //  appear in upper case hex.
            //

            if ( pszUser && (pszMask = strchr( pszUser, ',' )) ) {

                *pszMask = '\0';
                pszMask++;

                dwMask = hextointA( pszMask );
            } else {
                dwMask = VROOT_MASK_READ;
            }

            //
            // Remove commas from the root
            //

            pszComma = strchr(tmpRoot, ',');
            if ( pszComma != NULL ) {
                *pszComma = '\0';
            }

            //
            // Write it out to the metabase
            //

            //
            // This is the root
            //

            if ( !mb.AddObject( pszRoot ) &&
                 GetLastError() != ERROR_ALREADY_EXISTS )
            {
                 DBGPRINTF((DBG_CONTEXT,"AddMetaObject %s failed with %d\n",
                              pszRoot, GetLastError() ));
                goto exit;
            }

            //
            // Set Path
            //

            mb.SetString( pszRoot,
                          MD_VR_PATH,
                          IIS_MD_UT_FILE,
                          pszDirectory );

            //
            // Set Username
            //

            mb.SetString( pszRoot,
                          MD_VR_USERNAME,
                          IIS_MD_UT_FILE,
                          pszUser );

            //
            // Set Mask
            //

            mb.SetDword( pszRoot,
                         MD_ACCESS_PERM,
                         IIS_MD_UT_FILE,
                         dwMask );
        }

    } // while

    mb.Save();

    mb.Close();

exit:

    if ( hkeyRoots != NULL ) {
        RegCloseKey( hkeyRoots );
    }

    if ( hkeyExtMaps != NULL ) {
        RegCloseKey( hkeyExtMaps );
    }

    if ( hkey != NULL ) {
        RegCloseKey( hkey );
    }

    return fRet;
#else
    DBGPRINTF((DBG_CONTEXT,"MoveVrootFromRegToMD called!!!\n"));
    return(TRUE);
#endif

} // IIS_SERVER_INSTANCE::MoveVrootFromRegToMD


BOOL
TsCopyVrootToRegistry(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
{

    DWORD cch;
    DWORD err;
    HKEY hkey = (HKEY)pvContext;
    CHAR szValue[ MAX_PATH + UNLEN + 2 ];

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"CopyVrootToReg: Adding %s to registry\n",
            pvr->pszAlias));
    }

    cch = wsprintfA( szValue,
                     "%s,%s,%X",
                     pvr->pszPath,
                     pvr->pszUserName,
                     pvr->dwAccessPerm );

    DBG_ASSERT( cch < sizeof( szValue ) );

    err = WriteRegistryStringA(hkey,
                   pvr->pszAlias,
                   szValue,
                   strlen(szValue),
                   REG_SZ);

    DBG_ASSERT(err == NO_ERROR);

    return(TRUE);

} // TsCopyVrootToRegistry



BOOL
IIS_SERVER_INSTANCE::MoveMDVroots2Registry(
    VOID
    )
/*++

Routine Description:

    Moves MD VR entries to the registry if registry VR key
    does not exist at startup.

Arguments:

    None.

Return Value:

    None.

--*/
{

    HKEY hkey = NULL;
    HKEY hkeyRoots = NULL;
    DWORD dwDisp;
    DWORD err;
    BOOL  fMigrated = FALSE;

    MB mb( (IMDCOM*) m_Service->QueryMDObject()  );

    DBG_ASSERT(QueryInstanceId() == 1);

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Entering MoveMDToRegAtStartup.\n"));
    }

    //
    // see if the key exists
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        m_Service->QueryRegParamKey( ),
                        0,
                        KEY_ALL_ACCESS,
                        &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT,
            "RegOpenKeyEx %s returned error %d\n",
            m_Service->QueryRegParamKey(), err ));

        goto exit;
    }

    //
    // VR key?
    //

    err = RegCreateKeyEx( hkey,
                        VIRTUAL_ROOTS_KEY_A,
                        0,
                        NULL,
                        0,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkeyRoots,
                        &dwDisp );

    if ( err != NO_ERROR ) {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,
                "Error %d in RegCreateKeyEx\n",err));
        }

        goto exit;
    }

    if ( dwDisp == REG_OPENED_EXISTING_KEY ) {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,
                "Registry VR key found, aborting startup migration.\n"));
        }

        goto exit;
    }

    //
    // Get the MD handle to the VR root
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF((DBG_CONTEXT,"Open MD vr root returns %d\n",GetLastError()));
        goto exit;
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Opening MD path[%s]\n",QueryMDPath()));
    }

    TsRecursiveEnumVirtualRoots(
                    TsCopyVrootToRegistry,
                    hkeyRoots,
                    "IIS_MD_INSTANCE_ROOT/",
                    1,
                    (LPVOID)&mb,
                    TRUE );

    mb.Close();
    fMigrated = TRUE;

exit:

    if ( hkey != NULL ) {
        RegCloseKey(hkey);
    }

    if ( hkeyRoots != NULL ) {
        RegCloseKey(hkeyRoots);
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Leaving MoveMDToRegAtStartup.\n"));
    }
    return(fMigrated);

} // IIS_SERVER_INSTANCE::MoveMDVroots2Registry



VOID
IIS_SERVER_INSTANCE::PdcHackVRReg2MD(
    VOID
    )
/*++

Routine Description:

    Moves VR entries to the MD at startup.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD     err;
    CHAR      pszRoot[MAX_LENGTH_VIRTUAL_ROOT + MAX_LENGTH_ROOT_ADDR + 2];
    CHAR      pszDirectory[MAX_PATH + UNLEN + 3];

    CHAR *    pszUser;
    DWORD     cchRoot;
    DWORD     cchDir;
    DWORD     cch;
    BOOL      fRet = TRUE;
    DWORD     i = 0;
    DWORD     dwRegType;

    DWORD     dwMask;
    PCHAR     pszMask;
    PCHAR     tmpRoot;
    DWORD     dwAuthorization;
    DWORD     dwDirBrowse;
    STR       strFile;
    MB        mb( (IMDCOM*) m_Service->QueryMDObject()  );

    HKEY      hkey = NULL;
    HKEY      hkeyRoots = NULL;

    DBG_ASSERT(QueryInstanceId() == 1);

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"In MoveVrootFromRegToMD\n"));
    }

    //
    // see if the key exists
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        m_Service->QueryRegParamKey( ),
                        0,
                        KEY_ALL_ACCESS,
                        &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx returned error %d\n",err ));
        return;
    }

    //
    // VR key?
    //

    if ( err = RegOpenKeyEx( hkey,
                           VIRTUAL_ROOTS_KEY_A,
                           0,
                           KEY_ALL_ACCESS,
                           &hkeyRoots )) {

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"RegOpenKeyEx %s failed with %d\n",
                      VIRTUAL_ROOTS_KEY_A, err));
        }
        goto exit;
    }

    //
    // Key exists. Get the authorization key
    //

    {
        HKEY instanceKey;

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            QueryRegParamKey(),
                            0,
                            KEY_ALL_ACCESS,
                            &instanceKey );

        if ( err != NO_ERROR ) {
            goto exit;
        }

        dwAuthorization = ReadRegistryDword( instanceKey,
                                         INETA_AUTHENTICATION,
                                         INET_INFO_AUTH_ANONYMOUS );

        dwDirBrowse = ReadRegistryDword( hkey,
                                         "Dir Browse Control",
                                         0x4000001e );

        ReadRegistryStr( hkey,
                         strFile,
                         "Default Load File",
                         "Default.htm,Index.htm" );

        RegCloseKey( instanceKey );
    }

    //
    // Get the MD handle to the VR root
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF((DBG_CONTEXT,"Open MD vr root returns %d\n",GetLastError()));
        goto exit;
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Adding MD path[%s]\n",QueryMDPath()));
    }

    //
    //  Enumerate all of the listed items in the registry
    //  and add them
    //

    strcpy(pszRoot,IIS_MD_INSTANCE_ROOT);
    tmpRoot = (PCHAR)pszRoot+sizeof(IIS_MD_INSTANCE_ROOT) - 1;

    while ( TRUE ) {

        PCHAR pszComma;

        cchRoot = sizeof( pszRoot ) - 1;
        cchDir  = sizeof( pszDirectory );

        err = RegEnumValue( hkeyRoots,
                             i++,
                             tmpRoot,
                             &cchRoot,
                             NULL,
                             &dwRegType,
                             (LPBYTE) pszDirectory,
                             &cchDir );

        if ( err == ERROR_NO_MORE_ITEMS ) {
            break;
        }

        if ( dwRegType == REG_SZ ) {

            //
            //  The optional user name is kept after the directory.
            //  Only used for UNC roots, ignore for others
            //

            if ( pszUser = strchr( pszDirectory, ',' ) )
            {
                *pszUser = '\0';
                pszUser++;
            } else {
                pszUser = "";
            }

            //
            //  The optional access mask is kept after the user name.  It must
            //  appear in upper case hex.
            //

            if ( pszUser && (pszMask = strchr( pszUser, ',' )) ) {

                *pszMask = '\0';
                pszMask++;

                dwMask = hextointA( pszMask );
            } else {
                dwMask = VROOT_MASK_READ;
            }

            //
            // Remove commas from the root
            //

            pszComma = strchr(tmpRoot, ',');
            if ( pszComma != NULL ) {
                *pszComma = '\0';
                cchRoot--;
            }

            //
            // Write it out to the metabase
            //

            cchRoot++;

            //
            // This is the root
            //

            if ( !mb.AddObject( pszRoot ) )
            {
                 DBGPRINTF((DBG_CONTEXT,"AddMetaObject %s failed with %d\n",
                              pszRoot, GetLastError() ));
                continue;
            }

            //
            // Set Path
            //

            mb.SetString( pszRoot,
                          MD_VR_PATH,
                          IIS_MD_UT_FILE,
                          pszDirectory );

            //
            // Set Username
            //

            mb.SetString( pszRoot,
                          MD_VR_USERNAME,
                          IIS_MD_UT_FILE,
                          pszUser );

            //
            // Set Mask
            //

            mb.SetDword( pszRoot,
                         MD_ACCESS_PERM,
                         IIS_MD_UT_FILE,
                         dwMask );

            //
            // Set the default authorization requirements
            //

            mb.SetDword( pszRoot,
                         MD_AUTHORIZATION,
                         IIS_MD_UT_FILE,
                         dwAuthorization );

            //
            // Set the directory browsing control
            //

            mb.SetDword( pszRoot,
                         MD_DIRECTORY_BROWSING,
                         IIS_MD_UT_FILE,
                         dwDirBrowse );

            //
            // Set the default document
            //

            mb.SetString( pszRoot,
                          MD_DEFAULT_LOAD_FILE,
                          IIS_MD_UT_FILE,
                          strFile.QueryStr() );

        }

    } // while

    mb.Save();

    mb.Close();

exit:

    if ( hkeyRoots != NULL ) {
        RegCloseKey( hkeyRoots );
    }

    if ( hkey != NULL ) {
        RegCloseKey( hkey );
    }

    return;

} // IIS_SERVER_INSTANCE::PdcHackVRReg2MD


VOID
IIS_SERVER_INSTANCE::TsMirrorVirtualRoots(
    IN  LPIIS_INSTANCE_INFO_1   pConfig
    )
/*++
    Description:

        Writes the virtual roots specified in the config structure to the
        registry

    Arguments:
        pConfig - new list of virtual

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    DWORD               err;
    HKEY                hkey = NULL;
    HKEY                hkeyRoots = NULL;

    DWORD               dwDummy;
    LPINET_INFO_VIRTUAL_ROOT_LIST pRootsList;
    DWORD               cch;
    DWORD               i;

    DBG_ASSERT(QueryInstanceId() == 1);

    pRootsList = pConfig->VirtualRoots;

    //
    // Write it to the root key
    //

    err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    m_Service->QueryRegParamKey(),
                    0,
                    KEY_ALL_ACCESS,
                    &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx for returned error %d\n",err ));
        return;
    }

    //
    //  First delete the key to remove any old values
    //

    if (err = RegDeleteKey( hkey,
                            VIRTUAL_ROOTS_KEY_A ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[TsMirrorVRoots] Unable to remove old values\n"));

    }

    if ( err = RegCreateKeyEx( hkey,
                               VIRTUAL_ROOTS_KEY_A,
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hkeyRoots,
                               &dwDummy ))
    {
        goto exit;
    }

    //
    //  Permit empty list
    //

    if ( pRootsList == NULL ) {
        goto exit;
    }

    for ( i = 0; i < pRootsList->cEntries; i++ ) {

        WCHAR achValue[ MAX_PATH + UNLEN + 2 ];

        cch = wsprintfW( achValue,
                         L"%s,%s,%X",
                         pRootsList->aVirtRootEntry[i].pszDirectory,
                         pRootsList->aVirtRootEntry[i].pszAccountName,
                         pRootsList->aVirtRootEntry[i].dwMask );

        DBG_ASSERT( cch < sizeof( achValue ) / sizeof(WCHAR) );

        err = WriteRegistryStringW(hkeyRoots,
                       pRootsList->aVirtRootEntry[i].pszRoot,
                       achValue,
                       (wcslen(achValue) + 1) * sizeof(WCHAR),
                       REG_SZ);

        if ( err != NO_ERROR ) {
            goto exit;
        }
    }

exit:

    if ( hkeyRoots != NULL ) {
        RegCloseKey( hkeyRoots );
    }

    if ( hkey != NULL ) {
        RegCloseKey( hkey );
    }

    return;

} // IIS_SERVER_INSTANCE::TsMirrorVirtualRoots


VOID
ClearSentinelEntry(
    IN MB * pMB
    )
/*++
    Description:

        Removes the sentinel entry from all VR for this instance

    Arguments:
        pMD - pointer to metabase helper object that points to the
            instance metadatabase root.

    Returns:
        None.

--*/
{
    BOOL fGetRoot = TRUE;
    CHAR nameBuf[METADATA_MAX_NAME_LEN+2];
    DWORD i = 0;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Entering ClearSentinelEntry\n"));
    }

    while ( TRUE ) {

        METADATA_RECORD mdRecord;

        nameBuf[0] = nameBuf[1] = '/';

        if ( fGetRoot ) {

            fGetRoot = FALSE;
            nameBuf[2] = '\0';

        } else {

            if ( !pMB->EnumObjects( "IIS_MD_INSTANCE_ROOT/",
                                  &nameBuf[2],
                                  i++ ))
            {
                break;
            }
        }

        //
        // Delete sentinel value
        //

        if ( !pMB->DeleteData( nameBuf,
                            MD_VR_UPDATE,
                            IIS_MD_UT_FILE,
                            DWORD_METADATA
                            ))
        {
            IF_DEBUG(METABASE) {
                DBGPRINTF((DBG_CONTEXT,"Error %x deleting sentinel from %s\n",
                      GetLastError(), nameBuf));
            }
        }
    }

    return;

} // ClearSentinelEntry


VOID
RemoveUnmarkedRoots(
    IN MB * pMB
    )
/*++
    Description:

        Removes roots that are not marked by sentinel

    Arguments:
        pMD - pointer to metabase helper object that points to the
            instance metadatabase root.

    Returns:
        None.

--*/
{
    BOOL fGetRoot = TRUE;
    CHAR nameBuf[METADATA_MAX_NAME_LEN+sizeof(IIS_MD_INSTANCE_ROOT)];
    CHAR szDirectory[MAX_PATH+1];
    DWORD cb;
    DWORD i = 0;
    BOOL fProcessingRoot;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Entering RemoveUnmarkedRoots\n"));
    }

    while ( TRUE ) {

        strcpy(nameBuf, IIS_MD_INSTANCE_ROOT);
        nameBuf[sizeof(IIS_MD_INSTANCE_ROOT) - 1] = '/';

        if ( fGetRoot ) {

            fProcessingRoot = TRUE;
            fGetRoot = FALSE;
            nameBuf[2] = '\0';

        } else {

            fProcessingRoot = FALSE;
            if ( !pMB->EnumObjects( "IIS_MD_INSTANCE_ROOT",
                                  &nameBuf[sizeof(IIS_MD_INSTANCE_ROOT)],
                                  i++ ))
            {
                break;
            }
        }

        //
        // Delete sentinel value.  If delete successful, leave alone
        //

        if ( pMB->DeleteData( nameBuf,
                            MD_VR_UPDATE,
                            IIS_MD_UT_FILE,
                            DWORD_METADATA
                            ))
        {
            continue;
        }

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Error %x deleting sentinel from %s\n",
                  GetLastError(), nameBuf));
        }

        //
        // See if it has the path parameter
        //

        cb = sizeof( szDirectory );

        if ( !pMB->GetString( nameBuf,
                            MD_VR_PATH,
                            IIS_MD_UT_FILE,
                            szDirectory,
                            &cb,
                            0 ))
        {
            //
            // Not a VR
            //

            DBGPRINTF((DBG_CONTEXT,
                "Error %x reading path from %s. Not a VR.\n",
                      GetLastError(), nameBuf));
            continue;
        }

        //
        // Unmarked, delete the VR
        //

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Deleting vroot %s[%d]\n",
                nameBuf, fGetRoot));
        }

        if ( fProcessingRoot ) {

            //
            // if this is the root, just remove the path.  Deleting the
            // root is a potentially dangerous undertaking!
            //

            if ( !pMB->DeleteData( nameBuf,
                                MD_VR_PATH,
                                IIS_MD_UT_FILE,
                                STRING_METADATA
                                ))
            {
                DBGPRINTF((DBG_CONTEXT,"Error %x deleting root path\n",
                    GetLastError()));
            }

        } else {

            //
            // Delete the Vroot
            //

            if ( !pMB->DeleteObject( nameBuf ) )
            {
                DBGPRINTF((DBG_CONTEXT,"Error %x deleting %s\n",
                    GetLastError(), nameBuf));

            } else {

                //
                // the delete moved the index back by 1
                //

                --i;

                DBG_ASSERT( i >= 0 );
            }
        }

        fGetRoot = FALSE;
    }

    return;

} // RemoveUnmarkedRoots
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\beta2\instance.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        instance.cxx

   Abstract:

        Defines the functions for TCP services Info class.
        This module is intended to capture the common scheduler
            code for the tcp services ( especially internet services)
            which involves the Service Controller dispatch functions.
        Also this class provides an interface for common dll of servers.

   Author:

           Murali R. Krishnan    ( MuraliK )     15-Nov-1994

   Project:

          Internet Servers Common DLL

--*/


#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisbind.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"
#include <iiscnfg.h>
#include <imd.h>
#include <mb.hxx>

/************************************************************
 *    Symbolic Constants
 ************************************************************/

//
// LOCAL Functions
//

static ULONGLONG InetServiceIdForService( IN DWORD serviceId);

#define MAX_ADDRESSES_SUPPORTED           20
#define SIZEOF_IP_SEC_LIST( IPList )      (sizeof(INET_INFO_IP_SEC_LIST) + \
                                           (IPList)->cEntries *        \
                                           sizeof(INET_INFO_IP_SEC_ENTRY))


IIS_SERVER_INSTANCE::IIS_SERVER_INSTANCE(
        IN PIIS_SERVICE pService,
        IN DWORD  dwInstanceId,
        IN USHORT sPort,
        IN LPCSTR lpszRegParamKey,
        IN LPWSTR lpwszAnonPasswordSecretName,
        IN LPWSTR lpwszVirtualRootsSecretName,
        IN BOOL   fMigrateVroots
        )
/*++
    Desrcription:

        Contructor for IIS_SERVER_INSTANCE class.
        This constructs a new service info object for the service specified.

    Arguments:

        pService - pointer to the service object.

        dwInstanceId - Instance number of this instance.

        sPort - Default port number

        lpszRegParamKey
            fully qualified name of the registry key that contains the
            common service data for this server

        lpszAnonPasswordSecretName
            The name of the LSA secret the anonymous password is stored under

        lpszVirtualRootsSecretName
            The name of the LSA secret the virtual root passwords are stored
            under

    On success it initializes all the members of the object,
     inserts itself to the global list of service info objects and
     returns with success.

    Note:
        The caller of this function should check the validity by
        invoking the member function IsValid() after constructing
        this object.

--*/
:
    m_tslock              ( ),
    m_SecureBinding       ( NULL ),
    m_fZapRegKey          ( FALSE),
    m_fDoServerNameCheck  ( FALSE),
    m_reference           ( 0),
    m_sSecurePort         ( 0),
    m_sDefaultPort        ( sPort ),
    m_dwServerState       ( MD_SERVER_STATE_STOPPED),
    m_dwSavedState        ( MD_SERVER_STATE_STOPPED),
    m_Service             ( pService),
    m_instanceId          ( dwInstanceId),
    m_strParametersKey    ( lpszRegParamKey),
    m_dwAnonAcctDescLen   ( 0),
    m_cReadLocks          ( 0),
    m_strMDPath           ( ),
    m_strMDVirtualRootPath( ),
    m_dwMaxConnections    ( INETA_DEF_MAX_CONNECTIONS),
    m_dwMaxEndpointConnections( INETA_DEF_MAX_ENDPOINT_CONNECTIONS ),
    m_dwCurrentConnections( 0),
    m_dwConnectionTimeout ( INETA_DEF_CONNECTION_TIMEOUT),
    m_dwServerSize        ( INETA_DEF_SERVER_SIZE),
    m_nAcceptExOutstanding( INETA_DEF_ACCEPTEX_OUTSTANDING),
    m_AcceptExTimeout     ( INETA_DEF_ACCEPTEX_TIMEOUT),
    m_Logging( pService->QueryServiceName(), dwInstanceId ),
    m_dwLevelsToScan      ( INETA_DEF_LEVELS_TO_SCAN ),
    m_fAddedToServerInstanceList( FALSE )
{

    DBG_ASSERT( lpszRegParamKey != NULL );

    IF_DEBUG(INSTANCE) {
        DBGPRINTF( ( DBG_CONTEXT,"Creating iis instance %x[%u]. \n",
            this, dwInstanceId));
    }

    //
    // Limit PWS connections
    //

    if ( !TsIsNtServer() ) {
        m_dwMaxConnections = INETA_DEF_MAX_CONNECTIONS_PWS;
    }

    //
    // initialize locks
    //

    InitializeCriticalSection(&m_csLock);

    //
    // initialize binding support
    //

    InitializeListHead( &m_BindingListHead );

    //
    // reference the service
    //

    if ( !pService->CheckAndReference( )) {
        goto error_exit;
    }

    m_Service = pService;

    //
    // Set cache parameters
    //

    m_tsCache.SetParameters(
                pService->QueryServiceId(),
                dwInstanceId,
                this );

    //
    // Set the metadatabase path
    //

    if ( QueryInstanceId() == INET_INSTANCE_ROOT ) {

        DBG_ASSERT( FALSE );

    } else {

        CHAR szTemp[32];

        wsprintf(szTemp,"/%s/%s/%d",
            IIS_MD_LOCAL_MACHINE_PATH,
            pService->QueryServiceName(),
            QueryInstanceId());
        m_strMDPath.Copy(szTemp);

        wsprintf(szTemp,"/%s/%s/%d/%s/",
            IIS_MD_LOCAL_MACHINE_PATH,
            pService->QueryServiceName(),
            QueryInstanceId(),
            IIS_MD_INSTANCE_ROOT);
        m_strMDVirtualRootPath.Copy(szTemp);

        if ( fMigrateVroots ) {
            MoveVrootFromRegToMD();
        }

        if ( QueryInstanceId() == 1 ) {
            if ( !MoveMDVroots2Registry() ) {
                PdcHackVRReg2MD( );
            }
        }
    }

    //
    // Read common parameters.
    //

    if ( !RegReadCommonParams()  ) {
        goto error_exit;
    }

    //
    // Start logging
    //

    m_Logging.InitializeInstance( m_strMDPath.QueryStr(), m_Service->QueryMDObject() );
    m_Logging.CreateLog();
    m_Logging.Active();

    //
    // link this to the service
    //

    if ( dwInstanceId != INET_INSTANCE_ROOT ) {
        if ( !pService->AddServerInstance( this ) ) {
            DBG_ASSERT(m_reference == 0);
            goto error_exit;
        }
        DBG_ASSERT(m_reference == 1);
    }

    m_fAddedToServerInstanceList = TRUE;
    return;

error_exit:

    m_dwServerState = MD_SERVER_STATE_INVALID;
    DBG_ASSERT(m_reference == 0);
    return;

} // IIS_SERVER_INSTANCE::IIS_SERVER_INSTANCE()



IIS_SERVER_INSTANCE::~IIS_SERVER_INSTANCE( VOID)
/*++

    Description:

        Cleanup the instance object. If the service is not already
         terminated, it terminates the service before cleanup.

    Arguments:
        None

    Returns:
        None

--*/
{
    DBG_ASSERT(m_dwServerState != MD_SERVER_STATE_STARTED);
    DBG_ASSERT(m_reference == 0);

    //
    // start cleanup
    //

    DBG_REQUIRE( m_Logging.TerminateLogging());

    //
    //  If we failed to create this instance or it's getting deleted, remove
    //  the configuration tree
    //

    if ( m_fZapRegKey ) {
        DBGPRINTF((DBG_CONTEXT,"Zapping reg key for %x\n",this));
        ZapRegistryKey( NULL, QueryRegParamKey() );
        ZapInstanceMBTree( );
    }

    //
    // endpoints should have been dereferenced
    //

    DBG_ASSERT(m_SecureBinding == NULL);
    DBG_ASSERT(IsListEmpty( &m_BindingListHead ));

    //
    // dereference the service
    //

    if ( m_fAddedToServerInstanceList && m_Service != NULL ) {
        m_Service->Dereference( );
    }

    DeleteCriticalSection(&m_csLock);

} // IIS_SERVER_INSTANCE::~IIS_SERVER_INSTANCE()




# if DBG

VOID
IIS_SERVER_INSTANCE::Print( VOID) const
{
    IIS_SERVER_INSTANCE::Print();

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing IIS_SERVER_INSTANCE object ( %08x) \n"
                " State = %u.\n"
                ,
                this, m_dwServerState
                ));

    DBGPRINTF(( DBG_CONTEXT,
               " Server Admin Params: \n"
               " Log Anon = %u. Log NonAnon = %u.\n"
               ,
               m_fLogAnonymous, m_fLogNonAnonymous
               ));

    DBGPRINTF(( DBG_CONTEXT,
               " Printing IIS_SERVER_INSTANCE object (%08x)\n"
               " Readers # = %u.\n"
               " Reg Parameters Key = %s\n"
               " MaxConn = %d. ConnTimeout = %u secs.\n"
               ,
               this,
               m_cReadLocks,
               m_strParametersKey.QueryStr(),
               m_dwMaxConnections, m_dwConnectionTimeout
               ));
    return;
}   // IIS_SERVER_INSTANCE::Print()

#endif // DBG


VOID
IIS_SERVER_INSTANCE::ZapInstanceMBTree(
    VOID
    )
{

    MB  mb( (IMDCOM*) m_Service->QueryMDObject()  );

    //
    // Do the metabase
    //

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Deleting metabase node %s\n",
                  QueryMDPath()));
    }

    if ( !mb.Open( "/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Open MD instance root %s returns %d\n",
                      "/", GetLastError() ));
        }
        return;
    }

    //
    // Delete the instance tree
    //

    if ( !mb.DeleteObject( QueryMDPath() ))
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,
                      "Deleting instance node %s returns %d\n",
                      QueryMDPath(),
                      GetLastError()));
        }
    } else {

        mb.Save();
    }

    return;

} // IIS_SERVER_INSTANCE::ZapInstanceMBTree


DWORD
IIS_SERVER_INSTANCE::BindInstance(
    VOID
    )
/*++

Routine Description:

    Binds an instance to all configured endpoints (normal & secure).

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    DWORD err;

    //
    // Update the "normal" (i.e. non-secure) bindings.
    //

    err = UpdateNormalBindings();

    if( err != NO_ERROR ) {

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT, "UpdateNormalBindings() failed, %lu\n", err));
        }

        return err;

    }

    //
    // Update the secure bindings.
    //

    err = UpdateSecureBindings();

    if( err != NO_ERROR ) {

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT, "UpdateSecureBindings() failed, %lu\n", err));
        }

        //
        // The main port(s) are OK, but the SSL port(s) failed,
        // so start anyway.
        //

        err = NO_ERROR;

    }

    //
    // Success!
    //

    DBG_ASSERT( err == NO_ERROR );
    return NO_ERROR;

}   // IIS_SERVER_INSTANCE::BindInstance


DWORD
IIS_SERVER_INSTANCE::UnbindInstance(
    VOID
    )
/*++

Routine Description:

    Removes all bindings from an instance.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    PLIST_ENTRY listEntry;
    PIIS_SERVER_BINDING binding;

    LockThisForWrite();

    //
    // Walk the list of normal bindings and destroy them.
    //

    while( !IsListEmpty( &m_BindingListHead ) ) {

        listEntry = RemoveHeadList( &m_BindingListHead );

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "unbinding %lx from %lx, binding %lx (%lx:%d:%s)\n",
                binding->QueryEndpoint(),
                this,
                binding,
                binding->QueryIpAddress(),
                binding->QueryEndpoint()->QueryPort(),
                binding->QueryHostName()
                ));
        }

        binding->QueryEndpoint()->RemoveInstance(
            this,
            binding->QueryIpAddress(),
            binding->QueryHostName()
            );

        binding->QueryEndpoint()->Dereference();
        delete binding;

    }

    //
    // Remove from secure endpoint list if necessary.
    //

    if( m_SecureBinding != NULL ) {

        m_SecureBinding->QueryEndpoint()->RemoveInstance(
            this,
            m_SecureBinding->QueryIpAddress(),
            m_SecureBinding->QueryHostName()
            );

        m_SecureBinding->QueryEndpoint()->Dereference();
        delete m_SecureBinding;
        m_SecureBinding = NULL;

    }

    //
    // Success!
    //

    UnlockThis();
    return NO_ERROR;

}   // IIS_SERVER_INSTANCE::UnbindInstance


DWORD
IIS_SERVER_INSTANCE::UpdateNormalBindings(
    VOID
    )
/*++

Routine Description:

    Reads the normal binding list from the metabase and incorporates any
    changes into the current binding configuration.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    MB mb( (IMDCOM*)m_Service->QueryMDObject() );
    MULTISZ msz;
    DWORD status = NO_ERROR;
    const CHAR * scan;
    DWORD ipAddress;
    USHORT ipPort;
    const CHAR * hostName;
    PIIS_SERVER_BINDING binding;
    LIST_ENTRY createdBindings;
    PLIST_ENTRY listEntry;

    //
    // Setup locals.
    //

    InitializeListHead( &createdBindings );

    //
    // Open the metabase and get the current binding list.
    //

    if( mb.Open( QueryMDPath() ) ) {

        if( !mb.GetMultisz(
                "",
                MD_SERVER_BINDINGS,
                IIS_MD_UT_SERVER,
                &msz
                ) ) {

            status = GetLastError();

            if( status == MD_ERROR_DATA_NOT_FOUND ) {

                CHAR defaultBinding[sizeof(":65535:\0")];
                INT length;

                //
                // The bindings are not in the registry, so create
                // a default wildcard binding based on the default
                // port.
                //

                length = wsprintf(
                             defaultBinding,
                             ":%u:",
                             m_sDefaultPort
                             );

                length++;                           // account for terminator
                defaultBinding[length++] = '\0';    // add another terminator

                if( msz.Copy( defaultBinding, (DWORD)length ) ) {

                    status = NO_ERROR;

                } else {

                    status = GetLastError();

                }

            }

        }

        //
        // Close the metabase before continuing, as anyone that needs
        // to update the service status will need write access.
        //

        mb.Close();

    } else {

        status = GetLastError();

    }

    //
    // Lock the instance.
    //

    LockThisForWrite();

    //
    // Scan the multisz and look for instances we'll need to create.
    //

    if( status == NO_ERROR ) {

        for( scan = msz.First() ;
             scan != NULL ;
             scan = msz.Next( scan ) ) {

            //
            // Parse the descriptor (in "ip_address:port:host_name" form)
            // into its component parts.
            //

            status = IIS_SERVER_BINDING::ParseDescriptor(
                                             scan,
                                             &ipAddress,
                                             &ipPort,
                                             &hostName
                                             );

            if( status == NO_ERROR ) {

                //
                // See if the descriptor is in our current binding list.
                //

                if( !IsInCurrentBindingList(
                        ipAddress,
                        ipPort,
                        hostName
                        ) ) {

                    //
                    // It's not, so we need to create a new binding.
                    //

                    IF_DEBUG( INSTANCE ) {
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "Adding %lx:%d:%s\n",
                            ipAddress,
                            ipPort,
                            hostName
                            ));
                    }

                    DBG_CODE( binding = NULL );

                    status = CreateNewBinding(
                                 ipAddress,
                                 ipPort,
                                 hostName,
                                 FALSE,     // IsSecure
                                 &binding
                                 );

                    if( status == NO_ERROR ) {

                        //
                        // Add the new binding to the local list of
                        // newly created bindings.
                        //

                        DBG_ASSERT( binding != NULL );

                        InsertTailList(
                            &createdBindings,
                            &binding->m_BindingListEntry
                            );

                    } else {

                        //
                        // Could not create the new binding.
                        //

                        goto fatal;

                    }

                }

            } else {

                //
                // Could not parse the descriptor. We should probably
                // write something to the event log here.
                //

                DBGPRINTF((
                    DBG_CONTEXT,
                    "UpdateNormalBindings: could not parse %s, error %lu\n",
                    scan,
                    status
                    ));

                //
                // Press on regardless.
                //

                status = NO_ERROR;

            }

        }

    }

    //
    // Scan the existing bindings and look for those that need to
    // be deleted.
    //

    if( status == NO_ERROR ) {

        listEntry = m_BindingListHead.Flink;

        while( listEntry != &m_BindingListHead ) {

            binding = CONTAINING_RECORD(
                          listEntry,
                          IIS_SERVER_BINDING,
                          m_BindingListEntry
                          );

            listEntry = listEntry->Flink;

            if( !IsBindingInMultiSz(
                    binding,
                    msz
                    ) ) {

                //
                // Got one. Remove it from the instance list, dereference
                // the corresponding endpoint, then delete the binding.
                //

                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "zapping %lx from %lx, binding %lx (%lx:%d:%s)\n",
                        binding->QueryEndpoint(),
                        this,
                        binding,
                        binding->QueryIpAddress(),
                        binding->QueryEndpoint()->QueryPort(),
                        binding->QueryHostName()
                        ));
                }

                binding->QueryEndpoint()->RemoveInstance(
                    this,
                    binding->QueryIpAddress(),
                    binding->QueryHostName()
                    );

                RemoveEntryList(
                    &binding->m_BindingListEntry
                    );

                binding->QueryEndpoint()->Dereference();
                delete binding;

            }

        }

    }

    if( status == NO_ERROR ) {

        //
        // Move the newly created bindings over to the current binding
        // list.
        //

        m_BindingListHead.Blink->Flink = createdBindings.Flink;
        createdBindings.Flink->Blink = m_BindingListHead.Blink;
        createdBindings.Blink->Flink = &m_BindingListHead;
        m_BindingListHead.Blink = createdBindings.Blink;

    }

    UnlockThis();
    return status;

fatal:

    //
    // An unrecoverable error occurred, so loop through the local list
    // of newly created bindings and delete them.
    //

    DBG_ASSERT( status != NO_ERROR );

    while( !IsListEmpty( &createdBindings ) ) {

        listEntry = RemoveHeadList(
                        &createdBindings
                        );

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "zapping %lx from %lx, binding %lx (%lx:%d:%s) (ERROR)\n",
                binding->QueryEndpoint(),
                this,
                binding,
                binding->QueryIpAddress(),
                binding->QueryEndpoint()->QueryPort(),
                binding->QueryHostName()
                ));
        }

        binding->QueryEndpoint()->RemoveInstance(
            this,
            binding->QueryIpAddress(),
            binding->QueryHostName()
            );

        binding->QueryEndpoint()->Dereference();
        delete binding;

    }

    UnlockThis();
    return status;

}   // IIS_SERVER_INSTANCE::UpdateNormalBindings


DWORD
IIS_SERVER_INSTANCE::UpdateSecureBindings(
    VOID
    )
/*++

Routine Description:

    Reads the secure binding list from the metabase and incorporates any
    changes into the current binding configuration.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    MB mb( (IMDCOM*)m_Service->QueryMDObject() );
    DWORD securePort = 0;
    DWORD status = NO_ERROR;
    PIIS_SERVER_BINDING binding;

    //
    // Open the metabase and get the secure port.
    //

    if( mb.Open( QueryMDPath() ) ) {

        if( !mb.GetDword(
                "",
                MD_SECURE_PORT,
                IIS_MD_UT_SERVER,
                &securePort
                ) ) {
            securePort = 0;
        }

        //
        // Close the metabase before continuing, as anyone that needs
        // to update the service status will need write access.
        //

        mb.Close();

    } else {

        status = GetLastError();

    }

    //
    // Lock the instance.
    //

    LockThisForWrite();

    //
    // See if the secure port has changed.
    //

    if( status == NO_ERROR ) {

        if( ( m_SecureBinding == NULL && securePort != 0 ) ||
            ( m_SecureBinding != NULL &&
              !m_SecureBinding->Compare(
                   DEF_SECURE_IP_ADDRESS,
                   (USHORT)securePort,
                   DEF_SECURE_HOST_NAME
                   ) ) ) {

            //
            // Special case for new port == 0, meaning that the
            // we're disabling secure access to the instance.
            //

            if( securePort == 0 ) {
                binding = NULL;
                goto RemoveBinding;
            }

            //
            // Mismatch. Create a new binding.
            //

            status = CreateNewBinding(
                         DEF_SECURE_IP_ADDRESS,
                         (USHORT)securePort,
                         DEF_SECURE_HOST_NAME,
                         TRUE,      // IsSecure
                         &binding
                         );

            if( status == NO_ERROR ) {

RemoveBinding:

                if( m_SecureBinding != NULL ) {

                    m_SecureBinding->QueryEndpoint()->RemoveInstance(
                        this,
                        m_SecureBinding->QueryIpAddress(),
                        m_SecureBinding->QueryHostName()
                        );

                    m_SecureBinding->QueryEndpoint()->Dereference();
                    delete m_SecureBinding;

                }

                m_SecureBinding = binding;

            }

        }

    }

    UnlockThis();
    return status;

}   // IIS_SERVER_INSTANCE::UpdateSecureBindings


DWORD
IIS_SERVER_INSTANCE::CreateNewBinding(
    IN DWORD IpAddress,
    IN USHORT IpPort,
    IN const CHAR * HostName,
    IN BOOL IsSecure,
    OUT IIS_SERVER_BINDING ** NewBinding
    )
/*++

Routine Description:

    Creates a new binding object for the specified ip address, port, and
    host name, and creates/references the appropriate endpoint object.

Arguments:

    IpAddress - The binding IP address. May be INADDR_ANY.

    IpPort - The binding IP port. Required.

    HostName - The binding host name. May be empty ("").

    IsSecure - TRUE for secure endpoints. Only used if a new endpoint
        is created.

    NewBinding - Receives a pointer to the new binding object if successful.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    PIIS_ENDPOINT endpoint;
    PIIS_SERVER_BINDING binding;
    DWORD status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IpPort != 0 );
    DBG_ASSERT( HostName != NULL );
    DBG_ASSERT( NewBinding != NULL );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    endpoint = NULL;
    binding = NULL;

    //
    // Try to find an endpoint for the specified port.
    //

    endpoint = m_Service->FindAndReferenceEndpoint(
                   IpPort,
                   TRUE,        // CreateIfNotFound
                   IsSecure
                   );

    if( endpoint != NULL ) {

        //
        // Create a new binding.
        //

        binding = new IIS_SERVER_BINDING(
                          IpAddress,
                          IpPort,
                          HostName,
                          endpoint
                          );

        if( binding != NULL ) {

            if( endpoint->AddInstance(
                    this,
                    IpAddress,
                    HostName
                    ) ) {

                endpoint->Reference();
                *NewBinding = binding;
                status = NO_ERROR;

            } else {

                //
                // Could not associate the instance with the endpoint.
                //

                status = GetLastError();

            }

        } else {

            //
            // Could not create new binding object.
            //

            status = GetLastError();

        }

    } else {

        //
        // Could not find & reference endpoint.
        //

        status = GetLastError();

    }

    //
    // Remove the reference added in FindAndReferenceEndpoint().
    //

    if( endpoint != NULL ) {

        endpoint->Dereference();

    }

    //
    // Cleanup if necessary.
    //

    if( status != NO_ERROR ) {

        if( binding != NULL ) {

            delete binding;

        }

    }

    return status;

}   // IIS_SERVER_INSTANCE::CreateNewBinding


BOOL
IIS_SERVER_INSTANCE::IsInCurrentBindingList(
    IN DWORD IpAddress OPTIONAL,
    IN USHORT IpPort,
    IN const CHAR * HostName OPTIONAL
    )
/*++

Routine Description:

    Scans the current binding list looking for the specified IP address,
    port, and host name.

Arguments:

    IpAddress - The IP address to search for. May be INADDR_ANY.

    IpPort - The IP port to search for. Required.

    HostName - The host name to search for. May be empty ("").

Return Value:

    BOOL - TRUE if the binding was found, FALSE otherwise.

--*/
{

    PLIST_ENTRY listEntry;
    PIIS_SERVER_BINDING binding;

    //
    // Sanity check.
    //

    DBG_ASSERT( IpPort != 0 );
    DBG_ASSERT( HostName != NULL );

    //
    // Scan the bindings.
    //

    for( listEntry = m_BindingListHead.Flink ;
         listEntry != &m_BindingListHead ;
         listEntry = listEntry->Flink ) {

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        if( binding->Compare(
                IpAddress,
                IpPort,
                HostName
                ) ) {

            return TRUE;

        }

    }

    return FALSE;

}   // IIS_SERVER_INSTANCE::IsInCurrentBindingList


BOOL
IIS_SERVER_INSTANCE::IsBindingInMultiSz(
    IN PIIS_SERVER_BINDING Binding,
    IN const MULTISZ &msz
    )
/*++

Routine Description:

    Scans the specified MULTISZ object to see if it contains a descriptor
    matching the specified binding object.

Arguments:

    Binding - The binding to search for.

    msz - The MULTISZ to search.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    const CHAR * scan;
    DWORD status;
    BOOL result;

    //
    // Sanity check.
    //

    DBG_ASSERT( Binding != NULL );

    //
    // Scan the MULTISZ.
    //

    for( scan = msz.First() ;
         scan != NULL ;
         scan = msz.Next( scan ) ) {

        status = Binding->Compare( scan, &result );

        if( status == NO_ERROR && result ) {

            return TRUE;

        }

    }

    return FALSE;

}   // IIS_SERVER_INSTANCE::IsBindingInMultiSz


DWORD
IIS_SERVER_INSTANCE::PerformStateChange(
    VOID
    )
/*++

Routine Description:

    Reads the server instance state from the metabase and performs any
    necessary state changes.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    MB mb( (IMDCOM *)m_Service->QueryMDObject() );
    DWORD status;
    DWORD requestedState;
    DWORD currentState;
    DWORD serviceState;
    BOOL needToUpdateState;

    //
    // Setup locals.
    //

    status = NO_ERROR;
    needToUpdateState = TRUE;
    serviceState = m_Service->QueryCurrentServiceState();
    currentState = QueryServerState();

    //
    // Open the metabase and query the new state.
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ ) ) {

        if( !mb.GetDword(
                "",
                MD_SERVER_STATE,
                IIS_MD_UT_SERVER,
                &requestedState
                ) ) {

            status = GetLastError();

            IF_DEBUG( INSTANCE ) {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: cannot read server state, error %lu\n",
                    status
                    ));
            }

        }

        //
        // Close it so that code needed to update the metabase when
        // changing state can indeed open the metabase.
        //

        mb.Close();

    } else {

        status = GetLastError();

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "PerformStateChange: cannot open metabase for READ, error %lu\n",
                status
                ));
        }

    }

    //
    // Lock the instance.
    //

    LockThisForWrite();

    //
    // Interpret the state change.
    //

    if( status == NO_ERROR ) {

        switch( requestedState ) {

        case MD_SERVER_STATE_STARTING :

            //
            // Starting the service. If it's already running, there's
            // nothing to do. If it's stopped, then start it. If it's
            // in any other state, this is an invalid state transition.
            //
            // Note that the *service* must be running before an instance
            // can be started.
            //

            if( currentState == MD_SERVER_STATE_STARTED ) {

                break;

            } else
            if( serviceState == SERVICE_RUNNING &&
                currentState == MD_SERVER_STATE_STOPPED ) {

                status = StartInstance( &currentState );

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot start instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid state transition: %lu to %lu\n",
                    currentState,
                    requestedState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_STATE_STOPPING :

            //
            // Stopping the service. If it's already stopped, there's
            // nothing to do. If it's running or paused, then start it.
            // If it's in any other state, this is an invalid state
            // transition.
            //
            // Note that the *service* must be either running or paused
            // before an instance can be paused.
            //

            if( currentState == MD_SERVER_STATE_STOPPED ) {

                break;

            } else
            if( ( serviceState == SERVICE_RUNNING ||
                  serviceState == SERVICE_PAUSED ) &&
                ( currentState == MD_SERVER_STATE_STARTED ||
                  currentState == MD_SERVER_STATE_PAUSED ) ) {

                status = StopInstance( &currentState );

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot stop instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid state transition: %lu to %lu\n",
                    currentState,
                    requestedState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_STATE_PAUSING :

            //
            // Pausing the service. If it's already paused, there's
            // nothing to do. If it's running, then pause it. If it's
            // in any other state, this is an invalid state transition.
            //
            // Note that the *service* must be running before an instance
            // can be paused.
            //

            if( currentState == MD_SERVER_STATE_PAUSED ) {

                break;

            } else
            if( serviceState == SERVICE_RUNNING &&
                currentState == MD_SERVER_STATE_STARTED ) {

                status = PauseInstance( &currentState );

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot pause instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid state transition: %lu to %lu\n",
                    currentState,
                    requestedState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_STATE_CONTINUING :

            //
            // Continuing the service. If it's already running, there's
            // nothing to do. If it's paused, then continue it. If it's
            // in any other state, this is an invalid state transition.
            //
            // Note that the *service* must be running before an instance
            // can be continued.
            //

            if( currentState == MD_SERVER_STATE_STARTED ) {

                break;

            } else
            if( serviceState == SERVICE_RUNNING &&
                currentState == MD_SERVER_STATE_PAUSED ) {

                status = ContinueInstance( &currentState );

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot continue instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid state transition: %lu to %lu\n",
                    currentState,
                    requestedState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_STATE_STARTED :
        case MD_SERVER_STATE_STOPPED :
        case MD_SERVER_STATE_PAUSED :

            if( currentState == requestedState ) {

                //
                // This is a false notification; ignore it.
                //

                needToUpdateState = FALSE;

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid state transition: %lu to %lu\n",
                    currentState,
                    requestedState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }

            break;

        default :
            DBGPRINTF((
                DBG_CONTEXT,
                "PerformStateChange: invalid state %lu\n",
                requestedState
                ));

            status = ERROR_INVALID_SERVICE_CONTROL;
            break;

        }

    } else {

        DBGPRINTF((
            DBG_CONTEXT,
            "PerformStateChange: cannot read metabase, error %lu\n",
            status
            ));

    }

    //
    // Unlock the instance before trying to reopen the metabase.
    //

    UnlockThis();

    if( needToUpdateState ) {

        //
        // Update the server state and completion status.
        //

        SetServerState( currentState, status );

    }

    return status;

}   // IIS_SERVER_INSTANCE::PerformStateChange


VOID
IIS_SERVER_INSTANCE::SetServerState(
    IN DWORD NewState,
    IN DWORD Win32Error
    )
/*++

Routine Description:

    Sets the new server state, storing it locally and also storing the
    new state in the metabase.

Arguments:

    NewState - The new server state.

    Win32Error - New Win32 error value.

Return Value:

    None.

--*/
{

    DWORD status = NO_ERROR;
    MB mb( (IMDCOM *)m_Service->QueryMDObject() );

    //
    // Open the metabase and save the new state. Note that we map
    // MD_SERVER_STATE_INVALID to MD_SERVER_STATE_STOPPED in the metabase.
    // Client applications would probably be confused by the _INVALID state.
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {

        if( !mb.SetDword(
                "",
                MD_WIN32_ERROR,
                IIS_MD_UT_SERVER,
                Win32Error
                ) ||
            !mb.SetDword(
                "",
                MD_SERVER_STATE,
                IIS_MD_UT_SERVER,
                NewState == MD_SERVER_STATE_INVALID
                    ? MD_SERVER_STATE_STOPPED
                    : NewState
                ) ) {

            status = GetLastError();

        }

    } else {

        status = GetLastError();

    }

    if( status != NO_ERROR ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "SetServerState: cannot write metabase (%lu), error %lu\n",
            NewState,
            status
            ));

    }

    //
    // Save it in the object also.
    //

    m_dwServerState = NewState;

}   // IIS_SERVER_INSTANCE::SetServerState


BOOL
IIS_SERVER_INSTANCE::CloseInstance(
    VOID
    )
/*++

Routine Description:

    Shuts down instance

Arguments:

    None

Return Value:

    TRUE if Shutdown successful,
    FALSE otherwise

--*/
{

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::Close called for %x\n",
            this
            ));
    }

    (VOID)m_Service->DisassociateInstance( this );
    return TRUE;

} // IIS_SERVER_INSTANCE::CloseInstance


DWORD
IIS_SERVER_INSTANCE::StartInstance(
    LPDWORD NewState
    )
/*++

Routine Description:

    Sets instance to RUNNING

Arguments:

    NewState - Receives the new state.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD status;

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::StartInstance called for %x. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_STOPPED );

    //
    // Bind the instance.
    //

    status = BindInstance();

    if( status == NO_ERROR ) {

        //
        // Update the server state.
        //

        *NewState = MD_SERVER_STATE_STARTED;

    }

    return status;

} // IIS_SERVER_INSTANCE::StartInstance


DWORD
IIS_SERVER_INSTANCE::StopInstance(
    LPDWORD NewState
    )
/*++

Routine Description:

    Sets instance to STOPPED

Arguments:

    NewState - Receives the new state.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{
    DWORD status;

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::StopInstance called for %x. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_STARTED ||
                QueryServerState() == MD_SERVER_STATE_PAUSED );

    //
    // Set the state to STOPPED *before* unbinding to prevent a
    // race condition with incoming connections.
    //
    // Note that we call DisconnectUsersByInstance() before *and* after
    // unbinding the instance. This is to prevent a potential race condition
    // that can occur if another thread is already in IIS_ENDPOINT::
    // FindAndReferenceInstance(), has found the instance, checked its state,
    // and found it to be MD_SERVER_STATE_STARTED. The call to UnbindInstance()
    // will lock any affected endpoints, ensuring that there are no other
    // threads in the midst of a FindAndReferenceInstance(). The second
    // (seemingly redundant) call to DisconnectUsersByInstance() will catch
    // any threads that "snuck in" under these conditions.
    //

    m_dwServerState = MD_SERVER_STATE_STOPPED;

    status = m_Service->DisconnectUsersByInstance( this );

    if( status == NO_ERROR ) {
        status = UnbindInstance();
    }

    if( status == NO_ERROR ) {
        status = m_Service->DisconnectUsersByInstance( this );
    }

    if( status == NO_ERROR ) {
        *NewState = MD_SERVER_STATE_STOPPED;
        m_dwSavedState = MD_SERVER_STATE_STOPPED;
    }

    return status;

} // IIS_SERVER_INSTANCE::StopInstance


DWORD
IIS_SERVER_INSTANCE::PauseInstance(
    LPDWORD NewState
    )
/*++

Routine Description:

    Sets instance to PAUSE

Arguments:

    NewState - Receives the new state.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{
    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::Pause called for %x. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_STARTED );
    *NewState = MD_SERVER_STATE_PAUSED;
    return NO_ERROR;

} // IIS_SERVER_INSTANCE::PauseInstance


DWORD
IIS_SERVER_INSTANCE::ContinueInstance(
    LPDWORD NewState
    )
/*++

Routine Description:

    Sets instance to STARTED.

Arguments:

    NewState - Receives the new state.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{
    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::Continue called for %x. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_PAUSED );
    *NewState = MD_SERVER_STATE_STARTED;
    return NO_ERROR;

} // IIS_SERVER_INSTANCE::ContinueInstance


VOID
IIS_SERVER_INSTANCE::SetWin32Error(
    DWORD err
    )
{

    MB mb( (IMDCOM *)m_Service->QueryMDObject() );
    DWORD status = NO_ERROR;

    //
    // Open the metabase and save the error code.
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {

        if( !mb.SetDword(
                "",
                MD_WIN32_ERROR,
                IIS_MD_UT_SERVER,
                err
                ) ) {

            status = GetLastError();

        }

    } else {

        status = GetLastError();

    }

    if( status != NO_ERROR ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "SetWin32Error: cannot save error %lu (%lx), error %lx\n",
            err,
            err,
            status
            ));

    }

}   // IIS_SERVER_INSTANCE::SetWin32Error
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\common\beta2\tsvccfg.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        tsvccfg.cxx

   Abstract:

        Defines the functions for TCP services Info class.
        This module is intended to capture the common scheduler
            code for the tcp services ( especially internet services)
            which involves the Service Controller dispatch functions.
        Also this class provides an interface for common dll of servers.

   Author:

           Murali R. Krishnan    ( MuraliK )     15-Nov-1994

   Project:

          Internet Servers Common DLL

--*/

#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <iisbind.hxx>
#include <iisassoc.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"
#include <iiscnfg.h>
#include <rdns.hxx>

#include <ole2.h>
#include <imd.h>
#include <inetreg.h>
#include <mb.hxx>

//
// Used to configure
//

typedef struct _IIS_SOCKET_CONFIG {
    DWORD nAcceptExOutstanding;
} IIS_SOCKET_CONFIG;
IIS_SOCKET_CONFIG TsSocketConfig[3] = {{5}, {40}, {100}};

//
// from security.cxx
//

BOOL
BuildAnonymousAcctDesc(
    IN  OUT PCHAR        pszAcctDesc,
    IN  const CHAR *     pszDomainAndUser,
    IN  const CHAR *     pszPwd,
    OUT LPDWORD          pdwAcctDescLen
    );

BOOL
AppendDottedDecimal(
    STR * pstr,
    DWORD dwAddress
    );

//
// private functions
//

extern VOID
CopyUnicodeStringToBuffer(
   OUT WCHAR * pwchBuffer,
   IN  DWORD   cchMaxSize,
   IN  LPCWSTR pwszSource
   );


DWORD
SetInetLogConfiguration(
        IN LOGGING *pLogging,
        IN EVENT_LOG * pEventLog,
        IN const INET_LOG_CONFIGURATION * pRpcLogConfig
        );

DWORD
GetRPCLogConfiguration(
        LOGGING *pLogging,
        OUT LPINET_LOG_CONFIGURATION * ppLogConfig
        );

BOOL
GenerateIpList(
    BOOL fIsGrant,
    ADDRESS_CHECK *pCheck,
    LPINET_INFO_IP_SEC_LIST *ppInfo
    );

BOOL
FillAddrCheckFromIpList(
    BOOL fIsGrant,
    LPINET_INFO_IP_SEC_LIST pInfo,
    ADDRESS_CHECK *pCheck
    );

BOOL
GetVrootCount(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

BOOL
GetVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

VOID
CopyUnicodeStringToBuffer(
   OUT WCHAR * pwchBuffer,
   IN  DWORD   cchMaxSize,
   IN  LPCWSTR pwszSource)
/*
   copies at most cbMaxSize-1 characters from pwszSource to pwchBuffer
*/
{
    DBG_ASSERT( pwszSource != NULL);

    DWORD cchLen = lstrlenW( pwszSource);
    if ( cchLen >= cchMaxSize) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Long String ( %d chars) %ws given."
                    " Truncating to %d chars\n",
                    cchLen, pwszSource,
                    cchMaxSize - 1));


    //  There is a bug in the lstrcpyn. hence need to work around it.
#ifndef  LSTRCPYN_DEBUGGED
        cchLen = cchMaxSize - 2;
# else
       cchLen = cchMaxSize -1;
# endif
    }

#ifndef  LSTRCPYN_DEBUGGED
    lstrcpynW( pwchBuffer, pwszSource, cchLen + 1);
# else
    lstrcpynW( pwchBuffer, pwszSource, cchLen );
# endif

    return;
} // CopyUnicodeStringToBuffer()




BOOL
IIS_SERVER_INSTANCE::GetCommonConfig(
                                IN OUT PCHAR pConfig,
                                IN DWORD dwLevel
                                )
/*++
  This function copies the current configuration for a service (IIS_SERVER_INSTANCE)
    into the given RPC object pConfig.
  In case of any failures, it deallocates any memory block that was
     allocated during the process of copy by this function alone.

  Arguments:
     pConfig  - pointer to RPC configuration object for a service.
     dwLevel  - level of our configuration.

  Returns:

     TRUE for success and FALSE for any errors.
--*/
{
    BOOL fReturn = TRUE;
    LPIIS_INSTANCE_INFO_1 pInfoConfig = (LPIIS_INSTANCE_INFO_1)pConfig;
    ADDRESS_CHECK       acCheck;
    BOOL                fMustRel;
    MB                  mb( (IMDCOM*) m_Service->QueryMDObject() );
    DWORD               cRoots = 0;
    STR                 strAnon;
    STR                 strAnonPwd;
    STR                 strServerComment;

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((DBG_CONTEXT,"GetCommonConfig called with L%d for instance %d\n",
            dwLevel, QueryInstanceId() ));
    }

    LockThisForRead();

    if ( dwLevel == 2 ) {

        LPIIS_INSTANCE_INFO_2 pInfo2 = (LPIIS_INSTANCE_INFO_2)pConfig;
        pInfo2->FieldControl = FC_INET_INFO_ALL;
        pInfo2->dwInstance = QueryInstanceId( );

        //
        // HACK: Map MD_SERVER_STATE_* to IIS_SERVER_*.
        //

        switch( QueryServerState() ) {
        case MD_SERVER_STATE_STARTING:
        case MD_SERVER_STATE_STARTED:
        case MD_SERVER_STATE_CONTINUING:
            pInfo2->dwServerState = IIS_SERVER_RUNNING;
            break;

        case MD_SERVER_STATE_STOPPING:
        case MD_SERVER_STATE_STOPPED:
            pInfo2->dwServerState = IIS_SERVER_STOPPED;
            break;

        case MD_SERVER_STATE_PAUSING:
        case MD_SERVER_STATE_PAUSED:
            pInfo2->dwServerState = IIS_SERVER_PAUSED;
            break;

        default:
            pInfo2->dwServerState = IIS_SERVER_INVALID;
            break;
        }

        pInfo2->sSecurePort         = QuerySecurePort();

        (VOID)ConvertStringToRpc( &pInfo2->lpszServerName,
                                  ""); //QueryServerName());
//        (VOID)ConvertStringToRpc( &pInfo2->lpszHostName,
//                                  ""); //QueryHostName());

        UnlockThis();
        return(TRUE);
    }

    //
    //  Get always retrieves all of the parameters except for the anonymous
    //  password, which is retrieved as a secret
    //

    pInfoConfig->FieldControl = (FC_INET_INFO_ALL & ~FC_INET_INFO_ANON_PASSWORD);

    pInfoConfig->dwInstance          = QueryInstanceId( );
    pInfoConfig->dwConnectionTimeout = QueryConnectionTimeout();
    pInfoConfig->dwMaxConnections    = QueryMaxConnections();
    pInfoConfig->fAutoStart          = IsAutoStart();

    pInfoConfig->LangId              = GetSystemDefaultLangID();
    pInfoConfig->LocalId             = GetSystemDefaultLCID();

    //
    //  This is the PSS product ID
    //

    ZeroMemory( pInfoConfig->ProductId,sizeof( pInfoConfig->ProductId ));

    //
    //  Copy the strings
    //

    fReturn = (ConvertStringToRpc(&pInfoConfig->lpszAdminName,
                                  ""/*QueryAdminName()*/ )           &&
               ConvertStringToRpc( &pInfoConfig->lpszAdminEmail,
                                  "" /*QueryAdminEmail()*/ )          &&
//               ConvertStringToRpc( &pInfoConfig->lpszHostName,
//                                  "" /*QueryHostName()*/ )        &&
               ConvertStringToRpc( &pInfoConfig->lpszServerName,
                                  "" /*QueryServerName()*/) &&
               ConvertStringToRpc( &pInfoConfig->lpszDefBasicAuthDomain,
                                  "" /*QueryDefaultLogonDomain()*/)
               );

    if ( !fReturn ) {

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT,"ConvertStringToRpc failed with %d\n",
                GetLastError() ));
        }

        goto Exit;
    } else {

        DWORD dwError;

        dwError = GetRPCLogConfiguration(&m_Logging,
                                         &pInfoConfig->lpLogConfig);

        if ( pInfoConfig->lpLogConfig != NULL )
        {
            // convert the structure to RPC
        }

        if ( dwError != NO_ERROR)  {

            IF_DEBUG(INSTANCE) {
                DBGPRINTF((DBG_CONTEXT,"GetRPCLogConfiguration failed with %d\n",
                    dwError));
            }
            SetLastError( dwError);
            fReturn = FALSE;
            goto Exit;
        }
    }

    pInfoConfig->fLogAnonymous       = QueryLogAnonymous();
    pInfoConfig->fLogNonAnonymous    = QueryLogNonAnonymous();

    pInfoConfig->sSecurePort         = QuerySecurePort();

    ZeroMemory(
        pInfoConfig->szAnonPassword,
        sizeof( pInfoConfig->szAnonPassword )
        );

    //
    //  Copy the IP security info from metabase
    //

    if ( mb.Open( QueryMDVRPath() ) )
    {
        VOID * pvData;
        DWORD  cbData;
        DWORD  dwTag;

        if ( mb.ReferenceData( "",
                               MD_IP_SEC,
                               IIS_MD_UT_FILE,
                               BINARY_METADATA,
                               &pvData,
                               &cbData,
                               &dwTag ) &&
             dwTag )
        {
            acCheck.BindCheckList( (BYTE *) pvData, cbData );
            fMustRel = TRUE;
        }
        else
        {
            fMustRel = FALSE;
        }

        fReturn = GenerateIpList( TRUE, &acCheck, &pInfoConfig->GrantIPList ) &&
                  GenerateIpList( FALSE, &acCheck, &pInfoConfig->DenyIPList );

        if ( fMustRel )
        {
            DBG_REQUIRE( mb.ReleaseReferenceData( dwTag ));
        }

        DBG_REQUIRE( mb.Close() );
    }
    else
    {
        fReturn = FALSE;
    }

    if ( !fReturn )
    {
        goto Exit;
    }

    //
    //  Copy the virtual root info, note a NULL VirtualRoots is not
    //  valid as it is for IP security.  This should be the last
    //  allocated item for the pConfig structure
    //

    if ( TsEnumVirtualRoots( GetVrootCount, &cRoots ) )
    {
        DWORD cbSize = sizeof(INET_INFO_VIRTUAL_ROOT_LIST) +
                       cRoots * sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY)
                       ;
        pInfoConfig->VirtualRoots = (LPINET_INFO_VIRTUAL_ROOT_LIST)
                 MIDL_user_allocate( cbSize );

        memset( pInfoConfig->VirtualRoots, 0, cbSize );

        if ( pInfoConfig->VirtualRoots )
        {
            fReturn = TsEnumVirtualRoots( GetVroots, pInfoConfig->VirtualRoots );
        }
    }

    if ( !fReturn )
    {
        goto Exit;
    }

    if ( !mb.Open( QueryMDPath() ))
    {
        fReturn = FALSE;
        goto Exit;
    }

    if ( !mb.GetDword( "",
                       MD_AUTHORIZATION,
                       IIS_MD_UT_FILE,
                       &pInfoConfig->dwAuthentication ))
    {
        pInfoConfig->dwAuthentication = MD_AUTH_ANONYMOUS;
    }

    if ( !mb.GetStr( "",
                     MD_ANONYMOUS_USER_NAME,
                     IIS_MD_UT_FILE,
                     &strAnon,
                     METADATA_INHERIT,
                     "<>" ))
    {
        fReturn = FALSE;
        goto Exit;
    }

    if ( !mb.GetStr( "",
                     MD_SERVER_COMMENT,
                     IIS_MD_UT_SERVER,
                     &strServerComment,
                     METADATA_INHERIT,
                     INETA_DEF_SERVER_COMMENT ))
    {
        //
        // If this is a single instance service, this is also the
        // service comment
        //

        if ( !m_Service->IsMultiInstance() ) {
            m_Service->SetServiceComment( strServerComment.QueryStr() );
        }
    }

    fReturn = ConvertStringToRpc( &pInfoConfig->lpszServerComment,
                                  strServerComment.QueryStr() ) &&
              ConvertStringToRpc( &pInfoConfig->lpszAnonUserName,
                                  strAnon.QueryStr() );

    //
    //  Get the anonymous user password but store it as an LSA secret
    //

    if ( mb.GetStr( "",
                    MD_ANONYMOUS_PWD,
                    IIS_MD_UT_FILE,
                    &strAnonPwd,
                    METADATA_INHERIT | METADATA_SECURE ))
    {
#if 0
        fReturn = SetSecret( QueryService()->QueryAnonSecret,
                             strAnonPwd.QueryStr() );
#endif
    }

    if ( !fReturn ) {
        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT,"Cannot get anonymous user name"));
        }
    }

Exit:

    if ( !fReturn ) {

        if ( pInfoConfig->lpLogConfig != NULL) {

            MIDL_user_free( pInfoConfig->lpLogConfig);
            pInfoConfig->lpLogConfig = NULL;
        }

        //
        //  FreeRpcString checks for NULL pointer
        //

        FreeRpcString( pInfoConfig->lpszAdminName );
        FreeRpcString( pInfoConfig->lpszAdminEmail );
        FreeRpcString( pInfoConfig->lpszServerComment );
//        FreeRpcString( pInfoConfig->lpszHostName );
        FreeRpcString( pInfoConfig->lpszAnonUserName );

        if ( pInfoConfig->DenyIPList ) {

            MIDL_user_free( pInfoConfig->DenyIPList );
            pInfoConfig->DenyIPList = NULL;
        }

        if ( pInfoConfig->GrantIPList ) {
            MIDL_user_free( pInfoConfig->GrantIPList );
            pInfoConfig->GrantIPList = NULL;
        }
    }

    UnlockThis();

    return (fReturn);

} // IIS_SERVER_INSTANCE::GetConfiguration()



BOOL
IIS_SERVER_INSTANCE::RegReadCommonParams(
    BOOL fReadVirtualDirs
    )
/*++

   Description

     Reads the service common items from the registry

   Arguments:

   Note:

--*/
{
    MB                      mb( (IMDCOM*) m_Service->QueryMDObject()  );

    DBG_ASSERT( QueryInstanceId() != INET_INSTANCE_ROOT );

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF(( DBG_CONTEXT,
                   "IIS_SERVER_INSTANCE::ReadParamsFromRegistry() Entered\n"));
    }

    //
    // Open the metabase and read parameters for IIS_SERVER_INSTANCE object
    // itself.
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )) {

        DBGPRINTF(( DBG_CONTEXT,
                   "[ReadParamsFromRegistry] mb.Open returned error %d for path %s\n",
                    GetLastError(),
                    QueryMDPath() ));

#if 1   // Temporary until setup writes values to the metabase - Note this case
        // happens when the default instance is created and the metabase doesn't
        // exist yet - thus /LM/W3Svc/ doesn't exist.  This creates both the
        // default instance and the first real server instance.
        //
        if ( !mb.Open( METADATA_MASTER_ROOT_HANDLE,
                       METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ||
             !mb.AddObject( "/LM/W3SVC" ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[ReadParamsFromRegistry] Unable to create meta path, error %d\n",
                        GetLastError() ));

            return FALSE;
        }
#else
        return FALSE;
#endif
    }

    LockThisForWrite();

    if ( !mb.GetDword( "",
                       MD_CONNECTION_TIMEOUT,
                       IIS_MD_UT_SERVER,
                       &m_dwConnectionTimeout )) {

        m_dwConnectionTimeout = INETA_DEF_CONNECTION_TIMEOUT;
    }

    if ( !mb.GetDword( "",
                       MD_MAX_CONNECTIONS,
                       IIS_MD_UT_SERVER,
                       &m_dwMaxConnections )) {

        m_dwMaxConnections = INETA_DEF_MAX_CONNECTIONS;
    }

    if ( !mb.GetDword( "",
                       MD_MAX_ENDPOINT_CONNECTIONS,
                       IIS_MD_UT_SERVER,
                       &m_dwMaxEndpointConnections )) {

        m_dwMaxEndpointConnections = INETA_DEF_MAX_ENDPOINT_CONNECTIONS;
    }

    if ( !mb.GetDword( "",
                       MD_LEVELS_TO_SCAN,
                       IIS_MD_UT_SERVER,
                       &m_dwLevelsToScan )) {

        m_dwLevelsToScan = INETA_DEF_LEVELS_TO_SCAN;
    }

    //
    // if not NTS, limit the connections.  If reg value exceeds 40,
    // set it to 10.
    //

    if ( !TsIsNtServer() ) {

        if ( m_dwMaxConnections > INETA_MAX_MAX_CONNECTIONS_PWS ) {
            m_dwMaxConnections = INETA_DEF_MAX_CONNECTIONS_PWS;
        }

        if ( m_dwMaxEndpointConnections > INETA_MAX_MAX_ENDPOINT_CONNECTIONS_PWS ) {
            m_dwMaxEndpointConnections = INETA_DEF_MAX_ENDPOINT_CONNECTIONS_PWS;
        }
    }

    //
    //  Log anonymous and Log non-anonymous or for FTP only
    //

    if ( !mb.GetDword( "",
                       MD_LOG_ANONYMOUS,
                       IIS_MD_UT_SERVER,
                       (DWORD *) &m_fLogAnonymous )) {

        m_fLogAnonymous = INETA_DEF_LOG_ANONYMOUS;
    }

    if ( !mb.GetDword( "",
                       MD_LOG_NONANONYMOUS,
                       IIS_MD_UT_SERVER,
                       (DWORD *) &m_fLogNonAnonymous )) {

        m_fLogNonAnonymous = INETA_DEF_LOG_NONANONYMOUS;
    }

    DWORD dwSPort;
    if ( !mb.GetDword( "",
                       MD_SECURE_PORT,
                       IIS_MD_UT_SERVER,
                       &dwSPort )) {

        dwSPort = 0;
    }

    m_sSecurePort = (USHORT) dwSPort;

    if ( !mb.GetDword( "",
                       MD_SERVER_AUTOSTART,
                       IIS_MD_UT_SERVER,
                       (DWORD *) &m_fAutoStart )) {

        m_fAutoStart = TRUE;
    }

    //
    // Take this opportunity to write a reasonable initial server
    // state into the metabase.
    //

    if( !mb.SetDword( "",
                      MD_SERVER_STATE,
                      IIS_MD_UT_SERVER,
                      MD_SERVER_STATE_STOPPED )) {

        DBGPRINTF((
            DBG_CONTEXT,
            "RegReadCommonParams: cannot set server state, error %lu [ignoring]\n",
            GetLastError()
            ));

    }

    if( !mb.SetDword( "",
                      MD_WIN32_ERROR,
                      IIS_MD_UT_SERVER,
                      NO_ERROR )) {

        DBGPRINTF((
            DBG_CONTEXT,
            "RegReadCommonParams: cannot set win32 status, error %lu [ignoring]\n",
            GetLastError()
            ));

    }

    //
    //  Other fields
    //

    //
    // socket values
    //

    if ( !mb.GetDword( "",
                       MD_SERVER_SIZE,
                       IIS_MD_UT_SERVER,
                       &m_dwServerSize )) {

        m_dwServerSize = INETA_DEF_SERVER_SIZE;
    }

    if ( m_dwServerSize > MD_SERVER_SIZE_LARGE ) {
        m_dwServerSize = INETA_DEF_SERVER_SIZE;
    }

    if ( !mb.GetDword( "",
                       MD_SERVER_LISTEN_BACKLOG,
                       IIS_MD_UT_SERVER,
                       &m_nAcceptExOutstanding )) {

        m_nAcceptExOutstanding =
                TsSocketConfig[m_dwServerSize].nAcceptExOutstanding;
    }

    if ( !mb.GetDword( "",
                       MD_SERVER_LISTEN_TIMEOUT,
                       IIS_MD_UT_SERVER,
                       &m_AcceptExTimeout )) {

        m_AcceptExTimeout = INETA_DEF_ACCEPTEX_TIMEOUT;
    }

    // Root instance does not have VRs.  Close the metabase because the
    // virtual directories are going to be re-enumerated.
    //

    mb.Close();

    if ( fReadVirtualDirs ) {
        TsReadVirtualRoots( );
    }

    UnlockThis();
    return TRUE;

} // IIS_SERVER_INSTANCE::ReadParamsFromRegistry()



BOOL
IIS_SERVER_INSTANCE::SetCommonConfig(
    IN LPIIS_INSTANCE_INFO_1 pInfoConfig,
    IN BOOL  fRefresh
    )
/*++

   Description

     Writes the service common items to the registry

   Arguments:

      pInfoConfig - Admin items to write to the registry
      fRefresh    - Indicates whether we need to read back the data

   Note:
      We don't need to lock "this" object because we only write to the registry

      The anonymous password is set as a secret from the client side

--*/
{
    DWORD               err = NO_ERROR;
    FIELD_CONTROL       fcConfig;
    ADDRESS_CHECK       acCheck;
    BUFFER              buff;

    MB                  mb( (IMDCOM*) m_Service->QueryMDObject()  );

    //
    // Open the metabase and read parameters for IIS_SERVER_INSTANCE object
    // itself.
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )) {

        DBGPRINTF(( DBG_CONTEXT,
                   "[SetCommonConfig] mb.Open returned error %d for path %s\n",
                    GetLastError(),
                    QueryMDPath() ));


        return FALSE;
    }


    fcConfig = pInfoConfig->FieldControl;

    if ( IsFieldSet( fcConfig, FC_INET_INFO_CONNECTION_TIMEOUT ))
    {
        mb.SetDword( "",
                     MD_CONNECTION_TIMEOUT,
                     IIS_MD_UT_SERVER,
                     pInfoConfig->dwConnectionTimeout );
    }

    if ( (err == NO_ERROR) && IsFieldSet( fcConfig, FC_INET_INFO_MAX_CONNECTIONS ))
    {
        mb.SetDword( "",
                     MD_MAX_CONNECTIONS,
                     IIS_MD_UT_SERVER,
                     pInfoConfig->dwMaxConnections );
    }

    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_SERVER_COMMENT ) &&
         (pInfoConfig->lpszServerComment != NULL) )
    {
        if ( buff.Resize( 2 * (wcslen(pInfoConfig->lpszServerComment) + 1) *
                          sizeof(CHAR) ) )
        {
            (VOID) ConvertUnicodeToAnsi( pInfoConfig->lpszServerComment,
                                         (CHAR *) buff.QueryPtr(),
                                         buff.QuerySize() );

            mb.SetString( "",
                          MD_SERVER_COMMENT,
                          IIS_MD_UT_SERVER,
                          (CHAR *) buff.QueryPtr() );
        }
    }

#if 0
    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_HOST_NAME ) &&
         (pInfoConfig->lpszHostName != NULL) )
    {
        if ( buff.Resize( 2 * (wcslen(pInfoConfig->lpszHostName) + 1) *
                          sizeof(CHAR) ) )
        {
            (VOID) ConvertUnicodeToAnsi( pInfoConfig->lpszHostName,
                                         (CHAR *) buff.QueryPtr(),
                                         buff.QuerySize() );

            mb.SetData( "",
                        MD_HOSTNAME,
                        IIS_MD_UT_SERVER,
                        (CHAR *) buff.QueryPtr() );
        }

       err = WriteRegistryStringW( hkey,
                             INETA_HOST_NAME_W,
                             pInfoConfig->lpszHostName,
                             (wcslen( pInfoConfig->lpszHostName ) + 1) *
                                 sizeof( WCHAR ),
                             REG_SZ);
    }

    if ( (err == NO_ERROR) && IsFieldSet( fcConfig, FC_INET_INFO_PORT_NUMBER ))
    {

       err = WriteRegistryDword( hkey,
                                 INETA_PORT,
                                 (USHORT) pInfoConfig->sPort);
    }

    if ( (err == NO_ERROR) && IsFieldSet( fcConfig, FC_INET_INFO_SECURE_PORT_NUMBER ))
    {

       err = WriteRegistryDword( hkey,
                                 INETA_PORT_SECURE,
                                 (USHORT) pInfoConfig->sSecurePort);
    }
#endif

    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_ANON_USER_NAME ) &&
         (pInfoConfig->lpszAnonUserName != NULL) )
    {
        if ( buff.Resize( 2 * (wcslen(pInfoConfig->lpszAnonUserName) + 1) *
                          sizeof(CHAR) ) )
        {
            (VOID) ConvertUnicodeToAnsi( pInfoConfig->lpszAnonUserName,
                                         (CHAR *) buff.QueryPtr(),
                                         buff.QuerySize() );

            mb.SetString( "",
                          MD_ANONYMOUS_USER_NAME,
                          IIS_MD_UT_FILE,
                          (CHAR *) buff.QueryPtr() );
        }
    }

    if ( (err == NO_ERROR) && IsFieldSet( fcConfig, FC_INET_INFO_AUTHENTICATION ))
    {
        mb.SetDword( "",
                     MD_AUTHORIZATION,
                     IIS_MD_UT_FILE,
                     pInfoConfig->dwAuthentication );
    }

    //
    //  Write other fields
    //

    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_SITE_SECURITY ))
    {
        if ( (pInfoConfig->GrantIPList && pInfoConfig->GrantIPList->cEntries)
             || (pInfoConfig->DenyIPList && pInfoConfig->DenyIPList->cEntries) )
        {
            acCheck.BindCheckList( NULL, 0 );

            if ( FillAddrCheckFromIpList( TRUE, pInfoConfig->GrantIPList, &acCheck ) &&
                 FillAddrCheckFromIpList( FALSE, pInfoConfig->DenyIPList, &acCheck ) )
            {
                if ( !mb.SetData( "IIS_MD_INSTANCE_ROOT",
                                  MD_IP_SEC,
                                  IIS_MD_UT_FILE,
                                  BINARY_METADATA,
                                  (acCheck.GetStorage()->GetAlloc()
                                         ? acCheck.GetStorage()->GetAlloc() : (LPBYTE)""),
                                  acCheck.GetStorage()->GetUsed(),
                                  METADATA_INHERIT | METADATA_REFERENCE ))
                {
                    err = GetLastError();
                }
            }

            acCheck.UnbindCheckList();
        }
        else
        {
            if ( !mb.DeleteData( "IIS_MD_INSTANCE_ROOT",
                              MD_IP_SEC,
                              IIS_MD_UT_FILE,
                              BINARY_METADATA ) )
            {
                // not an error : property may not exists
                //err = GetLastError();
            }
        }
    }

    DBG_REQUIRE( mb.Close() );

    if ( (err == NO_ERROR) &&
        IsFieldSet( fcConfig, FC_INET_INFO_LOG_CONFIG) &&
        (pInfoConfig->lpLogConfig != NULL) ) {

        err = SetInetLogConfiguration(&m_Logging,
                                      m_Service->QueryEventLog(),
                                      pInfoConfig->lpLogConfig);

        if ( err != NO_ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "SetConfiguration() SetInetLogConfig() failed. "
                       " Err=%u\n",
                       err));
        } else {

            m_Logging.Active();
        }
    }

    if ( (err == NO_ERROR) &&
        IsFieldSet( fcConfig, FC_INET_INFO_VIRTUAL_ROOTS )) {

        if ( QueryInstanceId() != INET_INSTANCE_ROOT ) {

            if ( !TsSetVirtualRoots(  pInfoConfig
                                     )) {

                err = GetLastError();
                DBGPRINTF(( DBG_CONTEXT,
                           "[SetConfiguration()]SetVirtualRoots "
                           " returns error %d\n",
                            err));
            }
        }
    }

    if ( err != NO_ERROR ) {

        IF_DEBUG( ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "IIS_SERVER_INSTANCE::SetCommonConfig ==> Error = %u\n",
                       err));
        }

        SetLastError( err );
        return(FALSE);
    }

    return TRUE;

} // IIS_SERVER_INSTANCE::SetCommonConfig


VOID
IIS_SERVER_INSTANCE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this service.

  Arguments:
    pcoChangeList - path and id that has changed

--*/
{
    DWORD i;
    DWORD status;
    BOOL  fVRUpdated = FALSE;
    BOOL  fReadCommon = FALSE;
    BOOL  fShouldMirror = FALSE;


    if ( (pcoChangeList->dwMDChangeType &
                (MD_CHANGE_TYPE_DELETE_OBJECT |
                 MD_CHANGE_TYPE_RENAME_OBJECT |
                 MD_CHANGE_TYPE_ADD_OBJECT) ) != 0 )
    {

        //
        // Something got added/deleted/renamed
        //

        fShouldMirror = TRUE;
    }

    LockThisForWrite();
    for ( i = 0; i < pcoChangeList->dwMDNumDataIDs; i++ )
    {
        m_Logging.NotifyChange( pcoChangeList->pdwMDDataIDs[i] );
        switch ( pcoChangeList->pdwMDDataIDs[i] )
        {
        case MD_SERVER_BINDINGS:
            if( QueryServerState() != MD_SERVER_STATE_STOPPED ) {
                status = UpdateNormalBindings();
                if( status != NO_ERROR ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: UpdateNormalBindings() failed,error %lu\n",
                        status
                        ));
                }
                SetWin32Error( status );
            }
            break;

        case MD_SECURE_PORT:
            if( QueryServerState() != MD_SERVER_STATE_STOPPED ) {
                status = UpdateSecureBindings();
                if( status != NO_ERROR ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: UpdateSecureBindings() failed,error %lu\n",
                        status
                        ));
                }
                SetWin32Error( status );
            }
            break;

        case MD_SERVER_STATE:
            status = PerformStateChange();
            if( status != NO_ERROR ) {
                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: ProcessStateChange() failed, error %lu\n",
                        status
                        ));
                }
            }
            break;

        case MD_VR_PATH:
        case MD_VR_USERNAME:
        case MD_VR_PASSWORD:

            fShouldMirror = TRUE;
            if ( !fVRUpdated )
            {
                //
                //  Note individual root errors log an event
                //

                if ( !TsReadVirtualRoots() )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "Error %d (0x%lx) reading virtual roots\n",
                                GetLastError(), GetLastError() ));
                }

                fVRUpdated = TRUE;
            }
            break;

        //
        //  Ignore status updates
        //

        case MD_WIN32_ERROR:
            break;

        case MD_ACCESS_PERM:
            fShouldMirror = TRUE;

        default:
            fReadCommon = TRUE;
            break;
        }
    }

    if ( fReadCommon )
    {
        m_Logging.NotifyChange( 0 );
        RegReadCommonParams( FALSE );
    }

    //
    // reflect the changes to the registry
    //

    if ( fShouldMirror && (QueryInstanceId() == 1) )
    {
        MDMirrorVirtualRoots( );
    }

    UnlockThis();

} // IIS_SERVER_INSTANCE::MDChangeNotify



VOID
IIS_SERVER_INSTANCE::MDMirrorVirtualRoots(
    VOID
    )
{
    DWORD err;
    HKEY hkey = NULL;

    //
    // Delete VR key
    //

    err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    m_Service->QueryRegParamKey(),
                    0,
                    KEY_ALL_ACCESS,
                    &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx for returned error %d\n",err ));
        return;
    }

    //
    //  First delete the key to remove any old values
    //

    err = RegDeleteKey( hkey, VIRTUAL_ROOTS_KEY_A );
    RegCloseKey(hkey);

    if ( err != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[MDMirrorVRoots] Unable to remove old values\n"));
        return;
    }

    //
    // Now recreate the keys
    //

    MoveMDVroots2Registry( );
    return;

} // IIS_SERVER_INSTANCE::MDMirrorVirtualRoots

INETLOG_TYPE
FindInetLogType(
    IN DWORD dwValue
    )
{
    INETLOG_TYPE  ilType;

    switch (dwValue) {

      case INET_LOG_DISABLED:   ilType = InetNoLog;       break;
      case INET_LOG_TO_FILE:    ilType = InetLogToFile;   break;
      case INET_LOG_TO_SQL:     ilType = InetLogToSql;    break;
      default:                  ilType = InetLogInvalidType; break;
    } // switch()

    return (ilType);

} // FindInetLogType()


INETLOG_FORMAT
FindInetLogFormat(
    IN DWORD dwValue
    )
{
    INETLOG_FORMAT  ilFormat;

    switch (dwValue) {

      case INET_LOG_FORMAT_INTERNET_STD:    ilFormat = InternetStdLogFormat;       break;
      case INET_LOG_FORMAT_BINARY:          ilFormat = InetsvcsBinaryLogFormat;   break;
      case INET_LOG_FORMAT_NCSA:            ilFormat = NCSALogFormat;    break;
      case INET_LOG_FORMAT_CUSTOM:          ilFormat = CustomLogFormat;    break;
      default:                              ilFormat = InternetStdLogFormat; break;
    } // switch()

    return (ilFormat);

} // FindInetLogFormat()


INETLOG_PERIOD
FindInetLogPeriod(
        IN DWORD dwValue
        )
{
    INETLOG_PERIOD  ilPeriod;

    switch (dwValue) {
      case INET_LOG_PERIOD_NONE:   ilPeriod = InetLogNoPeriod; break;
      case INET_LOG_PERIOD_DAILY:  ilPeriod = InetLogDaily; break;
      case INET_LOG_PERIOD_WEEKLY: ilPeriod = InetLogWeekly; break;
      case INET_LOG_PERIOD_MONTHLY:ilPeriod = InetLogMonthly; break;
      case INET_LOG_PERIOD_YEARLY: ilPeriod = InetLogYearly; break;
      default:    ilPeriod = InetLogInvalidPeriod; break;
    } // switch()

    return (ilPeriod);
} // FindInetLogPeriod()



DWORD
GetRPCLogConfiguration(IN LOGGING *pLogging,
                       OUT LPINET_LOG_CONFIGURATION * ppLogConfig)
/*++
  This function allocates space (using MIDL_ functions) and stores
  log configuration for the given log handle in it.

  Arguments:
    hInetLog     handle for InetLog object.
    ppLogConfig  pointer to INET_LOG_CONFIGURATION object which on return
                  contains valid log config informtion, on success.

  Returns:
    Win32 error code.
--*/
{
    DWORD  dwError = NO_ERROR;
    LPINET_LOG_CONFIGURATION pRpcConfig;
    WCHAR cBuffer[MAX_PATH];

    DBG_ASSERT( ppLogConfig != NULL);

    pRpcConfig = ((LPINET_LOG_CONFIGURATION )
                  MIDL_user_allocate( sizeof(INET_LOG_CONFIGURATION)));

    if ( pRpcConfig != NULL) {

        INETLOG_CONFIGURATIONA  ilogConfig;
        DWORD cbConfig = sizeof(ilogConfig);
        BOOL fReturn=TRUE;

        ZeroMemory( &ilogConfig, sizeof(ilogConfig ));
        pLogging->GetConfig( &ilogConfig );

        //
        // we got valid config. copy it into pRpcConfig.
        // since the enumerated values in inetlog.w are same in inetasrv.h
        //  we do no mapping, we directly copy values.

        ZeroMemory( pRpcConfig, sizeof( INET_LOG_CONFIGURATION));
        pRpcConfig->inetLogType = ilogConfig.inetLogType;

        switch ( ilogConfig.inetLogType) {

          case InetNoLog:
            // do nothing
            break;

          case InetLogToFile:

            pRpcConfig->ilPeriod = ilogConfig.u.logFile.ilPeriod;
            pRpcConfig->cbSizeForTruncation =
              ilogConfig.u.logFile.cbSizeForTruncation;

             ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logFile.rgchLogFileDirectory, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchLogFileDirectory,
                MAX_PATH,
                cBuffer);

            *((DWORD *)&(pRpcConfig->rgchDataSource[MAX_PATH-sizeof(DWORD)]))=ilogConfig.u.logFile.ilFormat;
            *((DWORD *)&(pRpcConfig->rgchDataSource[MAX_PATH-2*sizeof(DWORD)]))=ilogConfig.u.logFile.dwFieldMask;

            break;

          case InetLogToSql:

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchDataSource, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchDataSource,
                MAX_PATH,
                cBuffer);

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchTableName, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchTableName,
                MAX_TABLE_NAME_LEN,
                cBuffer);

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchUserName, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchUserName,
                UNLEN,
                cBuffer);

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchPassword, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchPassword,
                PWLEN,
                cBuffer);
            break;

          default:
            break;

        } // switch()
    } else {

        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppLogConfig = pRpcConfig;

    return (dwError);
} // GetRPCLogConfiguration()



DWORD
SetInetLogConfiguration(IN LOGGING       *pLogging,
                        IN EVENT_LOG *    pEventLog,
                        IN const INET_LOG_CONFIGURATION * pRpcLogConfig)
/*++
  This function modifies the logconfiguration associated with a given InetLog
  handle. It also updates the registry containing log configuration for service
  with which the inetlog handle is associated.

  Arguments:
     hInetLog        Handle to INETLOG object whose configuration needs to be
                      changed.
     pRpcLogConfig   new RPC log configuration


  Returns:
    Win32 Error code. NO_ERROR returned on success.

--*/
{
    DWORD dwError = NO_ERROR;
    INETLOG_CONFIGURATIONA  ilConfig;
    WCHAR cBuffer[MAX_PATH];

    // initialize
    ZeroMemory( &ilConfig, sizeof(INETLOG_CONFIGURATIONA));

    // Copy the RPC inet log configuration into local INETLOG_CONFIGURATIONW

    // since the enumerated values in inetlog.w are same in inetasrv.h
    //  we do no mapping, we directly copy values.
    ilConfig.inetLogType = FindInetLogType(pRpcLogConfig->inetLogType);

    if ( ilConfig.inetLogType == InetLogInvalidType) {

        return (ERROR_INVALID_PARAMETER);
    }

    switch (ilConfig.inetLogType) {

      case INET_LOG_DISABLED:
        break;   // do nothing

      case INET_LOG_TO_FILE:

        CopyUnicodeStringToBuffer(cBuffer,
                                  MAX_PATH,
                                  pRpcLogConfig->rgchLogFileDirectory);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logFile.rgchLogFileDirectory,
                            MAX_PATH
                            );

        ilConfig.u.logFile.ilPeriod =
          FindInetLogPeriod(pRpcLogConfig->ilPeriod);

        if ( ilConfig.u.logFile.ilPeriod == InetLogInvalidPeriod) {
            return (ERROR_INVALID_PARAMETER);
        }

        ilConfig.u.logFile.cbSizeForTruncation =
          pRpcLogConfig->cbSizeForTruncation;

        ilConfig.u.logFile.ilFormat = FindInetLogFormat(*((DWORD *)&(pRpcLogConfig->rgchDataSource[MAX_PATH-sizeof(DWORD)])));
        ilConfig.u.logFile.dwFieldMask = *((DWORD *)&(pRpcLogConfig->rgchDataSource[MAX_PATH-2*sizeof(DWORD)]));
        break;

      case INET_LOG_TO_SQL:

        CopyUnicodeStringToBuffer(cBuffer,
                                  MAX_PATH,
                                  pRpcLogConfig->rgchDataSource);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchDataSource,
                            MAX_PATH);

        CopyUnicodeStringToBuffer(cBuffer,
                                  MAX_TABLE_NAME_LEN,
                                  pRpcLogConfig->rgchTableName);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchTableName,
                            MAX_PATH);

        CopyUnicodeStringToBuffer(cBuffer,
                                  UNLEN,
                                  pRpcLogConfig->rgchUserName);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchUserName,
                            MAX_PATH);

        CopyUnicodeStringToBuffer(cBuffer,
                                  CNLEN,
                                  pRpcLogConfig->rgchPassword);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchPassword,
                            MAX_PATH);

        break;

      default:
        return (ERROR_INVALID_PARAMETER);
    } // switch()


    //
    // Now the ilConfig contains the local data related to configuration.
    //   call modify log config to modify dynamically the log handle.
    //

    WCHAR pszErrorMessage[200] = L"";
    DWORD cchErrorMessage = sizeof(pszErrorMessage) /sizeof(WCHAR);
    pLogging->SetConfig( &ilConfig );
    return (dwError);

} // SetInetLogConfiguration()


BOOL
GenerateIpList(
    BOOL fIsGrant,
    ADDRESS_CHECK *pCheck,
    LPINET_INFO_IP_SEC_LIST *ppInfo
    )
/*++

Routine Description:

    generate an IP address list from an access check object

Arguments:

    fIsGrant - TRUE to access grant list, FALSE to access deny list
    pCheck - ptr to address check object to query from
    ppInfo - updated with ptr to IP list if success

Return:

    TRUE if success, otherwise FALSE

--*/
{
    UINT                        iM = pCheck->GetNbAddr( fIsGrant );
    LPINET_INFO_IP_SEC_LIST     pInfo;
    LPINET_INFO_IP_SEC_ENTRY    pI;
    UINT                        x;

    if ( iM == 0 )
    {
        *ppInfo = NULL;
        return TRUE;
    }

    if ( pInfo = (LPINET_INFO_IP_SEC_LIST)MIDL_user_allocate( sizeof(INET_INFO_IP_SEC_LIST) + iM * sizeof(INET_INFO_IP_SEC_ENTRY) ) )
    {
        pInfo->cEntries = 0;

        for ( x = 0, pI = pInfo->aIPSecEntry ;
              x < iM ;
              ++x )
        {
            LPBYTE pM;
            LPBYTE pA;
            DWORD dwF;

            if ( pCheck->GetAddr( fIsGrant, x, &dwF, &pM, &pA ) && dwF == AF_INET )
            {
                pI->dwMask = *(LPDWORD)pM;
                pI->dwNetwork = *(LPDWORD)pA;
                ++pI;
                ++pInfo->cEntries;
            }
        }

        *ppInfo = pInfo;

        return TRUE;
    }

    SetLastError( ERROR_NOT_ENOUGH_MEMORY );

    return FALSE;
}


BOOL
FillAddrCheckFromIpList(
    BOOL fIsGrant,
    LPINET_INFO_IP_SEC_LIST pInfo,
    ADDRESS_CHECK *pCheck
    )
/*++

Routine Description:

    Fill an access check object from an IP address list from

Arguments:

    fIsGrant - TRUE to access grant list, FALSE to access deny list
    pInfo - ptr to IP address list
    pCheck - ptr to address check object to update

Return:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    x;

    if ( pInfo )
    {
        for ( x = 0 ; x < pInfo->cEntries ; ++x )
        {
            if ( ! pCheck->AddAddr( fIsGrant,
                                    AF_INET,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwMask,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwNetwork ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL
GetVrootCount(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
/*++

Routine Description:

    Virtual directory enumerater callback that calculates the total required
    buffer size

Arguments:
    pvContext is a dword * that receives the count of virtual directories

Return:

    TRUE if success, otherwise FALSE

--*/
{
    *((DWORD *) pvContext) += 1;

    return TRUE;
}

BOOL
GetVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
/*++

Routine Description:

    Virtual directory enumerater callback that allocates and builds the
    virtual directory structure list

Arguments:
    pvContext is a pointer to the midl allocated memory

Return:

    TRUE if success, otherwise FALSE

--*/
{
    LPINET_INFO_VIRTUAL_ROOT_LIST  pvrl = (LPINET_INFO_VIRTUAL_ROOT_LIST) pvContext;
    DWORD                          i = pvrl->cEntries;
    LPINET_INFO_VIRTUAL_ROOT_ENTRY pvre = &pvrl->aVirtRootEntry[i];

    //
    //  Password doesn't go on the wire
    //

    DBG_ASSERT( pvr->pszMetaPath[0] == '/' &&
                pvr->pszMetaPath[1] == '/' );

    if ( !ConvertStringToRpc( &pvre->pszRoot,
                              pvr->pszAlias ) ||
         !ConvertStringToRpc( &pvre->pszDirectory,
                              pvr->pszPath ) ||
         !ConvertStringToRpc( &pvre->pszAddress,
                              "" ) ||
         !ConvertStringToRpc( &pvre->pszAccountName,
                              pvr->pszUserName ))
    {
        FreeRpcString( pvre->pszRoot );        pvre->pszRoot      = NULL;
        FreeRpcString( pvre->pszDirectory );   pvre->pszDirectory = NULL;
        FreeRpcString( pvre->pszAddress );     pvre->pszAddress   = NULL;
        FreeRpcString( pvre->pszAccountName ); pvre->pszAccountName = NULL;

        return FALSE;
    }

    pvre->dwMask = pvr->dwAccessPerm;

    pmb->GetDword( pvr->pszAlias,
                   MD_WIN32_ERROR,
                   IIS_MD_UT_SERVER,
                   &pvre->dwError );

    pvrl->cEntries++;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\comtest\sink.cxx ===
#include <windows.h>
#include <ole2.h>
#include <iadm.h>
#include <stdio.h>
#include <sink.hxx>

//extern HANDLE          hevtDone;

CImpIADMCOMSINK::CImpIADMCOMSINK()
{
    m_dwRefCount=0;
}

CImpIADMCOMSINK::~CImpIADMCOMSINK()
{
}

HRESULT
CImpIADMCOMSINK::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMSAdminBaseSink) {
        *ppObject = (IMSAdminBaseSink *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIADMCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIADMCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIADMCOMSINK::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;
    printf("*************Recieved callback \n");
    for (i = 0; i < dwMDNumElements; i++) {
        printf("Change Type = %X, Path = %s\n", pcoChangeList[i].dwMDChangeType, pcoChangeList[i].pszMDPath);
        for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++) {
            printf("\tData Changed ID = %X\n", pcoChangeList[i].pdwMDDataIDs[j]);
        }
    }
    printf("\n");
    return (0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\admutil\main.cxx ===
#define INITGUID
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <string.hxx>
#include <windows.h>
#include <tsres.hxx>
#include <stdio.h>
#include <iadm.h>

#include <iiscnfg.h>
# include "iisinfo.h"
#include <main.hxx>


#define GETADMCLSID(IsService) ((IsService) ? CLSID_ADMCOM : CLSID_ADMCOMEXE)


#define TIMEOUT_VALUE      1000

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}

LPSTR
ConvertDataTypeToString(DWORD dwDataType)
{
    LPTSTR strReturn;
    switch (dwDataType) {
    case DWORD_METADATA:
        strReturn = "DWORD";
        break;
    case STRING_METADATA:
        strReturn = "STRING";
        break;
    case BINARY_METADATA:
        strReturn = "BINARY";
        break;
    case ALL_METADATA:
        strReturn = "ALL";
        break;
    default:
        strReturn = "Invalid Data Type";
    }
    return (strReturn);
}

VOID
PrintDataBuffer(PMETADATA_RECORD pmdrData, LPSTR strInitialString)
{
    DWORD i;
    LPSTR pszIndex;
    if (strInitialString != NULL) {
        printf("%s", strInitialString);
    }
    switch (pmdrData->dwMDDataType) {
    case DWORD_METADATA:
        printf("0x%x", *(DWORD *)(pmdrData->pbMDData));
        break;
    case STRING_METADATA:
        for (pszIndex = (LPSTR)(pmdrData->pbMDData);
            *pszIndex!= '\0';
            pszIndex++) {
            if (*pszIndex == '\r') {
                *pszIndex = ' ';
            }
        }
        printf("%s", (LPTSTR)(pmdrData->pbMDData));
        break;
    case BINARY_METADATA:
        printf("0x");
        for (i = 0; i < pmdrData->dwMDDataLen; i++) {
            printf("%.2x ", ((PBYTE)(pmdrData->pbMDData))[i]);
        }
        break;
    }
    printf("\n");
}

LPSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = "ERROR_SUCCESS";
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = "ERROR_PATH_NOT_FOUND";
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = "ERROR_INVALID_HANDLE";
        break;
    case ERROR_INVALID_DATA:
        RetCode = "ERROR_INVALID_DATA";
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode = "ERROR_INVALID_PARAMETER";
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode = "ERROR_NOT_SUPPORTED";
        break;
    case ERROR_ACCESS_DENIED:
        RetCode = "ERROR_ACCESS_DENIED";
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode = "ERROR_NOT_ENOUGH_MEMORY";
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode = "ERROR_FILE_NOT_FOUND";
        break;
    case ERROR_DUP_NAME:
        RetCode = "ERROR_DUP_NAME";
        break;
    case ERROR_PATH_BUSY:
        RetCode = "ERROR_PATH_BUSY";
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode = "ERROR_NO_MORE_ITEMS";
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode = "ERROR_INSUFFICIENT_BUFFER";
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode = "ERROR_PROC_NOT_FOUND";
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode = "ERROR_INTERNAL_ERROR";
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode = "MD_ERROR_NOT_INITIALIZED";
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode = "MD_ERROR_DATA_NOT_FOUND";
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode = "ERROR_ALREADY_EXISTS";
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode = "MD_WARNING_PATH_NOT_FOUND";
        break;
    case MD_WARNING_DUP_NAME:
        RetCode = "MD_WARNING_DUP_NAME";
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode = "MD_WARNING_INVALID_DATA";
        break;
    case ERROR_INVALID_NAME:
        RetCode = "ERROR_INVALID_NAME";
        break;
    default:
        RetCode = "Unrecognized Error Code";
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPSTR ConvertHresToString(HRESULT hRes)
{
    LPSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_INTERNET) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        switch (hRes) {
        case CO_E_SERVER_EXEC_FAILURE:
            strReturn = "CO_E_SERVER_EXEC_FAILURE";
            break;
        default:
            strReturn = "Unrecognized hRes facility";
        }
    }
    return(strReturn);
}

ADMUTIL_PARAMS
ArgToParam(LPSTR pszParam, LPSTR &rpszParamValue)
{
    DWORD i;

    for (i = PARAM_NONE+1; i < PARAM_INVALID; i++) {
        if (_strnicmp(pszParam, ParamTable[i].pszString, strlen(ParamTable[i].pszString)) == 0) {
            break;
        }
    }
    if (i < PARAM_INVALID) {
        rpszParamValue = pszParam + strlen(ParamTable[i].pszString);
    }
    return (ADMUTIL_PARAMS)i;
}

ADMUTIL_COMMANDS
CheckCommand(LPSTR pszCommand)
{
    DWORD i;

    for (i = COMMAND_NONE+1; i < COMMAND_INVALID; i++) {
        if (_stricmp(pszCommand, CommandTable[i].pszString) == 0) {
            break;
        }
    }
    return (ADMUTIL_COMMANDS)CommandTable[i].dwID;
}

SYNTAX_ERRORS
CheckNumber(LPSTR pszParamValue)
{
    LPSTR pszIndex;
    SYNTAX_ERRORS seReturn = SYNTAX_NO_ERROR;
    for (pszIndex = pszParamValue; *pszIndex != '\0'; pszIndex++) {
        if ((*pszIndex < '0') || (*pszIndex > '9')) {
            break;
        }
    }
    if (pszIndex == pszParamValue) {
        seReturn = SYNTAX_MISSING_PARAM_VALUE;

    }
    else if (*pszIndex != '\0') {
        seReturn = SYNTAX_LETTERS_IN_DWORD;
    }
    return seReturn;
}

SYNTAX_ERRORS
CheckHeaderSyntax(LPSTR pszParamValue)
{
    LPSTR pszIndex;
    SYNTAX_ERRORS seReturn = SYNTAX_INVALID_HEADER;

    for (pszIndex = pszParamValue; *pszIndex != '\0'; pszIndex++) {
        if (*pszIndex == ':') {
            break;
        }
    }
    if ((*pszIndex == ':') && (pszIndex > pszParamValue)) {
        if (*(pszIndex+1) != '\0') {
            seReturn = SYNTAX_NO_ERROR;
        }
    }
    return seReturn;
}

SYNTAX_ERRORS
CheckPicSyntax(LPSTR pszParamValue, STR *pstrPic)
{
    SYNTAX_ERRORS seReturn;
    char pszPic[16];

    if ((tolower(pszParamValue[0]) != 'n') || (!isdigit((UCHAR)pszParamValue[1])) ||
        (tolower(pszParamValue[2]) != 's') || (!isdigit((UCHAR)pszParamValue[3])) ||
        (tolower(pszParamValue[4]) != 'v') || (!isdigit((UCHAR)pszParamValue[5])) ||
        (tolower(pszParamValue[6]) != 'l') || (!isdigit((UCHAR)pszParamValue[7]))) {
        seReturn = SYNTAX_INVALID_PIC;
    }
    else {
        pstrPic->Copy("PICS-Label: (PICS-1.1 \"http://www.rsac.org/ratingsv01.html\" l r (");
        pszPic[0] = 'n';
        pszPic[1] = ' ';
        pszPic[2] = pszParamValue[1];
        pszPic[3] = ' ';
        pszPic[4] = 's';
        pszPic[5] = ' ';
        pszPic[6] = pszParamValue[3];
        pszPic[7] = ' ';
        pszPic[8] = 'v';
        pszPic[9] = ' ';
        pszPic[10] = pszParamValue[5];
        pszPic[11] = ' ';
        pszPic[12] = 'l';
        pszPic[13] = ' ';
        pszPic[14] = pszParamValue[7];
        pszPic[15] = '\0';
        pstrPic->Append(pszPic);
        pstrPic->Append("))\r");
        seReturn = SYNTAX_NO_ERROR;
    }
    return seReturn;
}

#define AscToHex(a) ( (a)>='a' ? ((a)-'a'+10) : ((a)>='A' ? (a)-'A'+10 : (a)-'0') )

BOOL
ReadFile( LPSTR pszFilename, LPBYTE* ppBin, LPDWORD pcBin )
{
    HANDLE  hFile;
    BOOL    fSt;
    LPBYTE  pBin;
    DWORD   cBin;
    BOOL    fHex = FALSE;

    if ( *pszFilename == '!' )
    {
        fHex = TRUE;
        ++pszFilename;
    }

    if ( hFile = CreateFile( pszFilename,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL ) )
    {
        if ( (cBin = GetFileSize( hFile, NULL )) == 0xffffffff )
        {
            fSt = FALSE;
        }
        else if ( !(pBin = (LPBYTE)LocalAlloc( LMEM_FIXED, cBin )) )
        {
            fSt = FALSE;
        }
        else
        {
            *ppBin = pBin;
            fSt = ReadFile( hFile, pBin, cBin, pcBin, NULL );
            if ( fSt && fHex )
            {
                LPBYTE  p = pBin;
                LPBYTE  pAsc;
                LPBYTE  pMax;

                for ( pAsc = pBin, pMax = pBin + *pcBin ; pAsc < pMax ; pAsc += 2 )
                {
                    *p++ = (AscToHex(pAsc[0])<<4) | AscToHex(pAsc[1]) ;
                }
                *pcBin = p - pBin;
            }
        }
        CloseHandle( hFile );

        return fSt;
    }

    return FALSE;
}


BOOL
WriteFile( LPSTR pszFilename, LPBYTE pBin, DWORD cBin )
{
    HANDLE  hFile;
    BOOL    fSt;
    DWORD   dwWrite;


    if ( hFile = CreateFile( pszFilename,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL ) )
    {
        fSt = WriteFile( hFile, pBin, cBin, &dwWrite, NULL );
        CloseHandle( hFile );

        return fSt;
    }

    return FALSE;
}


VOID
PrintSyntaxError(SYNTAX_ERRORS seSyntax, LPSTR pszBadParam)
{
    printf("\n");
    printf(SyntaxTable[(DWORD)seSyntax].pszString, pszBadParam);
    printf("\n\n");
}

VOID
PrintUsage()
{
    printf("USAGE:\n\n");
    printf("ADMUTIL -c:<Command> [-s:<Server>] [-i:<Instance>] [-u:<URL>] [-d:<DWORD>] [-p:pic] [-h:<Header:Value>[ ...]]\n\n");
    printf("  <Command>\n");
    printf("    SETCUSTOM       Sets Custom Headers\n");
    printf("    GETCUSTOM       Gets Custom Headers\n");
    printf("    DELCUSTOM       Deletes Custom Headers\n");
    printf("    SETPIC          Sets PIC Headers\n");
    printf("    GETPIC          Gets PIC Headers\n");
    printf("    DELPIC          Deletes PIC Headers\n");
    printf("    SETEXPIRES      Sets Expires timeout\n");
    printf("    GETEXPIRES      Gets Expires timeout\n");
    printf("    DELEXPIRES      Deletes Expires timeout\n");
    printf("    SETACCESS       Sets Access Permissions Mask\n");
    printf("    GETACCESS       Gets Access Permissions Mask\n");
    printf("    DELACCESS       Deletes Access Permissions Mask\n");
    printf("    SETAUTH         Sets Authorizations Mask\n");
    printf("    GETAUTH         Gets Authorizations Mask\n");
    printf("    DELAUTH         Deletes Authorizations Mask\n");
    printf("    GETINSTANCES    Gets Instance Information\n\n");
    printf("    GETBIN          Gets Binary Information\n\n");
    printf("    SETBIN          Sets Binary Information\n\n");

    printf("  <Server>\n");
    printf("    The name of the server. Defaults to local machine.\n");

    printf("  <Instance>\n");
    printf("    The Instance nuber to set/get data on. Can be obtained from GETINSTANCES.\n");
    printf("    Required if -u:<URL> is specified.\n");

    printf("  <URL>\n");
    printf("    The URL to set/get data on. Must not include HTTP://.\n");

    printf("  <PIC>\n");
    printf("    The PIC (ratings) value in the form h#s#v#l#.\n");
    printf("    All #'s must be between 0 and 4.\n");

    printf("  <DWORD>\n");
    printf("    The unsigned integer value to set in decimal.\n");

    printf("  <Header:Value>\n");
    printf("    The header string in the form \"Header:Value\".\n");

    printf("  <MdId:Value>\n");
    printf("    The Metadata ID to use for binary commands\n" );

    printf("  <Attr:Value>\n");
    printf("    The Metadata attribute to use when setting a metadata object\n" );

    printf("  <Filename:Value>\n");
    printf("    The filename to use for binary commands\n" );

    printf("  <Namespace:Standard/NameSpaceExtension>\n");
    printf("    The name space to use to access object/properties\n" );

    printf("EXAMPLES\n");
    printf("  ADMUTIL -c:SETCUSTOM -u:virdir1/foo.htm -i:1 -h:Content-Language:en\n");
    printf("  ADMUTIL -c:GETCUSTOM -u:virdir1/foo.htm -i:1\n");
    printf("  ADMUTIL -c:DELCUSTOM -u:virdir1/foo.htm -i:1\n");
    printf("  ADMUTIL -c:SETPIC -s:myserver -p:n1s3v4l2\n");
    printf("  ADMUTIL -c:GETPIC -s:myserver -u:virdir1/foo.htm -i:1\n");
    printf("  ADMUTIL -c:DELPIC -s:myserver -u:virdir1/foo.htm -i:1\n");
    printf("  ADMUTIL -c:SETEXPIRES -u:virdir1/foo.htm -i:1 -d:123 \n");
    printf("  ADMUTIL -c:GETEXPIRES -u:virdir1/foo.htm -i:1\n");
    printf("  ADMUTIL -c:DELEXPIRES -u:virdir1/foo.htm -i:1\n");
    printf("  ADMUTIL -c:SETACCESS -i:2 -d:7\n");
    printf("  ADMUTIL -c:GETACCESS\n");
    printf("  ADMUTIL -c:DELACCESS\n");
    printf("  ADMUTIL -c:SETAUTH -i:1 -u:virdir2 -d:3\n");
    printf("  ADMUTIL -c:GETAUTH -i:1 -u:virdir2\n");
    printf("  ADMUTIL -c:DELAUTH -i:1 -u:virdir2\n");
    printf("  ADMUTIL -c:GETINSTANCES\n");
    printf("  ADMUTIL -c:GETBIN -f:file -m:1104\n");
    printf("  ADMUTIL -c:SETBIN -f:file -m:1104\n");
    printf("\nFor more information, see the readme.\n");
}

VOID
PrintResults(HRESULT hRes, LPSTR pszFailedAPI)
{
    if (FAILED(hRes)) {
        printf("%s failed, Return Code = 0x%X %s.\n",
               pszFailedAPI, hRes, ConvertHresToString(hRes));

    }
    else {
        printf("Success\n");
    }
}


#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisAdmUtilGuid, 
0x784d8922, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
    DECLARE_DEBUG_VARIABLE();
#endif
    DECLARE_DEBUG_PRINTS_OBJECT();

DWORD __cdecl
main( INT    cArgs,
      char * pArgs[] )
{
    int i,j;

    IADMCOM * pcCom = NULL;
    HRESULT hRes;

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT("TestMain", IisAdmUtilGuid);
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT("TestMain");
#endif

    SYNTAX_ERRORS seSyntaxOK = SYNTAX_NO_ERROR;
    DWORD mdcCommand = COMMAND_NONE;
    STR strPath("");
    STR strInstancePath("");
    STR strHeader("");
    DWORD dwHeaderCount = 0;
    LPSTR pszURL = NULL;
    BOOL bURLSet = FALSE;
    BOOL bPicSet = FALSE;
    DWORD dwDwordValue = 0;
    DWORD dwDwordCount = 0;
    LPSTR pszInstance = NULL;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchMachineName[MAX_PATH];
    METADATA_HANDLE FullPathHandle = 0;
    METADATA_HANDLE InstancePathHandle = 0;
    LPSTR pszFailedAPI = NULL;
    METADATA_RECORD mdrData;
    BUFFER bufReturnData(0);
    LPSTR pszBadParam = NULL;
    IClassFactory * pcsfFactory = NULL;
    STR strPic("");
    LPSTR pszFilename = NULL;
    DWORD dwMdIdentifier = 0;
    LPBYTE pBin = NULL;
    DWORD cBin = 0;
    DWORD dwMdAttr = METADATA_INHERIT;
    BOOL fIsStd = TRUE;

    for ( i = 1; i < cArgs; i++ ) {
        if ((*(pArgs[i]) != '-') && (*(pArgs[i]) != '/')) {
            seSyntaxOK = SYNTAX_INVALID_PARAM;
            pszBadParam = pArgs[i];
        }
        else {
            LPSTR pszParamValue;
            switch (ArgToParam(pArgs[i]+1, pszParamValue))
            {
            case PARAM_MACHINE:
                if (pcsiParam != NULL) {
                    seSyntaxOK = SYNTAX_EXTRA_PARAM;
                    pszBadParam = pArgs[i];
                }
                else {
                    if (strlen(pszParamValue) >= MAX_PATH) {
                        seSyntaxOK = SYNTAX_BAD_MACHINE_NAME;
                        pszBadParam = pszParamValue;
                    }
                    else {
                        wsprintfW( rgchMachineName, L"%S", pszParamValue);
                        csiMachineName.pwszName =  rgchMachineName;
                        csiMachineName.pAuthInfo = NULL;
                        csiMachineName.dwReserved1 = 0;
                        csiMachineName.dwReserved2 = 0;
                        pcsiParam = &csiMachineName;
                    }
                }
                break;
            case PARAM_COMMAND:
                if (mdcCommand != COMMAND_NONE) {
                    seSyntaxOK = SYNTAX_EXTRA_PARAM;
                    pszBadParam = pArgs[i];
                }
                else {
                    mdcCommand = CheckCommand(pszParamValue);
                    if ((mdcCommand <= COMMAND_NONE) || (mdcCommand >= COMMAND_INVALID)) {
                        seSyntaxOK = SYNTAX_INVALID_COMMAND;
                        pszBadParam = pszParamValue;
                    }
                }
                break;

            case PARAM_IF:
                fIsStd = pszParamValue[0] == 'S' || pszParamValue[0] == 's';
                break;

            case PARAM_MID:
                dwMdIdentifier = atoi(pszParamValue);
                seSyntaxOK = SYNTAX_NO_ERROR;
                break;

            case PARAM_ATTR:
                dwMdAttr = atoi(pszParamValue);
                seSyntaxOK = SYNTAX_NO_ERROR;
                break;

            case PARAM_FILENAME:
                pszFilename = pszParamValue;
                seSyntaxOK = SYNTAX_NO_ERROR;
                break;

            case PARAM_URL:
                if (bURLSet) {
                    seSyntaxOK = SYNTAX_EXTRA_PARAM;
                    pszBadParam = pArgs[i];
                }
                else {
                    bURLSet = TRUE;
                    pszURL = pszParamValue;
                }
                break;
            case PARAM_DWORD:
                if (dwDwordCount > 0) {
                    seSyntaxOK = SYNTAX_EXTRA_PARAM;
                    pszBadParam = pArgs[i];
                }
                else {
                    seSyntaxOK = CheckNumber(pszParamValue);
                    if (seSyntaxOK == SYNTAX_NO_ERROR) {
                        dwDwordValue = atoi(pszParamValue);
                        dwDwordCount++;
                    }
                    else if (seSyntaxOK == SYNTAX_MISSING_PARAM_VALUE) {
                        pszBadParam = pArgs[i];
                    }
                    else {
                        pszBadParam = pszParamValue;
                    }
                }
                break;
            case PARAM_HEADER:
                seSyntaxOK = CheckHeaderSyntax(pszParamValue);
                if (seSyntaxOK == SYNTAX_NO_ERROR) {
                    dwHeaderCount++;
                    strHeader.Append(pszParamValue);
                    strHeader.Append("\r");
                }
                else if (seSyntaxOK == SYNTAX_MISSING_PARAM_VALUE) {
                    pszBadParam = pArgs[i];
                }
                else {
                    pszBadParam = pszParamValue;
                }
                break;
            case PARAM_PIC:
                if (bPicSet != NULL) {
                    seSyntaxOK = SYNTAX_EXTRA_PARAM;
                    pszBadParam = pArgs[i];
                }
                else {
                    seSyntaxOK = CheckPicSyntax(pszParamValue, &strPic);
                    if (seSyntaxOK == SYNTAX_NO_ERROR) {
                        bPicSet = TRUE;
                    }
                    else if (seSyntaxOK == SYNTAX_MISSING_PARAM_VALUE) {
                        pszBadParam = pArgs[i];
                    }
                    else {
                        pszBadParam = pszParamValue;
                    }
                }
                break;
            case PARAM_INSTANCE:
                if (pszInstance != NULL) {
                    seSyntaxOK = SYNTAX_EXTRA_PARAM;
                    pszBadParam = pArgs[i];
                }
                else {
                    seSyntaxOK = CheckNumber(pszParamValue);
                    if (seSyntaxOK == SYNTAX_NO_ERROR) {
                        pszInstance = pszParamValue;
                    }
                    else if (seSyntaxOK == SYNTAX_MISSING_PARAM_VALUE) {
                        pszBadParam = pArgs[i];
                    }
                    else {
                        pszBadParam = pszParamValue;
                    }
                }
                break;
            default:
                seSyntaxOK = SYNTAX_INVALID_PARAM;
                pszBadParam = pArgs[i];
            }
        }
        if (seSyntaxOK != SYNTAX_NO_ERROR) {
            break;
        }
    }

    if (seSyntaxOK == SYNTAX_NO_ERROR) {
        switch (mdcCommand) {
        case COMMAND_SET_CUSTOM:
            if (dwHeaderCount == 0) {
                seSyntaxOK = SYNTAX_HEADER_REQUIRED;
            }
            else if (dwDwordCount > 0) {
                seSyntaxOK = SYNTAX_DWORD_NOT_ALLOWED;
            }
            else if ((pszInstance == NULL) && (bURLSet)) {
                seSyntaxOK = SYNTAX_INSTANCE_REQUIRED;
            }
            else if (bPicSet) {
                seSyntaxOK = SYNTAX_PIC_NOT_ALLOWED;
            }
            break;
        case COMMAND_SET_PIC:
            if (dwHeaderCount > 0) {
                seSyntaxOK = SYNTAX_HEADER_NOT_ALLOWED;
            }
            else if (dwDwordCount > 0) {
                seSyntaxOK = SYNTAX_DWORD_NOT_ALLOWED;
            }
            else if ((pszInstance == NULL) && (bURLSet)) {
                seSyntaxOK = SYNTAX_INSTANCE_REQUIRED;
            }
            else if (!bPicSet) {
                seSyntaxOK = SYNTAX_PIC_REQUIRED;
            }
            break;
        case COMMAND_SET_BINARY:
        case COMMAND_GET_BINARY:
            if ( dwMdIdentifier == NULL ) {
                seSyntaxOK = SYNTAX_MISSING_ID;
            }
            else if ( pszFilename == NULL ) {
                seSyntaxOK = SYNTAX_MISSING_FILENAME;
            }
            else {
                seSyntaxOK = SYNTAX_NO_ERROR;
                if ( mdcCommand == COMMAND_SET_BINARY )
                {
                    if ( !ReadFile( pszFilename, &pBin, &cBin ) )
                    {
                        seSyntaxOK = SYNTAX_BAD_FILENAME;
                    }
                }
            }
            break;
        case COMMAND_GET_CUSTOM:
        case COMMAND_GET_PIC:
        case COMMAND_DEL_CUSTOM:
        case COMMAND_DEL_PIC:
            if (dwHeaderCount > 0) {
                seSyntaxOK = SYNTAX_HEADER_NOT_ALLOWED;
            }
            else if (dwDwordCount > 0) {
                seSyntaxOK = SYNTAX_DWORD_NOT_ALLOWED;
            }
            else if ((pszInstance == NULL) && (bURLSet)) {
                seSyntaxOK = SYNTAX_INSTANCE_REQUIRED;
            }
            else if (bPicSet) {
                seSyntaxOK = SYNTAX_PIC_NOT_ALLOWED;
            }
            break;
        case COMMAND_SET_EXPIRES:
        case COMMAND_SET_ACCESS:
        case COMMAND_SET_AUTH:
            if (dwHeaderCount > 0) {
                seSyntaxOK = SYNTAX_HEADER_NOT_ALLOWED;
            }
            else if (dwDwordCount == 0) {
                seSyntaxOK = SYNTAX_DWORD_REQUIRED;
            }
            else if ((pszInstance == NULL) && (bURLSet)) {
                seSyntaxOK = SYNTAX_INSTANCE_REQUIRED;
            }
            else if (bPicSet) {
                seSyntaxOK = SYNTAX_PIC_NOT_ALLOWED;
            }
            break;
        case COMMAND_GET_EXPIRES:
        case COMMAND_GET_ACCESS:
        case COMMAND_GET_AUTH:
        case COMMAND_DEL_EXPIRES:
        case COMMAND_DEL_ACCESS:
        case COMMAND_DEL_AUTH:
            if (dwHeaderCount > 0) {
                seSyntaxOK = SYNTAX_HEADER_NOT_ALLOWED;
            }
            else if (dwDwordCount > 0) {
                seSyntaxOK = SYNTAX_DWORD_NOT_ALLOWED;
            }
            else if ((pszInstance == NULL) && (bURLSet)) {
                seSyntaxOK = SYNTAX_INSTANCE_REQUIRED;
            }
            else if (bPicSet) {
                seSyntaxOK = SYNTAX_PIC_NOT_ALLOWED;
            }
            break;
        case COMMAND_GET_INSTANCES:
            if (dwHeaderCount > 0) {
                seSyntaxOK = SYNTAX_HEADER_NOT_ALLOWED;
            }
            else if (dwDwordCount > 0) {
                seSyntaxOK = SYNTAX_DWORD_NOT_ALLOWED;
            }
            else if (bURLSet) {
                seSyntaxOK = SYNTAX_URL_NOT_ALLOWED;
            }
            else if (pszInstance != NULL) {
                seSyntaxOK = SYNTAX_INSTANCE_NOT_ALLOWED;
            }
            else if (bPicSet) {
                seSyntaxOK = SYNTAX_PIC_NOT_ALLOWED;
            }
            break;
        default:
            seSyntaxOK = SYNTAX_COMMAND_REQUIRED;
        }
    }

    if (seSyntaxOK != SYNTAX_NO_ERROR) {
        PrintSyntaxError(seSyntaxOK, pszBadParam);
        PrintUsage();
        return(0);
    }


    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        pszFailedAPI = "CoInitializeEx";
    }
    else {
        hRes = CoGetClassObject(GETADMCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                                IID_IClassFactory, (void**) &pcsfFactory);

        if (FAILED(hRes)) {
            pszFailedAPI = "CoGetClassObject";
        }
        else {
            hRes = pcsfFactory->CreateInstance(NULL, IID_IADMCOM, (void **) &pcCom);
            if (FAILED(hRes)) {
                pszFailedAPI = "CreateInstance: ADMCOM";
            }
        }
        if (SUCCEEDED(hRes)) {
            hRes = pcCom->ComADMInitialize();
            if (FAILED(hRes)) {
                pszFailedAPI = "ComADMInitialize";
            }
            else {
                strPath.Append(WWW_PATH);
                if (pszInstance != NULL) {
                    strPath.Append(pszInstance);
                    strPath.Append("/");
                    if (strPath.IsValid()) {
                        strInstancePath.Copy(strPath.QueryStr());
                        strInstancePath.Append("/");
                        if ((!bURLSet) || ((*pszURL != '/') && (*pszURL != '\\') && (*pszURL != '!'))) {
                            strPath.Append("/");
                        }
                        if (bURLSet) {
                            if ( *pszURL == '!' )
                            {
                                strPath.Append(pszURL+1);
                            }
                            else
                            {
                                strPath.Append(pszURL);
                            }
                        }
                    }
                }
                if (!strPath.IsValid()) {
                    hRes = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                //
                // path is now set
                //
                if (SUCCEEDED(hRes)) {
                    if ((mdcCommand == COMMAND_SET_CUSTOM) || (mdcCommand == COMMAND_SET_PIC) ||
                        (mdcCommand == COMMAND_SET_EXPIRES) || (mdcCommand == COMMAND_SET_ACCESS) ||
                        (mdcCommand == COMMAND_SET_AUTH) || (mdcCommand == COMMAND_SET_BINARY) ) {
                        hRes = pcCom->ComADMOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                            (PBYTE)strPath.QueryStr(), METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &FullPathHandle);
                        if (FAILED(hRes)) {
                            if (!bURLSet || (hRes != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))) {
                                pszFailedAPI = "ComADMOpenMetaObject";
                            }
                            else {
                                //
                                // open the instance and create the node
                                //
                                if (!strInstancePath.IsValid()) {
                                    hRes = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    hRes = pcCom->ComADMOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                        (PBYTE)strInstancePath.QueryStr(), METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &InstancePathHandle);
                                    if (FAILED(hRes)) {
                                        pszFailedAPI = "ComADMOpenMetaObject";
                                    }
                                    else {
                                        hRes = pcCom->ComADMAddMetaObject(InstancePathHandle, (PBYTE)pszURL);
                                        pcCom->ComADMCloseMetaObject(InstancePathHandle);
                                        if (FAILED(hRes)) {
                                            pszFailedAPI = "ComADMAddMetaObject";
                                        }
                                        else {
                                            hRes = pcCom->ComADMOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                                (PBYTE)strPath.QueryStr(), METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &FullPathHandle);
                                            if (FAILED(hRes)) {
                                                pszFailedAPI = "ComADMOpenMetaObject";
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (SUCCEEDED(hRes)) {
                            switch (mdcCommand) {
                            case COMMAND_SET_CUSTOM:
                                MD_SET_DATA_RECORD(&mdrData,
                                                   MD_HTTP_CUSTOM,
                                                   dwMdAttr,
                                                   IIS_MD_UT_FILE,
                                                   STRING_METADATA,
                                                   strHeader.QueryCCH()+1,
                                                   (PBYTE)strHeader.QueryStr());
                                break;
                            case COMMAND_SET_BINARY:
                                MD_SET_DATA_RECORD(&mdrData,
                                                   dwMdIdentifier,
                                                   dwMdAttr,
                                                   IIS_MD_UT_FILE,
                                                   BINARY_METADATA,
                                                   cBin,
                                                   (PBYTE)pBin);
                                break;
                            case COMMAND_SET_PIC:
                                MD_SET_DATA_RECORD(&mdrData,
                                                   MD_HTTP_PICS,
                                                   dwMdAttr,
                                                   IIS_MD_UT_FILE,
                                                   STRING_METADATA,
                                                   strPic.QueryCCH()+1,
                                                   (PBYTE)strPic.QueryStr());
                                break;
                            case COMMAND_SET_EXPIRES:
                                MD_SET_DATA_RECORD(&mdrData,
                                                   MD_HTTP_EXPIRES,
                                                   dwMdAttr,
                                                   IIS_MD_UT_FILE,
                                                   DWORD_METADATA,
                                                   sizeof(DWORD),
                                                   (PBYTE)&dwDwordValue);
                                break;
                            case COMMAND_SET_ACCESS:
                                MD_SET_DATA_RECORD(&mdrData,
                                                   MD_ACCESS_PERM,
                                                   dwMdAttr,
                                                   IIS_MD_UT_FILE,
                                                   DWORD_METADATA,
                                                   sizeof(DWORD),
                                                   (PBYTE)&dwDwordValue);
                                break;
                            case COMMAND_SET_AUTH:
                                MD_SET_DATA_RECORD(&mdrData,
                                                   MD_AUTHORIZATION,
                                                   dwMdAttr,
                                                   IIS_MD_UT_FILE,
                                                   DWORD_METADATA,
                                                   sizeof(DWORD),
                                                   (PBYTE)&dwDwordValue);
                                break;
                            }
                            hRes = pcCom->ComADMSetMetaData(FullPathHandle, (PBYTE)"", &mdrData);
                            if (FAILED(hRes)) {
                                pszFailedAPI = "ComADMSetMetaData";
                            }
                            else {
                                hRes = pcCom->ComADMSaveData();
                                if (FAILED(hRes)) {
                                    pszFailedAPI = "ComADMSaveData";
                                }
                            }

                            pcCom->ComADMCloseMetaObject(FullPathHandle);
                        }
                    }
                    else if ((mdcCommand == COMMAND_DEL_CUSTOM) || (mdcCommand == COMMAND_DEL_PIC) ||
                        (mdcCommand == COMMAND_DEL_EXPIRES) || (mdcCommand == COMMAND_DEL_ACCESS) ||
                        (mdcCommand == COMMAND_DEL_AUTH)) {
                        hRes = pcCom->ComADMOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                            (PBYTE)strPath.QueryStr(), METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &FullPathHandle);
                        if (FAILED(hRes)) {
                            pszFailedAPI = "ComADMOpenMetaObject";
                        }
                        else {
                            DWORD dwIdentifier;
                            switch (mdcCommand) {
                            case COMMAND_DEL_CUSTOM:
                                dwIdentifier = MD_HTTP_CUSTOM;
                                break;
                            case COMMAND_DEL_PIC:
                                dwIdentifier = MD_HTTP_PICS;
                                break;
                            case COMMAND_DEL_EXPIRES:
                                dwIdentifier = MD_HTTP_EXPIRES;
                                break;
                            case COMMAND_DEL_ACCESS:
                                dwIdentifier = MD_ACCESS_PERM;
                                break;
                            case COMMAND_DEL_AUTH:
                                dwIdentifier = MD_AUTHORIZATION;
                                break;
                            }
                            hRes = pcCom->ComADMDeleteMetaData(FullPathHandle, (PBYTE)"", dwIdentifier, ALL_METADATA);
                            if (FAILED(hRes)) {
                                pszFailedAPI = "ComADMDelMetaData";
                            }
                            else {
                                hRes = pcCom->ComADMSaveData();
                                if (FAILED(hRes)) {
                                    pszFailedAPI = "ComADMSaveData";
                                }
                            }
                            pcCom->ComADMCloseMetaObject(FullPathHandle);
                        }
                    }
                    else if (mdcCommand != COMMAND_GET_INSTANCES) {
                        LPSTR pszOutputString = NULL;
                        if (!bufReturnData.Resize(4096)) {
                            hRes = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                            pszFailedAPI = "BufferResize";
                        }
                        else {
                            DWORD dwRequiredDataLen;
                            MD_SET_DATA_RECORD(&mdrData,
                                               0,
                                               METADATA_INHERIT | METADATA_PARTIAL_PATH,
                                               0,
                                               0,
                                               bufReturnData.QuerySize(),
                                               (PBYTE)(bufReturnData.QueryPtr()));
                            switch (mdcCommand) {
                            case COMMAND_GET_CUSTOM:
                                pszOutputString = "Custom Headers = ";
                                mdrData.dwMDIdentifier = MD_HTTP_CUSTOM;
                                break;
                            case COMMAND_GET_BINARY:
                                pszOutputString = "Binary data = ";
                                mdrData.dwMDIdentifier = dwMdIdentifier;
                                break;
                            case COMMAND_GET_PIC:
                                pszOutputString = "PIC Headers = ";
                                mdrData.dwMDIdentifier = MD_HTTP_PICS;
                                break;
                            case COMMAND_GET_EXPIRES:
                                pszOutputString = "Expires = ";
                                mdrData.dwMDIdentifier = MD_HTTP_EXPIRES;
                                break;
                            case COMMAND_GET_ACCESS:
                                pszOutputString = "Access Permissions = ";
                                mdrData.dwMDIdentifier = MD_ACCESS_PERM;
                                break;
                            case COMMAND_GET_AUTH:
                                pszOutputString = "Authorization = ";
                                mdrData.dwMDIdentifier = MD_AUTHORIZATION;
                                break;
                            }
                            hRes = pcCom->ComADMGetMetaData(METADATA_MASTER_ROOT_HANDLE,
                                (PBYTE)strPath.QueryStr(), &mdrData, &dwRequiredDataLen);
                            if (FAILED(hRes)) {
                                if (hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
                                    if (!bufReturnData.Resize(dwRequiredDataLen)) {
                                        hRes = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                        pszFailedAPI = "BufferResize";
                                    }
                                    else {
                                        mdrData.dwMDDataLen = bufReturnData.QuerySize();
                                        mdrData.pbMDData = (PBYTE)bufReturnData.QueryPtr();
                                        hRes = pcCom->ComADMGetMetaData(METADATA_MASTER_ROOT_HANDLE,
                                            (PBYTE)strPath.QueryStr(), &mdrData, &dwRequiredDataLen);
                                        if (FAILED(hRes)) {
                                            pszFailedAPI = "ComADMGetMetaData";
                                        }
                                    }
                                }
                                else {
                                    pszFailedAPI = "ComADMGetMetaData";
                                }
                            }
                            if (SUCCEEDED(hRes)) {
                                if ( mdcCommand == COMMAND_GET_BINARY )
                                {
                                    WriteFile( pszFilename, mdrData.pbMDData, mdrData.dwMDDataLen );
                                }
                                else
                                {
                                    PrintDataBuffer(&mdrData, pszOutputString);
                                }
                            }
                        }
                    }
                    else { // mdcCommand == COMMAND_GET_INSTANCES
                        CHAR NameBuf[METADATA_MAX_NAME_LEN];
                        BOOL bInstanceFound = FALSE;
                        LPIIS_INSTANCE_INFO_1 piii1Buffer;
                        WCHAR pwszServerName[MAX_PATH+2];
                        WCHAR *pwszServer = NULL;
                        DWORD dwInstance;
                        DWORD err;

                        if (pcsiParam != NULL) {
                            wsprintfW( pwszServerName, L"\\\\%s", rgchMachineName);
                            pwszServer = pwszServerName;
                        }
                        for (i=0;SUCCEEDED(hRes);i++) {
                            hRes = pcCom->ComADMEnumMetaObjects(METADATA_MASTER_ROOT_HANDLE,
                                                               (PBYTE)strPath.QueryStr(), (PBYTE)NameBuf, i);
                            if ((SUCCEEDED(hRes)) && (CheckNumber(NameBuf) == SYNTAX_NO_ERROR)) {
                                printf("Instance: %s\n", NameBuf);
                                bInstanceFound = TRUE;
                                dwInstance = atoi(NameBuf);
                                piii1Buffer = NULL;
                                err = IISGetAdminInformation(
                                                        pwszServer,
                                                        1,
                                                        INET_HTTP_SVC_ID,
                                                        dwInstance,
                                                        (LPBYTE*)&piii1Buffer
                                                        );

                                if ( err == NO_ERROR ) {

                                    DWORD i;

                                    printf("    Host Name = %S\n",piii1Buffer->lpszHostName);
                                    printf("    Port Number = %d\n",piii1Buffer->sPort);
                                    printf("    Number Virtual Roots = %d\n",piii1Buffer->VirtualRoots->cEntries);

                                    for (i=0 ; i < piii1Buffer->VirtualRoots->cEntries ;i++ ) {
                                        printf("    Virtual Root %S\n        Directory %S\n",
                                            piii1Buffer->VirtualRoots->aVirtRootEntry[i].pszRoot,
                                            piii1Buffer->VirtualRoots->aVirtRootEntry[i].pszDirectory);
                                    }

                                    midl_user_free( piii1Buffer );
                                }
                                else {
                                    printf("    Unable to get information for instance %s.\n", NameBuf);
                                    printf("    Probable Cause: The web server is not started on %S.\n",
                                           (pwszServer != NULL) ? pwszServer : L"Local Machine");
                                }
                            }
                        }
                        if (bInstanceFound) {
                            hRes = ERROR_SUCCESS;
                        }
                        else {
                            pszFailedAPI = "ComADMEnumMetaObjects";
                        }
                    }
                }
                pcCom->ComADMTerminate( FALSE );
            }
            if ( pcCom )
            {
                pcCom->Release();
            }
        }
        CoUninitialize();
    }

    PrintResults(hRes, pszFailedAPI);

    DELETE_DEBUG_PRINT_OBJECT( );

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\comtest\main.cxx ===
#include <windows.h>
#define INITGUID

#include <ole2.h>
#include <stdio.h>
#include <sink.hxx>
#include <iadm.h>

#define MD_TEST_MAX_STRING_LEN   2048
#define MD_TEST_MAX_BINARY_LEN   2048

#define FILL_RETURN_BUFF   for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;
#define SET_RETURN_DATA    {ReturnDataLen=sizeof(ReturnBuf);ReturnUserType=0;ReturnDataType=0;ReturnAttributes=(METADATA_INHERIT | METADATA_PARTIAL_PATH);FILL_RETURN_BUFF}
#define MD_SET_DATA_RECORD(PMDR, ID, ATTR, UTYPE, DTYPE, DLEN, PD) \
            { \
            (PMDR)->dwMDIdentifier=ID; \
            (PMDR)->dwMDAttributes=ATTR; \
            (PMDR)->dwMDUserType=UTYPE; \
            (PMDR)->dwMDDataType=DTYPE; \
            (PMDR)->dwMDDataLen=DLEN; \
            (PMDR)->pbMDData=PD; \
            }

#define TIMEOUT_VALUE      1000
#define INITIAL_TIMEOUT_VALUE 15000

#define DWORD_DATA_NAME    1
#define BINARY_DATA_NAME   2
#define STRING_DATA_NAME   3
#define BAD_BINARY_DATA_NAME 4

#define DWORD_DATA_NAME_INHERIT 5

#define DWORD_DATA_NAME_NO_INHERIT 6

#define REFERENCE_DATA_NAME  7

#define EXPANDSZ_DATA_NAME   8

#define MULTISZ_DATA_NAME   9

#define VOLATILE_DATA_NAME 10

#define INSERT_PATH_DATA_NAME  11

#define MAX_DATA_ENTRIES   5
#define MY_GREATEROF(p1,p2) ((p1) > (p2))?(p1):(p2)
#define MAX_BUFFER_LEN     MY_GREATEROF((MD_TEST_MAX_STRING_LEN * sizeof(TCHAR)), MD_TEST_MAX_BINARY_LEN)
#define BUFFER_SIZE        5000

#define HUNDREDNANOSECONDSPERSECOND (DWORDLONG)10000000
#define HUNDREDNANOSECONDSPERMINUTE (HUNDREDNANOSECONDSPERSECOND * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERHOUR (HUNDREDNANOSECONDSPERMINUTE * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERDAY (HUNDREDNANOSECONDSPERHOUR * (DWORDLONG)24)
#define HUNDREDNANOSECONDSPERYEAR ((HUNDREDNANOSECONDSPERDAY * (DWORDLONG)365) + (HUNDREDNANOSECONDSPERDAY / (DWORDLONG)4))

#define INSERT_PATH_DATA "The path should be inserted here: " MD_INSERT_PATH_STRING " :Before here"

#define SET_GETALL_PARMS(p1) dwBufferSize = BUFFER_SIZE;dwNumDataEntries = MAX_DATA_ENTRIES;dwDataSetNumber=0;for (i=0;i<p1;i++){structDataEntries[i].pbMDData=binDataEntries[i];}

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}

VOID
PrintTime(PFILETIME pftTime)
{
    DWORDLONG dwlTime = *(PDWORDLONG)pftTime;
    printf("Year = %d\n", ((DWORD)(dwlTime / (DWORDLONG)HUNDREDNANOSECONDSPERYEAR)) + 1601);
    printf("Day = %d\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERYEAR) / (DWORDLONG)HUNDREDNANOSECONDSPERDAY));
    printf("Time = %d minutes\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERDAY) / (DWORDLONG)HUNDREDNANOSECONDSPERMINUTE));

    ULARGE_INTEGER uliTime = *(PULARGE_INTEGER)pftTime;
    printf("Time High Word = %X, Low Word = %X\n", uliTime.HighPart, uliTime.LowPart);

}

LPSTR
ConvertDataTypeToString(DWORD dwDataType)
{
    LPTSTR strReturn;
    switch (dwDataType) {
    case DWORD_METADATA:
        strReturn = "DWORD";
        break;
    case STRING_METADATA:
        strReturn = "STRING";
        break;
    case BINARY_METADATA:
        strReturn = "BINARY";
        break;
    case EXPANDSZ_METADATA:
        strReturn = "EXPANDSZ";
        break;
    case MULTISZ_METADATA:
        strReturn = "MULTISZ";
        break;
    case ALL_METADATA:
        strReturn = "ALL";
        break;
    default:
        strReturn = "Invalid Data Type";
    }
    return (strReturn);
}

VOID
PrintDataBuffer(PMETADATA_RECORD pmdrData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes, pmdrData->dwMDUserType,
        ConvertDataTypeToString(pmdrData->dwMDDataType), pmdrData->dwMDDataLen, pmdrData->dwMDDataTag);
    if (bPrintData) {
        printf(", Data = ");
        if (pmdrData->pbMDData != NULL) {
            switch (pmdrData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)(pmdrData->pbMDData));
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%s", (LPTSTR)(pmdrData->pbMDData));
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)(pmdrData->pbMDData))[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPSTR pszData = (LPSTR) pmdrData->pbMDData;
                for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                    if (pszData[i] != '\0') {
                        printf("%c", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
        else {
            printf("NULL");
        }
    }
    printf("\n");
}

VOID
PrintGetAllDataBuffer(PBYTE pbBase, PMETADATA_GETALL_RECORD pmdgarData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdgarData->dwMDIdentifier, pmdgarData->dwMDAttributes, pmdgarData->dwMDUserType,
        ConvertDataTypeToString(pmdgarData->dwMDDataType), pmdgarData->dwMDDataLen, pmdgarData->dwMDDataTag);
    if (bPrintData) {
        PBYTE pbData;
        if (pmdgarData->dwMDDataTag != 0) {
            printf(", Reference Data Address = 0x%x", (DWORD)pmdgarData->pbMDData);
        }
        else {
            printf(", Data = ");
            pbData = pbBase + (pmdgarData->dwMDDataOffset);
            switch (pmdgarData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)pbData);
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%s", (LPTSTR)pbData);
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdgarData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)pbData)[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPSTR pszData = (LPSTR) pbData;
                for (i = 0; i < pmdgarData->dwMDDataLen; i++) {
                    if (pszData[i] != '\0') {
                        printf("%c", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
    }
    printf("\n");
}

LPSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = "ERROR_SUCCESS";
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = "ERROR_PATH_NOT_FOUND";
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = "ERROR_INVALID_HANDLE";
        break;
    case ERROR_INVALID_DATA:
        RetCode = "ERROR_INVALID_DATA";
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode = "ERROR_INVALID_PARAMETER";
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode = "ERROR_NOT_SUPPORTED";
        break;
    case ERROR_ACCESS_DENIED:
        RetCode = "ERROR_ACCESS_DENIED";
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode = "ERROR_NOT_ENOUGH_MEMORY";
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode = "ERROR_FILE_NOT_FOUND";
        break;
    case ERROR_DUP_NAME:
        RetCode = "ERROR_DUP_NAME";
        break;
    case ERROR_PATH_BUSY:
        RetCode = "ERROR_PATH_BUSY";
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode = "ERROR_NO_MORE_ITEMS";
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode = "ERROR_INSUFFICIENT_BUFFER";
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode = "ERROR_PROC_NOT_FOUND";
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode = "ERROR_INTERNAL_ERROR";
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode = "MD_ERROR_NOT_INITIALIZED";
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode = "MD_ERROR_DATA_NOT_FOUND";
        break;
    case MD_ERROR_INVALID_VERSION:
        RetCode = "MD_ERROR_INVALID_VERSION";
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode = "ERROR_ALREADY_EXISTS";
        break;
    case MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE:
        RetCode = "MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE";
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode = "MD_WARNING_PATH_NOT_FOUND";
        break;
    case MD_WARNING_DUP_NAME:
        RetCode = "MD_WARNING_DUP_NAME";
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode = "MD_WARNING_INVALID_DATA";
        break;
    case ERROR_INVALID_NAME:
        RetCode = "ERROR_INVALID_NAME";
        break;
    case REGDB_E_CLASSNOTREG:
        RetCode = "REGDB_E_CLASSNOTREG";
        break;
    case ERROR_NO_SYSTEM_RESOURCES:
        RetCode = "ERROR_NO_SYSTEM_RESOURCES";
        break;
    default:
        RetCode = "Unrecognized Error Code";
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPSTR ConvertHresToString(HRESULT hRes)
{
    LPSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_INTERNET) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        strReturn = "Unrecognized hRes facility";
    }
    return(strReturn);
}

void
ConsumeRegistry(IMSAdminBase * pcCom, METADATA_HANDLE hHandle, LPTSTR pszPath, DWORD dwUnitSize = 10000);

void
ConsumeRegistry(IMSAdminBase * pcCom, METADATA_HANDLE hHandle, LPTSTR pszPath, DWORD dwUnitSize)
{
    METADATA_RECORD mdrData;
    HRESULT hRes = ERROR_SUCCESS;
    DWORD i;

    BYTE *bData = new BYTE[dwUnitSize];

    if (bData != NULL) {

        for (i = 0; i < dwUnitSize; i++) {
            bData[i] = 0;
        }

        for (i = 0; SUCCEEDED(hRes); i++) {
            MD_SET_DATA_RECORD(&mdrData, i, METADATA_NO_ATTRIBUTES, 0, BINARY_METADATA, dwUnitSize, bData)
            hRes = pcCom->SetData(hHandle,
                (PBYTE)pszPath,
                &mdrData);
            printf("MDSetMetaData(hHandle, %s, &mdrData); Returns %s\n",
                pszPath,
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                hRes = pcCom->SaveData();
                printf("\nMDSaveData(); Returns hRes = %X, %s\n",
                    hRes,
                    ConvertHresToString(hRes));

            }
            (bData[i % dwUnitSize])++;
        }
        delete (bData);
    }
}

DWORD
SetMultisz(LPSTR pszBuffer, LPSTR ppszStrings[], DWORD dwNumStrings)
{
    DWORD i;
    LPSTR pszIndex = pszBuffer;

    for (i = 0; i < dwNumStrings; i++) {
        strcpy(pszIndex, ppszStrings[i]);
        pszIndex += strlen(pszIndex) + 1;
    }

    *pszIndex = '\0';

    return ((pszIndex - pszBuffer) + 1);

}

DWORD
GetMultiszDataLen(LPSTR pszData)
{
    DWORD i;

    for (i = 1; (pszData[i-1] != (TCHAR)'\0') || (pszData[i] != (TCHAR)'\0'); i++) {
    }

    return(i + 1);
}

DWORD __cdecl
main( INT    cArgs,
      char * pArgs[] )
{
    DWORD RetCode;
    DWORD TestDword = 3;
    int TestBinary[] = {1,2,3,4};
    int i, ReturnIndex;
    DWORD ReturnDword = 0;
    DWORD ReturnAttributes = 0;
    DWORD ReturnDataType = 0;
    DWORD ReturnUserType = 0;
    METADATA_RECORD mdrData;
    UCHAR ReturnBuf[MAX_BUFFER_LEN];
    DWORD ReturnDataLen = sizeof(ReturnBuf);
    DWORD dwRequiredDataLen = 0;
    DWORD dwRequiredBufferLen = 0;
    TCHAR NameBuf[METADATA_MAX_NAME_LEN];
    METADATA_HANDLE OpenHandle, RootHandle;
    DWORD ReturnDataIdentifier;
    METADATA_RECORD structDataEntries[MAX_DATA_ENTRIES];
    BYTE binDataEntries[MAX_DATA_ENTRIES][MAX_BUFFER_LEN];
    DWORD dwNumDataEntries;
    BYTE pbBuffer[BUFFER_SIZE];
    DWORD dwBufferSize = BUFFER_SIZE;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam;
    OLECHAR rgchName[256];
    DWORD dwSystemChangeNumber;
    DWORD dwDataSetNumber;
    METADATA_HANDLE_INFO mhiInfo;
    FILETIME ftTime;
    LPSTR ppszData[10];
    DWORD dwMultiszLen;

    IClassFactory * pcsfFactory = NULL;
    IClassFactory * pcsfFactory2 = NULL;
    IMSAdminBase * pcCom = NULL;
    HRESULT hRes;
    CImpIADMCOMSINK *pEventSink = new CImpIADMCOMSINK();
    IConnectionPoint* pConnPoint = NULL;
    IConnectionPointContainer* pConnPointContainer = NULL;
    DWORD dwCookie;
    BOOL bSinkConnected = FALSE;

    if (cArgs > 1) {
        for (i = 0; pArgs[1][i] != '\0'; i++) {
            rgchName[i] = (OLECHAR) pArgs[1][i];
        }
        csiName.pwszName =  rgchName;
        csiName.pAuthInfo = NULL;
        pcsiParam = &csiName;
    }
    else {
        pcsiParam = NULL;
    }

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        printf("CoInitializeEx Failed\n");
    }


    hRes = CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void**) &pcCom);
    if (FAILED(hRes)) {
        printf("CoCreateInstance Attaching to service failed, hRes = %X\n", hRes);
        hRes = CoCreateInstance(GETAdminBaseCLSID(FALSE), NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void**) &pcCom);
    }
    if (FAILED(hRes)) {
        printf("CoCreateInstance attaching to exe failed, hRes = %X\n", hRes);
    }
    else {{


/*
    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
    printf("CoGetClassObject(GETMDCLSID(TRUE), ...; Returns hRes = %x, %s\n",
        hRes, ConvertHresToString(hRes));
    if (FAILED(hRes)) {
        hRes = CoGetClassObject(GETAdminBaseCLSID(FALSE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
        printf("CoGetClassObject(GETMDCLSID(FALSE), ...; Returns hRes = %x, %s\n",
            hRes, ConvertHresToString(hRes));
    }

    if (FAILED(hRes)) {
    }
    else {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pcCom);
        printf("Factory->CreateInstance(...); Returns hRes = %X, %s\n",
            hRes, ConvertHresToString(hRes));

        pcsfFactory->Release();
        printf("Factory->Release() called\n");

        if (FAILED(hRes)) {
            printf("Factory->CreateInstance failed, hRes = %X\n", hRes);
        }
        else {
*/
/*
        hRes = pcCom->Initialize();

        hRes = pcCom->AddKey(METADATA_MASTER_ROOT_HANDLE, sizeof("Garbage"), (unsigned char *)"Garbage");

        hRes = pcCom->Terminate(FALSE);

        hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, sizeof(""), (PBYTE)"", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
        printf("MDOpenKey(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
            ConvertHresToString(hRes));

*/

        // First query the object for its Connection Point Container. This
        // essentially asks the object in the server if it is connectable.
        hRes = pcCom->QueryInterface(
               IID_IConnectionPointContainer,
               (PVOID *)&pConnPointContainer);
        if SUCCEEDED(hRes)
        {
          // Find the requested Connection Point. This AddRef's the
          // returned pointer.
          hRes = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
          if (SUCCEEDED(hRes)) {
              hRes = pConnPoint->Advise((IUnknown *)pEventSink, &dwCookie);
              if (SUCCEEDED(hRes)) {
                  bSinkConnected = TRUE;
              }
              printf("pConnPoint->Advise((IUnknown *)pEventSink, &dwCookie); Returns %s\n", ConvertHresToString(hRes));
          }

          RELEASE_INTERFACE(pConnPointContainer);
        }

/*
        hRes = pcCom->Initialize();
        printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

        if (SUCCEEDED(hRes))  {

            hRes = pcCom->Initialize();
            printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

            if (SUCCEEDED(hRes))  {
                hRes = pcCom->Terminate(FALSE);
                printf("\nMDTerminate(FALSE); Returns %s\n",
                    ConvertHresToString(hRes));
            }
*/
        hRes = pcCom->GetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"Root Object", &ftTime, FALSE);
        printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
            ConvertHresToString(hRes));
        if (SUCCEEDED(hRes)) {
            PrintTime(&ftTime);
        }

        hRes = pcCom->GetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime, FALSE);
        printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime); Returns %s\n",
            ConvertHresToString(hRes));
        if (SUCCEEDED(hRes)) {
            PrintTime(&ftTime);
        }

        hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
        printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
            ConvertHresToString(hRes));
        if (!FAILED(hRes)) {
            printf("System Change Number = %d\n", dwSystemChangeNumber);
        }

        hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, INITIAL_TIMEOUT_VALUE, &RootHandle);
        printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
            ConvertHresToString(hRes));

        if (!FAILED(hRes)) {

            hRes = pcCom->DeleteAllData(RootHandle, (PBYTE)"Root Object", ALL_METADATA, ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteAllData(RootHandle, (PBYTE)"junk 1", ALL_METADATA, ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"junk 1\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteChildKeys(RootHandle, (PBYTE)"junk 1");
            printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"junk 1\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteChildKeys(RootHandle, (PBYTE)"Root Object");
            printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"Root Object\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteKey(RootHandle, (PBYTE)"Root Object");
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertHresToString(hRes));

            //
            // Delete everything we created last time.
            //

            hRes = pcCom->DeleteKey(RootHandle, (PBYTE)"junk 1");
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"junk 1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetHandleInfo(RootHandle, &mhiInfo);
            printf("MDGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
            }

            hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
            printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"junk 1/junk 2/junk 3/junk 4");
            printf("MDAddMetaObject(RootHandle, \"junk 1/junk 2/junk 3/junk 4\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->AddKey(RootHandle,
                (PBYTE) "junk 1/This is a very long name for a metaobject and should generate an error"
                " qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf"
                " fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf 012345");
            printf("MDAddMetaObject(RootHandle, \"junk 1/This is a very long name for a metaobject and should generate"
                   " an error qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf"
                   " fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf\"));"
                   " Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertHresToString(hRes));

//            ConsumeRegistry(pcCom, RootHandle, "Root Object");

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Child Object1");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Child Object2");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Child Object2");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Reference Object1");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Subject Object1");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Subject Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            // Create path while setting
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist 1/Doesn't Exist 2",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist 1/Doesn't Exist 2\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist 1/Doesn't Exist 2",&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist 1/Doesn't Exist 2\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 4, (PBYTE)NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 0, (PBYTE)NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            ppszData[0] = "Hello ";
            ppszData[1] = "World ";
            ppszData[2] = "Test ";
            dwMultiszLen = SetMultisz((LPSTR)binDataEntries, ppszData, 3);
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen - 1, (PBYTE)binDataEntries)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            ppszData[0] = "Hello ";
            ppszData[1] = "World ";
            ppszData[2] = "Test ";
            dwMultiszLen = SetMultisz((LPSTR)binDataEntries, ppszData, 3);
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen, (PBYTE)binDataEntries)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            ppszData[0] = "Hello ";
            ppszData[1] = INSERT_PATH_DATA;
            ppszData[2] = "Test ";
            dwMultiszLen = SetMultisz((LPSTR)binDataEntries, ppszData, 3);
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_INSERT_PATH | METADATA_INHERIT, 0, MULTISZ_METADATA, dwMultiszLen, (PBYTE)binDataEntries)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME,  METADATA_INSERT_PATH | METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include the MULTISZ Data %x without path replacement ID. Get normally.\n", MULTISZ_DATA_NAME);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include the MULTISZ Data %x with path replacement ID. Get normally.\n", MULTISZ_DATA_NAME);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, 0, METADATA_INSERT_PATH, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                DWORD_DATA_NAME, ALL_METADATA);

            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME, ALL_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }


/*
            hRes = pcCom->SetReferenceObject(RootHandle, (PBYTE)"Root Object/Reference Object1",
                RootHandle, (PBYTE)"Root Object/Reference Object1");
            printf("MDSetReferenceObject(RootHandle, TEXT(\"Root Object/Reference Object1\"),\n\tRootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                ConvertHresToString(hRes));
*/

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object", &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object", &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }
            // Test NULL String Data
            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof("STRING Data for Binary Name"), (PBYTE)"STRING Data for Binary Name")
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));


            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BAD_BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, 0x80000000, (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, FALSE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            if (pcsiParam == NULL) {
                //
                // Reference data doesn't work remotely.
                // But it sort of works on the same machine so test it here.
                //
/*
                printf("\nTESTING REFERENCE DATA\n\n");

                MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, STRING_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    hRes = pcCom->ReleaseReferenceData(mdrData.dwMDDataTag);
                    printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                        ConvertHresToString(hRes));
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->EnumData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                        if (mdrData.dwMDDataTag != 0) {
                            hRes = pcCom->ReleaseReferenceData(mdrData.dwMDDataTag);
                            printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->EnumData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                        if (mdrData.dwMDDataTag != 0) {
                            hRes = pcCom->ReleaseReferenceData(mdrData.dwMDDataTag);
                            printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                hRes = pcCom->GetAllData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                        DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                        if (dwDT != 0) {
                            hRes = pcCom->ReleaseReferenceData(dwDT);
                            printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                hRes = pcCom->GetAllData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                        DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                        if (dwDT != 0) {
                            hRes = pcCom->ReleaseReferenceData(dwDT);
                            printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                hRes = pcCom->DeleteData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    REFERENCE_DATA_NAME, ALL_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), REFERENCE_DATA_NAME, ALL_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                printf("\nEND TESTING REFERENCE DATA\n\n");
*/
            }

            MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_INSERT_PATH | METADATA_INHERIT, 0, STRING_METADATA, sizeof(INSERT_PATH_DATA), (PBYTE)INSERT_PATH_DATA)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_INSERT_PATH, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            printf("\nThis Enum should include the INSERT_PATH Data %x with path replacement ID.\n", INSERT_PATH_DATA_NAME);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, 0, METADATA_INSERT_PATH | METADATA_INHERIT, 0, STRING_METADATA, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }
            }


            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = 0;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER.\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = (dwRequiredBufferLen < BUFFER_SIZE) ? dwRequiredBufferLen : BUFFER_SIZE;
            printf("\nThis GetAll should include the INSERT_PATH Data %x with path replacement ID.\n", INSERT_PATH_DATA_NAME);
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, 0, (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED and set ISINHERITED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED and set ISINHERITED, PARTIAL_PATH only.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Should't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Should't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME_NO_INHERIT,\n\t &ReturnAttributes, &ReturnUserType, &ReturnDataType, &ReturnDataLen, (PVOID) ReturnBuf); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis Enum should set METADATA_ISINHERITED.\n");
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis Enum should set METADATA_ISINHERITED, PARTIAL_PATH only.\n");
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Shouldn't Exist",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Shouldn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"LM/W3SVC/1/Root/Scripts",
                METADATA_INHERIT | METADATA_PARTIAL_PATH, 2, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1/Root/Scripts\"),\n"
                   "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH,2, ALL_METADATA, &dwNumDataEntries,"
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);"
                   " Returns %s\n", ConvertHresToString(hRes));
            printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"LM/W3SVC/1/Root/Scripts/garbage/",
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1/Root/Scripts/garbage/\"),\n"
                   "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            //SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            dwBufferSize = 0;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                   " Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d, dwDataSetNumber = %d\n", dwRequiredBufferLen, dwDataSetNumber);

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            dwBufferSize = 101;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                   " Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = (dwRequiredBufferLen < BUFFER_SIZE)? dwRequiredBufferLen : BUFFER_SIZE;
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = BUFFER_SIZE;
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis GetAll should set METADATA_ISINHERITED.\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INHERIT | METADATA_ISINHERITED, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT | METADATA_ISINHERITED, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = BUFFER_SIZE;
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis GetAll should set METADATA_ISINHERITED, PARTIAL_PATH only.\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Shouldn't Exist",
                METADATA_INHERIT | METADATA_ISINHERITED | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Shouldn't Exist\"),\n"
                   "\tMETADATA_INHERIT | METADATA_ISINHERITED, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Partial Path Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis Partial Path GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                   "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Partial Path Enum should FAIL with ERROR_PATH_NOT_FOUND\n");
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf);
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis Partial Path GetAll should FAIL with ERROR_PATH_NOT_FOUND\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,
                dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,"
                   " dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->CopyData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                RootHandle,
                (PBYTE)"Root Object/Child Object1",
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, TRUE);
            printf("\nMDCopyMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), RootHandle,\n\tTEXT(\"Root Object/Child Object1\"), METADATA_INHERIT | METADATA_PARTIAL_PATH, 0, TRUE); Returns %s\n",
                ConvertHresToString(hRes));


            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"/Root Object", RootHandle, (PBYTE)"junk 1/Root Object", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"/Root Object\", RootHandle, (PBYTE)\"junk 1/Root Object\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/NewCopyTree/NewCopyName", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree/NewCopyName\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/NewCopyTree2/Root Object", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree2/Root Object\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", FALSE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", FALSE, FALSE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, FALSE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->RenameKey(RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", (PBYTE)"Renamed Object");
            printf("ADMRenameMetaObject(RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", (PBYTE)\"Renamed Object\"); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("ADMGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            ftTime.dwHighDateTime = 1;
            ftTime.dwLowDateTime = 2;

            hRes = pcCom->SetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime, FALSE);
            printf("ADMSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->SetLastChangeTime(RootHandle, NULL, &ftTime, FALSE);
            printf("ADMSetLastChangeTime(RootHandle, NULL, &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            printf("This SetData should set volatle and not get saved");
            MD_SET_DATA_RECORD(&mdrData, VOLATILE_DATA_NAME, METADATA_VOLATILE, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->ChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ);
            printf("ADMChangePermissions(RootHandle, METADATA_PERMISSION_READ); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->OpenKey(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
            printf("ADMOpenMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), METADATA_PERMISSION_READ, &OpenHandle); Returns %s\n\n",
                ConvertHresToString(hRes));

            if (hRes == ERROR_SUCCESS) {

                hRes = pcCom->GetHandleInfo(OpenHandle, &mhiInfo);
                printf("ADMGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
                }

                for (i=0;hRes == ERROR_SUCCESS;i++) {
                    hRes = pcCom->EnumKeys(OpenHandle, (PBYTE)"", (PBYTE)NameBuf, i);
                    printf("MDEnumMetaObjects(OpenHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                        ConvertHresToString(hRes));
                }

                hRes = pcCom->ChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ChangePermissions(OpenHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("MDChangePermissions(OpenHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->CloseKey(OpenHandle);
                printf("MDCloseMetaObject(OpenHandle); Returns %s\n\n",
                    ConvertHresToString(hRes));
            }

            for (i=0;hRes == ERROR_SUCCESS;i++) {
                hRes = pcCom->EnumKeys(RootHandle, (PBYTE)"", (PBYTE)NameBuf, i);
                printf("MDEnumMetaObjects(RootHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("Object Name = %s\n", NameBuf);
                }
            }

            hRes = pcCom->SaveData();
            printf("\nMDSaveData(); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->ChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
            printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 1, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, STRING_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, 0, 0, DWORD_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                BINARY_DATA_NAME, BINARY_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, BINARY_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->SetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime, FALSE);
            printf("MDSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                BINARY_DATA_NAME, STRING_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, STRING_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object",
                BINARY_DATA_NAME, ALL_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object/Trash",
                BINARY_DATA_NAME, ALL_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Trash\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteAllData(RootHandle,
                                                 (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                                                  ALL_METADATA,
                                                  ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteAllData(RootHandle,
                                                 (PBYTE)"Root Object",
                                                  ALL_METADATA,
                                                  ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteKey(RootHandle, (PBYTE)"Root Object/Child Object1");
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteKey(RootHandle, (PBYTE)"Root Object");
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteChildKeys(RootHandle, (PBYTE)"junk 1");
            printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"junk 1\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CloseKey(RootHandle);
            printf("MDCloseMetaObject(RootHandle); Returns %s\n",
                ConvertHresToString(hRes));



        }
/*
        hRes = pcCom->RemoveCallBack(&MDCallBack);
        printf("\nMDRemoveCallBack(&MDCallBack); Returns %s\n",
            ConvertHresToString(hRes));
*/

        hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"", METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle);
        printf("\n\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"\"), \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
            ConvertHresToString(hRes));

        if (hRes == ERROR_SUCCESS) {

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"/Root/");
            printf("\nMDAddMetaObject(RootHandle, TEXT(\"/Root/\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/instance1/Root/");
            printf("\nMDAddMetaObject(RootHandle, TEXT(\"Root Object/instance1/Root/\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CloseKey(RootHandle);
            printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"Root Object/instance1/", METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle);
            printf("\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"Root Object/instance1/\"), (PBYTE)\"Root Object/instance1/\", METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                ConvertHresToString(hRes));

            if (hRes == ERROR_SUCCESS) {

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(OpenHandle, (PBYTE)"/Root/", &mdrData);
                printf("MDSetMetaData(OpenHandle, sizeof(\"/Root/\"), (PBYTE)\"/Root/\", &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\", &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\", &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/Root/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/Root/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/Root/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/Root/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/Root/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                hRes = pcCom->CloseKey(OpenHandle);
                printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->SaveData();
                printf("\nMDSaveData(); Returns %s\n",
                    ConvertHresToString(hRes));
            }
        }
/*
            hRes = pcCom->Terminate(FALSE);
            printf("\nMDTerminate(FALSE); Returns %s\n",
                ConvertHresToString(hRes));
        }
*/

        if (bSinkConnected) {
            hRes = pConnPoint->Unadvise(dwCookie);
        }

        pcCom->Release();
    }

    }
    CoFreeUnusedLibraries();

    CoUninitialize();

    delete (pEventSink);

    return (0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\admacl.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :
      admacl.cxx

   Abstract:
      This module defines Admin API Access Check API

   Author:

       Philippe Choquier    02-Dec-1996
--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include "iiscnfgp.h"
#include <ole2.h>
#include <mdmsg.h>
#include <mdcommsg.h>
#include <imd.h>
#include <dbgutil.h>
#include <buffer.hxx>
#include <string.hxx>
#include <stringau.hxx>
#include <mb.hxx>

#include <admacl.hxx>
#include <coiadm.hxx>



//
// Globals
//

CRITICAL_SECTION CAdminAcl::m_csList;
LIST_ENTRY       CAdminAcl::m_ListHead;
LONG             CAdminAcl::m_lInList;

LONG             g_lMaxInList = 30;
DWORD            g_dwInit = 0;
CRITICAL_SECTION g_csInitCritSec;
CInitAdmacl      g_cinitadmacl;
LONG             g_lCacheAcls = 1;

extern COpenHandle g_ohMasterRootHandle;

    CInitAdmacl::CInitAdmacl()
    {
        INITIALIZE_CRITICAL_SECTION( &g_csInitCritSec );
        INITIALIZE_CRITICAL_SECTION( &CAdminAcl::m_csList );
        InitializeListHead( &CAdminAcl::m_ListHead );
        CAdminAcl::m_lInList = 0;

        DBG_REQUIRE(SUCCEEDED(g_ohMasterRootHandle.Init(METADATA_MASTER_ROOT_HANDLE,
                                                       L"",
                                                       L"",
                                                       FALSE)));
    }

CInitAdmacl::~CInitAdmacl()
{
    LIST_ENTRY*     pEntry;
    LIST_ENTRY*     pNext;
    CAdminAcl*      pAA = NULL;
    COpenHandle*       pOC;

    DBG_ASSERT(IsListEmpty( &CAdminAcl::m_ListHead ));

    DeleteCriticalSection( &CAdminAcl::m_csList );
    DeleteCriticalSection( &g_csInitCritSec );
}

//
//  Generic mapping for Application access check

GENERIC_MAPPING g_FileGenericMapping =
{
    FILE_READ_DATA,
    FILE_WRITE_DATA,
    FILE_EXECUTE,
    FILE_ALL_ACCESS
};

BOOL
AdminAclNotifyClose(
    LPVOID          pvAdmin,
    METADATA_HANDLE hAdminHandle
    )
/*++

Routine Description:

    Notify admin acl access check module of close request

Arguments:

    pvAdmin - admin context
    hAdminHandle - handle to metadata

Returns:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY*     pEntry;
    LIST_ENTRY*     pNext;
    CAdminAcl*      pAA = NULL;

    // flush cache for all entries using this handle

    EnterCriticalSection( &CAdminAcl::m_csList );

    for ( pEntry = CAdminAcl::m_ListHead.Flink ;
          pEntry != &CAdminAcl::m_ListHead ;
          pEntry =  pNext )
    {
        pAA = CONTAINING_RECORD( pEntry,
                                 CAdminAcl,
                                 CAdminAcl::m_ListEntry );
        pNext = pEntry->Flink;

        if (( pAA->GetAdminContext() == pvAdmin) &&
            ( pAA->GetAdminHandle() == hAdminHandle )) {
            RemoveEntryList( &pAA->m_ListEntry );
            delete pAA;
            InterlockedDecrement( &CAdminAcl::m_lInList );
        }
    }

    LeaveCriticalSection( &CAdminAcl::m_csList );

    return TRUE;
}

void
AdminAclDisableAclCache()
{
   EnterCriticalSection( &CAdminAcl::m_csList );

   g_lCacheAcls--;

   LeaveCriticalSection( &CAdminAcl::m_csList );
}

void
AdminAclEnableAclCache()
{
   EnterCriticalSection( &CAdminAcl::m_csList );

   g_lCacheAcls++;

   LeaveCriticalSection( &CAdminAcl::m_csList );
}

BOOL
AdminAclFlushCache(
    )
/*++

Routine Description:

    Flush cache

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY*     pEntry;
    LIST_ENTRY*     pNext;
    CAdminAcl*      pAA = NULL;

    // flush cache for all entries

    EnterCriticalSection( &CAdminAcl::m_csList );

    for ( pEntry = CAdminAcl::m_ListHead.Flink ;
          pEntry != &CAdminAcl::m_ListHead ;
          pEntry =  pNext )
    {
        pAA = CONTAINING_RECORD( pEntry,
                                 CAdminAcl,
                                 CAdminAcl::m_ListEntry );
        pNext = pEntry->Flink;

        RemoveEntryList( &pAA->m_ListEntry );
        delete pAA;
        InterlockedDecrement( &CAdminAcl::m_lInList );
    }

    LeaveCriticalSection( &CAdminAcl::m_csList );

    return TRUE;
}

BOOL
AdminAclNotifySetOrDeleteProp(
    METADATA_HANDLE hAdminHandle,
    DWORD           dwId
    )
/*++

Routine Description:

    Notify admin acl access check module of update to metabase

Arguments:

    hAdminHandle - handle to metadata
    dwId - property ID set or deleted

Returns:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY*     pEntry;
    LIST_ENTRY*     pNext;
    CAdminAcl*      pAA = NULL;
    BOOL            fSt = TRUE;
    UINT            cE;

    // flush cache for all ACLs

    if ( dwId == MD_ADMIN_ACL )
    {
        EnterCriticalSection( &CAdminAcl::m_csList );

        for ( pEntry = CAdminAcl::m_ListHead.Flink ;
              pEntry != &CAdminAcl::m_ListHead ;
              pEntry =  pNext )
        {
            pAA = CONTAINING_RECORD( pEntry,
                                     CAdminAcl,
                                     CAdminAcl::m_ListEntry );
            pNext = pEntry->Flink;

            RemoveEntryList( &pAA->m_ListEntry );
            delete pAA;
            InterlockedDecrement( &CAdminAcl::m_lInList );
        }

        LeaveCriticalSection( &CAdminAcl::m_csList );
    }

    return fSt;
}

BOOL
AdminAclAccessCheck(
    IMDCOM*         pMDCom,
    LPVOID          pvAdmin,
    METADATA_HANDLE hAdminHandle,
    LPCWSTR          pszRelPath,
    DWORD           dwId,           // check for MD_ADMIN_ACL, must have special right to write them
                                    // can be 0 for non ID based access ( enum, create )
                                    // or -1 for GetAll
    DWORD           dwAccess,       // METADATA_PERMISSION_*
    COpenHandle*    pohHandle,
    LPBOOL          pfEnableSecureAccess
    )
/*++

Routine Description:

    Perform access check based on path, ID and access type

Arguments:

    hAdminHandle - Open handle
    pszRelPath - path to object ( relative to open path )
    dwId - property ID
    dwAccess - access type, as defined by metabase header
    pfEnableSecureAccess - update with TRUE if read access to secure properties granted

Returns:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY*     pEntry;
    CAdminAcl*      pAdminAclCurrent = NULL;
    BOOL            bReturn = TRUE;
    HANDLE          hAccTok = NULL;
    LPBYTE          pAcl;
    DWORD           dwRef;
    BOOL            fIsAnyAcl;
    BOOL            bAddToCache = TRUE;

    if ( pfEnableSecureAccess )
    {
        *pfEnableSecureAccess = TRUE;
    }

    if ( pszRelPath == NULL )
    {
        pszRelPath = L"";
    }

    // find match : look for exact path match
    // keep at most N entry, reset at top of list when accessed
    // Investigate: if in <NSE> : cut-off point just before <nse>

    EnterCriticalSection( &CAdminAcl::m_csList );

    //
    // BUGBUG This checking only checks path and handle, not DCOM instance
    // So there could be incorrect matches.
    //

    for ( pEntry = CAdminAcl::m_ListHead.Flink;
          pEntry != &CAdminAcl::m_ListHead ;
          pEntry = pEntry->Flink )
    {
        pAdminAclCurrent = CONTAINING_RECORD( pEntry,
                                 CAdminAcl,
                                 CAdminAcl::m_ListEntry );

        if ((pAdminAclCurrent->GetAdminContext() == pvAdmin) &&
            (pAdminAclCurrent->GetAdminHandle() == hAdminHandle) &&
            (_wcsicmp(pAdminAclCurrent->GetPath(), pszRelPath) == 0)) {

            RemoveEntryList( &pAdminAclCurrent->m_ListEntry );
            InterlockedDecrement( &CAdminAcl::m_lInList );
            break;
        }
        else
        {
            pAdminAclCurrent = NULL;
        }
    }

    if( pAdminAclCurrent == NULL )
    {

        //
        // Check # of entries in cache, if above limit remove LRU
        //

        if ( CAdminAcl::m_lInList >= g_lMaxInList-1 )
        {
            pEntry = CAdminAcl::m_ListHead.Blink;
            pAdminAclCurrent = CONTAINING_RECORD( pEntry,
                                     CAdminAcl,
                                     CAdminAcl::m_ListEntry );
            RemoveEntryList( &pAdminAclCurrent->m_ListEntry );
            delete pAdminAclCurrent;
            InterlockedDecrement( &CAdminAcl::m_lInList );
        }

        if ( (pAdminAclCurrent = new CAdminAcl) )
        {
            // read ACL

            if ( !pohHandle->GetAcl( pMDCom, pszRelPath, &pAcl, &dwRef ) )
            {
                pAcl = NULL;
                dwRef = NULL;
            }

            //
            // BUGBUG should normalize the path so /x and x don't generate
            // 2 entries
            //

            //
            // If path is too long,
            // Go ahead and check the ACL, but don't put in cache
            //

            if ( !pAdminAclCurrent->Init( pMDCom,
                                          pvAdmin,
                                          hAdminHandle,
                                          pszRelPath,
                                          pAcl,
                                          dwRef,
                                          &bAddToCache ) )
            {

                //
                // Currently no possible failures
                //

                DBG_ASSERT(FALSE);
            }
        }
        else
        {
            //
            // failed to create new cache entry
            //

            bReturn = FALSE;
        }
    }

    if ( pAdminAclCurrent )
    {
        //
        // Access check
        //

        if ( pAcl = pAdminAclCurrent->GetAcl() )
        {
            IServerSecurity* pSec;

            //
            // test if already impersonated ( inprocess call w/o marshalling )
            // If not call DCOM to retrieve security context & impersonate, then
            // extract access token.
            //

            if ( OpenThreadToken( GetCurrentThread(),
                                  TOKEN_ALL_ACCESS,
                                  TRUE,
                                  &hAccTok ) )
            {
                pSec = NULL;
            }
            else // this thread is not impersonating -> process token
            {
                if ( SUCCEEDED( CoGetCallContext( IID_IServerSecurity, (void**)&pSec ) ) )
                {
                    pSec->ImpersonateClient();
                    if ( !OpenThreadToken( GetCurrentThread(),
                                           TOKEN_EXECUTE|TOKEN_QUERY,
                                           TRUE,
                                           &hAccTok ) )
                    {
                        hAccTok = NULL;
                    }
                }
                else
                {
                    pSec = NULL;
                }
            }

            if ( hAccTok ) // can be non null only if obtained from thread
            {
                DWORD dwAcc;

                //
                // Protected properties require EXECUTE access rights instead of WRITE
                //

                if ( dwAccess & METADATA_PERMISSION_WRITE )
                {
                    if ( dwId == MD_ADMIN_ACL ||
                         dwId == MD_APP_ISOLATED ||
                         dwId == MD_VR_PATH ||
                         dwId == MD_ACCESS_PERM ||
                         dwId == MD_ANONYMOUS_USER_NAME ||
                         dwId == MD_ANONYMOUS_PWD ||
                         dwId == MD_MAX_BANDWIDTH ||
                         dwId == MD_MAX_BANDWIDTH_BLOCKED ||
                         dwId == MD_ISM_ACCESS_CHECK ||
                         dwId == MD_FILTER_LOAD_ORDER ||
                         dwId == MD_FILTER_STATE ||
                         dwId == MD_FILTER_ENABLED ||
                         dwId == MD_FILTER_DESCRIPTION ||
                         dwId == MD_FILTER_FLAGS ||
                         dwId == MD_FILTER_IMAGE_PATH ||
                         dwId == MD_SECURE_BINDINGS ||
                         dwId == MD_SERVER_BINDINGS )
                    {
                        dwAcc = MD_ACR_RESTRICTED_WRITE;
                    }
                    else
                    {
                        dwAcc = MD_ACR_WRITE;
                    }
                }
                else // ! only METADATA_PERMISSION_WRITE
                {
                    if ( dwId == AAC_ENUM_KEYS )
                    {
                        dwAcc = MD_ACR_ENUM_KEYS;
                    }
                    else
                    {
                        // assume read access
                        dwAcc = MD_ACR_READ;
                    }
                }

                //
                // If copy or delete key, check if ACL exists in subtree
                // if yes required MD_ACR_RESTRICTED_WRITE
                //

                if ( dwAcc == MD_ACR_WRITE &&
                     (dwId == AAC_COPYKEY || dwId == AAC_DELETEKEY) )
                {
                    if ( pohHandle->CheckSubAcls( pMDCom, pszRelPath, &fIsAnyAcl ) &&
                         fIsAnyAcl )
                    {
                        dwAcc = MD_ACR_RESTRICTED_WRITE;
                    }
                }

                DWORD         dwGrantedAccess;
                BYTE          PrivSet[400];
                DWORD         cbPrivilegeSet = sizeof(PrivSet);
                BOOL          fAccessGranted;
CheckAgain:
                if ( !AccessCheck( pAcl,
                                   hAccTok,
                                   dwAcc,
                                   &g_FileGenericMapping,
                                   (PRIVILEGE_SET *) &PrivSet,
                                   &cbPrivilegeSet,
                                   &dwGrantedAccess,
                                   &fAccessGranted ) ||
                     !fAccessGranted )
                {
                    if ( dwAcc != MD_ACR_WRITE_DAC && (dwId == MD_ADMIN_ACL) )
                    {
                        dwAcc = MD_ACR_WRITE_DAC;
                        goto CheckAgain;
                    }

                    //
                    // If read access denied, retry with restricted read right
                    // only if not called from GetAll()
                    //

                    if ( dwAcc == MD_ACR_READ &&
                         pfEnableSecureAccess )
                    {
                        dwAcc = MD_ACR_UNSECURE_PROPS_READ;
                        *pfEnableSecureAccess = FALSE;
                        goto CheckAgain;
                    }
                    SetLastError( ERROR_ACCESS_DENIED );
                    bReturn = FALSE;
                }
                CloseHandle( hAccTok );
            }
            else
            {
                //
                // For now, assume failure to get IServerSecurity means we are
                // in the SYSTEM context, so grant access.
                //

                bReturn = TRUE;
            }

            if ( pSec ) // Good COM cleanp
            {
                pSec->RevertToSelf(); // better here, since
                                      // COM otherwise is reclaiming the 
                                      // thread token too late.
                pSec->Release();
            }
        }
        else
        {
            //
            // No ACL : access check succeed
            //

            bReturn = TRUE;
        }

        if (bAddToCache && IsAclCachingEnabled) {

            //
            // Set as last used in LRU list
            //
            
            //
            // Investigate how to put a breakpoint here
            //

            InsertHeadList( &CAdminAcl::m_ListHead,
                            &pAdminAclCurrent->m_ListEntry );
            InterlockedIncrement( &CAdminAcl::m_lInList );
        }
        else {
            delete pAdminAclCurrent;
        }
    }

    LeaveCriticalSection( &CAdminAcl::m_csList );

    if ( !bReturn )
    {
        SetLastError( ERROR_ACCESS_DENIED );
    }

    return bReturn;
}

CAdminAcl::~CAdminAcl(
    )
/*++

Routine Description:

    Destructor for Admin Acl cache entry

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( m_pMDCom )
    {
        if ( m_dwAclRef )
        {
            m_pMDCom->ComMDReleaseReferenceData( m_dwAclRef );
        }
        m_pMDCom->Release();
    }

    m_dwSignature = ADMINACL_FREED_SIGN;
}


BOOL
CAdminAcl::Init(
    IMDCOM*         pMDCom,
    LPVOID          pvAdmin,
    METADATA_HANDLE hAdminHandle,
    LPCWSTR         pszPath,
    LPBYTE          pAcl,
    DWORD           dwAclRef,
    PBOOL           pbIsPathCorrect
    )
/*++

Routine Description:

    Initialize an Admin Acl cache entry

Arguments:

    hAdminHandle - metadata handle
    pszPath - path to object ( absolute )
    pAcl - ptr to ACL for this path ( may be NULL )
    dwAclRef - access by reference ID

Returns:

    Nothing

--*/
{
    m_hAdminHandle = hAdminHandle;
    m_pvAdmin = pvAdmin;
    *pbIsPathCorrect = TRUE;

    if (pszPath != NULL)
    {
        if ( wcslen( pszPath ) < (sizeof(m_wchPath) / sizeof(WCHAR)) )
        {
            wcscpy( m_wchPath, pszPath );
        }
        else {
            m_wchPath[0] = (WCHAR)'\0';
            *pbIsPathCorrect = FALSE;
        }
    }
    else
    {
        m_wchPath[0] = (WCHAR)'\0';
    }
    m_pAcl = pAcl;
    m_dwAclRef = dwAclRef;
    m_pMDCom = pMDCom;
    pMDCom->AddRef();

    m_dwSignature = ADMINACL_INIT_SIGN;

    return TRUE;
}

HRESULT
COpenHandle::Init(
    METADATA_HANDLE hAdminHandle,
    LPCWSTR          pszRelPath,
    LPCWSTR          pszParentPath,
    BOOL            fIsNse
    )
/*++

Routine Description:

    Initialize an open context cache entry

Arguments:

    pvAdmin - admin context
    hAdminHandle - metadata handle
    pszRelPath - path to object ( absolute )
    fIsNse - TRUE if inside NSE

Returns:

    Nothing

--*/
{

    HRESULT hresReturn = ERROR_SUCCESS;
    LPWSTR pszRelPathIndex = (LPWSTR)pszRelPath;

    m_hAdminHandle = hAdminHandle;
    m_fIsNse = fIsNse;
    m_lRefCount = 1;

    if (pszRelPath == NULL) {
        pszRelPathIndex = L"";
    }

    DBG_ASSERT(pszParentPath != NULL);
    DBG_ASSERT((*pszParentPath == (WCHAR)'\0') ||
               ISPATHDELIMW(*pszParentPath));

    //
    // Strip front slash now, add it in later
    //

    if (ISPATHDELIMW(*pszRelPathIndex)) {
        pszRelPathIndex++;
    }

    DWORD dwRelPathLen = wcslen(pszRelPathIndex);
    DWORD dwParentPathLen = wcslen(pszParentPath);

    DBG_ASSERT((dwParentPathLen == 0) ||
               (!ISPATHDELIMW(pszParentPath[dwParentPathLen -1])));

    //
    // Get rid of trailing slash for good
    //

    if ((dwRelPathLen > 0) && (ISPATHDELIMW(pszRelPathIndex[dwRelPathLen -1]))) {
        dwRelPathLen--;
    }

    //
    // Include space for mid slash if Relpath exists
    // Include space for termination
    //

    DWORD dwTotalSize =
        (dwRelPathLen + dwParentPathLen + 1 + ((dwRelPathLen > 0) ? 1 : 0)) * sizeof(WCHAR);

    m_pszPath = (LPWSTR)LocalAlloc(LMEM_FIXED, dwTotalSize);

    if (m_pszPath == NULL) {
        hresReturn = RETURNCODETOHRESULT(GetLastError());
    }
    else {

        //
        // OK to always copy the first part
        //

        memcpy(m_pszPath,
               pszParentPath,
               dwParentPathLen * sizeof(WCHAR));

        //
        // Don't need slash if there is no RelPath
        //

        if (dwRelPathLen > 0) {

            m_pszPath[dwParentPathLen] = (WCHAR)'/';

            memcpy(m_pszPath + dwParentPathLen + 1,
                   pszRelPathIndex,
                   dwRelPathLen * sizeof(WCHAR));

        }

        m_pszPath[(dwTotalSize / sizeof(WCHAR)) - 1] = (WCHAR)'\0';

        //
        // Now convert \ to / for string compares
        //

        LPWSTR pszPathIndex = m_pszPath;

        while ((pszPathIndex = wcschr(pszPathIndex, (WCHAR)'\\')) != NULL) {
            *pszPathIndex = (WCHAR)'/';
        }

    }


    return hresReturn;
}

// Whistler 53924
/*++

  function backstrchr
  returns the last occurrence of a charcter or NULL if not found
  --*/

WCHAR * backstrchr(WCHAR * pString,WCHAR ThisChar)
{
	WCHAR *pCurrentPos = NULL;

	while(*pString){
		if (*pString == ThisChar){
            pCurrentPos = pString;
		}
		pString++;
	};
	return pCurrentPos;
}


BOOL
COpenHandle::GetAcl(
    IMDCOM* pMDCom,
    LPCWSTR  pszRelPath,
    LPBYTE* pAcl,
    LPDWORD pdwRef
    )
/*++

Routine Description:

    Retrieve Acl

Arguments:

    pszPath - path to object
    ppAcl - updated with ptr to ACL if success
    pdwRef - updated with ref to ACL if success

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;
    BOOL            bReturn = TRUE;
    METADATA_HANDLE hAdminHandle;
    LPWSTR          pszFullPath;
    LPWSTR          pszRelPathIndex = (LPWSTR)pszRelPath;



    if (pszRelPathIndex == NULL) {
        pszRelPathIndex = L"";
    }

    DBG_ASSERT(m_pszPath != NULL);
    DBG_ASSERT((*m_pszPath == (WCHAR)'\0') ||
               ISPATHDELIMW(*m_pszPath));

    //
    // Strip front slash now, add it in later
    //

    if (ISPATHDELIMW(*pszRelPathIndex)) {
        pszRelPathIndex++;
    }


    DWORD dwPathLen = wcslen(m_pszPath);
    DWORD dwRelPathLen = wcslen(pszRelPathIndex);

    DBG_ASSERT((dwPathLen == 0) ||
               (!ISPATHDELIMW(m_pszPath[dwPathLen -1])));

    //
    // Get rid of trailing slash for good
    //

    if ((dwRelPathLen > 0) && (ISPATHDELIMW(pszRelPathIndex[dwRelPathLen -1]))) {
        dwRelPathLen--;
    }

    //
    // Include space for mid slash and termination
    //

    DWORD dwTotalSize = (dwPathLen + dwRelPathLen + 1 + ((dwRelPathLen > 0) ? 1 : 0)) * sizeof(WCHAR);

    pszFullPath = (LPWSTR)LocalAlloc(LMEM_FIXED, dwTotalSize);

    if (pszFullPath == NULL) {
        bReturn = FALSE;
    }
    else {
        memcpy(pszFullPath,
               m_pszPath,
               dwPathLen * sizeof(WCHAR));

        //
        // Don't need slash if there is no RelPath
        //

        if (dwRelPathLen > 0) {
            pszFullPath[dwPathLen] = (WCHAR)'/';

            memcpy(pszFullPath + dwPathLen + 1,
                   pszRelPathIndex,
                   dwRelPathLen * sizeof(WCHAR));

        }

        pszFullPath[(dwTotalSize - sizeof(WCHAR)) / sizeof(WCHAR)] = (WCHAR)'\0';

        //
        // Now convert \ to / for string compares
        // m_pszPath was already converted, so start at relpath
        //

        LPWSTR pszPathIndex = pszFullPath + (dwPathLen);

        while ((pszPathIndex = wcschr(pszPathIndex, (WCHAR)'\\')) != NULL) {
            *pszPathIndex = (WCHAR)'/';
        }

        //
        // Use /schema ACL if path = /schema/...
        //

        if (_wcsnicmp(pszFullPath,
                      IIS_MD_ADSI_SCHEMA_PATH_W L"/",
                      ((sizeof(IIS_MD_ADSI_SCHEMA_PATH_W L"/") / sizeof(WCHAR)) - 1)) == 0) {
            pszFullPath[(sizeof(IIS_MD_ADSI_SCHEMA_PATH_W) / sizeof(WCHAR)) -1] = (WCHAR)'\0';
        }


        if ( m_fIsNse ) {

            pszPathIndex = wcschr( pszFullPath, (WCHAR)'<' );
            DBG_ASSERT(pszPathIndex != NULL);
            *pszPathIndex = (WCHAR)'\0';

            hRes = pMDCom->ComMDOpenMetaObjectW( METADATA_MASTER_ROOT_HANDLE,
                                                pszFullPath,
                                                METADATA_PERMISSION_READ,
                                                5000,
                                                &hAdminHandle );

            if ( SUCCEEDED( hRes ) )
            {
                mdRecord.dwMDIdentifier  = MD_ADMIN_ACL;
                mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_REFERENCE;
                mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;
                mdRecord.dwMDDataType    = BINARY_METADATA;
                mdRecord.dwMDDataLen     = 0;
                mdRecord.pbMDData        = NULL;
                mdRecord.dwMDDataTag     = NULL;

                hRes = pMDCom->ComMDGetMetaDataW( hAdminHandle,
                                                   L"",
                                                   &mdRecord,
                                                   &dwRequiredLen );

                if ( FAILED( hRes ) || !mdRecord.dwMDDataTag )
                {
                    bReturn = FALSE;
                }

                pMDCom->ComMDCloseMetaObject( hAdminHandle );
            }
        }
        else
        {
            mdRecord.dwMDIdentifier  = MD_ADMIN_ACL;
            mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_REFERENCE;
            mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;
            mdRecord.dwMDDataType    = BINARY_METADATA;
            mdRecord.dwMDDataLen     = 0;
            mdRecord.pbMDData        = NULL;
            mdRecord.dwMDDataTag     = NULL;

            hRes = pMDCom->ComMDGetMetaDataW( METADATA_MASTER_ROOT_HANDLE,
                                              pszFullPath,
                                              &mdRecord,
                                              &dwRequiredLen );

            // Whistler 53924
            if(HRESULTTOWIN32(hRes) == ERROR_INSUFFICIENT_BUFFER)
            {
                WCHAR * pLastSlash = NULL;
                while (pLastSlash = backstrchr(pszFullPath,L'/'))
                {
                    *pLastSlash = L'\0';
                    pLastSlash = NULL;

                    mdRecord.dwMDDataLen     = 0;
		            mdRecord.pbMDData        = NULL;
        		    mdRecord.dwMDDataTag     = NULL;

                    hRes = pMDCom->ComMDGetMetaDataW( METADATA_MASTER_ROOT_HANDLE,
                         		                      pszFullPath,
                                                      &mdRecord,
                                                      &dwRequiredLen );
                    if (SUCCEEDED(hRes)) break;
                }
            }

            if ( FAILED( hRes ) || !mdRecord.dwMDDataTag )
            {
                bReturn = FALSE;
            }
        }

        LocalFree( pszFullPath );
    }

    if ( bReturn )
    {
        *pAcl = mdRecord.pbMDData;
        *pdwRef = mdRecord.dwMDDataTag;
    }

    return bReturn;
}


BOOL
COpenHandle::CheckSubAcls(
    IMDCOM* pMDCom,
    LPCWSTR  pszRelPath,
    LPBOOL  pfIsAnyAcl
    )
/*++

Routine Description:

    Check if Acls exist in subtree

Arguments:

    pszRelPath - path to object
    pfIsAnyAcl - updated with TRUE if sub-acls exists, otherwise FALSE

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;
    BOOL            bReturn = TRUE;
    METADATA_HANDLE hAdminHandle;
    LPWSTR          pszFullPath;
    DWORD           dwPathLen;

    *pfIsAnyAcl = FALSE;

    if ( !m_fIsNse ) {
        LPWSTR          pszRelPathIndex = (LPWSTR)pszRelPath;

        if (pszRelPathIndex == NULL) {
            pszRelPathIndex = L"";
        }

        DBG_ASSERT(m_pszPath != NULL);
        DBG_ASSERT((*m_pszPath == (WCHAR)'\0') ||
                   ISPATHDELIMW(*m_pszPath));

        //
        // Strip front slash now, add it in later
        //

        if (ISPATHDELIMW(*pszRelPathIndex)) {
            pszRelPathIndex++;
        }


        DWORD dwPathLen = wcslen(m_pszPath);
        DWORD dwRelPathLen = wcslen(pszRelPathIndex);

        DBG_ASSERT((dwPathLen == 0) ||
                   (!ISPATHDELIMW(m_pszPath[dwPathLen -1])));

        //
        // Get rid of trailing slash for good
        //

        if ((dwRelPathLen > 0) && (ISPATHDELIMW(pszRelPathIndex[dwRelPathLen -1]))) {
            dwRelPathLen--;
        }

        //
        // Include space for mid slash and termination
        //

        DWORD dwTotalSize = (dwPathLen + dwRelPathLen + 1 + ((dwRelPathLen > 0) ? 1 : 0)) * sizeof(WCHAR);

        pszFullPath = (LPWSTR)LocalAlloc(LMEM_FIXED, dwTotalSize);

        if (pszFullPath == NULL) {
            bReturn = FALSE;
        }
        else {
            memcpy(pszFullPath,
                   m_pszPath,
                   dwPathLen * sizeof(WCHAR));

            //
            // Don't need slash if there is no RelPath
            //

            if (dwRelPathLen > 0) {

                pszFullPath[dwPathLen] = (WCHAR)'/';

                memcpy(pszFullPath + dwPathLen + 1,
                       pszRelPathIndex,
                       dwRelPathLen * sizeof(WCHAR));
            }

            pszFullPath[(dwTotalSize - sizeof(WCHAR)) / sizeof(WCHAR)] = (WCHAR)'\0';

            hRes = pMDCom->ComMDGetMetaDataPathsW(METADATA_MASTER_ROOT_HANDLE,
                                                 pszFullPath,
                                                 MD_ADMIN_ACL,
                                                 BINARY_METADATA,
                                                 0,
                                                 NULL,
                                                 &dwRequiredLen );

            LocalFree( pszFullPath );

            if ( FAILED( hRes ) ) {
                if ( hRes == RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER ) ) {
                    bReturn = TRUE;
                    *pfIsAnyAcl = TRUE;
                }
                else {
                    bReturn = FALSE;
                }
            }
        }
    }
    return bReturn;
}

VOID
COpenHandle::Release(PVOID pvAdmin)
{
    if (InterlockedDecrement(&m_lRefCount) == 0) {

        //
        //
        //

        AdminAclNotifyClose(pvAdmin, m_hAdminHandle);

        ((CADMCOMW *)pvAdmin)->DeleteNode(m_hAdminHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\cofact.cxx ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#include <coiadm.hxx>
#include <stdio.h>
#include <iadmext.h>
#include <iiscrypt.h>
#include <seccom.hxx>

extern ULONG g_dwRefCount;


CADMCOMSrvFactoryW::CADMCOMSrvFactoryW()
{
    m_dwRefCount=0;
}

CADMCOMSrvFactoryW::~CADMCOMSrvFactoryW()
{
}

HRESULT
CADMCOMSrvFactoryW::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void ** ppObject
    )
{
//    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactoryW::CreateInstance]\n"));

    HRESULT hresReturn = E_NOINTERFACE;

    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    if (IID_IUnknown==riid       || 
        IID_IMSAdminBase_W==riid ||
        IID_IMSAdminBase2_W==riid) {
        CADMCOMW *padmcomw = new CADMCOMW();

        if( padmcomw == NULL ) {
            hresReturn = E_OUTOFMEMORY;
        }
        else {
            hresReturn = padmcomw->GetStatus();
            if (SUCCEEDED(hresReturn)) {
                hresReturn = padmcomw->QueryInterface(riid, ppObject);
                if( FAILED(hresReturn) ) {
                    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactoryW::CreateInstance] no I/F\n"));
                }
            }
            padmcomw->Release();
        }
    }

    return hresReturn;
}

HRESULT
CADMCOMSrvFactoryW::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CADMCOMSrvFactoryW::QueryInterface(
    REFIID riid,
    void **ppObject
    )
{
//    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactoryW::QueryInterface]\n"));

    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
        *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return NO_ERROR;
}

ULONG
CADMCOMSrvFactoryW::AddRef(
    )
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    InterlockedIncrement((long *)&g_dwRefCount);
    return dwRefCount;
}

ULONG
CADMCOMSrvFactoryW::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    InterlockedDecrement((long *)&g_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}


STDAPI DllRegisterServer(
    )
{
    HKEY hKeyCLSID, hKeyInproc32;
    HKEY hKeyIF, hKeyStub32;
    HKEY hKeyAppExe, hKeyAppID, hKeyTemp;
    DWORD dwDisposition;
    BOOL bIsWin95 = FALSE;
    char pszName[MAX_PATH+1 + sizeof("inetinfo.exe -e iisadmin")];


    //
    // if win95, then don't register as service
    //

    if ( IISGetPlatformType() == PtWindows95 ) {

        bIsWin95 = TRUE;
    }

    //
    // register AppExe
    //

    HRESULT hr;

    if (bIsWin95) {

        HMODULE hModule=GetModuleHandle(TEXT("COADMIN.DLL"));
        if (!hModule) {
                return E_UNEXPECTED;
                }

        WCHAR wchName[MAX_PATH + 1];
        if (GetModuleFileName(hModule, pszName, sizeof(pszName))==0) {
                return E_UNEXPECTED;
                }

        int i;

        //
        // Set pszName to the command to start the web server
        //

        for (i = strlen(pszName) -1; (i >= 0) && (pszName[i] != '/') & (pszName[i] != '\\'); i--) {
        }

        pszName[i + 1] = '\0';
        strcat(pszName, "inetinfo.exe -e iisadmin");
    }

    //
    // register inetinfo AppID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("AppID\\inetinfo.exe"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyAppExe, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyAppExe, TEXT("AppID"), NULL, REG_SZ, (BYTE*) TEXT("{A9E69610-B80D-11D0-B9B9-00A0C922E750}"), sizeof(TEXT("{88E4BA60-537B-11D0-9B8E-00A0C922E703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyAppExe);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyAppExe);

    //
    // register AppID
    //
    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("AppID\\{A9E69610-B80D-11D0-B9B9-00A0C922E750}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyAppID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyAppID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS Admin Service"), sizeof(TEXT("IIS Admin Service")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyAppID);
                return E_UNEXPECTED;
                }

    if (!bIsWin95) {
        if (RegSetValueEx(hKeyAppID, TEXT("LocalService"), NULL, REG_SZ, (BYTE*) TEXT("IISADMIN"), sizeof(TEXT("IISADMIN")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyAppID);
            return E_UNEXPECTED;
        }
    }
    RegCloseKey(hKeyAppID);

    //
    // register CLSID
    //


    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{A9E69610-B80D-11D0-B9B9-00A0C922E750}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS Admin Service"), sizeof(TEXT("IIS Admin Servce")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT("AppID"), NULL, REG_SZ, (BYTE*) TEXT("{A9E69610-B80D-11D0-B9B9-00A0C922E750}"), sizeof(TEXT("{A9E69610-B80D-11D0-B9B9-00A0C922E750}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (bIsWin95) {
        if (RegCreateKeyEx(hKeyCLSID,
                           TEXT("LocalServer32"),
                           NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                            &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
        if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ, (BYTE*) pszName, strlen(pszName) + 1)!=ERROR_SUCCESS) {
                    RegCloseKey(hKeyTemp);
                    RegCloseKey(hKeyCLSID);
                    return E_UNEXPECTED;
                    }
        RegCloseKey(hKeyTemp);
    }
    else {
        if (RegSetValueEx(hKeyCLSID, TEXT("LocalService"), NULL, REG_SZ, (BYTE*) TEXT("IISADMIN"), sizeof(TEXT("IISADMIN")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
    }

    RegCloseKey(hKeyCLSID);

    //
    // Main Interfaces
    //

    //
    // UNICODE Main Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{70B51430-B6CA-11D0-B9B9-00A0C922E750}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("PSFactoryBuffer"), sizeof(TEXT("PSFactoryBuffer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       "InprocServer32",
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyInproc32, TEXT(""), NULL, REG_SZ, (BYTE*) "ADMWPROX.DLL", sizeof(TEXT("ADMWPROX.DLL")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyInproc32, TEXT("ThreadingModel"), NULL, REG_SZ, (BYTE*) "Both", sizeof("Both")-1 )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);
    
    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{8298d101-f992-43b7-8eca-5052d885b995}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("PSFactoryBuffer"), sizeof(TEXT("PSFactoryBuffer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       "InprocServer32",
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyInproc32, TEXT(""), NULL, REG_SZ, (BYTE*) "ADMWPROX.DLL", sizeof(TEXT("ADMWPROX.DLL")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyInproc32, TEXT("ThreadingModel"), NULL, REG_SZ, (BYTE*) "Both", sizeof("Both")-1 )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    //
    // Sink Interfaces
    //

    //
    // UNICODE Sink
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("PSFactoryBuffer"), sizeof(TEXT("PSFactoryBuffer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       "InprocServer32",
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyInproc32, TEXT(""), NULL, REG_SZ, (BYTE*) "ADMWPROX.DLL", sizeof(TEXT("ADMWPROX.DLL")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyInproc32, TEXT("ThreadingModel"), NULL, REG_SZ, (BYTE*) "Both", sizeof("Both")-1 )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    //
    // register Interfaces
    //

    //
    // UNICODE Main Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{70B51430-B6CA-11D0-B9B9-00A0C922E750}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IADMCOM"), sizeof(TEXT("IADMCOM")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyIF,
                    "ProxyStubClsid32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{70B51430-B6CA-11D0-B9B9-00A0C922E750}", sizeof("{70B51430-B6CA-11D0-B9B9-00A0C922E750}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{8298d101-f992-43b7-8eca-5052d885b995}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IADMCOM2"), sizeof(TEXT("IADMCOM2")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyIF,
                    "ProxyStubClsid32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{8298d101-f992-43b7-8eca-5052d885b995}", sizeof("{8298d101-f992-43b7-8eca-5052d885b995}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    //
    // UNICODE Sink Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IADMCOMSINK"), sizeof(TEXT("IADMCOMSINK")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyIF,
                    "ProxyStubClsid32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{A9E69612-B80D-11D0-B9B9-00A0C922E750}", sizeof("{A9E69612-B80D-11D0-B9B9-00A0C922E750}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    // an entry for async version
    if (RegSetValueEx(hKeyStub32, "AsynchronousInterface", NULL, REG_SZ, (BYTE*)"{A9E69613-B80D-11D0-B9B9-00A0C922E750}", sizeof("{A9E69613-B80D-11D0-B9B9-00A0C922E750}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    //
    // UNICODE Async Sink Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{A9E69613-B80D-11D0-B9B9-00A0C922E750}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("AsyncIADMCOMSINK"), sizeof(TEXT("AsyncIADMCOMSINK")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    // back link to synchronous version
    if (RegCreateKeyEx(hKeyIF,
                    "SynchronousInterface",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{A9E69612-B80D-11D0-B9B9-00A0C922E750}", sizeof("{A9E69612-B80D-11D0-B9B9-00A0C922E750}"))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            return E_UNEXPECTED;
            }


    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);
    //
    // IISADMIN registry entries
    //

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                    IISADMIN_EXTENSIONS_REG_KEY,
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }
    RegCloseKey(hKeyIF);

    return NOERROR;
}

STDAPI DllUnregisterServer(void) {

    BOOL bIsWin95 = FALSE;


    //
    // if win95, then don't register as service
    //

    if ( IISGetPlatformType() == PtWindows95 ) {

        bIsWin95 = TRUE;
    }

    //
    // Delete Crypto Keys
    //


    if (!bIsWin95) {
        HRESULT hres;
        hres = IISCryptoInitialize();
        if (SUCCEEDED(hres)) {

            IISCryptoDeleteContainerByName(DCOM_SERVER_CONTAINER,
                                           0);

            IISCryptoDeleteContainerByName(DCOM_SERVER_CONTAINER,
                                           CRYPT_MACHINE_KEYSET);

            IISCryptoDeleteContainerByName(DCOM_CLIENT_CONTAINER,
                                           0);

            IISCryptoDeleteContainerByName(DCOM_CLIENT_CONTAINER,
                                           CRYPT_MACHINE_KEYSET);

            IISCryptoTerminate();

        }
    }

    //
    // register AppID
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\inetinfo.exe"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{A9E69610-B80D-11D0-B9B9-00A0C922E750}"));

    //
    // register CLSID
    //

    if (bIsWin95) {
        RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}\\LocalServer32"));
    }

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}"));

    if (bIsWin95) {
        RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{A9E69610-B80D-11D0-B9B9-00A0C922E750}\\LocalServer32"));
    }

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{A9E69610-B80D-11D0-B9B9-00A0C922E750}"));

    //
    // Main Interfaces
    //

    //
    // ANSI Main Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}"));

    //
    // UNICODE Main Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{70B51430-B6CA-11D0-B9B9-00A0C922E750}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{70B51430-B6CA-11D0-B9B9-00A0C922E750}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{8298d101-f992-43b7-8eca-5052d885b995}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{8298d101-f992-43b7-8eca-5052d885b995}"));

    //
    // Sink Interfaces
    //

    //
    // Ansi Sink
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{1E056350-761E-11D0-9BA1-00A0C922E703}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{1E056350-761E-11D0-9BA1-00A0C922E703}"));

    //
    // UNICODE Sink
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}"));


    //
    // deregister Interfaces
    //

    //
    // ANSI Main Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}"));

    //
    // UNICODE Main Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{70B51430-B6CA-11d0-B9B9-00A0C922E750}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{70B51430-B6CA-11d0-B9B9-00A0C922E750}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{8298d101-f992-43b7-8eca-5052d885b995}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{8298d101-f992-43b7-8eca-5052d885b995}"));

    //
    // ANSI Sink Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{1E056350-761E-11D0-9BA1-00A0C922E703}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{1E056350-761E-11D0-9BA1-00A0C922E703}"));

    //
    // UNICODE Sink Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}"));

    //
    // UNICODE Async Sink
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{A9E69613-B80D-11D0-B9B9-00A0C922E750}\\SynchronousInterface"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{A9E69613-B80D-11D0-B9B9-00A0C922E750}"));
    //
    // IISADMIN registry entries
    //

    RegDeleteKey(HKEY_LOCAL_MACHINE, IISADMIN_EXTENSIONS_REG_KEY);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\comtest\beta2\main.cxx ===
#include <windows.h>
#define INITGUID

#include <ole2.h>
#include <stdio.h>
#include <sink.hxx>
#include <iadm.h>

#define MD_TEST_MAX_STRING_LEN   2048
#define MD_TEST_MAX_BINARY_LEN   2048

#define FILL_RETURN_BUFF   for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;
#define SET_RETURN_DATA    {ReturnDataLen=sizeof(ReturnBuf);ReturnUserType=0;ReturnDataType=0;ReturnAttributes=(METADATA_INHERIT | METADATA_PARTIAL_PATH);FILL_RETURN_BUFF}
#define MD_SET_DATA_RECORD(PMDR, ID, ATTR, UTYPE, DTYPE, DLEN, PD) \
            { \
            (PMDR)->dwMDIdentifier=ID; \
            (PMDR)->dwMDAttributes=ATTR; \
            (PMDR)->dwMDUserType=UTYPE; \
            (PMDR)->dwMDDataType=DTYPE; \
            (PMDR)->dwMDDataLen=DLEN; \
            (PMDR)->pbMDData=PD; \
            }

#define TIMEOUT_VALUE      1000
#define INITIAL_TIMEOUT_VALUE 15000

#define DWORD_DATA_NAME    1
#define BINARY_DATA_NAME   2
#define STRING_DATA_NAME   3
#define BAD_BINARY_DATA_NAME 4

#define DWORD_DATA_NAME_INHERIT 5

#define DWORD_DATA_NAME_NO_INHERIT 6

#define REFERENCE_DATA_NAME  7

#define EXPANDSZ_DATA_NAME   8

#define MULTISZ_DATA_NAME   9

#define VOLATILE_DATA_NAME 10

#define MAX_DATA_ENTRIES   5
#define MY_GREATEROF(p1,p2) ((p1) > (p2))?(p1):(p2)
#define MAX_BUFFER_LEN     MY_GREATEROF((MD_TEST_MAX_STRING_LEN * sizeof(TCHAR)), MD_TEST_MAX_BINARY_LEN)
#define BUFFER_SIZE        5000

#define HUNDREDNANOSECONDSPERSECOND (DWORDLONG)10000000
#define HUNDREDNANOSECONDSPERMINUTE (HUNDREDNANOSECONDSPERSECOND * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERHOUR (HUNDREDNANOSECONDSPERMINUTE * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERDAY (HUNDREDNANOSECONDSPERHOUR * (DWORDLONG)24)
#define HUNDREDNANOSECONDSPERYEAR ((HUNDREDNANOSECONDSPERDAY * (DWORDLONG)365) + (HUNDREDNANOSECONDSPERDAY / (DWORDLONG)4))


#define SET_GETALL_PARMS(p1) dwBufferSize = BUFFER_SIZE;dwNumDataEntries = MAX_DATA_ENTRIES;dwDataSetNumber=0;for (i=0;i<p1;i++){structDataEntries[i].pbMDData=binDataEntries[i];}

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}

VOID
PrintTime(PFILETIME pftTime)
{
    DWORDLONG dwlTime = *(PDWORDLONG)pftTime;
    printf("Year = %d\n", ((DWORD)(dwlTime / (DWORDLONG)HUNDREDNANOSECONDSPERYEAR)) + 1601);
    printf("Day = %d\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERYEAR) / (DWORDLONG)HUNDREDNANOSECONDSPERDAY));
    printf("Time = %d minutes\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERDAY) / (DWORDLONG)HUNDREDNANOSECONDSPERMINUTE));

    ULARGE_INTEGER uliTime = *(PULARGE_INTEGER)pftTime;
    printf("Time High Word = %X, Low Word = %X\n", uliTime.HighPart, uliTime.LowPart);

}

LPSTR
ConvertDataTypeToString(DWORD dwDataType)
{
    LPTSTR strReturn;
    switch (dwDataType) {
    case DWORD_METADATA:
        strReturn = "DWORD";
        break;
    case STRING_METADATA:
        strReturn = "STRING";
        break;
    case BINARY_METADATA:
        strReturn = "BINARY";
        break;
    case EXPANDSZ_METADATA:
        strReturn = "EXPANDSZ";
        break;
    case MULTISZ_METADATA:
        strReturn = "MULTISZ";
        break;
    case ALL_METADATA:
        strReturn = "ALL";
        break;
    default:
        strReturn = "Invalid Data Type";
    }
    return (strReturn);
}

VOID
PrintDataBuffer(PMETADATA_RECORD pmdrData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes, pmdrData->dwMDUserType,
        ConvertDataTypeToString(pmdrData->dwMDDataType), pmdrData->dwMDDataLen, pmdrData->dwMDDataTag);
    if (bPrintData) {
        printf(", Data = ");
        if (pmdrData->pbMDData != NULL) {
            switch (pmdrData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)(pmdrData->pbMDData));
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%s", (LPTSTR)(pmdrData->pbMDData));
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)(pmdrData->pbMDData))[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPSTR pszData = (LPSTR) pmdrData->pbMDData;
                for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                    if (pszData[i] != '\0') {
                        printf("%c", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
        else {
            printf("NULL");
        }
    }
    printf("\n");
}

VOID
PrintGetAllDataBuffer(PBYTE pbBase, PMETADATA_GETALL_RECORD pmdgarData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdgarData->dwMDIdentifier, pmdgarData->dwMDAttributes, pmdgarData->dwMDUserType,
        ConvertDataTypeToString(pmdgarData->dwMDDataType), pmdgarData->dwMDDataLen, pmdgarData->dwMDDataTag);
    if (bPrintData) {
        PBYTE pbData;
        if (pmdgarData->dwMDDataTag != 0) {
            printf(", Reference Data Address = 0x%x", (DWORD)pmdgarData->pbMDData);
        }
        else {
            printf(", Data = ");
            pbData = pbBase + (pmdgarData->dwMDDataOffset);
            switch (pmdgarData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)pbData);
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%s", (LPTSTR)pbData);
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdgarData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)pbData)[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPSTR pszData = (LPSTR) pbData;
                for (i = 0; i < pmdgarData->dwMDDataLen; i++) {
                    if (pszData[i] != '\0') {
                        printf("%c", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
    }
    printf("\n");
}

LPSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = "ERROR_SUCCESS";
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = "ERROR_PATH_NOT_FOUND";
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = "ERROR_INVALID_HANDLE";
        break;
    case ERROR_INVALID_DATA:
        RetCode = "ERROR_INVALID_DATA";
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode = "ERROR_INVALID_PARAMETER";
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode = "ERROR_NOT_SUPPORTED";
        break;
    case ERROR_ACCESS_DENIED:
        RetCode = "ERROR_ACCESS_DENIED";
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode = "ERROR_NOT_ENOUGH_MEMORY";
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode = "ERROR_FILE_NOT_FOUND";
        break;
    case ERROR_DUP_NAME:
        RetCode = "ERROR_DUP_NAME";
        break;
    case ERROR_PATH_BUSY:
        RetCode = "ERROR_PATH_BUSY";
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode = "ERROR_NO_MORE_ITEMS";
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode = "ERROR_INSUFFICIENT_BUFFER";
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode = "ERROR_PROC_NOT_FOUND";
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode = "ERROR_INTERNAL_ERROR";
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode = "MD_ERROR_NOT_INITIALIZED";
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode = "MD_ERROR_DATA_NOT_FOUND";
        break;
    case MD_ERROR_INVALID_VERSION:
        RetCode = "MD_ERROR_INVALID_VERSION";
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode = "ERROR_ALREADY_EXISTS";
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode = "MD_WARNING_PATH_NOT_FOUND";
        break;
    case MD_WARNING_DUP_NAME:
        RetCode = "MD_WARNING_DUP_NAME";
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode = "MD_WARNING_INVALID_DATA";
        break;
    case ERROR_INVALID_NAME:
        RetCode = "ERROR_INVALID_NAME";
        break;
    case REGDB_E_CLASSNOTREG:
        RetCode = "REGDB_E_CLASSNOTREG";
        break;
    case ERROR_NO_SYSTEM_RESOURCES:
        RetCode = "ERROR_NO_SYSTEM_RESOURCES";
        break;
    default:
        RetCode = "Unrecognized Error Code";
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPSTR ConvertHresToString(HRESULT hRes)
{
    LPSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_INTERNET) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        strReturn = "Unrecognized hRes facility";
    }
    return(strReturn);
}

void
ConsumeRegistry(IMSAdminBase * pcCom, METADATA_HANDLE hHandle, LPTSTR pszPath, DWORD dwUnitSize = 10000);

void
ConsumeRegistry(IMSAdminBase * pcCom, METADATA_HANDLE hHandle, LPTSTR pszPath, DWORD dwUnitSize)
{
    METADATA_RECORD mdrData;
    HRESULT hRes = ERROR_SUCCESS;
    DWORD i;

    BYTE *bData = new BYTE[dwUnitSize];

    if (bData != NULL) {

        for (i = 0; i < dwUnitSize; i++) {
            bData[i] = 0;
        }

        for (i = 0; SUCCEEDED(hRes); i++) {
            MD_SET_DATA_RECORD(&mdrData, i, METADATA_NO_ATTRIBUTES, 0, BINARY_METADATA, dwUnitSize, bData)
            hRes = pcCom->SetData(hHandle,
                (PBYTE)pszPath,
                &mdrData);
            printf("MDSetMetaData(hHandle, %s, &mdrData); Returns %s\n",
                pszPath,
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                hRes = pcCom->SaveData();
                printf("\nMDSaveData(); Returns hRes = %X, %s\n",
                    hRes,
                    ConvertHresToString(hRes));

            }
            (bData[i % dwUnitSize])++;
        }
        delete (bData);
    }
}

DWORD
SetMultisz(LPSTR pszBuffer, LPSTR ppszStrings[], DWORD dwNumStrings)
{
    DWORD i;
    LPSTR pszIndex = pszBuffer;

    for (i = 0; i < dwNumStrings; i++) {
        strcpy(pszIndex, ppszStrings[i]);
        pszIndex += strlen(pszIndex) + 1;
    }

    *pszIndex = '\0';

    return ((pszIndex - pszBuffer) + 1);

}

DWORD
GetMultiszDataLen(LPSTR pszData)
{
    DWORD i;

    for (i = 1; (pszData[i-1] != (TCHAR)'\0') || (pszData[i] != (TCHAR)'\0'); i++) {
    }

    return(i + 1);
}

DWORD __cdecl
main( INT    cArgs,
      char * pArgs[] )
{
    DWORD RetCode;
    DWORD TestDword = 3;
    int TestBinary[] = {1,2,3,4};
    int i, ReturnIndex;
    DWORD ReturnDword = 0;
    DWORD ReturnAttributes = 0;
    DWORD ReturnDataType = 0;
    DWORD ReturnUserType = 0;
    METADATA_RECORD mdrData;
    UCHAR ReturnBuf[MAX_BUFFER_LEN];
    DWORD ReturnDataLen = sizeof(ReturnBuf);
    DWORD dwRequiredDataLen = 0;
    DWORD dwRequiredBufferLen = 0;
    TCHAR NameBuf[METADATA_MAX_NAME_LEN];
    METADATA_HANDLE OpenHandle, RootHandle;
    DWORD ReturnDataIdentifier;
    METADATA_RECORD structDataEntries[MAX_DATA_ENTRIES];
    BYTE binDataEntries[MAX_DATA_ENTRIES][MAX_BUFFER_LEN];
    DWORD dwNumDataEntries;
    BYTE pbBuffer[BUFFER_SIZE];
    DWORD dwBufferSize = BUFFER_SIZE;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam;
    OLECHAR rgchName[256];
    DWORD dwSystemChangeNumber;
    DWORD dwDataSetNumber;
    METADATA_HANDLE_INFO mhiInfo;
    FILETIME ftTime;
    LPSTR ppszData[10];
    DWORD dwMultiszLen;

    IClassFactory * pcsfFactory = NULL;
    IClassFactory * pcsfFactory2 = NULL;
    IMSAdminBase * pcCom = NULL;
    HRESULT hRes;
    CImpIADMCOMSINK *pEventSink = new CImpIADMCOMSINK();
    IConnectionPoint* pConnPoint = NULL;
    IConnectionPointContainer* pConnPointContainer = NULL;
    DWORD dwCookie;
    BOOL bSinkConnected = FALSE;

    if (cArgs > 1) {
        for (i = 0; pArgs[1][i] != '\0'; i++) {
            rgchName[i] = (OLECHAR) pArgs[1][i];
        }
        csiName.pwszName =  rgchName;
        csiName.pAuthInfo = NULL;
        pcsiParam = &csiName;
    }
    else {
        pcsiParam = NULL;
    }

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        printf("CoInitializeEx Failed\n");
    }


    hRes = CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void**) &pcCom);
    if (FAILED(hRes)) {
        printf("CoCreateInstance Attaching to service failed, hRes = %X\n", hRes);
        hRes = CoCreateInstance(GETAdminBaseCLSID(FALSE), NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void**) &pcCom);
    }
    if (FAILED(hRes)) {
        printf("CoCreateInstance attaching to exe failed, hRes = %X\n", hRes);
    }
    else {{


/*
    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
    printf("CoGetClassObject(GETMDCLSID(TRUE), ...; Returns hRes = %x, %s\n",
        hRes, ConvertHresToString(hRes));
    if (FAILED(hRes)) {
        hRes = CoGetClassObject(GETAdminBaseCLSID(FALSE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
        printf("CoGetClassObject(GETMDCLSID(FALSE), ...; Returns hRes = %x, %s\n",
            hRes, ConvertHresToString(hRes));
    }

    if (FAILED(hRes)) {
    }
    else {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pcCom);
        printf("Factory->CreateInstance(...); Returns hRes = %X, %s\n",
            hRes, ConvertHresToString(hRes));

        pcsfFactory->Release();
        printf("Factory->Release() called\n");

        if (FAILED(hRes)) {
            printf("Factory->CreateInstance failed, hRes = %X\n", hRes);
        }
        else {
*/
/*
        hRes = pcCom->Initialize();

        hRes = pcCom->AddKey(METADATA_MASTER_ROOT_HANDLE, sizeof("Garbage"), (unsigned char *)"Garbage");

        hRes = pcCom->Terminate(FALSE);

        hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, sizeof(""), (PBYTE)"", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
        printf("MDOpenKey(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
            ConvertHresToString(hRes));

*/

        // First query the object for its Connection Point Container. This
        // essentially asks the object in the server if it is connectable.
        hRes = pcCom->QueryInterface(
               IID_IConnectionPointContainer,
               (PVOID *)&pConnPointContainer);
        if SUCCEEDED(hRes)
        {
          // Find the requested Connection Point. This AddRef's the
          // returned pointer.
          hRes = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
          if (SUCCEEDED(hRes)) {
              hRes = pConnPoint->Advise((IUnknown *)pEventSink, &dwCookie);
              if (SUCCEEDED(hRes)) {
                  bSinkConnected = TRUE;
              }
              printf("pConnPoint->Advise((IUnknown *)pEventSink, &dwCookie); Returns %s\n", ConvertHresToString(hRes));
          }

          RELEASE_INTERFACE(pConnPointContainer);
        }

/*
        hRes = pcCom->Initialize();
        printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

        if (SUCCEEDED(hRes))  {

            hRes = pcCom->Initialize();
            printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

            if (SUCCEEDED(hRes))  {
                hRes = pcCom->Terminate(FALSE);
                printf("\nMDTerminate(FALSE); Returns %s\n",
                    ConvertHresToString(hRes));
            }
*/
        hRes = pcCom->GetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"Root Object", &ftTime, FALSE);
        printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
            ConvertHresToString(hRes));
        if (SUCCEEDED(hRes)) {
            PrintTime(&ftTime);
        }

        hRes = pcCom->GetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime, FALSE);
        printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime); Returns %s\n",
            ConvertHresToString(hRes));
        if (SUCCEEDED(hRes)) {
            PrintTime(&ftTime);
        }

        hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
        printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
            ConvertHresToString(hRes));
        if (!FAILED(hRes)) {
            printf("System Change Number = %d\n", dwSystemChangeNumber);
        }

        hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, INITIAL_TIMEOUT_VALUE, &RootHandle);
        printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
            ConvertHresToString(hRes));

        if (!FAILED(hRes)) {

            hRes = pcCom->DeleteAllData(RootHandle, (PBYTE)"Root Object", ALL_METADATA, ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteAllData(RootHandle, (PBYTE)"junk 1", ALL_METADATA, ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"junk 1\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteChildKeys(RootHandle, (PBYTE)"junk 1");
            printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"junk 1\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteChildKeys(RootHandle, (PBYTE)"Root Object");
            printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"Root Object\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteKey(RootHandle, (PBYTE)"Root Object");
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertHresToString(hRes));

            //
            // Delete everything we created last time.
            //

            hRes = pcCom->DeleteKey(RootHandle, (PBYTE)"junk 1");
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"junk 1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetHandleInfo(RootHandle, &mhiInfo);
            printf("MDGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
            }

            hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
            printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"junk 1/junk 2/junk 3/junk 4");
            printf("MDAddMetaObject(RootHandle, \"junk 1/junk 2/junk 3/junk 4\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->AddKey(RootHandle,
                (PBYTE) "junk 1/This is a very long name for a metaobject and should generate an error"
                " qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf"
                " fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf 012345");
            printf("MDAddMetaObject(RootHandle, \"junk 1/This is a very long name for a metaobject and should generate"
                   " an error qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf"
                   " fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf\"));"
                   " Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertHresToString(hRes));

//            ConsumeRegistry(pcCom, RootHandle, "Root Object");

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Child Object1");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Child Object2");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Child Object2");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Reference Object1");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/Subject Object1");
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Subject Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 4, (PBYTE)NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 0, (PBYTE)NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            ppszData[0] = "Hello ";
            ppszData[1] = "World ";
            ppszData[2] = "Test ";
            dwMultiszLen = SetMultisz((LPSTR)binDataEntries, ppszData, 3);
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen - 1, (PBYTE)binDataEntries)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            ppszData[0] = "Hello ";
            ppszData[1] = "World ";
            ppszData[2] = "Test ";
            dwMultiszLen = SetMultisz((LPSTR)binDataEntries, ppszData, 3);
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen, (PBYTE)binDataEntries)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                DWORD_DATA_NAME, ALL_METADATA);

            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME, ALL_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist", &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }


/*
            hRes = pcCom->SetReferenceObject(RootHandle, (PBYTE)"Root Object/Reference Object1",
                RootHandle, (PBYTE)"Root Object/Reference Object1");
            printf("MDSetReferenceObject(RootHandle, TEXT(\"Root Object/Reference Object1\"),\n\tRootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                ConvertHresToString(hRes));
*/

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object", &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object", &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof("STRING Data for Binary Name"), (PBYTE)"STRING Data for Binary Name")
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));


            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BAD_BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, 0x80000000, (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, FALSE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            if (pcsiParam == NULL) {
                //
                // Reference data doesn't work remotely.
                // But it sort of works on the same machine so test it here.
                //
/*
                printf("\nTESTING REFERENCE DATA\n\n");

                MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, STRING_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    hRes = pcCom->ReleaseReferenceData(mdrData.dwMDDataTag);
                    printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                        ConvertHresToString(hRes));
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->EnumData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                        if (mdrData.dwMDDataTag != 0) {
                            hRes = pcCom->ReleaseReferenceData(mdrData.dwMDDataTag);
                            printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->EnumData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                        if (mdrData.dwMDDataTag != 0) {
                            hRes = pcCom->ReleaseReferenceData(mdrData.dwMDDataTag);
                            printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                hRes = pcCom->GetAllData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                        DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                        if (dwDT != 0) {
                            hRes = pcCom->ReleaseReferenceData(dwDT);
                            printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                hRes = pcCom->GetAllData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                        DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                        if (dwDT != 0) {
                            hRes = pcCom->ReleaseReferenceData(dwDT);
                            printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                hRes = pcCom->DeleteData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    REFERENCE_DATA_NAME, ALL_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), REFERENCE_DATA_NAME, ALL_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                printf("\nEND TESTING REFERENCE DATA\n\n");
*/
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, 0, (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED and set ISINHERITED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED and set ISINHERITED, PARTIAL_PATH only.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Should't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Should't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME_NO_INHERIT,\n\t &ReturnAttributes, &ReturnUserType, &ReturnDataType, &ReturnDataLen, (PVOID) ReturnBuf); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis Enum should set METADATA_ISINHERITED.\n");
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis Enum should set METADATA_ISINHERITED, PARTIAL_PATH only.\n");
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Shouldn't Exist",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Shouldn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"LM/W3SVC/1//Scripts",
                METADATA_INHERIT | METADATA_PARTIAL_PATH, 2, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1//Scripts\"),\n"
                   "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH,2, ALL_METADATA, &dwNumDataEntries,"
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);"
                   " Returns %s\n", ConvertHresToString(hRes));
            printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"LM/W3SVC/1//Scripts/garbage/",
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1//Scripts/garbage/\"),\n"
                   "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            //SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            dwBufferSize = 0;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                   " Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d, dwDataSetNumber = %d\n", dwRequiredBufferLen, dwDataSetNumber);

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            dwBufferSize = 101;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                   " Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = (dwRequiredBufferLen < BUFFER_SIZE)? dwRequiredBufferLen : BUFFER_SIZE;
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = BUFFER_SIZE;
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis GetAll should set METADATA_ISINHERITED.\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_INHERIT | METADATA_ISINHERITED, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT | METADATA_ISINHERITED, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = BUFFER_SIZE;
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis GetAll should set METADATA_ISINHERITED, PARTIAL_PATH only.\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Shouldn't Exist",
                METADATA_INHERIT | METADATA_ISINHERITED | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Shouldn't Exist\"),\n"
                   "\tMETADATA_INHERIT | METADATA_ISINHERITED, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Partial Path Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis Partial Path GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                   "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Partial Path Enum should FAIL with ERROR_PATH_NOT_FOUND\n");
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf);
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis Partial Path GetAll should FAIL with ERROR_PATH_NOT_FOUND\n");
            hRes = pcCom->GetAllData(RootHandle,
                (PBYTE)"Root Object/Doesn't Exist",
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,
                dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,"
                   " dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->CopyData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                RootHandle,
                (PBYTE)"Root Object/Child Object1",
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, TRUE);
            printf("\nMDCopyMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), RootHandle,\n\tTEXT(\"Root Object/Child Object1\"), METADATA_INHERIT | METADATA_PARTIAL_PATH, 0, TRUE); Returns %s\n",
                ConvertHresToString(hRes));


            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"/Root Object", RootHandle, (PBYTE)"junk 1/Root Object", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"/Root Object\", RootHandle, (PBYTE)\"junk 1/Root Object\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/NewCopyTree/NewCopyName", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree/NewCopyName\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/NewCopyTree2/Root Object", TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree2/Root Object\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", FALSE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", FALSE, FALSE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, FALSE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->RenameKey(RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", (PBYTE)"Renamed Object");
            printf("ADMRenameMetaObject(RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", (PBYTE)\"Renamed Object\"); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("ADMGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            ftTime.dwHighDateTime = 1;
            ftTime.dwLowDateTime = 2;

            hRes = pcCom->SetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime, FALSE);
            printf("ADMSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->SetLastChangeTime(RootHandle, NULL, &ftTime, FALSE);
            printf("ADMSetLastChangeTime(RootHandle, NULL, &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            printf("This SetData should set volatle and not get saved");
            MD_SET_DATA_RECORD(&mdrData, VOLATILE_DATA_NAME, METADATA_VOLATILE, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->ChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ);
            printf("ADMChangePermissions(RootHandle, METADATA_PERMISSION_READ); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->OpenKey(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
            printf("ADMOpenMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), METADATA_PERMISSION_READ, &OpenHandle); Returns %s\n\n",
                ConvertHresToString(hRes));

            if (hRes == ERROR_SUCCESS) {

                hRes = pcCom->GetHandleInfo(OpenHandle, &mhiInfo);
                printf("ADMGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
                }

                for (i=0;hRes == ERROR_SUCCESS;i++) {
                    hRes = pcCom->EnumKeys(OpenHandle, (PBYTE)"", (PBYTE)NameBuf, i);
                    printf("MDEnumMetaObjects(OpenHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                        ConvertHresToString(hRes));
                }

                hRes = pcCom->ChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ChangePermissions(OpenHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("MDChangePermissions(OpenHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->CloseKey(OpenHandle);
                printf("MDCloseMetaObject(OpenHandle); Returns %s\n\n",
                    ConvertHresToString(hRes));
            }

            for (i=0;hRes == ERROR_SUCCESS;i++) {
                hRes = pcCom->EnumKeys(RootHandle, (PBYTE)"", (PBYTE)NameBuf, i);
                printf("MDEnumMetaObjects(RootHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("Object Name = %s\n", NameBuf);
                }
            }

            hRes = pcCom->SaveData();
            printf("\nMDSaveData(); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->ChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
            printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 1, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, STRING_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, 0, 0, DWORD_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                BINARY_DATA_NAME, BINARY_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, BINARY_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->SetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime, FALSE);
            printf("MDSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->GetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                BINARY_DATA_NAME, STRING_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, STRING_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object",
                BINARY_DATA_NAME, ALL_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                (PBYTE)"Root Object/Trash",
                BINARY_DATA_NAME, ALL_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Trash\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteAllData(RootHandle,
                                                 (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                                                  ALL_METADATA,
                                                  ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteAllData(RootHandle,
                                                 (PBYTE)"Root Object",
                                                  ALL_METADATA,
                                                  ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteKey(RootHandle, (PBYTE)"Root Object/Child Object1");
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteKey(RootHandle, (PBYTE)"Root Object");
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteChildKeys(RootHandle, (PBYTE)"junk 1");
            printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"junk 1\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CloseKey(RootHandle);
            printf("MDCloseMetaObject(RootHandle); Returns %s\n",
                ConvertHresToString(hRes));



        }
/*
        hRes = pcCom->RemoveCallBack(&MDCallBack);
        printf("\nMDRemoveCallBack(&MDCallBack); Returns %s\n",
            ConvertHresToString(hRes));
*/

        hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"", METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle);
        printf("\n\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"\"), \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
            ConvertHresToString(hRes));

        if (hRes == ERROR_SUCCESS) {

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"//");
            printf("\nMDAddMetaObject(RootHandle, TEXT(\"//\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, (PBYTE)"Root Object/instance1//");
            printf("\nMDAddMetaObject(RootHandle, TEXT(\"Root Object/instance1//\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CloseKey(RootHandle);
            printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"Root Object/instance1/", METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle);
            printf("\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"Root Object/instance1/\"), (PBYTE)\"Root Object/instance1/\", METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                ConvertHresToString(hRes));

            if (hRes == ERROR_SUCCESS) {

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(OpenHandle, (PBYTE)"//", &mdrData);
                printf("MDSetMetaData(OpenHandle, sizeof(\"//\"), (PBYTE)\"//\", &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\", &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\", &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"//",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"/",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"//",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"//",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"//",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    (PBYTE)"//",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                hRes = pcCom->CloseKey(OpenHandle);
                printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));
            }
        }
/*
            hRes = pcCom->Terminate(FALSE);
            printf("\nMDTerminate(FALSE); Returns %s\n",
                ConvertHresToString(hRes));
        }
*/

        if (bSinkConnected) {
            hRes = pConnPoint->Unadvise(dwCookie);
        }

        pcCom->Release();
    }

    }
    CoFreeUnusedLibraries();

    CoUninitialize();

    delete (pEventSink);

    return (0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\globlist.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       globlist.cxx

   Abstract:

       Global object list for DCOMADM.

   Author:

       Michael Thomas (michth)   4-June-1997

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#include <coiadm.hxx>
#include <admacl.hxx>
#include <iiscnfg.h>
#include <secpriv.h>

CRITICAL_SECTION    CADMCOMW::sm_csObjectListLock;
LIST_ENTRY          CADMCOMW::sm_ObjectList = { NULL, NULL };
BOOL                CADMCOMW::sm_fShutdownInProgress = FALSE;

#if DBG
    PTRACE_LOG CADMCOMW::sm_pDbgRefTraceLog = NULL;
#endif

DECLARE_PLATFORM_TYPE();

// static
VOID
CADMCOMW::InitObjectList()
{
    InitializeListHead( &sm_ObjectList );
    INITIALIZE_CRITICAL_SECTION( &sm_csObjectListLock );

    sm_fShutdownInProgress = FALSE;

#if DBG
    sm_pDbgRefTraceLog = CreateRefTraceLog( 4096, 0 );
#endif
}

// static
VOID
CADMCOMW::TerminateObjectList()
{
    DBG_ASSERT( IsListEmpty( &sm_ObjectList ) );

    sm_ObjectList.Flink = NULL;
    sm_ObjectList.Blink = NULL;
    
    DeleteCriticalSection( &sm_csObjectListLock );

#if DBG
    if( sm_pDbgRefTraceLog )
    {
        DestroyRefTraceLog( sm_pDbgRefTraceLog );
        sm_pDbgRefTraceLog = NULL;
    }
#endif
}

VOID
CADMCOMW::AddObjectToList()
{
    DBG_ASSERT( IsListEmpty( &m_ObjectListEntry ) );

    GetObjectListLock();

    AddRef();
    InsertHeadList( &sm_ObjectList, &m_ObjectListEntry );

    ReleaseObjectListLock();
}

BOOL
CADMCOMW::RemoveObjectFromList( BOOL IgnoreShutdown )
{
    BOOL RemovedIt = FALSE;

    if( IgnoreShutdown || !sm_fShutdownInProgress )
    {
        GetObjectListLock();

        if( IgnoreShutdown || !sm_fShutdownInProgress )
        {
            if( !IsListEmpty( &m_ObjectListEntry ) )
            {
                RemovedIt = TRUE;

                RemoveEntryList( &m_ObjectListEntry );
                InitializeListHead( &m_ObjectListEntry );

                Release();
            }
        }

        ReleaseObjectListLock();
    }
    

    return RemovedIt;
}

// static
VOID
CADMCOMW::ShutDownObjects()
{

    CADMCOMW *  pCurrentObject = NULL;
    PLIST_ENTRY pCurrentEntry = NULL;

    //
    // Loop as long as we can get objects from the list
    //

    GetObjectListLock();

    sm_fShutdownInProgress = TRUE;

    ReleaseObjectListLock();
    
    
    while( TRUE ) 
    {

        GetObjectListLock();

        //
        // Remove the first object from the list
        //
        
        if( !IsListEmpty( &sm_ObjectList ) )
        {
            pCurrentEntry = sm_ObjectList.Flink;

            pCurrentObject = CONTAINING_RECORD( pCurrentEntry, 
                                                CADMCOMW, 
                                                m_ObjectListEntry );

            pCurrentObject->AddRef();

            DBG_REQUIRE( pCurrentObject->RemoveObjectFromList( TRUE ) );
        }
        
        ReleaseObjectListLock();

        if( pCurrentObject == NULL )
        {
            //
            // No more objects in the list.
            //

            break;
        }
        
        CoDisconnectObject( pCurrentObject, 0 );

        // 
        // Shutdown the object. ForceTerminate will do a bounded wait 
        // if the object is still being used.
        //

        pCurrentObject->ForceTerminate();
        
        pCurrentObject->Release();
        pCurrentObject = NULL;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\connect.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    connect.h

Abstract:

    defines for event/sink interface for IIS DCOM Admin.

Author:

    Sophia Chung (sophiac)   14-Jan-97

Revision History:

--*/

#if !defined(CONNECT_H)
#define CONNECT_H

#ifdef __cplusplus

// Types that should be in OLE2.H
#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif

// Convenient macros.

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}


// An enumeration giving symbol names for the connection
// points offered by the DllPaper component in this server.

enum
{
  ADM_CONNPOINT_WRITESINK = 0
};

enum
{
  // The maximum number of connection points offered by the DllPaper
  // component in this STOSERVE server.  The number of items in the
  // connection point enumeration above.
  MAX_CONNECTION_POINTS = 1,

  // A constant for the number of connections to add to the allocation
  // of the dynamic connection array.
  ALLOC_CONNECTIONS = 8,

  // The start value for the connection key (cookie) counter.
  COOKIE_START_VALUE = 500
};


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COEnumConnectionPoints

  Summary:     COM object class for enumerating the Connection Points
               offered by a connectable object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IEnumConnectionPoints
                 Interface for connection point enumeration.

  Aggregation: COEnumConnectionPoints COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COEnumConnectionPoints : public IEnumConnectionPoints
{
  public:
    // Main Object Constructor & Destructor.
    COEnumConnectionPoints(IUnknown* pHostObj);
    ~COEnumConnectionPoints(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(
              ULONG cConnPts,
              IConnectionPoint** paConnPts,
              ULONG iEnumIndex);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnectionPoints methods.
    STDMETHODIMP         Next(ULONG, IConnectionPoint**, ULONG*);
    STDMETHODIMP         Skip(ULONG);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumConnectionPoints**);

  private:
    // Private data of COEnumConnectionPoints COM objects.

    // Main Object reference count.
    ULONG              m_cRefs;

    // IUnknown pointer to host COM object being enumerated.
    IUnknown*          m_pHostObj;

    // Connection Point index variable.
    ULONG              m_iEnumIndex;

    // Number of Connection Points being enumerated.
    ULONG              m_cConnPts;

    // Allocated array of Connection Point interface pointers.
    IConnectionPoint** m_paConnPts;
};

typedef COEnumConnectionPoints* PCOEnumConnectionPoints;


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COConnectionPoint

  Summary:     Connection Point COM object class. Implements a native
               IConnectionPoint interface. The Advise, Unadvise, and
               EnumConnections methods use the CThreaded OwnThis mechanism
               to provide thread-safe mutually exclusive access to this
               connection point object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IConnectionPoint
                 Interface for connection point features.

  Aggregation: COConnectionPoint COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COConnectionPoint : public IConnectionPoint
{
  public:
    // Main Object Constructor & Destructor.
    COConnectionPoint(IUnknown* pHostObj);
    ~COConnectionPoint(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(REFIID riid);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IConnectionPoint methods.
    STDMETHODIMP GetConnectionInterface(IID*);
    STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer**);
    STDMETHODIMP Advise(IUnknown*, DWORD*);
    STDMETHODIMP Unadvise(DWORD);
    STDMETHODIMP EnumConnections(IEnumConnections**);


    // Our own methods
    STDMETHODIMP Unadvise_Worker(DWORD dwCookie);

  private:
    // Private utility methods of COConnectionPoint.
    HRESULT GetSlot(UINT* puiFreeSlot);
    HRESULT FindSlot(DWORD dwCookie, UINT* puiSlot);

    // Private data of COConnectionPoint COM objects.

    // Main Object reference count.
    ULONG          m_cRefs;

    // IUnknown pointer to host COM object offering this connection point.
    IUnknown*      m_pHostObj;

    // The IID of the sink interface associated with this connection point.
    IID            m_iidSink;

    // The current number of live sink connections to this connection point.
    UINT           m_cConnections;

    // The current maximum index into the dynamic connection array.
    UINT           m_uiMaxIndex;

    // The dynamic array of sink connections to this connection point.
    CONNECTDATA*   m_paConnections;

    // Determines which host object to use for calling SinkLock/Unlock
    BOOL m_bUnicode;

    IGlobalInterfaceTable* m_pGIT;

};

typedef COConnectionPoint* PCOConnectionPoint;


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COEnumConnections

  Summary:     COM object class for enumerating the connections of a
               connection point of a connectable object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IEnumConnections
                 Interface for connection enumeration features.

  Aggregation: COEnumConnections COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COEnumConnections : public IEnumConnections
{
  public:
    // Main Object Constructor & Destructor.
    COEnumConnections(IUnknown* pHostObj);
    ~COEnumConnections(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(
              ULONG cConnections,
              CONNECTDATA* paConnections,
              ULONG iEnumIndex,
              IGlobalInterfaceTable* pGIT = NULL
              );

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnections methods.
    STDMETHODIMP         Next(ULONG, CONNECTDATA*, ULONG*);
    STDMETHODIMP         Skip(ULONG);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumConnections**);

  private:
    // Private data of COEnumConnections COM objects.

    // Main Object reference count.
    ULONG            m_cRefs;

    // IUnknown pointer to host connection point COM object being
    // enumerated.
    IUnknown*        m_pHostObj;

    // Connection index variable.
    ULONG            m_iEnumIndex;

    // Number of Connections being enumerated.
    ULONG            m_cConnections;

    // Allocated array of live Connections only.
    CONNECTDATA*     m_paConnections;

};

typedef COEnumConnections* PCOEnumConnections;

#endif // __cplusplus

#endif // CONNECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\comobj.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       comobj.cxx

   Abstract:

       This module defines DCOM Admin APIs.

   Author:

       Sophia Chung (sophiac)   23-Nov-1996

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#include <coiadm.hxx>
#include <admacl.hxx>
#include <iiscnfg.h>
#include <secpriv.h>
#include <buffer.hxx>
#include <pwsctrl.h>
#include <inetinfo.h>
#include <metabase.hxx>

#include <stdio.h>
#include <iis64.h>
//
// Globals
//

DECLARE_DEBUG_PRINTS_OBJECT();

ULONG g_dwRefCount = 0;


COpenHandle g_ohMasterRootHandle;

HANDLE_TABLE g_MasterRoot = { NULL,
                              0,
                              METADATA_MASTER_ROOT_HANDLE,
                              ALL_HANDLE,
                              &g_ohMasterRootHandle };


//
// Private prototypes
//

#define MAX_SINK_CALLS_TOBE_REMOVED     10

//
// Used by RestoreHelper
//
#define RESTORE_HISTORY    0x1
#define RESTORE_BACKUP     0x2

BOOL
MakeParentPath(
    LPWSTR  pszPath
    );

BOOL
IsValidNsepmPath( 
    LPCWSTR pszMDPath 
    );

//------------------------------


CADMCOMW::CADMCOMW():
    m_ImpIConnectionPointContainer(),
    m_pMdObject(NULL),
    m_dwRefCount(1),
    m_dwHandleValue(1),
    m_pEventSink(NULL),
    m_pConnPoint(NULL),
    m_bSinkConnected(FALSE),
    m_bCallSinks(TRUE),
    m_piuFTM(NULL),
    m_pNseObject(NULL),
    m_bTerminated(FALSE),
    m_bIsTerminateRoutineComplete(FALSE)

{
    HRESULT hRes;
    UINT i;

    memset((PVOID)m_hashtab, 0, sizeof(m_hashtab) );


    // Null all entries in the connection point array.
    for (i=0; i<MAX_CONNECTION_POINTS; i++) {
        m_aConnectionPoints[i] = NULL;
    }

    InitializeListHead( &m_ObjectListEntry );

    hRes = CoCreateInstance(CLSID_MDCOM, NULL, CLSCTX_INPROC_SERVER, IID_IMDCOM2, (void**) &m_pMdObject);

    if (FAILED(hRes)) {
        DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOMW::CADMCOMW] CoCreateInstance(MDCOM) failed, error %lx\n",
                    hRes ));
    }
    else {
        hRes = m_pMdObject->ComMDInitialize();

        if (FAILED(hRes)) {
            DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOMW::CADMCOMW] ComMDInitialize(MDCOM) failed, error %lx\n",
                        hRes ));

            m_pMdObject->Release();
            m_pMdObject = NULL;
        }
    }

    if (SUCCEEDED(hRes)) {

        if ( IISGetPlatformType() != PtWindows95 ) {

            hRes = CoCreateInstance(CLSID_NSEPMCOM,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_NSECOM,
                                    (void**) &m_pNseObject);

            if (FAILED(hRes)) {
                DBGPRINTF(( DBG_CONTEXT,
                            "[CADMCOM::CADMCOM] CoCreateInstance(NSEPMCOM) failed, error %lx\n",
                            GetLastError() ));
            }
            else {

                hRes = m_pNseObject->ComMDInitialize();

                if (FAILED(hRes)) {
                    DBGPRINTF(( DBG_CONTEXT,
                                "[CADMCOM::CADMCOM] ComMDInitialize(NSEPMCOM) failed, error %lx\n",
                                hRes ));
                    m_pNseObject->Release();
                    m_pNseObject = NULL;
                }
            }
        }

        m_pEventSink = new CImpIMDCOMSINKW((IMSAdminBaseW*)this);
        if( m_pEventSink == NULL ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOMW::CADMCOMW] CImpIMDCOMSINKW failed, error %lx\n",
                        ERROR_NOT_ENOUGH_MEMORY ));
            hRes = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {

            m_pEventSink->AddRef();

            COConnectionPoint* pCOConnPt;

            m_ImpIConnectionPointContainer.Init(this);
            // Rig this COPaper COM object to be connectable. Assign the connection
            // point array. This object's connection points are determined at
            // compile time--it currently has only one connection point:
            // the CONNPOINT_PAPERSINK connection point. Create a connection
            // point object for this and assign it into the array. This array could
            // easily grow to support additional connection points in the future.

            // First try creating a new connection point object. Pass 'this' as the
            // pHostObj pointer used by the connection point to pass its AddRef and
            // Release calls back to the host connectable object.
            pCOConnPt = new COConnectionPoint((IUnknown*)this);
            if (NULL != pCOConnPt)
            {
              // If creation succeeded then initialize it (including creating
              // its initial dynamic connection array).

              hRes = pCOConnPt->Init(IID_IMSAdminBaseSink_W);

              // If the init succeeded then use QueryInterface to obtain the
              // IConnectionPoint interface on the new connection point object.
              // The interface pointer is assigned directly into the
              // connection point array. The QI also does the needed AddRef.
              if (SUCCEEDED(hRes)) {
                    hRes = pCOConnPt->QueryInterface(IID_IConnectionPoint,
                                                   (PPVOID)&m_aConnectionPoints[ADM_CONNPOINT_WRITESINK]);
              }
              if (FAILED(hRes)) {
                  delete (pCOConnPt);
              }
            }
            if (SUCCEEDED(hRes)) {
                //
                // Admin's sink
                //

                IConnectionPointContainer* pConnPointContainer = NULL;

                // First query the object for its Connection Point Container. This
                // essentially asks the object in the server if it is connectable.
                hRes = m_pMdObject->QueryInterface( IID_IConnectionPointContainer,
                       (PVOID *)&pConnPointContainer);

                if SUCCEEDED(hRes)
                {
                    // Find the requested Connection Point. This AddRef's the
                    // returned pointer.
                    hRes = pConnPointContainer->FindConnectionPoint(IID_IMDCOMSINK_W, &m_pConnPoint);
                    if (SUCCEEDED(hRes)) {
                        hRes = m_pConnPoint->Advise((IUnknown *)m_pEventSink, &m_dwCookie);
                        if (SUCCEEDED(hRes)) {
                            m_bSinkConnected = TRUE;
                        }
                    }
                    RELEASE_INTERFACE(pConnPointContainer);

                    if (SUCCEEDED(hRes)) {
                        hRes = CoCreateFreeThreadedMarshaler((IUnknown *)this, &m_piuFTM);
                    }

                }
            }
        }
    }
    SetStatus(hRes);

    //
    // Insert our object into the global list only if it is valid.
    //
    
    if( SUCCEEDED(hRes) )
    {
        AddObjectToList();
    }
}

CADMCOMW::~CADMCOMW()
{
    Terminate();
}

VOID
CADMCOMW::Terminate()
{
    HANDLE_TABLE *node;
    HANDLE_TABLE *nextnode;
    DWORD i;

    //
    // Terminate must only be called from two locations. And they
    // should synchronize correctly. 
    //
    // 1. From ~CADMCOMW. Obviously this should only be called once.
    //
    // 2. From ForceTerminate. That routine should only be called in
    // shutdown. With a reference held on this object. So the final
    // release should call the dtor and this routine should noop.
    //

    if( !m_bTerminated )
    {
        m_bTerminated = TRUE;

        if (m_bSinkConnected) {
            m_pConnPoint->Unadvise(m_dwCookie);
            m_rSinkResource.Lock(TSRES_LOCK_WRITE);
            m_bCallSinks = FALSE;
            m_rSinkResource.Unlock();
        }

        //
        // Tell ADMWPROX.DLL to release this object's associated security
        // context.
        //

        ReleaseObjectSecurityContextW( ( IUnknown* )this );

        //
        // Do final release of the connection point objects.
        // If this isn't the final release, then the client has an outstanding
        // unbalanced reference to a connection point and a memory leak may
        // likely result because the host COPaper object is now going away yet
        // a connection point for this host object will not end up deleting
        // itself (and its connections array).
        //

        for (i=0; i<MAX_CONNECTION_POINTS; i++)
        {
          CoDisconnectObject (m_aConnectionPoints[i],0);
          RELEASE_INTERFACE(m_aConnectionPoints[i]);
        }


        if (SUCCEEDED(GetStatus())) {
            //
            // Close all opened handles
            //

            m_rHandleResource.Lock(TSRES_LOCK_WRITE);

            for( i = 0; i < HASHSIZE; i++ ) {
                for( node = nextnode = m_hashtab[i]; node != NULL; node = nextnode ) {

                    if ( node->hAdminHandle != INVALID_ADMINHANDLE_VALUE ) {

                        AdminAclNotifyClose( (LPVOID)this, node->hAdminHandle );

                        if( node->HandleType == NSEPM_HANDLE ) {

                            //
                            // call nse com api
                            //

                            m_pNseObject->ComMDCloseMetaObject( node->hActualHandle );

                        }
                        else {

                            //
                            // call metadata com api
                            //

                            m_pMdObject->ComMDCloseMetaObject( node->hActualHandle );

                        }

                    }

                    nextnode = node->next;
                    delete node->pohHandle;
                    LocalFree(node);
                }
                m_hashtab[i] = NULL;
            }

            //
            // Issue TaylorW 3/20/2001
            // QFE tree contains this call:
            //
            // AdminAclNotifyClose( (LPVOID)this, METADATA_MASTER_ROOT_HANDLE );
            //
            // I have no idea when this may have entered their tree or been lost
            // from ours. I don't see any record in source depot of it being
            // removed or added. Need to investigate why it would be needed.
            //

            m_rHandleResource.Unlock();
        }

        if ( m_pEventSink != NULL )
        {
            m_pEventSink->Release();
            m_pEventSink = NULL;
        }

        if ( m_pMdObject != NULL )
        {
            m_pMdObject->ComMDTerminate(TRUE);
            m_pMdObject->Release();
            m_pMdObject = NULL;
        }

        if ( m_piuFTM != NULL )
        {
            m_piuFTM->Release();
            m_piuFTM = NULL;
        }

        if ( m_pNseObject != NULL )
        {
            m_pNseObject->ComMDTerminate(TRUE);
            m_pNseObject->Release();
            m_pNseObject = NULL;
        }
        m_bIsTerminateRoutineComplete = TRUE;
    }

    DBG_ASSERT( m_bIsTerminateRoutineComplete );
}

VOID
CADMCOMW::ForceTerminate()
{

    DBG_ASSERT( !m_bIsTerminateRoutineComplete );
    DBG_ASSERT( !m_bTerminated );

    //
    // Wait on the reference count of this object. But bound
    // the wait so a leaked in process object does not prevent 
    // us from shutting down the service.
    //
    // Wait on a ref count of 1, because the caller better be
    // holding our last reference. This assumes all external
    // references are killed through CoDisconnect() and all
    // internal references are released because of dependent
    // services shutting down.
    //
    // Issue TaylorW 3/20/2001
    //
    // In iis 5.1 the web service will shutdown filters after
    // it has already reported that it is done shutting down.
    // This is bad, but changing the shutdown logic of the
    // web service is not worth doing at this time. Hopefully
    // the shutdown timeout will be sufficient to allow this
    // operation to complete.
    //
    // Windows Bugs 318006
    //
    
    const INT MAX_WAIT_TRIES = 5;
    INT WaitTries;

    for( WaitTries = 0; 
         m_dwRefCount > 1 && WaitTries < MAX_WAIT_TRIES; 
         WaitTries++ )
    {
        Sleep( 1000 );
    }

    //
    // If we timed out. Something is wrong. Most likely someone in
    // process has leaked this object. These asserts are actually
    // overactive unless ref tracing is enabled on this object.
    //
    
    //
    // Issue TaylorW 4/9/2001
    //
    // It looks like front page leaks a base object from in process.
    // So these assertions need to be turned off.
    //
    #define DEBUG_BASE_OBJ_LEAK  0x80000000L
    
    IF_DEBUG( BASE_OBJ_LEAK ) {

        DBG_ASSERT( m_dwRefCount == 1 );
        DBG_ASSERT( WaitTries < MAX_WAIT_TRIES );
    }

    //
    // Go ahead and try to clean up.
    //

    Terminate();
}

HRESULT
CADMCOMW::QueryInterface(
    REFIID riid,
    void **ppObject)
{

    if (riid==IID_IUnknown || riid==IID_IMSAdminBase_W) {
        *ppObject = (IMSAdminBase *) this;
        AddRef();
    }
    else if (IID_IMSAdminBase2_W == riid) {
        *ppObject = (IMSAdminBase2 *) this;
        AddRef();
    }
    else if (IID_IConnectionPointContainer == riid) {
        *ppObject = &m_ImpIConnectionPointContainer;
        AddRef();
    }
    else if (IID_IMarshal == riid) {
        return m_piuFTM->QueryInterface(riid, ppObject);
    }
    else {
        return E_NOINTERFACE;
    }

    return S_OK;
}

ULONG
CADMCOMW::AddRef(
    )
{
    DWORD dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

#if DBG
    if( sm_pDbgRefTraceLog )
    {
        WriteRefTraceLog( sm_pDbgRefTraceLog, dwRefCount, this );
    }
#endif

    return dwRefCount;
}

ULONG
CADMCOMW::Release(
    )
{
    DWORD dwRefCount;

    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);

#if DBG
    if( sm_pDbgRefTraceLog )
    {
        WriteRefTraceLog( sm_pDbgRefTraceLog, -(LONG)dwRefCount, this );
    }
#endif

    if( dwRefCount == 1 ) {

        //
        // We keep a list of objects around so that we can clean up and
        // shutdown successfully. The list holds a reference to this object
        // when we hit a reference of 1, we know it is time to remove
        // ourselves from the list. If we are in shutdown we may already
        // have been removed from the list. But normally, this call to
        // RemoveObjectFromList removes our last reference and thus sends 
        // us back through Release and ultimately to our destructor.
        //

        RemoveObjectFromList();
    }
    else if( dwRefCount == 0 ) {
        delete this;
    }

    return dwRefCount;
}

HRESULT
CADMCOMW::AddKey(
    IN METADATA_HANDLE hMDHandle,
    IN LPCWSTR pszMDPath
    )
/*++

Routine Description:

    Add meta object and adds it to the list of child objects for the object
    specified by Path.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be added

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    hresReturn = AddKeyHelper(hMDHandle, pszMDPath);
        
    return hresReturn;
}

HRESULT
CADMCOMW::DeleteKey(
    IN METADATA_HANDLE hMDHandle,
    IN LPCWSTR pszMDPath
    )
/*++

Routine Description:

    Deletes a meta object and all of its data.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of object to be deleted, relative to the path of Handle.
           Must not be NULL.

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (pszMDPath == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          AAC_DELETEKEY,
                                          METADATA_PERMISSION_WRITE);
        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDDeleteMetaObjectW( hActualHandle,
                                                                   pszMDPath );

            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDDeleteMetaObjectW( hActualHandle,
                                                                  pszMDPath );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::DeleteChildKeys(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath
    )
/*++

Routine Description:

    Deletes all child meta objects of the specified object, with all of their
    data.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the parent of the objects to be deleted, relative to
                the path of Handle.

Return Value:

    Status.

--*/
{
    METADATA_HANDLE hActualHandle;
    HANDLE_TYPE HandleType;

    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    //
    // lookup and access check
    //

    hresReturn = LookupAndAccessCheck(hMDHandle,
                                      &hActualHandle,
                                      &HandleType,
                                      pszMDPath,
                                      0,
                                      METADATA_PERMISSION_WRITE);
    if (SUCCEEDED(hresReturn)) {

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            hresReturn = m_pNseObject->ComMDDeleteChildMetaObjectsW( hActualHandle,
                                                               pszMDPath );

        }
        else {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDDeleteChildMetaObjectsW( hActualHandle,
                                                              pszMDPath );
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::EnumKeys(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [size_is][in] */ LPCWSTR pszMDPath,
    /* [size_is][out] */ LPWSTR pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex
    )
/*++

Routine Description:

    Enumerate objects in path.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of parent object, relative to the path of Handle
                eg. "Root Object/Child/GrandChild"
    pszMDName - buffer where the Name of the object is returned

    dwEnumObjectIndex - index of the value to be retrieved

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (pszMDName == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          AAC_ENUM_KEYS,
                                          METADATA_PERMISSION_READ);
        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDEnumMetaObjectsW( hActualHandle,
                                                                  pszMDPath,
                                                                  pszMDName,
                                                                  dwMDEnumObjectIndex );

            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDEnumMetaObjectsW( hActualHandle,
                                                                 pszMDPath,
                                                                 pszMDName,
                                                                 dwMDEnumObjectIndex );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::CopyKey(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag
    )
/*++

Routine Description:

    Copy or move source meta object and its data and descendants to Dest.

Arguments:

    hMDSourceHandle - open handle

    pszMDSourcePath - path of the object to be copied

    hMDDestHandle - handle of the new location for the object

    pszMDDestPath - path of the new location for the object, relative
                          to the path of hMDDestHandle

    bMDOverwriteFlag - determine the behavior if a meta object with the same
                       name as source is already a child of pszMDDestPath.

    bMDCopyFlag - determine whether Source is deleted from its original location

Return Value:

    Status

--*/
{
    METADATA_HANDLE hSActualHandle;
    HANDLE_TYPE SHandleType;
    METADATA_HANDLE hDActualHandle;
    HANDLE_TYPE DHandleType;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    //
    // lookup and access check source
    //

    if (bMDCopyFlag) {
        hresReturn = LookupAndAccessCheck(hMDSourceHandle,
                                          &hSActualHandle,
                                          &SHandleType,
                                          pszMDSourcePath,
                                          0,
                                          METADATA_PERMISSION_READ);
    }
    else {

        //
        // Deleting source path, so need delete permission
        //

        hresReturn = LookupAndAccessCheck(hMDSourceHandle,
                                          &hSActualHandle,
                                          &SHandleType,
                                          pszMDSourcePath,
                                          AAC_DELETEKEY,
                                          METADATA_PERMISSION_WRITE);
    }
    if (SUCCEEDED(hresReturn)) {

        //
        // lookup and access check dest
        //

        hresReturn = LookupAndAccessCheck(hMDDestHandle,
                                          &hDActualHandle,
                                          &DHandleType,
                                          pszMDDestPath,
                                          AAC_COPYKEY,
                                          METADATA_PERMISSION_WRITE);
        if (SUCCEEDED(hresReturn)) {

            if( SHandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDCopyMetaObjectW( hSActualHandle,
                                                                 pszMDSourcePath,
                                                                 hDActualHandle,
                                                                 pszMDDestPath,
                                                                 bMDOverwriteFlag,
                                                                 bMDCopyFlag );
            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDCopyMetaObjectW( hSActualHandle,
                                                                pszMDSourcePath,
                                                                hDActualHandle,
                                                                pszMDDestPath,
                                                                bMDOverwriteFlag,
                                                                bMDCopyFlag );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::RenameKey(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [string][in][unique] */ LPCWSTR pszMDNewName)
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if ((LPSTR)pszMDNewName == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_WRITE);
        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDRenameMetaObjectW(hActualHandle,
                                                                pszMDPath,
                                                                pszMDNewName );
            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDRenameMetaObjectW(hActualHandle,
                                                               pszMDPath,
                                                               pszMDNewName );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::SetData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [size_is][in] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData
    )
/*++

Routine Description:

    Set a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data to set

Return Value:

    Status.

--*/
{
    METADATA_HANDLE hActualHandle;
    HANDLE_TYPE HandleType;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    //
    // lookup and access check
    //

    hresReturn = LookupAndAccessCheck(hMDHandle,
                                      &hActualHandle,
                                      &HandleType,
                                      pszMDPath,
                                      pmdrMDData->dwMDIdentifier,
                                      METADATA_PERMISSION_WRITE );
    if (SUCCEEDED(hresReturn)) {

        if ( !AdminAclNotifySetOrDeleteProp(
                                             hMDHandle,
                                             pmdrMDData->dwMDIdentifier ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOMW::SetData] AdminAclNotifySetOrDel failed, error %lx\n",
                    GetLastError() ));
            hresReturn = RETURNCODETOHRESULT( GetLastError() );
        }
        else {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDSetMetaDataW( hActualHandle,
                                                        pszMDPath,
                                                        pmdrMDData );
            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDSetMetaDataW( hActualHandle,
                                                       pszMDPath,
                                                       pmdrMDData );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Get one metadata value

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{
    BOOL    fEnableSecureAccess;
    BOOL    fRequestedInheritedStatus;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        !CheckGetAttributes(pmdrMDData->dwMDAttributes) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          pmdrMDData->dwMDIdentifier,
                                          METADATA_PERMISSION_READ,
                                          &fEnableSecureAccess );
        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDGetMetaDataW( hActualHandle,
                                                      pszMDPath,
                                                      pmdrMDData,
                                                      pdwMDRequiredDataLen );
            }
            else {

                DWORD RetCode;

                fRequestedInheritedStatus = pmdrMDData->dwMDAttributes & METADATA_ISINHERITED;
                pmdrMDData->dwMDAttributes |= METADATA_ISINHERITED;

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDGetMetaDataW( hActualHandle,
                                                     pszMDPath,
                                                     pmdrMDData,
                                                     pdwMDRequiredDataLen );

                //
                // if metadata is secure, check if can access this property from
                // where it is defined, i.e using the ACL visible at the definition
                // point in tree.
                //

                if ( SUCCEEDED( hresReturn ) &&
                     (pmdrMDData->dwMDAttributes & METADATA_SECURE) &&
                     (RetCode = IsReadAccessGranted( hMDHandle,
                                                     (LPWSTR)pszMDPath,
                                                     pmdrMDData ))
                        != ERROR_SUCCESS )
                {
                    hresReturn = RETURNCODETOHRESULT( RetCode );
                }

                if ( !fRequestedInheritedStatus )
                {
                    pmdrMDData->dwMDAttributes &= ~METADATA_ISINHERITED;
                }
            }

            //
            // if metadata secure, check access allowed to secure properties
            //

            if ( SUCCEEDED( hresReturn ) &&
                 (pmdrMDData->dwMDAttributes & METADATA_SECURE) &&
                 !fEnableSecureAccess) {
                 *pdwMDRequiredDataLen = 0;
                 pmdrMDData->dwMDDataLen = 0;
                 hresReturn = RETURNCODETOHRESULT( ERROR_ACCESS_DENIED );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::DeleteData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType
    )
/*++

Routine Description:

    Deletes a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDIdentifier - identifier of the data to remove

    dwMDDataType - optional type of the data to remove

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          dwMDIdentifier,
                                          METADATA_PERMISSION_WRITE);
        if (SUCCEEDED(hresReturn)) {

            if ( !AdminAclNotifySetOrDeleteProp(
                                                 hMDHandle,
                                                 dwMDIdentifier ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOMW::DeleteData] AdminAclNotifySetOrDel failed, error %lx\n",
                        GetLastError() ));
                hresReturn = RETURNCODETOHRESULT( GetLastError() );
            }

            else {
                if( HandleType == NSEPM_HANDLE ) {

                    //
                    // call nse com api
                    //

                    hresReturn = m_pNseObject->ComMDDeleteMetaDataW( hActualHandle,
                                                               pszMDPath,
                                                               dwMDIdentifier,
                                                               dwMDDataType );
                }
                else {

                    //
                    // call metadata com api
                    //

                    hresReturn = m_pMdObject->ComMDDeleteMetaDataW( hActualHandle,
                                                              pszMDPath,
                                                              dwMDIdentifier,
                                                              dwMDDataType );
                }
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::EnumData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Enumerate properties of object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{
    BOOL  fSecure;
    BOOL  fRequestedInheritedStatus;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        !CheckGetAttributes(pmdrMDData->dwMDAttributes) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_READ,
                                          &fSecure);

        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn  = m_pNseObject->ComMDEnumMetaDataW( hActualHandle,
                                                         pszMDPath,
                                                         pmdrMDData,
                                                         dwMDEnumDataIndex,
                                                         pdwMDRequiredDataLen );
                if ( !fSecure && SUCCEEDED(hresReturn) )
                {
                    hresReturn = RETURNCODETOHRESULT( ERROR_ACCESS_DENIED );

                    memset( pmdrMDData->pbMDData, 0x0, pmdrMDData->dwMDDataLen );
                }
            }
            else {

                fRequestedInheritedStatus = pmdrMDData->dwMDAttributes & METADATA_ISINHERITED;
                pmdrMDData->dwMDAttributes |= METADATA_ISINHERITED;

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDEnumMetaDataW( hActualHandle,
                                                        pszMDPath,
                                                        pmdrMDData,
                                                        dwMDEnumDataIndex,
                                                        pdwMDRequiredDataLen );

                //
                // if metadata is secure, check if can access this property from
                // where it is defined, i.e using the ACL visible at the definition
                // point in tree.
                //

                DWORD RetCode;

                if ( SUCCEEDED( hresReturn ) &&
                     (pmdrMDData->dwMDAttributes & METADATA_SECURE) &&
                     (RetCode = IsReadAccessGranted( hMDHandle,
                                                     (LPWSTR)pszMDPath,
                                                     pmdrMDData ))
                        != ERROR_SUCCESS )
                {
                    hresReturn = RETURNCODETOHRESULT( RetCode );
                    if ( !pmdrMDData->dwMDDataTag )
                    {
                        memset( pmdrMDData->pbMDData, 0x0, pmdrMDData->dwMDDataLen );
                    }
                }

                if ( !fRequestedInheritedStatus )
                {
                    pmdrMDData->dwMDAttributes &= ~METADATA_ISINHERITED;
                }

                if ( !fSecure && SUCCEEDED(hresReturn) )
                {
                    if ( pmdrMDData->dwMDAttributes & METADATA_SECURE )
                    {
                        hresReturn = RETURNCODETOHRESULT( ERROR_ACCESS_DENIED );

                        if ( !pmdrMDData->dwMDDataTag )
                        {
                            memset( pmdrMDData->pbMDData, 0x0, pmdrMDData->dwMDDataLen );
                        }
                    }
                }
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetAllData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
    )
/*++

Routine Description:

    Gets all data associated with a Meta Object

Arguments:

    hMDHandle - open  handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - type of the data

    pdwMDNumDataEntries - number of entries copied to Buffer

    pdwMDDataSetNumber - number associated with this data set

    dwMDBufferSize - size in bytes of buffer

    pbMDBuffer - buffer to store the data

    pdwMDRequiredBufferSize - updated with required length of buffer

Return Value:

    Status.

--*/
{
    BOOL    fSecure;
    BOOL    fRequestedInheritedStatus;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if ((pdwMDNumDataEntries == NULL) || ((dwMDBufferSize != 0) && (pbMDBuffer == NULL)) ||
        !CheckGetAttributes(dwMDAttributes) ||
        (dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          AAC_GETALL,
                                          METADATA_PERMISSION_READ,
                                          &fSecure );

        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDGetAllMetaDataW( hActualHandle,
                                                           pszMDPath,
                                                           dwMDAttributes,
                                                           dwMDUserType,
                                                           dwMDDataType,
                                                           pdwMDNumDataEntries,
                                                           pdwMDDataSetNumber,
                                                           dwMDBufferSize,
                                                           pbMDBuffer,
                                                           pdwMDRequiredBufferSize );
                if ( !fSecure && SUCCEEDED(hresReturn) )
                {
                    hresReturn = RETURNCODETOHRESULT( ERROR_ACCESS_DENIED );
                }
            }
            else {

                fRequestedInheritedStatus = dwMDAttributes & METADATA_ISINHERITED;
                dwMDAttributes |= METADATA_ISINHERITED;

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDGetAllMetaDataW( hActualHandle,
                                                          pszMDPath,
                                                          dwMDAttributes,
                                                          dwMDUserType,
                                                          dwMDDataType,
                                                          pdwMDNumDataEntries,
                                                          pdwMDDataSetNumber,
                                                          dwMDBufferSize,
                                                          pbMDBuffer,
                                                          pdwMDRequiredBufferSize );

                if ( SUCCEEDED(hresReturn) )
                {
                    PMETADATA_GETALL_RECORD pMDRecord;
                    DWORD                   iP;

                    //
                    // Scan for secure properties
                    // For such properties, check if user has access to it using following rules:
                    // - must have right to access secure properties in ACE
                    // - must have access to property using ACL visible where property is defined
                    // if no access to property then remove it from list of returned properties

                    pMDRecord = (PMETADATA_GETALL_RECORD)pbMDBuffer;
                    for ( iP = 0 ; iP < *pdwMDNumDataEntries ; )
                    {
                        if ( pMDRecord->dwMDAttributes & METADATA_SECURE )
                        {
                            if ( !fSecure ||
                                 IsReadAccessGranted( hMDHandle,
                                                      (LPWSTR)pszMDPath,
                                                      (PMETADATA_RECORD)pMDRecord ) != ERROR_SUCCESS )
                            {
                                //
                                // remove this property from METADATA_RECORD list,
                                // zero out content
                                //

                                memset( pbMDBuffer + pMDRecord->dwMDDataOffset,
                                        0x0,
                                        pMDRecord->dwMDDataLen );

                                --*pdwMDNumDataEntries;

                                memmove( pMDRecord,
                                         pMDRecord + 1,
                                         sizeof(METADATA_GETALL_RECORD) * (*pdwMDNumDataEntries-iP) );
                                continue;
                            }
                        }

                        if ( !fRequestedInheritedStatus )
                        {
                            pMDRecord->dwMDAttributes &= ~METADATA_ISINHERITED;
                        }

                        ++iP;
                        ++pMDRecord;
                    }
                }
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::DeleteAllData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType
    )
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (dwMDDataType >= INVALID_END_METADATA) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_WRITE);

        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDDeleteAllMetaDataW( hActualHandle,
                                                              pszMDPath,
                                                              dwMDUserType,
                                                              dwMDDataType );
            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDDeleteAllMetaDataW( hActualHandle,
                                                             pszMDPath,
                                                             dwMDUserType,
                                                             dwMDDataType );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::CopyData(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in] */ LPCWSTR pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag
    )
/*++

Routine Description:

    Copies or moves data associated with the source object to the destination
    object.

Arguments:

    hMDSourceHandle - open handle

    pszMDSourcePath - path of the meta object with which then source data is
                      associated

    hMDDestHandle - handle returned by MDOpenKey with write permission

    pszMDDestPath - path of the meta object for data to be copied to

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - optional type of the data to copy

    bMDCopyFlag - if true, data will be copied; if false, data will be moved.

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (((!bMDCopyFlag) && (dwMDAttributes & METADATA_INHERIT)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT))){
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hSActualHandle;
        HANDLE_TYPE SHandleType;
        METADATA_HANDLE hDActualHandle;
        HANDLE_TYPE DHandleType;

        //
        // lookup and access check source
        //

        if (bMDCopyFlag) {
            hresReturn = LookupAndAccessCheck(hMDSourceHandle,
                                              &hSActualHandle,
                                              &SHandleType,
                                              pszMDSourcePath,
                                              0,
                                              METADATA_PERMISSION_READ);
        }
        else {

            //
            // Deleting source data, so need delete permission
            //

            hresReturn = LookupAndAccessCheck(hMDSourceHandle,
                                              &hSActualHandle,
                                              &SHandleType,
                                              pszMDSourcePath,
                                              0,
                                              METADATA_PERMISSION_WRITE);
        }
        if (SUCCEEDED(hresReturn)) {

            //
            // lookup and access check dest
            //

            hresReturn = LookupAndAccessCheck(hMDDestHandle,
                                              &hDActualHandle,
                                              &DHandleType,
                                              pszMDDestPath,
                                              0,
                                              METADATA_PERMISSION_WRITE);
            if (SUCCEEDED(hresReturn)) {

                if( SHandleType != DHandleType ) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_HANDLE);
                }

                else {

                    if( SHandleType == NSEPM_HANDLE ) {

                        //
                        // call nse com api
                        //

                        hresReturn = m_pNseObject->ComMDCopyMetaDataW(hSActualHandle,
                                                                pszMDSourcePath,
                                                                hDActualHandle,
                                                                pszMDDestPath,
                                                                dwMDAttributes,
                                                                dwMDUserType,
                                                                dwMDDataType,
                                                                bMDCopyFlag );
                    }
                    else {
                        //
                        // call metadata com api
                        //

                        hresReturn = m_pMdObject->ComMDCopyMetaDataW(hSActualHandle,
                                                               pszMDSourcePath,
                                                               hDActualHandle,
                                                               pszMDDestPath,
                                                               dwMDAttributes,
                                                               dwMDUserType,
                                                               dwMDDataType,
                                                               bMDCopyFlag );
                    }
                }
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetDataPaths(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ LPWSTR pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    DWORD RetCode;
    BOOL  fSecure;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (((pszMDBuffer == NULL) && (dwMDBufferSize != 0)) ||
        (dwMDDataType >= INVALID_END_METADATA) ||
        (pdwMDRequiredBufferSize == NULL)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_READ,
                                          &fSecure);

        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDGetMetaDataPathsW(hActualHandle,
                                                            pszMDPath,
                                                            dwMDIdentifier,
                                                            dwMDDataType,
                                                            dwMDBufferSize,
                                                            pszMDBuffer,
                                                            pdwMDRequiredBufferSize );
            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDGetMetaDataPathsW( hActualHandle,
                                                            pszMDPath,
                                                            dwMDIdentifier,
                                                            dwMDDataType,
                                                            dwMDBufferSize,
                                                            pszMDBuffer,
                                                            pdwMDRequiredBufferSize );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::OpenKey(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle
    )
/*++

Routine Description:

    Opens a meta object for read and/or write access.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be opened

    dwMDAccessRequested - permissions requested

    dwMDTimeOut - time to block waiting for open to succeed, in miliseconds.

    phMDNewHandle - handle to be passed to other MD routines

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    hresReturn = OpenKeyHelper(hMDHandle, pszMDPath, dwMDAccessRequested, dwMDTimeOut, phMDNewHandle);

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::CloseKey(
    /* [in] */ METADATA_HANDLE hMDHandle
    )
/*++

Routine Description:

    Closes a handle to a meta object.

Arguments:

    hMDHandle - open handle

Return Value:

    Status.

--*/
{
    DWORD dwTemp;
    COpenHandle *pohHandle;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE)) {
        hresReturn = E_HANDLE;
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Map Admin Handle to Actual Handle
        //

        if( (dwTemp = Lookup( hMDHandle,
                              &hActualHandle,
                              &HandleType,
                              &pohHandle )) != ERROR_SUCCESS ) {
            hresReturn = RETURNCODETOHRESULT(dwTemp);
        }
        else {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDCloseMetaObject( hActualHandle );
            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDCloseMetaObject( hActualHandle );
            }

            pohHandle->Release(this);

            //
            // Remove node from handle table
            //
            if (SUCCEEDED(hresReturn)) {
                pohHandle->Release(this);
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::ChangePermissions(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [in] */ DWORD dwMDTimeOut,
    /* [in] */ DWORD dwMDAccessRequested)
/*++

Routine Description:

    Changes permissions on an open meta object handle.

Arguments:

    hMDHandle - handle to be modified

    dwMDTimeOut - time to block waiting for open to succeed, in miliseconds.

    dwMDAccessRequested - requested permissions

Return Value:

    Status.

--*/
{
    DWORD RetCode = ERROR_SUCCESS;
    METADATA_HANDLE hActualHandle;
    HANDLE_TYPE HandleType;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    //
    // Map Admin Handle to Actual Handle
    //

    if( (RetCode = Lookup( hMDHandle,
                           &hActualHandle,
                           &HandleType )) != ERROR_SUCCESS ) {
        hresReturn = RETURNCODETOHRESULT(RetCode);
    }
    else {
        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            hresReturn = m_pNseObject->ComMDChangePermissions( hActualHandle,
                                                         dwMDTimeOut,
                                                         dwMDAccessRequested );
        }
        else {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDChangePermissions( hActualHandle,
                                                        dwMDTimeOut,
                                                        dwMDAccessRequested );
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::SaveData(
    )
/*++

Routine Description:

    Saves all data changed since the last load or save to permanent storage.

Arguments:

    None.

Return Value:

    Status.

--*/
{
    METADATA_HANDLE mdhRoot = METADATA_MASTER_ROOT_HANDLE;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (m_pNseObject != NULL) {
        //
        // call nse com api
        // Do this while metabase is not open, as NSE may open
        // metabase internally
        //

        m_pNseObject->ComMDSaveData();
    }

    //
    // First try to lock the tree
    //

    hresReturn = m_pMdObject->ComMDOpenMetaObjectW(METADATA_MASTER_ROOT_HANDLE,
                                            NULL,
                                            METADATA_PERMISSION_READ,
                                            DEFAULT_SAVE_TIMEOUT,
                                            &mdhRoot);

    if (SUCCEEDED(hresReturn)) {
        //
        // call metadata com api
        //

        hresReturn = m_pMdObject->ComMDSaveData(mdhRoot);


        m_pMdObject->ComMDCloseMetaObject(mdhRoot);

    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetHandleInfo(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo
    )
/*++

Routine Description:

    Gets the information associated with a handle.

Arguments:

    hMDHandle - handle to get information about

    pmdhiInfo - structure filled in with the information

Return Value:

    Status.

--*/
{
    DWORD RetCode = ERROR_SUCCESS;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (pmdhiInfo == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            hresReturn = RETURNCODETOHRESULT(RetCode);
        }

        else {
            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDGetHandleInfo( hActualHandle,
                                                         pmdhiInfo );
            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDGetHandleInfo( hActualHandle,
                                                        pmdhiInfo );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetSystemChangeNumber(
    /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber
    )
/*++

Routine Description:

    Gets the System Change Number.

Arguments:

    pdwSystemChangeNumber - system change number

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (pdwSystemChangeNumber == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        //
        // call metadata com api
        //

        hresReturn = m_pMdObject->ComMDGetSystemChangeNumber( pdwSystemChangeNumber );
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetDataSetNumber(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ LPCWSTR pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber
    )
/*++

Routine Description:

    Gets all the data set number associated with a Meta Object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pdwMDDataSetNumber - number associated with this data set

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (pdwMDDataSetNumber == NULL){
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_READ);

        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDGetDataSetNumberW( hActualHandle,
                                                             pszMDPath,
                                                             pdwMDDataSetNumber );
            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDGetDataSetNumberW( hActualHandle,
                                                            pszMDPath,
                                                            pdwMDDataSetNumber );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::SetLastChangeTime(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime,
    /* [in] */ BOOL bLocalTime)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the affected meta object

    pftMDLastChangeTime - new change time for the meta object

Return Value:

    Status.

--*/
{
    FILETIME ftTime;
    FILETIME *pftTime = pftMDLastChangeTime;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (pftMDLastChangeTime == NULL){
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_WRITE);

        if (SUCCEEDED(hresReturn)) {

            if (bLocalTime) {
                if (!LocalFileTimeToFileTime(pftMDLastChangeTime, &ftTime)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
                }
                pftTime = &ftTime;
            }

            if (SUCCEEDED(hresReturn)) {

                if( HandleType == NSEPM_HANDLE ) {

                    //
                    // call nse com api
                    //

                    hresReturn = m_pNseObject->ComMDSetLastChangeTimeW( hActualHandle,
                                                                  pszMDPath,
                                                                  pftTime );
                }
                else {

                    //
                    // call metadata com api
                    //

                    hresReturn = m_pMdObject->ComMDSetLastChangeTimeW( hActualHandle,
                                                                 pszMDPath,
                                                                 pftTime );
                }
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetLastChangeTime(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime,
    /* [in] */ BOOL bLocalTime)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - open handle

    pszMDPath - path of the affected meta object

    pftMDLastChangeTime - place to return the change time for the meta object

Return Value:

    Status.

--*/
{
    DWORD RetCode = ERROR_SUCCESS;
    FILETIME ftTime;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (pftMDLastChangeTime == NULL){
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_READ);

        if (SUCCEEDED(hresReturn)) {

            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDGetLastChangeTimeW( hActualHandle,
                                                                    pszMDPath,
                                                                    &ftTime );
            }
            else {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDGetLastChangeTimeW( hActualHandle,
                                                                   pszMDPath,
                                                                   &ftTime );
            }

            if (bLocalTime) {
                if (!FileTimeToLocalFileTime(&ftTime, pftMDLastChangeTime)) {
                    hresReturn = E_UNEXPECTED;
                }
            }
            else {
                *pftMDLastChangeTime = ftTime;
            }
        }
    }

    return hresReturn;
}

HRESULT 
CADMCOMW::BackupHelper(
    LPCWSTR pszMDBackupLocation,
    DWORD dwMDVersion,
    DWORD dwMDFlags,
    LPCWSTR pszPasswd
    )
{

    HRESULT hresWarning = ERROR_SUCCESS;
    METADATA_HANDLE mdhRoot = METADATA_MASTER_ROOT_HANDLE;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    hresReturn = ERROR_SUCCESS;

    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               0,
                               METADATA_PERMISSION_READ,
                               &g_ohMasterRootHandle ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::Backup] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }
    else {

        if ((dwMDFlags & MD_BACKUP_SAVE_FIRST) != 0) {
            //
            // First lock the tree
            //

            hresReturn = m_pMdObject->ComMDOpenMetaObjectW(METADATA_MASTER_ROOT_HANDLE,
                                                         NULL,
                                                         METADATA_PERMISSION_READ,
                                                         DEFAULT_SAVE_TIMEOUT,
                                                         &mdhRoot);
        }

        if (FAILED(hresReturn)) {
            if ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0) {
                hresWarning = MD_WARNING_SAVE_FAILED;
                hresReturn = ERROR_SUCCESS;
                dwMDFlags &= ~(MD_BACKUP_FORCE_BACKUP | MD_BACKUP_SAVE_FIRST);
            }
        }

        if (SUCCEEDED(hresReturn)) {
            //
            // call metadata com api
            //
            if( !pszPasswd )
            {
                hresReturn = m_pMdObject->ComMDBackupW(mdhRoot,
                                                       pszMDBackupLocation,
                                                       dwMDVersion,
                                                       dwMDFlags);
            }
            else
            {
                hresReturn = m_pMdObject->ComMDBackupWithPasswdW(mdhRoot,
                                                                  pszMDBackupLocation,
                                                                  dwMDVersion,
                                                                  dwMDFlags,
                                                                  pszPasswd);
            }

            if ((dwMDFlags & MD_BACKUP_SAVE_FIRST) != 0) {
                m_pMdObject->ComMDCloseMetaObject(mdhRoot);
            }
        }

        if (hresReturn == ERROR_SUCCESS) {
            hresReturn = hresWarning;
        }
    }

    return hresReturn;
}

HRESULT 
CADMCOMW::RestoreHelper(
    LPCWSTR pszMDBackupLocation,
    DWORD dwMDVersion,
    DWORD dwMDMinorVersion,
    LPCWSTR pszPasswd,
    DWORD dwMDFlags,
    DWORD dwRestoreType // RESTORE_HISTORY or RESTORE_BACKUP
    )
{
    DBG_ASSERT(dwRestoreType == RESTORE_HISTORY || dwRestoreType == RESTORE_BACKUP);

    BOOL bIsWin95 = FALSE;
    BOOL bIsW3svcStarted;
    BUFFER bufDependentServices;
    SC_HANDLE schSCM = NULL;
    SC_HANDLE schIISADMIN = NULL;
    DWORD dwBytesNeeded;
    DWORD dwNumServices = 0;
    LPENUM_SERVICE_STATUS pessDependentServices;
    SERVICE_STATUS ssDependent;
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    hresReturn = ERROR_SUCCESS;

    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               0,
                               METADATA_PERMISSION_WRITE,
                               &g_ohMasterRootHandle ) )
    {
        if(dwRestoreType == RESTORE_HISTORY)
        {
            DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::RestoreHistory] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::Restore] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        }
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }
    else {

        if ((dwRestoreType == RESTORE_BACKUP && pszMDBackupLocation == NULL) || 
            (pszMDBackupLocation && wcslen(pszMDBackupLocation) >= MD_BACKUP_MAX_LEN)) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        }
        else {
            WCHAR pszEnumLocation[MD_BACKUP_MAX_LEN] = {0};
            DWORD dwEnumVersion;
            DWORD dwEnumMinorVersion;
            FILETIME ftEnumTime;
            if(pszMDBackupLocation != NULL)
            {
                wcscpy(pszEnumLocation, pszMDBackupLocation);
            }
            for (DWORD i = 0; SUCCEEDED(hresReturn); i++) {
                if(dwRestoreType == RESTORE_HISTORY)
                {
                    hresReturn = m_pMdObject->ComMDEnumHistoryW(pszEnumLocation,
                                                                &dwEnumVersion,
                                                                &dwEnumMinorVersion,
                                                                &ftEnumTime,
                                                                i);
                    if (SUCCEEDED(hresReturn)) {
                        // DBG_ASSERT(_wcsicmp(pszEnumLocation, pszMDBackupLocation) == 0);
                        if(dwMDFlags & MD_HISTORY_LATEST)
                        {
                            break;
                        }
                        else if (dwEnumVersion == dwMDVersion && 
                            dwEnumMinorVersion == dwMDMinorVersion)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    hresReturn = m_pMdObject->ComMDEnumBackupsW(pszEnumLocation,
                                                                &dwEnumVersion,
                                                                &ftEnumTime,
                                                                i);
                    if (SUCCEEDED(hresReturn)) {
                        DBG_ASSERT(_wcsicmp(pszEnumLocation, pszMDBackupLocation) == 0);
                        if ((dwEnumVersion == dwMDVersion) ||
                            (dwMDVersion == MD_BACKUP_HIGHEST_VERSION))
                        {
                            break;
                        }
                    }
                }
            }
            if (FAILED(hresReturn)) {
                if (hresReturn == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS)) {
                    if(dwRestoreType == RESTORE_HISTORY) {
                        if(dwMDFlags & MD_HISTORY_LATEST) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_FILE_NOT_FOUND);
                        }
                        else {
                            hresReturn = RETURNCODETOHRESULT(MD_ERROR_INVALID_VERSION);
                        }
                    }
                    else {
                        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
                    }
                }
            }
            else {
                //
                // Looks like a valid database
                //

                if ( IISGetPlatformType() == PtWindows95 ) {

                    bIsWin95 = TRUE;
                }

                if (bIsWin95) {
                    bIsW3svcStarted = IsInetinfoRunning();

                    if (bIsW3svcStarted) {
                        W95ShutdownW3SVC();
                        WaitForW95W3svcStop();
                    }
                }
                else {

                    schSCM = OpenSCManager(NULL,
                                           NULL,
                                           SC_MANAGER_ALL_ACCESS);
                    if (schSCM == NULL) {
                        hresReturn = RETURNCODETOHRESULT(GetLastError());
                    }
                    else {
                        schIISADMIN = OpenService(schSCM,
                                                  "IISADMIN",
                                                  STANDARD_RIGHTS_REQUIRED | SERVICE_ENUMERATE_DEPENDENTS);
                        if (schIISADMIN == NULL) {
                            hresReturn = RETURNCODETOHRESULT(GetLastError());
                        }
                        else {
                            if (!EnumDependentServices(schIISADMIN,
                                                       SERVICE_ACTIVE,
                                                       (LPENUM_SERVICE_STATUS)(bufDependentServices.QueryPtr()),
                                                       bufDependentServices.QuerySize(),
                                                       &dwBytesNeeded,
                                                       &dwNumServices)) {
                                if (GetLastError() == ERROR_MORE_DATA) {
                                    if (!bufDependentServices.Resize(dwBytesNeeded)) {
                                        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                    }
                                    else {
                                        if (!EnumDependentServices(schIISADMIN,
                                                           SERVICE_ACTIVE,
                                                           (LPENUM_SERVICE_STATUS)(bufDependentServices.QueryPtr()),
                                                           bufDependentServices.QuerySize(),
                                                           &dwBytesNeeded,
                                                           &dwNumServices)) {
                                            hresReturn = RETURNCODETOHRESULT(GetLastError());
                                        }
                                    }
                                }
                                else {
                                    hresReturn = RETURNCODETOHRESULT(GetLastError());
                                }
                            }
                            if (SUCCEEDED(hresReturn)) {
                                pessDependentServices = (LPENUM_SERVICE_STATUS)(bufDependentServices.QueryPtr());

                                if (dwNumServices != 0) {
                                    SC_HANDLE schDependent;
                                    //
                                    // Open handles and send service control stop command
                                    //
                                    for (DWORD i = 0; i < dwNumServices; i++) {
                                        //Stop Services
                                        if (pessDependentServices[i].ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) {
                                            schDependent = OpenService(schSCM,
                                                                       pessDependentServices[i].lpServiceName,
                                                                       SERVICE_ALL_ACCESS);
                                            if (schDependent != NULL)
                                            {
                                                ControlService(schDependent, SERVICE_CONTROL_STOP, &ssDependent);
                                                WaitForServiceStatus(schDependent, SERVICE_STOPPED);
                                                CloseServiceHandle(schDependent);
                                            }
                                        }
                                    }
                                }
                            }
                            CloseServiceHandle(schIISADMIN);
                        }
                    }
                }

                if (SUCCEEDED(hresReturn)) {

                    AdminAclDisableAclCache();

                    AdminAclFlushCache();

                    if(dwRestoreType == RESTORE_HISTORY)
                    {
                        hresReturn = m_pMdObject->ComMDRestoreHistoryW(pszMDBackupLocation,
                                                                       dwMDVersion,
                                                                       dwMDMinorVersion,
                                                                       dwMDFlags);
                    }
                    else
                    {
                        if( !pszPasswd )
                        {
                            hresReturn = m_pMdObject->ComMDRestoreW(pszMDBackupLocation,
                                                                    dwMDVersion,
                                                                    dwMDFlags);
                        }
                        else
                        {
                            hresReturn = m_pMdObject->ComMDRestoreWithPasswdW(pszMDBackupLocation,
                                                                              dwMDVersion,
                                                                              dwMDFlags,
                                                                              pszPasswd);
                        }
                    }

                    AdminAclEnableAclCache();
                }

                if (bIsWin95) {
                    if (bIsW3svcStarted) {
                        W95StartW3SVC();
                        //
                        // No good way to wait for service to start, so just
                        // sleep a little while
                        //
                        Sleep(SLEEP_INTERVAL);
                    }
                }
                else {
                    if (dwNumServices != 0) {
                        SC_HANDLE schDependent;
                        //
                        // Open handles and start services
                        // Use reverse order, since EnumServices orders
                        // list by dependencies
                        //
                        for (long i = (long)dwNumServices - 1; i >= 0; i--) {
                            //Stop Services
                            if (pessDependentServices[i].ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) {
                                schDependent = OpenService(schSCM,
                                                           pessDependentServices[i].lpServiceName,
                                                           SERVICE_ALL_ACCESS);
                                if (schDependent != NULL)
                                {
                                    StartService(schDependent, 0, NULL);
                                    WaitForServiceStatus(schDependent, SERVICE_RUNNING);
                                    CloseServiceHandle(schDependent);
                                }
                            }
                        }
                    }

                    if (schSCM != NULL) {
                        CloseServiceHandle(schSCM);
                    }
                }

                //
                // Issue TaylorW 4/10/2001 
                //
                // After the restore, notify clients, as data has changed 
                // and all handles have become invalid
                //
                // Windows Bug 82423
                //
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::Backup(
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion,
    /* [in] */ DWORD dwMDFlags)
{
    return BackupHelper( pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags
                         );
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::BackupWithPasswd(
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion,
    /* [in] */ DWORD dwMDFlags,
    /* [defaultvalue][string][in][unique] */ LPCWSTR pszPasswd
    )
{
    return BackupHelper( pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         pszPasswd
                         );
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::Restore(
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion,
    /* [in] */ DWORD dwMDFlags)
{
    return RestoreHelper( pszMDBackupLocation, 
                          dwMDVersion, 
                          0,
                          NULL,
                          dwMDFlags,
                          RESTORE_BACKUP
                          );
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::RestoreWithPasswd(
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion,
    /* [in] */ DWORD dwMDFlags,
    /* [defaultvalue][string][in][unique] */ LPCWSTR pszPasswd)
{
    return RestoreHelper( pszMDBackupLocation, 
                          dwMDVersion, 
                          0,
                          pszPasswd,
                          dwMDFlags,
                          RESTORE_BACKUP
                          );
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::EnumBackups(
    /* [size_is][out][in] */ LPWSTR pszMDBackupLocation,
    /* [out] */ DWORD __RPC_FAR *pdwMDVersion,
    /* [out] */ PFILETIME pftMDBackupTime,
    /* [in] */ DWORD dwMDEnumIndex)
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               0,
                               METADATA_PERMISSION_READ,
                               &g_ohMasterRootHandle ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::EnumBackups AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }
    else {

        //
        // call metadata com api
        //

        hresReturn = m_pMdObject->ComMDEnumBackupsW(pszMDBackupLocation,
                                                    pdwMDVersion,
                                                    pftMDBackupTime,
                                                    dwMDEnumIndex);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::DeleteBackup(
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion)
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               0,
                               METADATA_PERMISSION_WRITE,
                               &g_ohMasterRootHandle ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::DeleteBackup] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }

    else {
        //
        // call metadata com api
        //

        hresReturn = m_pMdObject->ComMDDeleteBackupW(pszMDBackupLocation,
                                                     dwMDVersion);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::Export(
    /* [string][in][unique] */ LPCWSTR i_wszPasswd,
    /* [string][in][unique] */ LPCWSTR i_wszFileName,
    /* [string][in][unique] */ LPCWSTR i_wszSourcePath,
    /* [in] */ DWORD i_dwMDFlags)
{
    HRESULT hresReturn  = MD_ERROR_NOT_INITIALIZED;
    HRESULT hresWarning = MD_ERROR_NOT_INITIALIZED;

    METADATA_HANDLE mdh          = 0;
    METADATA_HANDLE mdhActual    = 0;
    COpenHandle*    pohActual    = NULL;
    HANDLE_TYPE     mdHandleType;

    //
    // parameter validation
    //
    if (i_wszFileName == NULL || i_wszSourcePath == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        return hresReturn;
    }

    hresReturn = OpenKeyHelper(METADATA_MASTER_ROOT_HANDLE,
        i_wszSourcePath,
        METADATA_PERMISSION_READ,
        DEFAULT_SAVE_TIMEOUT,
        &mdh);
          
    //
    // pohActual refCount = 2 after Lookup.
    //
    if(SUCCEEDED(hresReturn)) {
        hresReturn = Lookup(mdh, &mdhActual, &mdHandleType, &pohActual);
        hresReturn = RETURNCODETOHRESULT(hresReturn);
    }

    if(SUCCEEDED(hresReturn)) {
        //
        // Move refCount down to 1.
        //
        pohActual->Release(this);
    
        if( !AdminAclAccessCheck( m_pMdObject,
                                    (LPVOID)this,
                                    mdh,
                                    L"",
                                    0,
                                    METADATA_PERMISSION_READ,
                                    pohActual ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOMW::Export] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            hresReturn = RETURNCODETOHRESULT( GetLastError() );
        }
        else
        {
            // call metadata com api
            hresReturn = m_pMdObject->ComMDExportW(mdhActual,
                i_wszPasswd,
                i_wszFileName,
                i_wszSourcePath,
                i_dwMDFlags);
        }

        // close key
        if( mdHandleType == NSEPM_HANDLE ) {
            // call nse com api
            hresWarning = m_pNseObject->ComMDCloseMetaObject( mdhActual );
        }
        else {
            // call metadata com api
            hresWarning = m_pMdObject->ComMDCloseMetaObject( mdhActual );
        }
        pohActual->Release(this);
    }
        

    if(SUCCEEDED(hresReturn)) {
       hresReturn = hresWarning;
    }
   return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CADMCOMW::Import(
    /* [string][in][unique] */ LPCWSTR i_wszPasswd,
    /* [string][in][unique] */ LPCWSTR i_wszFileName,
    /* [string][in][unique] */ LPCWSTR i_wszSourcePath,
    /* [string][in][unique] */ LPCWSTR i_wszDestPath,
    /* [in] */ DWORD i_dwMDFlags)
/*++

Synopsis: 

Arguments: [i_wszPasswd] - 
           [i_wszFileName] - 
           [i_wszSourcePath] - Absolute metabase path
           [i_wszDestPath] -   Absolute metabase path
           [i_dwMDFlags] - 
           
Return Value: 

--*/
{
    HRESULT hresReturn  = MD_ERROR_NOT_INITIALIZED;
    HRESULT hresWarning = MD_ERROR_NOT_INITIALIZED;

    METADATA_HANDLE mdh          = 0;
    METADATA_HANDLE mdhActual    = 0;
    COpenHandle*    pohActual    = NULL;
    HANDLE_TYPE     mdHandleType;

    LPWSTR          wszDeepest  = NULL;
    LONG            cchDeepest  = 0;
    LPWSTR          wszEnd      = NULL;
    LONG            idx         = 0;

    WCHAR wszKeyType[METADATA_MAX_STRING_LEN] = {0};
    DWORD dwRequiredSize = 0;
    METADATA_RECORD mr = {
        MD_KEY_TYPE,
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        STRING_METADATA,
        METADATA_MAX_STRING_LEN*sizeof(WCHAR),
        (LPBYTE)wszKeyType,
        0
    };

    //
    // parameter validation
    //
    if (i_wszFileName == NULL || i_wszSourcePath == NULL || i_wszDestPath == NULL) 
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        return hresReturn;
    }
    
    if (i_wszPasswd == NULL)
    {
        i_wszPasswd = L"";
    }

    //
    // else we can move on, but FreeInUse() must be called before exiting this
    // function.  this is done in exit section.
    //

    //
    // Copy i_wszDestPath to wszDeepest
    // Remove trailing slashes
    //
    cchDeepest = wcslen(i_wszDestPath);
    wszDeepest = new WCHAR[1+cchDeepest];
    if(!wszDeepest)
    {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    memcpy(wszDeepest, i_wszDestPath, sizeof(WCHAR)*(cchDeepest+1));

    while( cchDeepest > 0 && IS_MD_PATH_DELIM(wszDeepest[cchDeepest-1]) )
    {
        cchDeepest--;
    }

    //
    // Open the deepest level key possible
    //
    wszEnd = wszDeepest + cchDeepest;
    for(idx = cchDeepest; idx >= 0; idx--)
    {
        if(idx == 0 || idx == cchDeepest || IS_MD_PATH_DELIM(*wszEnd))
        {
            *wszEnd = L'\0';
            hresReturn = OpenKeyHelper(
                METADATA_MASTER_ROOT_HANDLE,
                wszDeepest,
                METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                DEFAULT_SAVE_TIMEOUT,
                &mdh);
            if( FAILED(hresReturn) &&
                hresReturn != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND) )
            {
                goto exit;
            }
            else if(SUCCEEDED(hresReturn))
            {
                break;
            }
        }
        wszEnd--;
    }
    if(FAILED(hresReturn))
    {
        goto exit;
    }

    //
    // If we are here, we now have an Open metabase handle
    //

    hresReturn = Lookup(mdh, &mdhActual, &mdHandleType, &pohActual);
    hresReturn = RETURNCODETOHRESULT(hresReturn);
    if(FAILED(hresReturn))
    {
        //
        // Yes, an open key does not get closed, but Lookup really should
        // not fail if mdh is a valid key.
        //
        goto exit;
    }
    pohActual->Release(this);           // Decrements refcount from 2 to 1.

    if( !AdminAclAccessCheck( m_pMdObject,
                                (LPVOID)this,
                                mdh,
                                L"",
                                0,
                                METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                pohActual ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::Import] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
        goto exit;
    }

    //
    // Get the keytype
    // If the node does not exist, or node exists but keytype doesn't, we
    // will not set wszKeytype and hence ComMDImport will not attempt to match
    // the source and dest keytype
    //
    hresReturn = m_pMdObject->ComMDGetMetaDataW(
        mdhActual,
        i_wszDestPath+idx,
        &mr,
        &dwRequiredSize);
    if(hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))
    {
        hresReturn = S_OK;
    }
    else if(hresReturn == MD_ERROR_DATA_NOT_FOUND)
    {
        hresReturn = S_OK;
    }
    if(FAILED(hresReturn))
    {
        DBGPRINTF((DBG_CONTEXT, "Error trying to retrieve keytype for %ws\n", i_wszDestPath+idx));
        goto exit;
    }

    //
    // Call Import
    //
    hresReturn = m_pMdObject->ComMDImportW(
        mdhActual,
        i_wszDestPath+idx,
        wszKeyType,
        i_wszPasswd,
        i_wszFileName,
        i_wszSourcePath,
        i_dwMDFlags);
    if(FAILED(hresReturn))
    {
        goto exit;
    }

exit:
    if(pohActual != NULL)
    {
        //
        // Close Key
        //
        if( mdHandleType == NSEPM_HANDLE ) 
        {
            // call nse com api
            hresWarning = m_pNseObject->ComMDCloseMetaObject( mdhActual );
        }
        else 
        {
            // call metadata com api
            hresWarning = m_pMdObject->ComMDCloseMetaObject( mdhActual );
        }
        pohActual->Release(this);    
        pohActual = NULL;
    }

    delete [] wszDeepest;
    return (FAILED(hresReturn)) ? hresReturn : hresWarning;
}

HRESULT STDMETHODCALLTYPE 
CADMCOMW::RestoreHistory(
    /* [unique][in][string] */ LPCWSTR pszMDHistoryLocation,
    /* [in] */ DWORD dwMDMajorVersion,
    /* [in] */ DWORD dwMDMinorVersion,
    /* [in] */ DWORD dwMDFlags)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if( (dwMDFlags & ~MD_HISTORY_LATEST) != 0 &&
        dwMDFlags != 0 )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_FLAGS);
    }

    if( (dwMDFlags & MD_HISTORY_LATEST) &&
        (dwMDMajorVersion != 0 || dwMDMinorVersion != 0) )
    {
        return E_INVALIDARG;
    }

    //
    // parameter validation done in here.
    //
    hresReturn = RestoreHelper(pszMDHistoryLocation,
        dwMDMajorVersion,
        dwMDMinorVersion,
        NULL,
        dwMDFlags,
        RESTORE_HISTORY);

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE 
CADMCOMW::EnumHistory(
    /* [size_is][out][in] */ LPWSTR io_wszMDHistoryLocation,
    /* [out] */ DWORD __RPC_FAR *o_pdwMDMajorVersion,
    /* [out] */ DWORD __RPC_FAR *o_pdwMDMinorVersion,
    /* [out] */ PFILETIME o_pftMDHistoryTime,
    /* [in] */ DWORD i_dwMDEnumIndex)
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if (io_wszMDHistoryLocation == NULL ||
        o_pdwMDMajorVersion == NULL ||
        o_pdwMDMinorVersion == NULL ||
        o_pftMDHistoryTime == NULL) {
        return RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }

    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               0,
                               METADATA_PERMISSION_READ,
                               &g_ohMasterRootHandle ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::EnumHistory AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }
    else {

        //
        // call metadata com api
        //

        hresReturn = m_pMdObject->ComMDEnumHistoryW(io_wszMDHistoryLocation,
                                                    o_pdwMDMajorVersion,
                                                    o_pdwMDMinorVersion,
                                                    o_pftMDHistoryTime,
                                                    i_dwMDEnumIndex);
    }

    return hresReturn;
}

VOID
CADMCOMW::ReleaseNode(
    IN HANDLE_TABLE *phndTable
    )
{
    if ( phndTable )
    {
        m_rHandleResource.Unlock();
    }
}

HRESULT
CADMCOMW::AddKeyHelper(
    IN METADATA_HANDLE hMDHandle,
    IN LPCWSTR pszMDPath
    )
/*++

Routine Description:

    Add meta object and adds it to the list of child objects for the object
    specified by Path.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be added

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if ((pszMDPath == NULL) ||
             (*pszMDPath == (WCHAR)'\0')) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          &HandleType,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_WRITE);
        if (SUCCEEDED(hresReturn)) {
            if( HandleType == NSEPM_HANDLE ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDAddMetaObjectW( hActualHandle,
                                                                pszMDPath );

            }
            else {
                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDAddMetaObjectW( hActualHandle,
                                                               pszMDPath );
            }
        }
    }

    return hresReturn;
}

HRESULT
CADMCOMW::OpenKeyHelper(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle
    )
/*++

Routine Description:

    Opens a meta object for read and/or write access.
    - This is used by Export.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be opened

    dwMDAccessRequested - permissions requested

    dwMDTimeOut - time to block waiting for open to succeed, in miliseconds.

    phMDNewHandle - handle to be passed to other MD routines

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = MD_ERROR_NOT_INITIALIZED;

    if ((phMDNewHandle == NULL) ||
            ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hNewHandle;
        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;
        DWORD RetCode;
        HANDLE_TABLE *phtNode;
        UINT cL;
        COpenHandle *pohParent;

        //
        // Map Admin Handle to Actual Handle
        //

        //
        // This Addrefs pohParent, which makes sure it doesn't do away
        // pohParent is needed by AddNode
        //

        RetCode = Lookup( hMDHandle,
                          &hActualHandle,
                          &HandleType,
                          &pohParent);

        if( RetCode == ERROR_SUCCESS) {
            if(HandleType == NSEPM_HANDLE || (HandleType == ALL_HANDLE &&
                 pszMDPath != NULL && IsValidNsepmPath( pszMDPath )) ) {

                //
                // call nse com api
                //

                hresReturn = m_pNseObject->ComMDOpenMetaObjectW( hActualHandle,
                                                           pszMDPath,
                                                           dwMDAccessRequested,
                                                           dwMDTimeOut,
                                                           &hNewHandle );

                if( SUCCEEDED(hresReturn) ) {
                    hresReturn = AddNode( hNewHandle,
                                    pohParent,
                                    NSEPM_HANDLE,
                                    phMDNewHandle,
                                    pszMDPath );

                    if (FAILED(hresReturn)) {
                        m_pNseObject->ComMDCloseMetaObject( hNewHandle );
                    }
                }
            }
            else {

                DBG_ASSERT( HandleType == META_HANDLE || HandleType == ALL_HANDLE );

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDOpenMetaObjectW( hActualHandle,
                                                         pszMDPath,
                                                         dwMDAccessRequested,
                                                         dwMDTimeOut,
                                                         &hNewHandle );
                if( SUCCEEDED(hresReturn) ) {
                    hresReturn = AddNode( hNewHandle,
                                    pohParent,
                                    META_HANDLE,
                                    phMDNewHandle,
                                    pszMDPath );

                    if (FAILED(hresReturn)) {
                        m_pMdObject->ComMDCloseMetaObject( hNewHandle );
                    }
                }
            }
            pohParent->Release(this);
        }
        else {
            hresReturn = RETURNCODETOHRESULT(RetCode);
        }
    }
    return hresReturn;
}


DWORD
CADMCOMW::Lookup(
    IN METADATA_HANDLE hHandle,
    OUT METADATA_HANDLE *phActualHandle,
    OUT HANDLE_TYPE *HandleType,
    OUT COpenHandle **ppohHandle
    )
{
    HANDLE_TABLE *phtNode;
    DWORD dwReturn = ERROR_INVALID_HANDLE;

    if( hHandle == METADATA_MASTER_ROOT_HANDLE ) {
        *phActualHandle = g_MasterRoot.hActualHandle;
        *HandleType = g_MasterRoot.HandleType;
        if (ppohHandle != NULL) {
            *ppohHandle = g_MasterRoot.pohHandle;
            (*ppohHandle)->AddRef();
        }
        dwReturn = ERROR_SUCCESS;
    }
    else {
        m_rHandleResource.Lock(TSRES_LOCK_READ);

        for( phtNode = m_hashtab[(DWORD)hHandle % HASHSIZE]; phtNode != NULL;
             phtNode = phtNode->next ) {

            if( phtNode->hAdminHandle == hHandle ) {
                *phActualHandle = phtNode->hActualHandle;
                *HandleType = phtNode->HandleType;
                if (ppohHandle != NULL) {
                    *ppohHandle = phtNode->pohHandle;
                    (*ppohHandle)->AddRef();
                }
                dwReturn = ERROR_SUCCESS;
                break;
            }
        }

        m_rHandleResource.Unlock();
    }

    return dwReturn;
}

VOID
CADMCOMW::DisableAllHandles(
    )
{
    HANDLE_TABLE *phtNode;
    DWORD i;

    //
    // At this point, all metadata handles should be closed because a retore
    // just happened. So don't need to close these handles.
    //

    //
    // Can't just delete them, becuase of syncronization problems
    // with CloseKey and Lookup. Set the hande to an invalid value
    // So Lookup won't use them.
    //

    m_rHandleResource.Lock(TSRES_LOCK_WRITE);

    for( i = 0; i < HASHSIZE; i++ ) {
        for( phtNode = m_hashtab[i]; phtNode != NULL; phtNode = phtNode->next ) {
            phtNode->hAdminHandle = INVALID_ADMINHANDLE_VALUE;
        }
    }

    if ( m_pNseObject ) {
        m_pNseObject->ComMDRestoreW( NULL,
                                     0,
                                     0 );
    }

    m_rHandleResource.Unlock();
}

HRESULT
CADMCOMW::LookupAndAccessCheck(
    IN METADATA_HANDLE   hHandle,
    OUT METADATA_HANDLE *phActualHandle,
    OUT HANDLE_TYPE     *pHandleType,
    IN LPCWSTR           pszPath,
    IN DWORD             dwId,           // check for MD_ADMIN_ACL, must have special right to write them
    IN DWORD             dwAccess,       // METADATA_PERMISSION_*
    OUT LPBOOL           pfEnableSecureAccess
    )
{
    DWORD dwReturn = ERROR_SUCCESS;

    COpenHandle *pohParent;

    //
    // Map Admin Handle to Actual Handle
    //

    //
    // This Addrefs pohParent, which makes sure it doesn't go away
    // until AdminAclAccessCheck is done
    //

    dwReturn = Lookup( hHandle,
                       phActualHandle,
                       pHandleType,
                       &pohParent);

    if (dwReturn == ERROR_SUCCESS) {
        if (!AdminAclAccessCheck(m_pMdObject,
                                 (LPVOID)this,
                                 hHandle,
                                 pszPath,
                                 dwId,
                                 dwAccess,
                                 pohParent,
                                 pfEnableSecureAccess)) {
            dwReturn = GetLastError();
        }
        pohParent->Release(this);
    }

    return RETURNCODETOHRESULT(dwReturn);
}

DWORD
CADMCOMW::LookupActualHandle(
    IN METADATA_HANDLE hHandle
    )
{
    HANDLE_TABLE *phtNode;
    DWORD i;
    DWORD dwReturn = ERROR_INVALID_HANDLE;

    m_rHandleResource.Lock(TSRES_LOCK_READ);

    for( i = 0; (i < HASHSIZE) && (dwReturn != ERROR_SUCCESS); i++ ) {
        for( phtNode = m_hashtab[i]; (phtNode != NULL) && (dwReturn != ERROR_SUCCESS); phtNode = phtNode->next ) {
            if( phtNode->hActualHandle == hHandle ) {
                dwReturn = ERROR_SUCCESS;
            }
        }
    }

    m_rHandleResource.Unlock();
    return dwReturn;
}

HRESULT
CADMCOMW::AddNode(
    METADATA_HANDLE hActualHandle,
    COpenHandle *pohParentHandle,
    enum HANDLE_TYPE HandleType,
    PMETADATA_HANDLE phAdminHandle,
    LPCWSTR pszPath
    )
{
    HANDLE_TABLE *phtNode = (HANDLE_TABLE *)LocalAlloc(LMEM_FIXED, sizeof(*phtNode));
    DWORD hashVal;
    HRESULT hresReturn = ERROR_SUCCESS;
    COpenHandle * pohHandle = new COpenHandle;
    METADATA_HANDLE hParentActualHandle;
    HANDLE_TYPE htParentType;

    if ((phtNode == NULL) ||
        (pohHandle == NULL)) {
        hresReturn = E_OUTOFMEMORY;
        if( phtNode ) 
        {
            LocalFree(phtNode);
        }
        if( pohHandle )
        {
            delete pohHandle;
        }
    }
    else {

        m_rHandleResource.Lock(TSRES_LOCK_WRITE);

        hresReturn = pohHandle->Init(m_dwHandleValue,
                                     pszPath,
                                     pohParentHandle->GetPath(),
                                     (HandleType == NSEPM_HANDLE) ? TRUE : FALSE);
        if (FAILED(hresReturn)) {
            LocalFree(phtNode);
            delete pohHandle;
        }
        else {
            phtNode->pohHandle = pohHandle;
            phtNode->hAdminHandle = m_dwHandleValue;
            *phAdminHandle = m_dwHandleValue++;
            phtNode->hActualHandle = hActualHandle;
            phtNode->HandleType = HandleType;
            hashVal = (phtNode->hAdminHandle) % HASHSIZE;
            phtNode->next = m_hashtab[hashVal];
            m_hashtab[hashVal] = phtNode;
        }

        m_rHandleResource.Unlock();
    }

    return hresReturn;
}

DWORD
CADMCOMW::DeleteNode(
    METADATA_HANDLE hHandle
    )
{
    HANDLE_TABLE *phtNode;
    HANDLE_TABLE *phtDelNode;
    DWORD HashValue = (DWORD)hHandle % HASHSIZE;

    if( hHandle == METADATA_MASTER_ROOT_HANDLE ) {
        return ERROR_SUCCESS;
    }

    m_rHandleResource.Lock(TSRES_LOCK_WRITE);

    phtNode = m_hashtab[HashValue];

    //
    // check single node linked list
    //

    if( phtNode->hAdminHandle == hHandle ) {
        m_hashtab[HashValue] = phtNode->next;
        delete phtNode->pohHandle;
        LocalFree(phtNode);
    }
    else {

        for( ; phtNode != NULL; phtNode = phtNode->next ) {

            phtDelNode = phtNode->next;
            if( phtDelNode != NULL ) {

                if( phtDelNode->hAdminHandle == hHandle ) {
                    phtNode->next = phtDelNode->next;
                    delete phtDelNode->pohHandle;
                    LocalFree(phtDelNode);
                    break;
                }
            }
        }
    }

    m_rHandleResource.Unlock();
    return ERROR_SUCCESS;
}
//---------------

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COPaper::NotifySinks

  Summary:  Internal utility method of this COM object used to fire event
            notification calls to all listening connection sinks in the
            client.

  Args:     PAPER_EVENT PaperEvent
              Type of notification event.
            SHORT nX
              X cordinate. Value is 0 unless event needs it.
            SHORT nY
              Y cordinate. Value is 0 unless event needs it.
            SHORT nInkWidth
              Ink Width. Value is 0 unless event needs it.
            SHORT crInkColor
              COLORREF RGB color value. Value is 0 unless event needs it.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT
CADMCOMW::NotifySinks(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [in] */ DWORD dwMDNumElements,
    /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ],
    /* [in] */ BOOL bIsMainNotification)
{

//  DBGPRINTF(( DBG_CONTEXT, "[CADMCOMW::NotifySink]\n" ));

    HRESULT hr = NOERROR;
    IConnectionPoint* pIConnectionPoint;
    IEnumConnections* pIEnum;
    CONNECTDATA ConnData;
    HRESULT hrTemp;
    HANDLE_TABLE *node;


    m_rSinkResource.Lock(TSRES_LOCK_READ);
    if (m_bCallSinks) {
        //
        // if the meta handle is for this object, return ERROR_SUCCESS to
        // the caller (admin's sink);
        //

        if( !bIsMainNotification || (LookupActualHandle( hMDHandle ) != ERROR_SUCCESS) ) {

            //
            // Correct broken connections.
            // It's not likely to be a high number so
            // save a memory allocation by using an array.
            //
            DWORD pdwLostConnections[MAX_SINK_CALLS_TOBE_REMOVED];
            DWORD dwNumLostConnections = 0;

            // If there was a paper event, broadcast appropriate notifications to
            // all Sinks connected to each connection point.
            // if (PAPER_EVENT_NONE != PaperEvent)
            {
                // Here is the section for the PaperSink connection point--currently
                // this is the only connection point offered by COPaper objects.
                pIConnectionPoint = m_aConnectionPoints[ADM_CONNPOINT_WRITESINK];
                if (NULL != pIConnectionPoint)
                {
                    pIConnectionPoint->AddRef();
                    hr = pIConnectionPoint->EnumConnections(&pIEnum);
                    if (SUCCEEDED(hr)) {
                        // Loop thru the connection point's connections and if the
                        // listening connection supports IPaperSink (ie, PaperSink events)
                        // then dispatch the PaperEvent event notification to that sink.

                       while (NOERROR == pIEnum->Next(1, &ConnData, NULL))
                        {
 
                            IMSAdminBaseSinkW       *pIADMCOMSINKW_Synchro = NULL;
                            AsyncIMSAdminBaseSinkW  *pIADMCOMSINKW_Async = NULL;
                            ICallFactory    *pCF = NULL;
                            HRESULT hr ;

                            hr = ConnData.pUnk->QueryInterface(IID_ICallFactory, (void **)&pCF);
                            if (SUCCEEDED(hr))
                            {
                                hr = pCF->CreateCall(IID_AsyncIMSAdminBaseSink_W, NULL, IID_AsyncIMSAdminBaseSink_W,
                                                    (IUnknown **)&pIADMCOMSINKW_Async);
                                if (SUCCEEDED(hr))
                                {
                                    if (bIsMainNotification) {
                                        hr = pIADMCOMSINKW_Async->Begin_SinkNotify(dwMDNumElements,
                                                                                   pcoChangeList);
                                    }
                                    else {
                                        hr = pIADMCOMSINKW_Async->Begin_ShutdownNotify();
                                    }
                                    pIADMCOMSINKW_Async->Release();
                                }
                                else
                                {
                                    DBGPRINTF(( DBG_CONTEXT, "Failled in CreateCall to ICallFactory !!!!\n" ));
                                }
                                pCF->Release();

                            }
                            else
                            {
                                hr = ConnData.pUnk->QueryInterface(IID_IMSAdminBaseSink_W,
                                                                    (PPVOID)&pIADMCOMSINKW_Synchro);
                                if (SUCCEEDED(hr))
                                {
                                    if (bIsMainNotification) {
                                        hr = pIADMCOMSINKW_Synchro->SinkNotify(dwMDNumElements,
                                            pcoChangeList);
                                    }
                                    else {
                                        hr= pIADMCOMSINKW_Synchro->ShutdownNotify();
                                    }
                                    pIADMCOMSINKW_Synchro->Release();
                                    
                                }
                                else
                                {
                                    DBGPRINTF(( DBG_CONTEXT, "Failled in QueryInterface for synchro version of IID_IMSAdminBaseSink_W\n" ));
                                }

                            }
                                
                            if (FAILED(hr)) {
                                if ((HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE) ||
                                    ((HRESULT_CODE(hr) >= RPC_S_NO_CALL_ACTIVE) &&
                                    (HRESULT_CODE(hr) <= RPC_S_CALL_FAILED_DNE))) {
                                    if (dwNumLostConnections < MAX_SINK_CALLS_TOBE_REMOVED) {
                                        pdwLostConnections[dwNumLostConnections++] = ConnData.dwCookie;
                                    }
                                }
                            }



                          ConnData.pUnk->Release();
                        }
                        pIEnum->Release();

                    }
                    while (dwNumLostConnections > 0) {
                        m_rSinkResource.Convert(TSRES_CONV_WRITE);
                        ((COConnectionPoint *)pIConnectionPoint)->Unadvise_Worker(
                            pdwLostConnections[--dwNumLostConnections]);
                    }
                    pIConnectionPoint->Release();
                }
            }
        }
    }

    m_rSinkResource.Unlock();
    return hr;
}
//
// Stubs for routine that clients shouldn't be calling anyway.
//

HRESULT
CADMCOMW::KeyExchangePhase1()
{
    return E_FAIL;
}

HRESULT
CADMCOMW::KeyExchangePhase2()
{
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE
CADMCOMW::GetServerGuid( void)
{
    return E_FAIL;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::UnmarshalInterface(
        /* [out] */ IMSAdminBaseW __RPC_FAR *__RPC_FAR *piadmbwInterface)
{
    AddRef();       // Always return interfaces addref'ed
    *piadmbwInterface = (IMSAdminBaseW *)this;
    return(NOERROR);
}

BOOL
CADMCOMW::CheckGetAttributes(DWORD dwAttributes)
{
    DWORD dwReturn = TRUE;
    if ((dwAttributes & METADATA_REFERENCE) ||
        ((dwAttributes & METADATA_PARTIAL_PATH) &&
            !(dwAttributes & METADATA_INHERIT))) {
        dwReturn = FALSE;
    }
    return dwReturn;
}

VOID
WaitForW95W3svcStop()
{
    DWORD dwSleepTotal = 0;
    while (dwSleepTotal < MAX_SLEEP) {

        if (!IsInetinfoRunning()) {
            break;
        }
        else {
            //
            // Still pending...
            //
            Sleep(SLEEP_INTERVAL);

            dwSleepTotal += SLEEP_INTERVAL;
        }
    }
}


VOID
WaitForServiceStatus(SC_HANDLE schDependent, DWORD dwDesiredServiceState)
{
    DWORD dwSleepTotal = 0;
    SERVICE_STATUS ssDependent;

    while (dwSleepTotal < MAX_SLEEP) {
        if (QueryServiceStatus(schDependent, &ssDependent)) {
            if (ssDependent.dwCurrentState == dwDesiredServiceState) {
                break;
            }
            else {
                //
                // Still pending...
                //
                Sleep(SLEEP_INTERVAL);

                dwSleepTotal += SLEEP_INTERVAL;
            }
        }
        else {
            break;
        }
    }
}



DWORD
CADMCOMW::IsReadAccessGranted(
    METADATA_HANDLE     hHandle,
    LPWSTR              pszPath,
    METADATA_RECORD*    pmdRecord
    )
/*++

Routine Description:

    Check if read access to property granted based on ACL visible at point in metabase
    where property is stored ( as opposed as check made by AdminAclAccessCheck which uses
    the ACL visible at path specified during data access )

Arguments:

    hHandle - DCOM metabase handle
    pszPath - path relative to hHandle
    pmdRecord - metadata info to access property

Returns:

    ERROR_SUCCESS if access granted, otherwise error code

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  pszPropPath;

    //
    // If property is not inherited then we already checked the correct ACL
    //

    if ( !(pmdRecord->dwMDAttributes & METADATA_ISINHERITED) )
    {
        return dwStatus;
    }

    // determine from where we got it
    // do AccessCheck

    if ( (dwStatus = FindClosestProp( hHandle,
                                      pszPath,
                                      &pszPropPath,
                                      pmdRecord->dwMDIdentifier,
                                      pmdRecord->dwMDDataType,
                                      pmdRecord->dwMDUserType,
                                      METADATA_SECURE,
                                      TRUE )) == ERROR_SUCCESS )
    {
        if ( pszPropPath )   // i.e such a property exist
        {
            dwStatus = AdminAclAccessCheck( m_pMdObject,
                                       (LPVOID)this,
                                       METADATA_MASTER_ROOT_HANDLE,
                                       pszPropPath,
                                       pmdRecord->dwMDIdentifier,
                                       METADATA_PERMISSION_READ,
                                       &g_ohMasterRootHandle ) ?
                       ERROR_SUCCESS :
                       GetLastError();
            LocalFree( pszPropPath );
        }
        else
        {
            dwStatus = MD_ERROR_DATA_NOT_FOUND;

            //
            // Should not happen unless handle is master root :
            // if we are here then we succeeded accessing data and as we have a read handle
            // nobody should be able to delete it
            // if master root handle we don't have such protection, so property could
            // have been deleted.
            //

            DBG_ASSERT ( METADATA_MASTER_ROOT_HANDLE == hHandle );
        }
    }

    return dwStatus;
}


DWORD
CADMCOMW::FindClosestProp(
    METADATA_HANDLE hHandle,
    LPWSTR          pszRelPath,
    LPWSTR*         ppszPropPath,
    DWORD           dwPropId,
    DWORD           dwDataType,
    DWORD           dwUserType,
    DWORD           dwAttr,
    BOOL            fSkipCurrentNode
    )
/*++

Routine Description:

    Find the closest path where the specified property exist ( in the direction of
    the root ) in metabase

Arguments:

    hHandle - DCOM metabase handle
    pszRelPath - path relative to hHandle
    ppszPropPath - updated with path to property or NULL if property not found
    dwPropId - property ID
    dwDataType - property data type
    dwUserType - property user type
    dwAttr - property attribute
    fSkipCurrentNode - TRUE to skip current node while scanning for property

Returns:

    TRUE if success ( including property not found ), otherwise FALSE

--*/
{
    DWORD           dwReturn;
    LPWSTR          pszParentPath;
    METADATA_HANDLE hActualHandle;
    HANDLE_TYPE     HandleType;
    COpenHandle *   pohParent;
    HRESULT         hRes;
    METADATA_RECORD mdRecord;
    DWORD           dwRequiredLen;
    LPWSTR          pszPath;
    BOOL            fFound;


    dwReturn = Lookup( hHandle,
                       &hActualHandle,
                       &HandleType,
                       &pohParent);

    if ( dwReturn != ERROR_SUCCESS )
    {
        return dwReturn;
    }

    pszParentPath = pohParent->GetPath();

    if (pszRelPath == NULL) {
        pszRelPath = L"";
    }

    DBG_ASSERT(pszParentPath != NULL);
    DBG_ASSERT((*pszParentPath == (WCHAR)'\0') ||
               ISPATHDELIMW(*pszParentPath));

    //
    // Strip front slash now, add it in later
    //

    if (ISPATHDELIMW(*pszRelPath)) {
        pszRelPath++;
    }

    DWORD dwRelPathLen = wcslen(pszRelPath);
    DWORD dwParentPathLen = wcslen(pszParentPath);

    DBG_ASSERT((dwParentPathLen == 0) ||
               (!ISPATHDELIMW(pszParentPath[dwParentPathLen -1])));

    //
    // Get rid of trailing slash for good
    //

    if ((dwRelPathLen > 0) && (ISPATHDELIMW(pszRelPath[dwRelPathLen -1]))) {
        dwRelPathLen--;
    }

    //
    // Include space for mid slash if Relpath exists
    // Include space for termination
    //

    DWORD dwTotalSize =
        (dwRelPathLen + dwParentPathLen + 1 + ((dwRelPathLen > 0) ? 1 : 0)) * sizeof(WCHAR);

    *ppszPropPath = pszPath = (LPWSTR)LocalAlloc(LMEM_FIXED, dwTotalSize);

    if (pszPath == NULL) {
        dwReturn = GetLastError();
    }
    else {

        //
        // OK to always copy the first part
        //

        memcpy(pszPath,
               pszParentPath,
               dwParentPathLen * sizeof(WCHAR));

        //
        // Don't need slash if there is no RelPath
        //

        if (dwRelPathLen > 0) {

            pszPath[dwParentPathLen] = (WCHAR)'/';

            memcpy(pszPath + dwParentPathLen + 1,
                   pszRelPath,
                   dwRelPathLen * sizeof(WCHAR));

        }

        pszPath[(dwTotalSize / sizeof(WCHAR)) - 1] = (WCHAR)'\0';

        //
        // Now convert \ to / for string compares
        //

        LPWSTR pszPathIndex = pszPath;

        while ((pszPathIndex = wcschr(pszPathIndex, (WCHAR)'\\')) != NULL) {
            *pszPathIndex = (WCHAR)'/';
        }

        // scan for property

        pszPathIndex = pszPath + wcslen(pszPath);

        while ( TRUE )
        {
            if ( !fSkipCurrentNode )
            {
                // check prop exist
                mdRecord.dwMDIdentifier  = dwPropId;
                mdRecord.dwMDAttributes  = dwAttr;
                mdRecord.dwMDUserType    = dwUserType;
                mdRecord.dwMDDataType    = dwDataType;
                mdRecord.dwMDDataLen     = 0;
                mdRecord.pbMDData        = NULL;
                mdRecord.dwMDDataTag     = NULL;

                hRes = m_pMdObject->ComMDGetMetaDataW( METADATA_MASTER_ROOT_HANDLE,
                                                       pszPath,
                                                       &mdRecord,
                                                       &dwRequiredLen );
                if ( hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) )
                {
                    break;
                }
            }

            // scan backward for delimiter

            fFound = FALSE;
            if ( pszPathIndex > pszPath )
            {
                do {
                    if ( *--pszPathIndex == L'/' )
                    {
                        *pszPathIndex = L'\0';
                        fFound = TRUE;
                        break;
                    }
                } while ( pszPathIndex > pszPath );
            }

            if ( !fFound )
            {
                // Property not found, return OK status with NULL string

                *ppszPropPath = NULL;
                LocalFree( pszPath );
                break;
            }

            fSkipCurrentNode = FALSE;
        }
    }

    pohParent->Release( this );

    return dwReturn;
}


BOOL
MakeParentPath(
    LPWSTR  pszPath
    )
/*++

Routine Description:

    Make the path points to parent

Arguments:

    pszPath - path to adjust

Returns:

    TRUE if success, otherwise FALSE ( no parent )

--*/
{
    LPWSTR  pszPathIndex = pszPath + wcslen( pszPath );
    BOOL    fFound = FALSE;

    while ( pszPathIndex > pszPath )
    {
        if ( *--pszPathIndex == L'/' )
        {
            *pszPathIndex = L'\0';
            fFound = TRUE;
            break;
        }
    }

    return fFound;
}


BOOL
IsValidNsepmPath( 
    LPCWSTR pszMDPath 
    )
/*++
Routine Description:

    Determine if pszMDPath is a valid NSEPM path. 

    Really the following are the only valid path forms, but we are going 
    to do a simpler test and just reject paths that have "Root" before the
    <nsepm>.

    /lm/<service>/<nsepm>
    /lm/<service>/<#>/<nsepm>

Arguments:

    psMDPath - the path to validate

Return Value:

    TRUE if path is valid
    
--*/
{
    BOOL    ValidPath = FALSE;
    LPWSTR  pszNsepmTag;
    
    if( pszNsepmTag = wcsstr( pszMDPath, L"<nsepm>" ) )
    {
        DWORD   cchPrefix = DIFF( pszNsepmTag - pszMDPath );
        LPWSTR  pszPrefix = (LPWSTR)LocalAlloc( LPTR, (cchPrefix + 1) * sizeof(WCHAR) );

        if( pszPrefix )
        {
            memcpy( pszPrefix, pszMDPath, cchPrefix * sizeof(WCHAR) );
            pszPrefix[cchPrefix] = 0;
            
            _wcsupr( pszPrefix );
            
            if( wcsstr( pszPrefix, L"ROOT" ) == NULL )
            {
                ValidPath = TRUE;
            }

            LocalFree( pszPrefix );
        }
    }
    return ValidPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\loadadm.cxx ===
// %%Includes: ---------------------------------------------------------------
#define INITGUID
#define INC_OLE2
#define STRICT
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#include <coiadm.hxx>
#include <admacl.hxx>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <wincrypt.h>

#define PATH_TO_KEY "Software\\Microsoft\\Cryptography\\Defaults\\Provider\\Microsoft Base Cryptographic Provider v1.0"

extern ULONG g_dwRefCount;

#ifdef _M_IX86
static  BYTE  SP3Sig[] = {0xbd, 0x9f, 0x13, 0xc5, 0x92, 0x12, 0x2b, 0x72,
                          0x4a, 0xba, 0xb6, 0x2a, 0xf9, 0xfc, 0x54, 0x46,
                          0x6f, 0xa1, 0xb4, 0xbb, 0x43, 0xa8, 0xfe, 0xf8,
                          0xa8, 0x23, 0x7d, 0xd1, 0x85, 0x84, 0x22, 0x6e,
                          0xb4, 0x58, 0x00, 0x3e, 0x0b, 0x19, 0x83, 0x88,
                          0x6a, 0x8d, 0x64, 0x02, 0xdf, 0x5f, 0x65, 0x7e,
                          0x3b, 0x4d, 0xd4, 0x10, 0x44, 0xb9, 0x46, 0x34,
                          0xf3, 0x40, 0xf4, 0xbc, 0x9f, 0x4b, 0x82, 0x1e,
                          0xcc, 0xa7, 0xd0, 0x2d, 0x22, 0xd7, 0xb1, 0xf0,
                          0x2e, 0xcd, 0x0e, 0x21, 0x52, 0xbc, 0x3e, 0x81,
                          0xb1, 0x1a, 0x86, 0x52, 0x4d, 0x3f, 0xfb, 0xa2,
                          0x9d, 0xae, 0xc6, 0x3d, 0xaa, 0x13, 0x4d, 0x18,
                          0x7c, 0xd2, 0x28, 0xce, 0x72, 0xb1, 0x26, 0x3f,
                          0xba, 0xf8, 0xa6, 0x4b, 0x01, 0xb9, 0xa4, 0x5c,
                          0x43, 0x68, 0xd3, 0x46, 0x81, 0x00, 0x7f, 0x6a,
                          0xd7, 0xd1, 0x69, 0x51, 0x47, 0x25, 0x14, 0x40,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#else // other than _M_IX86
static  BYTE  SP3Sig[] = {0x8a, 0x06, 0x01, 0x6d, 0xc2, 0xb5, 0xa2, 0x66,
                          0x12, 0x1b, 0x9c, 0xe4, 0x58, 0xb1, 0xf8, 0x7d,
                          0xad, 0x17, 0xc1, 0xf9, 0x3f, 0x87, 0xe3, 0x9c,
                          0xdd, 0xeb, 0xcc, 0xa8, 0x6b, 0x62, 0xd0, 0x72,
                          0xe7, 0xf2, 0xec, 0xd6, 0xd6, 0x36, 0xab, 0x2d,
                          0x28, 0xea, 0x74, 0x07, 0x0e, 0x6c, 0x6d, 0xe1,
                          0xf8, 0x17, 0x97, 0x13, 0x8d, 0xb1, 0x8b, 0x0b,
                          0x33, 0x97, 0xc5, 0x46, 0x66, 0x96, 0xb4, 0xf7,
                          0x03, 0xc5, 0x03, 0x98, 0xf7, 0x91, 0xae, 0x9d,
                          0x00, 0x1a, 0xc6, 0x86, 0x30, 0x5c, 0xc8, 0xc7,
                          0x05, 0x47, 0xed, 0x2d, 0xc2, 0x0b, 0x61, 0x4b,
                          0xce, 0xe5, 0xb7, 0xd7, 0x27, 0x0c, 0x9e, 0x2f,
                          0xc5, 0x25, 0xe3, 0x81, 0x13, 0x9d, 0xa2, 0x67,
                          0xb2, 0x26, 0xfc, 0x99, 0x9d, 0xce, 0x0e, 0xaf,
                          0x30, 0xf3, 0x30, 0xec, 0xa3, 0x0a, 0xfe, 0x16,
                          0xb6, 0xda, 0x16, 0x90, 0x9a, 0x9a, 0x74, 0x7a,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#endif      // _M_IX86


#if 0
    DWORD   g_dwComRegister;
    DWORD   g_dwAutoRegister;
#endif // 0
    DWORD   g_dwComRegisterW;
    DWORD   g_bInitialized = FALSE;
    IMDCOM *g_pcCom = NULL;
    IMDCOM *g_pcNSEPM = NULL;

#include <initguid.h>
DEFINE_GUID(IisCoAdminGuid, 
0x784d890B, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);


// ---------------------------------------------------------------------------
// %%Function: main
// ---------------------------------------------------------------------------

BOOL
InitComAdmindata(BOOL bRunAsExe)
{

    HRESULT hr;
    BOOL bReturn = TRUE;
    PLATFORM_TYPE ptPlatform;
#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "COADMIN", IisCoAdminGuid );
#else
    CREATE_DEBUG_PRINT_OBJECT( "COADMIN" );
#endif
    CADMCOMW::InitObjectList();

    //
    // if win95, then don't register as service
    //

    INITIALIZE_PLATFORM_TYPE();

    ptPlatform = IISGetPlatformType();

    if ( ptPlatform == PtWindows95 ) {

        DBG_ASSERT(bRunAsExe);
        DBGPRINTF((DBG_CONTEXT,
            "[InitComAdminData] Win95 - not registering as exe\n"));

        bRunAsExe = FALSE;
    }

    //
    // initialize COM for free-threading
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        bReturn = FALSE;
    }
    else {
        hr = CoCreateInstance(CLSID_NSEPMCOM, NULL, CLSCTX_SERVER, IID_NSECOM, (void**) &g_pcNSEPM);
        if( FAILED( hr ) )
        {
            bReturn = FALSE;
        }
        else
        {
            hr = CoCreateInstance(GETMDCLSID(!bRunAsExe), NULL, CLSCTX_SERVER, IID_IMDCOM, (void**) &g_pcCom);
            if (FAILED(hr)) {
                bReturn = FALSE;
            }
            else {

#if 0
                CADMCOMSrvFactory   *pADMClassFactory = new CADMCOMSrvFactory;
#endif
                CADMCOMSrvFactoryW   *pADMClassFactoryW = new CADMCOMSrvFactoryW;
                pADMClassFactoryW->AddRef();

#if 0
                if ((pADMClassFactory == NULL) || (pADMClassFactoryW == NULL)) {
#else
                if (pADMClassFactoryW == NULL) {
#endif // 0
                    DBGPRINTF((DBG_CONTEXT, "[InitComAdmindata] CADMCOMSrvFactoryW failed, error %lx\n",
                              GetLastError() ));
                    bReturn = FALSE;
                }
                else {
#if 0
                    // register the class-object with OLE
                    hr = CoRegisterClassObject(GETAdminBaseCLSID(!bRunAsExe), pADMClassFactory,
                        CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &g_dwComRegister);
                    if (FAILED(hr)) {
                        DBGPRINTF((DBG_CONTEXT, "[InitComAdmindata] CoRegisterClassObject failed, error %lx\n",
                                  GetLastError() ));
                        bReturn = FALSE;
                        delete pADMClassFactory;
                    }
                    else {
#endif // 0
                        // register the class-object with OLE
                        hr = CoRegisterClassObject(GETAdminBaseCLSIDW(!bRunAsExe), pADMClassFactoryW,
                            CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &g_dwComRegisterW);
                        if (FAILED(hr)) {
                            DBGPRINTF((DBG_CONTEXT, "[InitComAdmindata] CoRegisterClassObject failed, error %lx\n",
                                      GetLastError() ));
                            bReturn = FALSE;
                            CoRevokeClassObject(g_dwComRegisterW);
                        }
                        pADMClassFactoryW->Release();
#if 0
                    }
#endif // 0
                }
            }
        }
        if (!bReturn) {
            CoUninitialize();
        }
    }
    if (!bReturn) {
        CADMCOMW::TerminateObjectList();
        if (g_pcNSEPM != NULL) {
            g_pcNSEPM->Release();
        }
        if (g_pcCom != NULL) {
            g_pcCom->Release();
        }
    }
    g_bInitialized = bReturn;
    return bReturn;

}  // main

BOOL
TerminateComAdmindata()
{

    DBGPRINTF((DBG_CONTEXT, "[TerminateComAdmindata]\n" ));

    if (g_bInitialized) {
        g_bInitialized = FALSE;

        // Go ahead and flush the acl cache, since it holds
        // references to the CMDCOM object.  If users come in
        // after this and recreate the acls, they will be created
        // again and we will just wait the 7 seconds below.
        AdminAclFlushCache();

        g_pcCom->ComMDShutdown();
#if 0
        CoRevokeClassObject(g_dwComRegister);
#endif // 0
        if( FAILED( CoRevokeClassObject(g_dwComRegisterW) ) )
        {
            return FALSE;
        }

        CADMCOMW::ShutDownObjects();

        //
        // Wait for remaining accesses to the factory to complete
        // Do this after ShutDownObject to avoid extra waiting
        //

        for (int i = 0;(g_dwRefCount > 0) && (i < 5);i++) {
            DBGPRINTF((DBG_CONTEXT, "[TerminateComAdmindata] Waiting on factory shutdown, i = %d\n",
                      i ));
            Sleep(1000);
        }

        //
        // Just in case another object was allocated came through
        // while we were waiting
        //

        CADMCOMW::ShutDownObjects();


        AdminAclDisableAclCache();
        AdminAclFlushCache();
        if (g_pcNSEPM != NULL) {
            g_pcNSEPM->Release();
        }
        g_pcCom->Release();

        CoUninitialize();
        CADMCOMW::TerminateObjectList();
    }
#ifndef _NO_TRACING_
    DELETE_DEBUG_PRINT_OBJECT();
#endif

    return TRUE;
}

// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\connect.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    IIS DCOM Admin connection point code.

Author:

    Michael W. Thomas            02-Oct-96

Revision History:

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include "coiadm.hxx"

/*+==========================================================================
  File:      CONNECT.CPP

  Summary:   Implementation file for the connection points (and their
             connections) offered by the connectable objects in the
             STOSERVE server sample. COM objects are implemented for
             Connection Point Enumerators, Connection Points, and
             Connection Enumerators.

             For a comprehensive tutorial code tour of this module's
             contents and offerings see the accompanying STOSERVE.TXT
             file. For more specific technical details on the internal
             workings see the comments dispersed throughout the module's
             source code.

  Classes:   COEnumConnectionPoints, COConnectionPoint, and
             COEnumConnections.

  Functions: none.

  Origin:    6-10-96: atrent - Editor inheritance from CONSERVE OLE
             Tutorial Code Sample. Very little change was required.

----------------------------------------------------------------------------
  This file is part of the Microsoft OLE Tutorial Code Samples.

  Copyright (C) Microsoft Corporation, 1996.  All rights reserved.

  This source code is intended only as a supplement to Microsoft
  Development Tools and/or on-line documentation.  See these other
  materials for detailed information regarding Microsoft code samples.

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
==========================================================================+*/


/*---------------------------------------------------------------------------
  We include WINDOWS.H for all Win32 applications.
  We include OLE2.H because we will be making calls to the OLE Libraries.
  We include OLECTL.H because it has definitions for connectable objects.
  We include APPUTIL.H because we will be building this application using
    the convenient Virtual Window and Dialog classes and other
    utility functions in the APPUTIL Library (ie, APPUTIL.LIB).
  We include IPAPER.H and PAPGUIDS.H for the common paper-related
    Interface class, GUID, and CLSID specifications.
  We include SERVER.H because it has internal class declarations and
    resource ID definitions specific for this DLL.
  We include CONNECT.H for object class declarations for the various
    connection point and connection COM objects used in CONSERVE.
  We include PAPER.H because it has the class COEnumConnectionPoints
    declarations as well as the COPaper class declaration.
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
  COEnumConnectionPoints's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  Next, Skip, Reset, and Clone.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::COEnumConnectionPoints

  Summary:  COEnumConnectionPoints Constructor.

  Args:     IUnknown* pHostObj
              Pointer to the host object whose connection points are
              being enumerated.

  Modifies: m_cRefs, m_pHostObj, m_iEnumIndex, m_cConnPts, and m_paConnPts.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnectionPoints::COEnumConnectionPoints(
  IUnknown* pHostObj)
{
  // Zero the COM object's reference count.
  m_cRefs = 0;

  // Assign the Host Object pointer.
  m_pHostObj = pHostObj;

  // Initialize the Connection Point enumerator variables.
  m_iEnumIndex = 0;
  m_cConnPts = 0;
  m_paConnPts = NULL;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::~COEnumConnectionPoints

  Summary:  COEnumConnectionPoints Destructor.

  Args:     void

  Modifies: m_paConnPts.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnectionPoints::~COEnumConnectionPoints(void)
{
  if (NULL != m_paConnPts)
  {
    UINT i;

    // Release all the connection point interface pointers.
    for (i=0; i<m_cConnPts; i++)
      if (NULL != m_paConnPts[i])
        m_paConnPts[i]->Release();

    // Delete the array of interface pointers.
    delete [] m_paConnPts;
  }

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Init

  Summary:  COEnumConnectionPoints Initialization method.  Create any
            necessary arrays, structures, and objects.

  Args:     ULONG cConnPts,
              Number of Connections Points.
            IConnectionPoint** paConnPts,
              Pointer to array of connection point interface pointers.
            ULONG iEnumIndex
              The initial Enumerator index value.

  Modifies: m_cConnPts, m_paConnPts, m_iEnumIndex.

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COEnumConnectionPoints::Init(
          ULONG cConnPts,
          IConnectionPoint** paConnPts,
          ULONG iEnumIndex)
{
  HRESULT hr = NOERROR;
  UINT i;

  // Remember the number of Connection points.
  m_cConnPts = cConnPts;

  // Remember the initial enumerator index.
  m_iEnumIndex = iEnumIndex;

  // Create a copy of the array of connection points and keep it inside
  // this enumerator COM object.
  m_paConnPts = new IConnectionPoint* [(UINT) cConnPts];

  // Fill the array copy with the IConnectionPoint interface pointers from
  // the array passed. AddRef for each new Interface pointer copy made.
  if (NULL != m_paConnPts)
  {
    for (i=0; i<cConnPts; i++)
    {
      m_paConnPts[i] = paConnPts[i];
      m_paConnPts[i]->AddRef();
    }
  }
  else
    hr = E_OUTOFMEMORY;

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::QueryInterface

  Summary:  QueryInterface of the COEnumConnectionPoints non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  HRESULT hr = E_NOINTERFACE;

  *ppv = NULL;

  // The IEnumConnectionPoints interface is implemented directly in
  // this COM object rather than being a nested interface implementation.
  if (IID_IUnknown == riid || IID_IEnumConnectionPoints == riid)
    *ppv = (LPVOID)this;

  if (NULL != *ppv)
  {
    // We've handed out a pointer to the interface so obey the COM rules
    // and AddRef the reference count.
    ((LPUNKNOWN)*ppv)->AddRef();
    hr = NOERROR;
  }

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::AddRef

  Summary:  AddRef of the COEnumConnectionPoints non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnectionPoints::AddRef(void)
{
  ULONG cRefs;

  cRefs = ++m_cRefs;

  // Also AddRef the host object to ensure it stays around as long as
  // this enumerator.
  m_pHostObj->AddRef();

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Release

  Summary:  Release of the COEnumConnectionPoints non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnectionPoints::Release(void)
{
  ULONG cRefs;

  // Pass this release along to the Host object being enumerated.
  m_pHostObj->Release();

  cRefs = --m_cRefs;

  if (0 == cRefs)
  {
    // We artificially bump the main ref count to prevent reentrancy via
    // the main object destructor.
    m_cRefs++;
    delete this;
  }

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Next

  Summary:  The Next member method of this IEnumConnectionPoints interface
            implementation. Called by outside clients of a
            COEnumConnectionPoints object to request that a number of next
            connection point interface pointers be deposited into an array
            supplied by the caller.

  Args:     ULONG cReq
              Number of connection points requested for return (starting at
              the current Enumerator index).
            IConnectionPoint** paConnPts,
              Pointer to a caller's output array that will receive the
              enumerated IConnectionPoint interface pointers.
            ULONG* cEnumerated)
              Pointer to a ULONG variable that will contain the number of
              connection points actually enumerated by this call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Next(
               ULONG cReq,
               IConnectionPoint** paConnPts,
               ULONG* pcEnumerated)
{
  HRESULT hr = NOERROR;
  ULONG cRet = 0;

  // Make sure the argument values passed are valid.
  if (NULL != m_paConnPts)
  {
    if (NULL != paConnPts)
    {
      if (NULL != *paConnPts && m_iEnumIndex < m_cConnPts)
      {
        if (NULL != pcEnumerated)
          *pcEnumerated = 0L;
        else
          if (1L != cReq)
            hr = E_POINTER;
      }
      else
        hr = S_FALSE;
    }
    else
      hr = E_POINTER;
  }
  else
    hr = S_FALSE;

  if (SUCCEEDED(hr))
  {
    // Starting at the current Enumerator index, loop to assign the
    // requested number of output connection point interface pointers.
    for (; m_iEnumIndex < m_cConnPts && cReq > 0;
           paConnPts++, cRet++, cReq--)
    {
      // Assign from the inside Enumerator array to the specified receiving
      // array.
      *paConnPts = m_paConnPts[m_iEnumIndex++];
      // After assigning a copy of an IConnectionPoint pointer, AddRef it.
      if (NULL != *paConnPts)
        (*paConnPts)->AddRef();
    }

    // Assign the output number of connection points enumerated.
    if (NULL != pcEnumerated)
      *pcEnumerated = cRet;
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Skip

  Summary:  The Skip member method of this IEnumConnectionPoints interface
            implementation. Starting at the current Enumerator index, skip
            the specified number of connection point items.

  Args:     ULONG cSkip
              Number of Connection Point items to skip.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Skip(
               ULONG cSkip)
{
  HRESULT hr = NOERROR;

  // If there really is a connection point array and the requested
  // amount of skip does not exceed the number of connection points,
  // then bump the index by the requested skip amount.
  if (NULL != m_paConnPts && (m_iEnumIndex + cSkip) < m_cConnPts)
    m_iEnumIndex += cSkip;
  else
    hr = S_FALSE;

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Reset

  Summary:  The Reset member method of the IEnumConnectionPoints interface
            implementation. Resets the Enumeration index to the first
            connection point item in the array.

  Args:     void.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Reset(
               void)
{
  // Zero the main Enumerator index.
  m_iEnumIndex = 0;

  return NOERROR;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Clone

  Summary:  The Clone member method of this IEnumConnectionPoints
            interface implementation. Creates a new clone of this entire
            Connection Point enumerator COM object.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's output pointer variable that will
              receive the IEnumConnectionPoints interface pointer of the
              new enumerator clone.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Clone(
               IEnumConnectionPoints** ppIEnum)
{
  HRESULT hr;
  COEnumConnectionPoints* pCOEnum;

  // NULL the output variable first.
  *ppIEnum = NULL;

  // Create the Clone Enumerator COM object.
  pCOEnum = new COEnumConnectionPoints(m_pHostObj);
  if (NULL != pCOEnum)
  {
    // Initialize it with same values as in this existing enumerator.
    hr = pCOEnum->Init(m_cConnPts, m_paConnPts, m_iEnumIndex);
    if (SUCCEEDED(hr))
    {
      // QueryInterface to return the requested interface pointer.
      // An AddRef will be conveniently done by the QI.
      hr = pCOEnum->QueryInterface(
                        IID_IEnumConnectionPoints,
                        (PPVOID)ppIEnum);
    }

    if( FAILED( hr ) )
    {
        delete pCOEnum;
        pCOEnum = NULL;
    }
  }
  else
    hr = E_OUTOFMEMORY;

  return hr;
}


/*---------------------------------------------------------------------------
  COConnectionPoint's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  GetConnectionInterface, GetConnectionPointContainer, Advise, Unadvise,
  and EnumConnections.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::COConnectionPoint

  Summary:  COConnectionPoint Constructor.

  Args:     IUnknown* pHostObj
              Pointer to IUnknown of the connectable object offering this
              connection point.

  Modifies: ...

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COConnectionPoint::COConnectionPoint(
  IUnknown* pHostObj)
{
  // Zero the COM object's reference count.
  m_cRefs = 0;

  // Remember an IUnknown pointer to the connectable object that offers
  // this connection point. Since this connection point object's lifetime
  // is geared to that of the connectable object there is no need to
  // AddRef the following copied pointer to the connectable object.
  m_pHostObj = pHostObj;

  // Initialize the Connection Point variables.
  m_uiMaxIndex = 0;
  m_cConnections = 0;
  m_paConnections = NULL;
  m_pGIT = NULL;
  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::~COConnectionPoint

  Summary:  COConnectionPoint Destructor.

  Args:     void

  Modifies: m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COConnectionPoint::~COConnectionPoint(void)
{
  UINT i;
  IUnknown* pUnk;

  if (NULL != m_paConnections)
  {
    // Release all the connection sink interface pointers.
    for (i=0; i<m_uiMaxIndex; i++)
    {
      DBG_ASSERT(m_pGIT != NULL);
      if (m_pGIT != NULL)
      {
          if (m_paConnections[i].dwCookie != 0) {
              m_pGIT->RevokeInterfaceFromGlobal (m_paConnections[i].dwCookie);
          }
      }
    }

    // Delete the array of interface pointers.
    delete [] m_paConnections;
  }


  DBG_ASSERT(m_pGIT != NULL);
  if (m_pGIT)
  {
     m_pGIT->Release();
     m_pGIT = NULL;
  }

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Init

  Summary:  COConnectionPoint Initialization method.  Create any
            necessary arrays, structures, and subordinate objects.

  Args:     REFIID riid
              Reference to the IID of the Sink interface associated with
              this connection point.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::Init(
          REFIID riid)
{
  HRESULT hr = NOERROR;
  CONNECTDATA* paConns;

  // Keep a copy of the reference to the IID of the sink interface
  // associated with this connection point. Needed for later
  // use by the GetConnectionInterface method.
  m_iidSink = riid;

#if 0

  if (m_iidSink == IID_IMSAdminBaseSink_A) {
      m_bUnicode = FALSE;
  }
  else {
#endif // 0

      DBG_ASSERT(m_iidSink == IID_IMSAdminBaseSink_W);
      m_bUnicode = TRUE;

#if 0
  }
#endif

  // Build the initial dynamic array for connections.
  paConns = new CONNECTDATA[ALLOC_CONNECTIONS];
  if (NULL != paConns)
  {
    // Zero the array.
    memset(paConns, 0, ALLOC_CONNECTIONS * sizeof(CONNECTDATA));

    // Rig this connection point object so that it will use the
    // new internal array of connections.
    m_uiMaxIndex = ALLOC_CONNECTIONS;
    m_paConnections = paConns;
  }
  else
    hr = E_OUTOFMEMORY;

  if (m_pGIT == NULL) {
      hr = CoCreateInstance (
      CLSID_StdGlobalInterfaceTable,
      NULL,
      CLSCTX_INPROC_SERVER,
      IID_IGlobalInterfaceTable,
      (void **)&m_pGIT
      );
  }

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::QueryInterface

  Summary:  QueryInterface of the COConnectionPoint non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  HRESULT hr = E_NOINTERFACE;

  *ppv = NULL;

  // The IConnectionPoint interface is implemented directly in this
  // COM object rather than being a nested interface implementation.
  if (IID_IUnknown == riid || IID_IConnectionPoint == riid)
    *ppv = (LPVOID)this;

  if (NULL != *ppv)
  {
    // We've handed out a pointer to the interface so obey the COM rules
    // and AddRef the reference count.
    ((LPUNKNOWN)*ppv)->AddRef();
    hr = NOERROR;
  }

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::AddRef

  Summary:  AddRef of the COConnectionPoint non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COConnectionPoint::AddRef(void)
{
  ULONG cRefs;
  cRefs = InterlockedIncrement((long *)&m_cRefs);
  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Release

  Summary:  Release of the COConnectionPoint non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COConnectionPoint::Release(void)
{
  ULONG cRefs;

    cRefs = InterlockedDecrement((long *)&m_cRefs);

    if (0 == cRefs)
    {
      // We artificially bump the main ref count to prevent reentrancy via
      // the main object destructor. We relinquish thread ownership of this
      // object prior to deleting it--a good practice.
      InterlockedIncrement((long *)&m_cRefs);
      delete this;
    }

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetSlot

  Summary:  An internal private utility member method to obtain a free
            slot in the dynamic connections array. GetSlot will expand the
            dynamic array for more entries if needed. To guarantee thread
            safety, this private method should always be called within the
            protection of a bracketed OwnThis, UnOwnThis pair.

  Args:     UINT* puiFreeSlot
              Address of an output variable to receive the free slot index.

  Modifies: m_uiMaxIndex, m_paConnections.

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::GetSlot(
          UINT* puiFreeSlot)
{
  HRESULT hr = NOERROR;
  BOOL bOpen = FALSE;
  UINT i;
  CONNECTDATA* paConns;

  // Zero the output variable.
  *puiFreeSlot = 0;

  // Loop to find an empty slot.
  for (i=0; i<m_uiMaxIndex; i++)
  {
    if (m_paConnections[i].dwCookie == 0)
    {
      // We found an open empty slot.
      *puiFreeSlot = i;
      bOpen = TRUE;
      break;
    }
  }

  if (!bOpen)
  {
    // We didn't find an existing open slot in the array--it's full.
    // Expand the array by ALLOC_CONNECTIONS entries and assign the
    // appropriate output index.
    paConns = new CONNECTDATA[m_uiMaxIndex + ALLOC_CONNECTIONS];
    if (NULL != paConns)
    {
      // Copy the content of the old full array to the new larger array.
      for (i=0; i<m_uiMaxIndex; i++)
      {
        paConns[i].pUnk = m_paConnections[i].pUnk;
        paConns[i].dwCookie = m_paConnections[i].dwCookie;
      }

      // Zero (ie mark as empty) the expanded portion of the new array.
      for (i=m_uiMaxIndex; i<m_uiMaxIndex+ALLOC_CONNECTIONS; i++)
      {
        paConns[i].pUnk = NULL;
        paConns[i].dwCookie = 0;
      }

      // New larger array is ready--delete the old array.
      delete [] m_paConnections;

      // Rig the connection point to use the new larger array.
      m_paConnections = paConns;

      // Assign the output free slot as first entry in new expanded area.
      *puiFreeSlot = m_uiMaxIndex;

      // Calculate the new max index.
      m_uiMaxIndex += ALLOC_CONNECTIONS;
    }
    else
      hr = E_OUTOFMEMORY;
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::FindSlot

  Summary:  An internal private utility member method to find an existing
            slot (identified by the specified dwCookie value) in the
            dynamic connections array.

  Args:     DWORD dwCookie,
              The connection key (cookie) to find.
            UINT* puiSlot)
              Address of an output variable to receive the slot index.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::FindSlot(
          DWORD dwCookie,
          UINT* puiSlot)
{
  HRESULT hr = CONNECT_E_NOCONNECTION;
  UINT i;

  // Loop to find the Cookie.
  for (i=0; i<m_uiMaxIndex; i++)
  {
    if (dwCookie == m_paConnections[i].dwCookie)
    {
      // If a cookie match is found, assign the output slot index.
      *puiSlot = i;
      hr = NOERROR;
      break;
    }
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetConnectionInterface

  Summary:  The GetConnectionInterface member method of this
            IConnectionPoint interface implementation. Called to get the
            IID of the Sink interface associated with this connection
            point.

  Args:     IID* piidSink
              Pointer to the IID of the associated sink interface.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::GetConnectionInterface(
               IID* piidSink)
{
  HRESULT hr = NOERROR;

  if (NULL != piidSink)
    *piidSink = m_iidSink;
  else
    hr = E_POINTER;

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetConnectionPointContainer

  Summary:  The GetConnectionPointContainer member method of this
            IConnectionPoint interface implementation. Called to get the
            connection point container that contains this connection
            point.

  Args:     IConnectionPointContainer** ppConnPtCon
              Address of the pointer variable that will recieve the
              IConnectionPointContainer interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::GetConnectionPointContainer(
               IConnectionPointContainer** ppConnPtCon)
{
  HRESULT hr;

  // Use QueryInterface to get the interface pointer and to perform the
  // needed AddRef on the returned pointer.
  hr = m_pHostObj->QueryInterface(
                     IID_IConnectionPointContainer,
                     (PPVOID) ppConnPtCon);

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Advise

  Summary:  The Advise member method of this IConnectionPoint interface
            implementation. Called by clients to establish a connection of
            their sink to this connection point. Uses the CThreaded
            OwnThis mechanism to provide mutually exclusive access by
            multiple threads.

  Args:     IUnknown* pUnkSink
              IUnknown interface pointer of the Sink object in the client.
            DWORD* pdwCookie
              Pointer to a DWORD in the client that will receive a unique
              key used by the client to refer to the connection established
              by this Advise call.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::Advise(
               IUnknown* pUnkSink,
               DWORD* pdwCookie)
{
  HRESULT hr = NOERROR;
  UINT uiFreeSlot = 0;
  IUnknown* pISink = NULL;
  IUnknown *piunkPrivateSink;
  IUnknown *piunkPrivateSinkCopy;
  IUnknown *piunkSinkCopyIunknown;
  DWORD dwCookie = 0;
  HANDLE hThrToken = NULL;
  BOOL   fOpened=FALSE;

  if (m_bUnicode) {
      ((CADMCOMW *)m_pHostObj)->SinkLock(TSRES_LOCK_WRITE);
  }
  else {
#if 0
      ((CADMCOM *)m_pHostObj)->SinkLock(TSRES_LOCK_WRITE);
#else
      DBG_ASSERT(FALSE);
#endif // 0

  }
    // Zero the output connection key.
    *pdwCookie = 0;

    hr = CoImpersonateClient();
    if (SUCCEEDED(hr)) {

        hr = CoSetProxyBlanket(pUnkSink,
						       RPC_C_AUTHN_WINNT,      // use NT default security
						       RPC_C_AUTHZ_NONE,       // use NT default authentication
						       NULL,                   // must be null if default
						       RPC_C_AUTHN_LEVEL_CALL, // call
                               RPC_C_IMP_LEVEL_IMPERSONATE,
						       NULL,                   // use process token
						       EOAC_STATIC_CLOAKING);

		if(SUCCEEDED(hr))
		{
			// Get the access token of the client before we revert to self
			fOpened = OpenThreadToken(GetCurrentThread(), 
						     TOKEN_QUERY | TOKEN_IMPERSONATE, 
							 TRUE, 
							 &hThrToken);

			if(fOpened) {
			    // Get the specific associated client Sink interface that this
       	        // connection point expects to use for notifications.
				hr = pUnkSink->QueryInterface(m_iidSink, (PPVOID)&pISink);

				// if FAILED(hr), the token must be closed
			} 
            else 
            {
				hr = CONNECT_E_CANNOTCONNECT;
			}
		}

		// We don't have to do RevertToSelf() here since CoImpersonateClient() call
        // just impersonate the client for the duration of the call

    } 
    else 
    {
        // we cannot impersonate
        // maybe we are inproc
        // Just call the plain queryinterface without 
        // blanket
        hr = pUnkSink->QueryInterface(m_iidSink, (PPVOID)&pISink);
    }

    if (SUCCEEDED(hr))
    {
      // Store the specific sink interface in this connection point's
      // array of live connections. First find a free slot (expand the
      // array if needed).
      hr = GetSlot(&uiFreeSlot);
      if (SUCCEEDED(hr))
      {
        //
        // store interface ref in GIP
        //
        if (pISink != NULL)
        {
            DBG_ASSERT(m_pGIT != NULL);
            hr = m_pGIT->RegisterInterfaceInGlobal (pISink, m_iidSink, &dwCookie);
            pISink->Release();

            if (SUCCEEDED(hr)) {
                // Assign the new slot with the connection entry.
                // the place for the pIunk is used for the thread token, if any
                m_paConnections[uiFreeSlot].pUnk = (IUnknown *) hThrToken;
                m_paConnections[uiFreeSlot].dwCookie = dwCookie;

                // WinSE 7579
                hThrToken = NULL;

                // Assign the output Cookie value.
                *pdwCookie = dwCookie;

                // Increment the number of live connections.
                m_cConnections++;
            }
        }
      }
    } 
    else 
    {      
      hr = CONNECT_E_CANNOTCONNECT;
    }

  if (m_bUnicode) {
      ((CADMCOMW *)m_pHostObj)->SinkUnlock();
  }
  else {
#if 0
      ((CADMCOM *)m_pHostObj)->SinkUnlock();
#else
      DBG_ASSERT(FALSE);
#endif
  }

  if (hThrToken)
  {
      CloseHandle(hThrToken);
      hThrToken = NULL;
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Unadvise

  Summary:  The Unadvise member method of this IConnectionPoint interface
            implementation. Called by clients to disconnect a connection
            of their sink to this connection point. The connection is
            identified by the dwCookie argument (obtained by a previous
            Advise call). Uses the CThreaded OwnThis mechanism to provide
            mutually exclusive access by multiple threads.

  Args:     DWORD dwCookie
              Connection key that was obtained by a previous Advise call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/

STDMETHODIMP COConnectionPoint::Unadvise(
               DWORD dwCookie)
{
    HRESULT hr;
    if (m_bUnicode) {
        ((CADMCOMW *)m_pHostObj)->SinkLock(TSRES_LOCK_WRITE);
        hr = Unadvise_Worker(dwCookie);
        ((CADMCOMW *)m_pHostObj)->SinkUnlock();

    }
    else {
#if 0
        ((CADMCOM *)m_pHostObj)->SinkLock(TSRES_LOCK_WRITE);
        hr = Unadvise_Worker(dwCookie);
        ((CADMCOM *)m_pHostObj)->SinkUnlock();
#else
        hr = E_FAIL;
        DBG_ASSERT(FALSE);
#endif
    }

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Unadvise_Worker

  Summary:  Does the actual work of Unadvise. Assume a write lock is already
            held.

  Args:     DWORD dwCookie
              Connection key that was obtained by a previous Advise call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/

STDMETHODIMP
COConnectionPoint::Unadvise_Worker(DWORD dwCookie)
{
    HRESULT hr = NOERROR;
    UINT uiSlot;

    if (0 != dwCookie) {
        hr = FindSlot(dwCookie, &uiSlot);
        if (SUCCEEDED(hr))
        {
          DBG_ASSERT(m_pGIT != NULL);
          if (m_pGIT != NULL)
          {
              m_pGIT->RevokeInterfaceFromGlobal (dwCookie);
          }

          // Mark the array entry as empty.
          m_paConnections[uiSlot].dwCookie = 0;

          // Close the access token handle we opened in the Advise call
		  if(m_paConnections[uiSlot].pUnk) 
          {
			  CloseHandle((HANDLE)m_paConnections[uiSlot].pUnk);
	      }

          // Decrement the number of live connections.
          m_cConnections--;
        }
    }
    else {
      hr = E_INVALIDARG;
    }

    return hr;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::EnumConnections

  Summary:  The EnumConnections member method of this IConnectionPoint
            interface implementation. Called to obtain an IEnumConnections
            enumerator interface that can be used to enumerate the
            connections of this connection point. Uses the CThreaded
            OwnThis mechanism to ensure mutually exclusive access by
            multiple threads.

  Args:     IEnumConnections** ppIEnum
              Address of the caller's output pointer variable that will
              receive the enumerator IEnumConnections interface pointer.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::EnumConnections(
               IEnumConnections** ppIEnum)
{
  HRESULT hr = OLE_E_NOCONNECTION;
  CONNECTDATA* paConns;
  COEnumConnections* pCOEnum;
  UINT i,j;

  if (m_bUnicode) {
      ((CADMCOMW *)m_pHostObj)->SinkLock(TSRES_LOCK_READ);
  }
  else {
#if 0
      ((CADMCOM *)m_pHostObj)->SinkLock(TSRES_LOCK_READ);
#else
      DBG_ASSERT(FALSE);
#endif
  }

  // Zero the output enumerator interface pointer.
  *ppIEnum = NULL;

  if (0 != m_cConnections) {
      // Create an array of CONNECTDATA structures.
      paConns = new CONNECTDATA[(UINT)m_cConnections];
      if (NULL != paConns) {
          for (i=0, j=0; i<m_uiMaxIndex && j<m_cConnections; i++) {
            // Copy non-empty entries only.
            if (0 != m_paConnections[i].dwCookie) {

              //
              // Assign the occupied entry
              // the interface is the storage for the thread token
              //

              paConns[j].dwCookie = m_paConnections[i].dwCookie;
              paConns[j].pUnk = m_paConnections[i].pUnk;
              j++;
            }
          }

          //
          // Create a new COM object for enumerating connections. Pass
          // 'this' as a pHostObj pointer used later to ensure the host
          // connection point object stays alive as long as the enumerator
          // that enumerates connections to that connection point.
          //

          pCOEnum = new COEnumConnections(this);
          if (NULL != pCOEnum)
          {
              // Use the previously constructed (paConns) array of connections
              // to init the new COEnumConnections COM object. The Init will
              // build yet another internal copy of this array. Set the
              // initial enumerator index to 0.
              hr = pCOEnum->Init(m_cConnections, paConns, 0, m_pGIT);

              // QueryInterface to return the requested interface pointer.
              // An AddRef will be conveniently done by the QI.
              if (SUCCEEDED(hr)) {
                  hr = pCOEnum->QueryInterface(
                                IID_IEnumConnections,
                                (PPVOID)ppIEnum);
              }

              if (FAILED(hr)) {
                  delete pCOEnum;
              }
          }
          else {
              hr = E_OUTOFMEMORY;
          }

          // We're done with the locally constructed array copy--delete it.
          delete [] paConns;

      }
      else {
          hr = E_OUTOFMEMORY;
      }
  }

#if 0
  if (m_bUnicode) {
#endif // 0
      ((CADMCOMW *)m_pHostObj)->SinkUnlock();
#if 0
  }
  else {
      ((CADMCOM *)m_pHostObj)->SinkUnlock();
  }
#endif // 0

  return hr;
}


/*---------------------------------------------------------------------------
  COEnumConnections's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  Next, Skip, Reset, and Clone.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::COEnumConnections

  Summary:  COEnumConnections Constructor.

  Args:     IUnknown* pHostObj
              Pointer to IUnknown interface of the host Connection Point
              COM object whose connections are being enumerated.

  Modifies: m_cRefs, m_pHostObj, m_iEnumIndex, m_cConnections,
            and m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnections::COEnumConnections(
  IUnknown* pHostObj)
{
  // Zero the COM object's reference count.
  m_cRefs = 0;

  // Assign the Host Object pointer.
  m_pHostObj = pHostObj;

  // Initialize the Connection Point enumerator variables.
  m_iEnumIndex = 0;
  m_cConnections = 0;
  m_paConnections = NULL;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::~COEnumConnections

  Summary:  COEnumConnections Destructor.

  Args:     void

  Modifies: m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnections::~COEnumConnections(void)
{
  if (NULL != m_paConnections)
  {
    UINT i;

    // Release all the connected sink interface pointers.
    for (i=0; i<m_cConnections; i++) {
        if (m_paConnections[i].pUnk != NULL) {
            m_paConnections[i].pUnk->Release();
        }
    }

    // Delete the array of connections.
    delete [] m_paConnections;
  }

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Init

  Summary:  COEnumConnections Initialization method.  Create any
            necessary arrays, structures, and objects.

  Args:     ULONG cConnections
              Number of Connections.
            CONNECTDATA* paConnections,
              Pointer to array of connections.
            ULONG iEnumIndex
              The Enumerator index initial value.

  Modifies: m_cConnections, m_paConnections, m_pHostObj, m_iEnumIndex.

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COEnumConnections::Init(
          ULONG cConnections,
          CONNECTDATA* paConnections,
          ULONG iEnumIndex,
          IGlobalInterfaceTable* pGIT)
{
  HRESULT hr = NOERROR;
  UINT i;

  // Remember the number of live Connections.
  m_cConnections = cConnections;

  // Remember the initial enumerator index.
  m_iEnumIndex = iEnumIndex;

  // Create a copy of the array of connections and keep it inside
  // this enumerator COM object.
  m_paConnections = new CONNECTDATA [(UINT) cConnections];

  // Fill the array copy with the connection data from the connections
  // array passed. AddRef for each new sink Interface pointer copy made.
  if (NULL != m_paConnections) {
      for (i=0; (i < cConnections) ; i++) {

          m_paConnections[i].dwCookie = paConnections[i].dwCookie;
          m_paConnections[i].pUnk = NULL;

          if (SUCCEEDED(hr)) {

                  //
                  // Get the interface.
                  // Don't do this after a failure, to avoid overriding a previous
                  // error code.
                  //

              if (pGIT != NULL) {

                  hr = pGIT->GetInterfaceFromGlobal(m_paConnections[i].dwCookie,
                                                    IID_IMSAdminBaseSink_W,
                                                    (void**)&(m_paConnections[i].pUnk));

                  // if pUnk is not null, than it's a token                                  
                  if(SUCCEEDED(hr) && paConnections[i].pUnk)
				  { 					  
                     
					  if(SetThreadToken(NULL, (HANDLE)paConnections[i].pUnk))
					  {
                         // Set our cloaked identity to be used before we call back on this
                         // advise interface.  It's important to do this for security.  Since
                         // we run as LocalSystem, if we were to call back without cloaking, the
                         // client could impersonate us and get a free LocalSystem context which
                         // could be used for malicious purposes.
  
						  hr = CoSetProxyBlanket(m_paConnections[i].pUnk,
										 RPC_C_AUTHN_WINNT,      // use NT default security
									     RPC_C_AUTHZ_NONE,       // use NT default authentication
										 NULL,                   // must be null if default
                                         RPC_C_AUTHN_LEVEL_CALL, // call
                                         RPC_C_IMP_LEVEL_IMPERSONATE,
                                         NULL,                   // use process token
                                         EOAC_STATIC_CLOAKING);
					      
						  
					      if (!(SetThreadToken(NULL, NULL) && SUCCEEDED(hr)))
                          {
							   hr = E_FAIL;
						  }
					  }  
                      else 
                      {
                          hr = E_FAIL;   
                      }
				  }
              }
              else {

                  //
                  // This case only occurs when Clone is called, in which case the pUnk field
                  // is valid.
                  //

                  DBG_ASSERT(paConnections[i].pUnk != NULL);
                  hr = paConnections[i].pUnk->QueryInterface(IID_IMSAdminBaseSink_W,
                                                             (void **)&(m_paConnections[i].pUnk));
              }
          }
      }
  }
  else
    hr = E_OUTOFMEMORY;

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::QueryInterface

  Summary:  QueryInterface of the COEnumConnections non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  HRESULT hr = E_NOINTERFACE;

  *ppv = NULL;

  // The IEnumConnections interface is implemented directly in
  // this COM object rather than being a nested interface implementation.
  if (IID_IUnknown == riid || IID_IEnumConnections == riid)
    *ppv = (LPVOID)this;

  if (NULL != *ppv)
  {
    // We've handed out a pointer to the interface so obey the COM rules
    // and AddRef the reference count.
    ((LPUNKNOWN)*ppv)->AddRef();
    hr = NOERROR;
  }

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::AddRef

  Summary:  AddRef of the COEnumConnections non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnections::AddRef(void)
{
  ULONG cRefs;

  cRefs = InterlockedIncrement((long *)&m_cRefs);

  // Also AddRef the host object to ensure it stays around as long as
  // this enumerator.
  m_pHostObj->AddRef();

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Release

  Summary:  Release of the COEnumConnections non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnections::Release(void)
{
  ULONG cRefs;

  // Pass this release along to the Host object being enumerated.
  m_pHostObj->Release();

  cRefs = InterlockedDecrement((long *)&m_cRefs);

  if (0 == cRefs)
  {
    // We artificially bump the main ref count to prevent reentrancy via
    // the main object destructor.
    InterlockedIncrement((long *)&m_cRefs);
    delete this;
  }

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Next

  Summary:  The Next member method of this IEnumConnections interface
            implementation. Called by outside clients of a
            COEnumConnections object to request a number of next
            connections be returned in an array supplied by the caller.

  Args:     ULONG cReq
              Number of connection points requested for return (starting at
              the current Enumerator index).
            CONNECTDATA* paConnections,
              Pointer to a caller's output array that will receive the
              enumerated connection data structures.
            ULONG* pcEnumerated)
              Pointer to a ULONG variable that will contain the number of
              connection points actually enumerated by this call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Next(
               ULONG cReq,
               CONNECTDATA* paConnections,
               ULONG* pcEnumerated)
{
  HRESULT hr = NOERROR;
  ULONG cRet = 0;

  // Make sure the argument values passed are valid.
  if (NULL != m_paConnections)
  {
    if (NULL != paConnections)
    {
      if (m_iEnumIndex < m_cConnections)
      {
        if (NULL != pcEnumerated)
          *pcEnumerated = 0L;
        else
          if (1L != cReq)
            hr = E_POINTER;
      }
      else
        hr = S_FALSE;
    }
    else
      hr = E_POINTER;
  }
  else
    hr = S_FALSE;

  if (SUCCEEDED(hr))
  {
    // Starting at the current Enumerator index, loop to assign the
    // requested number of output connection data structures.
    for (; m_iEnumIndex < m_cConnections && cReq > 0;
           paConnections++, m_iEnumIndex++, cRet++, cReq--)
    {

      // Because we are assigning a copy of a connection's data, AddRef
      // its sink interface pointer.
      if (NULL != m_paConnections[m_iEnumIndex].pUnk)
        m_paConnections[m_iEnumIndex].pUnk->AddRef();

      // Assign a connection's data from the inside Enumerator array to
      // the specified output receiving array.
      *paConnections = m_paConnections[m_iEnumIndex];
    }

    // Assign the output number of connections enumerated.
    if (NULL != pcEnumerated)
      *pcEnumerated = cRet;
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Skip

  Summary:  The Skip member method of this IEnumConnections interface
            implementation. Starting at the current Enumerator index, skip
            the specified number of connection items.

  Args:     ULONG cSkip
              Number of Connection items to skip.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Skip(
               ULONG cSkip)
{
  HRESULT hr = NOERROR;

  // If there really is a connection array and the requested
  // amount of skip does not exceed the number of connections,
  // then bump the index by the requested skip amount.
  if (NULL != m_paConnections && (m_iEnumIndex + cSkip) < m_cConnections)
    m_iEnumIndex += cSkip;
  else
    hr = S_FALSE;

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Reset

  Summary:  The Reset member method of the IEnumConnections interface
            implementation. Resets the Enumeration index to the first
            connection item in the array.

  Args:     void.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Reset(
               void)
{
  // Zero the main Enumerator index.
  m_iEnumIndex = 0;

  return NOERROR;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Clone

  Summary:  The Clone member method of this IEnumConnections interface
            implementation. Creates a new clone of this entire Connection
            enumerator COM object and returns a pointer to its
            IEnumConnections interface.

  Args:     IEnumConnections** ppIEnum
              Address of the caller's output pointer variable that will
              receive the IEnumConnections interface pointer of the
              new enumerator clone.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Clone(
               IEnumConnections** ppIEnum)
{
  HRESULT hr;
  COEnumConnections* pCOEnum;

  // NULL the output variable first.
  *ppIEnum = NULL;

  // Create the Clone Enumerator COM object.
  pCOEnum = new COEnumConnections(m_pHostObj);
  if (NULL != pCOEnum)
  {
    // Initialize it with same values as in this existing enumerator.
    hr = pCOEnum->Init(m_cConnections, m_paConnections, m_iEnumIndex);
    if (SUCCEEDED(hr))
    {
      // QueryInterface to return the requested interface pointer.
      // An AddRef will be conveniently done by the QI.
      hr = pCOEnum->QueryInterface(
                        IID_IEnumConnections,
                        (PPVOID)ppIEnum);
    }

    if( FAILED( hr ) )
    {
        delete pCOEnum;
        pCOEnum = NULL;
    }
  }
  else
    hr = E_OUTOFMEMORY;

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\inc\pwsctrl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsctrl.cpp

Abstract:

    This is the main routine for the Internet Services suite.

Author:

    Boyd Multerer       (BoydM)     29-Apr-1997

--*/
BOOL W95StartW3SVC( void );
//BOOL W95StartW3SVC( LPCSTR pszPath, LPCSTR pszPathDir, PCHAR pszParams );
BOOL W95ShutdownW3SVC( VOID );
BOOL W95ShutdownIISADMIN( VOID );
BOOL IsIISAdminRunning( VOID );
BOOL IsInetinfoRunning( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\sink.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    IIS DCOM Admin connection point container code for sinks

Author:

    Sophia Chung            12-Jan-97

Revision History:

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include "coiadm.hxx"

#if 0
/*---------------------------------------------------------------------------
  CADMCOM's nested implementation of the COM standard
  IConnectionPointContainer interface including Constructor, Destructor,
  QueryInterface, AddRef, Release, FindConnectionPoint, and
  EnumConnectionPoints.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOM::CImpIConnectionPointContainer
              ::CImpIConnectionPointContainer

  Summary:  Constructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     CADMCOM* pBackObj,
              Back pointer to the parent outer object.
            IUnknown* pUnkOuter
              Pointer to the outer Unknown.  For delegation.

  Modifies: m_pBackObj, m_pUnkOuter.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CADMCOM::CImpIConnectionPointContainer::CImpIConnectionPointContainer()
{
  // Init the Back Object Pointer to point to the parent object.
  //m_pBackObj = pBackObj;

  //m_pUnkOuter = pBackObj;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOM::CImpIConnectionPointContainer
              ::~CImpIConnectionPointContainer

  Summary:  Destructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     void

  Modifies: .

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CADMCOM::CImpIConnectionPointContainer::~CImpIConnectionPointContainer(void)
{
  return;
}

VOID CADMCOM::CImpIConnectionPointContainer::Init(CADMCOM *pBackObj)
{
  // Init the Back Object Pointer to point to the parent object.
  m_pBackObj = pBackObj;

  m_pUnkOuter = pBackObj;

  return;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOM::CImpIConnectionPointContainer::QueryInterface

  Summary:  The QueryInterface IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
              Returned by the delegated outer QueryInterface call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CADMCOM::CImpIConnectionPointContainer::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  // Delegate this call to the outer object's QueryInterface.
  return m_pUnkOuter->QueryInterface(riid, ppv);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOM::CImpIConnectionPointContainer::AddRef

  Summary:  The AddRef IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer AddRef call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CADMCOM::CImpIConnectionPointContainer::AddRef(void)
{
  // Delegate this call to the outer object's AddRef.
  return m_pUnkOuter->AddRef();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOM::CImpIConnectionPointContainer::Release

  Summary:  The Release IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer Release call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CADMCOM::CImpIConnectionPointContainer::Release(void)
{
  // Delegate this call to the outer object's Release.
  return m_pUnkOuter->Release();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOM::CImpIConnectionPointContainer::FindConnectionPoint

  Summary:  Given an IID for a connection point sink find and return the
            interface pointer for that connection point sink.

  Args:     REFIID riid
              Reference to an IID
            IConnectionPoint** ppConnPt
              Address of the caller's IConnectionPoint interface pointer
              variable that will receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CADMCOM::CImpIConnectionPointContainer::FindConnectionPoint(
               REFIID riid,
               IConnectionPoint** ppConnPt)
{
  HRESULT hr = E_NOINTERFACE;
  IConnectionPoint* pIConnPt;
  m_pBackObj->SinkLock(TSRES_LOCK_READ);

  // NULL the output variable.
  *ppConnPt = NULL;

  pIConnPt = m_pBackObj->m_aConnectionPoints[ADM_CONNPOINT_WRITESINK];
  if (NULL != pIConnPt)
  {
    // This connectable CADMCOM object currently has only the Paper Sink
    // connection point. If the associated interface is requested,
    // use QI to get the Connection Point interface and perform the
    // needed AddRef.
    if (IID_IMSAdminBaseSink == riid)
      hr = pIConnPt->QueryInterface(
                       IID_IConnectionPoint,
                       (PPVOID)ppConnPt);
  }

  m_pBackObj->SinkUnlock();

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOM::CImpIConnectionPointContainer::EnumConnectionPoints

  Summary:  Return Enumerator for the connectable object's contained
            connection points.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's Enumerator interface pointer
              variable. An output variable that will receive a pointer to
              the connection point enumerator COM object.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CADMCOM::CImpIConnectionPointContainer::EnumConnectionPoints(
                       IEnumConnectionPoints** ppIEnum)
{
  HRESULT hr = NOERROR;
  IConnectionPoint* aConnPts[MAX_CONNECTION_POINTS];
  COEnumConnectionPoints* pCOEnum;
  UINT i;

  m_pBackObj->SinkLock(TSRES_LOCK_READ);
  // Zero the output interface pointer.
  *ppIEnum = NULL;

  // Make a copy on the stack of the array of connection point
  // interfaces. The copy is used below in the creation of the new
  // Enumerator object.
  for (i=0; i<MAX_CONNECTION_POINTS; i++)
    aConnPts[i] = (IConnectionPoint*)m_pBackObj->m_aConnectionPoints[i];

  // Create a Connection Point enumerator COM object for the connection
  // points offered by this CADMCOM object. Pass 'this' to be used to
  // hook the lifetime of the host object to the life time of this
  // enumerator object.
  pCOEnum = new COEnumConnectionPoints(this);
  if (NULL != pCOEnum)
  {
    // Use the array copy to Init the new Enumerator COM object.
    // Set the initial Enumerator index to 0.
    hr = pCOEnum->Init(MAX_CONNECTION_POINTS, aConnPts, 0);
    if (SUCCEEDED(hr))
    {
      // QueryInterface to return the requested interface pointer.
      // An AddRef will be conveniently done by the QI.
      if (SUCCEEDED(hr))
      {
        hr = pCOEnum->QueryInterface(
                        IID_IEnumConnectionPoints,
                        (PPVOID)ppIEnum);
      }
      else 
      {
         delete pCOEnum;
         pCOEnum = NULL;
      }
    }
  }
  else
    hr = E_OUTOFMEMORY;

  m_pBackObj->SinkUnlock();

  return hr;
}

/*
CImpIMDCOMSINK::CImpIMDCOMSINK()
{
    m_dwRefCount=0;
    m_pAdmObj = NULL;
}
*/

CImpIMDCOMSINK::CImpIMDCOMSINK(
    IMSAdminBase *pAdm
    )
{
    m_dwRefCount=0;
    m_pAdmObj = pAdm;
}


CImpIMDCOMSINK::~CImpIMDCOMSINK()
{
}

HRESULT
CImpIMDCOMSINK::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK) {
        *ppObject = (IMDCOMSINK *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIMDCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIMDCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINK::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
    HRESULT hRes;
/*
    printf("Recieved callback for handle %X\n", hMDHandle);
    for (i = 0; i < dwMDNumElements; i++) {
        printf("Change Type = %X, Path = %s\n", pcoChangeList[i].dwMDChangeType, pcoChangeList[i].pszMDPath);
        for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++) {
            printf("\tData Changed ID = %X\n", pcoChangeList[i].pdwMDDataIDs[j]);
        }
    }
*/

    hRes = ((CADMCOM *)m_pAdmObj)->NotifySink(hMDHandle, dwMDNumElements, pcoChangeList);
    return hRes;
}

#endif // 0

/*---------------------------------------------------------------------------
  CADMCOM's nested implementation of the COM standard
  IConnectionPointContainer interface including Constructor, Destructor,
  QueryInterface, AddRef, Release, FindConnectionPoint, and
  EnumConnectionPoints.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer
              ::CImpIConnectionPointContainer

  Summary:  Constructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     CADMCOMW* pBackObj,
              Back pointer to the parent outer object.
            IUnknown* pUnkOuter
              Pointer to the outer Unknown.  For delegation.

  Modifies: m_pBackObj, m_pUnkOuter.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CADMCOMW::CImpIConnectionPointContainer::CImpIConnectionPointContainer()
{
  // Init the Back Object Pointer to point to the parent object.
  //m_pBackObj = pBackObj;

  //m_pUnkOuter = pBackObj;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer
              ::~CImpIConnectionPointContainer

  Summary:  Destructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     void

  Modifies: .

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CADMCOMW::CImpIConnectionPointContainer::~CImpIConnectionPointContainer(void)
{
  return;
}

VOID CADMCOMW::CImpIConnectionPointContainer::Init(CADMCOMW *pBackObj)
{
  // Init the Back Object Pointer to point to the parent object.
  m_pBackObj = pBackObj;

  m_pUnkOuter = (IUnknown*)pBackObj;

  return;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::QueryInterface

  Summary:  The QueryInterface IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
              Returned by the delegated outer QueryInterface call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CADMCOMW::CImpIConnectionPointContainer::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  // Delegate this call to the outer object's QueryInterface.
  return m_pUnkOuter->QueryInterface(riid, ppv);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::AddRef

  Summary:  The AddRef IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer AddRef call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CADMCOMW::CImpIConnectionPointContainer::AddRef(void)
{
  // Delegate this call to the outer object's AddRef.
  return m_pUnkOuter->AddRef();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::Release

  Summary:  The Release IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer Release call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CADMCOMW::CImpIConnectionPointContainer::Release(void)
{
  // Delegate this call to the outer object's Release.
  return m_pUnkOuter->Release();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::FindConnectionPoint

  Summary:  Given an IID for a connection point sink find and return the
            interface pointer for that connection point sink.

  Args:     REFIID riid
              Reference to an IID
            IConnectionPoint** ppConnPt
              Address of the caller's IConnectionPoint interface pointer
              variable that will receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CADMCOMW::CImpIConnectionPointContainer::FindConnectionPoint(
               REFIID riid,
               IConnectionPoint** ppConnPt)
{
  HRESULT hr = E_NOINTERFACE;
  IConnectionPoint* pIConnPt;
  m_pBackObj->SinkLock(TSRES_LOCK_READ);

  // NULL the output variable.
  *ppConnPt = NULL;

  pIConnPt = m_pBackObj->m_aConnectionPoints[ADM_CONNPOINT_WRITESINK];
  if (NULL != pIConnPt)
  {
    // This connectable CADMCOMW object currently has only the Paper Sink
    // connection point. If the associated interface is requested,
    // use QI to get the Connection Point interface and perform the
    // needed AddRef.
    if (IID_IMSAdminBaseSink_W == riid)
      hr = pIConnPt->QueryInterface(
                       IID_IConnectionPoint,
                       (PPVOID)ppConnPt);
  }

  m_pBackObj->SinkUnlock();

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::EnumConnectionPoints

  Summary:  Return Enumerator for the connectable object's contained
            connection points.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's Enumerator interface pointer
              variable. An output variable that will receive a pointer to
              the connection point enumerator COM object.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CADMCOMW::CImpIConnectionPointContainer::EnumConnectionPoints(
                       IEnumConnectionPoints** ppIEnum)
{
  HRESULT hr = NOERROR;
  IConnectionPoint* aConnPts[MAX_CONNECTION_POINTS];
  COEnumConnectionPoints* pCOEnum;
  UINT i;

  m_pBackObj->SinkLock(TSRES_LOCK_READ);
  // Zero the output interface pointer.
  *ppIEnum = NULL;

  // Make a copy on the stack of the array of connection point
  // interfaces. The copy is used below in the creation of the new
  // Enumerator object.
  for (i=0; i<MAX_CONNECTION_POINTS; i++)
    aConnPts[i] = (IConnectionPoint*)m_pBackObj->m_aConnectionPoints[i];

  // Create a Connection Point enumerator COM object for the connection
  // points offered by this CADMCOMW object. Pass 'this' to be used to
  // hook the lifetime of the host object to the life time of this
  // enumerator object.
  pCOEnum = new COEnumConnectionPoints(this);
  if (NULL != pCOEnum)
  {
    // Use the array copy to Init the new Enumerator COM object.
    // Set the initial Enumerator index to 0.
    hr = pCOEnum->Init(MAX_CONNECTION_POINTS, aConnPts, 0);
    if (SUCCEEDED(hr))
    {
      // QueryInterface to return the requested interface pointer.
      // An AddRef will be conveniently done by the QI.
      if (SUCCEEDED(hr))
        hr = pCOEnum->QueryInterface(
                        IID_IEnumConnectionPoints,
                        (PPVOID)ppIEnum);
    }
  }
  else
    hr = E_OUTOFMEMORY;

  m_pBackObj->SinkUnlock();

  return hr;
}

CImpIMDCOMSINKW::CImpIMDCOMSINKW(
    IMSAdminBaseW *pAdm
    )
{
    m_dwRefCount=0;
    m_pAdmObj = pAdm;
}

CImpIMDCOMSINKW::~CImpIMDCOMSINKW()
{
}

HRESULT
CImpIMDCOMSINKW::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK_W) {
        *ppObject = (IMDCOMSINK *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIMDCOMSINKW::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIMDCOMSINKW::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINKW::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ])
{
    HRESULT hresReturn;
/*
    printf("Recieved callback for handle %X\n", hMDHandle);
    for (i = 0; i < dwMDNumElements; i++) {
        printf("Change Type = %X, Path = %s\n", pcoChangeList[i].dwMDChangeType, pcoChangeList[i].pszMDPath);
        for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++) {
            printf("\tData Changed ID = %X\n", pcoChangeList[i].pdwMDDataIDs[j]);
        }
    }
*/

    hresReturn = ((CADMCOMW *)m_pAdmObj)->NotifySinks(hMDHandle, dwMDNumElements, pcoChangeList, TRUE);
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINKW::ComMDShutdownNotify()
{
    HRESULT hresReturn;
    hresReturn = ((CADMCOMW *)m_pAdmObj)->NotifySinks(0, 0, NULL, FALSE);
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINKW::ComMDEventNotify(
        /* [in] */ DWORD dwMDEvent)
{

    if (dwMDEvent == MD_EVENT_MID_RESTORE) {
        ((CADMCOMW *)m_pAdmObj)->DisableAllHandles();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\beta2\autobj.cxx ===
/*++
   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       autobj.cxx

   Abstract:

       This module defines Automation Admin APIs.

   Author:

       Michael Thomas (michth)   17-Dec-1996

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#include <defaults.hxx>
#include <coiadm.hxx>
#include <coiaut.hxx>
#include <admacl.hxx>

#include <cguid.h>
#include <oleauto.h>

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}

//HRESULT RaiseException(int nID, REFGUID rguid);

CMSMetaBase::CMSMetaBase()
{
    HRESULT hresInit;
    IMSAdminBase *padmcDcomInterface;

    ITypeLib   *pITypeLib;

    m_pITINeutral=NULL;
    m_pITIDataNeutral=NULL;
    m_pITIKeyNeutral=NULL;
    m_bComInitialized = FALSE;

    m_padmcDcomInterface = NULL;
    hresInit = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hresInit)) {
        m_bComInitialized = TRUE;
        hresInit = CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void**) &padmcDcomInterface);
        if (FAILED(hresInit)) {
            hresInit = CoCreateInstance(GETAdminBaseCLSID(FALSE), NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void**) &padmcDcomInterface);
        }
    }

    if (SUCCEEDED(hresInit)) {
        m_padmcDcomInterface = padmcDcomInterface;
        hresInit = LoadRegTypeLib(LIBID_MSAdmin,
                                  1,
                                  0,
                                  LANG_NEUTRAL,
                                  &pITypeLib);
        if (FAILED(hresInit)) {
            hresInit=LoadTypeLib(OLESTR("iadm.tlb"), &pITypeLib);
        }

        if (SUCCEEDED(hresInit)) {
            //Got the type lib, get type info for the interface we want
            hresInit=pITypeLib->GetTypeInfoOfGuid(IID_IMSMetaBase, &m_pITINeutral);
            if (SUCCEEDED(hresInit)) {
                m_pITINeutral->AddRef();
                hresInit=pITypeLib->GetTypeInfoOfGuid(IID_IMSMetaDataItem, &m_pITIDataNeutral);
                if (SUCCEEDED(hresInit)) {
                    m_pITIDataNeutral->AddRef();
                    hresInit=pITypeLib->GetTypeInfoOfGuid(IID_IMSMetaKey, &m_pITIKeyNeutral);
                    if (SUCCEEDED(hresInit)) {
                        m_pITIKeyNeutral->AddRef();
                    }
                }
            }
            pITypeLib->Release();
        }

    }

    m_hresInit = hresInit;
}

CMSMetaBase::~CMSMetaBase()
{
    if (m_bComInitialized) {
        RELEASE_INTERFACE(m_pITINeutral);
        RELEASE_INTERFACE(m_pITIDataNeutral);
        RELEASE_INTERFACE(m_pITIKeyNeutral);
        RELEASE_INTERFACE(m_padmcDcomInterface);
        CoUninitialize();
    }
}

HRESULT STDMETHODCALLTYPE
CMSMetaBase::CopyKey(
        /* [in] */ IMSMetaKey __RPC_FAR *pmkSourceKey,
        /* [in] */ IMSMetaKey __RPC_FAR *pmkDestKey,
        /* [in] */ BOOL bOverwriteFlag,
        /* [in] */ BOOL bCopyFlag,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaSourcePath,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaDestPath)
{
    HRESULT hresReturn;
    BYTE *pszSourcePath;
    BYTE *pszDestPath;


    //DebugBreak();

    if ((pmkSourceKey == NULL) ||
        (!(((CMSMetaKey *)pmkSourceKey)->IsOpen())) ||
        (pmkDestKey == NULL) ||
        (!(((CMSMetaKey *)pmkDestKey)->IsOpen()))) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }

    if (SUCCEEDED(hresReturn)) {
        hresReturn = GetVariantString(pvaSourcePath, pszSourcePath);
    }

    if (SUCCEEDED(hresReturn)) {

        hresReturn = GetVariantString(pvaDestPath, pszDestPath);
    }


    if (SUCCEEDED(hresReturn)) {
        hresReturn = m_padmcDcomInterface->CopyKey(((CMSMetaKey *)pmkSourceKey)->GetHandle(),
                                                                pszSourcePath,
                                                                ((CMSMetaKey *)pmkDestKey)->GetHandle(),
                                                                pszDestPath,
                                                                bOverwriteFlag,
                                                                bCopyFlag);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaBase::CopyData(
        /* [in] */ IMSMetaKey __RPC_FAR *pmkSourceKey,
        /* [in] */ IMSMetaKey __RPC_FAR *pmkDestKey,
        /* [in] */ long dwAttributes,
        /* [in] */ long dwUserType,
        /* [in] */ long dwDataType,
        /* [in] */ BOOL bCopyFlag,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaSourcePath,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaDestPath)
{
    HRESULT hresReturn;
    BYTE *pszSourcePath;
    BYTE *pszDestPath;


    //DebugBreak();

    if ((pmkSourceKey == NULL) ||
        (!(((CMSMetaKey *)pmkSourceKey)->IsOpen())) ||
        (pmkDestKey == NULL) ||
        (!(((CMSMetaKey *)pmkDestKey)->IsOpen()))) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }

    if (SUCCEEDED(hresReturn)) {
        hresReturn = GetVariantString(pvaSourcePath, pszSourcePath);
    }

    if (SUCCEEDED(hresReturn)) {

        hresReturn = GetVariantString(pvaDestPath, pszDestPath);

        if (SUCCEEDED(hresReturn)) {
            hresReturn = m_padmcDcomInterface->CopyData(((CMSMetaKey *)pmkSourceKey)->GetHandle(),
                                                                  pszSourcePath,
                                                                  ((CMSMetaKey *)pmkDestKey)->GetHandle(),
                                                                  pszDestPath,
                                                                  dwAttributes,
                                                                  dwUserType,
                                                                  dwDataType,
                                                                  bCopyFlag);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaBase::OpenKey(
            /* [in] */ long dwAccessRequested,
            /* [optional][in] */ VARIANTARG vaTimeOut,
            /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath,
            /* [retval][out] */ IMSMetaKey __RPC_FAR *__RPC_FAR *ppmkKey)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;
    METADATA_HANDLE hNew;
    DWORD dwTimeOut;


    //DebugBreak();
    hresReturn = GetVariantString(pvaPath, pszPath);

    if (SUCCEEDED(hresReturn)) {
        hresReturn = GetVariantDword(&vaTimeOut, dwTimeOut, ADM_DEFAULT_TIMEOUT);
    }

    if (SUCCEEDED(hresReturn)) {
        hresReturn = m_padmcDcomInterface->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                                                pszPath,
                                                                dwAccessRequested,
                                                                dwTimeOut,
                                                                &hNew);

        if (SUCCEEDED(hresReturn)) {
            IMSMetaKey *pmkKey = new CMSMetaKey(m_pITIKeyNeutral,
                                                m_pITIDataNeutral,
                                                hNew,
                                                m_padmcDcomInterface,
                                                (IMSMetaBase *)this);
            if (pmkKey == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                hresReturn = pmkKey->QueryInterface(IID_IMSMetaKey, (void **)ppmkKey);
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaBase::FlushData( void)
{
    HRESULT hresReturn = ERROR_SUCCESS;


    //DebugBreak();
    hresReturn = m_padmcDcomInterface->SaveData();

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaBase::GetSystemChangeNumber(
        /* [out] */ VARIANTARG __RPC_FAR *pdwSystemChangeNumber)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD *pdwSCN;


    //DebugBreak();

    if ((pdwSystemChangeNumber == NULL) || ((pdwSystemChangeNumber->vt & VT_BYREF) == 0)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        switch ((pdwSystemChangeNumber->vt & 0xFF)) {
        case VT_I4:
            pdwSCN = (DWORD *)pdwSystemChangeNumber->plVal;
            break;
        case VT_UI1:
            pdwSCN = pdwSystemChangeNumber->pulVal;
            break;
        default:
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        }
    }

    if (SUCCEEDED(hresReturn)) {
        hresReturn = m_padmcDcomInterface->GetSystemChangeNumber(pdwSCN);
    }

    return hresReturn;
}

HRESULT _stdcall
CMSMetaBase::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IMSMetaBase || riid==IID_IDispatch) {
        *ppObject = (IMSMetaBase *) this;
        AddRef();
    }
    else {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

ULONG _stdcall
CMSMetaBase::AddRef()
{
    DWORD dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    return dwRefCount;
}

ULONG _stdcall
CMSMetaBase::Release()
{
    DWORD dwRefCount;

    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);

    if (dwRefCount == 0) {
        delete this;
    }

    return dwRefCount;
}

//IDispatch members

//IDispatch functions, now part of CMDCOM

/*
 * CMDCOM::GetTypeInfoCount
 *
 * Purpose:
 *  Returns the number of type information (ITypeInfo) interfaces
 *  that the object provides (0 or 1).
 *
 * Parameters:
 *  pctInfo         UINT * to the location to receive
 *                  the count of interfaces.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaBase::GetTypeInfoCount(UINT *pctInfo)
    {
    //We implement GetTypeInfo so return 1
    *pctInfo=1;
    return NOERROR;
    }


/*
 * CMDCOM::GetTypeInfo
 *
 * Purpose:
 *  Retrieves type information for the automation interface.  This
 *  is used anywhere that the right ITypeInfo interface is needed
 *  for whatever LCID is applicable.  Specifically, this is used
 *  from within GetIDsOfNames and Invoke.
 *
 * Parameters:
 *  itInfo          UINT reserved.  Must be zero.
 *  lcid            LCID providing the locale for the type
 *                  information.  If the object does not support
 *                  localization, this is ignored.
 *  ppITypeInfo     ITypeInfo ** in which to store the ITypeInfo
 *                  interface for the object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaBase::GetTypeInfo(UINT itInfo, LCID lcid
    , ITypeInfo **ppITypeInfo)
    {
    HRESULT     hr;
    ITypeLib   *pITypeLib;
    ITypeInfo **ppITI=NULL;

    if (0!=itInfo)
        return ResultFromScode(TYPE_E_ELEMENTNOTFOUND);

    if (NULL==ppITypeInfo)
        return ResultFromScode(E_POINTER);


    /*
     * Note:  the type library is still loaded since we have
     * an ITypeInfo from it.
     */
     m_pITINeutral->AddRef();
    *ppITypeInfo=m_pITINeutral;
    return NOERROR;
    }

/*
 * CMDCOM::GetIDsOfNames
 *
 * Purpose:
 *  Converts text names into DISPIDs to pass to Invoke
 *
 * Parameters:
 *  riid            REFIID reserved.  Must be IID_NULL.
 *  rgszNames       OLECHAR ** pointing to the array of names to be
 *                  mapped.
 *  cNames          UINT number of names to be mapped.
 *  lcid            LCID of the locale.
 *  rgDispID        DISPID * caller allocated array containing IDs
 *                  corresponging to those names in rgszNames.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaBase::GetIDsOfNames(REFIID riid
    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    HRESULT     hr;
    ITypeInfo  *pTI;

    if (IID_NULL!=riid)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    //Get the right ITypeInfo for lcid.
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
        {
        hr=DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
        pTI->Release();
        }

    return hr;
}

/*
 * CMDCOM::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaBase::Invoke(DISPID dispID, REFIID riid
    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams
    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    HRESULT     hr;

    //riid is supposed to be IID_NULL always
    if (IID_NULL!=riid)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    //Clear exceptions
    SetErrorInfo(0L, NULL);

    //This is exactly what DispInvoke does--so skip the overhead.
//    hr=pTI->Invoke((IADMCOM *)this, dispID, wFlags
//        , pDispParams, pVarResult, pExcepInfo, puArgErr);
    hr=DispInvoke((IMSMetaBase *)this, m_pITINeutral, dispID, wFlags
        , pDispParams, pVarResult, pExcepInfo, puArgErr);

    //Exception handling is done within ITypeInfo::Invoke

    return hr;
}

CMSMetaKey::CMSMetaKey(ITypeInfo   *pITIKey,
                       ITypeInfo   *pITIData,
                       METADATA_HANDLE hHandle,
                       IMSAdminBase     *padmcDcomInterface,
                       IMSMetaBase *pmbMetaBase)
{
    m_pITIKey = pITIKey;
    m_pITIKey->AddRef();
    m_pITIData = pITIData;
    m_pITIData->AddRef();
    m_hHandle = hHandle;
    m_bOpen = TRUE;
    DBG_REQUIRE(SUCCEEDED(pmbMetaBase->QueryInterface(IID_IMSMetaBase, (void **)&m_pmbMetaBase)));
    DBG_REQUIRE(SUCCEEDED(padmcDcomInterface->QueryInterface(IID_IMSAdminBase, (void **)&m_padmcDcomInterface)));
//    m_psaData = NULL;
//    m_dwData = 0;
}

CMSMetaKey::~CMSMetaKey()
{
    m_pITIKey->Release();
    m_pITIData->Release();
    if (m_bOpen) {
        Close();
    }
    m_padmcDcomInterface->Release();
    m_pmbMetaBase->Release();
}


HRESULT STDMETHODCALLTYPE
CMSMetaKey::AddKey(
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;


    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {

        hresReturn = GetVariantString(pvaPath, pszPath);

        if (SUCCEEDED(hresReturn)) {
            hresReturn = m_padmcDcomInterface->AddKey(m_hHandle, pszPath);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::DeleteKey(
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;


    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
    //DebugBreak();
        hresReturn = GetVariantString(pvaPath, pszPath);
        if (SUCCEEDED(hresReturn)) {
            hresReturn = m_padmcDcomInterface->DeleteKey(m_hHandle, pszPath);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::DeleteChildKeys(
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;


    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        hresReturn = GetVariantString(pvaPath, pszPath);

        if (SUCCEEDED(hresReturn)) {
            hresReturn = m_padmcDcomInterface->DeleteChildKeys(m_hHandle, pszPath);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::EnumKeys(
        /* [out] */ VARIANTARG __RPC_FAR *pvaName,
        /* [in] */ long dwEnumObjectIndex,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;
    BYTE pszName[METADATA_MAX_NAME_LEN];

    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        hresReturn = GetVariantString(pvaPath, pszPath);

        if (SUCCEEDED(hresReturn)) {
            if (pvaName == NULL) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }
        }
        if (SUCCEEDED(hresReturn)) {

            hresReturn = m_padmcDcomInterface->EnumKeys(m_hHandle, pszPath, pszName, dwEnumObjectIndex);
            if (SUCCEEDED(hresReturn)) {
                hresReturn = SetVariantString(pvaName, pszName);
            }
        }
    }

    return hresReturn;
}

//HRESULT STDMETHODCALLTYPE
//CMSMetaBase::GetDataObject(
//    /* [out] */ IMSMetaDataItem __RPC_FAR *__RPC_FAR *ppmdiData)
///* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
//CMSMetaBase::get_GetDataObject(
//    /* [retval][out] */ IMSMetaDataItem __RPC_FAR *__RPC_FAR *ppmdiData)

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaKey::get_DataItem(
        /* [retval][out] */ IMSMetaDataItem __RPC_FAR *__RPC_FAR *ppmdiData)
{
    HRESULT hresReturn;

    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        CMSMetaDataItem *padmadData = new CMSMetaDataItem(m_pITIData);
        if (padmadData == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            hresReturn = padmadData->QueryInterface(IID_IMSMetaDataItem, (void **)ppmdiData);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::SetData(
        /* [in] */ IMSMetaDataItem __RPC_FAR *pmdiData,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;

    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        if (pmdiData == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        }

        if (SUCCEEDED(hresReturn)) {

            hresReturn = GetVariantString(pvaPath, pszPath);

        }

        if (SUCCEEDED(hresReturn)) {
            METADATA_RECORD *pmdrData = ((CMSMetaDataItem *)pmdiData)->GetMDRecord();
            hresReturn = m_padmcDcomInterface->SetData(m_hHandle,
                                                                 pszPath,
                                                                 pmdrData);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::GetData(
        /* [in][out] */ IMSMetaDataItem __RPC_FAR *__RPC_FAR *ppmdiData,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;

    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        if (*ppmdiData == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        }

        if (SUCCEEDED(hresReturn)) {

            hresReturn = GetVariantString(pvaPath, pszPath);

        }

        if (SUCCEEDED(hresReturn)) {
            METADATA_RECORD *pmdrInput = ((CMSMetaDataItem *)(*ppmdiData))->GetMDRecord();
            METADATA_RECORD mdrData = *pmdrInput;
            BUFFER bufData;
            DWORD dwDataLen;

            mdrData.dwMDDataLen = bufData.QuerySize();
            mdrData.pbMDData = (BYTE *) (bufData.QueryPtr());

            hresReturn = m_padmcDcomInterface->GetData(m_hHandle,
                                                                 pszPath,
                                                                 &mdrData,
                                                                 &dwDataLen);
            if (hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
                if (!(bufData.Resize(dwDataLen))) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    mdrData.dwMDDataLen = bufData.QuerySize();
                    mdrData.pbMDData = (BYTE *) (bufData.QueryPtr());

                    hresReturn = m_padmcDcomInterface->GetData(m_hHandle,
                                                                         pszPath,
                                                                         &mdrData,
                                                                         &dwDataLen);
                }
            }
            if (SUCCEEDED(hresReturn)) {
                hresReturn = ((CMSMetaDataItem *)(*ppmdiData))->SetMDRecord(&mdrData);

            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::DeleteData(
        /* [in] */ long dwIdentifier,
        /* [in] */ long dwDataType,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;


    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        hresReturn = GetVariantString(pvaPath, pszPath);

        if (SUCCEEDED(hresReturn)) {
            hresReturn = m_padmcDcomInterface->DeleteData(m_hHandle,
                                                                    pszPath,
                                                                    dwIdentifier,
                                                                    dwDataType);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::EnumData(
        /* [out][in] */ IMSMetaDataItem __RPC_FAR *__RPC_FAR *ppmdiData,
        /* [in] */ long dwEnumDataIndex,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;

    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        if (*ppmdiData == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        }

        if (SUCCEEDED(hresReturn)) {

            hresReturn = GetVariantString(pvaPath, pszPath);

        }

        if (SUCCEEDED(hresReturn)) {
            METADATA_RECORD *pmdrInput = ((CMSMetaDataItem *)(*ppmdiData))->GetMDRecord();
            METADATA_RECORD mdrData = *pmdrInput;
            BUFFER bufData;
            DWORD dwDataLen;

            mdrData.dwMDDataLen = bufData.QuerySize();
            mdrData.pbMDData = (BYTE *) (bufData.QueryPtr());

            hresReturn = m_padmcDcomInterface->EnumData(m_hHandle,
                                                                 pszPath,
                                                                 &mdrData,
                                                                 dwEnumDataIndex,
                                                                 &dwDataLen);
            if (hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
                if (!(bufData.Resize(dwDataLen))) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    mdrData.dwMDDataLen = bufData.QuerySize();
                    mdrData.pbMDData = (BYTE *) (bufData.QueryPtr());

                    hresReturn = m_padmcDcomInterface->EnumData(m_hHandle,
                                                                         pszPath,
                                                                         &mdrData,
                                                                         dwEnumDataIndex,
                                                                         &dwDataLen);
                }
            }
            if (SUCCEEDED(hresReturn)) {
                hresReturn = ((CMSMetaDataItem *)(*ppmdiData))->SetMDRecord(&mdrData);

            }
        }
    }


    return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CMSMetaKey::GetAllData(
        /* [in] */ long dwAttributes,
        /* [in] */ long dwUserType,
        /* [in] */ long dwDataType,
        /* [out] */ long __RPC_FAR *pdwDataSetNumber,
        /* [out] */ VARIANTARG __RPC_FAR *pvaDataObjectsArray,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;

    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        if (pvaDataObjectsArray == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        }

        if (SUCCEEDED(hresReturn)) {

            hresReturn = GetVariantString(pvaPath, pszPath);

        }

        if (SUCCEEDED(hresReturn)) {
            BUFFER bufData;
            DWORD dwNumDataEntries;
            DWORD dwRequiredBufferLen;

            hresReturn = m_padmcDcomInterface->GetAllData(m_hHandle,
                                                                 pszPath,
                                                                 (DWORD) dwAttributes,
                                                                 (DWORD) dwUserType,
                                                                 (DWORD) dwDataType,
                                                                 &dwNumDataEntries,
                                                                 (DWORD *)pdwDataSetNumber,
                                                                 bufData.QuerySize(),
                                                                 (BYTE *)bufData.QueryPtr(),
                                                                 &dwRequiredBufferLen);

            if (hresReturn == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
                if (!(bufData.Resize(dwRequiredBufferLen))) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    hresReturn = m_padmcDcomInterface->GetAllData(m_hHandle,
                                                                         pszPath,
                                                                         (DWORD) dwAttributes,
                                                                         (DWORD) dwUserType,
                                                                         (DWORD) dwDataType,
                                                                         &dwNumDataEntries,
                                                                         (DWORD *)pdwDataSetNumber,
                                                                         bufData.QuerySize(),
                                                                         (BYTE *)bufData.QueryPtr(),
                                                                         &dwRequiredBufferLen);
                }
            }
            if (SUCCEEDED(hresReturn)) {

                SAFEARRAYBOUND sabBounds;
                SAFEARRAY *psaDataObjects;

                CMSMetaDataItem **ppadmadDataObjects;
                METADATA_GETALL_RECORD *pmdgarDataEntries = (METADATA_GETALL_RECORD *)bufData.QueryPtr();

                sabBounds.cElements = dwNumDataEntries;
                sabBounds.lLbound = 0;

                psaDataObjects = SafeArrayCreate(VT_DISPATCH, 1, &sabBounds);

                if (psaDataObjects == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    hresReturn = SafeArrayAccessData(psaDataObjects, (void **)&ppadmadDataObjects);
                    if (SUCCEEDED(hresReturn)) {
                        DWORD i;
                        CMSMetaDataItem *padmadNew;
                        for (i = 0; i < dwNumDataEntries; i++ ) {
                            padmadNew = new CMSMetaDataItem(m_pITIData);
                            if (padmadNew == NULL) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                break;
                            }

                            hresReturn = padmadNew->SetMDGetAllRecord((BYTE *)bufData.QueryPtr(), (&pmdgarDataEntries[i]));

                            if (FAILED(hresReturn)) {
                                break;
                            }
                            hresReturn = padmadNew->QueryInterface(IID_IMSMetaDataItem, (void **)&(ppadmadDataObjects[i]));

                            if (FAILED(hresReturn)) {
                                delete padmadNew;
                                break;
                            }
                        }

                        if (FAILED(hresReturn)) {
                            for (DWORD j = 0; j < i; j++) {
                                ppadmadDataObjects[j]->Release();
                            }
                        }

                        SafeArrayUnaccessData(psaDataObjects);

                        if (FAILED(hresReturn)) {
                            SafeArrayDestroy(psaDataObjects);
                        }
                        else {
                            pvaDataObjectsArray->vt = VT_ARRAY | VT_DISPATCH;
                            pvaDataObjectsArray->parray = psaDataObjects;
                        }
                    }
                }
            }
        }
    }


    return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CMSMetaKey::DeleteAllData(
        /* [in] */ long dwUserType,
        /* [in] */ long dwDataType,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;


    //DebugBreak();

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        hresReturn = GetVariantString(pvaPath, pszPath);

        if (SUCCEEDED(hresReturn)) {
            hresReturn = m_padmcDcomInterface->DeleteAllData(m_hHandle,
                                                                    pszPath,
                                                                    dwUserType,
                                                                    dwDataType);
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::OpenKey(
            /* [in] */ long dwAccessRequested,
            /* [optional][in] */ VARIANTARG vaTimeOut,
            /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath,
            /* [retval][out] */ IMSMetaKey __RPC_FAR *__RPC_FAR *ppmkKey)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;
    METADATA_HANDLE hNew;
    DWORD dwTimeOut;


    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
    //DebugBreak();
        hresReturn = GetVariantString(pvaPath, pszPath);

        if (SUCCEEDED(hresReturn)) {
            hresReturn = GetVariantDword(&vaTimeOut, dwTimeOut, ADM_DEFAULT_TIMEOUT);
        }


        if (SUCCEEDED(hresReturn)) {
            hresReturn = m_padmcDcomInterface->OpenKey(m_hHandle,
                                                                    pszPath,
                                                                    dwAccessRequested,
                                                                    dwTimeOut,
                                                                    &hNew);

            if (SUCCEEDED(hresReturn)) {
                IMSMetaKey *pmkKey = new CMSMetaKey(m_pITIKey,
                                                    m_pITIData,
                                                    hNew,
                                                    m_padmcDcomInterface,
                                                    m_pmbMetaBase);
                if (pmkKey == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    hresReturn = pmkKey->QueryInterface(IID_IMSMetaKey, (void **)ppmkKey);
                }
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::Close(void)
{
    HRESULT hresReturn = ERROR_SUCCESS;


    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        hresReturn = m_padmcDcomInterface->CloseKey(m_hHandle);
        if (SUCCEEDED(hresReturn)) {
            m_bOpen = FALSE;
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::ChangePermissions(
            /* [in] */ long dwAccessRequested,
            /* [optional][in] */ VARIANTARG vaTimeOut)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD dwTimeOut;


    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
    //DebugBreak();
        hresReturn = GetVariantDword(&vaTimeOut, dwTimeOut, ADM_DEFAULT_TIMEOUT);

        hresReturn = m_padmcDcomInterface->ChangePermissions(m_hHandle,
                                                                   dwTimeOut,
                                                                   dwAccessRequested);
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::GetKeyInfo(
        /* [out] */ long __RPC_FAR *dwPermissions,
        /* [out] */ long __RPC_FAR *dwSystemChangeNumber)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    METADATA_HANDLE_INFO mhiInfo;


    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
    //DebugBreak();
        hresReturn = m_padmcDcomInterface->GetHandleInfo(m_hHandle,
                                                               &mhiInfo);
        if (SUCCEEDED(hresReturn)) {
            *(DWORD *)dwPermissions = mhiInfo.dwMDPermissions;
            *(DWORD *)dwSystemChangeNumber = mhiInfo.dwMDSystemChangeNumber;
        }
    }

    return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CMSMetaKey::GetDataSetNumber(
        /* [out] */ long __RPC_FAR *pdwDataSetNumber,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;


    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
    //DebugBreak();

        if (pdwDataSetNumber == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        }
        else {

            hresReturn = GetVariantString(pvaPath, pszPath);

            if (SUCCEEDED(hresReturn)) {
                hresReturn = m_padmcDcomInterface->GetDataSetNumber(m_hHandle,
                                                                        pszPath,
                                                                        (DWORD *)pdwDataSetNumber);
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::SetLastChangeTime(
        /* [in] */ DATE dLastChangeTime,
        /* [optional][in] */ VARIANTARG vaLocalTime,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;
    BOOL bLocalTime = TRUE;

    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        if (SUCCEEDED(VariantChangeType(&vaLocalTime,
                                    &vaLocalTime,
                                    0,
                                    VT_BOOL))) {
            bLocalTime = vaLocalTime.boolVal;
        }
        //DebugBreak();

        hresReturn = GetVariantString(pvaPath, pszPath);

        if (SUCCEEDED(hresReturn)) {
            FILETIME ftTime;
            SYSTEMTIME stTime;
            if (!VariantTimeToSystemTime(dLastChangeTime,&stTime)) {
                hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }
            else if (!SystemTimeToFileTime(&stTime, &ftTime)) {
                hresReturn = E_UNEXPECTED;
            }
            else {
                hresReturn = m_padmcDcomInterface->SetLastChangeTime(m_hHandle,
                                                                           pszPath,
                                                                           &ftTime,
                                                                           bLocalTime);
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMSMetaKey::GetLastChangeTime(
        /* [out] */ DATE __RPC_FAR *pdLastChangeTime,
        /* [optional][in] */ VARIANTARG vaLocalTime,
        /* [optional][in] */ VARIANTARG __RPC_FAR *pvaPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    BYTE *pszPath;
    BOOL bLocalTime = TRUE;


    if (!m_bOpen) {
        hresReturn = E_HANDLE;
    }
    else {
        if (SUCCEEDED(VariantChangeType(&vaLocalTime,
                                    &vaLocalTime,
                                    0,
                                    VT_BOOL))) {
            bLocalTime = vaLocalTime.boolVal;
        }

        hresReturn = GetVariantString(pvaPath, pszPath);

        if (SUCCEEDED(hresReturn)) {
            FILETIME ftTime;
            SYSTEMTIME stTime;

            hresReturn = m_padmcDcomInterface->GetLastChangeTime(m_hHandle,
                                                                       pszPath,
                                                                       &ftTime,
                                                                       bLocalTime);
            if (SUCCEEDED(hresReturn)) {
                if (!FileTimeToSystemTime(&ftTime, &stTime)) {
                    hresReturn = E_UNEXPECTED;
                }
                else if (!SystemTimeToVariantTime(&stTime, pdLastChangeTime)) {
                    hresReturn = E_UNEXPECTED;
                }
            }
        }
    }

    return hresReturn;
}

HRESULT _stdcall
CMSMetaKey::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IMSMetaKey || riid==IID_IDispatch) {
        *ppObject = (IMSMetaKey *) this;
        AddRef();
    }
    else {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

ULONG _stdcall
CMSMetaKey::AddRef()
{
    DWORD dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    return dwRefCount;
}

ULONG _stdcall
CMSMetaKey::Release()
{
    DWORD dwRefCount;

    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);

    if (dwRefCount == 0) {
        delete (this);
    }

    return dwRefCount;
}

//IDispatch members

//IDispatch functions, now part of CMDCOM

/*
 * CMDCOM::GetTypeInfoCount
 *
 * Purpose:
 *  Returns the number of type information (ITypeInfo) interfaces
 *  that the object provides (0 or 1).
 *
 * Parameters:
 *  pctInfo         UINT * to the location to receive
 *                  the count of interfaces.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaKey::GetTypeInfoCount(UINT *pctInfo)
    {
    //We implement GetTypeInfo so return 1
    *pctInfo=1;
    return NOERROR;
    }

/*
 * CMDCOM::GetTypeInfo
 *
 * Purpose:
 *  Retrieves type information for the automation interface.  This
 *  is used anywhere that the right ITypeInfo interface is needed
 *  for whatever LCID is applicable.  Specifically, this is used
 *  from within GetIDsOfNames and Invoke.
 *
 * Parameters:
 *  itInfo          UINT reserved.  Must be zero.
 *  lcid            LCID providing the locale for the type
 *                  information.  If the object does not support
 *                  localization, this is ignored.
 *  ppITypeInfo     ITypeInfo ** in which to store the ITypeInfo
 *                  interface for the object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaKey::GetTypeInfo(UINT itInfo, LCID lcid
    , ITypeInfo **ppITypeInfo)
    {
    HRESULT     hr;
    ITypeLib   *pITypeLib;
    ITypeInfo **ppITI=NULL;

    if (0!=itInfo)
        return ResultFromScode(TYPE_E_ELEMENTNOTFOUND);

    if (NULL==ppITypeInfo)
        return ResultFromScode(E_POINTER);

    m_pITIKey->AddRef();
    *ppITypeInfo = m_pITIKey;
    return NOERROR;
    }

/*
 * CMDCOM::GetIDsOfNames
 *
 * Purpose:
 *  Converts text names into DISPIDs to pass to Invoke
 *
 * Parameters:
 *  riid            REFIID reserved.  Must be IID_NULL.
 *  rgszNames       OLECHAR ** pointing to the array of names to be
 *                  mapped.
 *  cNames          UINT number of names to be mapped.
 *  lcid            LCID of the locale.
 *  rgDispID        DISPID * caller allocated array containing IDs
 *                  corresponging to those names in rgszNames.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaKey::GetIDsOfNames(REFIID riid
    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    HRESULT     hr;
    ITypeInfo  *pTI;

    if (IID_NULL!=riid)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    //Get the right ITypeInfo for lcid.
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
        {
        hr=DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
        pTI->Release();
        }

    return hr;
}


/*
 * CMDCOM::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaKey::Invoke(DISPID dispID, REFIID riid
    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams
    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
    {
    HRESULT     hr;

    //riid is supposed to be IID_NULL always
    if (IID_NULL!=riid)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    //Clear exceptions
    SetErrorInfo(0L, NULL);

    //This is exactly what DispInvoke does--so skip the overhead.
//    hr=pTI->Invoke((IADMCOM *)this, dispID, wFlags
//        , pDispParams, pVarResult, pExcepInfo, puArgErr);
    hr=DispInvoke((IMSMetaKey *)this, m_pITIKey, dispID, wFlags
        , pDispParams, pVarResult, pExcepInfo, puArgErr);

    //Exception handling is done within ITypeInfo::Invoke

    return hr;
    }


CMSMetaDataItem::CMSMetaDataItem(ITypeInfo   *pITIData)
{
    m_mdrData.dwMDIdentifier = 0;
    m_mdrData.dwMDAttributes = 0;
    m_mdrData.dwMDDataType = ALL_METADATA;
    m_mdrData.dwMDUserType = ALL_METADATA;
    m_mdrData.pbMDData = NULL;
    m_pITIData = pITIData;
    m_pITIData->AddRef();
//    m_psaData = NULL;
//    m_dwData = 0;
}

CMSMetaDataItem::~CMSMetaDataItem()
{
    m_pITIData->Release();
}

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::get_Identifier(
    /* [out] */ long __RPC_FAR *pdwIdentifier)
{
    HRESULT hresReturn = ERROR_SUCCESS;


    //DebugBreak();
    if (pdwIdentifier == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        *pdwIdentifier = m_mdrData.dwMDIdentifier;
    }

    return hresReturn;
}

/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::put_Identifier(
    /* [in] */ long dwIdentifier)
{
    //DebugBreak();
    m_mdrData.dwMDIdentifier = dwIdentifier;

    return ERROR_SUCCESS;
}

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::get_Attributes(
    /* [out] */ long __RPC_FAR *pdwAttributes)
{
    HRESULT hresReturn = ERROR_SUCCESS;


    //DebugBreak();
    if (pdwAttributes == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        *pdwAttributes = m_mdrData.dwMDAttributes;
    }

    return hresReturn;
}

/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::put_Attributes(
    /* [in] */ long dwAttributes)
{
    //DebugBreak();
    m_mdrData.dwMDAttributes = dwAttributes;

    return ERROR_SUCCESS;
}

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::get_InheritAttribute(
    /* [retval][out] */ BOOL __RPC_FAR *pbInherit)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (pbInherit == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        if ((m_mdrData.dwMDAttributes & METADATA_INHERIT) == 0) {
            *pbInherit = FALSE;
        }
        else {
            *pbInherit = TRUE;
        }
    }
    return hresReturn;
}

/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::put_InheritAttribute(
    /* [in] */ BOOL bInherit)
{
    if (bInherit) {
        m_mdrData.dwMDAttributes |= METADATA_INHERIT;
    }
    else {
        m_mdrData.dwMDAttributes &= !METADATA_INHERIT;
    }
    return ERROR_SUCCESS;
}

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::get_ParialPathAttribute(
    /* [retval][out] */ BOOL __RPC_FAR *pbParialPath)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (pbParialPath == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        if ((m_mdrData.dwMDAttributes & METADATA_PARTIAL_PATH) == 0) {
            *pbParialPath = FALSE;
        }
        else {
            *pbParialPath = TRUE;
        }
    }
    return hresReturn;
}

/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::put_PartialPathAttribute(
    /* [in] */ BOOL bPartialPath)
{
    if (bPartialPath) {
        m_mdrData.dwMDAttributes |= METADATA_PARTIAL_PATH;
    }
    else {
        m_mdrData.dwMDAttributes &= !METADATA_PARTIAL_PATH;
    }
    return ERROR_SUCCESS;
}

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::get_SecureAttribute(
    /* [retval][out] */ BOOL __RPC_FAR *pbSecure)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (pbSecure == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        if ((m_mdrData.dwMDAttributes & METADATA_SECURE) == 0) {
            *pbSecure = FALSE;
        }
        else {
            *pbSecure = TRUE;
        }
    }
    return hresReturn;
}

/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::put_SecureAttribute(
    /* [in] */ BOOL bSecure)
{
    if (bSecure) {
        m_mdrData.dwMDAttributes |= METADATA_SECURE;
    }
    else {
        m_mdrData.dwMDAttributes &= !METADATA_SECURE;
    }
    return ERROR_SUCCESS;
}

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::get_ReferenceAttribute(
    /* [retval][out] */ BOOL __RPC_FAR *pbReference)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (pbReference == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        if ((m_mdrData.dwMDAttributes & METADATA_REFERENCE) == 0) {
            *pbReference = FALSE;
        }
        else {
            *pbReference = TRUE;
        }
    }
    return hresReturn;
}

/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::put_ReferenceAttribute(
    /* [in] */ BOOL bReference)
{
    if (bReference) {
        m_mdrData.dwMDAttributes |= METADATA_REFERENCE;
    }
    else {
        m_mdrData.dwMDAttributes &= !METADATA_REFERENCE;
    }
    return ERROR_SUCCESS;
}

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::get_UserType(
    /* [out] */ long __RPC_FAR *pdwUserType)
{
    HRESULT hresReturn = ERROR_SUCCESS;


    //DebugBreak();
    if (pdwUserType == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        *pdwUserType = m_mdrData.dwMDUserType;
    }

    return hresReturn;
}

/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::put_UserType(
    /* [in] */ long dwUserType)
{
    //DebugBreak();
    m_mdrData.dwMDUserType = dwUserType;

    return ERROR_SUCCESS;
}

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::get_DataType(
    /* [out] */ long __RPC_FAR *pdwDataType)
{
    HRESULT hresReturn = ERROR_SUCCESS;


    //DebugBreak();
    if (pdwDataType == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        *pdwDataType = m_mdrData.dwMDDataType;
    }

    return hresReturn;
}

/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::put_DataType(
    /* [in] */ LONG dwDataType)
{
    //DebugBreak();
    m_mdrData.dwMDDataType = (DWORD)dwDataType;

    return ERROR_SUCCESS;
}

///* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
//CMSMetaDataItem::get_GetDataLen(
//    /* [retval][out] */ long __RPC_FAR *pdwMDDataLen)
/*
{
    HRESULT hresReturn = ERROR_SUCCESS;

    //DebugBreak();
    if (pdwMDDataLen == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        *pdwMDDataLen = m_mdrData.dwMDDataLen;
    }

    return hresReturn;
}
*/

///* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
//CMSMetaDataItem::put_SetDataLen(
//    /* [in] */ long dwMDDataLen)
/*
{
    //DebugBreak();
    m_mdrData.dwMDDataLen = dwMDDataLen;

    return ERROR_SUCCESS;
}
*/

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::get_Value(
    /* [retval][out] */ VARIANTARG __RPC_FAR *pvaData)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    //DebugBreak();

    if (pvaData == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else if (m_mdrData.pbMDData == NULL) {
        //
        // Data not set
        //
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
    }
    else {
        switch (m_mdrData.dwMDDataType) {
        case DWORD_METADATA:
            {
                if (m_mdrData.dwMDDataLen != sizeof(DWORD)) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                }
                else {
                    pvaData->vt = VT_I4;
                    pvaData->lVal = *(long *) m_mdrData.pbMDData;
                }
/*
                m_vaData.vt = VT_I4;
                m_vaData.lVal = m_dwData;
*/
            }
            break;
        case STRING_METADATA:
        case BINARY_METADATA:
        case MULTISZ_METADATA:
        case EXPANDSZ_METADATA:
            {
                SAFEARRAYBOUND sabBounds;
                SAFEARRAY *psaData;
                BYTE *pbData;
                sabBounds.cElements = m_mdrData.dwMDDataLen;
                sabBounds.lLbound = 0;

                psaData = SafeArrayCreate(VT_I1, 1, &sabBounds);
                if (psaData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    hresReturn = SafeArrayAccessData(psaData, (void **)&pbData);
                }
                if (SUCCEEDED(hresReturn)) {
                    memcpy(pbData, m_mdrData.pbMDData, m_mdrData.dwMDDataLen);
                    pvaData->vt = VT_ARRAY | VT_UI1;
                    pvaData->parray = psaData;
                    SafeArrayUnaccessData(psaData);
                }

/*
                m_vaData.vt = VT_ARRAY | VT_UI1;
                m_vaData.parray = m_psaData;
*/

            }
            break;
        default:
            {
                hresReturn = RETURNCODETOHRESULT(MD_ERROR_NOT_INITIALIZED);
            }
            break;
        }
/*
        if (SUCCEEDED(hresReturn)) {
            pvaMDData = &m_vaData;
        }
*/
    }

    return hresReturn;
}

/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE
CMSMetaDataItem::put_Value(
    /* [in] */ VARIANTARG __RPC_FAR *pvaData)
{
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATATYPE);

    //DebugBreak();
/*
    if ((m_mdrData.dwMDDataType <= ALL_METADATA) ||
        (m_mdrData.dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = RETURNCODETOHRESULT(MD_ERROR_NOT_INITIALIZED);
    }
    else {
        if ((pvaMDData->vt & VT_ARRAY) != 0) {

            SAFEARRAY *psaInput;
            SAFEARRAY *psaOutput;

            if ((pvaMDData->vt & VT_BYREF) != 0) {
                psaInput = *(pvaMDData->pparray);
            }
            else {
                psaInput = (pvaMDData->parray);
            }

            if ((SafeArrayGetDim(psaInput) == 1) &&
                (SafeArrayGetElemsize(psaInput) == 1)) {
                //
                // byte array, good for all types except DWORD.
                //
                if ((m_mdrData.dwMDDataType == STRING_METADATA) ||
                    (m_mdrData.dwMDDataType == BINARY_METADATA) ||
                    (m_mdrData.dwMDDataType == MULTISZ_METADATA) ||
                    (m_mdrData.dwMDDataType == EXPANDSZ_METADATA)) {

                    hresReturn = SafeArrayCopy(psaInput, &psaOutput);
                    if (SUCCEEDED(hresReturn)) {
                        hresReturn = SafeArrayAccessData(psaOutput, (void **)&(m_mdrData.pbMDData));
                        if (SUCCEEDED(hresReturn)) {
                            SafeArrayUnaccessData(psaOutput);
                            if (m_psaData != NULL) {
                                SafeArrayDestroy(m_psaData);
                            }
                            long lLBound = 0;
                            long lUBound = 0;
                            hresReturn = SafeArrayGetLBound(psaOutput, 1, &lLBound);
                            hresReturn = SafeArrayGetUBound(psaOutput, 1, &lUBound);
                            m_mdrData.dwMDDataLen = (lUBound - lLBound) + 1;
                            m_psaData = psaOutput;
                        }
                        else {
                            SafeArrayDestroy(psaOutput);
                        }
                    }
*/
/*
                    SAFEARRAYBOUND sabBounds;
                    long lLBound = 0;
                    long lUBound = 0;
                    hresReturn = SafeArrayGetLBound(psaInput, 1, &lLBound);
                    hresReturn = SafeArrayGetUBound(psaInput, 1, &lUBound);
                    sabBounds.cElements = (lUBound - lLBound) + 1;
                    sabBounds.lLbound = 0;

                    if (m_psaData == NULL) {
                        m_psaData = SafeArrayCreate(VT_I1, 1, &sabBounds);
                        if (m_psaData == NULL) {
                            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        }
                    }
                    else {
                        hresReturn = SafeArrayRedim(m_psaData, &sabBounds);
                    }
                    void *pvInput;
                    void *pvOutput;
                    hresReturn = SafeArrayAccessData(m_psaData, &pvOutput);
                    hresReturn = SafeArrayAccessData(psaInput, &pvInput);
                    memcpy(pvOutput, pvInput, (lUBound - lLBound) + 1);
                    SafeArrayUnaccessData(m_psaData);
                    SafeArrayUnaccessData(psaInput);
*/
/*
                }
            }
        }
        else if (((pvaMDData->vt & 0xff) == VT_I4) || ((pvaMDData->vt & 0xff) == VT_UI4)) {
            if (m_mdrData.dwMDDataType == DWORD_METADATA) {
                if ((pvaMDData->vt & VT_BYREF) == 0) {
                    m_dwData = pvaMDData->ulVal;
                }
                else {
                    m_dwData = *(pvaMDData->pulVal);
                }
                m_mdrData.pbMDData = (BYTE *) &m_dwData;
                m_mdrData.dwMDDataLen = sizeof(DWORD);
                hresReturn = ERROR_SUCCESS;
            }
        }
        else if (((pvaMDData->vt & 0xff) == VT_I2) || ((pvaMDData->vt & 0xff) == VT_UI2)) {
            if (m_mdrData.dwMDDataType == DWORD_METADATA) {
                if ((pvaMDData->vt & VT_BYREF) == 0) {
                    m_dwData = pvaMDData->uiVal;
                }
                else {
                    m_dwData = *(pvaMDData->puiVal);
                }
                m_mdrData.pbMDData = (BYTE *) &m_dwData;
                m_mdrData.dwMDDataLen = sizeof(DWORD);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }
*/
    if ((m_mdrData.dwMDDataType > ALL_METADATA) &&
        (m_mdrData.dwMDDataType < INVALID_END_METADATA)) {

        BYTE *pbData;
        DWORD dwDataLen;

        if ((pvaData->vt & VT_ARRAY) != 0) {

            SAFEARRAY *psaInput;

            if ((pvaData->vt & VT_BYREF) != 0) {
                psaInput = *(pvaData->pparray);
            }
            else {
                psaInput = (pvaData->parray);
            }

            if ((SafeArrayGetDim(psaInput) == 1) &&
                (SafeArrayGetElemsize(psaInput) == 1)) {
                //
                // byte array, good for all types except DWORD.
                //
                if ((m_mdrData.dwMDDataType == STRING_METADATA) ||
                    (m_mdrData.dwMDDataType == BINARY_METADATA) ||
                    (m_mdrData.dwMDDataType == MULTISZ_METADATA) ||
                    (m_mdrData.dwMDDataType == EXPANDSZ_METADATA)) {
                    hresReturn = SafeArrayAccessData(psaInput, (void **)&pbData);
                    if (SUCCEEDED(hresReturn)) {
                        long lLBound = 0;
                        long lUBound = 0;
                        hresReturn = SafeArrayGetLBound(psaInput, 1, &lLBound);
                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SafeArrayGetUBound(psaInput, 1, &lUBound);
                        }
                        if (SUCCEEDED(hresReturn)) {
                            DWORD i;
                            dwDataLen = (lUBound - lLBound) + 1;
                            //
                            // Make sure a string has a '\0'
                            //
                            if ((m_mdrData.dwMDDataType == STRING_METADATA) ||
                                (m_mdrData.dwMDDataType == EXPANDSZ_METADATA)) {
                                for (i = 0; (i < dwDataLen) && (pbData[i] != (BYTE)'\0'); i++) {
                                }
                                if (i == dwDataLen) {
                                    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                                }
                            }
                            else if (m_mdrData.dwMDDataType == MULTISZ_METADATA) {
                                for (i = 0; (i < dwDataLen - 1); i++) {
                                    if ((pbData[i] == '\0') && (pbData[i+1]== (BYTE)'\0')) {
                                        break;
                                    }
                                }
                                if (i == dwDataLen - 1) {
                                    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_DATA);
                                }
                            }

                            if (SUCCEEDED(hresReturn)) {
                                if (!m_bufData.Resize(dwDataLen)) {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                                }
                                else {
                                    memcpy(m_bufData.QueryPtr(), pbData, dwDataLen);
                                }
                            }
                        }
                        SafeArrayUnaccessData(psaInput);
                    }
                }
            }
        }
        else if (((pvaData->vt & 0xff) == VT_I4) || ((pvaData->vt & 0xff) == VT_UI4)) {
            if (m_mdrData.dwMDDataType == DWORD_METADATA) {
                if ((pvaData->vt & VT_BYREF) == 0) {
                    *(DWORD *)(m_bufData.QueryPtr()) = pvaData->ulVal;
                }
                else {
                    *(DWORD *)(m_bufData.QueryPtr()) = *(pvaData->pulVal);
                }
                dwDataLen = sizeof(DWORD);
                hresReturn = ERROR_SUCCESS;
            }
        }
        else if (((pvaData->vt & 0xff) == VT_I2) || ((pvaData->vt & 0xff) == VT_UI2)) {
            if (m_mdrData.dwMDDataType == DWORD_METADATA) {
                if ((pvaData->vt & VT_BYREF) == 0) {
                    *(DWORD *)(m_bufData.QueryPtr()) = pvaData->uiVal;
                }
                else {
                    *(DWORD *)(m_bufData.QueryPtr()) = *(pvaData->puiVal);
                }
                dwDataLen = sizeof(DWORD);
                hresReturn = ERROR_SUCCESS;
            }
        }
        if (SUCCEEDED(hresReturn)) {
            m_mdrData.pbMDData = (BYTE *)m_bufData.QueryPtr();
            m_mdrData.dwMDDataLen = dwDataLen;
        }

    }
    return hresReturn;
}


METADATA_RECORD *
CMSMetaDataItem::GetMDRecord()
{
    return &m_mdrData;
}


HRESULT
CMSMetaDataItem::SetMDGetAllRecord(BYTE *pbBase, METADATA_GETALL_RECORD *pmdgarData)
{
    METADATA_RECORD mdrData;
    mdrData.dwMDIdentifier = pmdgarData->dwMDIdentifier;
    mdrData.dwMDAttributes = pmdgarData->dwMDAttributes;
    mdrData.dwMDUserType = pmdgarData->dwMDUserType;
    mdrData.dwMDDataType = pmdgarData->dwMDDataType;
    mdrData.dwMDDataLen = pmdgarData->dwMDDataLen;
    mdrData.pbMDData = pbBase + pmdgarData->dwMDDataOffset;
    return SetMDRecord(&mdrData);
}


HRESULT
CMSMetaDataItem::SetMDRecord(METADATA_RECORD *pmdrData)
{
    HRESULT hresReturn = ERROR_SUCCESS;

    if (!m_bufData.Resize(pmdrData->dwMDDataLen)) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        m_mdrData = *pmdrData;
        memcpy(m_bufData.QueryPtr(), m_mdrData.pbMDData, m_mdrData.dwMDDataLen);
        m_mdrData.pbMDData = (BYTE *)m_bufData.QueryPtr();
    }
/*
    if (m_mdrData.dwMDDataType == DWORD_METADATA) {
        m_dwData = *(DWORD *)m_mdrData.pbMDData;
        m_mdrData.pbMDData = (BYTE *)&m_dwData;
    }
    else {
        SAFEARRAY *psaNew;
        SAFEARRAYBOUND sabBounds;
        sabBounds.cElements = m_mdrData.dwMDDataLen;
        sabBounds.lLbound = 0;
        psaNew = SafeArrayCreate(VT_I1, 1, &sabBounds);
        if (psaNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            hresReturn = SafeArrayAccessData(psaNew, (void **)&(m_mdrData.pbMDData));
            if (SUCCEEDED(hresReturn)) {
                if (m_psaData != NULL) {
                    SafeArrayUnaccessData(m_psaData);
                    SafeArrayDestroy(m_psaData);
                }
                memcpy(m_mdrData.pbMDData, pmdrData->pbMDData, m_mdrData.dwMDDataLen);
                m_psaData = psaNew;
            }
            else {
                SafeArrayDestroy(psaNew);
            }
        }
    }
*/
    return hresReturn;

}




HRESULT _stdcall
CMSMetaDataItem::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IMSMetaDataItem || riid==IID_IDispatch) {
        *ppObject = (IMSMetaDataItem *) this;
        AddRef();
    }
    else {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

ULONG _stdcall
CMSMetaDataItem::AddRef()
{
    DWORD dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    return dwRefCount;
}

ULONG _stdcall
CMSMetaDataItem::Release()
{
    DWORD dwRefCount;

    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);

    if (dwRefCount == 0) {
        delete (this);
    }

    return dwRefCount;
}

//IDispatch members

//IDispatch functions, now part of CMDCOM

/*
 * CMDCOM::GetTypeInfoCount
 *
 * Purpose:
 *  Returns the number of type information (ITypeInfo) interfaces
 *  that the object provides (0 or 1).
 *
 * Parameters:
 *  pctInfo         UINT * to the location to receive
 *                  the count of interfaces.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaDataItem::GetTypeInfoCount(UINT *pctInfo)
    {
    //We implement GetTypeInfo so return 1
    *pctInfo=1;
    return NOERROR;
    }

/*
 * CMDCOM::GetTypeInfo
 *
 * Purpose:
 *  Retrieves type information for the automation interface.  This
 *  is used anywhere that the right ITypeInfo interface is needed
 *  for whatever LCID is applicable.  Specifically, this is used
 *  from within GetIDsOfNames and Invoke.
 *
 * Parameters:
 *  itInfo          UINT reserved.  Must be zero.
 *  lcid            LCID providing the locale for the type
 *                  information.  If the object does not support
 *                  localization, this is ignored.
 *  ppITypeInfo     ITypeInfo ** in which to store the ITypeInfo
 *                  interface for the object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaDataItem::GetTypeInfo(UINT itInfo, LCID lcid
    , ITypeInfo **ppITypeInfo)
    {
    HRESULT     hr;
    ITypeLib   *pITypeLib;
    ITypeInfo **ppITI=NULL;

    if (0!=itInfo)
        return ResultFromScode(TYPE_E_ELEMENTNOTFOUND);

    if (NULL==ppITypeInfo)
        return ResultFromScode(E_POINTER);

    m_pITIData->AddRef();
    *ppITypeInfo = m_pITIData;
    return NOERROR;
    }

/*
 * CMDCOM::GetIDsOfNames
 *
 * Purpose:
 *  Converts text names into DISPIDs to pass to Invoke
 *
 * Parameters:
 *  riid            REFIID reserved.  Must be IID_NULL.
 *  rgszNames       OLECHAR ** pointing to the array of names to be
 *                  mapped.
 *  cNames          UINT number of names to be mapped.
 *  lcid            LCID of the locale.
 *  rgDispID        DISPID * caller allocated array containing IDs
 *                  corresponging to those names in rgszNames.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaDataItem::GetIDsOfNames(REFIID riid
    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    HRESULT     hr;
    ITypeInfo  *pTI;

    if (IID_NULL!=riid)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    //Get the right ITypeInfo for lcid.
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
        {
        hr=DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
        pTI->Release();
        }

    return hr;
}


/*
 * CMDCOM::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */
STDMETHODIMP
CMSMetaDataItem::Invoke(DISPID dispID, REFIID riid
    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams
    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
    {
    HRESULT     hr;

    //riid is supposed to be IID_NULL always
    if (IID_NULL!=riid)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    //Clear exceptions
    SetErrorInfo(0L, NULL);

    //This is exactly what DispInvoke does--so skip the overhead.
//    hr=pTI->Invoke((IADMCOM *)this, dispID, wFlags
//        , pDispParams, pVarResult, pExcepInfo, puArgErr);
    hr=DispInvoke((IMSMetaDataItem *)this, m_pITIData, dispID, wFlags
        , pDispParams, pVarResult, pExcepInfo, puArgErr);

    //Exception handling is done within ITypeInfo::Invoke

    return hr;
    }

/*
 * RaiseException
 *
 * Parameters:
 *  nID                 Error number
 *  rguid               GUID of interface that is raising the exception.
 *
 * Return Value:
 *  HRESULT correspnding to the nID error number.
 *
 * Purpose:
 *  Fills the EXCEPINFO structure.
 *  Sets ErrorInfo object for vtable-binding controllers.
 *  For id-binding and late binding controllers DispInvoke
 *  will return DISP_E_EXCEPTION and fill the EXCEPINFO parameter
 *  with the error information set by SetErrorInfo.
 *
 */
/*
HRESULT RaiseException(int nID, REFGUID rguid)
{
    extern SCODE g_scodes[];
//    TCHAR szError[STR_LEN];
    ICreateErrorInfo *pcerrinfo;
    IErrorInfo *perrinfo;
    HRESULT hr;
    BSTR bstrDescription = NULL;

//    if (LoadString(g_pApplication->m_hinst, nID, szError, sizeof(szError)))
//        bstrDescription = SysAllocString(TO_OLE_STRING(szError));

    // Set ErrorInfo object so that vtable binding controller can get
    // rich error information. If the controller is using IDispatch
    // to access properties or methods, DispInvoke will fill the
    // EXCEPINFO structure using the values specified in the ErrorInfo
    // object and DispInvoke will return DISP_E_EXCEPTION. The property
    // or method must return a failure SCODE for DispInvoke to do this.
    hr = CreateErrorInfo(&pcerrinfo);
    if (SUCCEEDED(hr))
    {
       pcerrinfo->SetGUID(rguid);
//       pcerrinfo->SetSource(g_pApplication->m_bstrProgID);
       pcerrinfo->SetSource(NULL);
       if (bstrDescription)
           pcerrinfo->SetDescription(bstrDescription);
       hr = pcerrinfo->QueryInterface(IID_IErrorInfo, (LPVOID FAR*) &perrinfo);
       if (SUCCEEDED(hr))
       {
          SetErrorInfo(0, perrinfo);
          perrinfo->Release();
       }
       pcerrinfo->Release();
    }

    if (bstrDescription)
        SysFreeString(bstrDescription);
    return ResultFromScode(nID);
}
*/


HRESULT
GetVariantDword(VARIANTARG *pvaData, DWORD &rdwData, DWORD dwDefault)
{
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    rdwData = dwDefault;

    if ((pvaData == NULL) || (pvaData->vt == VT_ERROR)) {
        //
        // if optional path is not specified
        // type comes in as VT_ERROR
        //
        hresReturn = ERROR_SUCCESS;
    }
    else {
        hresReturn = VariantChangeType(pvaData,
                                       pvaData,
                                       0,
                                       VT_UI4);
        if (SUCCEEDED(hresReturn)) {
            rdwData = pvaData->ulVal;
        }

    }

    return hresReturn;

}



HRESULT
GetVariantString(VARIANTARG *pvaPath, BYTE *&rpszPath)
{
    HRESULT hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    rpszPath = NULL;

    if ((pvaPath == NULL) || (pvaPath->vt == VT_ERROR)) {
        //
        // if optional path is not specified
        // type comes in as VT_ERROR
        //
        hresReturn = ERROR_SUCCESS;
    }
    else if ((pvaPath->vt & VT_ARRAY) != 0) {

        SAFEARRAY *psaPath;

        if ((pvaPath->vt & VT_BYREF) != 0) {
            psaPath = *(pvaPath->pparray);
        }
        else {
            psaPath = (pvaPath->parray);
        }

        if ((SafeArrayGetDim(psaPath) == 1) &&
        (SafeArrayGetElemsize(psaPath) == 1)) {
            hresReturn = SafeArrayAccessData(psaPath, (void **) &rpszPath);
            if (SUCCEEDED(hresReturn)) {
                SafeArrayUnaccessData(psaPath);
            }
        }
    }

    return hresReturn;

}


HRESULT
SetVariantString(VARIANTARG *pvaString, BYTE *pszString)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    SAFEARRAYBOUND sabBounds;
    SAFEARRAY *psaString;
    BYTE *pbString;
    DWORD dwStringLen = strlen((LPSTR)pszString) + 1;

    sabBounds.cElements = dwStringLen;
    sabBounds.lLbound = 0;

    psaString = SafeArrayCreate(VT_I1, 1, &sabBounds);
    if (psaString == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        hresReturn = SafeArrayAccessData(psaString, (void **)&pbString);
    }
    if (SUCCEEDED(hresReturn)) {
        memcpy(pbString, pszString, dwStringLen);
        pvaString->vt = VT_ARRAY | VT_UI1;
        pvaString->parray = psaString;
        SafeArrayUnaccessData(psaString);
    }
    return hresReturn;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\pwsctrl.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsctrl.cpp

Abstract:

    This is the main routine for the Internet Services suite.

Author:

    Johnson Apacible    (JohnsonA)  29-Apr-1997
    Boyd Multerer       (BoydM)     29-Apr-1997

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#include <coiadm.hxx>
#include <admacl.hxx>
#include <iiscnfg.h>
#include <secpriv.h>
#include <buffer.hxx>
#include <string.hxx>
#include <pwsctrl.h>
#include <shellapi.h>
#include <pwsdata.hxx>
#include <inetsvcs.h>


#define REGKEY_STP          TEXT("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   TEXT("InstallPath")

//------------------------------------------------------------------------
//BOOL W95StartW3SVC( LPCSTR pszPath, LPCSTR pszPathDir, PCHAR pszParams )
BOOL W95StartW3SVC( void )
    {
    HKEY                hKey;
    TCHAR               chPath[MAX_PATH+1];
    DWORD       cbPath;
    DWORD       err, type;
    STR         strPath;

    // get the server install path from the registry
    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key
            REGKEY_STP,             // address of name of subkey to open
            0,                                  // reserved
            KEY_READ,                   // security access mask
            &hKey                               // address of handle of open key
            );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
    return FALSE;

    cbPath = sizeof(chPath);
    type = REG_SZ;
    err = RegQueryValueEx(
            hKey,                   // handle of key to query
            REGKEY_INSTALLKEY,  // address of name of value to query
            NULL,                   // reserved
            &type,                  // address of buffer for value type
            (PUCHAR)chPath,         // address of data buffer
            &cbPath             // address of data buffer size
            );

    // close the key
    RegCloseKey( hKey );

    // if we did get the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // add on the file name
    if (strPath.Copy(chPath)) {
        if (strPath.Append("\\inetinfo.exe")) {
            // and do it to it!
            ULONG_PTR res = (ULONG_PTR)ShellExecute(
                NULL,           // handle to parent window
                NULL,           // pointer to string that specifies operation to perform
                strPath.QueryStr(),                 // pointer to filename or folder name string
                "-e w3svc", // pointer to string that specifies executable-file parameters
                NULL,           // pointer to string that specifies default directory
                SW_HIDE             // whether file is shown when opened
               );

            return ( res > 32 );
        }
    }

    return FALSE;
}

//------------------------------------------------------------------------
BOOL
W95ShutdownW3SVC(
    VOID
    )
{
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, "Inet_shutdown");

    if ( hEvent == NULL ) {
        return TRUE;    // not there
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
        SetEvent( hEvent );
    }

    CloseHandle(hEvent);
    return TRUE;
}

//------------------------------------------------------------------------
BOOL
W95ShutdownIISADMIN(
    VOID
    )
{
    DWORD i;
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, IIS_AS_EXE_OBJECT_NAME);

    if ( hEvent == NULL ) {
        return(TRUE);
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
        SetEvent( hEvent );
    }

    CloseHandle(hEvent);

    for (i=0; i < 20; i++) {

        hEvent = CreateEvent(NULL, TRUE, FALSE, IIS_AS_EXE_OBJECT_NAME);
        if ( hEvent != NULL ) {
            DWORD err = GetLastError();
            CloseHandle(hEvent);

            if ( err == ERROR_ALREADY_EXISTS ) {
                Sleep(500);
                continue;
            }
        }

        break;
    }

    return(TRUE);
}

//------------------------------------------------------------------------
BOOL
IsIISAdminRunning(
    VOID
    )
{
    HANDLE hEvent;
    BOOL fFound = FALSE;

    hEvent = CreateEvent(NULL, TRUE, FALSE, IIS_AS_EXE_OBJECT_NAME);

    if ( hEvent != NULL ) {
        fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
        CloseHandle(hEvent);
    }

    return(fFound);
}

//------------------------------------------------------------------------
BOOL
IsInetinfoRunning(
    VOID
    )
{
    HANDLE hEvent;
    BOOL fFound = FALSE;

    hEvent = CreateEvent(NULL, TRUE, FALSE, PWS_SHUTDOWN_EVENT);

    if ( hEvent != NULL ) {
        fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
        CloseHandle(hEvent);
    }
    return(fFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\iadmwxp.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iadmxp.c

Abstract:

    Wrapper around the MIDL-generated IADM_P.C. This wrapper allows us
    to "hook" the RPC-runtime-supplied IUnknown_Release_Proxy used in
    the client-side object's VTable. We need to hook this method so
    we may determine the exact lifetime of the client-side object. We
    need the exact lifetime so we can know when to destroy the security
    context we associate with each object.

    Hooked_IUnknown_Release_Proxy is implemented in SECURITY.CXX.

Author:

    Keith Moore (keithmo)       29-Feb-1997

Revision History:

--*/

#define IUnknown_Release_Proxy Hooked_IUnknown_Release_Proxy
#include "iadmw_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\beta2\cofact.cxx ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#include <coiadm.hxx>
#include <isplat.h>
#include <stdio.h>

extern ULONG g_dwRefCount;

CADMCOMSrvFactory::CADMCOMSrvFactory()
{
    m_dwRefCount=0;
}

CADMCOMSrvFactory::~CADMCOMSrvFactory()
{
}

HRESULT
CADMCOMSrvFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void ** ppObject
    )
{
//    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactory::CreateInstance]\n"));

    HRESULT hresReturn = E_NOINTERFACE;

    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    if (IID_IUnknown==riid || IID_IDispatch==riid || IID_IMSAdminBase==riid) {
        CADMCOM *padmcom = new CADMCOM();

        if( padmcom == NULL ) {
            hresReturn = E_OUTOFMEMORY;
        }
        else {
            hresReturn = padmcom->GetStatus();
            if (FAILED(hresReturn)) {
                delete(padmcom);
            }
            else {
                hresReturn = padmcom->QueryInterface(riid, ppObject);
                if( FAILED(hresReturn) ) {
                    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactory::CreateInstance] no I/F\n"));
                    delete padmcom;
                }
            }
        }
    }

    return hresReturn;
}

HRESULT
CADMCOMSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CADMCOMSrvFactory::QueryInterface(
    REFIID riid,
    void **ppObject
    )
{
//    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactory::QueryInterface]\n"));

    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
        *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return NO_ERROR;
}

ULONG
CADMCOMSrvFactory::AddRef(
    )
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CADMCOMSrvFactory::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}



CMSMetaBaseSrvFactory::CMSMetaBaseSrvFactory()
{
    m_dwRefCount=0;
}

CMSMetaBaseSrvFactory::~CMSMetaBaseSrvFactory()
{
}

HRESULT
CMSMetaBaseSrvFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void ** ppObject
    )
{
//    DBGPRINTF( (DBG_CONTEXT, "[CADMAUTOSrvFactory::CreateInstance]\n"));

    HRESULT hresReturn = E_NOINTERFACE;
    if (pUnkOuter != NULL) {
        hresReturn = CLASS_E_NOAGGREGATION;
    }
    else if (IID_IUnknown==riid || IID_IDispatch==riid || IID_IMSMetaBase==riid) {
        CMSMetaBase *padmautoNew = new CMSMetaBase;
        if (padmautoNew == NULL) {
            hresReturn = E_OUTOFMEMORY;
        }
        else {
            hresReturn = padmautoNew->Init();
            if (SUCCEEDED(hresReturn)) {
                hresReturn = padmautoNew->QueryInterface(riid, ppObject);
            }
            if (FAILED(hresReturn)) {
                DBGPRINTF( (DBG_CONTEXT, "[CADMAUTOSrvFactory::CreateInstance] no I/F\n"));
                delete padmautoNew;
            }
        }
    }
    return hresReturn;
}

HRESULT
CMSMetaBaseSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CMSMetaBaseSrvFactory::QueryInterface(
    REFIID riid,
    void **ppObject
    )
{
//    DBGPRINTF( (DBG_CONTEXT, "[CADMAUTOSrvFactory::QueryInterface]\n"));

    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
        *ppObject = this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return NO_ERROR;
}

ULONG
CMSMetaBaseSrvFactory::AddRef(
    )
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CMSMetaBaseSrvFactory::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}


STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppObject)
{
    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactory::DllGetClassObject]\n" ) );

    if ((rclsid != CLSID_MSAdminBase) && (rclsid != CLSID_MSAdminBaseExe)) {
        DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactory::DllGetClassObject] bad class\n" ) );
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    CADMCOMSrvFactory *pFactory = new CADMCOMSrvFactory;
    if (FAILED(pFactory->QueryInterface(riid, ppObject))) {
        delete pFactory;
        *ppObject = NULL;
        DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactory::DllGetClassObject] no I/F\n" ) );
        return E_INVALIDARG;
    }
    return NO_ERROR;
}

HRESULT _stdcall DllCanUnloadNow(
    )
{

   if (g_dwRefCount) {
        return S_FALSE;
    }
    else {
        return S_OK;
    }
}

STDAPI DllRegisterServer(
    )
{
    HKEY hKeyCLSID, hKeyInproc32;
    HKEY hKeyIF, hKeyStub32;
    HKEY hKeyAppExe, hKeyAppID, hKeyTemp;
    DWORD dwDisposition;
    HMODULE hModule;
    BOOL bIsWin95 = FALSE;


    //
    // if win95, then don't register as service
    //

    if ( IISGetPlatformType() == PtWindows95 ) {

        bIsWin95 = TRUE;
    }

    //
    // register AppExe
    //

    HRESULT hr;
    ITypeLib   *pITypeLib;


    hModule=GetModuleHandle(TEXT("COADMIN.DLL"));
    if (!hModule) {
            return E_UNEXPECTED;
            }

    char pszName[MAX_PATH+1 + sizeof("inetinfo.exe -e iisadmin")];
    WCHAR wchName[MAX_PATH + 1];
    if (GetModuleFileName(hModule, pszName, sizeof(pszName))==0) {
            return E_UNEXPECTED;
            }

    int i;

    for (i = strlen(pszName) -1; (i >= 0) && (pszName[i] != '/') & (pszName[i] != '\\'); i--) {
    }

    pszName[i + 1] = '\0';
    strcat(pszName, "IADM.TLB");
    swprintf(wchName, OLESTR("%S"), pszName);

    hr=LoadTypeLibEx(wchName, REGKIND_REGISTER, &pITypeLib);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    if (bIsWin95) {
        //
        // Set pszName to the command to start the web server
        //

        for (i = strlen(pszName) -1; (i >= 0) && (pszName[i] != '/') & (pszName[i] != '\\'); i--) {
        }

        pszName[i + 1] = '\0';
        strcat(pszName, "inetinfo.exe -e iisadmin");
    }

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISAdmin.Object"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS Admin Service"), sizeof(TEXT("IIS Admin Service")))!=ERROR_SUCCESS) {
        RegCloseKey(hKeyTemp);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISAdmin.Object\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{668583F0-6FDB-11d0-B9B0-00A0C922E750}"),
                      sizeof(TEXT("{668583F0-6FDB-11d0-B9B0-00A0C922E750}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISAdmin.Object\\CurVer"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISAdmin.Object.1"),
                      sizeof(TEXT("IISAdmin.Object.1")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISAdmin.Object\\NotInsertable"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISAdmin.Object.1"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("ADMCOM"),
                      sizeof(TEXT("ADMCOM")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISAdmin.Object.1\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{668583F0-6FDB-11d0-B9B0-00A0C922E750}"),
                      sizeof(TEXT("{668583F0-6FDB-11d0-B9B0-00A0C922E750}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISAdmin.Object.1\\NotInsertable"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISAdmin.Object.1"),
                      sizeof(TEXT("IISAdmin.Object.1")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\VersionIndependentProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISAdmin.Object"),
                      sizeof(TEXT("IISAdmin.Object")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);


    if (bIsWin95) {
        if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                           TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\LocalServer32"),
                           NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                            &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
        }

        if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ, (BYTE*) pszName, strlen(pszName) + 1)!=ERROR_SUCCESS) {
                    RegCloseKey(hKeyTemp);
                    return E_UNEXPECTED;
                    }
        RegCloseKey(hKeyTemp);
    }

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{1B890330-4F09-11d0-B9AC-00A0C922E750}"),
                      sizeof(TEXT("{1B890330-4F09-11d0-B9AC-00A0C922E750}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\Programmable"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\NotInsertable"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register Automation CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS Admin Service"), sizeof(TEXT("IIS Admin Servce")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("AppID"), NULL, REG_SZ, (BYTE*) TEXT("{668583F0-6FDB-11d0-B9B0-00A0C922E750}"), sizeof(TEXT("{668583F0-6FDB-11d0-B9B0-00A0C922E750}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }


    //
    // register Automation AppID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("AppID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS Admin Service"), sizeof(TEXT("IIS Admin Service")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    if (!bIsWin95) {
        if (RegSetValueEx(hKeyTemp, TEXT("LocalService"), NULL, REG_SZ, (BYTE*) TEXT("IISADMIN"), sizeof(TEXT("IISADMIN")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyTemp);
            return E_UNEXPECTED;
        }
    }

    //
    // register inetinfo AppID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("AppID\\inetinfo.exe"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyAppExe, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyAppExe, TEXT("AppID"), NULL, REG_SZ, (BYTE*) TEXT("{88E4BA60-537B-11D0-9B8E-00A0C922E703}"), sizeof(TEXT("{88E4BA60-537B-11D0-9B8E-00A0C922E703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyAppExe);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyAppExe);

    //
    // register AppID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("AppID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyAppID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyAppID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS Admin Service"), sizeof(TEXT("IIS Admin Service")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyAppID);
                return E_UNEXPECTED;
                }

    if (!bIsWin95) {
        if (RegSetValueEx(hKeyAppID, TEXT("LocalService"), NULL, REG_SZ, (BYTE*) TEXT("IISADMIN"), sizeof(TEXT("IISADMIN")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyAppID);
            return E_UNEXPECTED;
        }
    }
    RegCloseKey(hKeyAppID);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS Admin Service"), sizeof(TEXT("IIS Admin Servce")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT("AppID"), NULL, REG_SZ, (BYTE*) TEXT("{88E4BA60-537B-11D0-9B8E-00A0C922E703}"), sizeof(TEXT("{88E4BA60-537B-11D0-9B8E-00A0C922E703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (bIsWin95) {
        if (RegCreateKeyEx(hKeyCLSID,
                           TEXT("LocalServer32"),
                           NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                            &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
        if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ, (BYTE*) pszName, strlen(pszName) + 1)!=ERROR_SUCCESS) {
                    RegCloseKey(hKeyTemp);
                    RegCloseKey(hKeyCLSID);
                    return E_UNEXPECTED;
                    }
        RegCloseKey(hKeyTemp);
    }
    else {
        if (RegSetValueEx(hKeyCLSID, TEXT("LocalService"), NULL, REG_SZ, (BYTE*) TEXT("IISADMIN"), sizeof(TEXT("IISADMIN")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
    }

    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("PSFactoryBuffer"), sizeof(TEXT("PSFactoryBuffer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       "InprocServer32",
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyInproc32, TEXT(""), NULL, REG_SZ, (BYTE*) "ADMPROX.DLL", sizeof(TEXT("ADMPROX.DLL")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyInproc32, TEXT("ThreadingModel"), NULL, REG_SZ, (BYTE*) "Both", sizeof("Both")-1 )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);


    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{1E056350-761E-11d0-9BA1-00A0C922E703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("PSFactoryBuffer"), sizeof(TEXT("PSFactoryBuffer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       "InprocServer32",
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyInproc32, TEXT(""), NULL, REG_SZ, (BYTE*) "ADMPROX.DLL", sizeof(TEXT("ADMPROX.DLL")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyInproc32, TEXT("ThreadingModel"), NULL, REG_SZ, (BYTE*) "Both", sizeof("Both")-1 )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    //
    // register Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IADMCOM"), sizeof(TEXT("IADMCOM")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyIF,
                    "ProxyStubClsid32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{CBA424F0-483A-11D0-9D2A-00A0C922E703}", sizeof("{CBA424F0-483A-11D0-9D2A-00A0C922E703}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{1E056350-761E-11d0-9BA1-00A0C922E703}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IADMCOMSINK"), sizeof(TEXT("IADMCOMSINK")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyIF,
                    "ProxyStubClsid32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{1E056350-761E-11d0-9BA1-00A0C922E703}", sizeof("{1E056350-761E-11d0-9BA1-00A0C922E703}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    return NOERROR;
}

STDAPI DllUnregisterServer(void) {

    BOOL bIsWin95 = FALSE;


    //
    // if win95, then don't register as service
    //

    if ( IISGetPlatformType() == PtWindows95 ) {

        bIsWin95 = TRUE;
    }

    UnRegisterTypeLib(LIBID_MSAdmin,
                      1,
                      0,
                      0,
                      SYS_WIN32);

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISAdmin.Object\\CLSID"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISAdmin.Object\\CurVer"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISAdmin.Object\\NotInsertable"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISAdmin.Object"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISAdmin.Object.1\\CLSID"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISAdmin.Object.1\\NotInsertable"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISAdmin.Object.1"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\ProgID"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\VersionIndependentProgID"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\TypeLib"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\Programmable"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\NotInsertable"));

    if (bIsWin95) {
        RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}\\LocalServer32"));
    }

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{668583F0-6FDB-11d0-B9B0-00A0C922E750}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\inetinfo.exe"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}"));

    if (bIsWin95) {
        RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}\\LocalServer32"));
    }

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{1E056350-761E-11d0-9BA1-00A0C922E703}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{1E056350-761E-11d0-9BA1-00A0C922E703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{1E056350-761E-11d0-9BA1-00A0C922E703}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{1E056350-761E-11d0-9BA1-00A0C922E703}"));

    return NOERROR;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\beta2\comobj.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       comobj.cxx

   Abstract:

       This module defines DCOM Admin APIs.

   Author:

       Sophia Chung (sophiac)   23-Nov-1996

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#include <coiadm.hxx>
#include <admacl.hxx>
#include <secpriv.h>


//
// Globals
//

DECLARE_DEBUG_PRINTS_OBJECT();

ULONG g_dwRefCount = 0;

HANDLE_TABLE g_MasterRoot = { NULL, 0, METADATA_MASTER_ROOT_HANDLE, ALL_HANDLE };


CADMCOM::CADMCOM():
    m_ImpIConnectionPointContainer(),
    m_pMdObject(NULL),
    m_pNseObject(NULL),
    m_dwRefCount(0),
    m_dwHandleValue(1),
    m_pEventSink(NULL),
    m_pConnPoint(NULL),
    m_bSinkConnected(FALSE)

{
    HRESULT hRes;
    UINT i;

    memset((PVOID)m_hashtab, 0, sizeof(m_hashtab) );

    // Null all entries in the connection point array.
    for (i=0; i<MAX_CONNECTION_POINTS; i++) {
        m_aConnectionPoints[i] = NULL;
    }

    hRes = CoCreateInstance(CLSID_MDCOM, NULL, CLSCTX_INPROC_SERVER, IID_IMDCOM, (void**) &m_pMdObject);

    if (FAILED(hRes)) {
        DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::CADMCOM] CoCreateInstance(MDCOM) failed, error %lx\n",
                    GetLastError() ));
        SetStatus(hRes);
    }
    else {

        hRes = m_pMdObject->ComMDInitialize();

        if (FAILED(hRes)) {
            DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOM::CADMCOM] ComMDInitialize(MDCOM) failed, error %lx\n",
                        hRes ));
            SetStatus(hRes);
            m_pMdObject->Release();
            m_pMdObject == NULL;
        }
    }

    if (SUCCEEDED(hRes)) {
        hRes = CoCreateInstance(CLSID_NSEPMCOM, NULL, CLSCTX_INPROC_SERVER, IID_NSECOM, (void**) &m_pNseObject);

        if (FAILED(hRes)) {
            DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOM::CADMCOM] CoCreateInstance(NSEPMCOM) failed, error %lx\n",
                        GetLastError() ));
        }
        else {

            hRes = m_pNseObject->ComMDInitialize();

            if (FAILED(hRes)) {
                DBGPRINTF(( DBG_CONTEXT,
                            "[CADMCOM::CADMCOM] ComMDInitialize(NSEPMCOM) failed, error %lx\n",
                            hRes ));
                m_pNseObject->Release();
                m_pNseObject = NULL;
            }
        }

        m_pEventSink = new CImpIMDCOMSINK((IMSAdminBase*)this);
        if( m_pEventSink == NULL ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOM::CADMCOM] CImpIMDCOMSINK failed, error %lx\n",
                        GetLastError() ));
            SetStatus(E_OUTOFMEMORY);
        }
        else {

            COConnectionPoint* pCOConnPt;

            m_ImpIConnectionPointContainer.Init(this);
            // Rig this COPaper COM object to be connectable. Assign the connection
            // point array. This object's connection points are determined at
            // compile time--it currently has only one connection point:
            // the CONNPOINT_PAPERSINK connection point. Create a connection
            // point object for this and assign it into the array. This array could
            // easily grow to support additional connection points in the future.

            // First try creating a new connection point object. Pass 'this' as the
            // pHostObj pointer used by the connection point to pass its AddRef and
            // Release calls back to the host connectable object.
            pCOConnPt = new COConnectionPoint(this);
            if (NULL != pCOConnPt)
            {
              // If creation succeeded then initialize it (including creating
              // its initial dynamic connection array).
              hRes = pCOConnPt->Init(IID_IMSAdminBaseSink);

              // If the init succeeded then use QueryInterface to obtain the
              // IConnectionPoint interface on the new connection point object.
              // The interface pointer is assigned directly into the
              // connection point array. The QI also does the needed AddRef.
              if (SUCCEEDED(hRes)) {
                    hRes = pCOConnPt->QueryInterface(IID_IConnectionPoint,
                                                   (PPVOID)&m_aConnectionPoints[ADM_CONNPOINT_WRITESINK]);
              }
              if (FAILED(hRes)) {
                  delete (pCOConnPt);
                  SetStatus(hRes);
              }
            }
            else {
              SetStatus(E_OUTOFMEMORY);
            }
            if (SUCCEEDED(GetStatus())) {
                //
                // Admin's sink
                //

                IConnectionPointContainer* pConnPointContainer = NULL;

                // First query the object for its Connection Point Container. This
                // essentially asks the object in the server if it is connectable.
                hRes = m_pMdObject->QueryInterface( IID_IConnectionPointContainer,
                       (PVOID *)&pConnPointContainer);

                if SUCCEEDED(hRes)
                {
                    // Find the requested Connection Point. This AddRef's the
                    // returned pointer.
                    hRes = pConnPointContainer->FindConnectionPoint(IID_IMDCOMSINK, &m_pConnPoint);
                    if (SUCCEEDED(hRes)) {
                        hRes = m_pConnPoint->Advise((IUnknown *)m_pEventSink, &m_dwCookie);
                        if (SUCCEEDED(hRes)) {
                            m_bSinkConnected = TRUE;
                        }
                    }
                    RELEASE_INTERFACE(pConnPointContainer);
                }
                if (FAILED(hRes)) {
                    SetStatus(hRes);
                }
            }
        }
    }
}

CADMCOM::~CADMCOM()
{

    DWORD i;
    HANDLE_TABLE *node;
    HANDLE_TABLE *nextnode;

    //
    // Tell ADMPROX.DLL to release this object's associated security
    // context.
    //

    ReleaseObjectSecurityContext( (IUnknown *)this );

    //
    // Do final release of the connection point objects.
    // If this isn't the final release, then the client has an outstanding
    // unbalanced reference to a connection point and a memory leak may
    // likely result because the host COPaper object is now going away yet
    // a connection point for this host object will not end up deleting
    // itself (and its connections array).
    //

    for (i=0; i<MAX_CONNECTION_POINTS; i++)
    {
      RELEASE_INTERFACE(m_aConnectionPoints[i]);
    }

    if (SUCCEEDED(GetStatus())) {
        //
        // Close all opened handles
        //

        m_rHandleResource.Lock(TSRES_LOCK_WRITE);

        for( i = 0; i < HASHSIZE; i++ ) {
            for( node = nextnode = m_hashtab[i]; node != NULL; node = nextnode ) {
                if( node->hAdminHandle != INVALID_ADMINHANDLE_VALUE ) {
                    if( node->HandleType == NSEPM_HANDLE ) {

                        //
                        // call nse com api
                        //

                        m_pNseObject->ComMDCloseMetaObject( node->hActualHandle );

                    }
                    else {

                        //
                        // call metadata com api
                        //

                        m_pMdObject->ComMDCloseMetaObject( node->hActualHandle );

                    }

                }

                nextnode = node->next;
                LocalFree(node);
            }
        }
    }

    m_rHandleResource.Unlock();

    if (m_bSinkConnected) {
        m_pConnPoint->Unadvise(m_dwCookie);
    }

    if ( m_pEventSink != NULL )
    {
        delete m_pEventSink;
    }

    if ( m_pMdObject != NULL )
    {
        m_pMdObject->ComMDTerminate(TRUE);
        m_pMdObject->Release();
    }

    if ( m_pNseObject != NULL )
    {
        m_pNseObject->ComMDTerminate(TRUE);
        m_pNseObject->Release();
    }

}

HRESULT
CADMCOM::QueryInterface(
    REFIID riid,
    void **ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IMSAdminBase) {
        *ppObject = (IMSAdminBase *) this;
        AddRef();
    }
    else if ( riid==IID_IMDCOM && m_pMdObject ) {
        *ppObject = (IMSAdminBase *)m_pMdObject;
        ((IMSAdminBase *)m_pMdObject)->AddRef();
    }
    else if ( riid==IID_NSECOM && m_pNseObject ) {
        *ppObject = (IMSAdminBase *)m_pNseObject;
        ((IMSAdminBase *)m_pNseObject)->AddRef();
    }
    else if (IID_IConnectionPointContainer == riid) {
        *ppObject = &m_ImpIConnectionPointContainer;
        AddRef();
    }
    else {
        return E_NOINTERFACE;
    }

    return NO_ERROR;
}

ULONG
CADMCOM::AddRef(
    )
{
    DWORD dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    return dwRefCount;
}

ULONG
CADMCOM::Release(
    )
{
    DWORD dwRefCount;

    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);

    if( dwRefCount == 0 ) {
        delete this;
        return 0;
    }

    return dwRefCount;
}

HRESULT
CADMCOM::AddKey(
    IN METADATA_HANDLE hMDHandle,
    IN PBYTE pszMDPath
    )
/*++

Routine Description:

    Add meta object and adds it to the list of child objects for the object
    specified by Path.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be added

Return Value:

    Status.

--*/
{

    DWORD RetCode;

    if (((LPSTR)pszMDPath == NULL) ||
             (*(LPSTR)pszMDPath == (TCHAR)'\0')) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_WRITE ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::AddKey] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDAddMetaObject( hActualHandle,
                                                     pszMDPath );

        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDAddMetaObject( hActualHandle,
                                                    pszMDPath );
        }
    }
}

HRESULT
CADMCOM::DeleteKey(
    IN METADATA_HANDLE hMDHandle,
    IN PBYTE pszMDPath
    )
/*++

Routine Description:

    Deletes a meta object and all of its data.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of object to be deleted, relative to the path of Handle.
           Must not be NULL.

Return Value:

    Status.

--*/
{
    DWORD RetCode;
    if ((LPSTR)pszMDPath == NULL) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_WRITE ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::DeleteKey] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDDeleteMetaObject( hActualHandle,
                                                        pszMDPath );
        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDDeleteMetaObject( hActualHandle,
                                                       pszMDPath );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::DeleteChildKeys(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath
    )
/*++

Routine Description:

    Deletes all child meta objects of the specified object, with all of their
    data.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the parent of the objects to be deleted, relative to
                the path of Handle.

Return Value:

    Status.

--*/
{
    DWORD RetCode;
    METADATA_HANDLE hActualHandle;
    HANDLE_TYPE HandleType;

    //
    // Access check
    //

    if ( !AdminAclAccessCheck( m_pMdObject,
                               hMDHandle,
                               pszMDPath,
                               0,
                               METADATA_PERMISSION_WRITE ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOM::DeletChildKeys] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        return RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // Map Admin Handle to Actual Handle
    //

    if( (RetCode = Lookup( hMDHandle,
                           &hActualHandle,
                           &HandleType )) != ERROR_SUCCESS ) {
        return RETURNCODETOHRESULT(RetCode);
    }

    if( HandleType == NSEPM_HANDLE ) {

        //
        // call nse com api
        //

        return m_pNseObject->ComMDDeleteChildMetaObjects( hActualHandle,
                                                          pszMDPath );

    }
    else {

        //
        // call metadata com api
        //

        return m_pMdObject->ComMDDeleteChildMetaObjects( hActualHandle,
                                                         pszMDPath );
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::EnumKeys(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex
    )
/*++

Routine Description:

    Enumerate objects in path.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of parent object, relative to the path of Handle
                eg. "Root Object/Child/GrandChild"
    pszMDName - buffer where the Name of the object is returned

    dwEnumObjectIndex - index of the value to be retrieved

Return Value:

    Status.

--*/
{
    DWORD RetCode;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if ((LPSTR)pszMDName == NULL) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_READ ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::EnumKeys] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDEnumMetaObjects( hActualHandle,
                                                       pszMDPath,
                                                       pszMDName,
                                                       dwMDEnumObjectIndex );
        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDEnumMetaObjects( hActualHandle,
                                                      pszMDPath,
                                                      pszMDName,
                                                      dwMDEnumObjectIndex );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::CopyKey(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag
    )
/*++

Routine Description:

    Copy or move source meta object and its data and descendants to Dest.

Arguments:

    hMDSourceHandle - open handle

    pszMDSourcePath - path of the object to be copied

    hMDDestHandle - handle of the new location for the object

    pszMDDestPath - path of the new location for the object, relative
                          to the path of hMDDestHandle

    bMDOverwriteFlag - determine the behavior if a meta object with the same
                       name as source is already a child of pszMDDestPath.

    bMDCopyFlag - determine whether Source is deleted from its original location

Return Value:

    Status

--*/
{
    DWORD RetCode = ERROR_SUCCESS;
    METADATA_HANDLE hSActualHandle;
    HANDLE_TYPE SHandleType;
    METADATA_HANDLE hDActualHandle;
    HANDLE_TYPE DHandleType;

    //
    // Access check source
    //

    if ( !AdminAclAccessCheck( m_pMdObject,
                               hMDSourceHandle,
                               pszMDSourcePath,
                               0,
                               METADATA_PERMISSION_READ ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOM::CopyKey] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        return RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // Access check dest
    //

    if ( !AdminAclAccessCheck( m_pMdObject,
                               hMDDestHandle,
                               pszMDDestPath,
                               0,
                               METADATA_PERMISSION_WRITE ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOM::CopyKey] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        return RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // Map Admin Handle to Actual Handle
    //

    if( (RetCode = Lookup( hMDSourceHandle,
                           &hSActualHandle,
                           &SHandleType )) != ERROR_SUCCESS ) {
        return RETURNCODETOHRESULT(RetCode);
    }

    if( (RetCode = Lookup( hMDDestHandle,
                           &hDActualHandle,
                           &DHandleType )) != ERROR_SUCCESS ) {
        return RETURNCODETOHRESULT(RetCode);
    }

    if( SHandleType != DHandleType ) {
        RetCode = ERROR_INVALID_HANDLE;
        return RETURNCODETOHRESULT(RetCode);
    }

    if( SHandleType == NSEPM_HANDLE ) {

        //
        // call nse com api
        //

        return m_pNseObject->ComMDCopyMetaObject( hSActualHandle,
                                                  pszMDSourcePath,
                                                  hDActualHandle,
                                                  pszMDDestPath,
                                                  bMDOverwriteFlag,
                                                  bMDCopyFlag );
    }
    else {

        //
        // call metadata com api
        //

        return m_pMdObject->ComMDCopyMetaObject( hSActualHandle,
                                                 pszMDSourcePath,
                                                 hDActualHandle,
                                                 pszMDDestPath,
                                                 bMDOverwriteFlag,
                                                 bMDCopyFlag );
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::SetData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData
    )
/*++

Routine Description:

    Set a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data to set

Return Value:

    Status.

--*/
{
    DWORD RetCode;
    METADATA_HANDLE hActualHandle;
    HANDLE_TYPE HandleType;

    //
    // Access check
    //

    if ( !AdminAclAccessCheck( m_pMdObject,
                               hMDHandle,
                               pszMDPath,
                               pmdrMDData->dwMDIdentifier,
                               METADATA_PERMISSION_WRITE ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOM::SetData] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        return RETURNCODETOHRESULT( GetLastError() );
    }

    if ( !AdminAclNotifySetOrDeleteProp(
                                         hMDHandle,
                                         pmdrMDData->dwMDIdentifier ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOM::SetData] AdminAclNotifySetOrDel failed, error %lx\n",
                GetLastError() ));
        return RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // Map Admin Handle to Actual Handle
    //

    if( (RetCode = Lookup( hMDHandle,
                           &hActualHandle,
                           &HandleType )) != ERROR_SUCCESS ) {
        return RETURNCODETOHRESULT(RetCode);
    }

    if( HandleType == NSEPM_HANDLE ) {

        //
        // call nse com api
        //

        return m_pNseObject->ComMDSetMetaData( hActualHandle,
                                               pszMDPath,
                                               pmdrMDData );
    }
    else {

        //
        // call metadata com api
        //

        return m_pMdObject->ComMDSetMetaData( hActualHandle,
                                              pszMDPath,
                                              pmdrMDData );
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::GetData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Get one metadata value

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{
    DWORD RetCode;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   pmdrMDData->dwMDIdentifier,
                                   METADATA_PERMISSION_READ ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::GetData] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDGetMetaData( hActualHandle,
                                                   pszMDPath,
                                                   pmdrMDData,
                                                   pdwMDRequiredDataLen );
        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDGetMetaData( hActualHandle,
                                                  pszMDPath,
                                                  pmdrMDData,
                                                  pdwMDRequiredDataLen );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::DeleteData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType
    )
/*++

Routine Description:

    Deletes a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDIdentifier - identifier of the data to remove

    dwMDDataType - optional type of the data to remove

Return Value:

    Status.

--*/
{
    DWORD RetCode;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (dwMDDataType >= INVALID_END_METADATA) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   dwMDIdentifier,
                                   METADATA_PERMISSION_WRITE ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::DeleteData] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        if ( !AdminAclNotifySetOrDeleteProp(
                                             hMDHandle,
                                             dwMDIdentifier ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::DeleteData] AdminAclNotifySetOrDel failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDDeleteMetaData( hActualHandle,
                                                      pszMDPath,
                                                      dwMDIdentifier,
                                                      dwMDDataType );
        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDDeleteMetaData( hActualHandle,
                                                     pszMDPath,
                                                     dwMDIdentifier,
                                                     dwMDDataType );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::EnumData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Enumerate properties of object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{
    DWORD RetCode;

    if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_READ ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::EnumData] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDEnumMetaData( hActualHandle,
                                                    pszMDPath,
                                                    pmdrMDData,
                                                    dwMDEnumDataIndex,
                                                    pdwMDRequiredDataLen );
        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDEnumMetaData( hActualHandle,
                                                   pszMDPath,
                                                   pmdrMDData,
                                                   dwMDEnumDataIndex,
                                                   pdwMDRequiredDataLen );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::GetAllData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
    )
/*++

Routine Description:

    Gets all data associated with a Meta Object

Arguments:

    hMDHandle - open  handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - type of the data

    pdwMDNumDataEntries - number of entries copied to Buffer

    pdwMDDataSetNumber - number associated with this data set

    dwMDBufferSize - size in bytes of buffer

    pbBuffer - buffer to store the data

    pdwMDRequiredBufferSize - updated with required length of buffer

Return Value:

    Status.

--*/
{
    DWORD RetCode;

    if ((pdwMDNumDataEntries == NULL) || ((dwMDBufferSize != 0) && (pbBuffer == NULL)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT)) ||
        (dwMDDataType >= INVALID_END_METADATA)) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_READ ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::GetAllData] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDGetAllMetaData( hActualHandle,
                                                      pszMDPath,
                                                      dwMDAttributes,
                                                      dwMDUserType,
                                                      dwMDDataType,
                                                      pdwMDNumDataEntries,
                                                      pdwMDDataSetNumber,
                                                      dwMDBufferSize,
                                                      pbBuffer,
                                                      pdwMDRequiredBufferSize );
        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDGetAllMetaData( hActualHandle,
                                                     pszMDPath,
                                                     dwMDAttributes,
                                                     dwMDUserType,
                                                     dwMDDataType,
                                                     pdwMDNumDataEntries,
                                                     pdwMDDataSetNumber,
                                                     dwMDBufferSize,
                                                     pbBuffer,
                                                     pdwMDRequiredBufferSize );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::DeleteAllData(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType
    )
{
    DWORD RetCode;

    if (dwMDDataType >= INVALID_END_METADATA) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_WRITE ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::DeleteAllData] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDDeleteAllMetaData( hActualHandle,
                                                         pszMDPath,
                                                         dwMDUserType,
                                                         dwMDDataType );

        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDDeleteAllMetaData( hActualHandle,
                                                        pszMDPath,
                                                        dwMDUserType,
                                                        dwMDDataType );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::CopyData(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag
    )
/*++

Routine Description:

    Copies or moves data associated with the source object to the destination
    object.

Arguments:

    hMDSourceHandle - open handle

    pszMDSourcePath - path of the meta object with which then source data is
                      associated

    hMDDestHandle - handle returned by MDOpenKey with write permission

    pszMDDestPath - path of the meta object for data to be copied to

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - optional type of the data to copy

    bMDCopyFlag - if true, data will be copied; if false, data will be moved.

Return Value:

    Status.

--*/
{
    DWORD RetCode;

    if (((!bMDCopyFlag) && (dwMDAttributes & METADATA_INHERIT)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT))){
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hSActualHandle;
        HANDLE_TYPE SHandleType;
        METADATA_HANDLE hDActualHandle;
        HANDLE_TYPE DHandleType;

        //
        // Access check source
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDSourceHandle,
                                   pszMDSourcePath,
                                   0,
                                   METADATA_PERMISSION_READ ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::CopyData] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Access check dest
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDDestHandle,
                                   pszMDDestPath,
                                   0,
                                   METADATA_PERMISSION_WRITE ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::CopyData] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        if( (RetCode = Lookup( hMDSourceHandle,
                               &hSActualHandle,
                               &SHandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( (RetCode = Lookup( hMDDestHandle,
                               &hDActualHandle,
                               &DHandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( SHandleType != DHandleType ) {
            RetCode = ERROR_INVALID_HANDLE;
            return RETURNCODETOHRESULT(RetCode);
        }

        if( SHandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDCopyMetaData( hSActualHandle,
                                                    pszMDSourcePath,
                                                    hDActualHandle,
                                                    pszMDDestPath,
                                                    dwMDAttributes,
                                                    dwMDUserType,
                                                    dwMDDataType,
                                                    bMDCopyFlag );
        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDCopyMetaData( hSActualHandle,
                                                   pszMDSourcePath,
                                                   hDActualHandle,
                                                   pszMDDestPath,
                                                   dwMDAttributes,
                                                   dwMDUserType,
                                                   dwMDDataType,
                                                   bMDCopyFlag );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::RenameKey(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName)
{
    DWORD RetCode;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if ((LPSTR)pszMDNewName == NULL) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_WRITE ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::RenameKey] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDRenameMetaObject( hActualHandle,
                                                        pszMDPath,
                                                        pszMDNewName );
        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDRenameMetaObject( hActualHandle,
                                                       pszMDPath,
                                                       pszMDNewName );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::OpenKey(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle
    )
/*++

Routine Description:

    Opens a meta object for read and/or write access.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be opened

    dwMDAccessRequested - permissions requested

    dwMDTimeOut - time to block waiting for open to succeed, in miliseconds.

    phMDNewHandle - handle to be passed to other MD routines

Return Value:

    Status.

--*/
{
    DWORD RetCode;
    BOOL  fIsNse;

    if ((phMDNewHandle == NULL) ||
            ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0)) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hNewHandle;
        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;
        HRESULT hRes;
        DWORD RetCode;

        //
        // Map Admin Handle to Actual Handle
        //

        RetCode = Lookup( hMDHandle,
                          &hActualHandle,
                          &HandleType );

        if( RetCode == ERROR_SUCCESS &&
            (HandleType == NSEPM_HANDLE || (HandleType == ALL_HANDLE  &&
             pszMDPath != NULL && strstr( (LPSTR)pszMDPath, "<nsepm>" )))) {

            //
            // call nse com api
            //

            hRes = m_pNseObject->ComMDOpenMetaObject( hActualHandle,
                                                      pszMDPath,
                                                      dwMDAccessRequested,
                                                      dwMDTimeOut,
                                                      &hNewHandle );

            if( FAILED(hRes) ) {
                return hRes;
            }

            hRes = AddNode(hNewHandle, NSEPM_HANDLE, phMDNewHandle);
            if (FAILED(hRes)) {
                m_pNseObject->ComMDCloseMetaObject( hActualHandle );
                return hRes;
            }

            fIsNse = TRUE;
        }
        else if( RetCode == ERROR_SUCCESS &&
                (HandleType == META_HANDLE || HandleType == ALL_HANDLE )) {

            //
            // call metadata com api
            //

            hRes = m_pMdObject->ComMDOpenMetaObject( hActualHandle,
                                                     pszMDPath,
                                                     dwMDAccessRequested,
                                                     dwMDTimeOut,
                                                     &hNewHandle );

            if( FAILED(hRes) ) {
                return hRes;
            }

            hRes = AddNode(hNewHandle, META_HANDLE, phMDNewHandle);
            if (FAILED(hRes)) {
                m_pMdObject->ComMDCloseMetaObject( hActualHandle );
                return hRes;
            }

            fIsNse = FALSE;
        }
        else {

            return RETURNCODETOHRESULT(RetCode);
        }

        if ( SUCCEEDED( hRes ) &&
             !AdminAclNotifyOpen( *phMDNewHandle,
                                  pszMDPath,
                                  fIsNse ) )
        {
            return RETURNCODETOHRESULT( GetLastError() );
        }

        return hRes;
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::CloseKey(
    /* [in] */ METADATA_HANDLE hMDHandle
    )
/*++

Routine Description:

    Closes a handle to a meta object.

Arguments:

    hMDHandle - open handle

Return Value:

    Status.

--*/
{
    DWORD dwTemp;
    HRESULT hRes = ERROR_SUCCESS;

    if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE)) {
        return E_HANDLE;
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        if ( !AdminAclNotifyClose( hMDHandle ) )
        {
            dwTemp = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::CloseKey] AdminAclNotifyClose failed, error %lx\n",
                    dwTemp ));
            return RETURNCODETOHRESULT(dwTemp);
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (dwTemp = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(dwTemp);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            hRes = m_pNseObject->ComMDCloseMetaObject( hActualHandle );

        }
        else {

            //
            // call metadata com api
            //

            hRes = m_pMdObject->ComMDCloseMetaObject( hActualHandle );
        }

        //
        // Remove node from handle table
        //
        if (SUCCEEDED(hRes)) {
            DeleteNode( hMDHandle );
        }
    }

    return hRes;
}

HRESULT STDMETHODCALLTYPE
CADMCOM::ChangePermissions(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [in] */ DWORD dwMDTimeOut,
    /* [in] */ DWORD dwMDAccessRequested)
/*++

Routine Description:

    Changes permissions on an open meta object handle.

Arguments:

    hMDHandle - handle to be modified

    dwMDTimeOut - time to block waiting for open to succeed, in miliseconds.

    dwMDAccessRequested - requested permissions

Return Value:

    Status.

--*/
{
    DWORD RetCode = ERROR_SUCCESS;
    METADATA_HANDLE hActualHandle;
    HANDLE_TYPE HandleType;

    //
    // Map Admin Handle to Actual Handle
    //

    if( (RetCode = Lookup( hMDHandle,
                           &hActualHandle,
                           &HandleType )) != ERROR_SUCCESS ) {
        return RETURNCODETOHRESULT(RetCode);
    }

    if( HandleType == NSEPM_HANDLE ) {

        //
        //
        // call nse com api
        //

        return m_pNseObject->ComMDChangePermissions( hActualHandle,
                                                     dwMDTimeOut,
                                                     dwMDAccessRequested );
    }
    else {

        //
        //
        // call metadata com api
        //

        return m_pMdObject->ComMDChangePermissions( hActualHandle,
                                                    dwMDTimeOut,
                                                    dwMDAccessRequested );
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::SaveData(
    )
/*++

Routine Description:

    Saves all data changed since the last load or save to permanent storage.

Arguments:

    None.

Return Value:

    Status.

--*/
{
    DWORD RetCode;
    HRESULT hRes;

    //
    // call metadata com api
    //

    hRes = m_pMdObject->ComMDSaveData();

    if (FAILED(hRes)) {
        return hRes;
    }

    //
    // call nse com api
    //

    return m_pNseObject->ComMDSaveData();
}

HRESULT STDMETHODCALLTYPE
CADMCOM::GetHandleInfo(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo
    )
/*++

Routine Description:

    Gets the information associated with a handle.

Arguments:

    hMDHandle - handle to get information about

    pmdhiInfo - structure filled in with the information

Return Value:

    Status.

--*/
{
    DWORD RetCode = ERROR_SUCCESS;

    if (pmdhiInfo == NULL) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

           //
           // call nse com api
           //

           return m_pNseObject->ComMDGetHandleInfo( hActualHandle,
                                                    pmdhiInfo );
        }
        else {

           //
           // call metadata com api
           //

           return m_pMdObject->ComMDGetHandleInfo( hActualHandle,
                                                   pmdhiInfo );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::GetSystemChangeNumber(
    /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber
    )
/*++

Routine Description:

    Gets the System Change Number.

Arguments:

    pdwSystemChangeNumber - system change number

Return Value:

    Status.

--*/
{
    DWORD RetCode = ERROR_SUCCESS;

    if (pdwSystemChangeNumber == NULL) {
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        //
        // call metadata com api
        //

        return m_pMdObject->ComMDGetSystemChangeNumber( pdwSystemChangeNumber );
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::GetDataSetNumber(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber
    )
/*++

Routine Description:

    Gets all the data set number associated with a Meta Object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pdwMDDataSetNumber - number associated with this data set

Return Value:

    Status.

--*/
{
    DWORD RetCode;

    if (pdwMDDataSetNumber == NULL){
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_READ ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::GetDataSetNumber] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDGetDataSetNumber( hActualHandle,
                                                        pszMDPath,
                                                        pdwMDDataSetNumber );
        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDGetDataSetNumber( hActualHandle,
                                                       pszMDPath,
                                                       pdwMDDataSetNumber );
        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::ReleaseReferenceData(
    /* [in] */ DWORD dwMDDataTag
    )
/*++

Routine Description:

    Releases data gotten by reference via the GetData, EnumMetadata, or GetAllMetadata.

Arguments:

    dwMDDataTag - The tag returned with the data.

Return Value:

    Status.

--*/
{
    DWORD RetCode = ERROR_SUCCESS;

    if (dwMDDataTag == 0){
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        //
        // call metadata com api
        //

        return m_pMdObject->ComMDReleaseReferenceData( dwMDDataTag );

    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::SetLastChangeTime(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime,
    /* [in] */ BOOL bLocalTime)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the affected meta object

    pftMDLastChangeTime - new change time for the meta object

Return Value:

    Status.

--*/
{
    DWORD RetCode = ERROR_SUCCESS;
    FILETIME ftTime;
    FILETIME *pftTime = pftMDLastChangeTime;

    if (pftMDLastChangeTime == NULL){
        RetCode = ERROR_INVALID_PARAMETER;
        return RETURNCODETOHRESULT(RetCode);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_WRITE ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::SetLastChangeTime] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if (bLocalTime) {
            if (!LocalFileTimeToFileTime(pftMDLastChangeTime, &ftTime)) {
                return RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }
            pftTime = &ftTime;
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            return m_pNseObject->ComMDSetLastChangeTime( hActualHandle,
                                                         pszMDPath,
                                                         pftTime );

        }
        else {

            //
            // call metadata com api
            //

            return m_pMdObject->ComMDSetLastChangeTime( hActualHandle,
                                                        pszMDPath,
                                                        pftTime );

        }
    }
}

HRESULT STDMETHODCALLTYPE
CADMCOM::GetLastChangeTime(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime,
    /* [in] */ BOOL bLocalTime)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - open handle

    pszMDPath - path of the affected meta object

    pftMDLastChangeTime - place to return the change time for the meta object

Return Value:

    Status.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    DWORD RetCode = ERROR_SUCCESS;
    FILETIME ftTime;

    if (pftMDLastChangeTime == NULL){
        return RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {

        METADATA_HANDLE hActualHandle;
        HANDLE_TYPE HandleType;

        //
        // Access check
        //

        if ( !AdminAclAccessCheck( m_pMdObject,
                                   hMDHandle,
                                   pszMDPath,
                                   0,
                                   METADATA_PERMISSION_READ ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOM::GetLastChangeTime] AdminAclAccessCheck failed, error %lx\n",
                    GetLastError() ));
            return RETURNCODETOHRESULT( GetLastError() );
        }

        //
        // Map Admin Handle to Actual Handle
        //

        if( (RetCode = Lookup( hMDHandle,
                               &hActualHandle,
                               &HandleType )) != ERROR_SUCCESS ) {
            return RETURNCODETOHRESULT(RetCode);
        }

        if( HandleType == NSEPM_HANDLE ) {

            //
            // call nse com api
            //

            hresReturn = m_pNseObject->ComMDGetLastChangeTime( hActualHandle,
                                                         pszMDPath,
                                                         &ftTime );

        }
        else {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDGetLastChangeTime( hActualHandle,
                                                        pszMDPath,
                                                        &ftTime );

        }

        if (bLocalTime) {
            if (!FileTimeToLocalFileTime(&ftTime, pftMDLastChangeTime)) {
                hresReturn = E_UNEXPECTED;
            }
        }
        else {
            *pftMDLastChangeTime = ftTime;
        }
    }
    return hresReturn;
}



DWORD
CADMCOM::Lookup(
    IN METADATA_HANDLE hHandle,
    OUT METADATA_HANDLE *hActHandle,
    OUT HANDLE_TYPE *HandleType
    )
{
    HANDLE_TABLE *phtNode;
    DWORD dwReturn = ERROR_INVALID_HANDLE;

    if( hHandle == METADATA_MASTER_ROOT_HANDLE ) {
        *hActHandle = g_MasterRoot.hActualHandle;
        *HandleType = g_MasterRoot.HandleType;
        dwReturn = ERROR_SUCCESS;
    }
    else {
        m_rHandleResource.Lock(TSRES_LOCK_READ);

        for( phtNode = m_hashtab[(DWORD)hHandle % HASHSIZE]; phtNode != NULL;
             phtNode = phtNode->next ) {

            if( phtNode->hAdminHandle == hHandle ) {
                *hActHandle = phtNode->hActualHandle;
                *HandleType = phtNode->HandleType;
                dwReturn = ERROR_SUCCESS;
                break;
            }
        }

        m_rHandleResource.Unlock();
    }
    return dwReturn;
}


DWORD
CADMCOM::LookupActualHandle(
    IN METADATA_HANDLE hHandle
    )
{
    HANDLE_TABLE *phtNode;
    DWORD i;
    DWORD dwReturn = ERROR_INVALID_HANDLE;

    m_rHandleResource.Lock(TSRES_LOCK_READ);

    for( i = 0; (i < HASHSIZE) && (dwReturn != ERROR_SUCCESS); i++ ) {
        for( phtNode = m_hashtab[i]; (phtNode != NULL) && (dwReturn != ERROR_SUCCESS); phtNode = phtNode->next ) {
            if( phtNode->hActualHandle == hHandle ) {
                dwReturn = ERROR_SUCCESS;
            }
        }
    }

    m_rHandleResource.Unlock();
    return dwReturn;
}

HRESULT
CADMCOM::AddNode(
    METADATA_HANDLE hHandle,
    enum HANDLE_TYPE HandleType,
    PMETADATA_HANDLE phAdminHandle
    )
{
    HANDLE_TABLE *phtNode;
    DWORD hashVal;
    HRESULT hresReturn = ERROR_SUCCESS;

    m_rHandleResource.Lock(TSRES_LOCK_WRITE);

    phtNode = (HANDLE_TABLE *)LocalAlloc(LMEM_FIXED, sizeof(*phtNode));

    if( phtNode == NULL ) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        phtNode->hAdminHandle = m_dwHandleValue;
        *phAdminHandle = m_dwHandleValue++;
        phtNode->hActualHandle = hHandle;
        phtNode->HandleType = HandleType;
        hashVal = (phtNode->hAdminHandle) % HASHSIZE;
        phtNode->next = m_hashtab[hashVal];
        m_hashtab[hashVal] = phtNode;
    }

    m_rHandleResource.Unlock();

    return hresReturn;
}

DWORD
CADMCOM::DeleteNode(
    METADATA_HANDLE hHandle
    )
{
    HANDLE_TABLE *phtNode;
    HANDLE_TABLE *phtDelNode;
    DWORD HashValue = (DWORD)hHandle % HASHSIZE;

    if( hHandle == METADATA_MASTER_ROOT_HANDLE ) {
        return ERROR_SUCCESS;
    }

    m_rHandleResource.Lock(TSRES_LOCK_WRITE);

    phtNode = m_hashtab[HashValue];

    //
    // check single node linked list
    //

    if( phtNode->hAdminHandle == hHandle ) {
        m_hashtab[HashValue] = phtNode->next;
        LocalFree(phtNode);
    }
    else {

        for( ; phtNode != NULL; phtNode = phtNode->next ) {

            phtDelNode = phtNode->next;
            if( phtDelNode != NULL ) {

                if( phtDelNode->hAdminHandle == hHandle ) {
                    phtNode->next = phtDelNode->next;
                }

                LocalFree(phtDelNode);
                break;
            }
        }
    }

    m_rHandleResource.Unlock();
    return ERROR_SUCCESS;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COPaper::NotifySinks

  Summary:  Internal utility method of this COM object used to fire event
            notification calls to all listening connection sinks in the
            client.

  Args:     PAPER_EVENT PaperEvent
              Type of notification event.
            SHORT nX
              X cordinate. Value is 0 unless event needs it.
            SHORT nY
              Y cordinate. Value is 0 unless event needs it.
            SHORT nInkWidth
              Ink Width. Value is 0 unless event needs it.
            SHORT crInkColor
              COLORREF RGB color value. Value is 0 unless event needs it.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT
CADMCOM::NotifySink(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [in] */ DWORD dwMDNumElements,
    /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{

//  DBGPRINTF(( DBG_CONTEXT, "[CADMCOM::NotifySink]\n" ));

  HRESULT hr = NOERROR;
  IConnectionPoint* pIConnectionPoint;
  IEnumConnections* pIEnum;
  CONNECTDATA ConnData;
  HRESULT hrTemp;
  HANDLE_TABLE *node;

  //
  // if the meta handle is for this object, return ERROR_SUCCESS to
  // the caller (admin's sink);
  //

  if( LookupActualHandle( hMDHandle ) == ERROR_SUCCESS ) {
      return ERROR_SUCCESS;
  }

  //
  // Correct broken connections.
  // It's not likely to be a high number so
  // save a memory allocation by using an array.
  //
  DWORD pdwLostConnections[10];
  DWORD dwNumLostConnections = 0;


  // If there was a paper event, broadcast appropriate notifications to
  // all Sinks connected to each connection point.
//  if (PAPER_EVENT_NONE != PaperEvent)
  {
      // Here is the section for the PaperSink connection point--currently
      // this is the only connection point offered by COPaper objects.
      pIConnectionPoint = m_aConnectionPoints[ADM_CONNPOINT_WRITESINK];
      if (NULL != pIConnectionPoint)
      {
          pIConnectionPoint->AddRef();
          m_rSinkResource.Lock(TSRES_LOCK_READ);
          hr = pIConnectionPoint->EnumConnections(&pIEnum);
          if (SUCCEEDED(hr)) {
              // Loop thru the connection point's connections and if the
              // listening connection supports IPaperSink (ie, PaperSink events)
              // then dispatch the PaperEvent event notification to that sink.
              while (NOERROR == pIEnum->Next(1, &ConnData, NULL))
              {
                IMSAdminBaseSink* pIADMCOMSINK;

                hr = ConnData.pUnk->QueryInterface(
                                      IID_IMSAdminBaseSink,
                                      (PPVOID)&pIADMCOMSINK);
                if (SUCCEEDED(hr))
                {
                    hrTemp = pIADMCOMSINK->SinkNotify(dwMDNumElements,
                                                            pcoChangeList);
                    pIADMCOMSINK->Release();
                    if (FAILED(hrTemp)) {
                        if ((HRESULT_CODE(hrTemp) == RPC_S_SERVER_UNAVAILABLE) ||
                            ((HRESULT_CODE(hrTemp) >= RPC_S_NO_CALL_ACTIVE) &&
                                (HRESULT_CODE(hrTemp) <= RPC_S_CALL_FAILED_DNE))) {
                            if (dwNumLostConnections < 10) {
                                pdwLostConnections[dwNumLostConnections++] = ConnData.dwCookie;
                            }
                        }
                    }
                }
                ConnData.pUnk->Release();
              }
              pIEnum->Release();
          }
          m_rSinkResource.Unlock();
          while (dwNumLostConnections > 0) {
              pIConnectionPoint->Unadvise(pdwLostConnections[--dwNumLostConnections]);
          }
          pIConnectionPoint->Release();
      }
  }

  return hr;
}

//
// Stubs for routine that clients shouldn't be calling anyway.
//

HRESULT
CADMCOM::KeyExchangePhase1()
{
    return E_FAIL;
}

HRESULT
CADMCOM::KeyExchangePhase2()
{
    return E_FAIL;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\inc\secpriv.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    secpriv.y

Abstract:

    This module contains private function prototypes exported by the
    ADMPROX proxy DLL for the exclusive use of the COADMIN server
    implementation.

Author:

    Keith Moore (keithmo)        25-Feb-1997

Revision History:

--*/


#ifndef _SECPRIV_H_
#define _SECPRIV_H_


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Function to release the security context for a given object. The
// server is expected to call this routine from within the object's
// destructor.
//

VOID
WINAPI
ReleaseObjectSecurityContextA(
    IUnknown * Object
    );

VOID
WINAPI
ReleaseObjectSecurityContextW(
    IUnknown * Object
    );

typedef
VOID
(WINAPI * LPFN_RELEASE_OBJECT_SECURITY_CONTEXT)(
    IUnknown * Object
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif  // _SECPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    DLL startup routine.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <dbgutil.h>

}   // extern "C"

#include <iadmw.h>
#include <icrypt.hxx>
#include <secdat.hxx>


//
// Private globals.
//

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisAdmWProxGuid, 
0x784d8923, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

extern "C" void InitializeIISRTL2();
extern "C" void TerminateIISRTL2();
#endif

//
// Private prototypes.
//


//
// DLL Entrypoint.
//

extern "C" {

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    BOOL status = TRUE;

    switch( dwReason ) {

    case DLL_PROCESS_ATTACH :
        INITIALIZE_PLATFORM_TYPE();
#ifdef _NO_TRACING_
        SET_DEBUG_FLAGS(DEBUG_ERROR);
        CREATE_DEBUG_PRINT_OBJECT( "admwprox" );
#else
        // This needs to be called to initialize the Critical Section which
        // is used by the CREATE_DEBUG_PRINT_OBJECT
        InitializeIISRTL2();
        // NOTE: Now you might be wondering why this needs to do an initialize. 
        // This is because this module links with iisrtl2.lib, not with 
        // iisrtl.lib and hence not with iisrtl.dll. So in order for tracing 
        // to get started this needs to do the initialize.
        CREATE_DEBUG_PRINT_OBJECT( "admwprox", IisAdmWProxGuid);
//        CREATE_INITIALIZE_DEBUG();
#endif
        status = ADM_SECURE_DATA::Initialize( hDll );
        ADM_GUID_MAP::Initialize();
        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH :
        ADM_GUID_MAP::Terminate();
        ADM_SECURE_DATA::Terminate();
        DELETE_DEBUG_PRINT_OBJECT();
#ifndef _NO_TRACING_
        // This needs to be called to remove the Critical Section which
        // was used by the DELETE_DEBUG_PRINT_OBJECT
        TerminateIISRTL2();
#endif
        break;

    }

    return status;

}   // DLLEntry

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME   = iadmw
IDL_FLAGS       = /I $(BASEDIR)\public\sdk\inc /I..\..\metadata\interfac -DREGISTER_PROXY_DLL


SDKINC          = $(BASEDIR)\public\sdk\inc

INCS            = -I. -I..\..\..\..\inc

CLIENT_STUB     =$(O)\$(IDL_FILE_NAME)_i.c
SERVER_STUB     =$(O)\$(IDL_FILE_NAME)_p.c
DLL_STUB        =$(O)\dlldata.c
HEADER_FILE     =$(IISBASEDIR)\inc\$(O)\$(IDL_FILE_NAME).h

CLIENT_TARGETS  = $(CLIENT_STUB) \

SERVER_TARGETS  = $(SERVER_STUB) \

DLL_TARGETS     = $(DLL_STUB) \

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)  \
                  $(HEADER_FILE) $(DLL_TARGETS)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES) -DMIDL_PASS

MSC_WARNING_LEVEL= /W3 /WX

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delsrc all

delsrc:
        -erase $(TARGETS)

#
#  MIDL Compile stuff
#
$(HEADER_FILE) $(CLIENT_TARGETS) $(SERVER_TARGETS) $(DLL_TARGETS):  .\$(IDL_FILE_NAME).idl
    midl -no_stamp -Oicf -error allocation -error ref -h $(HEADER_FILE) -iid $(CLIENT_STUB) -proxy $(SERVER_STUB) -dlldata $(DLL_STUB) $(IDL_FLAGS) $(CPP) $(INCS) .\$(IDL_FILE_NAME).idl
    munge postmidl.scr -t $(HEADER_FILE) >nul
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interfac\iadmxp.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iadmxp.c

Abstract:

    Wrapper around the MIDL-generated IADM_P.C. This wrapper allows us
    to "hook" the RPC-runtime-supplied IUnknown_Release_Proxy used in
    the client-side object's VTable. We need to hook this method so
    we may determine the exact lifetime of the client-side object. We
    need the exact lifetime so we can know when to destroy the security
    context we associate with each object.

    Hooked_IUnknown_Release_Proxy is implemented in SECURITY.CXX.

Author:

    Keith Moore (keithmo)       29-Feb-1997

Revision History:

--*/

#define IUnknown_Release_Proxy Hooked_IUnknown_Release_Proxy
#include "iadm_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\secdat.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    secdat.cxx

Abstract:

    This module implements the ADM_SECURE_DATA class.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ole2.h>
#include <windows.h>

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include <dbgutil.h>
#include <iadmw.h>
#include <icrypt.hxx>
#include <secdat.hxx>


//
// Private constants.
//

#define FREE_BLOB(blob)                                                 \
            if( blob != NULL ) {                                        \
                HRESULT _res;                                           \
                _res = ::IISCryptoFreeBlob( blob );                     \
                DBG_ASSERT( SUCCEEDED(_res) );                          \
            } else

#if DBG
#define ENABLE_ADM_COUNTERS 1
#define ADM_NOISY           0
#else
#define ENABLE_ADM_COUNTERS 0
#define ADM_NOISY           0
#endif

#if ADM_NOISY
#define NOISYPRINTF(x) DBGPRINTF(x)
#else
#define NOISYPRINTF(x)
#endif


//
// Private types.
//

#if ENABLE_ADM_COUNTERS

typedef struct _ADM_COUNTERS {
    LONG ObjectsCreated;
    LONG ObjectsDestroyed;
} ADM_COUNTERS, *PADM_COUNTERS;

#define DECLARE_ADM_COUNTERS() ADM_COUNTERS g_AdmCounters

#define UpdateObjectsCreated() InterlockedIncrement( &g_AdmCounters.ObjectsCreated )
#define UpdateObjectsDestroyed() InterlockedIncrement( &g_AdmCounters.ObjectsDestroyed )

#else

#define DECLARE_ADM_COUNTERS()

#define UpdateObjectsCreated()
#define UpdateObjectsDestroyed()

#endif


//
// Private globals.
//

LIST_ENTRY ADM_SECURE_DATA::sm_ServerSecureDataListHead;
LIST_ENTRY ADM_SECURE_DATA::sm_ClientSecureDataListHead;
LIST_ENTRY ADM_GUID_MAP::sm_GuidMapListHead;
CRITICAL_SECTION ADM_SECURE_DATA::sm_ServerSecureDataLock;
CRITICAL_SECTION ADM_SECURE_DATA::sm_ClientSecureDataLock;
CRITICAL_SECTION ADM_GUID_MAP::sm_GuidMapDataLock;
#if DBG
DWORD ADM_SECURE_DATA::sm_ServerSecureDataLockOwner;
DWORD ADM_SECURE_DATA::sm_ClientSecureDataLockOwner;
DWORD ADM_GUID_MAP::sm_GuidMapLockOwner;
PTRACE_LOG ADM_SECURE_DATA::sm_RefTraceLog;
PTRACE_LOG ADM_GUID_MAP::sm_RefTraceLog;
#endif
HCRYPTPROV ADM_SECURE_DATA::sm_ServerCryptoProvider;
HCRYPTPROV ADM_SECURE_DATA::sm_ClientCryptoProvider;

DECLARE_ADM_COUNTERS();

//
// ADM_SECURE_DATA methods.
//


ADM_SECURE_DATA::ADM_SECURE_DATA(
    IN IUnknown * Object,
    IN GUID guidServer,
    IN BOOL bServer
    ) :
    m_Object( Object ),
    m_KeyExchangeClient( NULL ),
    m_KeyExchangeServer( NULL ),
    m_SendCryptoStorage( NULL ),
    m_ReceiveCryptoStorage( NULL ),
    m_ReferenceCount( 1 ),
    m_guidServer(guidServer),
    m_bIsServer(bServer)
/*++

Routine Description:

    ADM_SECURE_DATA object constructor.

Arguments:

    Object - Pointer to the object to associate.

Return Value:

    None.

--*/
{
    NOISYPRINTF((
        DBG_CONTEXT,
        "ADM_SECURE_DATA: creating %08lx,%08lx\n",
        this,
        Object
        ));

    //
    // Sanity check.
    //

    DBG_ASSERT( (Object != NULL) || !bServer );

    //
    // Initialize any complex data members.
    //

    INITIALIZE_CRITICAL_SECTION( &m_ObjectLock );

    //
    // Put ourselves on the list.
    //

    if (bServer) {
        AcquireServerDataLock();
        InsertHeadList( &sm_ServerSecureDataListHead, &m_SecureDataListEntry );
        ReleaseServerDataLock();
    }
    else {
        AcquireClientDataLock();
        InsertHeadList( &sm_ClientSecureDataListHead, &m_SecureDataListEntry );
        ReleaseClientDataLock();
        //
        // Clients lifespan is controlled by ADM_GUID_MAP
        //
        m_ReferenceCount = 0;
    }

    UpdateObjectsCreated();

}   // ADM_SECURE_DATA::ADM_SECURE_DATA


ADM_SECURE_DATA::~ADM_SECURE_DATA()
/*++

Routine Description:

    ADM_SECURE_DATA object destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

    NOISYPRINTF((
        DBG_CONTEXT,
        "~ADM_SECURE_DATA: destroying %08lx,%08lx\n",
        this,
        m_Object
        ));

    //
    // Sanity check.
    //

    DBG_ASSERT( m_ReferenceCount == 0 );

    //
    // Cleanup.
    //

    CleanupCryptoData();

    if (m_bIsServer) {
        AcquireServerDataLock();
        RemoveEntryList( &m_SecureDataListEntry );
        ReleaseServerDataLock();
    }
    else {
        AcquireClientDataLock();
        RemoveEntryList( &m_SecureDataListEntry );
        ReleaseClientDataLock();
    }

    DeleteCriticalSection( &m_ObjectLock );
    UpdateObjectsDestroyed();

    m_Object = NULL;

}   // ADM_SECURE_DATA::~ADM_SECURE_DATA


BOOL
ADM_SECURE_DATA::Initialize(
    HINSTANCE hDll
    )
/*++

Routine Description:

    Initializes static global data private to ADM_SECURE_DATA.

Arguments:

    hDll - Handle to this DLL.

Return Value:

    None.

--*/
{

    HRESULT result;

    //
    // Initialize the crypto stuff.
    //

    result = ::IISCryptoInitialize();

    if( SUCCEEDED(result) ) {

        INITIALIZE_CRITICAL_SECTION( &sm_ServerSecureDataLock );
        INITIALIZE_CRITICAL_SECTION( &sm_ClientSecureDataLock );

#if DBG
        sm_ServerSecureDataLockOwner = 0;
        sm_ClientSecureDataLockOwner = 0;
        sm_RefTraceLog = CreateRefTraceLog( 1024, 0 );
#endif

        InitializeListHead( &sm_ServerSecureDataListHead );
        InitializeListHead( &sm_ClientSecureDataListHead );

    } else {
        DBGPRINTF((
            DBG_CONTEXT,
            "ADM_SECURE_DATA::Initialize: error %lx\n",
            result
            ));
    }

    return SUCCEEDED(result);

}   // ADM_SECURE_DATA::Initialize


VOID
ADM_SECURE_DATA::Terminate()
/*++

Routine Description:

    Terminates static global data private to ADM_SECURE_DATA.

Arguments:

    None.

Return Value:

    None.

--*/
{

    PLIST_ENTRY entry;
    ADM_SECURE_DATA * data;
    HRESULT result;

    //
    // Free any secure data objects on our list.
    //

    AcquireServerDataLock();

    entry = sm_ServerSecureDataListHead.Flink;

    while( entry != &sm_ServerSecureDataListHead ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_SECURE_DATA,
                   m_SecureDataListEntry
                   );
        entry = entry->Flink;

        data->Dereference();

    }
    ReleaseServerDataLock();

    AcquireClientDataLock();
    entry = sm_ClientSecureDataListHead.Flink;

    while( entry != &sm_ClientSecureDataListHead ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_SECURE_DATA,
                   m_SecureDataListEntry
                   );
        entry = entry->Flink;

        data->Dereference();

    }

    ReleaseClientDataLock();

    DBG_ASSERT( IsListEmpty( &sm_ServerSecureDataListHead ) );
    DBG_ASSERT( IsListEmpty( &sm_ClientSecureDataListHead ) );

    //
    // Terminate the crypto stuff.
    //

    if( sm_ServerCryptoProvider != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( sm_ServerCryptoProvider );
        DBG_ASSERT( SUCCEEDED(result) );
        sm_ServerCryptoProvider = CRYPT_NULL;
    }

    if( sm_ClientCryptoProvider != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( sm_ClientCryptoProvider );
        DBG_ASSERT( SUCCEEDED(result) );
        sm_ClientCryptoProvider = CRYPT_NULL;
    }

    result = ::IISCryptoTerminate();
    DBG_ASSERT( SUCCEEDED(result) );

    //
    // Final cleanup.
    //

    DeleteCriticalSection( &sm_ServerSecureDataLock );
    DeleteCriticalSection( &sm_ClientSecureDataLock );

#if DBG
    if( sm_RefTraceLog != NULL ) {
        DestroyRefTraceLog( sm_RefTraceLog );
    }
#endif

}   // ADM_SECURE_DATA::Terminate


ADM_SECURE_DATA *
ADM_SECURE_DATA::FindAndReferenceServerSecureData(
    IN IUnknown * Object,
    IN BOOL CreateIfNotFound
    )
/*++

Routine Description:

    Finds the ADM_SECURE_DATA object associated with Object. If it
    cannot be found, then a new ADM_SECURE_DATA object is created
    and put on the global list.

Arguments:

    Object - The object to search for.

    CreateIfNotFound - If the object is not on the list, a new association
        will only be created if this flag is TRUE.

Return Value:

    ADM_SECURE_DATA * - Pointer to the ADM_SECURE_DATA object if
        successful, NULL otherwise.

--*/
{

    PLIST_ENTRY entry;
    ADM_SECURE_DATA * data;

    AcquireServerDataLock();

    for( entry = sm_ServerSecureDataListHead.Flink ;
         entry != &sm_ServerSecureDataListHead ;
         entry = entry->Flink ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_SECURE_DATA,
                   m_SecureDataListEntry
                   );

        if( data->m_Object == Object ) {

            data->Reference();
            ReleaseServerDataLock();
            return data;

        }

    }

    data = NULL;
    if( CreateIfNotFound ) {

        GUID guidServer;
        HRESULT hresError;

        hresError = CoCreateGuid(&guidServer);

        if (SUCCEEDED(hresError)) {
            data = new ADM_SECURE_DATA( Object,
                                        guidServer,
                                        TRUE );

            if( data == NULL ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "ADM_SECURE_DATA::FindAndReferenceServerSecureData: out of memory\n"
                    ));

            } else {

                data->Reference();

            }
        }
        else {
            DBGPRINTF((
                DBG_CONTEXT,
                "ADM_SECURE_DATA::FindAndReferenceServerSecureData: CoCreateGuid failed\n"
                ));
        }
    }

    ReleaseServerDataLock();
    return data;

}   // ADM_SECURE_DATA::FindAndReferenceServerSecureData


ADM_SECURE_DATA *
ADM_SECURE_DATA::FindAndReferenceClientSecureData(
    IN IUnknown * Object,
    IN BOOL CreateIfNotFound,
    IN ADM_GUID_MAP *pguidmapRelated
    )
/*++

Routine Description:

    Finds the ADM_SECURE_DATA object associated with Object. If it
    cannot be found, then a new ADM_SECURE_DATA object is created
    and put on the global list.

Arguments:

    Object - The object to search for.

    CreateIfNotFound - If the object is not on the list, a new association
        will only be created if this flag is TRUE.

Return Value:

    ADM_SECURE_DATA * - Pointer to the ADM_SECURE_DATA object if
        successful, NULL otherwise.

--*/
{

    PLIST_ENTRY entry;
    ADM_SECURE_DATA * data = NULL;
    ADM_GUID_MAP *pguidmapData = pguidmapRelated;

    AcquireClientDataLock();


    if (pguidmapData == NULL) {

        pguidmapData = ADM_GUID_MAP::FindAndReferenceGuidMap(Object,
                                                             CreateIfNotFound);
    }

    if (pguidmapData != NULL) {

        for( entry = sm_ClientSecureDataListHead.Flink ;
             entry != &sm_ClientSecureDataListHead ;
             entry = entry->Flink ) {

            data = CONTAINING_RECORD(
                       entry,
                       ADM_SECURE_DATA,
                       m_SecureDataListEntry
                       );

            DBG_ASSERT(data->m_guidServer != GUID_NULL);
            if( data->m_guidServer == pguidmapData->GetGuid() ) {

                data->Reference();
                break;

            }

        }

        if (entry == &sm_ClientSecureDataListHead) {
            if(  CreateIfNotFound ) {

                data = new ADM_SECURE_DATA( NULL,
                                            pguidmapData->GetGuid(),
                                            FALSE );

                if( data == NULL ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "ADM_SECURE_DATA::FindAndReferenceClientSecureData: out of memory\n"
                        ));

                } else {

                    data->Reference();

                }

            } else {

                data = NULL;
            }
        }

        if (pguidmapRelated == NULL) {
            pguidmapData->Dereference();
        }
    }

    ReleaseClientDataLock();
    return data;

}   // ADM_SECURE_DATA::FindAndReferenceSecureData


HRESULT
ADM_SECURE_DATA::GetClientSendCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** SendCryptoStorage,
    IN  IUnknown * Object
    )
/*++

Routine Description:

    Retrieves the client-side IIS_CRYPTO_STORAGE object to be used for
    sending data to the server. This routine will perform the client-side
    key exchange if necessary.

Arguments:

    SendCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( SendCryptoStorage != NULL );

    //
    // Do that key exchange thang if we don't yet have it.
    //

    if( m_KeyExchangeClient == NULL ) {

        LockThis();

        if( m_KeyExchangeClient == NULL ) {

            result = DoClientSideKeyExchange(Object);

            if( FAILED(result) ) {

                UnlockThis();
                return result;

            }

        }

        UnlockThis();

    }

    DBG_ASSERT( m_SendCryptoStorage != NULL );

    *SendCryptoStorage = m_SendCryptoStorage;
    return NO_ERROR;

}   // ADM_SECURE_DATA::GetClientSendCryptoStorage


HRESULT
ADM_SECURE_DATA::GetClientReceiveCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** ReceiveCryptoStorage,
    IUnknown * Object
    )
/*++

Routine Description:

    Retrieves the client-side IIS_CRYPTO_STORAGE object to be used for
    receiving data from the server. This routine will perform the
    client-side key exchange if necessary.

Arguments:

    ReceiveCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ReceiveCryptoStorage != NULL );

    //
    // Do that key exchange thang if we don't yet have it.
    //

    if( m_KeyExchangeClient == NULL ) {

        LockThis();

        if( m_KeyExchangeClient == NULL ) {

            result = DoClientSideKeyExchange(Object);

            if( FAILED(result) ) {

                UnlockThis();
                return result;

            }

        }

        UnlockThis();

    }

    DBG_ASSERT( m_ReceiveCryptoStorage != NULL );

    *ReceiveCryptoStorage = m_ReceiveCryptoStorage;
    return NO_ERROR;

}   // ADM_SECURE_DATA::GetClientReceiveCryptoStorage


HRESULT
ADM_SECURE_DATA::GetServerSendCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** SendCryptoStorage
    )
/*++

Routine Description:

    Retrieves the server-side IIS_CRYPTO_STORAGE object to be used for
    sending data to the client.

Arguments:

    SendCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    if( m_SendCryptoStorage != NULL ) {

        *SendCryptoStorage = m_SendCryptoStorage;
        return NO_ERROR;

    }

    return MD_ERROR_SECURE_CHANNEL_FAILURE;

}   // ADM_SECURE_DATA::GetServerSendCryptoStorage


HRESULT
ADM_SECURE_DATA::GetServerReceiveCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** ReceiveCryptoStorage
    )
/*++

Routine Description:

    Retrieves the server-side IIS_CRYPTO_STORAGE object to be used for
    receiving data from the client.

Arguments:

    ReceiveCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    if( m_ReceiveCryptoStorage != NULL ) {

        *ReceiveCryptoStorage = m_ReceiveCryptoStorage;
        return NO_ERROR;

    }

    return MD_ERROR_SECURE_CHANNEL_FAILURE;

}   // ADM_SECURE_DATA::GetServerReceiveCryptoStorage


HRESULT
ADM_SECURE_DATA::DoClientSideKeyExchange(
    IUnknown * Object
    )
/*++

Routine Description:

    Performs all the client-side magic necessary to exchange session
    keys with the server.

Arguments:

    None.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;
    HCRYPTPROV prov;
    IIS_CRYPTO_EXCHANGE_CLIENT * keyExchangeClient;
    IIS_CRYPTO_BLOB *clientKeyExchangeKeyBlob;
    IIS_CRYPTO_BLOB *clientSignatureKeyBlob;
    IIS_CRYPTO_BLOB *clientSessionKeyBlob;
    IIS_CRYPTO_BLOB *clientHashBlob;
    IIS_CRYPTO_BLOB *serverKeyExchangeKeyBlob;
    IIS_CRYPTO_BLOB *serverSignatureKeyBlob;
    IIS_CRYPTO_BLOB *serverSessionKeyBlob;
    IIS_CRYPTO_BLOB *serverHashBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( Object != NULL );
    DBG_ASSERT( m_KeyExchangeClient == NULL );
    DBG_ASSERT( m_SendCryptoStorage == NULL );
    DBG_ASSERT( m_ReceiveCryptoStorage == NULL );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    keyExchangeClient = NULL;
    clientKeyExchangeKeyBlob = NULL;
    clientSignatureKeyBlob = NULL;
    clientSessionKeyBlob = NULL;
    clientHashBlob = NULL;
    serverKeyExchangeKeyBlob = NULL;
    serverSignatureKeyBlob = NULL;
    serverSessionKeyBlob = NULL;
    serverHashBlob = NULL;

    HANDLE hToken = NULL;

    if (OpenThreadToken( GetCurrentThread(), MAXIMUM_ALLOWED, TRUE, &hToken ) ) {
        RevertToSelf();
    }
    //
    // Get the crypto provider to use.
    //

    DBG_CODE( prov = CRYPT_NULL );

    result = GetClientCryptoProvider( &prov );

    if( FAILED(result) ) {
        goto cleanup;
    }

    DBG_ASSERT( prov != CRYPT_NULL );

    //
    // Create & initialize the client-side key exchange object.
    //
    // N.B. Do not set the m_KeyExchangeClient to a non-NULL value
    // until key exchange is complete.
    //

    keyExchangeClient = new IIS_CRYPTO_EXCHANGE_CLIENT;

    if( keyExchangeClient == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = keyExchangeClient->Initialize(
                 prov,                      // hProv
                 CRYPT_NULL,                // hKeyExchangeKey
                 CRYPT_NULL,                // hSignatureKey
                 TRUE                       // fUseMachineKeyset was FALSE before fix for  213126
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Phase 1: Get the client's key exchange and signature key blobs,
    // send them to the server, and get the server's key exchange,
    // signature, and session key blobs.
    //

    result = keyExchangeClient->ClientPhase1(
                 &clientKeyExchangeKeyBlob,
                 &clientSignatureKeyBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    result = IMSAdminBaseW_R_KeyExchangePhase1_Proxy(
                 (IMSAdminBaseW *)Object,
                 clientKeyExchangeKeyBlob,
                 clientSignatureKeyBlob,
                 &serverKeyExchangeKeyBlob,
                 &serverSignatureKeyBlob,
                 &serverSessionKeyBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Phase 2: Import the server's key exchange, signature, and session
    // key blobs, get the client's session key and hash blobs, send them
    // to the server, and get the server's hash blob.
    //

    result = keyExchangeClient->ClientPhase2(
                 serverKeyExchangeKeyBlob,
                 serverSignatureKeyBlob,
                 serverSessionKeyBlob,
                 &clientSessionKeyBlob,
                 &clientHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    result = IMSAdminBaseW_R_KeyExchangePhase2_Proxy(
                 (IMSAdminBaseW *)Object,
                 clientSessionKeyBlob,
                 clientHashBlob,
                 &serverHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Phase 3: Import the server's hash blob.
    //

    result = keyExchangeClient->ClientPhase3(
                 serverHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // OK, the key exchange is complete. We just need to create the
    // appropriate storage objects.
    //

    m_SendCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_SendCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_SendCryptoStorage->Initialize(
                 keyExchangeClient->QueryProviderHandle(),      // hProv
                 keyExchangeClient->AssumeClientSessionKey(),   // hSessionKey
                 CRYPT_NULL,                                    // hKeyExchangeKey
                 CRYPT_NULL,                                    // hSignatureKey
                 TRUE                                            // fUseMachineKeyset was FALSE before fix for  213126
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    m_ReceiveCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_ReceiveCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_ReceiveCryptoStorage->Initialize(
                 keyExchangeClient->QueryProviderHandle(),        // hProv
                 keyExchangeClient->AssumeServerSessionKey(),     // hSessionKey
                 CRYPT_NULL,                                      // hKeyExchangeKey
                 keyExchangeClient->AssumeServerSignatureKey(),   // hSignatureKey
                 TRUE                                              // fUseMachineKeyset was FALSE before fix for  213126
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Success!
    //

    m_KeyExchangeClient = keyExchangeClient;

cleanup:

    //
    // Free any blobs we allocated.
    //

    FREE_BLOB( clientKeyExchangeKeyBlob );
    FREE_BLOB( clientSignatureKeyBlob );
    FREE_BLOB( clientSessionKeyBlob );
    FREE_BLOB( clientHashBlob );
    FREE_BLOB( serverKeyExchangeKeyBlob );
    FREE_BLOB( serverSignatureKeyBlob );
    FREE_BLOB( serverSessionKeyBlob );
    FREE_BLOB( serverHashBlob );

    //
    // If we're failing the call, then free the associated objects we
    // created.
    //

    if( FAILED(result) ) {

        delete keyExchangeClient;
        CleanupCryptoData();

    }
    if (hToken) {
       if( ImpersonateLoggedOnUser( hToken ) )
       {
          // Nothing needs to be done here
       }

       CloseHandle(hToken);
       hToken = NULL;
    }
    return result;

}   // ADM_SECURE_DATA::DoClientSideKeyExchange


HRESULT
ADM_SECURE_DATA::DoServerSideKeyExchangePhase1(
    IN PIIS_CRYPTO_BLOB pClientKeyExchangeKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerKeyExchangeKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSessionKeyBlob
    )
/*++

Routine Description:

    Performs the first phase of server-side key exchange.

Arguments:

    pClientKeyExchangeKeyBlob - The client-side key exchange key blob.

    pClientSignatureKeyBlob - The client-side signature key blob.

    ppServerKeyExchangeKeyBlob - Receives a pointer to the server-side
        key exchange key blob if successful.

    ppServerSignatureKeyBlob - Receives a pointer to the server-side
        signature key blob if successful.

    ppServerSessionKeyBlob - Receives a pointer to the server-side session
        key blob if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;
    HCRYPTPROV prov;
    IIS_CRYPTO_EXCHANGE_SERVER * keyExchangeServer;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_Object != NULL );
    DBG_ASSERT( m_KeyExchangeServer == NULL );
    DBG_ASSERT( m_SendCryptoStorage == NULL );
    DBG_ASSERT( m_ReceiveCryptoStorage == NULL );
    DBG_ASSERT( pClientKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( pClientSignatureKeyBlob != NULL );
    DBG_ASSERT( ppServerKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( ppServerSignatureKeyBlob != NULL );
    DBG_ASSERT( ppServerSessionKeyBlob != NULL );

    HANDLE hToken = NULL;

    if (OpenThreadToken( GetCurrentThread(), MAXIMUM_ALLOWED, TRUE, &hToken ) ) {
        RevertToSelf();
    }
    //
    // Setup locals so we know how to cleanup on exit.
    //

    keyExchangeServer = NULL;

    //
    // Get the crypto provider to use.
    //

    DBG_CODE( prov = CRYPT_NULL );

    result = GetServerCryptoProvider( &prov );

    if( FAILED(result) ) {
        goto cleanup;
    }

    DBG_ASSERT( prov != CRYPT_NULL );

    //
    // Create & initialize the server-side key exchange object.
    //
    // N.B. Do not set the m_KeyExchangeServer to a non-NULL value
    // until key exchange is complete.
    //

    keyExchangeServer = new IIS_CRYPTO_EXCHANGE_SERVER;

    if( keyExchangeServer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = keyExchangeServer->Initialize(
                 prov,                      // hProv
                 CRYPT_NULL,                // hKeyExchangeKey
                 CRYPT_NULL,                // hSignatureKey
                 FALSE                      // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Do the first phase of the key exchange.
    //

    result = keyExchangeServer->ServerPhase1(
                 pClientKeyExchangeKeyBlob,
                 pClientSignatureKeyBlob,
                 ppServerKeyExchangeKeyBlob,
                 ppServerSignatureKeyBlob,
                 ppServerSessionKeyBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Success!
    //

    m_KeyExchangeServer = keyExchangeServer;

cleanup:

    //
    // If we're failing the call, then free the associated objects we
    // created.
    //

    if( FAILED(result) ) {

        delete keyExchangeServer;

    }
    if (hToken) {
       if( ImpersonateLoggedOnUser( hToken ) )
       {
           // Don't need to anything here
       }

       CloseHandle(hToken);
       hToken = NULL;
    }

    return result;

}   // ADM_SECURE_DATA::DoServerSideKeyExchangePhase1


HRESULT
ADM_SECURE_DATA::DoServerSideKeyExchangePhase2(
    IN PIIS_CRYPTO_BLOB pClientSessionKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientHashBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerHashBlob
    )
/*++

Routine Description:

    Performs the second phase of server-side key exchange.

Arguments:

    pClientSessionKeyBlob - The client-side session key blob.

    pClientHashBlob - The client-side hash blob.

    ppServerHashBlob - Receives a pointer to the server-side hash blob
        if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_Object != NULL );
    DBG_ASSERT( m_KeyExchangeServer != NULL );
    DBG_ASSERT( m_SendCryptoStorage == NULL );
    DBG_ASSERT( m_ReceiveCryptoStorage == NULL );
    DBG_ASSERT( pClientSessionKeyBlob != NULL );
    DBG_ASSERT( pClientHashBlob != NULL );
    DBG_ASSERT( ppServerHashBlob != NULL );

    HANDLE hToken = NULL;

    if (OpenThreadToken( GetCurrentThread(), MAXIMUM_ALLOWED, TRUE, &hToken ) ) {
        RevertToSelf();
    }
    //
    // Do the second phase of the key exchange.
    //

    result = m_KeyExchangeServer->ServerPhase2(
                 pClientSessionKeyBlob,
                 pClientHashBlob,
                 ppServerHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // OK, the key exchange is complete. We just need to create the
    // appropriate storage objects.
    //

    m_SendCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_SendCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_SendCryptoStorage->Initialize(
                 m_KeyExchangeServer->QueryProviderHandle(),    // hProv
                 m_KeyExchangeServer->AssumeServerSessionKey(), // hSessionKey
                 CRYPT_NULL,                                    // hKeyExchangeKey
                 CRYPT_NULL,                                    // hSignatureKey
                 FALSE                                          // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    m_ReceiveCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_ReceiveCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_ReceiveCryptoStorage->Initialize(
                 m_KeyExchangeServer->QueryProviderHandle(),      // hProv
                 m_KeyExchangeServer->AssumeClientSessionKey(),   // hSessionKey
                 CRYPT_NULL,                                      // hKeyExchangeKey
                 m_KeyExchangeServer->AssumeClientSignatureKey(), // hSignatureKey
                 FALSE                                            // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Success!
    //

cleanup:

    //
    // If we're failing the call, then free the associated objects we
    // created.
    //

    if( FAILED(result) ) {

        CleanupCryptoData();

    }
    if (hToken) {
       if( ImpersonateLoggedOnUser( hToken ) )
       {
           // Don't need to do anything here
       }

       CloseHandle(hToken);
       hToken = NULL;
    }

    return result;

}   // ADM_SECURE_DATA::DoServerSideKeyExchangePhase2


HRESULT
ADM_SECURE_DATA::GetCryptoProviderHelper(
    OUT HCRYPTPROV * UserProvider,
    OUT HCRYPTPROV * CachedProvider,
    IN LPTSTR ContainerName,
    IN DWORD CryptoFlags
    )
/*++

Routine Description:

    Helper routine for GetServerCryptoProvider and GetClientCryptoProvider().
    Provides necessary locking to ensure exactly one provider of each type
    is opened.

Arguments:

    UserProvider - Receives the handle to the provider.

    CachedProvider - Also receives the handle to the provider.

    ContainerName - The name of the container to open/create.

    CryptoFlags - Flags to pass into IISCryptoGetStandardContainer().

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;
    HCRYPTPROV hprov;

    //
    // Sanity check.
    //

    DBG_ASSERT( UserProvider != NULL );
    DBG_ASSERT( CachedProvider != NULL );

    LockThis();

    //
    // Recheck the provider handle under the guard of the lock, just
    // in case another thread has already created it.
    //

    hprov = *CachedProvider;

    if( hprov == CRYPT_NULL ) {

        //
        // Open/create the container.
        //

        result = IIS_CRYPTO_BASE::GetCryptoContainerByName(
                     &hprov,
                     ContainerName,
                     CryptoFlags,
                     FALSE              // fApplyAcl
                     );

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( hprov != CRYPT_NULL );
        *CachedProvider = hprov;
        *UserProvider = hprov;
    }

    UnlockThis();
    return result;

}   // ADM_SECURE_DATA::GetCryptoProviderHelper


VOID
ADM_SECURE_DATA::CleanupCryptoData()
/*++

Routine Description:

    Frees any crypto data associated with the current object.

Arguments:

    None.

Return Value:

    None.

--*/
{

    delete m_KeyExchangeClient;
    m_KeyExchangeClient = NULL;

    delete m_KeyExchangeServer;
    m_KeyExchangeServer = NULL;

    delete m_SendCryptoStorage;
    m_SendCryptoStorage = NULL;

    delete m_ReceiveCryptoStorage;
    m_ReceiveCryptoStorage = NULL;

}   // ADM_SECURE_DATA::CleanupCryptoData



HRESULT
ADM_SECURE_DATA::GetClientCryptoProvider(
    OUT HCRYPTPROV * Provider
    )
/*++

Routine Description:

    This method calls down to GetCryptoProviderHelper to create key
    and before that it prepares a name for key container

Arguments:

    Provider - returns handle to provider


Return Value:

    HRESULT error code if fail

--*/
{
    HRESULT retVal = NO_ERROR;
    
    if( sm_ClientCryptoProvider != CRYPT_NULL ) {
        *Provider = sm_ClientCryptoProvider;
        return retVal;
    }

    //
    // Previously each user had a unique container name generated
    // and keys would be stored persistently. 
    // Currently temporary container will be created to store temporary
    // keys. This way the race condition will be prevented where multiple
    // processes running under the same user identity would try to create
    // container of the same name (and one would eventually fail)
    //

    retVal =  GetCryptoProviderHelper( Provider,
                                       &sm_ClientCryptoProvider,
                                       NULL, // CREATE temporary container
                                       0
                                       );

    return retVal;
}


#define BUFSIZE_FOR_TOKEN   256

HRESULT
ADM_SECURE_DATA::GenerateNameForContainer(
    IN OUT PCHAR pszContainerName,
    IN DWORD dwBufferLen
    )
/*++

Routine Description:

    This method generates the name for crypoto container by taking some string
    which has 'IIS client ' appending that with suer name and user SID for uniqueness

Arguments:

    pszContainerName - pointer to a buffer which will receive a generated string

    dwBufferLen - size of buffer suplied for receiving string

Return Value:

    HRESULT

--*/
{
    HANDLE      hToken;
    BYTE        buf[BUFSIZE_FOR_TOKEN];
    PTOKEN_USER ptgUser = (PTOKEN_USER)buf;
    DWORD       cbBuffer=BUFSIZE_FOR_TOKEN;
    DWORD       dwLenOfBuffer, dwLenOfBuffAvailable;
    BOOL        bSuccess;
    PCHAR       pszPlaceToAppend;
    HRESULT     retVal;



    //
    // initialize string with some name for IIS client container
    //
    if (sizeof (DCOM_CLIENT_CONTAINER)  >= dwBufferLen)
    {
        return RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
    }
    strcpy (pszContainerName, DCOM_CLIENT_CONTAINER);

    dwLenOfBuffer = strlen(pszContainerName);
    pszPlaceToAppend = pszContainerName + dwLenOfBuffer;
    dwLenOfBuffAvailable =  dwBufferLen - dwLenOfBuffer;

    if ( !GetUserName(pszPlaceToAppen