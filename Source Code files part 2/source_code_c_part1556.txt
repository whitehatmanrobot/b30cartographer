DlgGetSelect(hDlg, R_IDC_POLY_FRONT_MODE);
   prd->iPolyBackMode      =CB_DlgGetSelect(hDlg, R_IDC_POLY_BACK_MODE);
   prd->iPointQuality      =CB_DlgGetSelect(hDlg, R_IDC_POINT_QUALITY);
   prd->iLineQuality       =CB_DlgGetSelect(hDlg, R_IDC_LINE_QUALITY);
   prd->iPolyQuality       =CB_DlgGetSelect(hDlg, R_IDC_POLY_QUALITY);
}

BOOL CALLBACK hugeRasterDlgProc(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
   static RASTERDATA *prd = NULL;
   
   switch (msg)
      {
      case WM_INITDIALOG:
         prd = (RASTERDATA*) (((PROPSHEETPAGE*)lParam)->lParam);
         CB_DlgAddString(hDlg, R_IDC_CULL_FACE_MODE, "front-facing polygons");
         CB_DlgAddString(hDlg, R_IDC_CULL_FACE_MODE, "back-facing polygons");
         CB_DlgAddString(hDlg, R_IDC_CULL_FACE_MODE, "cull all polygons");
         CB_DlgAddString(hDlg, R_IDC_POLY_FRONT_MODE,"Point");
         CB_DlgAddString(hDlg, R_IDC_POLY_FRONT_MODE,"Line");
         CB_DlgAddString(hDlg, R_IDC_POLY_FRONT_MODE,"Fill");
         CB_DlgAddString(hDlg, R_IDC_POLY_BACK_MODE, "Point");
         CB_DlgAddString(hDlg, R_IDC_POLY_BACK_MODE, "Line");
         CB_DlgAddString(hDlg, R_IDC_POLY_BACK_MODE, "Fill");
         CB_DlgAddString(hDlg, R_IDC_FRONT_FACE,     "CW polygons");
         CB_DlgAddString(hDlg, R_IDC_FRONT_FACE,     "CCW polygons");
         CB_DlgAddString(hDlg, R_IDC_POINT_QUALITY, "Fastest");
         CB_DlgAddString(hDlg, R_IDC_POINT_QUALITY, "Don't Care");
         CB_DlgAddString(hDlg, R_IDC_POINT_QUALITY, "Nicest");
         CB_DlgAddString(hDlg, R_IDC_LINE_QUALITY,  "Fastest");
         CB_DlgAddString(hDlg, R_IDC_LINE_QUALITY,  "Don't Care");
         CB_DlgAddString(hDlg, R_IDC_LINE_QUALITY,  "Nicest");
         CB_DlgAddString(hDlg, R_IDC_POLY_QUALITY,  "Fastest");
         CB_DlgAddString(hDlg, R_IDC_POLY_QUALITY,  "Don't Care");
         CB_DlgAddString(hDlg, R_IDC_POLY_QUALITY,  "Nicest");
         raster_SetDisplayFromData(hDlg,prd);
         return TRUE;

      case WM_COMMAND:
         {
            int iControl, iNote;
            iControl = LOWORD(wParam);
            iNote    = HIWORD(wParam); // notification code for edit boxes
            
            switch (iControl)
               {
               case R_IDC_POINT_SIZE:
               case R_IDC_LINE_WIDTH:
                  if (EN_KILLFOCUS == iNote) {
                     PropSheet_Changed(GetParent(hDlg),hDlg);
                     VerifyEditboxFloat(hDlg,iControl);
                  }
                  break;

               case R_IDC_LINE_STIPPLE_PATTERN:
               case R_IDC_POLY_STIPPLE_PATTERN:
                  if (EN_KILLFOCUS == iNote) {
                     PropSheet_Changed(GetParent(hDlg),hDlg);
                     VerifyEditboxHex(hDlg,iControl);
                  }
                  break;

               default:
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;
               }
         }
      break;

      case WM_NOTIFY:
         {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
               {
               case PSN_APPLY:  // user clicked on OK or Apply
                  raster_GetDataFromDisplay(hDlg, prd);
                  break;

               case PSN_RESET:  // user clicked on Cancel
                  break;

               case PSN_HELP:   // user clicked help
                  break;
               }
         }
      break;

      default:
         return FALSE;
      }
   return TRUE;
}

#else
#endif // NO_UI_IN_CNFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Profiler.rc
//
#define IDI_ICON1                       101
#define IDI_ICON2                       102
#define IDI_ICON3                       103
#define IDB_COLOR_CHECKERS              104
#define IDB_MONO_CHECKERS               105
#define IDD_ABOUT                       107
#define IDD_BUFFERS                     108
#define IDD_DIALOG1                     109
#define IDD_FOG                         110
#define IDD_GENERAL                     111
#define IDD_LIGHTING                    112
#define IDD_PRIMATIVES                  113
#define IDD_RASTERIZATION               114
#define IDD_RENAME                      115
#define IDD_TEXTURING                   116
#define IDR_ACCELERATOR1                117
#define IDR_ACCELERATOR2                118
#define IDC_POINTS                      701
#define IDC_LINES                       702
#define IDC_POLYGON                     703
#define IDC_TRIANGLES                   704
#define IDC_QUADS                       705
#define IDC_LINE_STRIP                  706
#define IDC_LINE_LOOP                   707
#define IDC_TRIANGLE_STRIP              708
#define IDC_TRIANGLE_FAN                709
#define IDC_QUAD_STRIP                  710
#define IDC_ABOUT_TEXT                  998
#define IDC_ENABLE                      999
#define B_IDC_AUTO_NORMAL               1000
#define B_IDC_CLEAR_ACCUM               1001
#define B_IDC_CLEAR_COLOR               1002
#define B_IDC_CLEAR_DEPTH               1003
#define B_IDC_CLEAR_STENCIL             1004
#define B_IDC_COLOR1                    1005
#define B_IDC_COLOR2                    1006
#define B_IDC_COLOR3                    1007
#define B_IDC_COLOR4                    1008
#define B_IDC_COLORBITS                 1009
#define B_IDC_DEPTHBITS                 1010
#define B_IDC_DEPTH_FUNC                1011
#define B_IDC_ENABLE_DEPTH              1012
#define B_IDC_ENABLE_STENCIL            1013
#define B_IDC_NORMALIZE                 1014
#define B_IDC_SHADE_MODEL               1015
#define F_IDC_COLOR1                    1100
#define F_IDC_COLOR2                    1101
#define F_IDC_COLOR3                    1102
#define F_IDC_COLOR4                    1103
#define F_IDC_DENSITY                   1104
#define F_IDC_LINEAREND                 1105
#define F_IDC_LINEARSTART               1106
#define F_IDC_MODE                      1107
#define F_IDC_QUALITY                   1108
#define G_IDC_BUFFERING                 1200
#define G_IDC_DURATION                  1201
#define G_IDC_HEIGHT                    1202
#define G_IDC_WIDTH                     1203
#define L_IDC_AMBIENT1                  1300
#define L_IDC_AMBIENT2                  1301
#define L_IDC_AMBIENT3                  1302
#define L_IDC_AMBIENT4                  1303
#define L_IDC_ATTENUATION1              1304
#define L_IDC_ATTENUATION2              1305
#define L_IDC_ATTENUATION3              1306
#define L_IDC_CUTOFF                    1307
#define L_IDC_DIFFUSE1                  1308
#define L_IDC_DIFFUSE2                  1309
#define L_IDC_DIFFUSE3                  1310
#define L_IDC_DIFFUSE4                  1311
#define L_IDC_ENABLELIGHT               1312
#define L_IDC_EXPONENT                  1313
#define L_IDC_INFINITEVIEWER            1314
#define L_IDC_LIGHT                     1315
#define L_IDC_LOCALVIEWER               1316
#define L_IDC_POSITION1                 1317
#define L_IDC_POSITION2                 1318
#define L_IDC_POSITION3                 1319
#define L_IDC_POSITION4                 1320
#define L_IDC_SPECULAR1                 1321
#define L_IDC_SPECULAR2                 1322
#define L_IDC_SPECULAR3                 1323
#define L_IDC_SPECULAR4                 1324
#define L_IDC_SPOTDIR1                  1325
#define L_IDC_SPOTDIR2                  1326
#define L_IDC_SPOTDIR3                  1327
#define L_IDC_TWOSIDED                  1328
#define L_IDC_WHICHLIGHT                1329
#define M_IDC_ABORT                     1400
#define M_IDC_CONFIG                    1401
#define M_IDC_DELETE                    1402
#define M_IDC_LOAD                      1403
#define M_IDC_NEW                       1404
#define M_IDC_NEWNAME                   1405
#define M_IDC_QUIT                      1406
#define M_IDC_RENAME                    1407
#define M_IDC_RUN                       1408
#define M_IDC_SAVE                      1409
#define M_IDC_WHICHTEST                 1410
#define P_IDC_ADD                       1500
#define P_IDC_MOVEDOWN                  1501
#define P_IDC_MOVEUP                    1502
#define P_IDC_POINT1                    1503
#define P_IDC_POINT2                    1504
#define P_IDC_POINT3                    1505
#define P_IDC_POINTLIST                 1506
#define P_IDC_POLY                      1507
#define P_IDC_REMOVE                    1508
#define R_IDC_CULL_FACE_ENABLE          1600
#define R_IDC_CULL_FACE_MODE            1601
#define R_IDC_FRONT_FACE                1602
#define R_IDC_LINE_QUALITY              1603
#define R_IDC_LINE_SMOOTH               1604
#define R_IDC_LINE_STIPPLE_ENABLE       1605
#define R_IDC_LINE_STIPPLE_PATTERN      1606
#define R_IDC_LINE_STIPPLE_REPEAT       1607
#define R_IDC_LINE_WIDTH                1608
#define R_IDC_POINT_QUALITY             1609
#define R_IDC_POINT_SIZE                1610
#define R_IDC_POINT_SMOOTH              1611
#define R_IDC_POLY_BACK_MODE            1612
#define R_IDC_POLY_FRONT_MODE           1613
#define R_IDC_POLY_QUALITY              1614
#define R_IDC_POLY_SMOOTH               1615
#define R_IDC_POLY_STIPPLE_ENABLE       1616
#define R_IDC_POLY_STIPPLE_PATTERN      1617
#define S_IDC_MESSAGE                   1700
#define X_IDC_1D_ENABLE                 1800
#define X_IDC_2D_ENABLE                 1801
#define X_IDC_AUTOMATIC_Q               1802
#define X_IDC_AUTOMATIC_R               1803
#define X_IDC_AUTOMATIC_S               1804
#define X_IDC_AUTOMATIC_T               1805
#define X_IDC_BORDER                    1806
#define X_IDC_BORDER_COLOR1             1807
#define X_IDC_BORDER_COLOR2             1808
#define X_IDC_BORDER_COLOR3             1809
#define X_IDC_BORDER_COLOR4             1810
#define X_IDC_BUILD_MIPMAP              1811
#define X_IDC_ENV_MODE                  1812
#define X_IDC_FILENAME                  1813
#define X_IDC_FILTER1                   1814
#define X_IDC_FILTER2                   1815
#define X_IDC_FILTER3                   1816
#define X_IDC_FILTER4                   1817
#define X_IDC_FILTER_1D                 1818
#define X_IDC_FILTER_2D                 1819
#define X_IDC_FILTER_MAG                1820
#define X_IDC_FILTER_MIN                1821
#define X_IDC_GEN_MODE_S                1822
#define X_IDC_HEIGHT                    1823
#define X_IDC_PERSPECTIVE_QUALITY       1824
#define X_IDC_PICKFILE                  1825
#define X_IDC_PICKFILE_C                1826
#define X_IDC_PICKFILE_M                1827
#define X_IDC_PREVIEW                   1828
#define X_IDC_WIDTH                     1829
#define X_IDC_WRAP_S                    1830
#define X_IDC_WRAP_T                    1831
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         2001
#define _APS_NEXT_CONTROL_VALUE         1900
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\small1.cpp ===
#include <stdio.h>
#include <windows.h>
#include <gl\gl.h>

#include "skeltest.h"
#include "small1.h"

SmallTriangle::SmallTriangle()
{
   td.swapbuffers = FALSE;
   td.iDuration   = 10000;
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   sprintf(td.acName, "Small Triangle (demo only)");
   bd.cColorBits  = 8;
   bd.cDepthBits  = 16;
   
   bFlip = FALSE;
}

void SmallTriangle::INITFUNCTION()
{
   if (h == 0)
      h = 1;
   td.iW = w;
   td.iH = h;
   glViewport(0,0,w,h);
   glLoadIdentity();
   glOrtho(0.0f, w, 0.0f, h, 1.0f, -1.0f);
}

void SmallTriangle::IDLEFUNCTION()
{
   bFlip = !bFlip;
}

void SmallTriangle::RENDFUNCTION()
{
   int xa,xb,ya,yb;
   
   //   glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
   //   glClear(GL_COLOR_BUFFER_BIT);
   
   if (bFlip)
      glColor3f(1.0f, 0.0f, 0.0f);
   else
      glColor3f(0.0f, 0.0f, 1.0f);
   
   glBegin(GL_TRIANGLES);
   for(ya = 0, yb = 10 ; yb <= td.iH ; ya += 10, yb += 10)
      for(xa = 0, xb = 10 ; xb <= td.iW ; xa += 10, xb += 10) {
         if (bFlip) {
            glVertex2i(xa, ya);
            glVertex2i(xa, yb);
            glVertex2i(xb, yb);
         } else {
            glVertex2i(xa, ya);
            glVertex2i(xb, yb);
            glVertex2i(xb, ya);
         }
      }
   glEnd();
   
   glFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\skeltest.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#include "skeltest.h"
#include "resource.h"
#include "macros.h"

extern HINSTANCE hInstance;

static TESTDATA   test_td;
static BUFFERDATA test_bd;

typedef BOOL CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);

DlgProc testDlgProc;
DlgProc testAboutDlgProc;
int CALLBACK PropSheetProc(HWND, UINT, LPARAM);

SkeletonTest::SkeletonTest()
{
   bzero(szTypeName, sizeof(szTypeName));
   bzero(szVersion,  sizeof(szVersion));
   
   bzero(&td,sizeof(TESTDATA));
   BEGINstring((&td), "testdata");
   ENDstring((&td),   "testdata");
   
   SetThisType("Skeleton");
   SetThisVersion("1.0");
   
   td.swapbuffers = FALSE;   // default: single buffer
   td.iDuration   = 1000;    // default: run for 1 second
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   td.acName[0] = 0;
   sprintf(td.acName, "Skeleton");
   sprintf(td.acAbout,"An OpenGL profiler test (sorry, no specific description for this test has been entered)");
   sprintf(td.acTestStatName,"Frames");
   td.dResult  = 0;
   
   InitBD(&bd);
   
   iNumConfigPages = 1;
   aPSpages = (PROPSHEETPAGE*) malloc(sizeof(PROPSHEETPAGE));
   
   bzero(aPSpages, sizeof(PROPSHEETPAGE));
   aPSpages[0].dwSize      = sizeof(PROPSHEETPAGE);
   aPSpages[0].dwFlags     = PSP_USECALLBACK;
   aPSpages[0].hInstance   = hInstance;
   aPSpages[0].pszTemplate = MAKEINTRESOURCE (IDD_GENERAL);
   aPSpages[0].pfnDlgProc  = (DLGPROC) testDlgProc;
   aPSpages[0].lParam      = (LPARAM) &td;
}

void SkeletonTest::SetThisType(const char *szType)
{
   strncpy(szTypeName, szType, MAXTYPELENGTH);
}

void SkeletonTest::SetThisVersion(const char *szVer)
{
   int iLen;
   iLen = strlen(szVersion);
   if (iLen == sizeof(szVersion))
      return;
   szVersion[iLen] = '|';
   iLen++;
   strncat(szVersion, szVer, sizeof(szVersion) - iLen);
}

void SkeletonTest::AddPropertyPages(int iNew, PROPSHEETPAGE *pNewPSpages)
{
   int i;
   
   aPSpages = (PROPSHEETPAGE*)
      realloc(aPSpages,(iNumConfigPages+iNew) * sizeof(PROPSHEETPAGE));
   for (i = 0 ; i < iNew ; i++) {
      aPSpages[i + iNumConfigPages] = pNewPSpages[i];
   }
   iNumConfigPages += iNew;
}

void SkeletonTest::SaveData()     { test_td = td; test_bd = bd; }
void SkeletonTest::RestoreSaved() { td = test_td; bd = test_bd; }
void SkeletonTest::ForgetSaved()  {}

int SkeletonTest::Save(HANDLE hFile)
{
   ulong ul;
   
   if (!WriteFile(hFile, (void*) szTypeName, sizeof(szTypeName), &ul, NULL))
      return -1;
   if (ul != sizeof(szTypeName)) return -1;
   if (!WriteFile(hFile, (void*) szVersion, sizeof(szVersion), &ul, NULL))
      return -1;
   if (ul != sizeof(szVersion)) return -1;
   if (!WriteFile(hFile, (void*) &td, sizeof(td), &ul, NULL))
      return -1;
   if (ul != sizeof(td)) return -1;
   if (!WriteFile(hFile, (void*) &bd, sizeof(bd), &ul, NULL))
      return -1;
   if (ul != sizeof(bd)) return -1;
   FlushFileBuffers(hFile);
   return sizeof(szTypeName) + sizeof(szVersion) + sizeof(td) + sizeof(bd);
}

int SkeletonTest::Load(HANDLE hFile)
{
   ulong ul;
   
   if (!ReadFile(hFile, (void*) szTypeName, sizeof(szTypeName), &ul, NULL))
      return -1;
   if (ul != sizeof(szTypeName)) return -1;
   if (!ReadFile(hFile, (void*) szVersion, sizeof(szVersion), &ul, NULL))
      return -1;
   if (ul != sizeof(szVersion)) return -1;
   if (!ReadFile(hFile, (void*) &td, sizeof(td), &ul, NULL))
      return -1;
   if (ul != sizeof(td)) return -1;
   if (!ReadFile(hFile, (void*) &bd, sizeof(bd), &ul, NULL))
      return -1;
   if (ul != sizeof(bd)) return -1;
   return sizeof(szTypeName) + sizeof(szVersion) + sizeof(td) + sizeof(bd);
}

int SkeletonTest::CNFGFUNCTION()
{
   PROPSHEETHEADER pshead;
   char acBuffer[128];
   int  i, j;
   
   this->SaveData();
   
   sprintf(acBuffer, "Configure Test: %s", szTypeName);
   
   // Initialize property sheet HEADER data
   bzero(&pshead, sizeof(pshead));
   
   pshead.dwSize  = sizeof(pshead);
   pshead.dwFlags = PSH_PROPSHEETPAGE;
   pshead.hwndParent  = hwndParent;
   pshead.pszCaption  = acBuffer;
   pshead.nPages      = iNumConfigPages;
   pshead.nStartPage  = 0;
   pshead.ppsp        = aPSpages;
   pshead.pfnCallback = PropSheetProc;

   SetLastError(0);
   i = PropertySheet (&pshead);
   j = GetLastError();
   switch (i)
      {
      case -1:                  // error
         fprintf(stderr,
                 "CreatePropertySheet() returned:   %d\n"
                 "GetLastError() returned: %d\n",
                 i,GetLastError());
         break;
      case 0:                   // cancel
         this->RestoreSaved();
         break;
      default:                  // OK
         this->ForgetSaved();
         break;
      }
   return i;
}

void test_SetDisplayFromData(HWND hDlg, const TESTDATA *ptd)
{
   SetDlgItemInt(hDlg,G_IDC_WIDTH,     ptd->iW,        TRUE);
   SetDlgItemInt(hDlg,G_IDC_HEIGHT,    ptd->iH,        TRUE);
   SetDlgItemInt(hDlg,G_IDC_DURATION,  ptd->iDuration, TRUE);
   CheckDlgButton(hDlg,G_IDC_BUFFERING,ptd->swapbuffers?1:0);
}

void test_GetDataFromDisplay(HWND hDlg, TESTDATA *ptd)
{
   ptd->iW          = GetDlgItemInt(hDlg, G_IDC_WIDTH,     NULL, TRUE);
   ptd->iH          = GetDlgItemInt(hDlg, G_IDC_HEIGHT,    NULL, TRUE);
   ptd->iDuration   = GetDlgItemInt(hDlg, G_IDC_DURATION,  NULL, TRUE);
   ptd->swapbuffers = IsDlgButtonChecked(hDlg,G_IDC_BUFFERING);
}

BOOL CALLBACK testDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
   static TESTDATA *ptd = NULL;
   
   switch (msg)
      {
      case WM_INITDIALOG:
         ptd = (TESTDATA*)(((PROPSHEETPAGE*)lParam)->lParam);
         test_SetDisplayFromData(hDlg,ptd);
         return TRUE;

      case WM_COMMAND:
         {
            int   i, j;
            i = LOWORD(wParam);
            j = HIWORD(wParam); // notification code for edit boxes
            switch (i)
               {
               case G_IDC_WIDTH:          // don't mess with display
               case G_IDC_HEIGHT:         // while editing text
               case G_IDC_DURATION:
                  if (EN_UPDATE == j)
                     PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;

               default:
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;
               }
         }
      break;

      case WM_NOTIFY:
         {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
               {
               case PSN_APPLY:  // user clicked on OK or Apply
                  test_GetDataFromDisplay(hDlg, ptd);
                  break;

               case PSN_RESET:  // user clicked on Cancel
                  break;

               case PSN_HELP:   // user clicked help
                  break;
               }
         }
      break;

      default:
         return FALSE;
      }
   return TRUE;
}

BOOL CALLBACK testAboutDlgProc(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
   char *szAbout;
   
   switch (msg)
      {
      case WM_INITDIALOG:
         szAbout = (char*)(((PROPSHEETPAGE*)lParam)->lParam);
         SetDlgItemText(hDlg,IDC_ABOUT_TEXT,szAbout);
         return TRUE;

      default:
         return FALSE;
      }
   return TRUE;
}

int CALLBACK PropSheetProc (HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
      {
      case PSCB_INITIALIZED :
         // Process PSCB_INITIALIZED
         break ;

      case PSCB_PRECREATE :
         // Process PSCB_PRECREATE
         break ;

      default :
         // Unknown message
         break ;
      }
   return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\scripter.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <commdlg.h>

#include "prfl.h"
#include "skeltest.h"
#include "hugetest.h"
#include "primtest.h"
#include "teapot.h"
#include "resource.h"
#include "macros.h"

// DEFINES

#define WM_EOT          (WM_USER+0)
#define WM_READTEST     (WM_USER+1)
#define WM_DONEREADING  (WM_USER+2)
#define WM_STARTTEST    (WM_USER+3)
#define WM_ABORTTEST    (WM_USER+4)
#define WM_TESTDONE     (WM_USER+5)


// GLOBAL VARIABLES

static LPCTSTR lpszAppName = "Scripter";
HINSTANCE       hInstance;
HWND            hWndMain;
FILE *infile  = stdin;
FILE *outfile = stdout;

// FUNCTION HEADERS

LRESULT CALLBACK mainWndProc(HWND, UINT, WPARAM, LPARAM);

// INLINE FUNCTIONS

inline void SetText(char *szText) {
   SetDlgItemText(hWndMain, S_IDC_MESSAGE, szText);
#ifdef DEBUG
   fprintf(stderr, "main window text: %s\n", szText);
#endif
}

inline void ShowButtonOK(BOOL bShow)
{ ShowWindow(GetDlgItem(hWndMain,IDOK),     bShow ? SW_SHOWNORMAL : SW_HIDE); }

inline void ShowButtonCancel(BOOL bShow)
{ ShowWindow(GetDlgItem(hWndMain,IDCANCEL), bShow ? SW_SHOWNORMAL : SW_HIDE); }

inline void ShowButtons(BOOL bShow)
{  ShowButtonOK(bShow);   ShowButtonCancel(bShow); }

inline void ErrorMessage(const char *szMsg) {
   fprintf(stderr, "%s\n", szMsg);
   MessageBox(NULL, szMsg, "ERROR!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
}

inline void WarningMessage(const char *szMsg) {
   fprintf(stderr, "%s\n", szMsg);
   MessageBox(NULL, szMsg, "WARNING!", MB_OK | MB_ICONWARNING | MB_TASKMODAL);
}

/*
 * reads one line in from our infile, handles comment character '#' and
 * line-continue character '\\'.  If our buffer would overflow, we return '+'
 * in the first character of our string, else we return '-'
 */
char *ReadOneLine()
{
   static char acLine[1024];
   char *pc;
   int   iSize = sizeof(acLine) - 1;
   int   iEnd;
   BOOL  bEOL = FALSE;
   
   acLine[0] = '-';
   pc = acLine + 1;
   
   while (!bEOL && iSize > 0) {
      pc = fgets(pc, iSize, infile);
      if (!pc) {                // EOF
         return NULL;
      }
      
      pc = index(pc, '#');     // comments
      if (pc)   *pc = '\0';
      
      iEnd = strlen(acLine);
      if (acLine[iEnd-1] == '\n') { // don't return new line
         acLine[iEnd-1] = '\0';
         iEnd--;
      }
      if (acLine[iEnd-1] != '\\') { // use \ as a line-continue indicator
         bEOL = TRUE;
      } else {
         bEOL = FALSE;
         iSize = sizeof(acLine) - iEnd;
         pc = acLine + iEnd - 1;
      }
   }
   if (!bEOL)   acLine[0] = '+'; // have we run out of room?
   return acLine;
}

char *ReadOneNonBlankLine()
{
   char *pc, *rol;
   BOOL  bEND = FALSE;
   
   while (!bEND) {
      rol = pc = ReadOneLine();
      if (!pc)   return pc;
      pc++;
      while (*pc && isspace(*pc)) pc++;
      bEND = (BOOL) *pc;
   }
   pc--;
   *pc = *rol;
   return pc;
}

int ReadScriptHeader()
{
   char *pc;
   pc = ReadOneNonBlankLine();
   if (!pc || *pc == '+') {
      ErrorMessage("Fatal error reading number of tests in script file!");
      exit(-1);
   }
   return atoi(pc+1);
}

SkeletonTest **AllocateTestArray(int i)
{
   SkeletonTest **past;
   past = (SkeletonTest **) malloc(i*sizeof(SkeletonTest*));
   bzero(past, i*sizeof(SkeletonTest*));
   return past;
}



SkeletonTest *ReadAndCreateTest()
{
   SkeletonTest *pst = NULL;
   char          acFileName[_MAX_PATH], acData[1024];
   char         *szLine, *pc;
   int           i, iFile = 0, iData = 0;
   void         *pTmp;
   
   szLine = ReadOneNonBlankLine();
   if (!szLine) {
      ErrorMessage("Unexpected end of file.");
      return NULL;
   }
   if (*szLine == '+') {
      ErrorMessage("Line too long.");
      exit(-1);
   }
   szLine++;
   i = sscanf(szLine, "%s %n", acFileName, &iData);
   if (i == 0) {
      *acFileName = '\0';
      WarningMessage("Warning: no data file for this test.");
   }
   if (*acFileName == '"') {
      pc = index(szLine+iFile+1, '"');
      if (!pc) {
         fprintf(stderr, "Unmatched \".");
         exit(-1);
      }
      bzero(acFileName, sizeof(acFileName));
      strncpy(acFileName, szLine+iFile+1, (pc-szLine) - iFile - 1);
      sscanf(pc, "\" %n", &iData);
      strncpy(acData, pc+iData, sizeof(acData));
   } else {
      strncpy(acData, szLine+iData, sizeof(acData));
   }
   if (iData == 0)
      *acData = '\0';
#ifdef DEBUG
   fprintf(stderr,
           "line: \'%s\'\ni:    %d\nFile: %s\nData: (%d) \'%s\'\n\n",
           szLine, i, acFileName, iData, acData);
#endif
   
   pst = NULL;
   pTmp = prfl_AutoLoad(acFileName, &iData);
   if (iData) {
      ErrorMessage((char*)pTmp);
      return NULL;
   }
   pst = (SkeletonTest*) pTmp;
   
   if (*acData) {
      pst->ReadExtraData(acData);
   }
   
   return pst;
}

void SetFilesFromCmdLine(const char *szCmdLine)
{
   char acBuffer[512], acErrBuf[512];
   char *szIn, *szOut, *szEnd;
   
   strncpy(acBuffer, szCmdLine, sizeof(acBuffer));
   szIn = acBuffer;
   while (*szIn && isspace(*szIn))  szIn++;
   szEnd = szIn;
   if (*szEnd == '"') {
      szEnd = index(szIn+1, '"');
      if (!szEnd) {
         fprintf(stderr, "Unmatched \".");
         exit(-1);
      }
   }
   while (*szEnd && !isspace(*szEnd)) szEnd++;
   *szEnd = '\0';
   
   szOut = szEnd+1;
   while (*szOut && isspace(*szOut)) szOut++;
   szEnd = szOut;
   if (*szEnd == '"') {
      szEnd = index(szOut+1, '"');
      if (!szEnd) {
         fprintf(stderr, "Unmatched \".");
         exit(-1);
      }
   }
   while (*szEnd && !isspace(*szEnd)) szEnd++;
   *szEnd = '\0';
   
   infile = stdin;  outfile = stdout;
   if (szIn  && (*szIn  != '\0')&&(*szIn  != '-'))  infile  = fopen(szIn, "r");
   if (szOut && (*szOut != '\0')&&(*szOut != '-'))  outfile = fopen(szOut,"a");
   if (infile && outfile)
      return;
   if (infile && !outfile)
      sprintf(acErrBuf, "Error opening output file: %s", szOut);
   if (!infile && outfile)
      sprintf(acErrBuf, "Error opening input file: %s", szIn);
   if (!infile && !outfile)
      sprintf(acErrBuf, "Error opening input file:  %s\n"
              "Error opening output file: %s", szIn, szOut);
   ErrorMessage(acErrBuf);
   exit(-1);
}

int APIENTRY WinMain(HINSTANCE hInst,     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine, int       iCmdShow)
{
   MSG            msg;
   WNDCLASSEX     wc;
   HACCEL         hAccel;
   SkeletonTest **past;
   int            i;
   
   hInstance = hInst;
   
   // Register Window style
   wc.cbSize               = sizeof(wc);
   wc.style                = CS_HREDRAW | CS_VREDRAW;
   wc.lpfnWndProc          = (WNDPROC) mainWndProc;
   wc.cbClsExtra           = 0;
   wc.cbWndExtra           = DLGWINDOWEXTRA;
   wc.hInstance            = hInstance;
   wc.hIcon                = NULL;
   wc.hCursor              = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground        = (HBRUSH) COLOR_BTNSHADOW;
   wc.lpszMenuName         = NULL;
   wc.lpszClassName        = lpszAppName;
   wc.hIconSm              = NULL;
   
   // Register the window class
   if(RegisterClassEx(&wc) == 0)
      exit(-1);
   if (prfl_RegisterClass(hInstance) == FALSE)
      exit(-1);
   
   SetFilesFromCmdLine(lpCmdLine);
   fprintf(stdout, "Reading script.\n");
   fflush(stdout);
   i = ReadScriptHeader();
   past = AllocateTestArray(i);

   hWndMain = CreateDialog(hInstance, lpszAppName, 0, NULL);
   SendMessage(hWndMain, WM_INITDIALOG, (WPARAM) i, (LPARAM) past);
   
   hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR2));
   
   while(GetMessage(&msg, NULL, 0, 0)) {
      if (!TranslateAccelerator(hWndMain, hAccel, &msg)) {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
      }
   }
   
   return msg.wParam;
}

void EOT_callback()
{
   PostMessage(hWndMain, WM_EOT, 0, 0);
}

// Window procedure, handles all messages for this window
LRESULT CALLBACK mainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   typedef enum { NONE, LOADING, WAITING, RUNNING, DONE } ModeType;
   static ModeType mMode = NONE;
   static char           szFileName[_MAX_PATH];
   static char           szTitleName[_MAX_FNAME + _MAX_EXT];
   static char           acBuffer[120];
   static SkeletonTest **past = NULL;
   static int            iNumTests =  0;
   static int            iCurrent  = -1;
   static SkeletonTest  *pTest = NULL;
   static BOOL           bOnce = FALSE;
   int           iControl;
   
   iControl = LOWORD(wParam);
#ifdef DEBUG
   if ((msg >= WM_USER) || (msg == WM_INITDIALOG)) {
      fprintf(stderr, "message: %d (WM_USER+%d) %u (%d) %u\n",
              msg, msg-WM_USER, wParam, iControl, lParam);
   }
#endif
   
   switch (msg)
      {
      case WM_CREATE:
         break;                 // WM_CREATE

      case WM_INITDIALOG:
         if (!bOnce) {
            mMode = LOADING;
            past      = (SkeletonTest **) lParam;
            iNumTests = iControl;
            PostMessage(hwnd, WM_READTEST, 0, 0);
            ShowButtonOK(FALSE);
            ShowButtonCancel(TRUE);
            SetText("This is some text.");
            bOnce = TRUE;
         } else {
            fprintf(stderr, "%cERROR -- Multiple inits!!!\n",7);
         }
         break;                 // WM_INITDIALOG

      case WM_READTEST:
         sprintf(acBuffer,"Reading test %d of %d.", iControl+1, iNumTests);
         SetText(acBuffer);
         past[iControl] = ReadAndCreateTest();
         if (iControl+1 < iNumTests)
            PostMessage(hwnd, WM_READTEST, iControl+1, 0);
         else
            PostMessage(hwnd, WM_DONEREADING, 0, 0);
         break;                 // WM_READTEST

      case WM_DONEREADING:
         mMode = WAITING;
         sprintf(acBuffer, "Script loaded, ready to run.");
         SetText(acBuffer);
         ShowButtons(TRUE);
         break;                 // WM_DONEREADING

      case WM_STARTTEST:
         iCurrent = iControl;
         if (iCurrent >=  iNumTests) {
            iCurrent = -1;
            pTest = NULL;
            return 0;
         }
         pTest = past[iCurrent];
         if (!pTest) {
            sprintf(acBuffer, "Can't run test %d (doesn't exist).",iControl+1);
            SetText(acBuffer);
            return 0;
         }
         sprintf(acBuffer,"Running test %d: %s",iControl+1,pTest->QueryName());
#ifdef DEBUG
         fprintf(stderr,"%s\n",acBuffer);
#endif
         SetText(acBuffer);
         mMode = RUNNING;
         if (!prfl_StartTest(pTest, pTest->QueryName(), EOT_callback)) {
            sprintf(acBuffer, "Error starting test %d: %s",
                    iCurrent, pTest->QueryName());
            SetText(acBuffer);
            MessageBeep(0);
            ErrorMessage(acBuffer);
            mMode = WAITING;
            return 0;
         }
         ShowButtonOK(FALSE);
         break;                 // WM_STARTTEST

      case WM_ABORTTEST:
         prfl_StopTest();
         mMode = WAITING;
         sprintf(acBuffer, "Script aborted. Ready to re-run.");
         SetText(acBuffer);
         ShowButtons(TRUE);
         break;                 // WM_ABORTTEST

      case WM_COMMAND:
         {
            switch (iControl)
               {
               case IDOK:
                  switch (mMode)
                     {
                     case NONE:
                     case LOADING:
                     case RUNNING:
                        break;
                     case WAITING:
                        PostMessage(hwnd, WM_STARTTEST, 0, 0);
                        break;
                     case DONE:
                        DestroyWindow(hwnd);
                        break;
                     }
                  break;        // IDOK

               case IDCANCEL:
                  switch (mMode)
                     {
                     case NONE:
                     case LOADING:
                     case WAITING:
                     case DONE:
                        DestroyWindow(hwnd);
                        break;
                     case RUNNING:
                        SendMessage(hwnd, WM_ABORTTEST, 0, 0);
                        break;
                     }
                  break;        // IDCANCEL

               default:         // This is an error!
                  MessageBeep(0);
                  return DefWindowProc(hwnd,msg,wParam,lParam);
               }
            
         }
      return 0;                 // WM_COMMAND

      case WM_EOT:
         if (prfl_TestRunning()) {
            PostMessage(hwnd, WM_EOT, 0, 0);
         } else {
            double dNumCalls, dDuration, dResult;
            
            dNumCalls = prfl_GetCount();
            dDuration = prfl_GetDuration();
            dResult   = prfl_GetResult();
            
            sprintf(acBuffer, "%d %g %g %g %g %g %s", 
                    iCurrent, dDuration, dNumCalls, dNumCalls*1000/dDuration,
                    dResult, dResult*1000/dDuration, pTest->QueryName());
            fprintf(outfile, "%s\n", acBuffer);
            fflush(outfile);
            if (iCurrent < iNumTests-1) {
               PostMessage(hwnd, WM_STARTTEST, iCurrent+1, 0);
            } else {
               PostMessage(hwnd, WM_TESTDONE, 0, 0);
            }
         }
         break;                 // WM_EOT

      case WM_TESTDONE:
         mMode = DONE;
         sprintf(acBuffer, "Script completed.");
         SetText(acBuffer);
         ShowButtonOK(TRUE);
         ShowButtonCancel(FALSE);
         break;

      case WM_DESTROY:
         PostQuitMessage(0);
         return 0;              // WM_DESTROY
      }
   
   return DefWindowProc(hwnd,msg,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\small1.h ===
#ifndef SMALL_TRIANGLE_1_TEST_H
#define SMALL_TRIANGLE_1_TEST_H

class SmallTriangle : public SkeletonTest
{
private:
   typedef SkeletonTest parent;

public:
   SmallTriangle();
   
   virtual void INITFUNCTION();
   virtual void IDLEFUNCTION();
   virtual void RENDFUNCTION();

private:
   BOOL bFlip;
};

#endif // SMALL_TRIANGLE_1_TEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\small2.h ===
#ifndef SMALL_TRIANGLE2_TEST_H
#define SMALL_TRIANGLE2_TEST_H

#include "primtest.h"

class SmallTriangle2 : public PrimativeTest
{
private:
   typedef PrimativeTest parent;

public:
   SmallTriangle2();
   
   virtual void IDLEFUNCTION();
};

#endif // SMALL_TRIANGLE2_TEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\small2.cpp ===
#include <windows.h>
#include <gl\gl.h>
#include <stdio.h>

#include "hugetest.h"
#include "small2.h"

SmallTriangle2::SmallTriangle2()
{
   int xa, xb, ya, yb;
   int SIZE;
   
   td.swapbuffers = TRUE;
   td.iDuration   = 10000;
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   sprintf(td.acName, "Small Triangles 2");
   sprintf(td.acTestStatName, "Triangles");
   td.dResult  = 0.0;
   bd.uiClear  = GL_COLOR_BUFFER_BIT;
   bd.cColorBits  = 8;
   bd.cDepthBits  = 16;

   bd.fClearColor[0] = 0.0;
   bd.fClearColor[1] = 0.0;
   bd.fClearColor[2] = 1.0;
   bd.fClearColor[3] = 0.0;
   
   afDrawColor[0] = 0.0;
   afDrawColor[1] = 1.0;
   afDrawColor[2] = 0.0;
   
   range.fxMin =   0;
   range.fxMax = 640;
   range.fyMin =   0;
   range.fyMax = 480;

   SIZE = 4;
   aPntLst[3].AllocatePoints(3*(300/SIZE)*(200/SIZE));
   for(ya = 0, yb = SIZE ; yb <= range.fyMax ; ya += SIZE, yb += SIZE)
      for(xa = 0, xb = SIZE ; xb <= range.fxMax ; xa += SIZE, xb += SIZE) {
         // lower right half
         aPntLst[3].AddPoint((GLfloat) xa, (GLfloat) ya, 0);
         aPntLst[3].AddPoint((GLfloat) xb, (GLfloat) yb, 0);
         aPntLst[3].AddPoint((GLfloat) xb, (GLfloat) ya, 0);
      }
   td.dResult = (double) (aPntLst[3].QueryNumber() / 3);
   
   /*
   for(ya = 0, yb = SIZE ; yb <= range.fyMax ; ya += SIZE, yb += SIZE)
      for(xa = 0, xb = SIZE ; xb <= range.fyMin ; xa += SIZE, xb += SIZE) {
         // upper left half
         aPntLst[3].AddPoint((GLfloat) xa, (GLfloat) ya, 0);
         aPntLst[3].AddPoint((GLfloat) xa, (GLfloat) yb, 0);
         aPntLst[3].AddPoint((GLfloat) xb, (GLfloat) yb, 0);
      }
   */
}

void SmallTriangle2::IDLEFUNCTION()
{
   static BOOL bFlip = TRUE;
   if ((bFlip = !bFlip)) {
      afDrawColor[0] = 0.0;
      afDrawColor[1] = 1.0;
      afDrawColor[2] = 0.0;
   } else {
      afDrawColor[0] = 1.0;
      afDrawColor[1] = 0.0;
      afDrawColor[2] = 0.0;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\skeltest.h ===
#ifndef PROFILETEST_H
#define PROFILETEST_H

// without windows.h, gl/gl.h causes errors.
// without gl/gl.h, test.h causes errors.
// technically, you should have both of these includes in your .c file...
#include <windows.h>
#include <commctrl.h>
#include <gl/gl.h>

#include "buffers.h"

#define MAXNAMELENGTH    32
#define MAXSTATLENGTH    32
#define MAXABOUTLENGTH  128

#define MAXTYPELENGTH    32
#define TOTALVERLENGTH  256

typedef struct {
   char acDummy1[16];
   // General stuff
   int  iX,iY,iH,iW;                    // window position and size
   BOOL swapbuffers;                    // Double buffered?
   char acName[MAXNAMELENGTH];          // name of test
   char acAbout[MAXABOUTLENGTH];        // a discription of the test
   char acTestStatName[MAXSTATLENGTH];  // statistic to be tested
   int  iDuration;                      // duration (ms) of test
   
   double     dResult;
   char acDummy2[16];
} TESTDATA;

#define CNFGFUNCTION() cnfgfunct(HWND hwndParent)
#define INITFUNCTION() initfunct(GLsizei w, GLsizei h)
#define IDLEFUNCTION() idlefunct(void)
#define RENDFUNCTION() rendfunct(void)
#define DESTFUNCTION() destfunct(void)

class SkeletonTest {
public:
   SkeletonTest();
   ~SkeletonTest(void) {};
   
   virtual BOOL CNFGFUNCTION();         // if an error occurred FALSE else TRUE
   virtual void INITFUNCTION() {};      // called once, when creating window
   virtual void IDLEFUNCTION() {};      // the idle function
   virtual void RENDFUNCTION() {};      // the rendering function (WM_PAINT)
   virtual void DESTFUNCTION() {};      // called once, when destroying window
   
   virtual void ReadExtraData(char *) {};
   
   void SetThisType(const char *szType);
   void SetThisVersion(const char *szVer);
   
   void AddPropertyPages(int, PROPSHEETPAGE*);
   void Rename(char *szNew) { sprintf(td.acName,"%s",szNew); };
   
   // I want to get ride of these functions soon, as the should be redundant
   virtual void SaveData();
   virtual void RestoreSaved();
   virtual void ForgetSaved();
   
   virtual int Save(HANDLE hFile);
   virtual int Load(HANDLE hFile);
   
   const char *QueryName()    { return td.acName;  };
   const char *QueryType()    { return szTypeName; };
   const char *QueryVersion() { return szVersion;  };
   
   TESTDATA   td;

protected:
   BUFFERDATA bd;
   
   friend void SetDCPixelFormat(HDC hDC);

private:
   char szTypeName[MAXTYPELENGTH];
   char szVersion[TOTALVERLENGTH];

   PROPSHEETPAGE *aPSpages;
   int            iNumConfigPages;
};

#endif  // PROFILETEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\square.h ===
#ifndef SQUARE_TEST_H
#define SQUARE_TEST_H

class SquareTest : public SkeletonTest
{
private:
   typedef SkeletonTest parent;

public:
   SquareTest();
   
   virtual void INITFUNCTION();
   virtual void IDLEFUNCTION();
   virtual void RENDFUNCTION();

private:
   // Square position and size
   GLfloat fX1, fY1;
   GLsizei iRsize;
   
   // Step size in x and y directions
   GLfloat fXstep, fYstep;
   
   // Keep track of the window size
   GLfloat fWindowWidth, fWindowHeight;
};

#endif // SQUARE_TEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\teapot.cpp ===
#include <windows.h>
#include <gl\gl.h>
#include <gl\glaux.h>
#include <stdio.h>

#include "skeltest.h"
#include "hugetest.h"
#include "teapot.h"

TeapotTest::TeapotTest()
{
   SetThisType("Teapot");
   SetThisVersion("1.0");
   
   td.swapbuffers = TRUE;
   td.iDuration   = 30000;
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   sprintf(td.acName, "3D Teapot (aux)");
   sprintf(td.acTestStatName, "Frames");
   
   bd.uiClear  = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT;
   bd.fClearColor[0] = 0.0f;
   bd.fClearColor[1] = 0.0f;
   bd.fClearColor[2] = 0.0f;
   bd.cColorBits  = 24;
   bd.cDepthBits  = 16;
   bd.bDepthTestEnable = TRUE;
   bd.iDepthFunction   = LEQUAL;
   bd.bNormalize  = TRUE;
   bd.bAutoNormal = TRUE;
   bd.iShadeModel = SMOOTH;

   rd.bPolyCullFaceEnable = TRUE;
   rd.iPolyDir = GL_CW;

   afDrawColor[0] = 1.0;
   afDrawColor[1] = 1.0;
   afDrawColor[2] = 1.0;

   range.fxMin = -3.5;
   range.fyMin = -3.5;
   range.fzMin = -3.5;
   range.fxMax =  3.5;
   range.fyMax =  3.5;
   range.fzMax =  3.5;

   fAngle = 0.0f;
}

GLfloat  specref[] =  { 1.0f, 1.0f, 1.0f, 1.0f };

void TeapotTest::INITFUNCTION()
{
   parent::initfunct(w,h);
   
   // Set Material properties to follow glColor values
   glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
   
   // All materials hereafter have full specular reflectivity
   // with a high shine
   glMaterialfv(GL_FRONT, GL_SPECULAR, specref);
   glMateriali(GL_FRONT, GL_SHININESS, 128);
}

void TeapotTest::IDLEFUNCTION()
{
   fAngle += 5.0f;
}

void TeapotTest::RENDFUNCTION()
{
   glClearColor(bd.fClearColor[0],bd.fClearColor[1],
                bd.fClearColor[2],bd.fClearColor[3]);
   glClear(bd.uiClear);
   
   glColor3f(afDrawColor[0], afDrawColor[1], afDrawColor[2]);
   
   glPushMatrix(); {
      glRotatef(30.0, 1.0, 0.0, 0.0);
      glRotatef(fAngle, 0.0, 1.0, 0.0);
      auxSolidTeapot(2.0);
   } glPopMatrix();
   
   glFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\square.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <windows.h>
#include <gl\gl.h>

#include "skeltest.h"
#include "square.h"

SquareTest::SquareTest()
{
   static BOOL b = FALSE;
   if (!b) {
      srand((unsigned)time(NULL));
      b = TRUE;
   }
   
   td.swapbuffers = FALSE;
   td.iDuration   = 10000;
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   sprintf(td.acName,"Bouncing Square (demo only)");
   bd.cColorBits  = 8;
   bd.cDepthBits  = 16;
   
   iRsize = 50;
   fXstep = 1.0f;
   fYstep = 1.0f;
}

void SquareTest::INITFUNCTION()
{
   // Prevent a divide by zero, when window is too short
   // (you cant make a window of zero width).
   if(h == 0)   h = 1;
   
   fX1 = (GLfloat) rand()/100.0f;
   fY1 = (GLfloat) rand()/150.0f;
   
   // Set the viewport to be the entire window
   glViewport(0, 0, w, h);
   
   // Reset the coordinate system before modifying
   glLoadIdentity();
   
   // Keep the square square, this time, save calculated
   // width and height for later use
   if (w <= h) {
      fWindowHeight = 250.0f*h/w;
      fWindowWidth = 250.0f;
   } else {
      fWindowWidth = 250.0f*w/h;
      fWindowHeight = 250.0f;
   }
   
   // Set the clipping volume
   glOrtho(0.0f, fWindowWidth, 0.0f, fWindowHeight, 1.0f, -1.0f);
}

void SquareTest::IDLEFUNCTION()
{
   // Reverse direction when you reach left or right edge
   if(fX1 > fWindowWidth-iRsize || fX1 < 0)
      fXstep = -fXstep;
   
   // Reverse direction when you reach top or bottom edge
   if(fY1 > fWindowHeight-iRsize || fY1 < 0)
      fYstep = -fYstep;
   
   // Check bounds.  This is incase the window is made
   // smaller and the rectangle is outside the new
   // clipping volume
   if(fX1 > fWindowWidth-iRsize)
      fX1 = fWindowWidth-iRsize-1;
   
   if(fY1 > fWindowHeight-iRsize)
      fY1 = fWindowHeight-iRsize-1;
   
   // Actually move the square
   fX1 += fXstep;
   fY1 += fYstep;
}

void SquareTest::RENDFUNCTION()
{
   // Set background clearing color to blue
   glClearColor(0.0f, 0.0f, 1.0f, 1.0f);
   // Clear the window with current clearing color
   glClear(GL_COLOR_BUFFER_BIT);
   // Set drawing color to Red, and draw rectangle at
   // current position.
   glColor3f(1.0f, 0.0f, 0.0f);
   glRectf(fX1, fY1, fX1+iRsize, fY1+iRsize);
   glFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\teapot.h ===
#ifndef TEAPOT_TEST_H
#define TEAPOT_TEST_H

class TeapotTest : public HugeTest
{
private:
   typedef HugeTest parent;

public:
   TeapotTest();
   
   virtual void IDLEFUNCTION();
   virtual void INITFUNCTION();
   virtual void RENDFUNCTION();

private:
   GLfloat fAngle;
};

#endif // TEAPOT_TEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\texture.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <commdlg.h>
#include <math.h>
#include <gl/gl.h>
#include <gl/glu.h>
#include <gl/glaux.h>

#include "hugetest.h"
#include "texture.h"
#include "resource.h"
#include "ui_huge.h"
#include "macros.h"

extern HINSTANCE hInstance;

BOOL PreviewImage(HWND hDlg, ImageType cWhichImage, char *szFileName);
BOOL LoadImage(TEXTUREDATA *pxd);

#define COLOR_STRING "Color Pattern"
#define MONO_STRING "Monochrome Checkers"

#define CHECKERWIDTH    64
#define CHECKERHEIGHT   64
GLubyte acMonoCheckerImage[3 * CHECKERWIDTH * CHECKERHEIGHT];
GLubyte acColorImage[3 * CHECKERWIDTH * CHECKERHEIGHT];
AUX_RGBImageRec MonoImageRec;
AUX_RGBImageRec ColorImageRec;

void MakeMonoCheckerImage()
{
   int i, j, c;
   
   static BOOL done = FALSE;
   if (done) return;
   done = TRUE;
   
   MonoImageRec.sizeX = CHECKERWIDTH;
   MonoImageRec.sizeY = CHECKERHEIGHT;
   MonoImageRec.data  = acMonoCheckerImage;
   
   for (i = 0 ; i < CHECKERWIDTH ; i++) {
      for (j = 0 ; j < CHECKERHEIGHT ; j++) {
         c = ((((i&0x8)==0)^((j&0x8))==0))*255;
         acMonoCheckerImage[3 * (CHECKERHEIGHT * i + j) + 0] = (GLubyte) c;
         acMonoCheckerImage[3 * (CHECKERHEIGHT * i + j) + 1] = (GLubyte) c;
         acMonoCheckerImage[3 * (CHECKERHEIGHT * i + j) + 2] = (GLubyte) c;
      }
   }
}

void MakeColorImage(void)
{
   int i, j;
   float ti, tj;
   
   static BOOL done = FALSE;
   if (done) return;
   done = TRUE;
   
   ColorImageRec.sizeX = CHECKERWIDTH;
   ColorImageRec.sizeY = CHECKERHEIGHT;
   ColorImageRec.data  = acColorImage;

   for (i = 0; i < CHECKERWIDTH; i++) {
      ti = 2.0f*3.14159265f*i/CHECKERWIDTH;
      for (j = 0; j < CHECKERHEIGHT; j++) {
         tj = 2.0f*3.14159265f*j/CHECKERHEIGHT;
         acColorImage[3*(CHECKERHEIGHT*i+j)+0]=(GLubyte)(127*(1.0+sin(ti)));
         acColorImage[3*(CHECKERHEIGHT*i+j)+1]=(GLubyte)(127*(1.0+cos(2*tj)));
         acColorImage[3*(CHECKERHEIGHT*i+j)+2]=(GLubyte)(127*(1.0+cos(ti+tj)));
      }
   }
}

void InitXD(TEXTUREDATA *pxd)
{
   MakeMonoCheckerImage();
   MakeColorImage();
   bzero(pxd,sizeof(TEXTUREDATA));
   BEGINstring(pxd, "texture");
   ENDstring(pxd,   "texture");
   
   sprintf(pxd->szFileName, MONO_STRING);
   pxd->cWhichImage  = MONO_CHECKERS;
   pxd->iHeight      = CHECKERHEIGHT;
   pxd->iWidth       = CHECKERWIDTH;
   pxd->iBorder      = 0;
   pxd->iQuality     = DONT_CARE;
   pxd->bEnable1D    = FALSE;
   pxd->bEnable2D    = FALSE;
   pxd->bBuildMipmap = TRUE;
   pxd->aiFilter[0]  = NEAREST_MIPMAP_LINEAR;
   pxd->aiFilter[1]  = LINEAR;
   pxd->aiFilter[2]  = NEAREST_MIPMAP_LINEAR;
   pxd->aiFilter[3]  = LINEAR;
   pxd->iEnvMode     = MODULATE;
   pxd->iGenModeS    = EYE_LINEAR;
   pxd->iGenModeT    = EYE_LINEAR;
   pxd->iGenModeR    = EYE_LINEAR;
   pxd->iGenModeQ    = EYE_LINEAR;
   pxd->bAutoGenS    = TRUE;
   pxd->bAutoGenT    = TRUE;
   pxd->bAutoGenR    = FALSE;
   pxd->bAutoGenQ    = FALSE;
   pxd->iWrapS       = REPEAT;
   pxd->iWrapT       = REPEAT;
   
   LoadImage(pxd);
} // void InitXD(TEXTUREDATA *pxd);

void texture_init(const TEXTUREDATA xd)
{
   byte  *Image = NULL;
   int    iWidth, iHeight;
   byte   Image64[64][64][3];
   int    iErr;

   float  Debug_S[] = { 1.0, 1.0, 1.0, 0.0 };
   float  Debug_T[] = { 0.0, 1.0, 0.0, 0.0 };
   
   Image   = xd.acImage;
   iWidth  = xd.iWidth;
   iHeight = xd.iHeight;
   
   switch (xd.iQuality) {
   case FASTEST:   glHint(GL_PERSPECTIVE_CORRECTION_HINT,GL_FASTEST);   break;
   case DONT_CARE: glHint(GL_PERSPECTIVE_CORRECTION_HINT,GL_DONT_CARE); break;
   case NICEST:    glHint(GL_PERSPECTIVE_CORRECTION_HINT,GL_NICEST);    break;
   }

   if (xd.bEnable1D || xd.bEnable2D) {
      switch (xd.iEnvMode) {
      case 0: glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);    break;
      case 1: glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE); break;
      case 2: glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_BLEND);    break;
      }
   } // if (xd.bEnable1D || xd.bEnable2D)

   switch (xd.iWrapS) {
   case CLAMP:  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
      break;
   case REPEAT: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
      break;
   }

   switch (xd.iWrapT) {
   case CLAMP:  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
      break;
   case REPEAT: glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
      break;
   }

   if (xd.bEnable2D) {
      if (!Image) {
         MessageBox(NULL, "ERROR: No texture image found, using default!",
                    NULL, MB_OK | MB_ICONERROR);
         Image   = MonoImageRec.data;
         iWidth  = MonoImageRec.sizeX;
         iHeight = MonoImageRec.sizeY;
      }
      
      glTexImage2D(GL_TEXTURE_2D, 0, 3, iWidth, iHeight, xd.iBorder,
                   GL_RGB, GL_UNSIGNED_BYTE, Image);
      
      if (xd.bBuildMipmap) {
         glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
         iErr = gluScaleImage(GL_RGB, iWidth, iHeight, GL_UNSIGNED_BYTE,
                              Image, 64, 64, GL_UNSIGNED_BYTE, Image64);
         iErr = gluBuild2DMipmaps(GL_TEXTURE_2D, 3, 64, 64, GL_RGB,
                                  GL_UNSIGNED_BYTE, Image64);
      }
      
      switch (xd.aiFilter[2]) {
      case 0:
         glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
         break;
      case 1:
         glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
         break;
      case 2:
         glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);
         break;
      case 3:
         glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);
         break;
      case 4:
         glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);
         break;
      case 5:
         glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
         break;
      } // switch (xd.aiFilter[2])

      switch (xd.aiFilter[3]) {
      case 0:glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
         break;
      case 1:glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
         break;
      } // switch (xd.aiFilter[3])

      glEnable(GL_TEXTURE_2D);
   } else {                     // if (xd.bEnable2D)
      glDisable(GL_TEXTURE_2D);
   } // if (xd.bEnable2D) (else)

   switch (xd.iGenModeS)
      {
      case DISABLE: break;
      case OBJECT_LINEAR:
         glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR); break;
      case EYE_LINEAR:
         glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);    break;
      case SPHERE_MAP:
         glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);    break;
      }
   
   switch (xd.iGenModeT)
      {
      case DISABLE: break;
      case OBJECT_LINEAR:
         glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR); break;
      case EYE_LINEAR:
         glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);    break;
      case SPHERE_MAP:
         glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);    break;
      }
   
   switch (xd.iGenModeR)
      {
      case DISABLE: break;
      case OBJECT_LINEAR:
         glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR); break;
      case EYE_LINEAR:
         glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);    break;
      case SPHERE_MAP:
         glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);    break;
      }
   
   switch (xd.iGenModeQ)
      {
      case DISABLE: break;
      case OBJECT_LINEAR:
         glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR); break;
      case EYE_LINEAR:
         glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);    break;
      case SPHERE_MAP:
         glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);    break;
      }
   
   GL_EnableOrDisable(xd.bAutoGenS, GL_TEXTURE_GEN_S);
   GL_EnableOrDisable(xd.bAutoGenT, GL_TEXTURE_GEN_T);
   GL_EnableOrDisable(xd.bAutoGenR, GL_TEXTURE_GEN_R);
   GL_EnableOrDisable(xd.bAutoGenQ, GL_TEXTURE_GEN_Q);
}

BOOL PreviewImage(HWND hDlg, ImageType cWhichImage, char *szFileName)
{
   HBITMAP hBitmap;
   AUX_RGBImageRec *pImageRec;
   
   switch (cWhichImage)
      {
      case COLOR_CHECKERS:
         hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_COLOR_CHECKERS));
         szFileName = COLOR_STRING;
         pImageRec = &ColorImageRec;
         break;

      case MONO_CHECKERS:
         hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_MONO_CHECKERS));
         szFileName = MONO_STRING;
         pImageRec = &MonoImageRec;
         break;

      case EXTERNAL:
         pImageRec = auxDIBImageLoadA(szFileName);
         break;

      default:
         return FALSE;
      }
   
   if (!pImageRec)
      return FALSE;
   
   SetDlgItemText(hDlg, X_IDC_FILENAME, szFileName);
   SetDlgItemInt(hDlg,  X_IDC_WIDTH,    pImageRec->sizeX, TRUE);
   SetDlgItemInt(hDlg,  X_IDC_HEIGHT,   pImageRec->sizeY, TRUE);
   
   if (cWhichImage == EXTERNAL) {
      free(pImageRec->data);
      free(pImageRec);
   }
   
   return TRUE;
}

BOOL UnloadImage(TEXTUREDATA *pxd)
{
   if (pxd->cWhichImage == EXTERNAL) {
      free(pxd->acImage);
   }
   pxd->cWhichImage = NONE;
   pxd->acImage = NULL;
   return TRUE;
}

// loads the appropriate image file into pxd->acImage
BOOL LoadImage(TEXTUREDATA *pxd)
{
   HBITMAP hBitmap;
   AUX_RGBImageRec *pImageRec;
   
   if (pxd->cWhichImage == EXTERNAL) {
      pImageRec = auxDIBImageLoadA(pxd->szFileName);
      if (pImageRec) {
         pxd->acImage = pImageRec->data;
         pxd->iWidth  = pImageRec->sizeX;
         pxd->iHeight = pImageRec->sizeY;
         free(pImageRec);
      } else {
         pxd->cWhichImage = MONO_CHECKERS;
      }
   }
   
   switch (pxd->cWhichImage)
      {
      case COLOR_CHECKERS:
         hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_COLOR_CHECKERS));
         pxd->acImage = (byte*) acColorImage;
         pxd->iWidth  = CHECKERWIDTH;
         pxd->iHeight = CHECKERHEIGHT;
         break;

      case MONO_CHECKERS:
         hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_MONO_CHECKERS));
         pxd->acImage = (byte*) acMonoCheckerImage;
         pxd->iWidth  = CHECKERWIDTH;
         pxd->iHeight = CHECKERHEIGHT;
         break;

      case EXTERNAL:
         break;

      default:
         return FALSE;
      }
   return TRUE;
}

#ifndef NO_UI_IN_CNFG

void texture_SetDisplayFromData(HWND hDlg, const TEXTUREDATA *pxd)
{
   CB_DlgSetSelect(hDlg,   X_IDC_ENV_MODE,            pxd->iEnvMode);
   CB_DlgSetSelect(hDlg,   X_IDC_FILTER1,             pxd->aiFilter[0]);
   CB_DlgSetSelect(hDlg,   X_IDC_FILTER2,             pxd->aiFilter[1]);
   CB_DlgSetSelect(hDlg,   X_IDC_FILTER3,             pxd->aiFilter[2]);
   CB_DlgSetSelect(hDlg,   X_IDC_FILTER4,             pxd->aiFilter[3]);
   CB_DlgSetSelect(hDlg,   X_IDC_GEN_MODE_S,          pxd->iGenModeS);
   CB_DlgSetSelect(hDlg,   X_IDC_PERSPECTIVE_QUALITY, pxd->iQuality);
   CB_DlgSetSelect(hDlg,   X_IDC_WRAP_S,              pxd->iWrapS);
   CB_DlgSetSelect(hDlg,   X_IDC_WRAP_T,              pxd->iWrapT);
   CheckDlgButton(hDlg,    X_IDC_1D_ENABLE,           pxd->bEnable1D?1:0);
   CheckDlgButton(hDlg,    X_IDC_2D_ENABLE,           pxd->bEnable2D?1:0);
   CheckDlgButton(hDlg,    X_IDC_AUTOMATIC_Q,         pxd->bAutoGenQ?1:0);
   CheckDlgButton(hDlg,    X_IDC_AUTOMATIC_R,         pxd->bAutoGenR?1:0);
   CheckDlgButton(hDlg,    X_IDC_AUTOMATIC_S,         pxd->bAutoGenS?1:0);
   CheckDlgButton(hDlg,    X_IDC_AUTOMATIC_T,         pxd->bAutoGenT?1:0);
   CheckDlgButton(hDlg,    X_IDC_BUILD_MIPMAP,        pxd->bBuildMipmap?1:0);
   SetDlgFloatString(hDlg, X_IDC_BORDER_COLOR1,       pxd->afBorderColor[0]);
   SetDlgFloatString(hDlg, X_IDC_BORDER_COLOR2,       pxd->afBorderColor[1]);
   SetDlgFloatString(hDlg, X_IDC_BORDER_COLOR3,       pxd->afBorderColor[2]);
   SetDlgFloatString(hDlg, X_IDC_BORDER_COLOR4,       pxd->afBorderColor[3]);
   SetDlgItemInt(hDlg,     X_IDC_BORDER,              pxd->iBorder, TRUE);
   SetDlgItemInt(hDlg,     X_IDC_HEIGHT,              pxd->iHeight, TRUE);
   SetDlgItemInt(hDlg,     X_IDC_WIDTH,               pxd->iWidth,  TRUE);
   SetDlgItemText(hDlg,    X_IDC_FILENAME,            pxd->szFileName);
} // void texture_SetDisplayFromData(HWND hDlg, const TEXTUREDATA *pxd);

void texture_GetDataFromDisplay(HWND hDlg, TEXTUREDATA *pxd)
{
   UnloadImage(pxd);
   
   GetDlgItemText(hDlg,X_IDC_FILENAME,pxd->szFileName,sizeof(pxd->szFileName));
   pxd->afBorderColor[0] = GetDlgFloatString(hDlg, X_IDC_BORDER_COLOR1);
   pxd->afBorderColor[1] = GetDlgFloatString(hDlg, X_IDC_BORDER_COLOR2);
   pxd->afBorderColor[2] = GetDlgFloatString(hDlg, X_IDC_BORDER_COLOR3);
   pxd->afBorderColor[3] = GetDlgFloatString(hDlg, X_IDC_BORDER_COLOR4);
   pxd->aiFilter[0]  = CB_DlgGetSelect(hDlg,        X_IDC_FILTER1);
   pxd->aiFilter[1]  = CB_DlgGetSelect(hDlg,        X_IDC_FILTER2);
   pxd->aiFilter[2]  = CB_DlgGetSelect(hDlg,        X_IDC_FILTER3);
   pxd->aiFilter[3]  = CB_DlgGetSelect(hDlg,        X_IDC_FILTER4);
   pxd->bAutoGenQ    = IsDlgButtonChecked(hDlg,     X_IDC_AUTOMATIC_Q);
   pxd->bAutoGenR    = IsDlgButtonChecked(hDlg,     X_IDC_AUTOMATIC_R);
   pxd->bAutoGenS    = IsDlgButtonChecked(hDlg,     X_IDC_AUTOMATIC_S);
   pxd->bAutoGenT    = IsDlgButtonChecked(hDlg,     X_IDC_AUTOMATIC_T);
   pxd->bBuildMipmap = IsDlgButtonChecked(hDlg,     X_IDC_BUILD_MIPMAP);
   pxd->bEnable1D    = IsDlgButtonChecked(hDlg,     X_IDC_1D_ENABLE);
   pxd->bEnable2D    = IsDlgButtonChecked(hDlg,     X_IDC_2D_ENABLE);
   pxd->iBorder      = GetDlgItemInt(hDlg,          X_IDC_BORDER, NULL, TRUE);
   pxd->iEnvMode     = CB_DlgGetSelect(hDlg,        X_IDC_ENV_MODE);
   pxd->iEnvMode     = CB_DlgGetSelect(hDlg,        X_IDC_ENV_MODE);
   pxd->iGenModeS    = CB_DlgGetSelect(hDlg,        X_IDC_GEN_MODE_S);
   pxd->iGenModeT = pxd->iGenModeR = pxd->iGenModeQ = pxd->iGenModeS;
   pxd->iHeight      = GetDlgItemInt(hDlg,          X_IDC_HEIGHT, NULL, TRUE);
   pxd->iQuality     = CB_DlgGetSelect(hDlg,        X_IDC_PERSPECTIVE_QUALITY);
   pxd->iWidth       = GetDlgItemInt(hDlg,          X_IDC_WIDTH,  NULL, TRUE);
   pxd->iWrapS       = CB_DlgGetSelect(hDlg,        X_IDC_WRAP_S);
   pxd->iWrapT       = CB_DlgGetSelect(hDlg,        X_IDC_WRAP_T);
   
   pxd->cWhichImage = EXTERNAL;
   /* This switch statement is setup and use for speed, because it's much
    * faster than using several if statements which all call strcmp.
    * It is likely that szFileName begins with "C:\" so we check for "C:", not
    * just "C".
    */
   switch (pxd->szFileName[0])
      {
      case 'c':
      case 'C':
         if (pxd->szFileName[1] != ':')
            if (0 == strcmp(pxd->szFileName, COLOR_STRING))
               pxd->cWhichImage = COLOR_CHECKERS;
         break;

      case 'm':
      case 'M':
         if (0 == strcmp(pxd->szFileName, MONO_STRING))
            pxd->cWhichImage = MONO_CHECKERS;
         break;
      }
   LoadImage(pxd);
} // void texture_GetDataFromDisplay(HWND hDlg, TEXTUREDATA *pxd);

void ShowOrHideFilter(HWND hDlg)
{
   int iIDs[] = { X_IDC_FILTER1, X_IDC_FILTER2, X_IDC_FILTER3, X_IDC_FILTER4 };
   int i, iShow;
   
   iShow  = IsDlgButtonChecked(hDlg,X_IDC_FILTER_MAG);
   iShow += IsDlgButtonChecked(hDlg,X_IDC_FILTER_2D)  ? 2 : 0;
   for (i = 0 ; i < 4 ; i++) {
      ShowWindow(GetDlgItem(hDlg, iIDs[i]), iShow==i ? SW_SHOWNORMAL: SW_HIDE);
   }
} // void ShowOrHideFilter(HWND hDlg)

BOOL CALLBACK hugeTextureDlgProc(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
   static TEXTUREDATA *pxd = NULL;
   static OPENFILENAME ofn;
   static char szFileName[_MAX_PATH];
   static char szTitleName[_MAX_FNAME + _MAX_EXT];
   static char szFilter[] = "Bitmap Files (*.bmp)\0*.bmp\0"  \
      "All Files (*.*)\0*.*\0\0" ;

   switch (msg)
      {
      case WM_INITDIALOG:
         pxd = (TEXTUREDATA*) (((PROPSHEETPAGE*)lParam)->lParam);
         CB_DlgAddString(hDlg, X_IDC_PERSPECTIVE_QUALITY, "Fastest");
         CB_DlgAddString(hDlg, X_IDC_PERSPECTIVE_QUALITY, "Don't Care");
         CB_DlgAddString(hDlg, X_IDC_PERSPECTIVE_QUALITY, "Nicest");
         CB_DlgAddString(hDlg, X_IDC_ENV_MODE, "Decal");
         CB_DlgAddString(hDlg, X_IDC_ENV_MODE, "Modulate");
         CB_DlgAddString(hDlg, X_IDC_ENV_MODE, "Blend");
         // CB_DlgAddString(hDlg, X_IDC_GEN_MODE_S, "<disabled>");
         CB_DlgAddString(hDlg, X_IDC_GEN_MODE_S, "Object Linear");
         CB_DlgAddString(hDlg, X_IDC_GEN_MODE_S, "Eye Linear");
         CB_DlgAddString(hDlg, X_IDC_GEN_MODE_S, "Sphere Map");
         CheckDlgButton(hDlg,  X_IDC_FILTER_2D,  1);
         CheckDlgButton(hDlg,  X_IDC_FILTER_MAG, 1);
         CB_DlgAddString(hDlg, X_IDC_FILTER1, "Nearest");
         CB_DlgAddString(hDlg, X_IDC_FILTER1, "Linear");
         CB_DlgAddString(hDlg, X_IDC_FILTER1, "Nearest Mipmap Nearest");
         CB_DlgAddString(hDlg, X_IDC_FILTER1, "Nearest Mipmap Linear");
         CB_DlgAddString(hDlg, X_IDC_FILTER1, "Linear Mipmap Nearest");
         CB_DlgAddString(hDlg, X_IDC_FILTER1, "Linear Mipmap Linear");
         CB_DlgAddString(hDlg, X_IDC_FILTER2, "Nearest");
         CB_DlgAddString(hDlg, X_IDC_FILTER2, "Linear");
         CB_DlgAddString(hDlg, X_IDC_FILTER3, "Nearest");
         CB_DlgAddString(hDlg, X_IDC_FILTER3, "Linear");
         CB_DlgAddString(hDlg, X_IDC_FILTER3, "Nearest Mipmap Nearest");
         CB_DlgAddString(hDlg, X_IDC_FILTER3, "Nearest Mipmap Linear");
         CB_DlgAddString(hDlg, X_IDC_FILTER3, "Linear Mipmap Nearest");
         CB_DlgAddString(hDlg, X_IDC_FILTER3, "Linear Mipmap Linear");
         CB_DlgAddString(hDlg, X_IDC_FILTER4, "Nearest");
         CB_DlgAddString(hDlg, X_IDC_FILTER4, "Linear");
         CB_DlgAddString(hDlg, X_IDC_WRAP_S, "Clamp S");
         CB_DlgAddString(hDlg, X_IDC_WRAP_S, "Repeat S");
         CB_DlgAddString(hDlg, X_IDC_WRAP_T, "Clamp T");
         CB_DlgAddString(hDlg, X_IDC_WRAP_T, "Repeat T");
         ShowOrHideFilter(hDlg);
         texture_SetDisplayFromData(hDlg, pxd);

         ofn.lStructSize       = sizeof (OPENFILENAME);
         ofn.hwndOwner         = hDlg;
         ofn.hInstance         = NULL;
         ofn.lpstrFilter       = szFilter;
         ofn.lpstrCustomFilter = NULL;
         ofn.nMaxCustFilter    = 0;
         ofn.nFilterIndex      = 0;
         ofn.lpstrFile         = szFileName;
         ofn.nMaxFile          = _MAX_PATH;
         ofn.lpstrFileTitle    = szTitleName;
         ofn.nMaxFileTitle     = _MAX_FNAME + _MAX_EXT;
         ofn.lpstrInitialDir   = NULL;
         ofn.lpstrTitle        = NULL;
         ofn.Flags             = OFN_FILEMUSTEXIST;
         ofn.nFileOffset       = 0;
         ofn.nFileExtension    = 0;
         ofn.lpstrDefExt       = "bmp";
         ofn.lCustData         = 0L;
         ofn.lpfnHook          = NULL;
         ofn.lpTemplateName    = NULL;
         break;

      case WM_COMMAND:
         {
            int    iControl, iNote;
            iControl = LOWORD(wParam);
            iNote = HIWORD(wParam); // notification code for edit boxes

            switch (iControl)
               {
               case X_IDC_BORDER_COLOR1:
               case X_IDC_BORDER_COLOR2:
               case X_IDC_BORDER_COLOR3:
               case X_IDC_BORDER_COLOR4:
                  if (EN_KILLFOCUS == iNote) {
                     PropSheet_Changed(GetParent(hDlg),hDlg);
                     VerifyEditboxFloat(hDlg,iControl);
                  }
                  break;

               case X_IDC_PICKFILE:
                  ofn.hwndOwner = hDlg;
                  if (GetOpenFileName (&ofn)) {
                     PreviewImage(hDlg, EXTERNAL, szFileName);
                  };
                  break;

               case X_IDC_PICKFILE_C:
                  PreviewImage(hDlg, COLOR_CHECKERS, NULL);
                  break;

               case X_IDC_PICKFILE_M:
                  PreviewImage(hDlg, MONO_CHECKERS, NULL);
                  break;

               case X_IDC_FILTER_1D:
               case X_IDC_FILTER_2D:
               case X_IDC_FILTER_MAG:
               case X_IDC_FILTER_MIN:
                  ShowOrHideFilter(hDlg);
                  break;

               default:
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;
               }
         }
      break;

      case WM_NOTIFY:
         {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
               {
               case PSN_APPLY:  // user clicked on OK or Apply
                  texture_GetDataFromDisplay(hDlg, pxd);
                  break;

               case PSN_RESET:  // user clicked on Cancel
                  break;

               case PSN_HELP:   // user clicked help
                  break;
               }
         }
      break;

      default:
         return FALSE;
      }
   return TRUE;
}

#else
#endif // NO_UI_IN_CNFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\tptlght.h ===
#ifndef TEAPOTLIGHTTEST_H
#define TEAPOTLIGHTTEST_H

class TeapotLightTest : public TeapotTest
{
private:
   typedef TeapotTest parent;

public:
   TeapotLightTest();
};

#endif // TEAPOTLIGHTTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\tptlght.cpp ===
#include <windows.h>
#include <gl\gl.h>
#include <gl\glaux.h>
#include <stdio.h>

#include "skeltest.h"
#include "hugetest.h"
#include "teapot.h"
#include "tptlght.h"

TeapotLightTest::TeapotLightTest()
{
   SetThisType("Teapot - Light");
   SetThisVersion("1.0");
   
   td.swapbuffers = TRUE;
   td.iDuration   = 30000;
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   sprintf(td.acName, "Teapot w/ Lighting (demo)");
   sprintf(td.acTestStatName, "Frames");
   
   bd.uiClear  = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT;
   bd.fClearColor[0] = 0.0f;
   bd.fClearColor[1] = 0.0f;
   bd.fClearColor[2] = 0.0f;
   bd.fClearColor[3] = 0.0f;
   bd.cColorBits  = 24;
   bd.cDepthBits  = 16;
   bd.bDepthTestEnable = TRUE;
   bd.iDepthFunction   = LEQUAL;
   bd.bNormalize  = TRUE;
   bd.bAutoNormal = TRUE;
   bd.iShadeModel = SMOOTH;

   ld.bEnable = TRUE;
   ld.aLights[0].bEnable = TRUE;
   ld.aLights[0].afAmbient[0] = 0.3f;
   ld.aLights[0].afAmbient[1] = 0.3f;
   ld.aLights[0].afAmbient[2] = 0.3f;
   ld.aLights[0].afAmbient[3] = 1.0f;
   ld.aLights[0].afDiffuse[0] = 0.8f;
   ld.aLights[0].afDiffuse[1] = 0.4f;
   ld.aLights[0].afDiffuse[2] = 0.0f;
   ld.aLights[0].afDiffuse[3] = 1.0f;
   ld.aLights[0].afSpecular[0] = 1.0f;
   ld.aLights[0].afSpecular[1] = 1.0f;
   ld.aLights[0].afSpecular[2] = 1.0f;
   ld.aLights[0].afSpecular[3] = 1.0f;
   ld.aLights[0].afPosition[0] = -50.0f;
   ld.aLights[0].afPosition[1] = 100.0f;
   ld.aLights[0].afPosition[2] = 150.0f;
   ld.aLights[0].afPosition[3] =   0.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\tpttxtr.h ===
#ifndef TEAPOT_TEXTURE_TEST_H
#define TEAPOT_TEXTURE_TEST_H

class TeapotTextureTest : public TeapotTest
{
private:
   typedef TeapotTest parent;

public:
   TeapotTextureTest();
};

#endif // TEAPOT_TEXTURE_TEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\texture.h ===
#ifndef TEXTURE_H
#define TEXTURE_H

#include <stdlib.h>

// change that to DISABLE = 0, when changing the UI
enum { DISABLE = -1, OBJECT_LINEAR, EYE_LINEAR, SPHERE_MAP };
enum { DECAL, MODULATE, BLEND };
enum {
   NEAREST, LINEAR, NEAREST_MIPMAP_NEAREST,
   NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, LINEAR_MIPMAP_LINEAR
};
typedef enum { NONE, EXTERNAL, COLOR_CHECKERS, MONO_CHECKERS } ImageType;
enum { CLAMP, REPEAT };

typedef struct {
   char   acDummy1[16];
   BOOL   bEnable1D;
   BOOL   bEnable2D;
   BOOL   bAutoGenQ;
   BOOL   bAutoGenR;
   BOOL   bAutoGenS;
   BOOL   bAutoGenT;
   BOOL   bBuildMipmap;
   int    iWrapS;
   int    iWrapT;
   int    iQuality;
   int    iGenModeS;
   int    iGenModeT;
   int    iGenModeR;
   int    iGenModeQ;
   int    iEnvMode;
   int    aiFilter[4];           // 1 Min, 1 Mag, 2 Min, 2 Mag
   char   szFileName[_MAX_PATH];
   byte   cWhichImage;
   byte  *acImage;
   float  afBorderColor[4];
   int    iWidth, iHeight, iBorder;
   
   char acDummy2[16];
} TEXTUREDATA;

void InitXD(TEXTUREDATA *pfd);
void texture_init(TEXTUREDATA fd);

#endif // TEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\tpttxtr.cpp ===
#include <windows.h>
#include <gl\gl.h>
#include <gl\glaux.h>
#include <stdio.h>
#include <math.h>

#include "hugetest.h"
#include "teapot.h"
#include "tpttxtr.h"

TeapotTextureTest::TeapotTextureTest()
{
   td.swapbuffers = TRUE;
   td.iDuration   = 10000;
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   sprintf(td.acName, "Texture Test");
   sprintf(td.acTestStatName, "whatever");

   bd.uiClear  = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT;
   bd.fClearColor[0] = 0.0;
   bd.fClearColor[1] = 0.0;
   bd.fClearColor[2] = 0.0;
   bd.cColorBits  = 8;
   bd.cDepthBits  = 16;
   bd.bDepthTestEnable = TRUE;
   bd.iDepthFunction   = LEQUAL;
   bd.bNormalize = TRUE;

   xd.bEnable2D = TRUE;
   xd.bAutoGenS = FALSE;
   xd.bAutoGenT = FALSE;
   xd.bAutoGenR = FALSE;
   xd.bAutoGenQ = FALSE;
   xd.iGenModeS = OBJECT_LINEAR;
   xd.iGenModeT = OBJECT_LINEAR;
   xd.iGenModeR = DISABLE;
   xd.iGenModeQ = DISABLE;
   xd.iEnvMode  = DECAL;
   xd.aiFilter[2] = NEAREST;
   xd.aiFilter[3] = NEAREST;

   afDrawColor[0] = 1.0;
   afDrawColor[1] = 1.0;
   afDrawColor[2] = 0.0;

   range.fxMin = -3.5;
   range.fyMin = -3.5;
   range.fzMin = -3.5;
   range.fxMax =  3.5;
   range.fyMax =  3.5;
   range.fzMax =  3.5;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\ui_huge.h ===
#ifndef UI_HUGETEST_H
#define UI_HUGETEST_H

void VerifyEditboxFloat(HWND hDlg, int iControl);
void VerifyEditboxHex(HWND hDlg, int iControl);
void SetDlgFloatString(HWND hDlg, int iControl, GLfloat f);
void SetDlgHexString(HWND hDlg, int iControl, ushort us);
GLfloat GetDlgFloatString(HWND hDlg, int iControl);
ushort  GetDlgHexString(HWND hDlg, int iControl);

#endif // UI_HUGETEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\ui_huge.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <commctrl.h>
#include <memory.h>

#include "hugetest.h"
#include "resource.h"
#include "macros.h"

#ifndef NO_UI_IN_CNFG

extern HINSTANCE hInstance;

typedef BOOL CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);

DlgProc hugeBufferDlgProc;      // buffers.cpp
DlgProc hugeFogDlgProc;         // fog.cpp
DlgProc hugeLightDlgProc;       // lighting.cpp
DlgProc hugeRasterDlgProc;      // raster.cpp
DlgProc hugeTextureDlgProc;     // texture.cpp
DlgProc hugeDummyDlgProc;

void VerifyEditboxFloat(HWND hDlg, int iControl)
{
   char   aBuf[20];
   double d;
   
   GetDlgItemText(hDlg, iControl, aBuf, sizeof(aBuf));
   d = atof(aBuf);
   sprintf(aBuf,"%g",d);
   SetDlgItemText(hDlg, iControl, aBuf);
}

void SetDlgFloatString(HWND hDlg, int iControl, GLfloat f)
{
   char aBuf[20];
   sprintf(aBuf,"%g",f);
   SetDlgItemText(hDlg, iControl, aBuf);
}

GLfloat GetDlgFloatString(HWND hDlg, int iControl)
{
   char aBuf[20];
   GetDlgItemText(hDlg, iControl, aBuf, sizeof(aBuf));
   return (GLfloat) atof(aBuf);
}

void VerifyEditboxHex(HWND hDlg, int iControl)
{
   char   aBuf[20];
   ushort us;
   
   GetDlgItemText(hDlg, iControl, aBuf, sizeof(aBuf));
   us = (ushort) strtol(aBuf, NULL, 0);
   sprintf(aBuf,"0x%04X", us);
   SetDlgItemText(hDlg, iControl, aBuf);
}

void SetDlgHexString(HWND hDlg, int iControl, ushort us)
{
   char aBuf[20];
   sprintf(aBuf,"0x%04X",us);
   SetDlgItemText(hDlg, iControl, aBuf);
}

ushort GetDlgHexString(HWND hDlg, int iControl)
{
   char aBuf[20];
   GetDlgItemText(hDlg, iControl, aBuf, sizeof(aBuf));
   return (ushort) strtol(aBuf, NULL, 0);
}

void HugeTest::UI_init()
{
   PROPSHEETPAGE pspage[6];
   
   // Zero out property PAGE data
   bzero (&pspage, sizeof(pspage)) ;
   
   pspage[0].dwSize      = sizeof(PROPSHEETPAGE);
   pspage[0].dwFlags     = PSP_USECALLBACK;
   pspage[0].hInstance   = hInstance;
   pspage[0].pszTemplate = MAKEINTRESOURCE (IDD_BUFFERS);
   pspage[0].pfnDlgProc  = (DLGPROC) hugeBufferDlgProc;
   pspage[0].lParam      = (LPARAM) &bd;
      
   pspage[1].dwSize      = sizeof(PROPSHEETPAGE);
   pspage[1].dwFlags     = PSP_USECALLBACK;
   pspage[1].hInstance   = hInstance;
   pspage[1].pszTemplate = MAKEINTRESOURCE (IDD_FOG);
   pspage[1].pfnDlgProc  = (DLGPROC) hugeFogDlgProc;
   pspage[1].lParam      = (LPARAM) &fd;
   
   pspage[2].dwSize      = sizeof(PROPSHEETPAGE);
   pspage[2].dwFlags     = PSP_USECALLBACK;
   pspage[2].hInstance   = hInstance;
   pspage[2].pszTemplate = MAKEINTRESOURCE (IDD_LIGHTING);
   pspage[2].pfnDlgProc  = (DLGPROC) hugeLightDlgProc;
   pspage[2].lParam      = (LPARAM) &ld;

   pspage[3].dwSize      = sizeof(PROPSHEETPAGE);
   pspage[3].dwFlags     = PSP_USECALLBACK;
   pspage[3].hInstance   = hInstance;
   pspage[3].pszTemplate = MAKEINTRESOURCE (IDD_RASTERIZATION);
   pspage[3].pfnDlgProc  = (DLGPROC) hugeRasterDlgProc;
   pspage[3].lParam      = (LPARAM) &rd;
   
   pspage[4].dwSize      = sizeof(PROPSHEETPAGE);
   pspage[4].dwFlags     = PSP_USECALLBACK;
   pspage[4].hInstance   = hInstance;
   pspage[4].pszTemplate = MAKEINTRESOURCE (IDD_TEXTURING);
   pspage[4].pfnDlgProc  = (DLGPROC) hugeTextureDlgProc;
   pspage[4].lParam      = (LPARAM) &xd;
   
   AddPropertyPages(5, pspage);
}

BOOL CALLBACK hugeDummyDlgProc(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
   switch (msg)
      {
      case WM_INITDIALOG:
         return TRUE;

      case WM_COMMAND:
         {
            int    iControl, iNote;
            iControl = LOWORD(wParam);
            iNote = HIWORD(wParam); // notification code for edit boxes
            
            switch (iControl)
               {
               case P_IDC_POINT1:
               case P_IDC_POINT2:
               case P_IDC_POINT3:
                  if (EN_KILLFOCUS == iNote) {
                     PropSheet_Changed(GetParent(hDlg),hDlg);
                     VerifyEditboxFloat(hDlg,iControl);
                  }
                  break;

               default:
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;
               }
         }
      break;

      case WM_NOTIFY:
         {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
               {
               case PSN_APPLY:  // user clicked on OK or Apply
                  break;

               case PSN_RESET:  // user clicked on Cancel
                  break;

               case PSN_HELP:   // user clicked help
                  break;
               }
         }
      break;

      default:
         return FALSE;
      }
   return TRUE;
}

#else
void HugeTest::UI_init() {};
#endif // NO_UI_IN_CNFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\taccum.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
//#include <unistd.h>
#include <stdlib.h>
#include "tk.h"


GLenum doubleBuffer, directRender;
GLint thing1, thing2;


static void Init(void)
{

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearAccum(0.0, 0.0, 0.0, 0.0);

    thing1 = glGenLists(1);
    glNewList(thing1, GL_COMPILE);
	glColor3f(1.0, 0.0, 0.0);
	glRectf(-1.0, -1.0, 1.0, 0.0);
    glEndList();

    thing2 = glGenLists(1);
    glNewList(thing2, GL_COMPILE);
	glColor3f(0.0, 1.0, 0.0);
	glRectf(0.0, -1.0, 1.0, 1.0);
    glEndList();
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_1:
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	break;
      case TK_2:
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glPushMatrix();

    glScalef(0.8, 0.8, 1.0);

    glClear(GL_COLOR_BUFFER_BIT);
    glCallList(thing1);
    glAccum(GL_LOAD, 0.5);

    glClear(GL_COLOR_BUFFER_BIT);
    glCallList(thing2);
    glAccum(GL_ACCUM, 0.5);

    glAccum(GL_RETURN, 1.0);

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    type = TK_RGB | TK_ACCUM;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Accum Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\ddtex.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <math.h>
#include <time.h>
#include <sys\types.h>
#include <sys\timeb.h>
#include <stdlib.h>
#include <ddraw.h>
#include "tk.h"

#pragma warning(disable:4244)

GLenum doubleBuffer, directRender;

LPDIRECTDRAWSURFACE pddsTex;
DDSURFACEDESC ddsdTex;

#define WWIDTH 300
#define WHEIGHT 300

#define TWIDTH 256
#define THEIGHT 256

#define TRAIL_X 1
#define TRAIL_Y 1
#define TRAIL_WIDTH (TWIDTH-2*TRAIL_X)
#define TRAIL_HEIGHT (THEIGHT-2*TRAIL_Y)

#define TRAIL_SPEED (TRAIL_WIDTH/16)
#define TRAIL_MIN_SPEED 2
#define TRAIL_RAND_SPEED() ((rand() % TRAIL_SPEED)+TRAIL_MIN_SPEED)

#define TRAIL 16
#define NEXT_TRAIL_IDX(idx) (((idx)+1) & (TRAIL-1))
POINT trail[TRAIL][2];
POINT vel[2];
int trail_idx = 0;

double trail_hue = 0.0;
#define HUE_STEP 1.0
#define NEXT_TRAIL_HUE(hue) \
    ((hue) < (360.0-HUE_STEP) ? (hue)+HUE_STEP : (hue)+HUE_STEP-360.0)

float *minFilter, *magFilter, *sWrapMode, *tWrapMode;
float decal[] = {GL_DECAL};
float modulate[] = {GL_MODULATE};
float repeat[] = {GL_REPEAT};
float clamp[] = {GL_CLAMP};
float nr[] = {GL_NEAREST};
float ln[] = {GL_LINEAR};
float nr_mipmap_nr[] = {GL_NEAREST_MIPMAP_NEAREST};
float nr_mipmap_ln[] = {GL_NEAREST_MIPMAP_LINEAR};
float ln_mipmap_nr[] = {GL_LINEAR_MIPMAP_NEAREST};
float ln_mipmap_ln[] = {GL_LINEAR_MIPMAP_LINEAR};
GLint sphereMap[] = {GL_SPHERE_MAP};

GLboolean displayFrameRate = GL_FALSE;
GLboolean animate = GL_TRUE;
GLboolean spin = GL_TRUE;
GLboolean showSphere = GL_FALSE;
GLint frames, curFrame = 0, nextFrame = 0;
GLint frameCount = 0;
GLenum doDither = GL_TRUE;
GLenum doSphere = GL_FALSE;
float xRotation = 0.0, yRotation = 0.0, zTranslate = -3.125;

GLint cube;
float c[6][4][3] = {
    {
	{
	    1.0, 1.0, -1.0
	},
	{
	    -1.0, 1.0, -1.0
	},
	{
	    -1.0, -1.0, -1.0
	},
	{
	    1.0, -1.0, -1.0
	}
    },
    {
	{
	    1.0, 1.0, 1.0
	},
	{
	    1.0, 1.0, -1.0
	},
	{
	    1.0, -1.0, -1.0
	},
	{
	    1.0, -1.0, 1.0
	}
    },
    {
	{
	    -1.0, 1.0, 1.0
	},
	{
	    1.0, 1.0, 1.0
	},
	{
	    1.0, -1.0, 1.0
	},
	{
	    -1.0, -1.0, 1.0
	}
    },
    {
	{
	    -1.0, 1.0, -1.0
	},
	{
	    -1.0, 1.0, 1.0
	},
	{
	    -1.0, -1.0, 1.0
	},
	{
	    -1.0, -1.0, -1.0
	}
    },
    {
	{
	    -1.0, 1.0, 1.0
	},
	{
	    -1.0, 1.0, -1.0
	},
	{
	    1.0, 1.0, -1.0
	},
	{
	    1.0, 1.0, 1.0
	}
    },
    {
	{
	    -1.0, -1.0, -1.0
	},
	{
	    -1.0, -1.0, 1.0
	},
	{
	    1.0, -1.0, 1.0
	},
	{
	    1.0, -1.0, -1.0
	}
    }
};
static float n[6][3] = {
    {
	0.0, 0.0, -1.0
    },
    {
	1.0, 0.0, 0.0
    },
    {
	0.0, 0.0, 1.0
    },
    {
	-1.0, 0.0, 0.0
    },
    {
	0.0, 1.0, 0.0
    },
    {
	0.0, -1.0, 0.0
    }
};
#if 0
static float t[6][4][2] = {
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    -0.1,  1.1
	},
	{
	    1.1, 1.1
	},
	{
	    1.1, -0.1
	},
	{
	    -0.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
};
#else
static float t[6][4][2] = {
    {
	{
	    1.0,  1.0
	},
	{
	    -0.0, 1.0
	},
	{
	    -0.0, -0.0
	},
	{
	    1.0,  -0.0
	}
    },
    {
	{
	    1.0,  1.0
	},
	{
	    -0.0, 1.0
	},
	{
	    -0.0, -0.0
	},
	{
	    1.0,  -0.0
	}
    },
    {
	{
	    -0.0,  1.0
	},
	{
	    1.0, 1.0
	},
	{
	    1.0, -0.0
	},
	{
	    -0.0,  -0.0
	}
    },
    {
	{
	    1.0,  1.0
	},
	{
	    -0.0, 1.0
	},
	{
	    -0.0, -0.0
	},
	{
	    1.0,  -0.0
	}
    },
    {
	{
	    1.0,  1.0
	},
	{
	    -0.0, 1.0
	},
	{
	    -0.0, -0.0
	},
	{
	    1.0,  -0.0
	}
    },
    {
	{
	    1.0,  1.0
	},
	{
	    -0.0, 1.0
	},
	{
	    -0.0, -0.0
	},
	{
	    1.0,  -0.0
	}
    },
};
#endif

static void Animate(void);

void SolidSphere (GLdouble radius)
{
    GLUquadricObj *quadObj;
    static GLuint displayList = 0;

    if (displayList == 0) {
        displayList = glGenLists(1);
        glNewList(displayList, GL_COMPILE_AND_EXECUTE);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_FILL);
            gluQuadricNormals (quadObj, GLU_SMOOTH);
            gluQuadricTexture (quadObj, GL_TRUE);
            gluSphere (quadObj, radius, 16, 16);
        glEndList();
    }
    else {
        glCallList(displayList);
    }
}

COLORREF HueToRgb(double hue)
{
    int hex;
    double frac;
    BYTE v1, v2, v3;
    
    hue /= 60.0;
    hex = (int)hue;
    frac = hue-hex;
    v1 = 0;
    v2 = (BYTE)((1-frac)*255);
    v3 = (BYTE)(frac*255);
    switch(hex)
    {
    case 0:
        return RGB(255, v3, v1);
    case 1:
        return RGB(v2, 255, v1);
    case 2:
        return RGB(v1, 255, v3);
    case 3:
        return RGB(v1, v2, 255);
    case 4:
        return RGB(v3, v1, 255);
    default:
        return RGB(255, v1, v2);
    }
}

static void BuildCube(void)
{
    GLint i;

    glNewList(cube, GL_COMPILE);
    for (i = 0; i < 6; i++) {
	glBegin(GL_POLYGON);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][0]); glVertex3fv(c[i][0]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][1]); glVertex3fv(c[i][1]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][2]); glVertex3fv(c[i][2]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][3]); glVertex3fv(c[i][3]);
	glEnd();
    }
    glEndList();
}

static void BuildLists(void)
{

    cube = glGenLists(1);
    BuildCube();
}

BOOL WINAPI texCallback(LPDDSURFACEDESC pddsd, LPVOID pv)
{
    if (pddsd->ddpfPixelFormat.dwFlags == DDPF_RGB)
    {
        ddsdTex = *pddsd;
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

void CreateTex(void)
{
    LPDIRECTDRAW pdd;
    HDC hdc;

    if (!wglEnumTextureFormats(texCallback, NULL))
    {
	printf("wglEnumTextureFormats failed, %d\n", GetLastError());
	tkQuit();
    }

    if (DirectDrawCreate(NULL, &pdd, NULL) != DD_OK)
    {
        tkQuit();
    }
    if (pdd->lpVtbl->SetCooperativeLevel(pdd, NULL, DDSCL_NORMAL) != DD_OK)
    {
        tkQuit();
    }

    ddsdTex.dwFlags |= DDSD_WIDTH | DDSD_HEIGHT;
    ddsdTex.dwWidth = TWIDTH;
    ddsdTex.dwHeight = THEIGHT;
    ddsdTex.ddsCaps.dwCaps &= ~DDSCAPS_MIPMAP;
    
    if (pdd->lpVtbl->CreateSurface(pdd, &ddsdTex, &pddsTex, NULL) != DD_OK)
    {
        tkQuit();
    }

    if (pddsTex->lpVtbl->GetDC(pddsTex, &hdc) != DD_OK)
    {
        tkQuit();
    }

    SelectObject(hdc, GetStockObject(BLACK_BRUSH));
    SelectObject(hdc, GetStockObject(WHITE_PEN));
    Rectangle(hdc, 0, 0, TWIDTH, THEIGHT);

    pddsTex->lpVtbl->ReleaseDC(pddsTex, hdc);
}

static void Init(void)
{
    CreateTex();

    srand(time(NULL));
    trail[0][0].x = (rand() % TRAIL_WIDTH)+TRAIL_X;
    trail[0][0].y = (rand() % TRAIL_HEIGHT)+TRAIL_Y;
    trail[0][1].x = (rand() % TRAIL_WIDTH)+TRAIL_X;
    trail[0][1].y = (rand() % TRAIL_HEIGHT)+TRAIL_Y;
    vel[0].x = TRAIL_RAND_SPEED();
    vel[0].y = TRAIL_RAND_SPEED();
    vel[1].x = TRAIL_RAND_SPEED();
    vel[1].y = TRAIL_RAND_SPEED();
    
    wglBindDirectDrawTexture(pddsTex);
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
    glEnable(GL_TEXTURE_2D);

    glFrontFace(GL_CCW);
    glCullFace(GL_FRONT);
    glEnable(GL_CULL_FACE);

    BuildLists();

    glClearColor(0.0, 0.0, 0.0, 0.0);

    magFilter = nr;
    minFilter = nr;
    sWrapMode = repeat;
    tWrapMode = repeat;

    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(90.0, 1.0, 0.01, 1000);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();

      case TK_SPACE:
        if (animate)
        {
            tkIdleFunc(NULL);
        }
        else
        {
            tkIdleFunc(Animate);
        }
        animate = !animate;
        break;

      case TK_n:
        spin = !spin;
        break;
      case TK_p:
        showSphere = !showSphere;
        break;
        
      case TK_LEFT:
	yRotation -= 0.5;
	break;
      case TK_RIGHT:
	yRotation += 0.5;
	break;
      case TK_UP:
	xRotation -= 0.5;
	break;
      case TK_DOWN:
	xRotation += 0.5;
	break;
      case TK_f:
	displayFrameRate = !displayFrameRate;
	frameCount = 0;
	break;
      case TK_d:
	doDither = !doDither;
	(doDither) ? glEnable(GL_DITHER) : glDisable(GL_DITHER);
	break;
      case TK_T:
	zTranslate += 0.25;
	break;
      case TK_t:
	zTranslate -= 0.25;
	break;

      case TK_s:
	doSphere = !doSphere;
	if (doSphere) {
	    glTexGeniv(GL_S, GL_TEXTURE_GEN_MODE, sphereMap);
	    glTexGeniv(GL_T, GL_TEXTURE_GEN_MODE, sphereMap);
	    glEnable(GL_TEXTURE_GEN_S);
	    glEnable(GL_TEXTURE_GEN_T);
	} else {
	    glDisable(GL_TEXTURE_GEN_S);
	    glDisable(GL_TEXTURE_GEN_T);
	}
	break;

      case TK_0:
	magFilter = nr;
	break;
      case TK_1:
	magFilter = ln;
	break;
      case TK_2:
	minFilter = nr;
	break;
      case TK_3:
	minFilter = ln;
	break;
      case TK_4:
	minFilter = nr_mipmap_nr;
	break;
      case TK_5:
	minFilter = nr_mipmap_ln;
	break;
      case TK_6:
	minFilter = ln_mipmap_nr;
	break;
      case TK_7:
	minFilter = ln_mipmap_ln;
	break;

      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{
    glClear(GL_COLOR_BUFFER_BIT);

    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, tWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);

    glPushMatrix();

    glTranslatef(0.0, 0.0, zTranslate);
    glRotatef(xRotation, 1, 0, 0);
    glRotatef(yRotation, 0, 1, 0);
    if (showSphere)
    {
        SolidSphere(1);
    }
    else
    {
        glCallList(cube);
    }

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void UpdateTex(void)
{
    HDC hdc;
    int i;
    int idx;
    HPEN hpen;
    
    if (pddsTex->lpVtbl->GetDC(pddsTex, &hdc) != DD_OK)
    {
        tkQuit();
    }

    idx = NEXT_TRAIL_IDX(trail_idx);
    
    // Erase oldest trail line
    SelectObject(hdc, GetStockObject(BLACK_PEN));
    MoveToEx(hdc, trail[idx][0].x, trail[idx][0].y, NULL);
    LineTo(hdc, trail[idx][1].x, trail[idx][1].y);

    // Update points
    for (i = 0; i < 2; i++)
    {
        trail[idx][i].x = trail[trail_idx][i].x+vel[i].x;
        if (trail[idx][i].x < TRAIL_X)
        {
            trail[idx][i].x = TRAIL_X;
            vel[i].x = TRAIL_RAND_SPEED();
        }
        else if (trail[idx][i].x >= TRAIL_X+TRAIL_WIDTH)
        {
            trail[idx][i].x = TRAIL_X+TRAIL_WIDTH-1;
            vel[i].x = -TRAIL_RAND_SPEED();
        }
        
        trail[idx][i].y = trail[trail_idx][i].y+vel[i].y;
        if (trail[idx][i].y < TRAIL_Y)
        {
            trail[idx][i].y = TRAIL_Y;
            vel[i].y = TRAIL_RAND_SPEED();
        }
        else if (trail[idx][i].y >= TRAIL_Y+TRAIL_HEIGHT)
        {
            trail[idx][i].y = TRAIL_Y+TRAIL_HEIGHT-1;
            vel[i].y = -TRAIL_RAND_SPEED();
        }
    }

    // Draw newest line
    hpen = CreatePen(PS_SOLID, 0, HueToRgb(trail_hue));
    SelectObject(hdc, hpen);
    MoveToEx(hdc, trail[idx][0].x, trail[idx][0].y, NULL);
    LineTo(hdc, trail[idx][1].x, trail[idx][1].y);
    SelectObject(hdc, GetStockObject(WHITE_PEN));
    DeleteObject(hpen);

    trail_idx = idx;
    trail_hue = NEXT_TRAIL_HUE(trail_hue);
    
    pddsTex->lpVtbl->ReleaseDC(pddsTex, hdc);
}

static void Animate(void)
{
    static struct _timeb thisTime, baseTime;
    double elapsed, frameRate, deltat;

    if (curFrame++ >= 10) {
    	if( !frameCount ) {
 	    _ftime( &baseTime );
	}
	else {
	    if( displayFrameRate ) {
 	        _ftime( &thisTime );
	        elapsed = thisTime.time + thisTime.millitm/1000.0 -
		          (baseTime.time + baseTime.millitm/1000.0);
	        if( elapsed == 0.0 )
	            printf( "Frame rate = unknown\n" );
	        else {
	            frameRate = frameCount / elapsed;
	            printf( "Frame rate = %5.2f fps\n", frameRate );
	        }
	    }
	}
	frameCount += 10;

	curFrame = 0;
    }

    UpdateTex();

    Draw();

    if (spin)
    {
        xRotation += 10.0;
        yRotation += 10.0;
    }
}

void __cdecl main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, WWIDTH, WHEIGHT);

    type = TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Texture Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    if (animate)
    {
        tkIdleFunc(Animate);
    }
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tbitmap1.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


#define OPENGL_WIDTH 24
#define OPENGL_HEIGHT 13


GLenum rgb, doubleBuffer, directRender, windType;

float boxA[3] = {
    0, 0, 0
};
float boxB[3] = {
    -100, 0, 0
};
float boxC[3] = {
    100, 0, 0
};
float boxD[3] = {
    0, 95, 0
};
float boxE[3] = {
    0, -105, 0
};
GLubyte OpenGL_bits1[] = {
   0x00, 0x03, 0x00,
   0x7f, 0xfb, 0xff,
   0x7f, 0xfb, 0xff,
   0x00, 0x03, 0x00,
   0x3e, 0x8f, 0xb7,
   0x63, 0xdb, 0xb0,
   0x63, 0xdb, 0xb7,
   0x63, 0xdb, 0xb6,
   0x63, 0x8f, 0xf3,
   0x63, 0x00, 0x00,
   0x63, 0x00, 0x00,
   0x63, 0x00, 0x00,
   0x3e, 0x00, 0x00,
};
GLubyte OpenGL_bits2[] = {
   0x00, 0x00, 0x00,
   0xff, 0xff, 0x01,
   0xff, 0xff, 0x01, 
   0x00, 0x00, 0x00,
   0xf9, 0xfc, 0x01, 
   0x8d, 0x0d, 0x00,
   0x8d, 0x0d, 0x00, 
   0x8d, 0x0d, 0x00,
   0xcc, 0x0d, 0x00, 
   0x0c, 0x4c, 0x0a,
   0x0c, 0x4c, 0x0e, 
   0x8c, 0xed, 0x0e,
   0xf8, 0x0c, 0x00, 
};
GLubyte logo_bits[] = {
   0x00, 0x66, 0x66, 
   0xff, 0x66, 0x66, 
   0x00, 0x00, 0x00, 
   0xff, 0x3c, 0x3c, 
   0x00, 0x42, 0x40, 
   0xff, 0x42, 0x40, 
   0x00, 0x41, 0x40, 
   0xff, 0x21, 0x20, 
   0x00, 0x2f, 0x20, 
   0xff, 0x20, 0x20, 
   0x00, 0x10, 0x90, 
   0xff, 0x10, 0x90, 
   0x00, 0x0f, 0x10, 
   0xff, 0x00, 0x00, 
   0x00, 0x66, 0x66, 
   0xff, 0x66, 0x66, 
};


static void Init(void)
{

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0.0);
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-175, 175, -175, 175);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
        tkQuit();
    }
    return GL_FALSE;
}

static void Draw(void)
{
    float mapI[2], mapIA[2], mapIR[2];

    glClear(GL_COLOR_BUFFER_BIT);

    mapI[0] = 0.0;
    mapI[1] = 1.0;
    mapIR[0] = 0.0;
    mapIR[1] = 0.0;
    mapIA[0] = 1.0;
    mapIA[1] = 1.0;
    
    glPixelMapfv(GL_PIXEL_MAP_I_TO_R, 2, mapIR);
    glPixelMapfv(GL_PIXEL_MAP_I_TO_G, 2, mapI);
    glPixelMapfv(GL_PIXEL_MAP_I_TO_B, 2, mapI);
    glPixelMapfv(GL_PIXEL_MAP_I_TO_A, 2, mapIA);
    glPixelTransferi(GL_MAP_COLOR, GL_TRUE);
    
    TK_SETCOLOR(windType, TK_WHITE);
    glRasterPos3fv(boxA);
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 24);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 8);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, 2);
    glPixelStorei(GL_UNPACK_LSB_FIRST, GL_FALSE);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glBitmap(16, 12, 8.0, 0.0, 0.0, 0.0, logo_bits);
	     
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
    glPixelStorei(GL_UNPACK_LSB_FIRST, GL_TRUE);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    TK_SETCOLOR(windType, TK_WHITE);
    glRasterPos3fv(boxB);
    glBitmap(OPENGL_WIDTH, OPENGL_HEIGHT, OPENGL_WIDTH, 0.0, OPENGL_WIDTH, 0.0,
	     OpenGL_bits1);
    glBitmap(OPENGL_WIDTH, OPENGL_HEIGHT, OPENGL_WIDTH, 0.0, OPENGL_WIDTH, 0.0,
	     OpenGL_bits2);

    TK_SETCOLOR(windType, TK_YELLOW);
    glRasterPos3fv(boxC);
    glBitmap(OPENGL_WIDTH, OPENGL_HEIGHT, OPENGL_WIDTH, 0.0, OPENGL_WIDTH, 0.0,
	     OpenGL_bits1);
    glBitmap(OPENGL_WIDTH, OPENGL_HEIGHT, OPENGL_WIDTH, 0.0, OPENGL_WIDTH, 0.0,
	     OpenGL_bits2);

    TK_SETCOLOR(windType, TK_CYAN);
    glRasterPos3fv(boxD);
    glBitmap(OPENGL_WIDTH, OPENGL_HEIGHT, OPENGL_WIDTH, 0.0, OPENGL_WIDTH, 0.0,
	     OpenGL_bits1);
    glBitmap(OPENGL_WIDTH, OPENGL_HEIGHT, OPENGL_WIDTH, 0.0, OPENGL_WIDTH, 0.0,
	     OpenGL_bits2);

    TK_SETCOLOR(windType, TK_RED);
    glRasterPos3fv(boxE);
    glBitmap(OPENGL_WIDTH, OPENGL_HEIGHT, OPENGL_WIDTH, 0.0, OPENGL_WIDTH, 0.0,
	     OpenGL_bits1);
    glBitmap(OPENGL_WIDTH, OPENGL_HEIGHT, OPENGL_WIDTH, 0.0, OPENGL_WIDTH, 0.0,
	     OpenGL_bits2);

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    windType = (rgb) ? TK_RGB : TK_INDEX;
    windType |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    windType |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(windType);

    if (tkInitWindow("Bitmap Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tcopy.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
//#include <unistd.h>
#include "tk.h"


GLenum doubleBuffer, directRender;
GLint windW, windH;

char *fileName = 0;
TK_RGBImageRec *image;
float point[3];
float zoom;
GLint x, y;


static void Init(void)
{

    glClearColor(0.0, 0.0, 0.0, 0.0);

    x = 0;
    y = windH;
    zoom = 1.8;
}

static void Reshape(int width, int height)
{

    windW = (GLint)width;
    windH = (GLint)height;

    glViewport(0, 0, windW, windH);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, windW, 0, windH);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
        tkQuit();
      case TK_Z:
	zoom += 0.2;
	break;
      case TK_z:
	zoom -= 0.2;
	if (zoom < 0.2) {
	    zoom = 0.2;
	}
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static GLenum Mouse(int mouseX, int mouseY, GLenum button)
{

    x = (GLint)mouseX;
    y = (GLint)mouseY;
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT);

    point[0] = (windW / 2) - (image->sizeX / 2);
    point[1] = (windH / 2) - (image->sizeY / 2);
    point[2] = 0;
    glRasterPos3fv(point);

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glPixelZoom(1.0, 1.0);
    glDrawPixels(image->sizeX, image->sizeY, GL_RGB, GL_UNSIGNED_BYTE,
		 image->data);

    point[0] = (float)x;
    point[1] = windH - (float)y;
    point[2] = 0.0;
    glRasterPos3fv(point);

    glPixelZoom(zoom, zoom);
    glCopyPixels((windW/2)-(image->sizeX/2),
		 (windH/2)-(image->sizeY/2),
		 image->sizeX, image->sizeY, GL_COLOR);

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-f") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-f (No file name).\n");
		return GL_FALSE;
	    } else {
		fileName = argv[++i];
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    if (fileName == 0) {
	printf("No image file.\n");
	tkQuit();
    }

    image = tkRGBImageLoad(fileName);

    windW = 300;
    windH = 300;
    tkInitPosition(0, 0, windW, windH);

    type = TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Copy Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkMouseDownFunc(Mouse);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tbitmap2.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


#define EXP_WIDTH 80
#define EXP_HEIGHT 80


GLenum rgb, doubleBuffer, directRender, windType;

GLenum useLists, abuse;
GLubyte exp_bits[7][800] = {
    {
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x40, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x80, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xf2, 0x1f, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xbe, 0x7c, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xf6, 0x4f, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xde, 0x7d, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xea, 0xef, 0x01, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xff, 0x55, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xdd, 0xfd, 0x03, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xbf, 0xae, 0x22, 0x36, 0x00, 0x00,
       0x00, 0x00, 0x00, 0xdb, 0xf7, 0x3f, 0x1e, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x50, 0xbf, 0xbf, 0x85, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xff, 0xe5, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xee, 0x7e, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x74, 0x4b, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xe8, 0x3e, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xf8, 0x49, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x54, 0x07, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xc0, 0x70, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x78, 0x91, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x60, 0xf1, 0x53, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x40, 0x97, 0x5c, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0xa0, 0x0c, 0x8c, 0x1b, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0xc4, 0x01, 0x00, 0xc8, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x08, 0x02, 0x00, 0x88, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x60, 0x00, 0x02, 0x40, 0x02, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x70, 0x00, 0x0c, 0x40, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x70, 0xe0, 0x0d, 0x00, 0x04, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x72, 0xc8, 0x07, 0x40, 0x08, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x02, 0x78, 0x2f, 0x40, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x40, 0x02, 0xb0, 0x0a, 0x20, 0x77, 0x00, 0x00,
       0x00, 0x00, 0x40, 0x13, 0x10, 0x33, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0xc0, 0x02, 0x78, 0xbb, 0x81, 0x09, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x02, 0xdc, 0xe7, 0x00, 0x09, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xac, 0x78, 0x00, 0x31, 0x00, 0x00,
       0x00, 0x00, 0x40, 0x03, 0x74, 0x4b, 0x00, 0x03, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x02, 0xe8, 0x3e, 0x00, 0x01, 0x10, 0x00,
       0x00, 0x00, 0x80, 0x00, 0xf8, 0x49, 0x80, 0x09, 0x1c, 0x00,
       0x00, 0x00, 0x00, 0x0c, 0x40, 0x07, 0x00, 0x05, 0x1c, 0x00,
       0x00, 0x00, 0x80, 0x09, 0x04, 0x80, 0x00, 0x02, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x1d, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
       0x00, 0x00, 0x80, 0xe3, 0x0b, 0x00, 0x22, 0x01, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x8f, 0x10, 0x00, 0xa0, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x4f, 0x20, 0x78, 0x60, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x80, 0x80, 0x79, 0x18, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x78, 0x7c, 0x05, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x03, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x01, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x02, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x18, 0xc0, 0x04, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x84, 0x80, 0x04, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x80, 0x60, 0x06, 0x0c, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x80, 0x07, 0x64, 0x3a, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x20, 0x00, 0x08, 0x72, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x3b, 0x00, 0x00, 0xc0, 0x33, 0x00, 0x00,
       0x00, 0x00, 0xa0, 0x1b, 0x00, 0x00, 0x80, 0x42, 0x00, 0x00,
       0x00, 0x00, 0xd0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
       0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
       0x00, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
       0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
       0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
       0x00, 0x30, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
       0x00, 0x80, 0x03, 0x03, 0x80, 0x00, 0x00, 0x00, 0x08, 0x00,
       0x00, 0xe2, 0x82, 0x03, 0x00, 0x20, 0x00, 0x00, 0x40, 0x00,
       0x00, 0x0e, 0x80, 0x03, 0x00, 0x4c, 0x00, 0x00, 0x10, 0x00,
       0x00, 0x0e, 0x80, 0x03, 0xec, 0x10, 0x00, 0x00, 0x60, 0x00,
       0x00, 0x12, 0x00, 0x00, 0x05, 0x93, 0x01, 0x00, 0x20, 0x00,
       0x00, 0x12, 0x00, 0x00, 0x00, 0x5c, 0x0c, 0x00, 0x60, 0x00,
       0x00, 0x30, 0x00, 0xc0, 0x05, 0x81, 0x10, 0x00, 0x00, 0x00,
       0x00, 0x2c, 0x00, 0x00, 0xcc, 0x06, 0x00, 0x00, 0x20, 0x00,
       0x00, 0x30, 0x00, 0x00, 0x28, 0x20, 0x02, 0x00, 0x00, 0x00,
       0x00, 0x30, 0x80, 0x80, 0x22, 0x00, 0x02, 0x00, 0x00, 0x02,
       0x00, 0x20, 0x00, 0x80, 0x02, 0x20, 0x08, 0x00, 0x20, 0x02,
       0x00, 0x38, 0x00, 0x00, 0x00, 0x11, 0x28, 0x00, 0x20, 0x06,
       0x00, 0x20, 0x00, 0x80, 0x0e, 0xc0, 0x21, 0x00, 0x5c, 0x00,
       0x00, 0x24, 0x00, 0x90, 0x40, 0x58, 0x04, 0x00, 0x20, 0x01,
       0x00, 0x24, 0x00, 0x10, 0x22, 0x02, 0x05, 0x00, 0x20, 0x02,
       0x00, 0x00, 0x00, 0x00, 0x28, 0xb6, 0x00, 0x00, 0x20, 0x01,
       0x00, 0x70, 0x00, 0x00, 0x18, 0xc1, 0x00, 0x00, 0xc0, 0x01,
       0x00, 0xc0, 0x00, 0x00, 0x40, 0x83, 0x04, 0x00, 0xc0, 0x01,
       0x00, 0x00, 0x01, 0x80, 0xfc, 0x41, 0x02, 0x00, 0x10, 0x00,
       0x00, 0x00, 0x01, 0x00, 0x03, 0x30, 0x00, 0x00, 0x10, 0x00,
       0x00, 0x10, 0x02, 0x00, 0x40, 0x1d, 0x00, 0x00, 0x20, 0x00,
       0x00, 0x30, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x20, 0x00,
       0x00, 0x00, 0x04, 0x00, 0x60, 0x00, 0x00, 0x00, 0x20, 0x00,
       0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
       0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01,
       0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00,
       0x00, 0x00, 0x38, 0x00, 0x81, 0x0f, 0x00, 0x00, 0x2a, 0x00,
       0x00, 0x00, 0xf8, 0x02, 0x80, 0x0f, 0x00, 0x00, 0x10, 0x00,
       0x00, 0x00, 0xf8, 0x02, 0x80, 0x0f, 0x00, 0x00, 0x08, 0x00,
       0x00, 0x00, 0x00, 0x06, 0xc0, 0x01, 0x00, 0x00, 0x07, 0x00,
       0x00, 0x00, 0x00, 0x14, 0xe0, 0x00, 0x00, 0x80, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x08, 0x70, 0x00, 0x00, 0x85, 0x00, 0x00,
       0x00, 0x00, 0xc0, 0x00, 0x30, 0x00, 0x20, 0x3c, 0x00, 0x00,
       0x00, 0x00, 0x00, 0xe0, 0xe0, 0x80, 0x00, 0x0b, 0x00, 0x00,
       0x00, 0x00, 0x00, 0xe0, 0x79, 0x83, 0x80, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x80, 0x19, 0x22, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0xf4, 0x28, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
       0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x04, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x80, 0x01, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
       0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
       0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00,
       0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
       0x00, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0xe0, 0x03, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
       0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00,
       0x03, 0x00, 0x00, 0x00, 0x02, 0x90, 0x00, 0x00, 0x00, 0x40,
       0x02, 0x02, 0x00, 0x80, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00,
       0x40, 0x00, 0x00, 0x40, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x01, 0x00, 0x20, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x30, 0x28, 0x90, 0x05, 0x00, 0x00, 0x40,
       0x00, 0x00, 0x00, 0x48, 0x05, 0x00, 0x21, 0x00, 0x00, 0x0c,
       0x00, 0x00, 0x00, 0x84, 0x00, 0x54, 0x05, 0x00, 0x00, 0x00,
       0x04, 0x00, 0x00, 0x40, 0x05, 0x80, 0x41, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x0e, 0x02, 0x01, 0x00, 0x00, 0x20,
       0x00, 0x00, 0x00, 0x08, 0x20, 0x20, 0x01, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x84, 0x82, 0x00, 0x03, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x48, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x40,
       0x04, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x21, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x90, 0x40, 0x40, 0x04, 0x00, 0x00, 0x80,
       0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x41, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x08, 0x40, 0xa0, 0x00, 0x00, 0x00, 0x50,
       0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x00, 0x40,
       0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0x04, 0x00, 0x00, 0x30,
       0x00, 0x00, 0x00, 0x80, 0x84, 0x00, 0x02, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0xc2, 0x20, 0x20, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x10, 0xc0, 0x05, 0x20, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x02, 0x00, 0x00, 0x10,
       0x08, 0x00, 0x00, 0x80, 0x00, 0x10, 0x10, 0x00, 0x00, 0x08,
       0x10, 0x02, 0x00, 0x00, 0x21, 0x04, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
       0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
       0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x18, 0x08, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x08, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x3a, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x40, 0x04,
       0x00, 0x60, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x04,
       0x00, 0xb8, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
       0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x40, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
       0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x10, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00,
       0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x08, 0x00, 0x00,
       0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x1f, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x40, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00,
       0x00, 0x00, 0x60, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x08, 0x01, 0x00, 0x01, 0x10, 0x04, 0x00, 0x00,
       0x00, 0x40, 0x00, 0x02, 0x02, 0x90, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x03, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x1c, 0x20, 0x05, 0x00, 0x04, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x14, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x20, 0x40, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0xc4, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x40, 0x00, 0x02, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x10, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00,
       0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00,
       0x00, 0x00, 0x42, 0x00, 0x00, 0x04, 0x20, 0x01, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x20, 0x05, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x02, 0x00, 0x81, 0x07, 0x01, 0x03, 0x00, 0x00,
       0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x20, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x08, 0x02, 0x80, 0x20, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x80, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x80, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x80, 0x00, 0x00, 0x40, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
       0xc0, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x40, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x40, 0x0d, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
       0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
       0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
       0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x01, 0x10, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0x00,
       0x02, 0x02, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0xc0, 0x00, 0x40, 0x00, 0x02, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00,
       0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01,
       0x00, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
       0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
       0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x80, 0x06, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00,
       0x08, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00
    },
    {
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x04, 0x00, 0x00, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
       0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
       0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
       0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x01, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }
};
GLint exp_lists[7];


static void Init(void)
{
    GLint i;

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0.0);

    glPixelStorei(GL_UNPACK_LSB_FIRST, GL_TRUE);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    for (i = 0; i < 7; i++) {
	exp_lists[i] = glGenLists(1);
	glNewList(exp_lists[i], GL_COMPILE);
	    glBitmap(80, 80, 40.0, 40.0, 0.0, 0.0, exp_bits[i]);
	glEndList();
    }

    abuse = GL_FALSE;
    useLists = GL_TRUE;
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-175, 175, -175, 175);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
        tkQuit();
      case TK_1:
	useLists = !useLists;
        break;
      case TK_2:
	abuse = !abuse;
        break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{
    float mapI[2], mapIA[2], mapIR[2];
    GLint i, j;

    glClear(GL_COLOR_BUFFER_BIT);

    for (i = 0; i < 7; i++) {
	for (j = 0; j < 40; j++) {
	    switch (j % 7) {
	      case 0:
		TK_SETCOLOR(windType, TK_YELLOW);
		break;
	      case 1:
		TK_SETCOLOR(windType, TK_GREEN);
		break;
	      case 2:
		TK_SETCOLOR(windType, TK_BLUE);
		break;
	      case 3:
		TK_SETCOLOR(windType, TK_MAGENTA);
		break;
	      case 4:
		TK_SETCOLOR(windType, TK_CYAN);
		break;
	      case 5:
		TK_SETCOLOR(windType, TK_WHITE);
		break;
	      case 6:
		TK_SETCOLOR(windType, TK_RED);
		break;
	    }
	    glRasterPos3i((j*3)%5, (j*3)%8, 0);

	    if (useLists) {
	    	glCallList(exp_lists[i]); 
	    } else {
		glBitmap(80, 80, 40.0, 40.0, 0.0, 0.0, exp_bits[i]);
	    }
	    if (!abuse) {
		break;
	    }
	}

	if (i == 6) {
	    break;
	}

	for (j = 0; j < 40; j++) {
	    TK_SETCOLOR(windType, TK_BLACK);
	    glRasterPos3i((j*3)%5, (j*3)%8, 0);
	    if (useLists) {
		glCallList(exp_lists[i]); 
	    } else {
		glBitmap(80, 80, 40.0, 40.0, 0.0, 0.0, exp_bits[i]);
	    }
	    if (!abuse) {
		break;
	    }
	}
    }

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    windType = (rgb) ? TK_RGB : TK_INDEX;
    windType |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    windType |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(windType);

    if (tkInitWindow("Bitmap Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tdepth.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


#if 0
#define CI_OFFSET_1 16
#define CI_OFFSET_2 32
#else
#define CI_OFFSET_1 32
#define CI_OFFSET_2 48
#endif


GLenum rgb, doubleBuffer, directRender;

GLenum antiAlias, stipple;
GLubyte stippleBits[32*4] = {
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
};


static void Init(void)
{
    GLint i;

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0.0);

    if (!rgb) {
	for (i = 0; i < 16; i++) {
	    tkSetOneColor(i+CI_OFFSET_1, 0.0, 0.0, i/15.0);
	    tkSetOneColor(i+CI_OFFSET_2, 0.0, i/15.0, 0.0);
	}
    }

    antiAlias = GL_FALSE;
    stipple = GL_FALSE;
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.0, 1.0, -1.0, 1.0, -0.5, 1000.0);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_1:
	antiAlias = !antiAlias;
	break;
      case TK_2:
	stipple = !stipple;
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{
    GLint ci1, ci2;

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    if (antiAlias) {
	ci1 = CI_OFFSET_1;
	ci2 = CI_OFFSET_2;
	glBlendFunc(GL_SRC_ALPHA, GL_ONE);
	glEnable(GL_BLEND);
	glEnable(GL_POLYGON_SMOOTH);
	glDisable(GL_DEPTH_TEST);
    } else {
	ci1 = TK_BLUE;
	ci2 = TK_GREEN;
	glDisable(GL_BLEND);
	glDisable(GL_POLYGON_SMOOTH);
	glEnable(GL_DEPTH_TEST);
    }

    if (stipple) {
	glPolygonStipple(stippleBits);
	glEnable(GL_POLYGON_STIPPLE);
    } else {
	glDisable(GL_POLYGON_STIPPLE);
    }

    glBegin(GL_TRIANGLES);
	(rgb) ? glColor3fv(tkRGBMap[TK_BLUE]) : glIndexi(ci1);
	glVertex3f( 0.9, -0.9, -30.0);
	glVertex3f( 0.9,  0.9, -30.0);
	glVertex3f(-0.9,  0.0, -30.0);
	(rgb) ? glColor3fv(tkRGBMap[TK_GREEN]) : glIndexi(ci2);
	glVertex3f(-0.9, -0.9, -40.0);
	glVertex3f(-0.9,  0.9, -40.0);
	glVertex3f( 0.9,  0.0, -25.0);
    glEnd();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    type = TK_DEPTH16;
    type |= (rgb) ? TK_RGB : TK_INDEX;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Depth Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tdibtex.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
//#include <unistd.h>
#include <math.h>
#include <stdlib.h>
#include "tk.h"


GLenum doubleBuffer, directRender;

char *texFileName = 0;
TK_RGBImageRec *image;

float *minFilter, *magFilter, *sWrapMode, *tWrapMode;
float decal[] = {GL_DECAL};
float modulate[] = {GL_MODULATE};
float repeat[] = {GL_REPEAT};
float clamp[] = {GL_CLAMP};
float nr[] = {GL_NEAREST};
float ln[] = {GL_LINEAR};
float nr_mipmap_nr[] = {GL_NEAREST_MIPMAP_NEAREST};
float nr_mipmap_ln[] = {GL_NEAREST_MIPMAP_LINEAR};
float ln_mipmap_nr[] = {GL_LINEAR_MIPMAP_NEAREST};
float ln_mipmap_ln[] = {GL_LINEAR_MIPMAP_LINEAR};
GLint sphereMap[] = {GL_SPHERE_MAP};

GLenum doSphere = GL_FALSE;
float xRotation = 0.0, yRotation = 0.0, zTranslate = -3.125;

GLint cube;
float c[6][4][3] = {
    {
	{
	    1.0, 1.0, -1.0
	},
	{
	    -1.0, 1.0, -1.0
	},
	{
	    -1.0, -1.0, -1.0
	},
	{
	    1.0, -1.0, -1.0
	}
    },
    {
	{
	    1.0, 1.0, 1.0
	},
	{
	    1.0, 1.0, -1.0
	},
	{
	    1.0, -1.0, -1.0
	},
	{
	    1.0, -1.0, 1.0
	}
    },
    {
	{
	    -1.0, 1.0, 1.0
	},
	{
	    1.0, 1.0, 1.0
	},
	{
	    1.0, -1.0, 1.0
	},
	{
	    -1.0, -1.0, 1.0
	}
    },
    {
	{
	    -1.0, 1.0, -1.0
	},
	{
	    -1.0, 1.0, 1.0
	},
	{
	    -1.0, -1.0, 1.0
	},
	{
	    -1.0, -1.0, -1.0
	}
    },
    {
	{
	    -1.0, 1.0, 1.0
	},
	{
	    -1.0, 1.0, -1.0
	},
	{
	    1.0, 1.0, -1.0
	},
	{
	    1.0, 1.0, 1.0
	}
    },
    {
	{
	    -1.0, -1.0, -1.0
	},
	{
	    -1.0, -1.0, 1.0
	},
	{
	    1.0, -1.0, 1.0
	},
	{
	    1.0, -1.0, -1.0
	}
    }
};
static float n[6][3] = {
    {
	0.0, 0.0, -1.0
    },
    {
	1.0, 0.0, 0.0
    },
    {
	0.0, 0.0, 1.0
    },
    {
	-1.0, 0.0, 0.0
    },
    {
	0.0, 1.0, 0.0
    },
    {
	0.0, -1.0, 0.0
    }
};
static float t[6][4][2] = {
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    -0.1,  1.1
	},
	{
	    1.1, 1.1
	},
	{
	    1.1, -0.1
	},
	{
	    -0.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
};


static void BuildCube(void)
{
    GLint i;

    glNewList(cube, GL_COMPILE);
    for (i = 0; i < 6; i++) {
	glBegin(GL_POLYGON);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][0]); glVertex3fv(c[i][0]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][1]); glVertex3fv(c[i][1]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][2]); glVertex3fv(c[i][2]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][3]); glVertex3fv(c[i][3]);
	glEnd();
    }
    glEndList();
}

static void BuildLists(void)
{

    cube = glGenLists(1);
    BuildCube();
}

static void Init(void)
{

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image->sizeX, image->sizeY,
		      GL_RGB, GL_UNSIGNED_BYTE, image->data);
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
    glEnable(GL_TEXTURE_2D);

    glFrontFace(GL_CCW);
    glCullFace(GL_FRONT);
    glEnable(GL_CULL_FACE);

    BuildLists();

    glClearColor(0.0, 0.0, 0.0, 0.0);

    magFilter = nr;
    minFilter = nr;
    sWrapMode = repeat;
    tWrapMode = repeat;
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(145.0, 1.0, 0.01, 1000);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();

      case TK_LEFT:
	yRotation -= 0.5;
	break;
      case TK_RIGHT:
	yRotation += 0.5;
	break;
      case TK_UP:
	xRotation -= 0.5;
	break;
      case TK_DOWN:
	xRotation += 0.5;
	break;
      case TK_T:
	zTranslate += 0.25;
	break;
      case TK_t:
	zTranslate -= 0.25;
	break;

      case TK_s:
	doSphere = !doSphere;
	if (doSphere) {
	    glTexGeniv(GL_S, GL_TEXTURE_GEN_MODE, sphereMap);
	    glTexGeniv(GL_T, GL_TEXTURE_GEN_MODE, sphereMap);
	    glEnable(GL_TEXTURE_GEN_S);
	    glEnable(GL_TEXTURE_GEN_T);
	} else {
	    glDisable(GL_TEXTURE_GEN_S);
	    glDisable(GL_TEXTURE_GEN_T);
	}
	break;

      case TK_0:
	magFilter = nr;
	break;
      case TK_1:
	magFilter = ln;
	break;
      case TK_2:
	minFilter = nr;
	break;
      case TK_3:
	minFilter = ln;
	break;
      case TK_4:
	minFilter = nr_mipmap_nr;
	break;
      case TK_5:
	minFilter = nr_mipmap_ln;
	break;
      case TK_6:
	minFilter = ln_mipmap_nr;
	break;
      case TK_7:
	minFilter = ln_mipmap_ln;
	break;

      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT);

    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, tWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);

    glPushMatrix();

    glTranslatef(0.0, 0.0, zTranslate);
    glRotatef(xRotation, 1, 0, 0);
    glRotatef(yRotation, 0, 1, 0);
    glCallList(cube);

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-f") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-f (No file name).\n");
		return GL_FALSE;
	    } else {
		texFileName = argv[++i];
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    if (texFileName == 0) {
	printf("No image file.\n");
	tkQuit();
    }

    image = tkDIBImageLoad(texFileName);

    tkInitPosition(0, 0, 300, 300);

    type = TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Texture Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tfont.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


#define OPENGL_WIDTH 24
#define OPENGL_HEIGHT 13


char string[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz";
GLenum rgb, doubleBuffer, directRender, windType;
GLuint strokeBase, outlineBase, filledBase, bitmapBase;
float angleX = 0.0, angleY = 0.0, angleZ = 0.0;
float scaleX = 1.0, scaleY = 1.0, scaleZ = 1.0;
float shiftX = 0.0, shiftY = 0.0, shiftZ = 0.0;


static void Init(void)
{

    strokeBase = glGenLists(256);
    if (tkCreateStrokeFont(strokeBase) == GL_FALSE) {
	tkQuit();
    }
    outlineBase = glGenLists(256);
    if (tkCreateOutlineFont(outlineBase) == GL_FALSE) {
	tkQuit();
    }
    filledBase = glGenLists(256);
    if (tkCreateFilledFont(filledBase) == GL_FALSE) {
	tkQuit();
    }
    bitmapBase = glGenLists(256);
    if (tkCreateBitmapFont(bitmapBase) == GL_FALSE) {
	tkQuit();
    }

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0.0);
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-400.0, 400.0, -200.0, 200.0, -400.0, 400.0);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
        tkQuit();

      case TK_LEFT:
	shiftX -= 20.0;
	break;
      case TK_RIGHT:
	shiftX += 20.0;
	break;
      case TK_UP:
	shiftY += 20.0;
	break;
      case TK_DOWN:
	shiftY -= 20.0;
	break;
      case TK_n:
	shiftZ += 20.0;
	break;
      case TK_m:
	shiftZ -= 20.0;
	break;

      case TK_q:
	scaleX -= 0.1;
	if (scaleX < 0.1) {
	    scaleX = 0.1;
	}
	break;
      case TK_w:
	scaleX += 0.1;
	break;
      case TK_a:
	scaleY -= 0.1;
	if (scaleY < 0.1) {
	    scaleY = 0.1;
	}
	break;
      case TK_s:
	scaleY += 0.1;
	break;
      case TK_z:
	scaleZ -= 0.1;
	if (scaleZ < 0.1) {
	    scaleZ = 0.1;
	}
	break;
      case TK_x:
	scaleZ += 0.1;
	break;

      case TK_e:
	angleX -= 5.0;
	if (angleX < 0.0) {
	    angleX = 360.0 + angleX;
	}
	break;
      case TK_r:
	angleX += 5.0;
	if (angleX > 360.0) {
	    angleX = angleX - 360.0;
	}
	break;
      case TK_d:
	angleY -= 5.0;
	if (angleY < 0.0) {
	    angleY = 360.0 + angleY;
	}
	break;
      case TK_f:
	angleY += 5.0;
	if (angleY > 360.0) {
	    angleY = angleY - 360.0;
	}
	break;
      case TK_c:
	angleZ -= 5.0;
	if (angleZ < 0.0) {
	    angleZ = 360.0 + angleZ;
	}
	break;
      case TK_v:
	angleZ += 5.0;
	if (angleZ > 360.0) {
	    angleZ = angleZ - 360.0;
	}
	break;

      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT);

    TK_SETCOLOR(windType, TK_WHITE);

    glPushMatrix();

    glTranslatef(shiftX, shiftY, shiftZ);
    glRotatef(angleX, 1.0, 0.0, 0.0);
    glRotatef(angleY, 0.0, 1.0, 0.0);
    glRotatef(angleZ, 0.0, 0.0, 1.0);
    glScalef(scaleX, scaleY, scaleZ);

    glPushMatrix();
    glRasterPos2f(-390.5, 0.5);
    tkDrawStr(bitmapBase, string);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(-390.5, -30.5, 0.0);
    tkDrawStr(strokeBase, string);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(-390.5, -60.5, 0.0);
    tkDrawStr(outlineBase, string);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(-390.5, -90.5, 0.0);
    tkDrawStr(filledBase, string);
    glPopMatrix();

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 800, 400);

    windType = (rgb) ? TK_RGB : TK_INDEX;
    windType |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    windType |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(windType);

    if (tkInitWindow("Font Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tline.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


#define CI_OFFSET 16


GLenum rgb, doubleBuffer, directRender, windType;

GLenum mode1, mode2;
GLint size;
float pntA[3] = {
    -160.0, 0.0, 0.0
};
float pntB[3] = {
    -130.0, 0.0, 0.0
};
float pntC[3] = {
    -40.0, -50.0, 0.0
};
float pntD[3] = {
    30.0, 60.0, 0.0
};


static void Init(void)
{
    GLint i;

    glClearColor(0.0, 0.0, 0.0, 0.0);

    glLineStipple(1, 0xF0E0);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE);

    if (!rgb) {
	for (i = 0; i < 16; i++) {
	    tkSetOneColor(i+CI_OFFSET, i/15.0, i/15.0, 0.0);
	}
    }

    mode1 = GL_FALSE;
    mode2 = GL_FALSE;
    size = 1;
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-175, 175, -175, 175);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_1:
	mode1 = !mode1;
	break;
      case TK_2:
	mode2 = !mode2;
	break;
      case TK_W:
	size++;
	break;
      case TK_w:
	size--;
	if (size < 1) {
	    size = 1;
	}
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{
    GLint ci, i;

    glClear(GL_COLOR_BUFFER_BIT);

    glLineWidth(size);

    if (mode1) {
	glEnable(GL_LINE_STIPPLE);
    } else {
	glDisable(GL_LINE_STIPPLE);
    }
    
    if (mode2) {
	ci = CI_OFFSET;
	glEnable(GL_LINE_SMOOTH);
	glEnable(GL_BLEND);
    } else {
	ci = TK_YELLOW;
	glDisable(GL_LINE_SMOOTH);
	glDisable(GL_BLEND);
    }

    glPushMatrix();

    for (i = 0; i < 360; i += 5) {
	glRotatef(5.0, 0,0,1);

	(rgb) ? glColor3f(1.0, 1.0, 0.0) : glIndexi(ci);
	glBegin(GL_LINE_STRIP);
	    glVertex3fv(pntA);
	    glVertex3fv(pntB);
	glEnd();

	glPointSize(1);

	TK_SETCOLOR(windType, TK_GREEN);
	glBegin(GL_POINTS);
	    glVertex3fv(pntA);
	    glVertex3fv(pntB);
	glEnd();
    }

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    windType = TK_ALPHA;
    windType |= (rgb) ? TK_RGB : TK_INDEX;
    windType |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    windType |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(windType);

    if (tkInitWindow("Line Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\teval.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "tk.h"


#define VORDER 10
#define CORDER 10
#define TORDER 3

#define VMAJOR_ORDER 2
#define VMINOR_ORDER 3

#define CMAJOR_ORDER 2
#define CMINOR_ORDER 2

#define TMAJOR_ORDER 2
#define TMINOR_ORDER 2

#define VDIM 4
#define CDIM 4
#define TDIM 2

#define ONE_D 1
#define TWO_D 2

#define EVAL 3
#define MESH 4


GLenum doubleBuffer, directRender;

float rotX = 0.0, rotY = 0.0, translateZ = -1.0;

GLenum arrayType = ONE_D;
GLenum colorType = GL_FALSE;
GLenum textureType = GL_FALSE;
GLenum polygonFilled = GL_FALSE;
GLenum lighting = GL_FALSE;
GLenum mapPoint = GL_FALSE;
GLenum mapType = EVAL;

double point1[10*4] = {
    -0.5, 0.0, 0.0, 1.0,
    -0.4, 0.5, 0.0, 1.0,
    -0.3,-0.5, 0.0, 1.0,
    -0.2, 0.5, 0.0, 1.0,
    -0.1,-0.5, 0.0, 1.0,
    0.0, 0.5, 0.0, 1.0,
    0.1,-0.5, 0.0, 1.0,
    0.2, 0.5, 0.0, 1.0,
    0.3,-0.5, 0.0, 1.0,
    0.4, 0.0, 0.0, 1.0,
};
double cpoint1[10*4] = {
    0.0, 0.0, 1.0, 1.0,
    0.3, 0.0, 0.7, 1.0,
    0.6, 0.0, 0.3, 1.0,
    1.0, 0.0, 0.0, 1.0,
    1.0, 0.3, 0.0, 1.0,
    1.0, 0.6, 0.0, 1.0,
    1.0, 1.0, 0.0, 1.0,
    1.0, 1.0, 0.5, 1.0,
    1.0, 1.0, 1.0, 1.0,
};
double tpoint1[11*4] = {
    0.0, 0.0, 0.0, 1.0,
    0.0, 0.1, 0.0, 1.0,
    0.0, 0.2, 0.0, 1.0,
    0.0, 0.3, 0.0, 1.0,
    0.0, 0.4, 0.0, 1.0,
    0.0, 0.5, 0.0, 1.0,
    0.0, 0.6, 0.0, 1.0,
    0.0, 0.7, 0.0, 1.0,
    0.0, 0.8, 0.0, 1.0,
    0.0, 0.9, 0.0, 1.0,
};
double point2[2*3*4] = {
    -0.5, -0.5,  0.5, 1.0, 
     0.0,  1.0,  0.5, 1.0, 
     0.5, -0.5,  0.5, 1.0,
    -0.5,  0.5, -0.5, 1.0, 
     0.0, -1.0, -0.5, 1.0, 
     0.5,  0.5, -0.5, 1.0,
};
double cpoint2[2*2*4] = {
    0.0, 0.0, 0.0, 1.0,
    0.0, 0.0, 1.0, 1.0,
    0.0, 1.0, 0.0, 1.0,
    1.0, 1.0, 1.0, 1.0,
};
double tpoint2[2*2*2] = {
    0.0, 0.0, 0.0, 1.0,
    1.0, 0.0, 1.0, 1.0, 
};
float textureImage[4*2*4] =  {
    1.0, 1.0, 1.0, 1.0,
    1.0, 0.0, 0.0, 1.0,
    1.0, 0.0, 0.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 
    1.0, 1.0, 1.0, 1.0,
    1.0, 0.0, 0.0, 1.0,
    1.0, 0.0, 0.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 
};


static void Init(void)
{
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {1.0, 1.0, 1.0, 1.0};
    static float position[] = {0.0, 0.0, -150.0, 0.0};
    static float front_mat_shininess[] = {30.0};
    static float front_mat_specular[] = {0.7, 0.7, 0.7, 1.0};
    static float front_mat_diffuse[] = {1.0, 0.2, 1.0, 1.0};
    static float back_mat_shininess[] = {50.0};
    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0};
    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0};
    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0};
    static float lmodel_twoside[] = {GL_TRUE};
    static float decal[] = {GL_DECAL};
    static float modulate[] = {GL_MODULATE};
    static float repeat[] = {GL_REPEAT};
    static float clamp[] = {GL_CLAMP};
    static float nr[] = {GL_NEAREST};
    static float ln[] = {GL_LINEAR};

    glFrontFace(GL_CCW);

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);

    glMap1d(GL_MAP1_VERTEX_4, 0.0, 1.0, VDIM, VORDER, point1);
    glMap1d(GL_MAP1_COLOR_4, 0.0, 1.0, CDIM, CORDER, cpoint1);

    glMap2d(GL_MAP2_VERTEX_4, 0.0, 1.0, VMINOR_ORDER*VDIM, VMAJOR_ORDER, 0.0,
	    1.0, VDIM, VMINOR_ORDER, point2);
    glMap2d(GL_MAP2_COLOR_4, 0.0, 1.0, CMINOR_ORDER*CDIM, CMAJOR_ORDER, 0.0,
	    1.0, CDIM, CMINOR_ORDER, cpoint2);
    glMap2d(GL_MAP2_TEXTURE_COORD_2, 0.0, 1.0, TMINOR_ORDER*TDIM,
	    TMAJOR_ORDER, 0.0, 1.0, TDIM, TMINOR_ORDER, tpoint2);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    
    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);

    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nr);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nr);
    glTexImage2D(GL_TEXTURE_2D, 0, 4, 2, 4, 0, GL_RGBA, GL_FLOAT,
		 (GLvoid *)textureImage);
}

static void DrawPoints1(void)
{
    GLint i;

    glColor3f(0.0, 1.0, 0.0);
    glPointSize(2);
    glBegin(GL_POINTS);
	for (i = 0; i < VORDER; i++) {
	    glVertex4dv(&point1[i*4]);
	}
    glEnd();
}

static void DrawPoints2(void)
{
    GLint i, j;

    glColor3f(1.0, 0.0, 1.0);
    glPointSize(2);
    glBegin(GL_POINTS);
	for (i = 0; i < VMAJOR_ORDER; i++) {
	    for (j = 0; j < VMINOR_ORDER; j++) {
		glVertex4dv(&point2[i*4*VMINOR_ORDER+j*4]);
	    }
	}
    glEnd();
}

static void DrawMapEval1(float du)
{
    float u;

    glColor3f(1.0, 0.0, 0.0);
    glBegin(GL_LINE_STRIP);
	for (u = 0.0; u < 1.0; u += du) {
	    glEvalCoord1d(u);
	}
	glEvalCoord1d(1.0);
    glEnd();
}

static void DrawMapEval2(float du, float dv)
{
    float u, v, tmp;

    glColor3f(1.0, 0.0, 0.0);
    for (v = 0.0; v < 1.0; v += dv) {
	glBegin(GL_QUAD_STRIP);
	    for (u = 0.0; u <= 1.0; u += du) {
		glEvalCoord2d(u,v);
		tmp = (v + dv < 1.0) ? (v + dv) : 1.0;
		glEvalCoord2d(u, tmp);
	    }
	    glEvalCoord2d(1.0, v);
	    glEvalCoord2d(1.0, v+dv);
	glEnd();
    }
}

static void RenderEval(void)
{

    if (colorType) {
	glEnable(GL_MAP1_COLOR_4);
	glEnable(GL_MAP2_COLOR_4);
    } else {
	glDisable(GL_MAP1_COLOR_4);
	glDisable(GL_MAP2_COLOR_4);
    }

    if (textureType) {
	glEnable(GL_TEXTURE_2D);
	glEnable(GL_MAP2_TEXTURE_COORD_2);
    } else {
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_MAP2_TEXTURE_COORD_2);
    }

    if (polygonFilled) {
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    } else {
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    }

    glShadeModel(GL_SMOOTH);

    switch (mapType) {
      case EVAL:
	switch (arrayType) {
	  case ONE_D:
	    glDisable(GL_MAP2_VERTEX_4);
	    glEnable(GL_MAP1_VERTEX_4);
	    DrawPoints1();
	    DrawMapEval1(0.1/VORDER);
	    break;
	  case TWO_D:
	    glDisable(GL_MAP1_VERTEX_4);
	    glEnable(GL_MAP2_VERTEX_4);
	    DrawPoints2();
	    DrawMapEval2(0.1/VMAJOR_ORDER,0.1/VMINOR_ORDER);
	    break;
	}
	break;
      case MESH:
	switch (arrayType) {
	  case ONE_D:
	    DrawPoints1();
	    glDisable(GL_MAP2_VERTEX_4);
	    glEnable (GL_MAP1_VERTEX_4);
	    glColor3f(0.0, 0.0, 1.0);
	    glMapGrid1d(40, 0.0, 1.0);
	    if (mapPoint) {
		glPointSize(2);
		glEvalMesh1(GL_POINT, 0, 40);
	    } else {
		glEvalMesh1(GL_LINE, 0, 40);
	    }
	    break;
	  case TWO_D:
	    DrawPoints2();
	    glDisable(GL_MAP1_VERTEX_4);
	    glEnable(GL_MAP2_VERTEX_4);
	    glColor3f(0.0, 0.0, 1.0);
	    glMapGrid2d(20, 0.0, 1.0, 20, 0.0, 1.0);
	    if (mapPoint) {
		glPointSize(2);
		glEvalMesh2(GL_POINT, 0, 20, 0, 20);
	    } else if (polygonFilled) {
		glEvalMesh2(GL_FILL, 0, 20, 0, 20);
	    } else {
		glEvalMesh2(GL_LINE, 0, 20, 0, 20);
	    }
	    break;
	}
	break;
    }
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.0, 1.0, -1.0, 1.0, -0.5, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_LEFT:
	rotY -= 30;
	break;
      case TK_RIGHT:
	rotY += 30;
	break;
      case TK_UP:
	rotX -= 30;
	break;
      case TK_DOWN:
	rotX += 30;
	break;
      case TK_1:
	arrayType = ONE_D;
	break;
      case TK_2:
	arrayType = TWO_D;
	break;
      case TK_e:
	mapType = EVAL;
	break;
      case TK_m:
	mapType = MESH;
	break;
      case TK_f:
	polygonFilled = !polygonFilled;
	break;
      case TK_p:
	mapPoint = !mapPoint;
	break;
      case TK_c:
	colorType = !colorType;
	break;
      case TK_t:
	textureType = !textureType;
	break;
      case TK_l:
	lighting =! lighting;
	if (lighting) {
	    glEnable(GL_LIGHTING);
	    glEnable(GL_LIGHT0);
	    glEnable(GL_AUTO_NORMAL);
	} else {
	    glDisable(GL_LIGHTING);
	    glDisable(GL_LIGHT0);
	    glDisable(GL_AUTO_NORMAL);
	}
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    glPushMatrix();

    glTranslatef(0.0, 0.0 , translateZ);
    glRotatef(rotX, 1, 0, 0);
    glRotatef(rotY, 0, 1, 0);
    RenderEval();

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    type = TK_RGB | TK_DEPTH16;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Evaluator Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tlogo.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


#define PI 3.141592654

#define	BLACK 0
#define	GRAY 128
#define	WHITE 255
#define BL 0x00
#define WH 0xFF
#define RD 0xA40000FF
#define WT 0xFFFFFFFF

#define	CHECKIMAGEWIDTH 8
#define	CHECKIMAGEHEIGHT 8
#define	BRICKIMAGEWIDTH 16
#define	BRICKIMAGEHEIGHT 16


GLenum rgb, doubleBuffer, directRender;

float black[3] = {0.0, 0.0, 0.0};
float white[3] = {1.0, 1.0, 1.0};
float gray[3] = {0.5, 0.5, 0.5};
float blue[3] = {0.0, 0.0, 1.0};
GLint colorIndexes[3] = {0, 200, 255};

GLenum polyMode;
GLenum dithering;
GLenum shade;
GLenum doStipple;

double plane[4] = {1.0, 0.0, -1.0, 0.0};
float xRotation = 30.0, yRotation = 30.0;
float zTranslation = -15.0;

GLint singleCylinder;
GLint doubleCylinder;
GLint elbow, logo;

GLubyte checkImage[3*CHECKIMAGEWIDTH*CHECKIMAGEHEIGHT] = {
    BL, BL, BL, WH, WH, WH, BL, BL, BL, WH, WH, WH, BL, BL, BL, WH,
    WH, WH, BL, BL, BL, WH, WH, WH, WH, WH, WH, BL, BL, BL, WH, WH,
    WH, BL, BL, BL, WH, WH, WH, BL, BL, BL, WH, WH, WH, BL, BL, BL,
    BL, BL, BL, WH, WH, WH, BL, BL, BL, WH, WH, WH, BL, BL, BL, WH,
    WH, WH, BL, BL, BL, WH, WH, WH, WH, WH, WH, BL, BL, BL, WH, WH,
    WH, BL, BL, BL, WH, WH, WH, BL, BL, BL, WH, WH, WH, BL, BL, BL,
    BL, BL, BL, WH, WH, WH, BL, BL, BL, WH, WH, WH, BL, BL, BL, WH,
    WH, WH, BL, BL, BL, WH, WH, WH, WH, WH, WH, BL, BL, BL, WH, WH,
    WH, BL, BL, BL, WH, WH, WH, BL, BL, BL, WH, WH, WH, BL, BL, BL,
    BL, BL, BL, WH, WH, WH, BL, BL, BL, WH, WH, WH, BL, BL, BL, WH,
    WH, WH, BL, BL, BL, WH, WH, WH, WH, WH, WH, BL, BL, BL, WH, WH,
    WH, BL, BL, BL, WH, WH, WH, BL, BL, BL, WH, WH, WH, BL, BL, BL, 
};
GLuint brickImage[BRICKIMAGEWIDTH*BRICKIMAGEHEIGHT] = {
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT,
    RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD
};

GLubyte *image = checkImage;
GLint imageHeight = CHECKIMAGEHEIGHT;
GLint imageWidth = CHECKIMAGEWIDTH;

float decal[] = {
    GL_DECAL,
};
float modulate[] = {
    GL_MODULATE,
};
float repeat[] = {
    GL_REPEAT,
};
float nearest[] = {
    GL_NEAREST,
};

GLubyte stipple[4*32] = {
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,

    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,
    0x00, 0x0F, 0xF0, 0x00,

    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
};

float tscp[18][2] = {
    {
	0.0, 0.0
    },
    {
	1.0, 0.0
    },
    {
	0.0, 0.125
    },
    {
	1.0, 0.125
    },
    {
	0.0, 0.250
    },
    {
	1.0, 0.25
    },
    {
	0.0, 0.375
    },
    {
	1.0, 0.375
    },
    {
	0.0, 0.50
    },
    {
	1.0, 0.50
    },
    {
	0.0, 0.625
    },
    {
	1.0, 0.625
    },
    {
	0.0, 0.75
    },
    {
	1.0, 0.75
    },
    {
	0.0, 0.875
    },
    {
	1.0, 0.875
    },
    {
	0.0, 1.0
    },
    {
	1.0, 1.0
    }
};
float scp[18][3] = {
    {
	1.000000, 0.000000, 0.000000
    },
    {
	1.000000, 0.000000, 5.000000
    },
    {
	0.707107, 0.707107, 0.000000
    },
    {
	0.707107, 0.707107, 5.000000
    },
    {
	0.000000, 1.000000, 0.000000
    },
    {
	0.000000, 1.000000, 5.000000
    },
    {
	-0.707107, 0.707107, 0.000000
    },
    {
	-0.707107, 0.707107, 5.000000
    },
    {
	-1.000000, 0.000000, 0.000000
    },
    {
	-1.000000, 0.000000, 5.000000
    },
    {
	-0.707107, -0.707107, 0.000000
    },
    {
	-0.707107, -0.707107, 5.000000
    },
    {
	0.000000, -1.000000, 0.000000
    },
    {
	0.000000, -1.000000, 5.000000
    },
    {
	0.707107, -0.707107, 0.000000
    },
    {
	0.707107, -0.707107, 5.000000
    },
    {
	1.000000, 0.000000, 0.000000
    },
    {
	1.000000, 0.000000, 5.000000
    }
};
float dcp[18][3] = {
    {
	1.000000, 0.000000, 0.000000
    },
    {
	1.000000, 0.000000, 7.000000
    },
    {
	0.707107, 0.707107, 0.000000
    },
    {
	0.707107, 0.707107, 7.000000
    },
    {
	0.000000, 1.000000, 0.000000
    },
    {
	0.000000, 1.000000, 7.000000
    },
    {
	-0.707107, 0.707107, 0.000000
    },
    {
	-0.707107, 0.707107, 7.000000
    },
    {
	-1.000000, 0.000000, 0.000000
    },
    {
	-1.000000, 0.000000, 7.000000
    },
    {
	-0.707107, -0.707107, 0.000000
    },
    {
	-0.707107, -0.707107, 7.000000
    },
    {
	0.000000, -1.000000, 0.000000
    },
    {
	0.000000, -1.000000, 7.000000
    },
    {
	0.707107, -0.707107, 0.000000
    },
    {
	0.707107, -0.707107, 7.000000
    },
    {
	1.000000, 0.000000, 0.000000
    },
    {
	1.000000, 0.000000, 7.000000
    }
};
float ep[7][9][3] = {
    {
	{
	    1.000000, 0.000000, 0.000000
	},
	{
	    0.707107, 0.707107, 0.000000
	},
	{
	    0.000000, 1.000000, 0.000000
	},
	{
	    -0.707107, 0.707107, 0.000000
	},
	{
	    -1.000000, 0.000000, 0.000000
	},
	{
	    -0.707107, -0.707107, 0.000000
	},
	{
	    0.000000, -1.000000, 0.000000
	},
	{
	    0.707107, -0.707107, 0.000000
	},
	{
	    1.000000, 0.000000, 0.000000
	}
    },
    {
	{
	    1.000000, 0.034074, 0.258819
	},
	{
	    0.707107, 0.717087, 0.075806
	},
	{
	    0.000000, 1.000000, 0.000000
	},
	{
	    -0.707107, 0.717087, 0.075806
	},
	{
	    -1.000000, 0.034074, 0.258819
	},
	{
	    -0.707107, -0.648939, 0.441832
	},
	{
	    0.000000, -0.931852, 0.517638
	},
	{
	    0.707107, -0.648939, 0.441832
	},
	{
	    1.000000, 0.034074, 0.258819
	}
    },
    {
	{
	    1.000000, 0.133975, 0.500000
	},
	{
	    0.707107, 0.746347, 0.146447
	},
	{
	    0.000000, 1.000000, 0.000000
	},
	{
	    -0.707107, 0.746347, 0.146447
	},
	{
	    -1.000000, 0.133975, 0.500000
	},
	{
	    -0.707107, -0.478398, 0.853553
	},
	{
	    0.000000, -0.732051, 1.000000
	},
	{
	    0.707107, -0.478398, 0.853553
	},
	{
	    1.000000, 0.133975, 0.500000
	}
    },
    {
	{
	    1.000000, 0.292893, 0.707107
	},
	{
	    0.707107, 0.792893, 0.207107
	},
	{
	    0.000000, 1.000000, 0.000000
	},
	{
	    -0.707107, 0.792893, 0.207107
	},
	{
	    -1.000000, 0.292893, 0.707107
	},
	{
	    -0.707107, -0.207107, 1.207107
	},
	{
	    0.000000, -0.414214, 1.414214
	},
	{
	    0.707107, -0.207107, 1.207107
	},
	{
	    1.000000, 0.292893, 0.707107
	}
    },
    {
	{
	    1.000000, 0.500000, 0.866025
	},
	{
	    0.707107, 0.853553, 0.253653
	},
	{
	    0.000000, 1.000000, 0.000000
	},
	{
	    -0.707107, 0.853553, 0.253653
	},
	{
	    -1.000000, 0.500000, 0.866025
	},
	{
	    -0.707107, 0.146447, 1.478398
	},
	{
	    0.000000, 0.000000, 1.732051
	},
	{
	    0.707107, 0.146447, 1.478398
	},
	{
	    1.000000, 0.500000, 0.866025
	}
    },
    {
	{
	    1.000000, 0.741181, 0.965926
	},
	{
	    0.707107, 0.924194, 0.282913
	},
	{
	    0.000000, 1.000000, 0.000000
	},
	{
	    -0.707107, 0.924194, 0.282913
	},
	{
	    -1.000000, 0.741181, 0.965926
	},
	{
	    -0.707107, 0.558168, 1.648939
	},
	{
	    0.000000, 0.482362, 1.931852
	},
	{
	    0.707107, 0.558168, 1.648939
	},
	{
	    1.000000, 0.741181, 0.965926
	}
    },
    {
	{
	    1.000000, 1.000000, 1.000000
	},
	{
	    0.707107, 1.000000, 0.292893
	},
	{
	    0.000000, 1.000000, 0.000000
	},
	{
	    -0.707107, 1.000000, 0.292893
	},
	{
	    -1.000000, 1.000000, 1.000000
	},
	{
	    -0.707107, 1.000000, 1.707107
	},
	{
	    0.000000, 1.000000, 2.000000
	},
	{
	    0.707107, 1.000000, 1.707107
	},
	{
	    1.000000, 1.000000, 1.000000
	}
    }
};
float en[7][9][3] = {
    {
	{
	    1.000000, 0.000000, 0.000000
	},
	{
	    0.707107, 0.707107, 0.000000
	},
	{
	    0.000000, 1.000000, 0.000000
	},
	{
	    -0.707107, 0.707107, 0.000000
	},
	{
	    -1.000000, 0.000000, 0.000000
	},
	{
	    -0.707107, -0.707107, 0.000000
	},
	{
	    0.000000, -1.000000, 0.000000
	},
	{
	    0.707107, -0.707107, 0.000000
	},
	{
	    1.000000, 0.000000, 0.000000
	}
    },
    {
	{
	    1.000000, 0.000000, 0.000000
	},
	{
	    0.707107, 0.683013, -0.183013
	},
	{
	    0.000000, 0.965926, -0.258819
	},
	{
	    -0.707107, 0.683013, -0.183013
	},
	{
	    -1.000000, 0.000000, 0.000000
	},
	{
	    -0.707107, -0.683013, 0.183013
	},
	{
	    0.000000, -0.965926, 0.258819
	},
	{
	    0.707107, -0.683013, 0.183013
	},
	{
	    1.000000, 0.000000, 0.000000
	}
    },
    {
	{
	    1.000000, 0.000000, 0.000000
	},
	{
	    0.707107, 0.612372, -0.353553
	},
	{
	    0.000000, 0.866025, -0.500000
	},
	{
	    -0.707107, 0.612372, -0.353553
	},
	{
	    -1.000000, 0.000000, 0.000000
	},
	{
	    -0.707107, -0.612372, 0.353553
	},
	{
	    0.000000, -0.866025, 0.500000
	},
	{
	    0.707107, -0.612372, 0.353553
	},
	{
	    1.000000, 0.000000, 0.000000
	}
    },
    {
	{
	    1.000000, 0.000000, 0.000000
	},
	{
	    0.707107, 0.500000, -0.500000
	},
	{
	    0.000000, 0.707107, -0.707107
	},
	{
	    -0.707107, 0.500000, -0.500000
	},
	{
	    -1.000000, 0.000000, 0.000000
	},
	{
	    -0.707107, -0.500000, 0.500000
	},
	{
	    0.000000, -0.707107, 0.707107
	},
	{
	    0.707107, -0.500000, 0.500000
	},
	{
	    1.000000, 0.000000, 0.000000
	}
    },
    {
	{
	    1.000000, 0.000000, 0.000000
	},
	{
	    0.707107, 0.353553, -0.612372
	},
	{
	    0.000000, 0.500000, -0.866025
	},
	{
	    -0.707107, 0.353553, -0.612372
	},
	{
	    -1.000000, 0.000000, 0.000000
	},
	{
	    -0.707107, -0.353553, 0.612372
	},
	{
	    0.000000, -0.500000, 0.866025
	},
	{
	    0.707107, -0.353553, 0.612372
	},
	{
	    1.000000, 0.000000, 0.000000
	}
    },
    {
	{
	    1.000000, 0.000000, 0.000000
	},
	{
	    0.707107, 0.183013, -0.683013
	},
	{
	    0.000000, 0.258819, -0.965926
	},
	{
	    -0.707107, 0.183013, -0.683013
	},
	{
	    -1.000000, 0.000000, 0.000000
	},
	{
	    -0.707107, -0.183013, 0.683013
	},
	{
	    0.000000, -0.258819, 0.965926
	},
	{
	    0.707107, -0.183013, 0.683013
	},
	{
	    1.000000, 0.000000, 0.000000
	}
    },
    {
	{
	    1.000000, 0.000000, 0.000000
	},
	{
	    0.707107, 0.000000, -0.707107
	},
	{
	    0.000000, 0.000000, -1.000000
	},
	{
	    -0.707107, 0.000000, -0.707107
	},
	{
	    -1.000000, 0.000000, 0.000000
	},
	{
	    -0.707107, 0.000000, 0.707107
	},
	{
	    0.000000, 0.000000, 1.000000
	},
	{
	    0.707107, 0.000000, 0.707107
	},
	{
	    1.000000, 0.000000, 0.000000
	}
    }
};
float tep[7][9][2] = {
    {
	{
	    0,     0.0
	},
	{
	    0.125, 0.0
	},
	{
	    0.25,  0.0
	},
	{
	    0.375, 0.0
	},
	{
	    0.5,   0.0
	},
	{
	    0.625, 0.0
	},
	{
	    0.75,  0.0
	},
	{
	    0.875, 0.0
	},
	{
	    1.0,   0.0
	}
    },
    {
	{
	    0,     0.16667
	},
	{
	    0.125, 0.16667
	},
	{
	    0.25,  0.16667
	},
	{
	    0.375, 0.16667
	},
	{
	    0.5,   0.16667
	},
	{
	    0.625, 0.16667
	},
	{
	    0.75,  0.16667
	},
	{
	    0.875, 0.16667
	},
	{
	    1.0,   0.16667
	}
    },
    {
	{
	    0,     0.33333
	},
	{
	    0.125, 0.33333
	},
	{
	    0.25,  0.33333
	},
	{
	    0.375, 0.33333
	},
	{
	    0.5,   0.33333
	},
	{
	    0.625, 0.33333
	},
	{
	    0.75,  0.33333
	},
	{
	    0.875, 0.33333
	},
	{
	    1.0,   0.33333
	}
    },
    {
	{
	    0,     0.5
	},
	{
	    0.125, 0.5
	},
	{
	    0.25,  0.5
	},
	{
	    0.375, 0.5
	},
	{
	    0.5,   0.5
	},
	{
	    0.625, 0.5
	},
	{
	    0.75,  0.5
	},
	{
	    0.875, 0.5
	},
	{
	    1.0,   0.5
	}
    },
    {
	{
	    0,     0.6667
	},
	{
	    0.125, 0.6667
	},
	{
	    0.25,  0.6667
	},
	{
	    0.375, 0.6667
	},
	{
	    0.5,   0.6667
	},
	{
	    0.625, 0.6667
	},
	{
	    0.75,  0.6667
	},
	{
	    0.875, 0.6667
	},
	{
	    1.0,   0.6667
	}
    },
    {
	{
	    0,     0.83333
	},
	{
	    0.125, 0.83333
	},
	{
	    0.25,  0.83333
	},
	{
	    0.375, 0.83333
	},
	{
	    0.5,   0.83333
	},
	{
	    0.625, 0.83333
	},
	{
	    0.75,  0.83333
	},
	{
	    0.875, 0.83333
	},
	{
	    1.0,   0.83333
	}
    },
    {
	{
	    0,     1.0
	},
	{
	    0.125, 1.0
	},
	{
	    0.25,  1.0
	},
	{
	    0.375, 1.0
	},
	{
	    0.5,   1.0
	},
	{
	    0.625, 1.0
	},
	{
	    0.75,  1.0
	},
	{
	    0.875, 1.0
	},
	{
	    1.0,   1.0
	}
    }
};


static void SetUpAntiAliasedGrayScale(void)
{
    float color;
    GLint i, j;

    for (i = 0; i < 16; i++) {
	color = (2 * i + 1) / 32.0;
	for (j = 0; j < 16; j++) {
	    tkSetOneColor(i*16+j, color*j/15.0, color*j/15.0, color*j/15.0);
	}
    }
}

static void BendForward(void)
{

    glTranslatef(0.0, 1.0, 0.0);
    glRotatef(90.0, 1, 0, 0);
    glTranslatef(0.0, -1.0, 0.0);
}

static void BendLeft(void)
{

    glRotatef(-90.0, 0, 0, 1);
    glTranslatef(0.0, 1.0, 0.0);
    glRotatef(90.0, 1, 0, 0);
    glTranslatef(0.0, -1.0, 0.0);
}

static void BendRight(void)
{

    glRotatef(90.0, 0, 0, 1);
    glTranslatef(0.0, 1.0, 0.0);
    glRotatef(90.0, 1, 0, 0);
    glTranslatef(0.0, -1.0, 0.0);
}

static void BuildSingleCylinder(void)
{

    glNewList(singleCylinder, GL_COMPILE);

    glBegin(GL_TRIANGLE_STRIP);
       glNormal3fv(scp[0]); glTexCoord2fv(tscp[0]); glVertex3fv(scp[0]);
       glNormal3fv(scp[0]); glTexCoord2fv(tscp[1]); glVertex3fv(scp[1]);
       glNormal3fv(scp[2]); glTexCoord2fv(tscp[2]); glVertex3fv(scp[2]);
       glNormal3fv(scp[2]); glTexCoord2fv(tscp[3]); glVertex3fv(scp[3]);
       glNormal3fv(scp[4]); glTexCoord2fv(tscp[4]); glVertex3fv(scp[4]);
       glNormal3fv(scp[4]); glTexCoord2fv(tscp[5]); glVertex3fv(scp[5]);
       glNormal3fv(scp[6]); glTexCoord2fv(tscp[6]); glVertex3fv(scp[6]);
       glNormal3fv(scp[6]); glTexCoord2fv(tscp[7]); glVertex3fv(scp[7]);
       glNormal3fv(scp[8]); glTexCoord2fv(tscp[8]); glVertex3fv(scp[8]);
       glNormal3fv(scp[8]); glTexCoord2fv(tscp[9]); glVertex3fv(scp[9]);
       glNormal3fv(scp[10]); glTexCoord2fv(tscp[10]); glVertex3fv(scp[10]);
       glNormal3fv(scp[10]); glTexCoord2fv(tscp[11]); glVertex3fv(scp[11]);
       glNormal3fv(scp[12]); glTexCoord2fv(tscp[12]); glVertex3fv(scp[12]);
       glNormal3fv(scp[12]); glTexCoord2fv(tscp[13]); glVertex3fv(scp[13]);
       glNormal3fv(scp[14]); glTexCoord2fv(tscp[14]); glVertex3fv(scp[14]);
       glNormal3fv(scp[14]); glTexCoord2fv(tscp[15]); glVertex3fv(scp[15]);
       glNormal3fv(scp[16]); glTexCoord2fv(tscp[16]); glVertex3fv(scp[16]);
       glNormal3fv(scp[16]); glTexCoord2fv(tscp[17]); glVertex3fv(scp[17]);
    glEnd();

    glEndList();
}

static void BuildDoubleCylinder(void)
{

    glNewList(doubleCylinder, GL_COMPILE);

    glBegin(GL_TRIANGLE_STRIP);
	glNormal3fv(dcp[0]); glTexCoord2fv(tscp[0]); glVertex3fv(dcp[0]);
	glNormal3fv(dcp[0]); glTexCoord2fv(tscp[1]); glVertex3fv(dcp[1]);
	glNormal3fv(dcp[2]); glTexCoord2fv(tscp[2]); glVertex3fv(dcp[2]);
	glNormal3fv(dcp[2]); glTexCoord2fv(tscp[3]); glVertex3fv(dcp[3]);
	glNormal3fv(dcp[4]); glTexCoord2fv(tscp[4]); glVertex3fv(dcp[4]);
	glNormal3fv(dcp[4]); glTexCoord2fv(tscp[5]); glVertex3fv(dcp[5]);
	glNormal3fv(dcp[6]); glTexCoord2fv(tscp[6]); glVertex3fv(dcp[6]);
	glNormal3fv(dcp[6]); glTexCoord2fv(tscp[7]); glVertex3fv(dcp[7]);
	glNormal3fv(dcp[8]); glTexCoord2fv(tscp[8]); glVertex3fv(dcp[8]);
	glNormal3fv(dcp[8]); glTexCoord2fv(tscp[9]); glVertex3fv(dcp[9]);
	glNormal3fv(dcp[10]); glTexCoord2fv(tscp[10]); glVertex3fv(dcp[10]);
	glNormal3fv(dcp[10]); glTexCoord2fv(tscp[11]); glVertex3fv(dcp[11]);
	glNormal3fv(dcp[12]); glTexCoord2fv(tscp[12]); glVertex3fv(dcp[12]);
	glNormal3fv(dcp[12]); glTexCoord2fv(tscp[13]); glVertex3fv(dcp[13]);
	glNormal3fv(dcp[14]); glTexCoord2fv(tscp[14]); glVertex3fv(dcp[14]);
	glNormal3fv(dcp[14]); glTexCoord2fv(tscp[15]); glVertex3fv(dcp[15]);
	glNormal3fv(dcp[16]); glTexCoord2fv(tscp[16]); glVertex3fv(dcp[16]);
	glNormal3fv(dcp[16]); glTexCoord2fv(tscp[17]); glVertex3fv(dcp[17]);
    glEnd();

    glEndList();
}

static void BuildElbow(void)
{

    glNewList(elbow, GL_COMPILE);

    glBegin(GL_TRIANGLE_STRIP);
	glNormal3fv(en[0][0]); glTexCoord2fv(tep[0][0]); glVertex3fv(ep[0][0]);
	glNormal3fv(en[1][0]); glTexCoord2fv(tep[1][0]); glVertex3fv(ep[1][0]);
	glNormal3fv(en[0][1]); glTexCoord2fv(tep[0][1]); glVertex3fv(ep[0][1]);
	glNormal3fv(en[1][1]); glTexCoord2fv(tep[1][1]); glVertex3fv(ep[1][1]);
	glNormal3fv(en[0][2]); glTexCoord2fv(tep[0][2]); glVertex3fv(ep[0][2]);
	glNormal3fv(en[1][2]); glTexCoord2fv(tep[1][2]); glVertex3fv(ep[1][2]);
	glNormal3fv(en[0][3]); glTexCoord2fv(tep[0][3]); glVertex3fv(ep[0][3]);
	glNormal3fv(en[1][3]); glTexCoord2fv(tep[1][3]); glVertex3fv(ep[1][3]);
	glNormal3fv(en[0][4]); glTexCoord2fv(tep[0][4]); glVertex3fv(ep[0][4]);
	glNormal3fv(en[1][4]); glTexCoord2fv(tep[1][4]); glVertex3fv(ep[1][4]);
	glNormal3fv(en[0][5]); glTexCoord2fv(tep[0][5]); glVertex3fv(ep[0][5]);
	glNormal3fv(en[1][5]); glTexCoord2fv(tep[1][5]); glVertex3fv(ep[1][5]);
	glNormal3fv(en[0][6]); glTexCoord2fv(tep[0][6]); glVertex3fv(ep[0][6]);
	glNormal3fv(en[1][6]); glTexCoord2fv(tep[1][6]); glVertex3fv(ep[1][6]);
	glNormal3fv(en[0][7]); glTexCoord2fv(tep[0][7]); glVertex3fv(ep[0][7]);
	glNormal3fv(en[1][7]); glTexCoord2fv(tep[1][7]); glVertex3fv(ep[1][7]);
	glNormal3fv(en[0][8]); glTexCoord2fv(tep[0][8]); glVertex3fv(ep[0][8]);
	glNormal3fv(en[1][8]); glTexCoord2fv(tep[1][8]); glVertex3fv(ep[1][8]);
    glEnd();
    glBegin(GL_TRIANGLE_STRIP);
	glNormal3fv(en[1][0]); glTexCoord2fv(tep[1][0]); glVertex3fv(ep[1][0]);
	glNormal3fv(en[2][0]); glTexCoord2fv(tep[2][0]); glVertex3fv(ep[2][0]);
	glNormal3fv(en[1][1]); glTexCoord2fv(tep[1][1]); glVertex3fv(ep[1][1]);
	glNormal3fv(en[2][1]); glTexCoord2fv(tep[2][1]); glVertex3fv(ep[2][1]);
	glNormal3fv(en[1][2]); glTexCoord2fv(tep[1][2]); glVertex3fv(ep[1][2]);
	glNormal3fv(en[2][2]); glTexCoord2fv(tep[2][2]); glVertex3fv(ep[2][2]);
	glNormal3fv(en[1][3]); glTexCoord2fv(tep[1][3]); glVertex3fv(ep[1][3]);
	glNormal3fv(en[2][3]); glTexCoord2fv(tep[2][3]); glVertex3fv(ep[2][3]);
	glNormal3fv(en[1][4]); glTexCoord2fv(tep[1][4]); glVertex3fv(ep[1][4]);
	glNormal3fv(en[2][4]); glTexCoord2fv(tep[2][4]); glVertex3fv(ep[2][4]);
	glNormal3fv(en[1][5]); glTexCoord2fv(tep[1][5]); glVertex3fv(ep[1][5]);
	glNormal3fv(en[2][5]); glTexCoord2fv(tep[2][5]); glVertex3fv(ep[2][5]);
	glNormal3fv(en[1][6]); glTexCoord2fv(tep[1][6]); glVertex3fv(ep[1][6]);
	glNormal3fv(en[2][6]); glTexCoord2fv(tep[2][6]); glVertex3fv(ep[2][6]);
	glNormal3fv(en[1][7]); glTexCoord2fv(tep[1][7]); glVertex3fv(ep[1][7]);
	glNormal3fv(en[2][7]); glTexCoord2fv(tep[2][7]); glVertex3fv(ep[2][7]);
	glNormal3fv(en[1][8]); glTexCoord2fv(tep[1][8]); glVertex3fv(ep[1][8]);
	glNormal3fv(en[2][8]); glTexCoord2fv(tep[2][8]); glVertex3fv(ep[2][8]);
    glEnd();
    glBegin(GL_TRIANGLE_STRIP);
	glNormal3fv(en[2][0]); glTexCoord2fv(tep[2][0]); glVertex3fv(ep[2][0]);
	glNormal3fv(en[3][0]); glTexCoord2fv(tep[3][0]); glVertex3fv(ep[3][0]);
	glNormal3fv(en[2][1]); glTexCoord2fv(tep[2][1]); glVertex3fv(ep[2][1]);
	glNormal3fv(en[3][1]); glTexCoord2fv(tep[3][1]); glVertex3fv(ep[3][1]);
	glNormal3fv(en[2][2]); glTexCoord2fv(tep[2][2]); glVertex3fv(ep[2][2]);
	glNormal3fv(en[3][2]); glTexCoord2fv(tep[3][2]); glVertex3fv(ep[3][2]);
	glNormal3fv(en[2][3]); glTexCoord2fv(tep[2][3]); glVertex3fv(ep[2][3]);
	glNormal3fv(en[3][3]); glTexCoord2fv(tep[3][3]); glVertex3fv(ep[3][3]);
	glNormal3fv(en[2][4]); glTexCoord2fv(tep[2][4]); glVertex3fv(ep[2][4]);
	glNormal3fv(en[3][4]); glTexCoord2fv(tep[3][4]); glVertex3fv(ep[3][4]);
	glNormal3fv(en[2][5]); glTexCoord2fv(tep[2][5]); glVertex3fv(ep[2][5]);
	glNormal3fv(en[3][5]); glTexCoord2fv(tep[3][5]); glVertex3fv(ep[3][5]);
	glNormal3fv(en[2][6]); glTexCoord2fv(tep[2][6]); glVertex3fv(ep[2][6]);
	glNormal3fv(en[3][6]); glTexCoord2fv(tep[3][6]); glVertex3fv(ep[3][6]);
	glNormal3fv(en[2][7]); glTexCoord2fv(tep[2][7]); glVertex3fv(ep[2][7]);
	glNormal3fv(en[3][7]); glTexCoord2fv(tep[3][7]); glVertex3fv(ep[3][7]);
	glNormal3fv(en[2][8]); glTexCoord2fv(tep[2][8]); glVertex3fv(ep[2][8]);
	glNormal3fv(en[3][8]); glTexCoord2fv(tep[3][8]); glVertex3fv(ep[3][8]);
    glEnd();
    glBegin(GL_TRIANGLE_STRIP);
	glNormal3fv(en[3][0]); glTexCoord2fv(tep[3][0]); glVertex3fv(ep[3][0]);
	glNormal3fv(en[4][0]); glTexCoord2fv(tep[4][0]); glVertex3fv(ep[4][0]);
	glNormal3fv(en[3][1]); glTexCoord2fv(tep[3][1]); glVertex3fv(ep[3][1]);
	glNormal3fv(en[4][1]); glTexCoord2fv(tep[4][1]); glVertex3fv(ep[4][1]);
	glNormal3fv(en[3][2]); glTexCoord2fv(tep[3][2]); glVertex3fv(ep[3][2]);
	glNormal3fv(en[4][2]); glTexCoord2fv(tep[4][2]); glVertex3fv(ep[4][2]);
	glNormal3fv(en[3][3]); glTexCoord2fv(tep[3][3]); glVertex3fv(ep[3][3]);
	glNormal3fv(en[4][3]); glTexCoord2fv(tep[4][3]); glVertex3fv(ep[4][3]);
	glNormal3fv(en[3][4]); glTexCoord2fv(tep[3][4]); glVertex3fv(ep[3][4]);
	glNormal3fv(en[4][4]); glTexCoord2fv(tep[4][4]); glVertex3fv(ep[4][4]);
	glNormal3fv(en[3][5]); glTexCoord2fv(tep[3][5]); glVertex3fv(ep[3][5]);
	glNormal3fv(en[4][5]); glTexCoord2fv(tep[4][5]); glVertex3fv(ep[4][5]);
	glNormal3fv(en[3][6]); glTexCoord2fv(tep[3][6]); glVertex3fv(ep[3][6]);
	glNormal3fv(en[4][6]); glTexCoord2fv(tep[4][6]); glVertex3fv(ep[4][6]);
	glNormal3fv(en[3][7]); glTexCoord2fv(tep[3][7]); glVertex3fv(ep[3][7]);
	glNormal3fv(en[4][7]); glTexCoord2fv(tep[4][7]); glVertex3fv(ep[4][7]);
	glNormal3fv(en[3][8]); glTexCoord2fv(tep[3][8]); glVertex3fv(ep[3][8]);
	glNormal3fv(en[4][8]); glTexCoord2fv(tep[4][8]); glVertex3fv(ep[4][8]);
    glEnd();
    glBegin(GL_TRIANGLE_STRIP);
	glNormal3fv(en[4][0]); glTexCoord2fv(tep[4][0]); glVertex3fv(ep[4][0]);
	glNormal3fv(en[5][0]); glTexCoord2fv(tep[5][0]); glVertex3fv(ep[5][0]);
	glNormal3fv(en[4][1]); glTexCoord2fv(tep[4][1]); glVertex3fv(ep[4][1]);
	glNormal3fv(en[5][1]); glTexCoord2fv(tep[5][1]); glVertex3fv(ep[5][1]);
	glNormal3fv(en[4][2]); glTexCoord2fv(tep[4][2]); glVertex3fv(ep[4][2]);
	glNormal3fv(en[5][2]); glTexCoord2fv(tep[5][2]); glVertex3fv(ep[5][2]);
	glNormal3fv(en[4][3]); glTexCoord2fv(tep[4][3]); glVertex3fv(ep[4][3]);
	glNormal3fv(en[5][3]); glTexCoord2fv(tep[5][3]); glVertex3fv(ep[5][3]);
	glNormal3fv(en[4][4]); glTexCoord2fv(tep[4][4]); glVertex3fv(ep[4][4]);
	glNormal3fv(en[5][4]); glTexCoord2fv(tep[5][4]); glVertex3fv(ep[5][4]);
	glNormal3fv(en[4][5]); glTexCoord2fv(tep[4][5]); glVertex3fv(ep[4][5]);
	glNormal3fv(en[5][5]); glTexCoord2fv(tep[5][5]); glVertex3fv(ep[5][5]);
	glNormal3fv(en[4][6]); glTexCoord2fv(tep[4][6]); glVertex3fv(ep[4][6]);
	glNormal3fv(en[5][6]); glTexCoord2fv(tep[5][6]); glVertex3fv(ep[5][6]);
	glNormal3fv(en[4][7]); glTexCoord2fv(tep[4][7]); glVertex3fv(ep[4][7]);
	glNormal3fv(en[5][7]); glTexCoord2fv(tep[5][7]); glVertex3fv(ep[5][7]);
	glNormal3fv(en[4][8]); glTexCoord2fv(tep[4][8]); glVertex3fv(ep[4][8]);
	glNormal3fv(en[5][8]); glTexCoord2fv(tep[5][8]); glVertex3fv(ep[5][8]);
    glEnd();
    glBegin(GL_TRIANGLE_STRIP);
	glNormal3fv(en[5][0]); glTexCoord2fv(tep[5][0]); glVertex3fv(ep[5][0]);
	glNormal3fv(en[6][0]); glTexCoord2fv(tep[6][0]); glVertex3fv(ep[6][0]);
	glNormal3fv(en[5][1]); glTexCoord2fv(tep[5][1]); glVertex3fv(ep[5][1]);
	glNormal3fv(en[6][1]); glTexCoord2fv(tep[6][1]); glVertex3fv(ep[6][1]);
	glNormal3fv(en[5][2]); glTexCoord2fv(tep[5][2]); glVertex3fv(ep[5][2]);
	glNormal3fv(en[6][2]); glTexCoord2fv(tep[6][2]); glVertex3fv(ep[6][2]);
	glNormal3fv(en[5][3]); glTexCoord2fv(tep[5][3]); glVertex3fv(ep[5][3]);
	glNormal3fv(en[6][3]); glTexCoord2fv(tep[6][3]); glVertex3fv(ep[6][3]);
	glNormal3fv(en[5][4]); glTexCoord2fv(tep[5][4]); glVertex3fv(ep[5][4]);
	glNormal3fv(en[6][4]); glTexCoord2fv(tep[6][4]); glVertex3fv(ep[6][4]);
	glNormal3fv(en[5][5]); glTexCoord2fv(tep[5][5]); glVertex3fv(ep[5][5]);
	glNormal3fv(en[6][5]); glTexCoord2fv(tep[6][5]); glVertex3fv(ep[6][5]);
	glNormal3fv(en[5][6]); glTexCoord2fv(tep[5][6]); glVertex3fv(ep[5][6]);
	glNormal3fv(en[6][6]); glTexCoord2fv(tep[6][6]); glVertex3fv(ep[6][6]);
	glNormal3fv(en[5][7]); glTexCoord2fv(tep[5][7]); glVertex3fv(ep[5][7]);
	glNormal3fv(en[6][7]); glTexCoord2fv(tep[6][7]); glVertex3fv(ep[6][7]);
	glNormal3fv(en[5][8]); glTexCoord2fv(tep[5][8]); glVertex3fv(ep[5][8]);
	glNormal3fv(en[6][8]); glTexCoord2fv(tep[6][8]); glVertex3fv(ep[6][8]);
    glEnd();

    glEndList();
}

static void BuildLogo(void)
{

    glNewList(logo, GL_COMPILE);

    glTranslatef(5.5, -3.5, 4.5);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -5.0);
    glCallList(singleCylinder);
    BendRight();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -5.0);
    glCallList(singleCylinder);
    BendLeft();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -5.0);
    glCallList(singleCylinder);
    BendRight();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -5.0);
    glCallList(singleCylinder);
    BendLeft();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -5.0);
    glCallList(singleCylinder);
    BendRight();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -7.0);
    glCallList(doubleCylinder);
    BendForward();
    glCallList(elbow);
    glTranslatef(0.0, 0.0, -5.0);
    glCallList(singleCylinder);
    BendLeft();
    glCallList(elbow);

    glEndList();
}

static void BuildLists(void)
{

    singleCylinder = glGenLists(1);
    doubleCylinder = glGenLists(1);
    elbow = glGenLists(1);
    logo = glGenLists(1);

    BuildSingleCylinder();
    BuildDoubleCylinder();
    BuildElbow();
    BuildLogo();
}

static void Init(void)
{
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {0.5, 1.0, 1.0, 1.0};
    static float position[] = {90.0, 90.0, 150.0, 0.0};
    static float front_mat_shininess[] = {30.0};
    static float front_mat_specular[] = {0.2, 0.2, 0.2, 1.0};
    static float front_mat_diffuse[] = {0.5, 0.28, 0.38, 1.0};
    static float back_mat_shininess[] = {50.0};
    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0};
    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0};
    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0};
    static float lmodel_twoside[] = {GL_TRUE};

    glClearColor(0.0, 0.0, 0.0, 0.0);

    glFrontFace(GL_CW);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    
    glMaterialfv(GL_FRONT, GL_SHININESS, front_mat_shininess);
    glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_BACK, GL_SHININESS, back_mat_shininess);
    glMaterialfv(GL_BACK, GL_SPECULAR, back_mat_specular);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);

    glEnable(GL_CLIP_PLANE0);

    if (rgb) {
	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nearest);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nearest);
	glTexImage2D(GL_TEXTURE_2D, 0, 3, CHECKIMAGEWIDTH, CHECKIMAGEHEIGHT, 0,
		     GL_RGB, GL_UNSIGNED_BYTE, (GLvoid *)checkImage);
	glEnable(GL_TEXTURE_2D);

	glCullFace(GL_BACK);
	glEnable(GL_CULL_FACE);
    } else {
	tkSetGreyRamp();
	if (doubleBuffer) {
	    colorIndexes[1] = 10;
	    colorIndexes[2] = 15;
	}
	glMaterialiv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, colorIndexes);
    }

    BuildLists();

    dithering = GL_TRUE;
    shade = GL_TRUE;
    doStipple = GL_FALSE;
    polyMode = GL_BACK;
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(90, 1.0, 1.0, 200.0);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();

      case TK_LEFT:
	yRotation += 0.5;
	break;
      case TK_RIGHT:
	yRotation -= 0.5;
	break;
      case TK_UP:
	plane[3] += 2.0;
	break;
      case TK_DOWN:
	plane[3] -= 2.0;
	break;
      case TK_Z:
	zTranslation -= 1.0;
	break;
      case TK_z:
	zTranslation += 1.0;
	break;

      case TK_1:
	glPolygonMode(polyMode, GL_POINT);
	break;
      case TK_2:
	glPolygonMode(polyMode, GL_LINE);
	break;
      case TK_3:
	glPolygonMode(polyMode, GL_FILL);
	break;
      case TK_p:
	switch (polyMode) {
	  case GL_BACK:
	    polyMode = GL_FRONT;
	    break;
	  case GL_FRONT:
	    polyMode = GL_FRONT_AND_BACK;
	    break;
	  case GL_FRONT_AND_BACK:
	    polyMode = GL_BACK;
	    break;
	}
	break;

      case TK_4:
	glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
	break;
      case TK_5:
	glEnable(GL_POLYGON_SMOOTH);
	if (rgb) {
	    glBlendFunc(GL_SRC_ALPHA, GL_ONE);
	    glEnable(GL_BLEND);
	    glDisable(GL_DEPTH_TEST);
	} else {
	    SetUpAntiAliasedGrayScale();
	}
	break;
      case TK_6:
	glDisable(GL_POLYGON_SMOOTH);
	if (rgb) {
	    glBlendFunc(GL_ONE, GL_ZERO);
	    glDisable(GL_BLEND);
	    glEnable(GL_DEPTH_TEST);
	} else {
	    tkSetGreyRamp();
	}
	break;

      case TK_8:
	dithering = !dithering;
	(dithering) ? glEnable(GL_DITHER) : glDisable(GL_DITHER);
	break;

      case TK_9:
	doStipple = !doStipple;
	if (doStipple) {
	    glPolygonStipple(stipple);
	    glEnable(GL_POLYGON_STIPPLE);
	} else {
	    glDisable(GL_POLYGON_STIPPLE);
	}
	break;

      case TK_0:
	shade = !shade;
	(shade) ? glShadeModel(GL_SMOOTH) : glShadeModel(GL_FLAT);
	break;

      case TK_q:
	glDisable(GL_CULL_FACE);
	break;
      case TK_w:
	glEnable(GL_CULL_FACE);
	glCullFace(GL_FRONT);
	break;
      case TK_e:
	glEnable(GL_CULL_FACE);
	glCullFace(GL_BACK);
	break;

      case TK_r:
	glFrontFace(GL_CW);
	break;
      case TK_t: 
	glFrontFace(GL_CCW);
	break;
      case TK_y:
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glPixelStorei(GL_UNPACK_LSB_FIRST, 0);
	glPolygonStipple(stipple);
	break;
      case TK_u:
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glPixelStorei(GL_UNPACK_LSB_FIRST, 1);
	glPolygonStipple(stipple);
	break;

      case TK_a:
	glEnable(GL_TEXTURE_2D);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nearest);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nearest);
	glTexImage2D(GL_TEXTURE_2D, 0, 4, BRICKIMAGEWIDTH,
		     BRICKIMAGEHEIGHT, 0, GL_RGBA, GL_UNSIGNED_BYTE,
		     (GLvoid *)brickImage);
	break;
      case TK_s:
	glEnable(GL_TEXTURE_2D);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nearest);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nearest);
	glTexImage2D(GL_TEXTURE_2D, 0, 3, CHECKIMAGEWIDTH,
		     CHECKIMAGEHEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE,
		     (GLvoid *)checkImage);
	break;
      case TK_d:
	glDisable(GL_TEXTURE_2D);
	break;

      case TK_f:
	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
	break;
      case TK_g:
	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, modulate);
	break;

      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    glPushMatrix();

    glTranslatef(0, 0, zTranslation);
    glRotatef(30.0, 1, 0, 0);
    glRotatef(yRotation, 0, 1, 0);
    glClipPlane(GL_CLIP_PLANE0, plane);
    glCallList(logo);

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_TRUE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    type = TK_DEPTH16;
    type |= (rgb) ? TK_RGB : TK_INDEX;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Logo Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tfog.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


GLenum rgb, doubleBuffer, directRender;

double plane[4] = {
    1.0, 0.0, -1.0, 0.0
};
float rotX = 5.0, rotY = -5.0, zTranslate = -65.0;
float fogDensity = 0.02;
GLint cubeList = 1;

float scp[18][3] = {
    {
	1.000000, 0.000000, 0.000000
    },	
    {
	1.000000, 0.000000, 5.000000
    },
    {
	0.707107, 0.707107, 0.000000
    },	
    {
	0.707107, 0.707107, 5.000000
    },
    {
	0.000000, 1.000000, 0.000000
    },	
    {
	0.000000, 1.000000, 5.000000
    },
    {
	-0.707107, 0.707107, 0.000000
    },	
    {
	-0.707107, 0.707107, 5.000000
    },
    {
	-1.000000, 0.000000, 0.000000
    },	
    {
	-1.000000, 0.000000, 5.000000
    },
    {
	-0.707107, -0.707107, 0.000000
    },	
    {
	-0.707107, -0.707107, 5.000000
    },
    {
	0.000000, -1.000000, 0.000000
    },	
    {
	0.000000, -1.000000, 5.000000
    },
    {
	0.707107, -0.707107, 0.000000
    },	
    {
	0.707107, -0.707107, 5.000000
    },
    {
	1.000000, 0.000000, 0.000000
    },	
    {
	1.000000, 0.000000, 5.000000
    },
};


static void Build_lists(void)
{

    glNewList(cubeList, GL_COMPILE);
	glBegin(GL_TRIANGLE_STRIP);
	   glNormal3fv(scp[0]); glVertex3fv(scp[0]);
	   glNormal3fv(scp[0]); glVertex3fv(scp[1]);
	   glNormal3fv(scp[2]); glVertex3fv(scp[2]);
	   glNormal3fv(scp[2]); glVertex3fv(scp[3]);
	   glNormal3fv(scp[4]); glVertex3fv(scp[4]);
	   glNormal3fv(scp[4]); glVertex3fv(scp[5]);
	   glNormal3fv(scp[6]); glVertex3fv(scp[6]);
	   glNormal3fv(scp[6]); glVertex3fv(scp[7]);
	   glNormal3fv(scp[8]); glVertex3fv(scp[8]);
	   glNormal3fv(scp[8]); glVertex3fv(scp[9]);
	   glNormal3fv(scp[10]); glVertex3fv(scp[10]);
	   glNormal3fv(scp[10]); glVertex3fv(scp[11]);
	   glNormal3fv(scp[12]); glVertex3fv(scp[12]);
	   glNormal3fv(scp[12]); glVertex3fv(scp[13]);
	   glNormal3fv(scp[14]); glVertex3fv(scp[14]);
	   glNormal3fv(scp[14]); glVertex3fv(scp[15]);
	   glNormal3fv(scp[16]); glVertex3fv(scp[16]);
	   glNormal3fv(scp[16]); glVertex3fv(scp[17]);
	glEnd();
    glEndList();
}

static void Init(void)
{
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {1.0, 1.0, 1.0, 1.0};
    static float position[] = {90.0, 90.0, 0.0, 0.0};
    static float front_mat_shininess[] = {30.0};
    static float front_mat_specular[] = {0.0, 0.0, 0.0, 1.0};
    static float front_mat_diffuse[] = {0.0, 1.0, 0.0, 1.0};
    static float back_mat_shininess[] = {50.0};
    static float back_mat_specular[] = {0.0, 0.0, 1.0, 1.0};
    static float back_mat_diffuse[] = {1.0, 0.0, 0.0, 1.0};
    static float lmodel_ambient[] = {0.0, 0.0, 0.0, 1.0};
    static float fog_color[] = {0.8, 0.8, 0.8, 1.0};
    
    glFrontFace(GL_CW);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    
    glMaterialfv(GL_FRONT, GL_SHININESS, front_mat_shininess);
    glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_BACK, GL_SHININESS, back_mat_shininess);
    glMaterialfv(GL_BACK, GL_SPECULAR, back_mat_specular);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);

    glEnable(GL_FOG);
    glFogi(GL_FOG_MODE, GL_EXP);
    glFogf(GL_FOG_DENSITY, fogDensity);
    if (rgb) {
	glFogfv(GL_FOG_COLOR, fog_color);
	glClearColor(0.8, 0.8, 0.8, 1.0);
    } else {
	glFogi(GL_FOG_INDEX, 1<<5);
	tkSetFogRamp(5, 3);
	glClearIndex(128);
    }

    Build_lists();
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, 1.0, 1.0, 200.0);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_UP:
	rotX -= 5;
	break;
      case TK_DOWN:
	rotX += 5;
	break;
      case TK_LEFT:
	rotY -= 5;
	break;
      case TK_RIGHT:
	rotY += 5;
	break;
      case TK_D:
	if (rgb) {
	    fogDensity *= 1.10;
	    glFogf(GL_FOG_DENSITY, fogDensity);
	}
	break;
      case TK_d:
	if (rgb) {
	    fogDensity /= 1.10;
	    glFogf(GL_FOG_DENSITY, fogDensity);
	}
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    glPushMatrix();

    glTranslatef(0, 0, zTranslate);
    glRotatef(rotY, 0,1,0);
    glRotatef(rotX, 1,0,0);
    glScalef(1.0, 1.0, 10.0);

    glCallList(cubeList);

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    type = TK_DEPTH16;
    type |= (rgb) ? TK_RGB : TK_INDEX;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Fog Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tnurb.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <math.h>
#include "tk.h"


#define INREAL float

#define S_NUMPOINTS 13
#define S_ORDER     3   
#define S_NUMKNOTS  (S_NUMPOINTS + S_ORDER)
#define T_NUMPOINTS 3
#define T_ORDER     3 
#define T_NUMKNOTS  (T_NUMPOINTS + T_ORDER)
#define SQRT_TWO    1.41421356237309504880


typedef INREAL Point[4];


GLenum doubleBuffer, directRender;

GLenum expectedError;
GLint rotX = 40, rotY = 40;
INREAL sknots[S_NUMKNOTS] = {
    -1.0, -1.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0,
    4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 9.0, 9.0
};
INREAL tknots[T_NUMKNOTS] = {
    1.0, 1.0, 1.0, 2.0, 2.0, 2.0
};
Point ctlpoints[S_NUMPOINTS][T_NUMPOINTS] = {
    {
	{
	    4.0, 2.0, 2.0, 1.0
	},
	{
	    4.0, 1.6, 2.5, 1.0
	},
	{
	    4.0, 2.0, 3.0, 1.0
	}
    },
    {
	{
	    5.0, 4.0, 2.0, 1.0
	},
	{
	    5.0, 4.0, 2.5, 1.0
	},
	{
	    5.0, 4.0, 3.0, 1.0
	}
    },
    {
	{
	    6.0, 5.0, 2.0, 1.0
	},
	{
	    6.0, 5.0, 2.5, 1.0
	},
	{
	    6.0, 5.0, 3.0, 1.0
	}
    },
    {
	{
	    SQRT_TWO*6.0, SQRT_TWO*6.0, SQRT_TWO*2.0, SQRT_TWO
	},
	{
	    SQRT_TWO*6.0, SQRT_TWO*6.0, SQRT_TWO*2.5, SQRT_TWO
	},
	{
	    SQRT_TWO*6.0, SQRT_TWO*6.0, SQRT_TWO*3.0, SQRT_TWO
	}  
    },
    {
	{
	    5.2, 6.7, 2.0, 1.0
	},
	{
	    5.2, 6.7, 2.5, 1.0
	},
	{
	    5.2, 6.7, 3.0, 1.0
	}
    },
    {
	{
	    SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*2.0, SQRT_TWO
	},
	{
	    SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*2.5, SQRT_TWO
	}, 
	{
	    SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*3.0, SQRT_TWO
	}  
    }, 
    {
	{
	    4.0, 5.2, 2.0, 1.0
	},
	{
	    4.0, 4.6, 2.5, 1.0
	},
	{
	    4.0, 5.2, 3.0, 1.0
	}  
    },
    {
	{
	    SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*2.0, SQRT_TWO
	},
	{
	    SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*2.5, SQRT_TWO
	},
	{
	    SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*3.0, SQRT_TWO
	}  
    },
    {
	{
	    2.8, 6.7, 2.0, 1.0
	},
	{
	    2.8, 6.7, 2.5, 1.0
	},
	{
	    2.8, 6.7, 3.0, 1.0
	}   
    },
    {
	{
	    SQRT_TWO*2.0, SQRT_TWO*6.0, SQRT_TWO*2.0, SQRT_TWO
	},
	{
	    SQRT_TWO*2.0, SQRT_TWO*6.0, SQRT_TWO*2.5, SQRT_TWO
	},
	{
	    SQRT_TWO*2.0, SQRT_TWO*6.0, SQRT_TWO*3.0, SQRT_TWO
	}  
    },
    {
	{
	    2.0, 5.0, 2.0, 1.0
	},
	{
	    2.0, 5.0, 2.5, 1.0
	},
	{
	    2.0, 5.0, 3.0, 1.0
	} 
    },
    {
	{
	    3.0, 4.0, 2.0, 1.0
	},
	{
	    3.0, 4.0, 2.5, 1.0
	},
	{
	    3.0, 4.0, 3.0, 1.0
	} 
    },
    {
	{
	    4.0, 2.0, 2.0, 1.0
	},
	{
	    4.0, 1.6, 2.5, 1.0
	},
	{
	    4.0, 2.0, 3.0, 1.0
	}    
    }
};
GLUnurbsObj *theNurbs;


static void ErrorCallback(GLenum which)
{

    if (which != expectedError) {
	fprintf(stderr, "Unexpected error occured (%d):\n", which);
	fprintf(stderr, "    %s\n", gluErrorString(which));
    }
}

static void Init(void)
{

    theNurbs = gluNewNurbsRenderer();
    gluNurbsCallback(theNurbs, GLU_ERROR, ErrorCallback);

    gluNurbsProperty(theNurbs, GLU_SAMPLING_TOLERANCE, 15.0);
    gluNurbsProperty(theNurbs, GLU_DISPLAY_MODE, GLU_OUTLINE_PATCH);

    expectedError = GLU_INVALID_ENUM;
    gluNurbsProperty(theNurbs, ~0, 15.0);
    expectedError = GLU_NURBS_ERROR13;
    gluEndSurface(theNurbs);
    expectedError = 0;

    glColor3f(1.0, 1.0, 1.0);
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-2.0, 2.0, -2.0, 2.0, 0.8, 10.0);
    gluLookAt(7.0, 4.5, 4.0, 4.5, 4.5, 2.5, 6.0, -3.0, 2.0);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_DOWN:
	rotX -= 5;
	break;
      case TK_UP:
	rotX += 5;
	break;
      case TK_LEFT:
	rotY -= 5;
	break;
      case TK_RIGHT:
	rotY += 5;
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT);

    glPushMatrix();

    glTranslatef(4.0, 4.5, 2.5);
    glRotatef(rotY, 1, 0, 0);
    glRotatef(rotX, 0, 1, 0);
    glTranslatef(-4.0, -4.5, -2.5);

    gluBeginSurface(theNurbs);
    gluNurbsSurface(theNurbs, S_NUMKNOTS, sknots, T_NUMKNOTS, tknots,
		    4*T_NUMPOINTS, 4, &ctlpoints[0][0][0], S_ORDER,
		    T_ORDER, GL_MAP2_VERTEX_4);
    gluEndSurface(theNurbs);

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    type = TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("NURBS Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tpoint.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


#define CI_RED TK_RED
#define CI_ANTI_ALIAS_GREEN 16
#define CI_ANTI_ALIAS_YELLOW 32
#define CI_ANTI_ALIAS_RED 48


GLenum rgb, doubleBuffer, directRender, windType;
GLint windW, windH;

GLenum mode;
GLint size;
float point[3] = {
    1.0, 1.0, 0.0
};


static void Init(void)
{
    GLint i;

    glClearColor(0.0, 0.0, 0.0, 0.0);

    glBlendFunc(GL_SRC_ALPHA, GL_ZERO);

    if (!rgb) {
	for (i = 0; i < 16; i++) {
	    tkSetOneColor(i+CI_ANTI_ALIAS_RED, i/15.0, 0.0, 0.0);
	    tkSetOneColor(i+CI_ANTI_ALIAS_YELLOW, i/15.0, i/15.0, 0.0);
	    tkSetOneColor(i+CI_ANTI_ALIAS_GREEN, 0.0, i/15.0, 0.0);
	}
    }

    mode = GL_FALSE;
    size = 1;
}

static void Reshape(int width, int height)
{

    windW = (GLint)width;
    windH = (GLint)height;

    glViewport(0, 0, width, height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-windW/2, windW/2, -windH/2, windH/2);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_1:
	mode = !mode;
	break;
      case TK_W:
	size++;
	break;
      case TK_w:
	size--;
	if (size < 1) {
	    size = 1;
	}
	break;
      case TK_LEFT:
	point[0] -= 0.25;
	break;
      case TK_RIGHT:
	point[0] += 0.25;
	break;
      case TK_UP:
	point[1] += 0.25;
	break;
      case TK_DOWN:
	point[1] -= 0.25;
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT);

    TK_SETCOLOR(windType, TK_YELLOW);
    glBegin(GL_LINE_STRIP);
	glVertex2f(-windW/2, 0);
	glVertex2f(windW/2, 0);
    glEnd();
    glBegin(GL_LINE_STRIP);
	glVertex2f(0, -windH/2);
	glVertex2f(0, windH/2);
    glEnd();

    if (mode) {
	glEnable(GL_BLEND);
	glEnable(GL_POINT_SMOOTH);
    } else {
	glDisable(GL_BLEND);
	glDisable(GL_POINT_SMOOTH);
    }

    glPointSize(size);
    if (mode) {
	(rgb) ? glColor3f(1.0, 0.0, 0.0) : glIndexf(CI_ANTI_ALIAS_RED);
    } else {
	(rgb) ? glColor3f(1.0, 0.0, 0.0) : glIndexf(CI_RED);
    }
    glBegin(GL_POINTS);
	glVertex3fv(point);
    glEnd();

    glDisable(GL_POINT_SMOOTH);

    glPointSize(1);
    TK_SETCOLOR(windType, TK_GREEN);
    glBegin(GL_POINTS);
	glVertex3fv(point);
    glEnd();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    windW = 300;
    windH = 300;
    tkInitPosition(0, 0, windW, windH);

    windType = (rgb) ? TK_RGB : TK_INDEX;
    windType |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    windType |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(windType);

    if (tkInitWindow("Point Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tprim.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
//#include <unistd.h>
#include <stdlib.h>
#include "tk.h"


#define PIXEL_CENTER(x) ((long)(x) + 0.5)

#define GAP 10
#define ROWS 3
#define COLS 4

#define OPENGL_WIDTH 48
#define OPENGL_HEIGHT 13


GLenum rgb, doubleBuffer, directRender, windType;
GLint windW, windH;

GLenum mode1, mode2;
GLint boxW, boxH;
GLubyte OpenGL_bits[] = {
   0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
   0x7f, 0xfb, 0xff, 0xff, 0xff, 0x01,
   0x7f, 0xfb, 0xff, 0xff, 0xff, 0x01, 
   0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
   0x3e, 0x8f, 0xb7, 0xf9, 0xfc, 0x01, 
   0x63, 0xdb, 0xb0, 0x8d, 0x0d, 0x00,
   0x63, 0xdb, 0xb7, 0x8d, 0x0d, 0x00, 
   0x63, 0xdb, 0xb6, 0x8d, 0x0d, 0x00,
   0x63, 0x8f, 0xf3, 0xcc, 0x0d, 0x00, 
   0x63, 0x00, 0x00, 0x0c, 0x4c, 0x0a,
   0x63, 0x00, 0x00, 0x0c, 0x4c, 0x0e, 
   0x63, 0x00, 0x00, 0x8c, 0xed, 0x0e,
   0x3e, 0x00, 0x00, 0xf8, 0x0c, 0x00, 
};


static void Init(void)
{

    mode1 = GL_TRUE;
    mode2 = GL_TRUE;
}

static void Reshape(int width, int height)
{

    windW = (GLint)width;
    windH = (GLint)height;
}

static void RotateColorMask(void)
{
    static GLint rotation = 0;
    
    rotation = (rotation + 1) & 0x3;
    switch (rotation) {
      case 0:
	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
	glIndexMask( 0xff );
	break;
      case 1:
	glColorMask(GL_FALSE, GL_TRUE, GL_TRUE, GL_TRUE);
	glIndexMask(0xFE);
	break;
      case 2:
	glColorMask(GL_TRUE, GL_FALSE, GL_TRUE, GL_TRUE);
	glIndexMask(0xFD);
	break;
      case 3:
	glColorMask(GL_TRUE, GL_TRUE, GL_FALSE, GL_TRUE);
	glIndexMask(0xEF);
	break;
    }
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_1:
	mode1 = !mode1;
	break;
      case TK_2:
	mode2 = !mode2;
	break;
      case TK_3:
	RotateColorMask();
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Viewport(GLint row, GLint column)
{
    GLint x, y;

    boxW = (windW - (COLS + 1) * GAP) / COLS;
    boxH = (windH - (ROWS + 1) * GAP) / ROWS;

    x = GAP + column * (boxW + GAP);
    y = GAP + row * (boxH + GAP);

    glViewport(x, y, boxW, boxH);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-boxW/2, boxW/2, -boxH/2, boxH/2, 0.0, 1.0);
    glMatrixMode(GL_MODELVIEW);

    glEnable(GL_SCISSOR_TEST);
    glScissor(x, y, boxW, boxH);
}

static void Point(void)
{
    GLint i;

    glBegin(GL_POINTS);
	TK_SETCOLOR(windType, TK_WHITE);
	glVertex2i(0, 0);
	for (i = 1; i < 8; i++) {
	    GLint j = i * 2;
	    TK_SETCOLOR(windType, i + TK_RED - 1);
	    glVertex2i(-j, -j);
	    glVertex2i(-j, 0);
	    glVertex2i(-j, j);
	    glVertex2i(0, j);
	    glVertex2i(j, j);
	    glVertex2i(j, 0);
	    glVertex2i(j, -j);
	    glVertex2i(0, -j);
	}
    glEnd();
}

static void Lines(void)
{
    GLint i;

    glPushMatrix();

    glTranslatef(-12, 0, 0);
    for (i = 1; i < 8; i++) {
	TK_SETCOLOR(windType, i + TK_RED - 1);
	glBegin(GL_LINES);
	    glVertex2i(-boxW/4, -boxH/4);
	    glVertex2i(boxW/4, boxH/4);
	glEnd();
	glTranslatef(4, 0, 0);
    }

    glPopMatrix();

    glBegin(GL_LINES);
	glVertex2i(0, 0);
    glEnd();
}

static void LineStrip(void)
{

    glBegin(GL_LINE_STRIP);
	TK_SETCOLOR(windType, TK_RED);
	glVertex2f(PIXEL_CENTER(-boxW/4), PIXEL_CENTER(-boxH/4));
	TK_SETCOLOR(windType, TK_GREEN);
	glVertex2f(PIXEL_CENTER(-boxW/4), PIXEL_CENTER(boxH/4));
	TK_SETCOLOR(windType, TK_BLUE);
	glVertex2f(PIXEL_CENTER(boxW/4), PIXEL_CENTER(boxH/4));
	TK_SETCOLOR(windType, TK_WHITE);
	glVertex2f(PIXEL_CENTER(boxW/4), PIXEL_CENTER(-boxH/4));
    glEnd();

    glBegin(GL_LINE_STRIP);
	glVertex2i(0, 0);
    glEnd();
}

static void LineLoop(void)
{

    glBegin(GL_LINE_LOOP);
	TK_SETCOLOR(windType, TK_RED);
	glVertex2f(PIXEL_CENTER(-boxW/4), PIXEL_CENTER(-boxH/4));
	TK_SETCOLOR(windType, TK_GREEN);
	glVertex2f(PIXEL_CENTER(-boxW/4), PIXEL_CENTER(boxH/4));
	TK_SETCOLOR(windType, TK_BLUE);
	glVertex2f(PIXEL_CENTER(boxW/4), PIXEL_CENTER(boxH/4));
	TK_SETCOLOR(windType, TK_WHITE);
	glVertex2f(PIXEL_CENTER(boxW/4), PIXEL_CENTER(-boxH/4));
    glEnd();

    glEnable(GL_LOGIC_OP);
    glLogicOp(GL_XOR);

    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);

    TK_SETCOLOR(windType, TK_MAGENTA);
    glBegin(GL_LINE_LOOP);
	glVertex2f(PIXEL_CENTER(-boxW/8), PIXEL_CENTER(-boxH/8));
	glVertex2f(PIXEL_CENTER(-boxW/8), PIXEL_CENTER(boxH/8));
    glEnd();
    glBegin(GL_LINE_LOOP);
	glVertex2f(PIXEL_CENTER(-boxW/8), PIXEL_CENTER(boxH/8+5));
	glVertex2f(PIXEL_CENTER(boxW/8), PIXEL_CENTER(boxH/8+5));
    glEnd();
    glDisable(GL_LOGIC_OP);
    glDisable(GL_BLEND);

    TK_SETCOLOR(windType, TK_GREEN);
    glBegin(GL_POINTS);
	glVertex2i(0, 0);
    glEnd();

    glBegin(GL_LINE_LOOP);
	glVertex2i(0, 0);
    glEnd();
}

static void Bitmap(void)
{

    glBegin(GL_LINES);
	TK_SETCOLOR(windType, TK_GREEN);
	glVertex2i(-boxW/2, 0);
	glVertex2i(boxW/2, 0);
	glVertex2i(0, -boxH/2);
	glVertex2i(0, boxH/2);
	TK_SETCOLOR(windType, TK_RED);
	glVertex2i(0, -3);
	glVertex2i(0, -3+OPENGL_HEIGHT);
	TK_SETCOLOR(windType, TK_BLUE);
	glVertex2i(0, -3);
	glVertex2i(OPENGL_WIDTH, -3);
    glEnd();

    TK_SETCOLOR(windType, TK_GREEN);

    glPixelStorei(GL_UNPACK_LSB_FIRST, GL_TRUE);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    glRasterPos2i(0, 0);
    glBitmap(OPENGL_WIDTH, OPENGL_HEIGHT, 0, 3, 0.0, 0.0, OpenGL_bits);
}

static void Triangles(void)
{

    glBegin(GL_TRIANGLES);
	TK_SETCOLOR(windType, TK_GREEN);
	glVertex2i(-boxW/4, -boxH/4);
	TK_SETCOLOR(windType, TK_RED);
	glVertex2i(-boxW/8, -boxH/16);
	TK_SETCOLOR(windType, TK_BLUE);
	glVertex2i(boxW/8, -boxH/16);

	TK_SETCOLOR(windType, TK_GREEN);
	glVertex2i(-boxW/4, boxH/4);
	TK_SETCOLOR(windType, TK_RED);
	glVertex2i(-boxW/8, boxH/16);
	TK_SETCOLOR(windType, TK_BLUE);
	glVertex2i(boxW/8, boxH/16);
    glEnd();

    glBegin(GL_TRIANGLES);
	glVertex2i(0, 0);
	glVertex2i(-100, 100);
    glEnd();
}

static void TriangleStrip(void)
{

    glBegin(GL_TRIANGLE_STRIP);
	TK_SETCOLOR(windType, TK_GREEN);
	glVertex2i(-boxW/4, -boxH/4);
	TK_SETCOLOR(windType, TK_RED);
	glVertex2i(-boxW/4, boxH/4);
	TK_SETCOLOR(windType, TK_BLUE);
	glVertex2i(0, -boxH/4);
	TK_SETCOLOR(windType, TK_WHITE);
	glVertex2i(0, boxH/4);
	TK_SETCOLOR(windType, TK_CYAN);
	glVertex2i(boxW/4, -boxH/4);
	TK_SETCOLOR(windType, TK_YELLOW);
	glVertex2i(boxW/4, boxH/4);
    glEnd();

    glBegin(GL_TRIANGLE_STRIP);
	glVertex2i(0, 0);
	glVertex2i(-100, 100);
    glEnd();
}

static void TriangleFan(void)
{
    GLint vx[8][2];
    GLint x0, y0, x1, y1, x2, y2, x3, y3;
    GLint i;

    y0 = -boxH/4;
    y1 = y0 + boxH/2/3;
    y2 = y1 + boxH/2/3;
    y3 = boxH/4;
    x0 = -boxW/4;
    x1 = x0 + boxW/2/3;
    x2 = x1 + boxW/2/3;
    x3 = boxW/4;

    vx[0][0] = x0; vx[0][1] = y1;
    vx[1][0] = x0; vx[1][1] = y2;
    vx[2][0] = x1; vx[2][1] = y3;
    vx[3][0] = x2; vx[3][1] = y3;
    vx[4][0] = x3; vx[4][1] = y2;
    vx[5][0] = x3; vx[5][1] = y1;
    vx[6][0] = x2; vx[6][1] = y0;
    vx[7][0] = x1; vx[7][1] = y0;

    glBegin(GL_TRIANGLE_FAN);
	TK_SETCOLOR(windType, TK_WHITE);
	glVertex2i(0, 0);
	for (i = 0; i < 8; i++) {
	    TK_SETCOLOR(windType, TK_WHITE-i);
	    glVertex2iv(vx[i]);
	}
    glEnd();

    glBegin(GL_TRIANGLE_FAN);
	glVertex2i(0, 0);
	glVertex2i(-100, 100);
    glEnd();
}

static void Rect(void)
{

    TK_SETCOLOR(windType, TK_GREEN);
    glRecti(-boxW/4, -boxH/4, boxW/4, boxH/4);
}

static void tprimPolygon(void)
{
    GLint vx[8][2];
    GLint x0, y0, x1, y1, x2, y2, x3, y3;
    GLint i;

    y0 = -boxH/4;
    y1 = y0 + boxH/2/3;
    y2 = y1 + boxH/2/3;
    y3 = boxH/4;
    x0 = -boxW/4;
    x1 = x0 + boxW/2/3;
    x2 = x1 + boxW/2/3;
    x3 = boxW/4;

    vx[0][0] = x0; vx[0][1] = y1;
    vx[1][0] = x0; vx[1][1] = y2;
    vx[2][0] = x1; vx[2][1] = y3;
    vx[3][0] = x2; vx[3][1] = y3;
    vx[4][0] = x3; vx[4][1] = y2;
    vx[5][0] = x3; vx[5][1] = y1;
    vx[6][0] = x2; vx[6][1] = y0;
    vx[7][0] = x1; vx[7][1] = y0;

    glBegin(GL_POLYGON);
	for (i = 0; i < 8; i++) {
	    TK_SETCOLOR(windType, TK_WHITE-i);
	    glVertex2iv(vx[i]);
	}
    glEnd();

    glBegin(GL_POLYGON);
	glVertex2i(0, 0);
	glVertex2i(100, 100);
    glEnd();
}

static void Quads(void)
{

    glBegin(GL_QUADS);
	TK_SETCOLOR(windType, TK_GREEN);
	glVertex2i(-boxW/4, -boxH/4);
	TK_SETCOLOR(windType, TK_RED);
	glVertex2i(-boxW/8, -boxH/16);
	TK_SETCOLOR(windType, TK_BLUE);
	glVertex2i(boxW/8, -boxH/16);
	TK_SETCOLOR(windType, TK_WHITE);
	glVertex2i(boxW/4, -boxH/4);

	TK_SETCOLOR(windType, TK_GREEN);
	glVertex2i(-boxW/4, boxH/4);
	TK_SETCOLOR(windType, TK_RED);
	glVertex2i(-boxW/8, boxH/16);
	TK_SETCOLOR(windType, TK_BLUE);
	glVertex2i(boxW/8, boxH/16);
	TK_SETCOLOR(windType, TK_WHITE);
	glVertex2i(boxW/4, boxH/4);
    glEnd();

    glBegin(GL_QUADS);
	glVertex2i(0, 0);
	glVertex2i(100, 100);
	glVertex2i(-100, 100);
    glEnd();
}

static void QuadStrip(void)
{

    glBegin(GL_QUAD_STRIP);
	TK_SETCOLOR(windType, TK_GREEN);
	glVertex2i(-boxW/4, -boxH/4);
	TK_SETCOLOR(windType, TK_RED);
	glVertex2i(-boxW/4, boxH/4);
	TK_SETCOLOR(windType, TK_BLUE);
	glVertex2i(0, -boxH/4);
	TK_SETCOLOR(windType, TK_WHITE);
	glVertex2i(0, boxH/4);
	TK_SETCOLOR(windType, TK_CYAN);
	glVertex2i(boxW/4, -boxH/4);
	TK_SETCOLOR(windType, TK_YELLOW);
	glVertex2i(boxW/4, boxH/4);
    glEnd();

    glBegin(GL_QUAD_STRIP);
	glVertex2i(0, 0);
	glVertex2i(100, 100);
	glVertex2i(-100, 100);
    glEnd();
}

static void Draw(void)
{

    glViewport(0, 0, windW, windH);
    glDisable(GL_SCISSOR_TEST);

    glPushAttrib(GL_COLOR_BUFFER_BIT);

    glColorMask(1, 1, 1, 1);
    glIndexMask(~0);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    glPopAttrib();

    if (mode1) {
	glShadeModel(GL_SMOOTH);
    } else {
	glShadeModel(GL_FLAT);
    }

    if (mode2) {
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    } else {
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    }

    Viewport(0, 0); Point();
    Viewport(0, 1); Lines();
    Viewport(0, 2); LineStrip();
    Viewport(0, 3); LineLoop();

    Viewport(1, 0); Bitmap();

    Viewport(1, 1); TriangleFan();
    Viewport(1, 2); Triangles();
    Viewport(1, 3); TriangleStrip();

    Viewport(2, 0); Rect();
    Viewport(2, 1); tprimPolygon();
    Viewport(2, 2); Quads();
    Viewport(2, 3); QuadStrip();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    windW = 600;
    windH = 300;
    tkInitPosition(0, 0, windW, windH);

    windType = (rgb) ? TK_RGB : TK_INDEX;
    windType |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    windType |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(windType);

    if (tkInitWindow("Primitive Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tolympic.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#ifdef __unix 
#include <sys/time.h>
#else
#include <stdlib.h>
#include <time.h>
#endif
#include "tk.h"


#ifdef __unix
extern double drand48(void);
extern void srand48(long seedval);
#endif


#define XSIZE	100
#define YSIZE	75

#define RINGS 5
#define BLUERING 0
#define BLACKRING 1
#define REDRING 2
#define YELLOWRING 3
#define GREENRING 4

#define BACKGROUND 8

enum {
    BLACK = 0,
    RED,
    GREEN,
    YELLOW,
    BLUE,
    MAGENTA,
    CYAN,
    WHITE
};


typedef short Point[2];


GLenum rgb, doubleBuffer, directRender;

unsigned char rgb_colors[RINGS][3];
int mapped_colors[RINGS];
float dests[RINGS][3];
float offsets[RINGS][3];
float angs[RINGS];
float rotAxis[RINGS][3];
int iters[RINGS];
GLuint theTorus;


void FillTorus(float rc, int numc, float rt, int numt)
{
    int i, j, k;
    double s, t;
    double x, y, z;
    double pi, twopi;

    pi = 3.14159265358979323846;
    twopi = 2 * pi;
 
    for (i = 0; i < numc; i++) {
	glBegin(GL_QUAD_STRIP);
        for (j = 0; j <= numt; j++) {
	    for (k = 1; k >= 0; k--) {
		s = (i + k) % numc + 0.5;
		t = j % numt;

		x = cos(t*twopi/numt) * cos(s*twopi/numc);
		y = sin(t*twopi/numt) * cos(s*twopi/numc);
		z = sin(s*twopi/numc);
		glNormal3f(x, y, z);

		x = (rt + rc * cos(s*twopi/numc)) * cos(t*twopi/numt);
		y = (rt + rc * cos(s*twopi/numc)) * sin(t*twopi/numt);
		z = rc * sin(s*twopi/numc);
		glVertex3f(x, y, z);
	    }
        }
	glEnd();
    }
}

float Clamp(int iters_left, float t)
{

    if (iters_left < 3) {
	return 0.0;
    }
    return (iters_left-2)*t/iters_left;
}

void DrawScene(void)
{
    int i, j;

    for (i = 0; i < RINGS; i++) {
	if (iters[i]) {
	    for (j = 0; j < 3; j++) {
		offsets[i][j] = Clamp(iters[i], offsets[i][j]);
	    }
	    angs[i] = Clamp(iters[i], angs[i]);
	    iters[i]--;
	}
    }

    glPushMatrix();
    
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    gluLookAt(0,0,10, 0,0,0, 0,1,0);

    for (i = 0; i < RINGS; i++) {
	if (rgb) {
	    glColor3ubv(rgb_colors[i]);
	} else {
	    glIndexi(mapped_colors[i]);
	}
	glPushMatrix();
	glTranslatef(dests[i][0]+offsets[i][0], dests[i][1]+offsets[i][1],
		     dests[i][2]+offsets[i][2]);
	glRotatef(angs[i], rotAxis[i][0], rotAxis[i][1], rotAxis[i][2]);
	glCallList(theTorus);
	glPopMatrix();
    }

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

float MyRand(void)
{
#ifdef __unix
    return 10.0 * (drand48() - 0.5);
#else
    return 10.0 * ( ((float) rand())/((float) RAND_MAX) - 0.5);
#endif
}

void ReInit(void)
{
    int i;
    float deviation;

    deviation = MyRand() / 2;
    deviation = deviation * deviation;
    for (i = 0; i < RINGS; i++) {
	offsets[i][0] = MyRand();
	offsets[i][1] = MyRand();
	offsets[i][2] = MyRand();
	angs[i] = 260.0 * MyRand();
	rotAxis[i][0] = MyRand();
	rotAxis[i][1] = MyRand();
	rotAxis[i][2] = MyRand();
	iters[i] = (deviation * MyRand() + 60.0);
    }
}

void Init(void)
{
    int gid;
    float base, height;
    float aspect, x, y;
    int i;
#ifdef __unix 
    struct timeval t;
    struct timezone tz;
#else
    time_t timer, timerr;
#endif
    float sc = 10;
    float top_y = 1.0;
    float bottom_y = 0.0;
    float top_z = 0.15;
    float bottom_z = 0.69;
    float spacing = 2.5;
    static float lmodel_ambient[] = {0.0, 0.0, 0.0, 0.0};
    static float lmodel_twoside[] = {GL_FALSE};
    static float lmodel_local[] = {GL_FALSE};
    static float light0_ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float light0_diffuse[] = {1.0, 1.0, 1.0, 0.0};
    static float light0_position[] = {0.8660254, 0.5, 1, 0};
    static float light0_specular[] = {1.0, 1.0, 1.0, 0.0};
    static float bevel_mat_ambient[] = {0.0, 0.0, 0.0, 1.0};
    static float bevel_mat_shininess[] = {40.0};
    static float bevel_mat_specular[] = {1.0, 1.0, 1.0, 0.0};
    static float bevel_mat_diffuse[] = {1.0, 0.0, 0.0, 0.0};

#ifdef __unix 
    gettimeofday(&t, &tz);
    srand48(t.tv_usec);
#else
    time( &timer );
    srand( timer );
#endif
    ReInit();
    for (i = 0; i < RINGS; i++) {
	rgb_colors[i][0] = rgb_colors[i][1] = rgb_colors[i][2] = 0;
    }
    rgb_colors[BLUERING][2] = 255;
    rgb_colors[REDRING][0] = 255;
    rgb_colors[GREENRING][1] = 255;
    rgb_colors[YELLOWRING][0] = 255;
    rgb_colors[YELLOWRING][1] = 255;
    mapped_colors[BLUERING] = BLUE;
    mapped_colors[REDRING] = RED;
    mapped_colors[GREENRING] = GREEN;
    mapped_colors[YELLOWRING] = YELLOW;
    mapped_colors[BLACKRING] = BLACK;

    dests[BLUERING][0] = -spacing;
    dests[BLUERING][1] = top_y;
    dests[BLUERING][2] = top_z;

    dests[BLACKRING][0] = 0.0;
    dests[BLACKRING][1] = top_y;
    dests[BLACKRING][2] = top_z;

    dests[REDRING][0] = spacing;
    dests[REDRING][1] = top_y;
    dests[REDRING][2] = top_z;

    dests[YELLOWRING][0] = -spacing / 2.0;
    dests[YELLOWRING][1] = bottom_y;
    dests[YELLOWRING][2] = bottom_z;

    dests[GREENRING][0] = spacing / 2.0;
    dests[GREENRING][1] = bottom_y;
    dests[GREENRING][2] = bottom_z;

    base = 2.0; 
    height = 2.0;
    theTorus = glGenLists(1);
    glNewList(theTorus, GL_COMPILE);
    FillTorus(0.1, 8, 1.0, 25);
    glEndList();

    x = (float)XSIZE;
    y = (float)YSIZE;
    aspect = x / y;
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    glClearDepth(1.0);

    if (rgb) {
	glClearColor(0.5, 0.5, 0.5, 0.0);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
	glEnable(GL_LIGHT0);

	glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, lmodel_local);
	glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
	glEnable(GL_LIGHTING);

	glMaterialfv(GL_FRONT, GL_AMBIENT, bevel_mat_ambient);
	glMaterialfv(GL_FRONT, GL_SHININESS, bevel_mat_shininess);
	glMaterialfv(GL_FRONT, GL_SPECULAR, bevel_mat_specular);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, bevel_mat_diffuse);

	glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
	glEnable(GL_COLOR_MATERIAL);
	glShadeModel(GL_SMOOTH);
    } else {
	glClearIndex(BACKGROUND);
	glShadeModel(GL_FLAT);
    }

    glMatrixMode(GL_PROJECTION);
    gluPerspective(45, 1.33, 0.1, 100.0);
    glMatrixMode(GL_MODELVIEW);
}

void Reshape(int width, int height)
{

    glViewport(0, 0, width, height);
}

GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_SPACE:
	ReInit();
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_TRUE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(10, 30, 400, 300);

    type = (rgb) ? TK_RGB : TK_INDEX;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    type |= TK_DEPTH16;
    tkInitDisplayMode(type);

    if (tkInitWindow("Olympic") == GL_FALSE) {
        tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkIdleFunc(DrawScene);

    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tselect.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include "tk.h"


#define MAXOBJS 10000
#define MAXSELECT 100
#define MAXFEED 300
#define	SOLID 1
#define	LINE 2
#define	POINT 3


GLenum directRender;
GLint windW, windH;

GLuint selectBuf[MAXSELECT];
GLfloat feedBuf[MAXFEED];
GLint vp[4];
float zRotation = 90.0;
float zoom = 1.0;
GLint objectCount;
GLint numObjects;
struct object {
    float v1[2];
    float v2[2];
    float v3[2];
    float color[3];
} objects[MAXOBJS];
GLenum linePoly = GL_FALSE;


static void InitObjects(GLint num)
{
    GLint i;
    float x, y;

    if (num > MAXOBJS) {
	num = MAXOBJS;
    }
    if (num < 1) {
	num = 1;
    }
    objectCount = num;

    srand((unsigned int)time(NULL));
    for (i = 0; i < num; i++) {
	x = (rand() % 300) - 150;
	y = (rand() % 300) - 150;

	objects[i].v1[0] = x + (rand() % 50) - 25;
	objects[i].v2[0] = x + (rand() % 50) - 25;
	objects[i].v3[0] = x + (rand() % 50) - 25;
	objects[i].v1[1] = y + (rand() % 50) - 25;
	objects[i].v2[1] = y + (rand() % 50) - 25;
	objects[i].v3[1] = y + (rand() % 50) - 25;
	objects[i].color[0] = ((rand() % 100) + 50) / 150.0;
	objects[i].color[1] = ((rand() % 100) + 50) / 150.0;
	objects[i].color[2] = ((rand() % 100) + 50) / 150.0;
    }
}

static void Init(void)
{

    numObjects = 10;
    InitObjects(numObjects);
    glGetIntegerv(GL_VIEWPORT, vp);
}

static void Reshape(int width, int height)
{

    windW = (GLint)width;
    windH = (GLint)height;
}

static void Render(GLenum mode)
{
    GLint i;

    for (i = 0; i < objectCount; i++) {
	if (mode == GL_SELECT) {
	    glLoadName(i);
	}
	glColor3fv(objects[i].color);
	glBegin(GL_POLYGON);
	    glVertex2fv(objects[i].v1);
	    glVertex2fv(objects[i].v2);
	    glVertex2fv(objects[i].v3);
	glEnd();
    }
}

static GLint DoSelect(GLint x, GLint y)
{
    GLint hits;

    glSelectBuffer(MAXSELECT, selectBuf);
    (void)glRenderMode(GL_SELECT);
    glInitNames();
    glPushName(~0);

    glPushMatrix();

    glViewport(0, 0, windW, windH);
    glGetIntegerv(GL_VIEWPORT, vp);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPickMatrix(x, windH-y, 4, 4, vp);
    gluOrtho2D(-175, 175, -175, 175);
    glMatrixMode(GL_MODELVIEW);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    glScalef(zoom, zoom, zoom);
    glRotatef(zRotation, 0, 0, 1);

    Render(GL_SELECT);

    glPopMatrix();
    
    hits = glRenderMode(GL_RENDER); 
    if (hits <= 0) {
	return -1;
    }

    return selectBuf[(hits-1)*4+3];
}

static void RecolorTri(GLint h)
{

    objects[h].color[0] = ((rand() % 100) + 50) / 150.0;
    objects[h].color[1] = ((rand() % 100) + 50) / 150.0;
    objects[h].color[2] = ((rand() % 100) + 50) / 150.0;
}

static void DeleteTri(GLint h)
{

    objects[h] = objects[objectCount-1];
    objectCount--;
}

static void GrowTri(GLint h)
{
    float v[2];
    float *oldV;
    GLint i;

    v[0] = objects[h].v1[0] + objects[h].v2[0] + objects[h].v3[0];
    v[1] = objects[h].v1[1] + objects[h].v2[1] + objects[h].v3[1];
    v[0] /= 3;
    v[1] /= 3;

    for (i = 0; i < 3; i++) {
	switch (i) {
	  case 0:
	    oldV = objects[h].v1;
	    break;
	  case 1:
	    oldV = objects[h].v2;
	    break;
	  case 2:
	    oldV = objects[h].v3;
	    break;
	}
	oldV[0] = 1.5 * (oldV[0] - v[0]) + v[0];
	oldV[1] = 1.5 * (oldV[1] - v[1]) + v[1];
    }
}

static GLenum Mouse(int mouseX, int mouseY, GLenum button)
{
    GLint hit;

    hit = DoSelect((GLint)mouseX, (GLint)mouseY);
    if (hit != -1) {
	if (button & TK_LEFTBUTTON) {
	    RecolorTri(hit);
	}
	if (button & TK_MIDDLEBUTTON) {
	    GrowTri(hit);
	}
	if (button & TK_RIGHTBUTTON) {
	    DeleteTri(hit);
	}
	return GL_TRUE;
    }
    return GL_FALSE;
}

static void Draw(void)
{

    glPushMatrix();

    glViewport(0, 0, windW, windH);
    glGetIntegerv(GL_VIEWPORT, vp);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-175, 175, -175, 175);
    glMatrixMode(GL_MODELVIEW);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    glScalef(zoom, zoom, zoom);
    glRotatef(zRotation, 0, 0, 1);

    Render(GL_RENDER);

    glPopMatrix();

    glFlush();
}

static void DrawZoom(GLint x, GLint y)
{

    glPushMatrix();

    glViewport(0, 0, windW, windH);
    glGetIntegerv(GL_VIEWPORT, vp);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPickMatrix(x, windH-y, 4, 4, vp);
    gluOrtho2D(-175, 175, -175, 175);
    glMatrixMode(GL_MODELVIEW);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    glScalef(zoom, zoom, zoom);
    glRotatef(zRotation, 0, 0, 1);

    Render(GL_RENDER);

    glPopMatrix();
}

static void DumpFeedbackVert(GLint *i, GLint n)
{
    GLint index;

    index = *i;
    if (index+7 > n) {
	*i = n;
	printf("  ???\n");
	return;
    }
    printf("  (%g %g %g), color = (%4.2f %4.2f %4.2f)\n",
	   feedBuf[index],
	   feedBuf[index+1],
	   feedBuf[index+2],
	   feedBuf[index+3],
	   feedBuf[index+4],
	   feedBuf[index+5]);
    index += 7;
    *i = index;
}

static void DrawFeedback(GLint n)
{
    GLint i;
    GLint verts;

    printf("Feedback results (%d floats):\n", n);
    for (i = 0; i < n; i++) {
	switch ((GLint)feedBuf[i]) {
	  case GL_POLYGON_TOKEN:
	    printf("Polygon");
	    i++;
	    if (i < n) {
		verts = (GLint)feedBuf[i];
		i++;
		printf(": %d vertices", verts);
	    } else {
		verts = 0;
	    }
	    printf("\n");
	    while (verts) {
		DumpFeedbackVert(&i, n);
		verts--;
	    }
	    i--;
	    break;
	  case GL_LINE_TOKEN:
	    printf("Line:\n");
	    i++;
	    DumpFeedbackVert(&i, n);
	    DumpFeedbackVert(&i, n);
	    i--;
	    break;
	  case GL_LINE_RESET_TOKEN:
	    printf("Line Reset:\n");
	    i++;
	    DumpFeedbackVert(&i, n);
	    DumpFeedbackVert(&i, n);
	    i--;
	    break;
	  default:
	    printf("%9.2f\n", feedBuf[i]);
	    break;
	}
    }
    if (i == MAXFEED) {
	printf("...\n");
    }
    printf("\n");
}

static void DoFeedback(void) 
{
    GLint x;

    glFeedbackBuffer(MAXFEED, GL_3D_COLOR, feedBuf);
    (void)glRenderMode(GL_FEEDBACK);

    glPushMatrix();

    glViewport(0, 0, windW, windH);
    glGetIntegerv(GL_VIEWPORT, vp);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-175, 175, -175, 175);
    glMatrixMode(GL_MODELVIEW);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    glScalef(zoom, zoom, zoom);
    glRotatef(zRotation, 0, 0, 1);

    Render(GL_FEEDBACK);

    glPopMatrix();
    
    x = glRenderMode(GL_RENDER); 
    if (x == -1) {
	x = MAXFEED;
    }

    DrawFeedback((GLint)x);
}

static GLenum Key(int key, GLenum mask)
{
    int mouseX, mouseY;

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_LEFT:
	zRotation += 0.5;
	break;
      case TK_RIGHT:
	zRotation -= 0.5;
	break;
      case TK_Z:
	zoom /= 0.75;
	break;
      case TK_z:
	zoom *= 0.75;
	break;
      case TK_f:
	DoFeedback();
	break;
      case TK_d:
	tkGetMouseLoc(&mouseX, &mouseY);
	DrawZoom((GLint)mouseX, (GLint)mouseY);
	break;
      case TK_l:
	linePoly = !linePoly;
	if (linePoly) {
	    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	} else {
	    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	}
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    windW = 300;
    windH = 300;
    tkInitPosition(0, 0, windW, windH);

    type = TK_RGB | TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Select Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkMouseDownFunc(Mouse);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tsphere.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include "tk.h"


// Fix math definitions
#define	cosf	cos
#define sinf	sin

#define FALSE 0
#define TRUE  1
#define PI    3.14159265358979323846


GLenum doubleBuffer, directRender;
int W = 400, H = 400;

char *imageFileName = 0;
TK_RGBImageRec *image;

int numComponents;

float *minFilter, *magFilter, *sWrapMode, *tWrapMode;
float decal[] = {GL_DECAL};
float modulate[] = {GL_MODULATE};
float repeat[] = {GL_REPEAT};
float clamp[] = {GL_CLAMP};
float nearest[] = {GL_NEAREST};
float linear[] = {GL_LINEAR};
float nearest_mipmap_nearest[] = {GL_NEAREST_MIPMAP_NEAREST};
float nearest_mipmap_linear[] = {GL_NEAREST_MIPMAP_LINEAR};
float linear_mipmap_nearest[] = {GL_LINEAR_MIPMAP_NEAREST};
float linear_mipmap_linear[] = {GL_LINEAR_MIPMAP_LINEAR};
GLint sphereMap[] = {GL_SPHERE_MAP};

float xRotation = 0.0, yRotation = 0.0;
float zTranslate = -4.0;
GLenum autoRotate = TRUE;
GLenum deepestColor = TK_GREEN;
GLenum isLit = TRUE;
GLenum isFogged = FALSE;
float *textureEnvironment = modulate;

struct MipMap {
    int width, height;
    unsigned char *data;
};

int cube, cage, cylinder, torus, genericObject;

float c[6][4][4][3] = {
    {
	{
	    {
		1.0, 1.0, -1.0
	    }, 
	    {
		0.0, 1.0, -1.0
	    },
	    {
		0.0, 0.0, -1.0
	    },
	    {
		1.0, 0.0, -1.0
	    },
	},
	{
	    {
		0.0, 1.0, -1.0
	    },
	    {
		-1.0, 1.0, -1.0
	    }, 
	    {
		-1.0, 0.0, -1.0
	    }, 
	    {
		0.0, 0.0, -1.0
	    },
	},
	{
	    {
		0.0,  0.0, -1.0
	    },
	    {
		-1.0, 0.0, -1.0
	    },
	    {
		-1.0, -1.0, -1.0
	    },
	    {
		0.0, -1.0, -1.0
	    },
	},
	{
	    {
		1.0, 0.0, -1.0
	    },
	    {
		0.0, 0.0, -1.0
	    },
	    {
		0.0, -1.0, -1.0
	    },
	    {
		1.0, -1.0, -1.0
	    },
	},
    },
    {
	{
	    {
		1.0, 1.0, 1.0
	    },
	    {
		1.0, 1.0, 0.0
	    },
	    {
		1.0, 0.0, 0.0
	    },
	    {
		1.0, 0.0, 1.0
	    },
	},
	{
	    {
		1.0, 1.0, 0.0
	    },
	    {
		1.0, 1.0, -1.0
	    },
	    {
		1.0, 0.0, -1.0
	    },
	    {
		1.0, 0.0, 0.0
	    },
	},
	{
	    {
		1.0, 0.0, -1.0
	    },
	    {
		1.0, -1.0, -1.0
	    },
	    {
		1.0, -1.0, 0.0
	    },
	    {
		1.0, 0.0, 0.0
	    },
	},
	{
	    {
		1.0, 0.0, 0.0
	    },
	    {
		1.0, -1.0, 0.0
	    },
	    {
		1.0, -1.0, 1.0
	    },
	    {
		1.0, 0.0, 1.0
	    },
	},
    },
    {
	{
	    {
		-1.0, 1.0, 1.0
	    },
	    {
		0.0, 1.0, 1.0
	    },
	    {
		0.0, 0.0, 1.0
	    },
	    {
		-1.0, 0.0, 1.0
	    },
	},
	{
	    {
		0.0, 1.0, 1.0
	    },
	    {
		1.0, 1.0, 1.0
	    },
	    {
		1.0, 0.0, 1.0
	    },
	    {
		0.0, 0.0, 1.0
	    },
	},
	{
	    {
		1.0, 0.0, 1.0
	    },
	    {
		1.0, -1.0, 1.0
	    },
	    {
		0.0, -1.0, 1.0
	    },
	    {
		0.0, 0.0, 1.0
	    },
	},
	{
	    {
		0.0, -1.0, 1.0
	    },
	    {
		-1.0, -1.0, 1.0
	    },
	    {
		-1.0, 0.0, 1.0
	    },
	    {
		0.0, 0.0, 1.0
	    },
	},
    },
    {
	{
	    {
		-1.0, 1.0, -1.0
	    },
	    {
		-1.0, 1.0, 0.0
	    },
	    {
		-1.0, 0.0, 0.0
	    },
	    {
		-1.0, 0.0, -1.0
	    },
	}, 
	{
	    {
		-1.0, 1.0, 0.0
	    },
	    {
		-1.0, 1.0, 1.0
	    },
	    {
		-1.0, 0.0, 1.0
	    },
	    {
		-1.0, 0.0, 0.0
	    },
	}, 
	{
	    {
		-1.0, 0.0, 1.0
	    },
	    {
		-1.0, -1.0, 1.0
	    },
	    {
		-1.0, -1.0, 0.0
	    },
	    {
		-1.0, 0.0, 0.0
	    },
	}, 
	{
	    {
		-1.0, -1.0, 0.0
	    },
	    {
		-1.0, -1.0, -1.0
	    },
	    {
		-1.0, 0.0, -1.0
	    },
	    {
		-1.0, 0.0, 0.0
	    },
	}, 
    },
    {
	{
	    {
		-1.0, 1.0, 1.0
	    },
	    {
		-1.0, 1.0, 0.0
	    },
	    {
		0.0, 1.0, 0.0
	    },
	    {
		0.0, 1.0, 1.0
	    },
	},
	{
	    {
		-1.0, 1.0, 0.0
	    },
	    {
		-1.0, 1.0, -1.0
	    },
	    {
		0.0, 1.0, -1.0
	    },
	    {
		0.0, 1.0, 0.0
	    },
	},
	{
	    {
		0.0, 1.0, -1.0
	    },
	    {
		1.0, 1.0, -1.0
	    },
	    {
		1.0, 1.0, 0.0
	    },
	    {
		0.0, 1.0, 0.0
	    },
	},
	{
	    {
		1.0, 1.0, 0.0
	    },
	    {
		1.0, 1.0, 1.0
	    },
	    {
		0.0, 1.0, 1.0
	    },
	    {
		0.0, 1.0, 0.0
	    },
	},
    },
    {
	{
	    {
		-1.0, -1.0, -1.0
	    },
	    {
		-1.0, -1.0, 0.0
	    },
	    {
		0.0, -1.0, 0.0
	    },
	    {
		0.0, -1.0, -1.0
	    },
	},
	{
	    {
		-1.0, -1.0, 0.0
	    },
	    {
		-1.0, -1.0, 1.0
	    },
	    {
		0.0, -1.0, 1.0
	    },
	    {
		0.0, -1.0, 0.0
	    },
	},
	{
	    {
		0.0, -1.0, 1.0
	    },
	    {
		1.0, -1.0, 1.0
	    },
	    {
		1.0, -1.0, 0.0
	    },
	    {
		0.0, -1.0, 0.0
	    },
	},
	{
	    {
		1.0, -1.0, 0.0
	    },
	    {
		1.0, -1.0, -1.0
	    },
	    {
		0.0, -1.0, -1.0
	    },
	    {
		0.0, -1.0, 0.0
	    },
	},
    }
};

float n[6][3] = {
    {
	0.0, 0.0, -1.0
    },
    {
	1.0, 0.0, 0.0
    },
    {
	0.0, 0.0, 1.0
    },
    {
	-1.0, 0.0, 0.0
    },
    {
	0.0, 1.0, 0.0
    },
    {
	0.0, -1.0, 0.0
    }
};

GLfloat identity[16] = {
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1,
};


void BuildCylinder(int numEdges)
{
    int i, top = 1.0, bottom = -1.0;
    float x[100], y[100], angle; 
    
    for (i = 0; i <= numEdges; i++) {
	angle = i * 2.0 * PI / numEdges;
	x[i] = cosf(angle);
	y[i] = sinf(angle);
    }

    glNewList(cylinder, GL_COMPILE);
    glBegin(GL_TRIANGLE_STRIP);
	for (i = 0; i <= numEdges; i++) {
	    glNormal3f(x[i], y[i], 0.0);
	    glVertex3f(x[i], y[i], bottom);
	    glVertex3f(x[i], y[i], top);
	}
    glEnd();
    glBegin(GL_TRIANGLE_FAN);
	glNormal3f(0.0, 0.0, 1.0);
	glVertex3f(0.0, 0.0, top);
	for (i = 0; i <= numEdges; i++) {
	    glVertex3f(x[i], -y[i], top);
	}
    glEnd();
    glBegin(GL_TRIANGLE_FAN);
	glNormal3f(0.0, 0.0, -1.0);
	glVertex3f(0.0, 0.0, bottom);
	for (i = 0; i <= numEdges; i++) {
	    glVertex3f(x[i], y[i], bottom);
	}
    glEnd();
    glEndList();
}

void BuildTorus(float rc, int numc, float rt, int numt)
{
    int i, j, k;
    double s, t;
    double x, y, z;
    double pi, twopi;

    pi = 3.14159265358979323846;
    twopi = 2.0 * pi;
 
    glNewList(torus, GL_COMPILE);
    for (i = 0; i < numc; i++) {
	glBegin(GL_QUAD_STRIP);
        for (j = 0; j <= numt; j++) {
	    for (k = 0; k <= 1; k++) {
		s = (i + k) % numc + 0.5;
		t = j % numt;

		x = cos(t*twopi/numt) * cos(s*twopi/numc);
		y = sin(t*twopi/numt) * cos(s*twopi/numc);
		z = sin(s*twopi/numc);
		glNormal3f(x, y, z);

		x = (rt + rc * cos(s*twopi/numc)) * cos(t*twopi/numt);
		y = (rt + rc * cos(s*twopi/numc)) * sin(t*twopi/numt);
		z = rc * sin(s*twopi/numc);
		glVertex3f(x, y, z);
	    }
        }
	glEnd();
    }
    glEndList();
}

void BuildCage(void)
{
    int i, j;
    float inc;
    float right, left, top, bottom, front, back;

    front  = 0.0;
    back   = -8.0;

    left   = -4.0;
    bottom = -4.0;
    right  = 4.0;
    top    = 4.0; 

    inc = 2.0 * 4.0 * 0.1;

    glNewList(cage, GL_COMPILE);
    for (i = 0; i < 10; i++) {

	/*
	** Back
	*/
	glBegin(GL_LINES);
	    glVertex3f(left+i*inc, top,    back);
	    glVertex3f(left+i*inc, bottom, back);
	glEnd();
	glBegin(GL_LINES);
	    glVertex3f(right, bottom+i*inc, back);
	    glVertex3f(left,  bottom+i*inc, back);
	glEnd();

	/*
	** Front
	*/
	glBegin(GL_LINES);
	    glVertex3f(left+i*inc, top,    front);
	    glVertex3f(left+i*inc, bottom, front);
	glEnd();
	glBegin(GL_LINES);
	    glVertex3f(right, bottom+i*inc, front);
	    glVertex3f(left,  bottom+i*inc, front);
	glEnd();

	/*
	** Left
	*/
	glBegin(GL_LINES);
	    glVertex3f(left, bottom+i*inc, front);
	    glVertex3f(left, bottom+i*inc, back);
	glEnd();
	glBegin(GL_LINES);
	    glVertex3f(left, top,    back+i*inc);
	    glVertex3f(left, bottom, back+i*inc);
	glEnd();

	/*
	** Right
	*/
	glBegin(GL_LINES);
	    glVertex3f(right, top-i*inc, front);
	    glVertex3f(right, top-i*inc, back);
	glEnd();
	glBegin(GL_LINES);
	    glVertex3f(right, top,    back+i*inc);
	    glVertex3f(right, bottom, back+i*inc);
	glEnd();

	/*
	** Top
	*/
	glBegin(GL_LINES);
	    glVertex3f(left+i*inc, top, front);
	    glVertex3f(left+i*inc, top, back);
	glEnd();
	glBegin(GL_LINES);
	    glVertex3f(right, top, back+i*inc);
	    glVertex3f(left,  top, back+i*inc);
	glEnd();

	/*
	** Bottom
	*/
	glBegin(GL_LINES);
	    glVertex3f(right-i*inc, bottom, front);
	    glVertex3f(right-i*inc, bottom, back);
	glEnd();
	glBegin(GL_LINES);
	    glVertex3f(right, bottom, back+i*inc);
	    glVertex3f(left,  bottom, back+i*inc);
	glEnd();
    }
    glEndList();
}

void BuildCube(void)
{
    int i, j;

    glNewList(cube, GL_COMPILE);
    for (i = 0; i < 6; i++) {
	for (j = 0; j < 4; j++) {
	    glNormal3fv(n[i]); 
	    glBegin(GL_POLYGON);
		glVertex3fv(c[i][j][0]);
		glVertex3fv(c[i][j][1]);
		glVertex3fv(c[i][j][2]);
		glVertex3fv(c[i][j][3]);
	    glEnd();
	}
    }
    glEndList();
}

void BuildLists(void)
{

    cube = glGenLists(1);
    BuildCube();

    cage = glGenLists(2);
    BuildCage();

    cylinder = glGenLists(3);
    BuildCylinder(60);

    torus = glGenLists(4);
    BuildTorus(0.65, 20, .85, 65);

    genericObject = torus;
}

void SetDeepestColor(void)
{
    int redBits, greenBits, blueBits;

    glGetIntegerv(GL_RED_BITS, &redBits);
    glGetIntegerv(GL_GREEN_BITS, &greenBits);
    glGetIntegerv(GL_BLUE_BITS, &blueBits);

    deepestColor = (redBits >= greenBits) ? TK_RED : TK_GREEN;
    deepestColor = (deepestColor >= blueBits) ? deepestColor : TK_BLUE; 
}

void SetDefaultSettings(void)
{

    magFilter = nearest;
    minFilter = nearest;
    sWrapMode = repeat;
    tWrapMode = repeat;
    textureEnvironment = modulate;
    autoRotate = TRUE;
}

unsigned char *AlphaPadImage(int bufSize, unsigned char *inData, int alpha)
{
    unsigned char *outData, *out_ptr, *in_ptr;
    int i;

    outData = malloc(bufSize * 4);
    out_ptr = outData;
    in_ptr = inData;

    for (i = 0; i < bufSize; i++) {
	*out_ptr++ = *in_ptr++;
	*out_ptr++ = *in_ptr++;
	*out_ptr++ = *in_ptr++;
	*out_ptr++ = alpha;
    }

    free (inData);
    return outData;
}

void Init(void)
{
    float ambient[] = {0.0, 0.0, 0.0, 1.0};
    float diffuse[] = {0.0, 1.0, 0.0, 1.0};
    float specular[] = {1.0, 1.0, 1.0, 1.0};
    float position[] = {2.0, 2.0,  0.0, 1.0};
    float fog_color[] = {0.0, 0.0, 0.0, 1.0};
    float mat_ambient[] = {0.0, 0.0, 0.0, 1.0};
    float mat_shininess[] = {90.0};
    float mat_specular[] = {1.0, 1.0, 1.0, 1.0};
    float mat_diffuse[] = {1.0, 1.0, 1.0, 1.0};
    float lmodel_ambient[] = {0.0, 0.0, 0.0, 1.0};
    float lmodel_twoside[] = {GL_TRUE};
    float lmodel_local_viewer[] = {GL_FALSE};

    SetDeepestColor();
    SetDefaultSettings();

    if (numComponents == 4) {
	image = tkRGBImageLoad(imageFileName);
	image->data = AlphaPadImage(image->sizeX*image->sizeY,
                                    image->data, 128);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	gluBuild2DMipmaps(GL_TEXTURE_2D, numComponents, 
			  image->sizeX, image->sizeY, 
			  GL_RGBA, GL_UNSIGNED_BYTE, image->data);
    } else {
	image = tkRGBImageLoad(imageFileName);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	gluBuild2DMipmaps(GL_TEXTURE_2D, numComponents, 
			  image->sizeX, image->sizeY, 
			  GL_RGB, GL_UNSIGNED_BYTE, image->data);
    }
    
    glFogf(GL_FOG_DENSITY, 0.125);
    glFogi(GL_FOG_MODE, GL_LINEAR);
    glFogf(GL_FOG_START, 4.0);
    glFogf(GL_FOG_END, 9.0);
    glFogfv(GL_FOG_COLOR, fog_color);

    glDepthFunc(GL_LEQUAL);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, specular);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, mat_ambient);

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
    glShadeModel(GL_SMOOTH);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glViewport(0, 0, W, H);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);

    glFrontFace(GL_CW);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);

    glEnable(GL_TEXTURE_2D);
    glTexGeniv(GL_S, GL_TEXTURE_GEN_MODE, sphereMap);
    glTexGeniv(GL_T, GL_TEXTURE_GEN_MODE, sphereMap);
    glEnable(GL_TEXTURE_GEN_S);
    glEnable(GL_TEXTURE_GEN_T);

    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, tWrapMode);

    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, textureEnvironment);

    BuildLists();
}

void ReInit(void)
{

    if (genericObject == torus) {
	glEnable(GL_DEPTH_TEST);
    } else  {
	glDisable(GL_DEPTH_TEST);
    }
    if (isFogged) {
	textureEnvironment = modulate;
    }

    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, textureEnvironment);
}

void Draw(void)
{

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-0.2, 0.2, -0.2, 0.2, 0.15, 9.0);
    glMatrixMode(GL_MODELVIEW);

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    if (isFogged) {
	glEnable(GL_FOG);
	glColor3fv(tkRGBMap[deepestColor]);
    } else {
	glColor3fv(tkRGBMap[TK_WHITE]);
    }
    glDisable(GL_LIGHTING);
    glDisable(GL_LIGHT0);
    glDisable(GL_TEXTURE_2D);
    glCallList(cage);

    glPushMatrix();
    glTranslatef(0.0, 0.0, zTranslate);
    glRotatef(xRotation, 1, 0, 0);
    glRotatef(yRotation, 0, 1, 0);

    if (isLit == TRUE) {
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
    }

    glEnable(GL_TEXTURE_2D);
    if (isFogged) {
	glDisable(GL_FOG);
    }
    glPolygonMode(GL_FRONT, GL_FILL);
    glColor3fv(tkRGBMap[deepestColor]);
    glCallList(genericObject);

    glPopMatrix();
    glFlush();

    if (autoRotate) {
	xRotation += .75;
	yRotation += .375;
    } 
    tkSwapBuffers();
}

void Reshape(int width, int height)
{

    W = width;
    H = height;
    ReInit();
}

GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	free(image->data);
	tkQuit();

      case TK_LEFT:
	yRotation -= 0.5;
	autoRotate = FALSE;
	ReInit();
	break;
      case TK_RIGHT:
	yRotation += 0.5;
	autoRotate = FALSE;
	ReInit();
	break;
      case TK_UP:
	xRotation -= 0.5;
	autoRotate = FALSE;
	ReInit();
	break;
      case TK_DOWN:
	xRotation += 0.5;
	autoRotate = FALSE;
	ReInit();
	break;
      case TK_a:
	autoRotate = !autoRotate;
	ReInit();
	break;
      case TK_c:
	genericObject = (genericObject == cube) ? cylinder : cube;
	ReInit();
	break;
      case TK_d:
	textureEnvironment = decal;
	ReInit();
	break;
      case TK_m:
	textureEnvironment = modulate;
	ReInit();
	break;
      case TK_l:
	isLit = !isLit;
	ReInit();
	break;
      case TK_f:
	isFogged = !isFogged;
	ReInit();
	break;
      case TK_t:
	genericObject = torus;
	ReInit();
	break;
      case TK_0:
	magFilter = nearest;
	ReInit();
	break;
      case TK_1:
	magFilter = linear;
	ReInit();
	break;
      case TK_2:
	minFilter = nearest;
	ReInit();
	break;
      case TK_3:
	minFilter = linear;
	ReInit();
	break;
      case TK_4:
	minFilter = nearest_mipmap_nearest;
	ReInit();
	break;
      case TK_5:
	minFilter = nearest_mipmap_linear;
	ReInit();
	break;
      case TK_6:
	minFilter = linear_mipmap_nearest;
	ReInit();
	break;
      case TK_7:
	minFilter = linear_mipmap_linear;
	ReInit();
	break;

      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;
    numComponents = 4;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-f") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-f (No file name).\n");
		return GL_FALSE;
	    } else {
		imageFileName = argv[++i];
	    }
	} else if (strcmp(argv[i], "-4") == 0) {
	    numComponents = 4;
	} else if (strcmp(argv[i], "-3") == 0) {
	    numComponents = 3;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    if (imageFileName == 0) {
	printf("No image file.\n");
	tkQuit();
    }

    tkInitPosition(0, 0, W, H);

    type = TK_RGB | TK_DEPTH16;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Texture Test") == GL_FALSE) {
        tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkIdleFunc(Draw);

    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tspeed.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
//#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#include "tk.h"

#ifdef __unix
#include <sys/times.h>
#include <sys/param.h>
#else
#include <sys\types.h>
#include <sys\timeb.h>
#endif


#define GAP 10
#define ROWS 1
#define COLS 4


GLenum rgb, doubleBuffer, directRender, windType;
GLint windW, windH;

GLint boxW, boxH;

GLenum antialiasing = GL_FALSE;
GLenum depthTesting = GL_FALSE;
GLenum fogging = GL_FALSE, niceFogging = GL_FALSE;
GLenum lighting = GL_FALSE;
GLenum shading = GL_FALSE;
GLenum texturing = GL_FALSE;

// mf: change these to more reasonable numbers
GLint repeatCount = 300;
GLint loopCount = 10;

GLubyte texture[4*3] = {
    0xFF, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0xFF, 0,
};


static void SetWindSize(int width, int height)
{

    windW = (GLint)width;
    windH = (GLint)height;
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_a:
	antialiasing = !antialiasing;
	break;
      case TK_d:
	depthTesting = !depthTesting;
	break;
      case TK_f:
	fogging = !fogging;
	break;
      case TK_F:
	niceFogging = !niceFogging;
	break;
      case TK_l:
	lighting = !lighting;
	break;
      case TK_s:
	shading = !shading;
	break;
      case TK_t:
	texturing = !texturing;
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Viewport(GLint row, GLint column)
{
    GLint x, y;

    boxW = (windW - (COLS + 1) * GAP) / COLS;
    boxH = (windH - (ROWS + 1) * GAP) / ROWS;

    x = GAP + column * (boxW + GAP);
    y = GAP + row * (boxH + GAP);

    glViewport(x, y, boxW, boxH);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-boxW/2, boxW/2, -boxH/2, boxH/2);
    glMatrixMode(GL_MODELVIEW);

    glEnable(GL_SCISSOR_TEST);
    glScissor(x, y, boxW, boxH);
}

static double Now(void)
{
#ifdef __unix
    struct tms tm;
    clock_t clk;

    clk = times(&tm);
    return (double)clk / (double)HZ;
#else
    struct _timeb tm;

    _ftime( &tm );
    return (tm.time + tm.millitm/1000.0);
#endif
}

static void Report(const char *msg, float elapsed)
{

    if (elapsed == 0.0) {
	printf("%s per second: Unknown, elapsed time is zero\n", msg);
    } else {
	printf("%s per second: %g\n", msg, repeatCount*loopCount/elapsed);
    }
}

static void Points(void)
{
    GLint i, j;
    float v1[3];
    double start;

    start = Now();
    for (i = 0; i < repeatCount; i++) {
	v1[0] = 10;
	v1[1] = 10;
	v1[2] = 10;
	glBegin(GL_POINTS);
	    for (j = 0; j < loopCount; j++) {
		glVertex2fv(v1);
	    }
	glEnd();
    }
    glFinish();
    Report("Points", Now()-start);
}

static void Lines(void)
{
    GLint i, j;
    float v1[3], v2[3];
    double start;

    start = Now();
    for (i = 0; i < repeatCount; i++) {
	v1[0] = 10;
	v1[1] = 10;
	v1[2] = 10;
	v2[0] = 20;
	v2[1] = 20;
	v2[2] = 10;
	glBegin(GL_LINES);
	    for (j = 0; j < loopCount; j++) {
		glVertex2fv(v1);
		glVertex2fv(v2);
	    }
	glEnd();
    }
    glFinish();
    Report("Lines", Now()-start);
}

static void Triangles(void)
{
    GLint i, j;
    float v1[3], v2[3], v3[3], t1[2], t2[2], t3[2];
    double start;

    start = Now();

    v1[0] = 10;
    v1[1] = 10;
    v1[2] = 10;
    v2[0] = 20;
    v2[1] = 20;
    v2[2] = 10;
    v3[0] = 10;
    v3[1] = 20;
    v3[2] = 10;

    t1[0] = 0;
    t1[1] = 0;
    t2[0] = 1;
    t2[1] = 1;
    t3[0] = 0;
    t3[1] = 1;

    for (i = 0; i < repeatCount; i++) {
	glBegin(GL_TRIANGLES);
	    for (j = 0; j < loopCount; j++) {
		if (texturing) {
		    glTexCoord2fv(t1);
		}
		glVertex2fv(v1);
		if (texturing) {
		    glTexCoord2fv(t2);
		}
		glVertex2fv(v2);
		if (texturing) {
		    glTexCoord2fv(t3);
		}
		glVertex2fv(v3);
	    }
	glEnd();
    }
    glFinish();
    Report("Triangles", Now()-start);
}

static void Rects(void)
{
    GLint i, j;
    float v1[2], v2[2];
    double start;

    start = Now();
    for (i = 0; i < repeatCount; i++) {
	v1[0] = 10;
	v1[1] = 10;
	v2[0] = 20;
	v2[1] = 20;
	for (j = 0; j < loopCount; j++) {
	    glRectfv(v1, v2);
	}
    }
    glFinish();
    Report("Rects", Now()-start);
}

static void Draw(void)
{

    glDisable(GL_SCISSOR_TEST);
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    TK_SETCOLOR(windType, TK_YELLOW);

    if (antialiasing) {
	glBlendFunc(GL_SRC_ALPHA, GL_ZERO);
	glEnable(GL_BLEND);

	glEnable(GL_POINT_SMOOTH);
	glEnable(GL_LINE_SMOOTH);
	glEnable(GL_POLYGON_SMOOTH);
    }
    if (depthTesting) {
	glEnable(GL_DEPTH_TEST);
    }
    if (fogging) {
	glEnable(GL_FOG);
	glHint(GL_FOG_HINT, (niceFogging) ? GL_NICEST : GL_FASTEST);
    }
    if (lighting) {
	static GLfloat ambient[4] = {1, 0.5, 0.5, 0};

	glEnable(GL_NORMALIZE);
	glNormal3f(1.0, 1.0, 1.0);
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambient);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
    }
    (shading) ? glShadeModel(GL_SMOOTH) : glShadeModel(GL_FLAT);
    if (texturing) {
	static GLfloat modulate[1] = {GL_DECAL};
	static GLfloat clamp[1] = {GL_CLAMP};
	static GLfloat linear[1] = {GL_LINEAR};

	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexImage2D(GL_TEXTURE_2D, 0, 3, 2, 2, 0, GL_RGB, GL_UNSIGNED_BYTE,
		     (GLvoid *)texture);
	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, modulate);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, clamp);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, clamp);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, linear);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, linear);
	glEnable(GL_TEXTURE_2D);
    }

    Viewport(0, 0); Points();
    Viewport(0, 1); Lines();
    Viewport(0, 2); Triangles();
    Viewport(0, 3); Rects();
    printf( "\n" );

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    windW = 600;
    windH = 300;
    tkInitPosition(0, 0, windW, windH);

    windType = TK_DEPTH16;
    windType |= (rgb) ? TK_RGB : TK_INDEX;
    windType |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    windType |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(windType);

    if (tkInitWindow("Speed Test") == GL_FALSE) {
	tkQuit();
    }

    tkExposeFunc(SetWindSize);
    tkReshapeFunc(SetWindSize);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tstar.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include "windows.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include "GL/gl.h"
#include "GL/glu.h"
#include "tk.h"


#define PI 3.141592657

enum {
    NORMAL = 0,
    WEIRD = 1
};

enum {
    STREAK = 0,
    CIRCLE = 1
};

#define MAXSTARS 400
#define MAXPOS 10000
#define MAXWARP 10
#define MAXANGLES 6000


typedef struct _starRec {
    GLint type;
    float x[2], y[2], z[2];
    float offsetX, offsetY, offsetR, rotation;
} starRec;


GLenum doubleBuffer, directRender;
GLint windW, windH;

GLenum flag = NORMAL;
GLint starCount = MAXSTARS / 2;
float speed = 1.0;
GLint nitro = 0;
starRec stars[MAXSTARS];
float sinTable[MAXANGLES];


float Sin(float angle)
{

    return (sinTable[(GLint)angle]);
}

float Cos(float angle)
{

    return (sinTable[((GLint)angle+(MAXANGLES/4))%MAXANGLES]);
}

void NewStar(GLint n, GLint d)
{

    if (rand()%4 == 0) {
	stars[n].type = CIRCLE;
    } else {
	stars[n].type = STREAK;
    }
    stars[n].x[0] = (float)(rand() % MAXPOS - MAXPOS / 2);
    stars[n].y[0] = (float)(rand() % MAXPOS - MAXPOS / 2);
    stars[n].z[0] = (float)(rand() % MAXPOS + d);
    if (rand()%4 == 0 && flag == WEIRD) {
	stars[n].offsetX = (float)(rand() % 100 - 100 / 2);
	stars[n].offsetY = (float)(rand() % 100 - 100 / 2);
	stars[n].offsetR = (float)(rand() % 25 - 25 / 2);
    } else {
	stars[n].offsetX = 0.0;
	stars[n].offsetY = 0.0;
	stars[n].offsetR = 0.0;
    }
}

void RotatePoint(float *x, float *y, float rotation)
{
    float tmpX, tmpY;

    tmpX = *x * Cos(rotation) - *y * Sin(rotation);
    tmpY = *y * Cos(rotation) + *x * Sin(rotation);
    *x = tmpX;
    *y = tmpY;
}

void MoveStars(void)
{
    float offset;
    GLint n;

    offset = speed * 60.0;

    for (n = 0; n < starCount; n++) {
	stars[n].x[1] = stars[n].x[0];
	stars[n].y[1] = stars[n].y[0];
	stars[n].z[1] = stars[n].z[0];
	stars[n].x[0] += stars[n].offsetX;
	stars[n].y[0] += stars[n].offsetY;
	stars[n].z[0] -= offset;
        stars[n].rotation += stars[n].offsetR;
        if (stars[n].rotation > MAXANGLES) {
            stars[n].rotation = 0.0;
	}
    }
}

GLenum StarPoint(GLint n)
{
    float x0, y0, x1, y1, width;
    GLint i;

    x0 = stars[n].x[0] * windW / stars[n].z[0];
    y0 = stars[n].y[0] * windH / stars[n].z[0];
    RotatePoint(&x0, &y0, stars[n].rotation);
    x0 += windW / 2.0;
    y0 += windH / 2.0;

    if (x0 >= 0.0 && x0 < windW && y0 >= 0.0 && y0 < windH) {
	if (stars[n].type == STREAK) {
	    x1 = stars[n].x[1] * windW / stars[n].z[1];
	    y1 = stars[n].y[1] * windH / stars[n].z[1];
	    RotatePoint(&x1, &y1, stars[n].rotation);
	    x1 += windW / 2.0;
	    y1 += windH / 2.0;

	    glLineWidth(MAXPOS/100.0/stars[n].z[0]+1.0);
	    glColor3f(1.0, (MAXWARP-speed)/MAXWARP, (MAXWARP-speed)/MAXWARP);
	    if (fabs(x0-x1) < 1.0 && fabs(y0-y1) < 1.0) {
		glBegin(GL_POINTS);
		    glVertex2f(x0, y0);
		glEnd();
	    } else {
		glBegin(GL_LINES);
		    glVertex2f(x0, y0);
		    glVertex2f(x1, y1);
		glEnd();
	    }
	} else {
	    width = MAXPOS / 10.0 / stars[n].z[0] + 1.0;
	    glColor3f(1.0, 0.0, 0.0);
	    glBegin(GL_POLYGON);
		for (i = 0; i < 8; i++) {
		    float x = x0 + width * Cos((float)i*MAXANGLES/8.0);
		    float y = y0 + width * Sin((float)i*MAXANGLES/8.0);
		    glVertex2f(x, y);
		};
	    glEnd();
	}
	return GL_TRUE;
    } else {
	return GL_FALSE;
    }
}

void ShowStars(void)
{
    GLint n;

    glClear(GL_COLOR_BUFFER_BIT);

    for (n = 0; n < starCount; n++) {
	if (stars[n].z[0] > speed || (stars[n].z[0] > 0.0 && speed < MAXWARP)) {
	    if (StarPoint(n) == GL_FALSE) {
		NewStar(n, MAXPOS);
	    }
	} else {
	    NewStar(n, MAXPOS);
	}
    }
}

static void Init(void)
{
    float angle;
    GLint n;

    srand((unsigned int)time(NULL));

    for (n = 0; n < MAXSTARS; n++) {
	NewStar(n, 100);
    }

    angle = 0.0;
    for (n = 0; n < MAXANGLES ; n++) {
	sinTable[n] = sin(angle);
        angle += PI / (MAXANGLES / 2.0);
    }

    glClearColor(0.0, 0.0, 0.0, 0.0);

    glDisable(GL_DITHER);
}

void Reshape(int width, int height)
{

    windW = (GLint)width;
    windH = (GLint)height;

    glViewport(0, 0, windW, windH);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-0.5, windW+0.5, -0.5, windH+0.5);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_SPACE:
	flag = (flag == NORMAL) ? WEIRD : NORMAL;
	break;
      case TK_t:
	nitro = 1;
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

void Idle(void)
{

    MoveStars();
    ShowStars();
    if (nitro > 0) {
	speed = (float)(nitro / 10) + 1.0;
	if (speed > MAXWARP) {
	    speed = MAXWARP;
	}
	if (++nitro > MAXWARP*10) {
	    nitro = -nitro;
	}
    } else if (nitro < 0) {
	nitro++;
	speed = (float)(-nitro / 10) + 1.0;
	if (speed > MAXWARP) {
	    speed = MAXWARP;
	}
    }

    glFlush();
    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    windW = 300;
    windH = 300;
    tkInitPosition(0, 0, 300, 300);

    type = TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Stars") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkIdleFunc(Idle);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tquad.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


#define PI 3.141592654
#define	BLACK 0
#define	GRAY 128
#define	WHITE 255
#define RD 0xA40000FF
#define WT 0xFFFFFFFF
#define	brickImageWidth 16
#define	brickImageHeight 16


GLenum rgb, doubleBuffer, directRender;

float black[3] = {
    0.0, 0.0, 0.0
};
float blue[3] =  {
    0.0, 0.0, 1.0
};
float gray[3] =  {
    0.5, 0.5, 0.5
};
float white[3] = {
    1.0, 1.0, 1.0
};

GLenum doDither = GL_TRUE;
GLenum shade = GL_TRUE;
// mf
GLenum texture = GL_FALSE;

float xRotation = 30.0, yRotation = 30.0, zRotation = 0.0;
GLint radius1, radius2;
GLdouble angle1, angle2;
GLint slices, stacks;
GLint height;
GLint orientation = GLU_OUTSIDE;
GLint whichQuadric;
GLUquadricObj *quadObj;

GLuint brickImage[brickImageWidth*brickImageHeight] = {
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT,
    RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD
};
char *texFileName = 0;


static void ErrorHandler(GLenum which)
{

    fprintf(stderr, "Quad Error: %s\n", gluErrorString(which));
}

static void Init(void)
{
    static GLint colorIndexes[3] = {0, 200, 255};
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {0.5, 1.0, 1.0, 1.0};
    static float position[] = {90.0, 90.0, 150.0, 0.0};
    static float front_mat_shininess[] = {30.0};
    static float front_mat_specular[] = {0.2, 0.2, 0.2, 1.0};
    static float front_mat_diffuse[] = {0.5, 0.28, 0.38, 1.0};
    static float back_mat_shininess[] = {50.0};
    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0};
    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0};
    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0};
    static float lmodel_twoside[] = {GL_TRUE};
    static float decal[] = {GL_DECAL};
    static float modulate[] = {GL_MODULATE};
    static float repeat[] = {GL_REPEAT};
    static float nearest[] = {GL_NEAREST};
    TK_RGBImageRec *image;

    if (!rgb) {
	tkSetGreyRamp();
    }
    glClearColor(0.0, 0.0, 0.0, 0.0);
    
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glMaterialfv(GL_FRONT, GL_SHININESS, front_mat_shininess);
    glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_BACK, GL_SHININESS, back_mat_shininess);
    glMaterialfv(GL_BACK, GL_SPECULAR, back_mat_specular);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
    if (!rgb) {
	glMaterialiv( GL_FRONT_AND_BACK, GL_COLOR_INDEXES, colorIndexes);
    }

    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nearest);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nearest);
    if (texFileName) {
	image = tkRGBImageLoad(texFileName);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image->sizeX, image->sizeY,
			  GL_RGB, GL_UNSIGNED_BYTE, image->data);
    } else {
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexImage2D(GL_TEXTURE_2D, 0, 4, brickImageWidth, brickImageHeight,
		     0, GL_RGBA, GL_UNSIGNED_BYTE, (GLvoid *)brickImage);
    }

    quadObj = gluNewQuadric();
    gluQuadricCallback(quadObj, GLU_ERROR, ErrorHandler);

    radius1 = 10;
    radius2 = 5;
    angle1 = 90;
    angle2 = 180;
    slices = 16;
    stacks = 10;
    height = 20;
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1, 1, -1, 1, 1, 10);
    gluLookAt(2, 2, 2, 0, 0, 0, 0, 0, 1);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();

      case TK_LEFT:
	yRotation += 5;
	break;
      case TK_RIGHT:
	yRotation -= 5;
	break;
      case TK_UP:
	xRotation += 5;
	break;
      case TK_DOWN:
	xRotation -= 5;
	break;
      case TK_X:
	zRotation += 5;
	break;
      case TK_x:
	zRotation -= 5;
	break;

      case TK_1:
	gluQuadricDrawStyle(quadObj, GLU_FILL);
	break;
      case TK_2:
	gluQuadricDrawStyle(quadObj, GLU_POINT);
	break;
      case TK_3:
	gluQuadricDrawStyle(quadObj, GLU_LINE);
	break;
      case TK_4:
	gluQuadricDrawStyle(quadObj, GLU_SILHOUETTE);
	break;

      case TK_0:
	shade = !shade;
	if (shade) {
	    glShadeModel(GL_SMOOTH);
	    gluQuadricNormals(quadObj, GLU_SMOOTH);
	} else {
	    glShadeModel(GL_FLAT);
	    gluQuadricNormals(quadObj, GLU_FLAT);
	}
	break;

      case TK_A:
	stacks++;
	break;
      case TK_a:
	stacks--;
	break;
    
      case TK_S:
	slices++;
	break;
      case TK_s:
	slices--;
	break;

      case TK_d:
	switch(orientation) {
	  case GLU_OUTSIDE:
	    orientation = GLU_INSIDE;
	    break;
	  case GLU_INSIDE:
	  default:
	    orientation = GLU_OUTSIDE;
	    break;
	}
	gluQuadricOrientation(quadObj, orientation);
	break;

      case TK_f:
	whichQuadric = whichQuadric >= 3 ? 0 : whichQuadric + 1;
	break;

      case TK_G:
	radius1 += 1;
	break;
      case TK_g:
	radius1 -= 1;
	break;

      case TK_J:
	radius2 += 1;
	break;
      case TK_j:
	radius2 -= 1;
	break;

      case TK_H:
	height += 2;
	break;
      case TK_h:
	height -= 2;
	break;

      case TK_K:
	angle1 += 5;
	break;
      case TK_k:
	angle1 -= 5;
	break;

      case TK_L:
	angle2 += 5;
	break;
      case TK_l:
	angle2 -= 5;
	break;

      case TK_z:
        texture = !texture;
	if (texture) {
	    gluQuadricTexture(quadObj, GL_TRUE);
	    glEnable(GL_TEXTURE_2D);
	} else {
	    gluQuadricTexture(quadObj, GL_FALSE);
	    glDisable(GL_TEXTURE_2D);
	}
	break;

      case TK_q:
	glDisable(GL_CULL_FACE);
	break;
      case TK_w:
	glEnable(GL_CULL_FACE);
	glCullFace(GL_FRONT);
	break;
      case TK_e:
	glEnable(GL_CULL_FACE);
	glCullFace(GL_BACK);
	break;

      case TK_r:
	glFrontFace(GL_CW);
	break;
      case TK_t: 
	glFrontFace(GL_CCW);
	break;

      case TK_y:
	doDither = !doDither;
	(doDither) ? glEnable(GL_DITHER) : glDisable(GL_DITHER);
	break;

      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glLoadIdentity();
    glRotatef(xRotation, 1, 0, 0);
    glRotatef(yRotation, 0, 1, 0);
    glRotatef(zRotation, 0, 0, 1);

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    glColor3f(1.0, 1.0, 1.0);
    switch (whichQuadric) {
      case 0:
	glTranslatef(0, 0, -height/20.0);
	gluCylinder(quadObj, radius1/10.0, radius2/10.0, height/10.0, 
		    slices, stacks);
	break;
      case 1:
	gluSphere(quadObj, radius1/10.0, slices, stacks);
	break;
      case 2:
	gluPartialDisk(quadObj, radius2/10.0, radius1/10.0, slices, 
		       stacks, angle1, angle2);
	break;
      case 3:
	gluDisk(quadObj, radius2/10.0, radius1/10.0, slices, stacks);
	break;
    }

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-f") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-f (No file name).\n");
		return GL_FALSE;
	    } else {
		texFileName = argv[++i];
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    type = TK_DEPTH16;
    type |= (rgb) ? TK_RGB : TK_INDEX;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Quad Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tstencil.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "tk.h"


GLenum directRender;


static void Init(void)
{

    glClearColor(0.0, 0.0, 0.0, 0.0);

    glClearStencil(0);
    glStencilMask(1);
    glEnable(GL_STENCIL_TEST);
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-5.0, 5.0, -5.0, 5.0, -5.0, 5.0);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
    }
    return GL_FALSE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);

    glStencilFunc(GL_ALWAYS, 1, 1);
    glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);

    glColor3ub(200, 0, 0);
    glBegin(GL_POLYGON);        
	glVertex3i(-4, -4, 0);
	glVertex3i( 4, -4, 0);
	glVertex3i( 0,  4, 0);
    glEnd();

    glStencilFunc(GL_EQUAL, 1, 1);
    glStencilOp(GL_INCR, GL_KEEP, GL_DECR);

    glColor3ub(0, 200, 0);
    glBegin(GL_POLYGON);
	glVertex3i(3, 3, 0);
	glVertex3i(-3, 3, 0);
	glVertex3i(-3, -3, 0);
	glVertex3i(3, -3, 0);
    glEnd();

    glStencilFunc(GL_EQUAL, 1, 1);
    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);

    glColor3ub(0, 0, 200);
    glBegin(GL_POLYGON);
	glVertex3i(3, 3, 0);
	glVertex3i(-3, 3, 0);
	glVertex3i(-3, -3, 0);
	glVertex3i(3, -3, 0);
    glEnd();

    glFlush();
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(0, 0, 300, 300);

    type = TK_RGB | TK_SINGLE | TK_STENCIL;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Stencil Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\ttex2.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
//#include <unistd.h>
#include <math.h>
#include <time.h>
#include <sys\types.h>
#include <sys\timeb.h>
#include <stdlib.h>
#include "tk.h"


GLenum doubleBuffer, directRender;

char *texFileName = 0;
TK_RGBImageRec *image;

float *minFilter, *magFilter, *sWrapMode, *tWrapMode;
float decal[] = {GL_DECAL};
float modulate[] = {GL_MODULATE};
float repeat[] = {GL_REPEAT};
float clamp[] = {GL_CLAMP};
float nr[] = {GL_NEAREST};
float ln[] = {GL_LINEAR};
float nr_mipmap_nr[] = {GL_NEAREST_MIPMAP_NEAREST};
float nr_mipmap_ln[] = {GL_NEAREST_MIPMAP_LINEAR};
float ln_mipmap_nr[] = {GL_LINEAR_MIPMAP_NEAREST};
float ln_mipmap_ln[] = {GL_LINEAR_MIPMAP_LINEAR};
GLint sphereMap[] = {GL_SPHERE_MAP};

GLboolean displayFrameRate = GL_FALSE;
GLint frames, curFrame = 0, nextFrame = 0;
GLint frameCount = 0;
GLenum doDither = GL_TRUE;
GLenum doSphere = GL_FALSE;
float xRotation = 0.0, yRotation = 0.0, zTranslate = -3.125;

GLint cube;
float c[6][4][3] = {
    {
	{
	    1.0, 1.0, -1.0
	},
	{
	    -1.0, 1.0, -1.0
	},
	{
	    -1.0, -1.0, -1.0
	},
	{
	    1.0, -1.0, -1.0
	}
    },
    {
	{
	    1.0, 1.0, 1.0
	},
	{
	    1.0, 1.0, -1.0
	},
	{
	    1.0, -1.0, -1.0
	},
	{
	    1.0, -1.0, 1.0
	}
    },
    {
	{
	    -1.0, 1.0, 1.0
	},
	{
	    1.0, 1.0, 1.0
	},
	{
	    1.0, -1.0, 1.0
	},
	{
	    -1.0, -1.0, 1.0
	}
    },
    {
	{
	    -1.0, 1.0, -1.0
	},
	{
	    -1.0, 1.0, 1.0
	},
	{
	    -1.0, -1.0, 1.0
	},
	{
	    -1.0, -1.0, -1.0
	}
    },
    {
	{
	    -1.0, 1.0, 1.0
	},
	{
	    -1.0, 1.0, -1.0
	},
	{
	    1.0, 1.0, -1.0
	},
	{
	    1.0, 1.0, 1.0
	}
    },
    {
	{
	    -1.0, -1.0, -1.0
	},
	{
	    -1.0, -1.0, 1.0
	},
	{
	    1.0, -1.0, 1.0
	},
	{
	    1.0, -1.0, -1.0
	}
    }
};
static float n[6][3] = {
    {
	0.0, 0.0, -1.0
    },
    {
	1.0, 0.0, 0.0
    },
    {
	0.0, 0.0, 1.0
    },
    {
	-1.0, 0.0, 0.0
    },
    {
	0.0, 1.0, 0.0
    },
    {
	0.0, -1.0, 0.0
    }
};
static float t[6][4][2] = {
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    -0.1,  1.1
	},
	{
	    1.1, 1.1
	},
	{
	    1.1, -0.1
	},
	{
	    -0.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
};


static void BuildCube(void)
{
    GLint i;

    glNewList(cube, GL_COMPILE);
    for (i = 0; i < 6; i++) {
	glBegin(GL_POLYGON);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][0]); glVertex3fv(c[i][0]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][1]); glVertex3fv(c[i][1]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][2]); glVertex3fv(c[i][2]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][3]); glVertex3fv(c[i][3]);
	glEnd();
    }
    glEndList();
}

static void BuildLists(void)
{

    cube = glGenLists(1);
    BuildCube();
}

static void Init(void)
{


    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image->sizeX, image->sizeY,
		      GL_RGB, GL_UNSIGNED_BYTE, image->data);
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
    glEnable(GL_TEXTURE_2D);

    glFrontFace(GL_CCW);
    glCullFace(GL_FRONT);
    glEnable(GL_CULL_FACE);

    BuildLists();

    glClearColor(0.0, 0.0, 0.0, 0.0);

    magFilter = nr;
    minFilter = nr;
    sWrapMode = repeat;
    tWrapMode = repeat;
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
//    gluPerspective(145.0, 1.0, 0.01, 1000);
//    gluPerspective(90.0, 1.0, 0.01, 1000);
    glOrtho(-3.0, 3.0, -3.0, 3.0, -5.0, 5.0);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();

      case TK_LEFT:
	yRotation -= 0.5;
	break;
      case TK_RIGHT:
	yRotation += 0.5;
	break;
      case TK_UP:
	xRotation -= 0.5;
	break;
      case TK_DOWN:
	xRotation += 0.5;
	break;
      case TK_f:
	displayFrameRate = !displayFrameRate;
	frameCount = 0;
	break;
      case TK_d:
	doDither = !doDither;
	(doDither) ? glEnable(GL_DITHER) : glDisable(GL_DITHER);
	break;
      case TK_T:
	zTranslate += 0.25;
	break;
      case TK_t:
	zTranslate -= 0.25;
	break;

      case TK_s:
	doSphere = !doSphere;
	if (doSphere) {
	    glTexGeniv(GL_S, GL_TEXTURE_GEN_MODE, sphereMap);
	    glTexGeniv(GL_T, GL_TEXTURE_GEN_MODE, sphereMap);
	    glEnable(GL_TEXTURE_GEN_S);
	    glEnable(GL_TEXTURE_GEN_T);
	} else {
	    glDisable(GL_TEXTURE_GEN_S);
	    glDisable(GL_TEXTURE_GEN_T);
	}
	break;

      case TK_0:
	magFilter = nr;
	break;
      case TK_1:
	magFilter = ln;
	break;
      case TK_2:
	minFilter = nr;
	break;
      case TK_3:
	minFilter = ln;
	break;
      case TK_4:
	minFilter = nr_mipmap_nr;
	break;
      case TK_5:
	minFilter = nr_mipmap_ln;
	break;
      case TK_6:
	minFilter = ln_mipmap_nr;
	break;
      case TK_7:
	minFilter = ln_mipmap_ln;
	break;

      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT);

    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, tWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);

    glPushMatrix();

    glTranslatef(0.0, 0.0, zTranslate);
    glRotatef(xRotation, 1, 0, 0);
    glRotatef(yRotation, 0, 1, 0);
    glCallList(cube);

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-f") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-f (No file name).\n");
		return GL_FALSE;
	    } else {
		texFileName = argv[++i];
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

static void Animate(void)
{
    static struct _timeb thisTime, baseTime;
    double elapsed, frameRate, deltat;

    if (curFrame++ >= 10) {
    	if( !frameCount ) {
 	    _ftime( &baseTime );
	}
	else {
	    if( displayFrameRate ) {
 	        _ftime( &thisTime );
	        elapsed = thisTime.time + thisTime.millitm/1000.0 -
		          (baseTime.time + baseTime.millitm/1000.0);
	        if( elapsed == 0.0 )
	            printf( "Frame rate = unknown\n" );
	        else {
	            frameRate = frameCount / elapsed;
	            printf( "Frame rate = %5.2f fps\n", frameRate );
	        }
	    }
	}
	frameCount += 10;

	curFrame = 0;
    }


    glClear(GL_COLOR_BUFFER_BIT);

    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, tWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);

    glPushMatrix();

    glTranslatef(0.0, 0.0, zTranslate);
    glRotatef(xRotation, 1, 0, 0);
    glRotatef(yRotation, 0, 1, 0);
    glCallList(cube);

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }

    xRotation += 10.0;
    yRotation += 10.0;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    if (texFileName == 0) {
	printf("No image file.\n");
	tkQuit();
    }

    image = tkRGBImageLoad(texFileName);

    tkInitPosition(0, 0, 300, 300);

    type = TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Texture Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkIdleFunc(Animate);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\tstretch.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <malloc.h>
#include <fcntl.h>
//#include <unistd.h>
#include <math.h>
#include "tk.h"


// fix up math definitions
#define logf	log
#define	powf	pow

#define STEPCOUNT 40
#define FALSE 0
#define TRUE 1
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
#define MIN(a, b) (((a) < (b)) ? (a) : (b))


enum {
    OP_NOOP = 0,
    OP_STRETCH,
    OP_DRAWPOINT,
    OP_DRAWIMAGE
};


typedef struct _cRec {
    float x, y;
} cRec;

typedef struct _vertexRec {
    float x, y;
    float dX, dY;
    float tX, tY;
} vertexRec;


GLenum doubleBuffer, directRender;
int imageSizeX, imageSizeY;
char *fileName = 0;
TK_RGBImageRec *image;
cRec cList[50];
vertexRec vList[5];
int cCount, cIndex[2], cStep;
GLenum op = OP_NOOP;


void DrawImage(void)
{

    glRasterPos2i(0, 0);
    glDrawPixels(image->sizeX, image->sizeY, GL_RGB, GL_UNSIGNED_BYTE,
		 image->data);

    tkSwapBuffers();

    glRasterPos2i(0, 0);
    glDrawPixels(image->sizeX, image->sizeY, GL_RGB, GL_UNSIGNED_BYTE,
		 image->data);
}

void DrawPoint(void)
{
    int i;

    glColor3f(1.0, 0.0, 1.0);
    glPointSize(3.0);
    glBegin(GL_POINTS);
	for (i = 0; i < cCount; i++) {
	    glVertex2f(cList[i].x, cList[i].y);
	}
    glEnd();

    tkSwapBuffers();
}

void InitVList(void)
{

    vList[0].x = 0.0;
    vList[0].y = 0.0;
    vList[0].dX = 0.0;
    vList[0].dY = 0.0;
    vList[0].tX = 0.0;
    vList[0].tY = 0.0;

    vList[1].x = (float)imageSizeX;
    vList[1].y = 0.0;
    vList[1].dX = 0.0;
    vList[1].dY = 0.0;
    vList[1].tX = 1.0;
    vList[1].tY = 0.0;

    vList[2].x = (float)imageSizeX;
    vList[2].y = (float)imageSizeY;
    vList[2].dX = 0.0;
    vList[2].dY = 0.0;
    vList[2].tX = 1.0;
    vList[2].tY = 1.0;

    vList[3].x = 0.0;
    vList[3].y = (float)imageSizeY;
    vList[3].dX = 0.0;
    vList[3].dY = 0.0;
    vList[3].tX = 0.0;
    vList[3].tY = 1.0;

    vList[4].x = cList[0].x;
    vList[4].y = cList[0].y;
    vList[4].dX = (cList[1].x - cList[0].x) / STEPCOUNT;
    vList[4].dY = (cList[1].y - cList[0].y) / STEPCOUNT;
    vList[4].tX = cList[0].x / (float)imageSizeX;
    vList[4].tY = cList[0].y / (float)imageSizeY;
}

void ScaleImage(int sizeX, int sizeY)
{
    GLubyte *buf;

    buf = (GLubyte *)malloc(3*sizeX*sizeY);
    gluScaleImage(GL_RGB, image->sizeX, image->sizeY, GL_UNSIGNED_BYTE,
                  image->data, sizeX, sizeY, GL_UNSIGNED_BYTE, buf);
    free(image->data);
    image->data = buf;
    image->sizeX = sizeX;
    image->sizeY = sizeY;
}

void SetPoint(int x, int y)
{

    cList[cCount].x = (float)x;
    cList[cCount].y = (float)y;
    cCount++;
}

void Stretch(void)
{

    glBegin(GL_TRIANGLES);
	glTexCoord2f(vList[0].tX, vList[0].tY);
	glVertex2f(vList[0].x, vList[0].y);
	glTexCoord2f(vList[1].tX, vList[1].tY);
	glVertex2f(vList[1].x, vList[1].y);
	glTexCoord2f(vList[4].tX, vList[4].tY);
	glVertex2f(vList[4].x, vList[4].y);
    glEnd();

    glBegin(GL_TRIANGLES);
	glTexCoord2f(vList[1].tX, vList[1].tY);
	glVertex2f(vList[1].x, vList[1].y);
	glTexCoord2f(vList[2].tX, vList[2].tY);
	glVertex2f(vList[2].x, vList[2].y);
	glTexCoord2f(vList[4].tX, vList[4].tY);
	glVertex2f(vList[4].x, vList[4].y);
    glEnd();

    glBegin(GL_TRIANGLES);
	glTexCoord2f(vList[2].tX, vList[2].tY);
	glVertex2f(vList[2].x, vList[2].y);
	glTexCoord2f(vList[3].tX, vList[3].tY);
	glVertex2f(vList[3].x, vList[3].y);
	glTexCoord2f(vList[4].tX, vList[4].tY);
	glVertex2f(vList[4].x, vList[4].y);
    glEnd();

    glBegin(GL_TRIANGLES);
	glTexCoord2f(vList[3].tX, vList[3].tY);
	glVertex2f(vList[3].x, vList[3].y);
	glTexCoord2f(vList[0].tX, vList[0].tY);
	glVertex2f(vList[0].x, vList[0].y);
	glTexCoord2f(vList[4].tX, vList[4].tY);
	glVertex2f(vList[4].x, vList[4].y);
    glEnd();

    tkSwapBuffers();

    if (++cStep < STEPCOUNT) {
	vList[4].x += vList[4].dX;
	vList[4].y += vList[4].dY;
    } else {
	cIndex[0] = cIndex[1];
	cIndex[1] = cIndex[1] + 1;
	if (cIndex[1] == cCount) {
	    cIndex[1] = 0;
	}
	vList[4].dX = (cList[cIndex[1]].x - cList[cIndex[0]].x) / STEPCOUNT;
	vList[4].dY = (cList[cIndex[1]].y - cList[cIndex[0]].y) / STEPCOUNT;
	cStep = 0;
    }
}

GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	free(image->data);
        tkQuit();
      case TK_SPACE:
	if (cCount > 1) {
	    InitVList();
	    cIndex[0] = 0;
	    cIndex[1] = 1;
	    cStep = 0;
	    glEnable(GL_TEXTURE_2D);
	    op = OP_STRETCH;
	}
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

GLenum Mouse(int mouseX, int mouseY, GLenum button)
{

    if (op == OP_STRETCH) {
	glDisable(GL_TEXTURE_2D);
	cCount = 0;
	op = OP_DRAWIMAGE;
    } else {
	SetPoint(mouseX, imageSizeY-mouseY);
	op = OP_DRAWPOINT;
    }
    return GL_TRUE;
}

void Animate(void)
{

    switch (op) {
      case OP_STRETCH:
	Stretch();
	break;
      case OP_DRAWPOINT:
	DrawPoint();
	break;
      case OP_DRAWIMAGE:
	DrawImage();
	break;
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-f") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-f (No file name).\n");
		return GL_FALSE;
	    } else {
		fileName = argv[++i];
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    if (fileName == 0) {
	printf("No image file.\n");
	tkQuit();
    }

    image = tkRGBImageLoad(fileName);

    imageSizeX = (int)powf(2.0, (float)((int)(logf(image->sizeX)/logf(2.0))));
    imageSizeY = (int)powf(2.0, (float)((int)(logf(image->sizeY)/logf(2.0))));

    tkInitPosition(0, 0, imageSizeX, imageSizeY);

    type = TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Stretch") == GL_FALSE) {
        tkQuit();
    }

    glViewport(0, 0, imageSizeX, imageSizeY);
    gluOrtho2D(0, imageSizeX, 0, imageSizeY);
    glClearColor(0.0, 0.0, 0.0, 0.0);

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glPixelStorei(GL_PACK_ALIGNMENT, 1);

    ScaleImage(imageSizeX, imageSizeY);

    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, image->sizeX, image->sizeY, 0,
                 GL_RGB, GL_UNSIGNED_BYTE, (unsigned char *)image->data);

    cCount = 0;
    cIndex[0] = 0;
    cIndex[1] = 0;
    cStep = 0;
    op = OP_DRAWIMAGE;

    tkKeyDownFunc(Key);
    tkMouseDownFunc(Mouse);
    tkIdleFunc(Animate);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\twave.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <sys\types.h>
#include <sys\timeb.h>
#include "tk.h"


#define PI 3.14159265358979323846

#define GETCOORD(frame, x, y) (&(theMesh.coords[frame*theMesh.numCoords+(x)+(y)*(theMesh.widthX+1)]))
#define GETFACET(frame, x, y) (&(theMesh.facets[frame*theMesh.numFacets+(x)+(y)*theMesh.widthX]))


GLenum rgb, doubleBuffer, directRender, noSwap, noClear;

GLint colorIndexes1[3];
GLint colorIndexes2[3];
GLenum clearMask = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT;

GLenum smooth = GL_TRUE;
GLenum lighting = GL_TRUE;
GLenum depth = GL_TRUE;
GLenum stepMode = GL_FALSE;
GLenum spinMode = GL_FALSE;
GLint contouring = 0;

GLint widthX, widthY;
GLint checkerSize;
float height;

GLint frames, curFrame = 0, nextFrame = 0;
GLboolean displayFrameRate = GL_FALSE;
static GLint frameCount = 0;

struct facet {
    float color[3];
    float normal[3];
};
struct coord {
    float vertex[3];
    float normal[3];
};
struct mesh {
    GLint widthX, widthY;
    GLint numFacets;
    GLint numCoords;
    GLint frames;
    struct coord *coords;
    struct facet *facets;
} theMesh;

GLubyte contourTexture1[] = {
    255, 255, 255, 255,
    255, 255, 255, 255,
    255, 255, 255, 255,
    127, 127, 127, 127,
};
GLubyte contourTexture2[] = {
    255, 255, 255, 255,
    255, 127, 127, 127,
    255, 127, 127, 127,
    255, 127, 127, 127,
};


static void Animate(void)
{
    struct coord *coord;
    struct facet *facet;
    float *lastColor;
    float *thisColor;
    GLint i, j;
    static struct _timeb thisTime, baseTime;
    double elapsed, frameRate, deltat;

    if (!noClear)
    {
        glClear(clearMask);
    }

    if (nextFrame || !stepMode) {
	curFrame++;
    }

    if (curFrame >= theMesh.frames) {
	// mf: do frame rate calcs here
    	if( !frameCount ) {
 	    _ftime( &baseTime );
	}
	else {
	    if( displayFrameRate ) {
 	        _ftime( &thisTime );
	        elapsed = thisTime.time + thisTime.millitm/1000.0 -
		          (baseTime.time + baseTime.millitm/1000.0);
	        if( elapsed == 0.0 )
	            printf( "Frame rate = unknown\n" );
	        else {
	            frameRate = frameCount / elapsed;
	            printf( "Frame rate = %5.2f fps\n", frameRate );
	        }
	    }
	}
	frameCount += theMesh.frames;

	curFrame = 0;
    }

    if ((nextFrame || !stepMode) && spinMode) {
	glRotatef(5.0, 0.0, 0.0, 1.0);
    }
    nextFrame = 0;

    for (i = 0; i < theMesh.widthX; i++) {
	glBegin(GL_QUAD_STRIP);
	lastColor = NULL;
	for (j = 0; j < theMesh.widthY; j++) {
	    facet = GETFACET(curFrame, i, j);
	    if (!smooth && lighting) {
		glNormal3fv(facet->normal);
	    }
	    if (lighting) {
		if (rgb) {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
		} else {
		    thisColor = facet->color;
		    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, 
				 facet->color);
		}
	    } else {
		if (rgb) {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
		} else {
		    thisColor = facet->color;
		    glIndexf(facet->color[1]);
		}
	    }

	    if (!lastColor || (thisColor[0] != lastColor[0] && smooth)) {
		if (lastColor) {
		    glEnd();
		    glBegin(GL_QUAD_STRIP);
		}
		coord = GETCOORD(curFrame, i, j);
		if (smooth && lighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);

		coord = GETCOORD(curFrame, i+1, j);
		if (smooth && lighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);
	    }

	    coord = GETCOORD(curFrame, i, j+1);
	    if (smooth && lighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    coord = GETCOORD(curFrame, i+1, j+1);
	    if (smooth && lighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    lastColor = thisColor;
	}
	glEnd();
    }

    glFlush();
    if (doubleBuffer && !noSwap) {
	tkSwapBuffers();
    }
}

static void SetColorMap(void) 
{
    static float green[3] = {0.2, 1.0, 0.2};
    static float red[3] = {1.0, 0.2, 0.2};
    float *color, percent;
    GLint *indexes, entries, i, j;
    long buf[4];

    entries = tkGetColorMapSize();

    colorIndexes1[0] = 1;
    colorIndexes1[1] = 1 + (GLint)((entries - 1) * 0.3);
    colorIndexes1[2] = (GLint)((entries - 1) * 0.5);
    colorIndexes2[0] = 1 + (GLint)((entries - 1) * 0.5);
    colorIndexes2[1] = 1 + (GLint)((entries - 1) * 0.8);
    colorIndexes2[2] = entries - 1;

    for (i = 0; i < 2; i++) {
	switch (i) {
	  case 0:
	    color = green;
	    indexes = colorIndexes1;
	    break;
	  case 1:
	    color = red;
	    indexes = colorIndexes2;
	    break;
	}

	for (j = indexes[0]; j < indexes[1]; j++) {
	    percent = 0.2 + 0.8 * (j - indexes[0]) /
		      (float)(indexes[1] - indexes[0]);
	    tkSetOneColor(j, percent*color[0], percent*color[1],
			   percent*color[2]);
	}
	for (j=indexes[1]; j<=indexes[2]; j++) {
	    percent = (j - indexes[1]) / (float)(indexes[2] - indexes[1]);
	    tkSetOneColor(j, percent*(1-color[0])+color[0],
			   percent*(1-color[1])+color[1],
			   percent*(1-color[2])+color[2]);
	}
    }
}

static void InitMesh(void)
{
    struct coord *coord;
    struct facet *facet;
    float dp1[3], dp2[3];
    float *pt1, *pt2, *pt3;
    float angle, d, x, y;
    GLint numFacets, numCoords, frameNum, i, j;

    theMesh.widthX = widthX;
    theMesh.widthY = widthY;
    theMesh.frames = frames;

    numFacets = widthX * widthY;
    numCoords = (widthX + 1) * (widthY + 1);

    theMesh.numCoords = numCoords;
    theMesh.numFacets = numFacets;

    theMesh.coords = (struct coord *)malloc(frames*numCoords*
					    sizeof(struct coord));
    theMesh.facets = (struct facet *)malloc(frames*numFacets*
					    sizeof(struct facet));
    if (theMesh.coords == NULL || theMesh.facets == NULL) {
	printf("Out of memory.\n");
	tkQuit();
    }

    for (frameNum = 0; frameNum < frames; frameNum++) {
	for (i = 0; i <= widthX; i++) {
	    x = i / (float)widthX;
	    for (j = 0; j <= widthY; j++) {
		y = j / (float)widthY;

		d = sqrt(x*x+y*y);
		if (d == 0.0) {
		    d = 0.0001;
		}
		angle = 2 * PI * d + (2 * PI / frames * frameNum);

		coord = GETCOORD(frameNum, i, j);

		coord->vertex[0] = x - 0.5;
		coord->vertex[1] = y - 0.5;
		coord->vertex[2] = (height - height * d) * cos(angle);

		coord->normal[0] = -(height / d) * x * ((1 - d) * 2 * PI *
				   sin(angle) + cos(angle));
		coord->normal[1] = -(height / d) * y * ((1 - d) * 2 * PI *
				   sin(angle) + cos(angle));
		coord->normal[2] = -1;

		d = 1.0 / sqrt(coord->normal[0]*coord->normal[0]+
			       coord->normal[1]*coord->normal[1]+1);
		coord->normal[0] *= d;
		coord->normal[1] *= d;
		coord->normal[2] *= d;
	    }
	}
	for (i = 0; i < widthX; i++) {
	    for (j = 0; j < widthY; j++) {
		facet = GETFACET(frameNum, i, j);
		if (((i/checkerSize)%2)^(j/checkerSize)%2) {
		    if (rgb) {
			facet->color[0] = 1.0;
			facet->color[1] = 0.2;
			facet->color[2] = 0.2;
		    } else {
			facet->color[0] = colorIndexes1[0];
			facet->color[1] = colorIndexes1[1];
			facet->color[2] = colorIndexes1[2];
		    }
		} else {
		    if (rgb) {
			facet->color[0] = 0.2;
			facet->color[1] = 1.0;
			facet->color[2] = 0.2;
		    } else {
			facet->color[0] = colorIndexes2[0];
			facet->color[1] = colorIndexes2[1];
			facet->color[2] = colorIndexes2[2];
		    }
		}
		pt1 = GETCOORD(frameNum, i, j)->vertex;
		pt2 = GETCOORD(frameNum, i, j+1)->vertex;
		pt3 = GETCOORD(frameNum, i+1, j+1)->vertex;

		dp1[0] = pt2[0] - pt1[0];
		dp1[1] = pt2[1] - pt1[1];
		dp1[2] = pt2[2] - pt1[2];

		dp2[0] = pt3[0] - pt2[0];
		dp2[1] = pt3[1] - pt2[1];
		dp2[2] = pt3[2] - pt2[2];

		facet->normal[0] = dp1[1] * dp2[2] - dp1[2] * dp2[1];
		facet->normal[1] = dp1[2] * dp2[0] - dp1[0] * dp2[2];
		facet->normal[2] = dp1[0] * dp2[1] - dp1[1] * dp2[0];

		d = 1.0 / sqrt(facet->normal[0]*facet->normal[0]+
			       facet->normal[1]*facet->normal[1]+
			       facet->normal[2]*facet->normal[2]);

		facet->normal[0] *= d;
		facet->normal[1] *= d;
		facet->normal[2] *= d;
	    }
	}
    }
}

static void InitMaterials(void)
{
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {0.5, 1.0, 1.0, 1.0};
    static float position[] = {90.0, 90.0, 150.0, 0.0};
    static float front_mat_shininess[] = {60.0};
    static float front_mat_specular[] = {0.2, 0.2, 0.2, 1.0};
    static float front_mat_diffuse[] = {0.5, 0.28, 0.38, 1.0};
    static float back_mat_shininess[] = {60.0};
    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0};
    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0};
    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0};
    static float lmodel_twoside[] = {GL_TRUE};

    glMatrixMode(GL_PROJECTION);
    gluPerspective(450, 1.0, 0.5, 10.0);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    
    glMaterialfv(GL_FRONT, GL_SHININESS, front_mat_shininess);
    glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_BACK, GL_SHININESS, back_mat_shininess);
    glMaterialfv(GL_BACK, GL_SPECULAR, back_mat_specular);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
    if (rgb) {
	glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
    }

    if (rgb) {
	glEnable(GL_COLOR_MATERIAL);
    } else {
	SetColorMap();
    }
}

static void InitTexture(void)
{

    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
}

static void Init(void)
{

    glClearColor(0.0, 0.0, 0.0, 0.0);

    if (smooth) {
        glShadeModel(GL_SMOOTH);
    } else {
        glShadeModel(GL_FLAT);
    }
    
    glFrontFace(GL_CW);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    InitMaterials();
    InitTexture();
    InitMesh();

    glMatrixMode(GL_MODELVIEW);
    glTranslatef(0.0, 0.4, -1.8);
    glScalef(2.0, 2.0, 2.0);
    glRotatef(-35.0, 1.0, 0.0, 0.0);
    glRotatef(35.0, 0.0, 0.0, 1.0);
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_c:
	contouring++;
	if (contouring == 1) {
	    static GLfloat map[4] = {0, 0, 20, 0};

	    glTexImage2D(GL_TEXTURE_2D, 0, 3, 4, 4, 0, GL_LUMINANCE,
			 GL_UNSIGNED_BYTE, (GLvoid *)contourTexture1);
	    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	    glTexGenfv(GL_S, GL_OBJECT_PLANE, map);
	    glTexGenfv(GL_T, GL_OBJECT_PLANE, map);
	    glEnable(GL_TEXTURE_2D);
	    glEnable(GL_TEXTURE_GEN_S);
	    glEnable(GL_TEXTURE_GEN_T);
	} else if (contouring == 2) {
	    static GLfloat map[4] = {0, 0, 20, 0};

	    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	    glPushMatrix();
	    glMatrixMode(GL_MODELVIEW);
	    glLoadIdentity();
	    glTexGenfv(GL_S, GL_EYE_PLANE, map);
	    glTexGenfv(GL_T, GL_EYE_PLANE, map);
	    glPopMatrix();
	} else {
	    contouring = 0;
	    glDisable(GL_TEXTURE_GEN_S);
	    glDisable(GL_TEXTURE_GEN_T);
	    glDisable(GL_TEXTURE_2D);
	}
	break;
      case TK_s:
	smooth = !smooth;
	if (smooth) {
	    glShadeModel(GL_SMOOTH);
	} else {
	    glShadeModel(GL_FLAT);
	}
	break;
      case TK_l:
	lighting = !lighting;
	if (lighting) {
	    glEnable(GL_LIGHTING);
	    glEnable(GL_LIGHT0);
	    if (rgb) {
		glEnable(GL_COLOR_MATERIAL);
	    }
	} else {
	    glDisable(GL_LIGHTING);
	    glDisable(GL_LIGHT0);
	    if (rgb) {
		glDisable(GL_COLOR_MATERIAL);
	    }
	}
	break;
      case TK_d:
	depth = !depth;
	if (depth) {
	    glEnable(GL_DEPTH_TEST);
	    clearMask |= GL_DEPTH_BUFFER_BIT;
	} else {
	    glDisable(GL_DEPTH_TEST);
	    clearMask &= ~GL_DEPTH_BUFFER_BIT;
	}
	break;
      case TK_SPACE:
	stepMode = !stepMode;
	if (stepMode) {
	    tkIdleFunc(0);
	    tkDisplayFunc(Animate);
	} else {
	    tkIdleFunc(Animate);
	    tkDisplayFunc(0);
	}
	break;
      case TK_n:
	if (stepMode) {
	    nextFrame = 1;
	}
	break;
      case TK_f:
	displayFrameRate = !displayFrameRate;
	frameCount = 0;
	break;
      case TK_a:
	spinMode = !spinMode;
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_TRUE;
    directRender = GL_FALSE;
    noSwap = GL_FALSE;
    noClear = GL_FALSE;

    frames = 10;
    widthX = 10;
    widthY = 10;
    checkerSize = 2;
    height = 0.2;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-noswap") == 0) {
	    noSwap = GL_TRUE;
	} else if (strcmp(argv[i], "-noclear") == 0) {
	    noClear = GL_TRUE;
	} else if (strcmp(argv[i], "-grid") == 0) {
	    if (i+2 >= argc || argv[i+1][0] == '-' || argv[i+2][0] == '-') {
		printf("-grid (No numbers).\n");
		return GL_FALSE;
	    } else {
		widthX = atoi(argv[++i]);
		widthY = atoi(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-size") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-checker (No number).\n");
		return GL_FALSE;
	    } else {
		checkerSize = atoi(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-wave") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-wave (No number).\n");
		return GL_FALSE;
	    } else {
		height = atof(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-frames") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-frames (No number).\n");
		return GL_FALSE;
	    } else {
		frames = atoi(argv[++i]);
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(10, 30, 300, 300);

    type = TK_DEPTH16;
    type |= (rgb) ? TK_RGB : TK_INDEX;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Wave Demo") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkIdleFunc(Animate);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\seepal\seepal.c ===
#include <windows.h>

#include <GL\gl.h>

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

#define XSIZE 16
#define YSIZE 16

long WndProc ( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam );
BOOL DrawPalette(HWND hwnd, HDC hdc);
BOOL Cleanup(HWND hwnd, HDC hdc);

HPALETTE ghpal = 0, ghpalOld = 0;

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "View System Palette";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;
    char title[32];

    if ( !hPrevInstance )
    {
        //wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.style          = CS_OWNDC;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        //wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hCursor        = NULL;
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        // With a NULL icon handle, app will paint into the icon window.
        wndclass.hIcon          = NULL;
        //wndclass.hIcon          = LoadIcon(hInstance, "CubeIcon");

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = 0;
    Rect.top    = 0;
    Rect.right  = 16 * XSIZE;
    Rect.bottom = 16 * YSIZE;

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

    hwnd = CreateWindowEx  (  WS_EX_TOPMOST,
    szAppName,              // window class name
                            szAppName,              // window caption
                            WS_OVERLAPPEDWINDOW
                            | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                            CW_USEDEFAULT,          // initial x position
                            CW_USEDEFAULT,          // initial y position
                            WINDSIZEX(Rect),        // initial x size
                            WINDSIZEY(Rect),        // initial y size
                            NULL,                   // parent window handle
                            NULL,                   // window menu handle
                            hInstance,              // program instance handle
                            NULL                    // creation parameter
                        );

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        //if ( (hdlgRotate == 0) || !IsDialogMessage(hdlgRotate, &msg) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }

    return( msg.wParam );
}


long
WndProc (   HWND hWnd,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
        )
{
    HDC hDc;
    PAINTSTRUCT ps;

    switch ( message )
    {
        case WM_PAINT:
            hDc = BeginPaint( hWnd, &ps );

            DrawPalette( hWnd, hDc );

            EndPaint( hWnd, &ps );
            return(0);

        case WM_PALETTECHANGED:
            if (hWnd != (HWND) wParam)
            {
                int iRet = 0;

                if (hDc = GetDC(hWnd))
                {
                    SelectPalette(hDc, ghpal, TRUE);
                    if (RealizePalette(hDc) != GDI_ERROR)
                    {
                        InvalidateRect(hWnd, NULL, FALSE);
                        iRet = 1;
                    }
                    ReleaseDC(hWnd, hDc);
                }

                return iRet;
            }
            return 0;

        case WM_QUERYNEWPALETTE:

            if (hDc = GetDC(hWnd))
            {
                int iRet = 0;

                SelectPalette(hDc, ghpal, FALSE);
                if (RealizePalette(hDc) != GDI_ERROR)
                {
                    InvalidateRect(hWnd, NULL, FALSE);
                    iRet = 1;
                }
                ReleaseDC(hWnd, hDc);

                return iRet;
            }
            return 0;

        case WM_KEYDOWN:
            switch (wParam)
            {
            case VK_ESCAPE:
                PostMessage(hWnd, WM_DESTROY, 0, 0);
                break;
            default:
                break;
            }
            return 0;

        case WM_DESTROY:
            Cleanup(hWnd, hDc);
            PostQuitMessage( 0 );
            break;
    }
    return( DefWindowProc( hWnd, message, wParam, lParam ) );
}


BOOL DrawPalette(HWND hwnd, HDC hdc)
{
    int i, j;
    LOGBRUSH lb;
    LOGPEN   lp;
    HBRUSH hb, hbOld;
    HPEN   hp, hpOld;
    LOGPALETTE *ppal;
    PALETTEENTRY *ppalent;

    ppal = (LOGPALETTE *)
           LocalAlloc(LMEM_FIXED,
                      sizeof(LOGPALETTE) + 256*sizeof(PALETTEENTRY));
    if (!ppal)
        MessageBox(GetFocus(), "Out of memory!", "Error -- seepal.exe", MB_OK);

    lp.lopnStyle = PS_SOLID;
    lp.lopnWidth.x = 2;
    lp.lopnWidth.y = 2;
    lp.lopnColor = PALETTERGB(0, 0, 0);

    hpOld = SelectObject(hdc, hp = CreatePenIndirect(&lp));
    if (!hp || !hpOld)
        MessageBox(GetFocus(), "Failed to create pen.", "Error -- seepal.exe", MB_OK);

    lb.lbStyle = BS_SOLID;
    lb.lbHatch = 0;

    ppal->palVersion = 0x0300;
    ppal->palNumEntries = 256;
    ppalent = ppal->palPalEntry;
    if (GetSystemPaletteEntries(hdc, 0, 256, ppalent) != 256)
        MessageBox(GetFocus(), "Failed to read system palette.",
                   "Error -- seepal.exe", MB_OK);

    if (ghpal)
        DeleteObject(SelectPalette(hdc, ghpalOld, FALSE));

    ghpal = CreatePalette(ppal);
    ghpalOld = SelectPalette(hdc, ghpal, FALSE);

    if (!ghpal || !ghpalOld)
        MessageBox(GetFocus(), "Failed to create palette.", "Error -- seepal.exe", MB_OK);

    RealizePalette(hdc);

    for (i = 0; i < 16; i++)
        for (j = 0; j < 16; j++)
        {
            //lb.lbColor = PALETTERGB(ppalent->peRed,
            //                        ppalent->peGreen,
            //                        ppalent->peBlue);
            lb.lbColor = PALETTEINDEX(i*16 + j);

            hbOld = SelectObject(hdc, hb = CreateBrushIndirect(&lb));
            if (!hb || !hbOld)
                MessageBox(GetFocus(), "Failed to create brush.", "Error -- seepal.exe", MB_OK);

            Rectangle(hdc, j*XSIZE, i*YSIZE, j*XSIZE + XSIZE, i*YSIZE + YSIZE);

            DeleteObject(SelectObject(hdc, hbOld));

            ppalent++;
        }

    DeleteObject(SelectObject(hdc, hpOld));

    LocalFree(ppal);

    return TRUE;
}


BOOL Cleanup(HWND hwnd, HDC hdc)
{
    if (ghpal)
        DeleteObject(SelectPalette(hdc, ghpalOld, FALSE));
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\ttexture.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
//#include <unistd.h>
#include <math.h>
#include <stdlib.h>
#include "tk.h"


GLenum doubleBuffer, directRender;

char *texFileName = 0;
TK_RGBImageRec *image;

float *minFilter, *magFilter, *sWrapMode, *tWrapMode;
float decal[] = {GL_DECAL};
float modulate[] = {GL_MODULATE};
float repeat[] = {GL_REPEAT};
float clamp[] = {GL_CLAMP};
float nr[] = {GL_NEAREST};
float ln[] = {GL_LINEAR};
float nr_mipmap_nr[] = {GL_NEAREST_MIPMAP_NEAREST};
float nr_mipmap_ln[] = {GL_NEAREST_MIPMAP_LINEAR};
float ln_mipmap_nr[] = {GL_LINEAR_MIPMAP_NEAREST};
float ln_mipmap_ln[] = {GL_LINEAR_MIPMAP_LINEAR};
GLint sphereMap[] = {GL_SPHERE_MAP};

GLenum doSphere = GL_FALSE;
float xRotation = 0.0, yRotation = 0.0, zTranslate = -3.125;

GLint cube;
float c[6][4][3] = {
    {
	{
	    1.0, 1.0, -1.0
	},
	{
	    -1.0, 1.0, -1.0
	},
	{
	    -1.0, -1.0, -1.0
	},
	{
	    1.0, -1.0, -1.0
	}
    },
    {
	{
	    1.0, 1.0, 1.0
	},
	{
	    1.0, 1.0, -1.0
	},
	{
	    1.0, -1.0, -1.0
	},
	{
	    1.0, -1.0, 1.0
	}
    },
    {
	{
	    -1.0, 1.0, 1.0
	},
	{
	    1.0, 1.0, 1.0
	},
	{
	    1.0, -1.0, 1.0
	},
	{
	    -1.0, -1.0, 1.0
	}
    },
    {
	{
	    -1.0, 1.0, -1.0
	},
	{
	    -1.0, 1.0, 1.0
	},
	{
	    -1.0, -1.0, 1.0
	},
	{
	    -1.0, -1.0, -1.0
	}
    },
    {
	{
	    -1.0, 1.0, 1.0
	},
	{
	    -1.0, 1.0, -1.0
	},
	{
	    1.0, 1.0, -1.0
	},
	{
	    1.0, 1.0, 1.0
	}
    },
    {
	{
	    -1.0, -1.0, -1.0
	},
	{
	    -1.0, -1.0, 1.0
	},
	{
	    1.0, -1.0, 1.0
	},
	{
	    1.0, -1.0, -1.0
	}
    }
};
static float n[6][3] = {
    {
	0.0, 0.0, -1.0
    },
    {
	1.0, 0.0, 0.0
    },
    {
	0.0, 0.0, 1.0
    },
    {
	-1.0, 0.0, 0.0
    },
    {
	0.0, 1.0, 0.0
    },
    {
	0.0, -1.0, 0.0
    }
};
static float t[6][4][2] = {
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    -0.1,  1.1
	},
	{
	    1.1, 1.1
	},
	{
	    1.1, -0.1
	},
	{
	    -0.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
    {
	{
	    1.1,  1.1
	},
	{
	    -0.1, 1.1
	},
	{
	    -0.1, -0.1
	},
	{
	    1.1,  -0.1
	}
    },
};


static void BuildCube(void)
{
    GLint i;

    glNewList(cube, GL_COMPILE);
    for (i = 0; i < 6; i++) {
	glBegin(GL_POLYGON);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][0]); glVertex3fv(c[i][0]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][1]); glVertex3fv(c[i][1]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][2]); glVertex3fv(c[i][2]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][3]); glVertex3fv(c[i][3]);
	glEnd();
    }
    glEndList();
}

static void BuildLists(void)
{

    cube = glGenLists(1);
    BuildCube();
}

static void Init(void)
{

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image->sizeX, image->sizeY,
		      GL_RGB, GL_UNSIGNED_BYTE, image->data);
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
    glEnable(GL_TEXTURE_2D);

    glFrontFace(GL_CCW);
    glCullFace(GL_FRONT);
    glEnable(GL_CULL_FACE);

    BuildLists();

    glClearColor(0.0, 0.0, 0.0, 0.0);

    magFilter = nr;
    minFilter = nr;
    sWrapMode = repeat;
    tWrapMode = repeat;
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(145.0, 1.0, 0.01, 1000);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();

      case TK_LEFT:
	yRotation -= 0.5;
	break;
      case TK_RIGHT:
	yRotation += 0.5;
	break;
      case TK_UP:
	xRotation -= 0.5;
	break;
      case TK_DOWN:
	xRotation += 0.5;
	break;
      case TK_T:
	zTranslate += 0.25;
	break;
      case TK_t:
	zTranslate -= 0.25;
	break;

      case TK_s:
	doSphere = !doSphere;
	if (doSphere) {
	    glTexGeniv(GL_S, GL_TEXTURE_GEN_MODE, sphereMap);
	    glTexGeniv(GL_T, GL_TEXTURE_GEN_MODE, sphereMap);
	    glEnable(GL_TEXTURE_GEN_S);
	    glEnable(GL_TEXTURE_GEN_T);
	} else {
	    glDisable(GL_TEXTURE_GEN_S);
	    glDisable(GL_TEXTURE_GEN_T);
	}
	break;

      case TK_0:
	magFilter = nr;
	break;
      case TK_1:
	magFilter = ln;
	break;
      case TK_2:
	minFilter = nr;
	break;
      case TK_3:
	minFilter = ln;
	break;
      case TK_4:
	minFilter = nr_mipmap_nr;
	break;
      case TK_5:
	minFilter = nr_mipmap_ln;
	break;
      case TK_6:
	minFilter = ln_mipmap_nr;
	break;
      case TK_7:
	minFilter = ln_mipmap_ln;
	break;

      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void Draw(void)
{

    glClear(GL_COLOR_BUFFER_BIT);

    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, tWrapMode);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);

    glPushMatrix();

    glTranslatef(0.0, 0.0, zTranslate);
    glRotatef(xRotation, 1, 0, 0);
    glRotatef(yRotation, 0, 1, 0);
    glCallList(cube);

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-f") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-f (No file name).\n");
		return GL_FALSE;
	    } else {
		texFileName = argv[++i];
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    if (texFileName == 0) {
	printf("No image file.\n");
	tkQuit();
    }

    image = tkRGBImageLoad(texFileName);

    tkInitPosition(0, 0, 300, 300);

    type = TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Texture Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\ttri.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"


#define	SOLID 1
#define	LINE 2
#define	POINT 3


GLenum rgb, doubleBuffer, directRender, windType;
GLint windW, windH;

GLenum dithering = GL_TRUE;
GLenum showVerticies = GL_TRUE;
GLenum hideBottomTriangle = GL_FALSE;
GLenum outline = GL_TRUE;
GLenum culling = GL_FALSE;
GLenum winding = GL_FALSE;
GLenum face = GL_FALSE;
GLenum state = SOLID;
GLenum aaMode = GL_FALSE;
GLenum shade = GL_TRUE;

GLint color1, color2, color3;

float zRotation = 90.0;
float zoom = 1.0;

float boxA[3] = {-100, -100, 0};
float boxB[3] = { 100, -100, 0};
float boxC[3] = { 100,  100, 0};
float boxD[3] = {-100,  100, 0};

float p0[3] = {-125,-80, 0};
float p1[3] = {-125, 80, 0};
float p2[3] = { 172,  0, 0};


static void Init(void)
{
    float r, g, b;
    float percent1, percent2;
    GLint i, j;

    glClearColor(0.0, 0.0, 0.0, 0.0);

    glLineStipple(1, 0xF0F0);

    glEnable(GL_SCISSOR_TEST);

    if (!rgb) {
	for (j = 0; j <= 12; j++) {
	    if (j <= 6) {
		percent1 = j / 6.0;
		r = 1.0 - 0.8 * percent1;
		g = 0.2 + 0.8 * percent1;
		b = 0.2;
	    } else {
		percent1 = (j - 6) / 6.0;
		r = 0.2;
		g = 1.0 - 0.8 * percent1;
		b = 0.2 + 0.8 * percent1;
	    }
	    tkSetOneColor(j+18, r, g, b);
	    for (i = 0; i < 16; i++) {
		percent2 = i / 15.0;
		tkSetOneColor(j*16+1+32, r*percent2, g*percent2, b*percent2);
	    }
	}
	color1 = 18;
	color2 = 24;
	color3 = 30;
    }
}

static void Reshape(int width, int height)
{

    windW = (GLint)width;
    windH = (GLint)height;
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_LEFT:
	zRotation += 0.5;
	break;
      case TK_RIGHT:
	zRotation -= 0.5;
	break;
      case TK_Z:
	zoom *= 0.75;
	break;
      case TK_z:
	zoom /= 0.75;
	if (zoom > 10) {
	    zoom = 10;
	}
	break;
      case TK_1:
	glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
	break;
      case TK_2:
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	break;
      case TK_3:
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	break;
      case TK_4:
	state = POINT;
	break;
      case TK_5:
	state = LINE;
	break;
      case TK_6:
	state = SOLID;
	break;
      case TK_7:
	culling = !culling;
	break;
      case TK_8:
	winding = !winding;
	break;
      case TK_9:
	face = !face;
	break;
      case TK_v:
	showVerticies = !showVerticies;
	break;
      case TK_s:
	shade = !shade;
	(shade) ? glShadeModel(GL_SMOOTH) : glShadeModel(GL_FLAT);
	break;
      case TK_h:
	hideBottomTriangle = !hideBottomTriangle;
	break;
      case TK_o:
	outline = !outline;
	break;
      case TK_m:
	dithering = !dithering;
	break;
      case TK_0:
	aaMode = !aaMode;
	if (aaMode) {
	    glEnable(GL_POLYGON_SMOOTH);
	    glEnable(GL_BLEND);
	    glBlendFunc(GL_SRC_ALPHA, GL_ONE);
	    if (!rgb) {
		color1 = 32;
		color2 = 128;
		color3 = 224;
	    }
	} else {
	    glDisable(GL_POLYGON_SMOOTH);
	    glDisable(GL_BLEND);
	    if (!rgb) {
		color1 = 18;
		color2 = 24;
		color3 = 30;
	    }
	}
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static void BeginPrim(void)
{

    switch (state) {
      case SOLID:
	glBegin(GL_POLYGON);
	break;
      case LINE:
	glBegin(GL_LINE_LOOP);
	break;
      case POINT:
	glBegin(GL_POINTS);
	break;
    }
}

static void EndPrim(void)
{

    glEnd();
}

static void Draw(void)
{
    float scaleX, scaleY;

    glViewport(0, 0, windW, windH);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-175, 175, -175, 175);
    glMatrixMode(GL_MODELVIEW);

    glScissor(0, 0, windW, windH);

    (culling) ? glEnable(GL_CULL_FACE) : glDisable(GL_CULL_FACE);
    (winding) ? glFrontFace(GL_CCW) : glFrontFace(GL_CW);
    (face) ? glCullFace(GL_FRONT) : glCullFace(GL_BACK);

    (dithering) ? glEnable(GL_DITHER) : glDisable(GL_DITHER);

    glClear(GL_COLOR_BUFFER_BIT);

    TK_SETCOLOR(windType, TK_GREEN);
    glBegin(GL_LINE_LOOP);
	glVertex3fv(boxA);
	glVertex3fv(boxB);
	glVertex3fv(boxC);
	glVertex3fv(boxD);
    glEnd();

    if (!hideBottomTriangle) {
	glPushMatrix();

	glScalef(zoom, zoom, zoom);
	glRotatef(zRotation, 0, 0, 1);

	TK_SETCOLOR(windType, TK_BLUE);
	BeginPrim();
	    glVertex3fv(p0);
	    glVertex3fv(p1);
	    glVertex3fv(p2);
	EndPrim();

	if (showVerticies) {
	    (rgb) ? glColor3fv(tkRGBMap[TK_RED]) : glIndexf(color1);
	    glRectf(p0[0]-2, p0[1]-2, p0[0]+2, p0[1]+2);
	    (rgb) ? glColor3fv(tkRGBMap[TK_GREEN]) : glIndexf(color2);
	    glRectf(p1[0]-2, p1[1]-2, p1[0]+2, p1[1]+2);
	    (rgb) ? glColor3fv(tkRGBMap[TK_BLUE]) : glIndexf(color3);
	    glRectf(p2[0]-2, p2[1]-2, p2[0]+2, p2[1]+2);
	}

	glPopMatrix();
    }

    scaleX = (float)(windW - 20) / 2 / 175 * (175 - 100) + 10;
    scaleY = (float)(windH - 20) / 2 / 175 * (175 - 100) + 10;

    glViewport(scaleX, scaleY, windW-2*scaleX, windH-2*scaleY);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-100, 100, -100, 100);
    glMatrixMode(GL_MODELVIEW);

    glScissor(scaleX, scaleY, windW-2*scaleX, windH-2*scaleY);

    glPushMatrix();

    glScalef(zoom, zoom, zoom);
    glRotatef(zRotation, 0,0,1);

    glPointSize(10);
    glLineWidth(5);
    glEnable(GL_POINT_SMOOTH);
    glEnable(GL_LINE_STIPPLE);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    TK_SETCOLOR(windType, TK_RED);
    BeginPrim();
	(rgb) ? glColor3fv(tkRGBMap[TK_RED]) : glIndexf(color1);
	glVertex3fv(p0);
	(rgb) ? glColor3fv(tkRGBMap[TK_GREEN]) : glIndexf(color2);
	glVertex3fv(p1);
	(rgb) ? glColor3fv(tkRGBMap[TK_BLUE]) : glIndexf(color3);
	glVertex3fv(p2);
    EndPrim();

    glPointSize(1);
    glLineWidth(1);
    glDisable(GL_POINT_SMOOTH);
    glDisable(GL_LINE_STIPPLE);
    glBlendFunc(GL_ONE, GL_ZERO);

    if (outline) {
	TK_SETCOLOR(windType, TK_WHITE);
	glBegin(GL_LINE_LOOP);
	    glVertex3fv(p0);
	    glVertex3fv(p1);
	    glVertex3fv(p2);
	glEnd();
    }

    glPopMatrix();

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    windW = 600;
    windH = 300;
    tkInitPosition(0, 0, windW, windH);

    windType = (rgb) ? TK_RGB : TK_INDEX;
    windType |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    windType |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(windType);

    if (tkInitWindow("Triangle Test") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkDisplayFunc(Draw);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\samples\twave2.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <sys\types.h>
#include <sys\timeb.h>
#include "tk.h"


#define PI 3.14159265358979323846

#define GETCOORD(frame, x, y) (&(theMesh.coords[frame*theMesh.numCoords+(x)+(y)*(theMesh.widthX+1)]))
#define GETFACET(frame, x, y) (&(theMesh.facets[frame*theMesh.numFacets+(x)+(y)*theMesh.widthX]))


GLenum rgb, doubleBuffer, directRender;

GLint colorIndexes1[3];
GLint colorIndexes2[3];
GLenum clearMask = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT;

GLenum smooth = GL_TRUE;
GLenum lighting = GL_TRUE;
GLenum depth = GL_TRUE;
GLenum stepMode = GL_FALSE;
GLenum spinMode = GL_FALSE;
GLint contouring = 0;

GLint widthX, widthY;
GLint checkerSize;
float height;

GLint frames, curFrame = 0, nextFrame = 0;
GLboolean displayFrameRate = GL_FALSE;
static GLint frameCount = 0;

struct facet {
    float color[3];
    float normal[3];
};
struct coord {
    float vertex[3];
    float normal[3];
};
struct mesh {
    GLint widthX, widthY;
    GLint numFacets;
    GLint numCoords;
    GLint frames;
    struct coord *coords;
    struct facet *facets;
} theMesh;

GLubyte contourTexture1[] = {
    255, 255, 255, 255,
    255, 255, 255, 255,
    255, 255, 255, 255,
    127, 127, 127, 127,
};
GLubyte contourTexture2[] = {
    255, 255, 255, 255,
    255, 127, 127, 127,
    255, 127, 127, 127,
    255, 127, 127, 127,
};


static void Animate(void)
{
    struct coord *coord;
    struct facet *facet;
    float *lastColor;
    float *thisColor;
    GLint i, j;
    static struct _timeb thisTime, baseTime;
    double elapsed, frameRate, deltat;

    glClear(clearMask);

    if (nextFrame || !stepMode) {
	curFrame++;
    }

    if (curFrame >= theMesh.frames) {
	// mf: do frame rate calcs here
    	if( !frameCount ) {
 	    _ftime( &baseTime );
	}
	else {
	    if( displayFrameRate ) {
 	        _ftime( &thisTime );
	        elapsed = thisTime.time + thisTime.millitm/1000.0 -
		          (baseTime.time + baseTime.millitm/1000.0);
	        if( elapsed == 0.0 )
	            printf( "Frame rate = unknown\n" );
	        else {
	            frameRate = frameCount / elapsed;
	            printf( "Frame rate = %5.2f fps\n", frameRate );
	        }
	    }
	}
	frameCount += theMesh.frames;

	curFrame = 0;
    }

    if ((nextFrame || !stepMode) && spinMode) {
	glRotatef(5.0, 0.0, 0.0, 1.0);
    }
    nextFrame = 0;

    for (i = 0; i < theMesh.widthX; i++) {
	glBegin(GL_QUAD_STRIP);
	lastColor = NULL;
	for (j = 0; j < theMesh.widthY; j++) {
	    facet = GETFACET(curFrame, i, j);
	    if (!smooth && lighting) {
		glNormal3fv(facet->normal);
	    }
	    if (lighting) {
		if (rgb) {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
		} else {
		    thisColor = facet->color;
		    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, 
				 facet->color);
		}
	    } else {
		if (rgb) {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
		} else {
		    thisColor = facet->color;
		    glIndexf(facet->color[1]);
		}
	    }

	    if (!lastColor || (thisColor[0] != lastColor[0] && smooth)) {
		if (lastColor) {
		    glEnd();
		    glBegin(GL_QUAD_STRIP);
		}
		coord = GETCOORD(curFrame, i, j);
		if (smooth && lighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);

		coord = GETCOORD(curFrame, i+1, j);
		if (smooth && lighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);
	    }

	    coord = GETCOORD(curFrame, i, j+1);
	    if (smooth && lighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    coord = GETCOORD(curFrame, i+1, j+1);
	    if (smooth && lighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    lastColor = thisColor;
	}
	glEnd();
    }

    glFlush();
    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static void SetColorMap(void) 
{
    static float green[3] = {0.2, 1.0, 0.2};
    static float red[3] = {1.0, 0.2, 0.2};
    float *color, percent;
    GLint *indexes, entries, i, j;
    long buf[4];

    entries = tkGetColorMapSize();

    colorIndexes1[0] = 1;
    colorIndexes1[1] = 1 + (GLint)((entries - 1) * 0.3);
    colorIndexes1[2] = (GLint)((entries - 1) * 0.5);
    colorIndexes2[0] = 1 + (GLint)((entries - 1) * 0.5);
    colorIndexes2[1] = 1 + (GLint)((entries - 1) * 0.8);
    colorIndexes2[2] = entries - 1;

    for (i = 0; i < 2; i++) {
	switch (i) {
	  case 0:
	    color = green;
	    indexes = colorIndexes1;
	    break;
	  case 1:
	    color = red;
	    indexes = colorIndexes2;
	    break;
	}

	for (j = indexes[0]; j < indexes[1]; j++) {
	    percent = 0.2 + 0.8 * (j - indexes[0]) /
		      (float)(indexes[1] - indexes[0]);
	    tkSetOneColor(j, percent*color[0], percent*color[1],
			   percent*color[2]);
	}
	for (j=indexes[1]; j<=indexes[2]; j++) {
	    percent = (j - indexes[1]) / (float)(indexes[2] - indexes[1]);
	    tkSetOneColor(j, percent*(1-color[0])+color[0],
			   percent*(1-color[1])+color[1],
			   percent*(1-color[2])+color[2]);
	}
    }
}

static void InitMesh(void)
{
    struct coord *coord;
    struct facet *facet;
    float dp1[3], dp2[3];
    float *pt1, *pt2, *pt3;
    float angle, d, x, y;
    GLint numFacets, numCoords, frameNum, i, j;

    theMesh.widthX = widthX;
    theMesh.widthY = widthY;
    theMesh.frames = frames;

    numFacets = widthX * widthY;
    numCoords = (widthX + 1) * (widthY + 1);

    theMesh.numCoords = numCoords;
    theMesh.numFacets = numFacets;

    theMesh.coords = (struct coord *)malloc(frames*numCoords*
					    sizeof(struct coord));
    theMesh.facets = (struct facet *)malloc(frames*numFacets*
					    sizeof(struct facet));
    if (theMesh.coords == NULL || theMesh.facets == NULL) {
	printf("Out of memory.\n");
	tkQuit();
    }

    for (frameNum = 0; frameNum < frames; frameNum++) {
	for (i = 0; i <= widthX; i++) {
	    x = i / (float)widthX;
	    for (j = 0; j <= widthY; j++) {
		y = j / (float)widthY;

		d = sqrt(x*x+y*y);
		if (d == 0.0) {
		    d = 0.0001;
		}
		angle = 2 * PI * d + (2 * PI / frames * frameNum);

		coord = GETCOORD(frameNum, i, j);

		coord->vertex[0] = x - 0.5;
		coord->vertex[1] = y - 0.5;
		coord->vertex[2] = (height - height * d) * cos(angle);

		coord->normal[0] = -(height / d) * x * ((1 - d) * 2 * PI *
				   sin(angle) + cos(angle));
		coord->normal[1] = -(height / d) * y * ((1 - d) * 2 * PI *
				   sin(angle) + cos(angle));
		coord->normal[2] = -1;

		d = 1.0 / sqrt(coord->normal[0]*coord->normal[0]+
			       coord->normal[1]*coord->normal[1]+1);
		coord->normal[0] *= d;
		coord->normal[1] *= d;
		coord->normal[2] *= d;
	    }
	}
	for (i = 0; i < widthX; i++) {
	    for (j = 0; j < widthY; j++) {
		facet = GETFACET(frameNum, i, j);
		if (((i/checkerSize)%2)^(j/checkerSize)%2) {
		    if (rgb) {
			facet->color[0] = 1.0;
			facet->color[1] = 0.2;
			facet->color[2] = 0.2;
		    } else {
			facet->color[0] = colorIndexes1[0];
			facet->color[1] = colorIndexes1[1];
			facet->color[2] = colorIndexes1[2];
		    }
		} else {
		    if (rgb) {
			facet->color[0] = 0.2;
			facet->color[1] = 1.0;
			facet->color[2] = 0.2;
		    } else {
			facet->color[0] = colorIndexes2[0];
			facet->color[1] = colorIndexes2[1];
			facet->color[2] = colorIndexes2[2];
		    }
		}
		pt1 = GETCOORD(frameNum, i, j)->vertex;
		pt2 = GETCOORD(frameNum, i, j+1)->vertex;
		pt3 = GETCOORD(frameNum, i+1, j+1)->vertex;

		dp1[0] = pt2[0] - pt1[0];
		dp1[1] = pt2[1] - pt1[1];
		dp1[2] = pt2[2] - pt1[2];

		dp2[0] = pt3[0] - pt2[0];
		dp2[1] = pt3[1] - pt2[1];
		dp2[2] = pt3[2] - pt2[2];

		facet->normal[0] = dp1[1] * dp2[2] - dp1[2] * dp2[1];
		facet->normal[1] = dp1[2] * dp2[0] - dp1[0] * dp2[2];
		facet->normal[2] = dp1[0] * dp2[1] - dp1[1] * dp2[0];

		d = 1.0 / sqrt(facet->normal[0]*facet->normal[0]+
			       facet->normal[1]*facet->normal[1]+
			       facet->normal[2]*facet->normal[2]);

		facet->normal[0] *= d;
		facet->normal[1] *= d;
		facet->normal[2] *= d;
	    }
	}
    }
}

static void InitMaterials(void)
{
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {0.5, 1.0, 1.0, 1.0};
    static float position[] = {90.0, 90.0, 150.0, 0.0};
    static float front_mat_shininess[] = {60.0};
    static float front_mat_specular[] = {0.2, 0.2, 0.2, 1.0};
    static float front_mat_diffuse[] = {0.5, 0.28, 0.38, 1.0};
    static float back_mat_shininess[] = {60.0};
    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0};
    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0};
    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0};
    static float lmodel_twoside[] = {GL_TRUE};

    glMatrixMode(GL_PROJECTION);
    gluPerspective(450, 1.0, 0.5, 10.0);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    
    glMaterialfv(GL_FRONT, GL_SHININESS, front_mat_shininess);
    glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_BACK, GL_SHININESS, back_mat_shininess);
    glMaterialfv(GL_BACK, GL_SPECULAR, back_mat_specular);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
    if (rgb) {
	glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
    }

    if (rgb) {
	glEnable(GL_COLOR_MATERIAL);
    } else {
	SetColorMap();
    }
}

static void InitTexture(void)
{

    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
}

static void Init(void)
{

    glClearColor(0.0, 0.0, 0.0, 0.0);

    if (smooth) {
        glShadeModel(GL_SMOOTH);
    } else {
        glShadeModel(GL_FLAT);
    }
    
    glFrontFace(GL_CW);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    InitMaterials();
    InitTexture();
    InitMesh();

    glMatrixMode(GL_MODELVIEW);
    glTranslatef(0.0, 0.4, -1.8);
    glScalef(2.0, 2.0, 2.0);
    glRotatef(-35.0, 1.0, 0.0, 0.0);
    glRotatef(35.0, 0.0, 0.0, 1.0);
}

static void Reshape(int width, int height)
{

    glViewport(0, 0, (GLint)width, (GLint)height);
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      case TK_c:
	contouring++;
	if (contouring == 1) {
	    static GLfloat map[4] = {0, 0, 20, 0};

	    glTexImage2D(GL_TEXTURE_2D, 0, 1, 4, 4, 0, GL_LUMINANCE,
			 GL_UNSIGNED_BYTE, (GLvoid *)contourTexture1);
	    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	    glTexGenfv(GL_S, GL_OBJECT_PLANE, map);
	    glTexGenfv(GL_T, GL_OBJECT_PLANE, map);
	    glEnable(GL_TEXTURE_2D);
	    glEnable(GL_TEXTURE_GEN_S);
	    glEnable(GL_TEXTURE_GEN_T);
	} else if (contouring == 2) {
	    static GLfloat map[4] = {0, 0, 20, 0};

	    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	    glPushMatrix();
	    glMatrixMode(GL_MODELVIEW);
	    glLoadIdentity();
	    glTexGenfv(GL_S, GL_EYE_PLANE, map);
	    glTexGenfv(GL_T, GL_EYE_PLANE, map);
	    glPopMatrix();
	} else {
	    contouring = 0;
	    glDisable(GL_TEXTURE_GEN_S);
	    glDisable(GL_TEXTURE_GEN_T);
	    glDisable(GL_TEXTURE_2D);
	}
	break;
      case TK_s:
	smooth = !smooth;
	if (smooth) {
	    glShadeModel(GL_SMOOTH);
	} else {
	    glShadeModel(GL_FLAT);
	}
	break;
      case TK_l:
	lighting = !lighting;
	if (lighting) {
	    glEnable(GL_LIGHTING);
	    glEnable(GL_LIGHT0);
	    if (rgb) {
		glEnable(GL_COLOR_MATERIAL);
	    }
	} else {
	    glDisable(GL_LIGHTING);
	    glDisable(GL_LIGHT0);
	    if (rgb) {
		glDisable(GL_COLOR_MATERIAL);
	    }
	}
	break;
      case TK_d:
	depth = !depth;
	if (depth) {
	    glEnable(GL_DEPTH_TEST);
	    clearMask |= GL_DEPTH_BUFFER_BIT;
	} else {
	    glDisable(GL_DEPTH_TEST);
	    clearMask &= ~GL_DEPTH_BUFFER_BIT;
	}
	break;
      case TK_SPACE:
	stepMode = !stepMode;
	if (stepMode) {
	    tkIdleFunc(0);
	    tkDisplayFunc(Animate);
	} else {
	    tkIdleFunc(Animate);
	    tkDisplayFunc(0);
	}
	break;
      case TK_n:
	if (stepMode) {
	    nextFrame = 1;
	}
	break;
      case TK_f:
	displayFrameRate = !displayFrameRate;
	frameCount = 0;
	break;
      case TK_a:
	spinMode = !spinMode;
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_FALSE;
    directRender = GL_FALSE;

    frames = 10;
    widthX = 10;
    widthY = 10;
    checkerSize = 2;
    height = 0.2;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-grid") == 0) {
	    if (i+2 >= argc || argv[i+1][0] == '-' || argv[i+2][0] == '-') {
		printf("-grid (No numbers).\n");
		return GL_FALSE;
	    } else {
		widthX = atoi(argv[++i]);
		widthY = atoi(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-size") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-checker (No number).\n");
		return GL_FALSE;
	    } else {
		checkerSize = atoi(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-wave") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-wave (No number).\n");
		return GL_FALSE;
	    } else {
		height = atof(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-frames") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-frames (No number).\n");
		return GL_FALSE;
	    } else {
		frames = atoi(argv[++i]);
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    tkInitPosition(CW_USEDEFAULT, 30, 300, 300);
    //tkInitPosition(10, 30, 300, 300);

    type = TK_DEPTH16 | TK_FIXED_332_PAL;
    type |= (rgb) ? TK_RGB : TK_INDEX;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Wave Demo w/ fixed 332 pal") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkIdleFunc(Animate);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\ci\glcube\glcube.c ===
#define DBLBUFFER       1
#define USE_COLOR_INDEX 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ptypes32.h>
#include <pwin32.h>

long WndProc ( HWND hwnd, UINT message, DWORD wParam, LONG lParam );
void DoGlStuff( HWND hWnd, HDC hDc );
HGLRC hrcInitGL(HWND hwnd, HDC hdc);
void vCleanupGL(HGLRC hrc);

#include <GL\gl.h>

#define TERMINATE   DbgPrint("%s (%d)\n", __FILE__, __LINE__), ExitProcess(0)

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

// Default Logical Palette indexes
#define BLACK_INDEX	0
#define WHITE_INDEX	19
#define RED_INDEX	13
#define GREEN_INDEX	14
#define BLUE_INDEX	16
#define YELLOW_INDEX	15
#define MAGENTA_INDEX	17
#define CYAN_INDEX      18

// Global variables defining current position and orientation.
GLfloat AngleX = 0.0;
GLfloat AngleY = 0.0;
GLfloat AngleZ = 0.0;
GLfloat OffsetX = 0.0;
GLfloat OffsetY = 0.0;
GLfloat OffsetZ = -3.0;

HGLRC ghrc = (HGLRC) 0;

#ifdef DBLBUFFER
HDC     ghdcMem;
HBITMAP ghbmBackBuffer, ghbmOld;
#endif

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "GL Cube";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        //wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.style          = 0;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
        wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = 100;
    Rect.top    = 100;
    Rect.right  = 200;
    Rect.bottom = 200;

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

    hwnd = CreateWindow  (  szAppName,              // window class name
                            "GL Cube",              // window caption
                            WS_OVERLAPPEDWINDOW,    // window style
                            Rect.left,              // initial x position
                            Rect.top,               // initial y position
                            WINDSIZEX(Rect),        // initial x size
                            WINDSIZEY(Rect),        // initial y size
                            NULL,                   // parent window handle
                            NULL,                   // window menu handle
                            hInstance,              // program instance handle
                            NULL                    // creation parameter

                        );

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    return( msg.wParam );
}


long
WndProc (   HWND hWnd,
            UINT message,
            DWORD wParam,
            LONG lParam
        )
{
    HDC hDc;
    PAINTSTRUCT ps;
    BOOL bValidKey = TRUE;

    switch ( message )
    {
        case WM_PAINT:
            hDc = BeginPaint( hWnd, &ps );

            if (ghrc == (HGLRC) 0)
                ghrc = hrcInitGL(hWnd, hDc);

            DoGlStuff( hWnd, hDc );

            EndPaint( hWnd, &ps );
            return(0);

        case WM_CHAR:
            switch(wParam)
            {
                case 'u':
                case 'U':
                    AngleX += 10.0;
                    AngleX = (AngleX > 360.0) ? 0.0 : AngleX;
                    break;

                case 'j':
                case 'J':
                    AngleX -= 10.0;
                    AngleX = (AngleX < 0.0) ? 360.0 : AngleX;
                    break;

                case 'i':
                case 'I':
                    AngleY += 10.0;
                    AngleY = (AngleY > 360.0) ? 0.0 : AngleY;
                    break;

                case 'k':
                case 'K':
                    AngleY -= 10.0;
                    AngleY = (AngleY < 0.0) ? 360.0 : AngleY;
                    break;

                case 'o':
                case 'O':
                    AngleZ += 10.0;
                    AngleZ = (AngleZ > 360.0) ? 0.0 : AngleZ;
                    break;

                case 'l':
                case 'L':
                    AngleZ -= 10.0;
                    AngleZ = (AngleZ < 0.0) ? 360.0 : AngleZ;
                    break;

                case 'd':
                case 'D':
                    OffsetX += 0.2;
                    break;

                case 'a':
                case 'A':
                    OffsetX -= 0.2;
                    break;

            // !!! Note: currently the coordinate system is upside down, so
            // !!!       so up and down are reversed.

                case 's':
                case 'S':
                    OffsetY += 0.2;
                    break;

                case 'w':
                case 'W':
                    OffsetY -= 0.2;
                    break;

                case 'q':
                case 'Q':
                    OffsetZ += 0.2;
                    break;

                case 'e':
                case 'E':
                    OffsetZ -= 0.2;
                    break;

                default:
                    bValidKey = FALSE;
            }

            if (bValidKey)
            {
                hDc = GetDC(hWnd);

                if (ghrc == (HGLRC) 0)
                    ghrc = hrcInitGL(hWnd, hDc);

                DoGlStuff( hWnd, hDc );

                ReleaseDC(hWnd, hDc);
            }

            return 0;

        case WM_DESTROY:
            vCleanupGL(ghrc);
            PostQuitMessage( 0 );
            return( 0 );

    }
    return( DefWindowProc( hWnd, message, wParam, lParam ) );

}

HGLRC hrcInitGL(HWND hwnd, HDC hdc)
{
    RECT Rect;
    HGLRC hrc;
    int iWidth, iHeight;

#if !USE_COLOR_INDEX
    static GLfloat ClearColor[] =   {
                                        (GLfloat)0.0,   // Red
                                        (GLfloat)0.0,   // Green
                                        (GLfloat)0.0,   // Blue
                                        (GLfloat)1.0    // Alpha

                                    };
#endif

    /* Get the size of the client area */

    GetClientRect( hwnd, &Rect );
    iWidth  = Rect.right-Rect.left;
    iHeight = Rect.bottom-Rect.top;

    /* Create a Rendering Context */

#if DBLBUFFER
    ghdcMem = CreateCompatibleDC(hdc);
    SelectObject(ghdcMem, GetStockObject(DEFAULT_PALETTE));

    ghbmBackBuffer = CreateCompatibleBitmap(hdc, iWidth, iHeight);
    ghbmOld = SelectObject(ghdcMem, ghbmBackBuffer);

    //!!! [GilmanW] OpenGL hack !!!
    //!!!
    //!!! For some reason we need to prepare the memory DC.  GL
    //!!! drawing seems limited to the area drawn to by GDI calls.
    //!!! By BitBlt'ing the entire memory DC, the whole thing is
    //!!! is available to GL.
    //!!!
    //!!! There must be something we need to update on the server
    //!!! side so that this is not necessary.
    BitBlt(ghdcMem, 0, 0, iWidth, iHeight, NULL, 0, 0, BLACKNESS);

    hrc = wglCreateContext( ghdcMem );
#else
    hrc = wglCreateContext( hdc );
#endif

    /* Make it Current */

#if DBLBUFFER
    wglMakeCurrent( ghdcMem, hrc );
#else
    wglMakeCurrent( hdc, hrc );
#endif

    // !!! Note: currently the coordinate system is upside down, so we
    // !!!       need to reverse the default "front face" definition.

    glFrontFace(GL_CW);

    /* Set the clear color */

#if USE_COLOR_INDEX
    glClearIndex(BLACK_INDEX);
#else
    glClearColor( ClearColor[0], ClearColor[1], ClearColor[2], ClearColor[3] );
#endif

    /* Turn off dithering */

    glDisable(GL_DITHER);

    /* Turn on z-buffer */

    glEnable(GL_DEPTH_TEST);

    return hrc;
}

void
vCleanupGL(hrc)
{
    /*  Destroy our context */

    wglDeleteContext( hrc );

#if DBLBUFFER
    DeleteObject(SelectObject(ghdcMem, ghbmOld));
    DeleteDC(ghdcMem);
#endif
}

void
DoGlStuff( HWND hWnd, HDC hDc )
{
    RECT Rect;
    HGLRC hRc;

#if !USE_COLOR_INDEX
    static GLfloat Cyan[] =     {
                                    (GLfloat)0.0,   // Read
                                    (GLfloat)0.666, // Green
                                    (GLfloat)0.666, // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Yellow[] =   {
                                    (GLfloat)0.666, // Red
                                    (GLfloat)0.666, // Green
                                    (GLfloat)0.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Magenta[] =  {
                                    (GLfloat)0.666, // Red
                                    (GLfloat)0.0,   // Green
                                    (GLfloat)0.666, // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Red[] =      {
                                    (GLfloat)1.0,   // Red
                                    (GLfloat)0.0,   // Green
                                    (GLfloat)0.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Green[] =    {
                                    (GLfloat)0.0,   // Red
                                    (GLfloat)1.0,   // Green
                                    (GLfloat)0.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Blue[] =     {
                                    (GLfloat)0.0,   // Red
                                    (GLfloat)0.0,   // Green
                                    (GLfloat)1.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };
#endif

    /* Get the size of the client area */

    GetClientRect( hWnd, &Rect );

    /* Set up the projection matrix */

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.5, 20.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glTranslatef(OffsetX, OffsetY, OffsetZ);

    glRotatef(AngleX, 1.0, 0.0, 0.0);
    glRotatef(AngleY, 0.0, 1.0, 0.0);
    glRotatef(AngleZ, 0.0, 0.0, 1.0);

    glViewport(0, 0, WINDSIZEX(Rect), WINDSIZEY(Rect));

    /* Clear the color buffer */

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    /* Draw the cube */

    glBegin(GL_QUADS);

#if USE_COLOR_INDEX
        glIndexi(BLUE_INDEX);
#else
        glColor4fv( Blue );
#endif
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) -0.7);

#if USE_COLOR_INDEX
        glIndexi(GREEN_INDEX);
#else
        glColor4fv( Green );
#endif
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) -0.7);

#if USE_COLOR_INDEX
        glIndexi(RED_INDEX);
#else
        glColor4fv( Red );
#endif
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) 0.7);

#if USE_COLOR_INDEX
        glIndexi(CYAN_INDEX);
#else
        glColor4fv( Cyan );
#endif
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) 0.7);

#if USE_COLOR_INDEX
        glIndexi(YELLOW_INDEX);
#else
        glColor4fv( Yellow );
#endif
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) 0.7);

#if USE_COLOR_INDEX
        glIndexi(MAGENTA_INDEX);
#else
        glColor4fv( Magenta );
#endif
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) -0.7);

    glEnd();
    glFlush();

#if DBLBUFFER
    BitBlt(hDc, 0, 0, Rect.right-Rect.left, Rect.bottom-Rect.top, ghdcMem, 0, 0, SRCCOPY);
    GdiFlush();
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\ci\pntrast\hellowin.c ===
#define SIMPLE_ORTHO
//#define UNIT_CUBE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ptypes32.h>
#include <pwin32.h>

long WndProc ( HWND hwnd, UINT message, DWORD wParam, LONG lParam );
void DrawGlStuff( );
void InitGL( HWND hWnd );

#include <GL\gl.h>

#define TERMINATE   DbgPrint("%s (%d)\n", __FILE__, __LINE__), ExitProcess(0)

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

// Default Logical Palette indexes
#define BLACK_INDEX	0
#define WHITE_INDEX	19
#define RED_INDEX	13
#define GREEN_INDEX	14
#define BLUE_INDEX	16
#define YELLOW_INDEX	15
#define MAGENTA_INDEX	17
#define CYAN_INDEX	18



// Globals
HDC hDc;
HGLRC hRc;

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "HelloWin";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
        wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = 50;
    Rect.top    = 200;
    Rect.right  = 150;
    Rect.bottom = 300;

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

DbgPrint("CreateWindow in app\n");
    hwnd = CreateWindow  (  szAppName,              // window class name
                            "The Hello Program",    // window caption
                            WS_OVERLAPPEDWINDOW,    // window style
                            Rect.left,              // initial x position
                            Rect.top,               // initial y position
                            WINDSIZEX(Rect),        // initial x size
                            WINDSIZEY(Rect),        // initial y size
                            NULL,                   // parent window handle
                            NULL,                   // window menu handle
                            hInstance,              // program instance handle
                            NULL                    // creation parameter

                        );
DbgPrint("Back CreateWindow in app\n");
    hDc = GetDC(hwnd);
DbgPrint("hDc in app is 0x%x\n", hDc);

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    return( msg.wParam );
}


long
WndProc (   HWND hWnd,
            UINT message,
            DWORD wParam,
            LONG lParam
        )
{
    PAINTSTRUCT ps;
    HDC paintdc;

    switch ( message )
    {
        case WM_PAINT:
DbgPrint("WM_PAINT\n");
            if (hRc == NULL)
                InitGL(hWnd);

            paintdc = BeginPaint( hWnd, &ps );
DbgPrint("paintdc is 0x%x\n", paintdc);

            DrawGlStuff();

            EndPaint( hWnd, &ps );
            return(0);

        case WM_DESTROY:
            wglDeleteContext( hRc );
            PostQuitMessage( 0 );
            return( 0 );


    }
    return( DefWindowProc( hWnd, message, wParam, lParam ) );

}

void
InitGL( HWND hWnd )
{
    RECT Rect;


    DbgPrint("InitGL");
    /* Get the size of the client area */

    GetClientRect( hWnd, &Rect );

    DbgPrint("GetClientRect: hdc 0x%x (%d, %d) (%d, %d)\n",
        hDc,
        Rect.left,
        Rect.top,
        Rect.right,
        Rect.bottom );

    /* Create a Rendering Context */

    hRc = wglCreateContext( hDc );

    /* Make it Current */

    wglMakeCurrent( hDc, hRc );

    /* Set up the projection matrix */

    //Ortho2D(0, WINDSIZEX(Rect), 0, WINDSIZEY(Rect));

#ifdef SIMPLE_ORTHO
    glOrtho(0, WINDSIZEX(Rect), 0, WINDSIZEY(Rect), -1, 1);
#endif

// the following should be the default
#ifdef X_UNIT_CUBE		
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
#endif

    glViewport(0, 0, WINDSIZEX(Rect), WINDSIZEY(Rect));

    /* Set the clear color */

    //glClearColor( ClearColor[0], ClearColor[1], ClearColor[2], ClearColor[3] );
    /* Turn off dithering */

    glDisable(GL_DITHER);

}


void
DrawGlStuff( )
{
    int i;


    /* Clear the color buffer */

    glClear( GL_COLOR_BUFFER_BIT );


    /* Draw a single point */

    glBegin(GL_POINTS);

        /*  Set the color */
DbgPrint("hello:PALETTERGB ix 0x%x\n", PALETTERGB(255, 0, 0));

        //glIndexi(PALETTERGB(255, 0, 0));
        //glIndexi(PALETTEINDEX(13));
        //glIndexi(13);

        /*  Draw the point at this location */


#ifdef SIMPLE_ORTHO
        glIndexi(RED_INDEX);
        glVertex2f( (GLfloat)10, (GLfloat)10 );

        glIndexi(GREEN_INDEX);
        glVertex2f( (GLfloat)20, (GLfloat)20 );

        glIndexi(BLUE_INDEX);
        glVertex2f( (GLfloat)30, (GLfloat)50 );

        for (i=0; i<20; i++) {
            //glIndexi(PALETTEINDEX(i));
            glIndexi(i);
            glVertex2f( (GLfloat)40 + 2*i, (GLfloat)50 );
        }
#endif

#ifdef UNIT_CUBE
        glVertex2f( (GLfloat).1, (GLfloat).1 );
        glVertex2f( (GLfloat).2, (GLfloat).2 );
        glVertex2f( (GLfloat).3, (GLfloat).5 );
#endif

    glEnd();

    glFlush();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\ci\timecube\timecube.c ===
#define ZBUFFER         0
#define DBLBUFFER       1
#define USE_COLOR_INDEX 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ptypes32.h>
#include <pwin32.h>

long WndProc ( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam );
long DlgProcRotate ( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam );
void DoGlStuff( HWND hWnd, HDC hDc );
HGLRC hrcInitGL(HWND hwnd, HDC hdc);
void vResizeDoubleBuffer(HWND hwnd, HDC hdc);
void vCleanupGL(HGLRC hrc);

#include <GL\gl.h>

#define TERMINATE   DbgPrint("%s (%d)\n", __FILE__, __LINE__), ExitProcess(0)

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

// Default Logical Palette indexes
#define BLACK_INDEX     0
#define WHITE_INDEX     19
#define RED_INDEX       13
#define GREEN_INDEX     14
#define BLUE_INDEX      16
#define YELLOW_INDEX    15
#define MAGENTA_INDEX   17
#define CYAN_INDEX      18

// Global variables defining current position and orientation.
GLfloat AngleX = 145.0;
GLfloat AngleY = 50.0;
GLfloat AngleZ = 0.0;
GLfloat DeltaAngle[3] = { 0.0, 0.0, 0.0 };
GLfloat OffsetX = 0.0;
GLfloat OffsetY = 0.0;
GLfloat OffsetZ = -3.0;
GLuint  DListCube;
UINT    guiTimerTick = 128;

HGLRC ghrc = (HGLRC) 0;

#ifdef DBLBUFFER
HDC     ghdcMem;
HBITMAP ghbmBackBuffer = (HBITMAP) 0, ghbmOld;
#endif
HWND hdlgRotate;

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "TimeCube";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        //wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.style          = 0;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        // With a NULL icon handle, app will paint into the icon window.
        wndclass.hIcon          = NULL;
        //wndclass.hIcon          = LoadIcon(hInstance, "CubeIcon");

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = GetPrivateProfileInt("Window", "left",   100, "timecube.ini");
    Rect.top    = GetPrivateProfileInt("Window", "top",    100, "timecube.ini");;
    Rect.right  = GetPrivateProfileInt("Window", "right",  200, "timecube.ini");;
    Rect.bottom = GetPrivateProfileInt("Window", "bottom", 200, "timecube.ini");;
    guiTimerTick= GetPrivateProfileInt("Animate", "Timer", 32,  "timecube.ini");;

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

    hwnd = CreateWindow  (  szAppName,              // window class name
                            "TimeCube",             // window caption
                            WS_OVERLAPPEDWINDOW,    // window style
                            Rect.left,              // initial x position
                            Rect.top,               // initial y position
                            WINDSIZEX(Rect),        // initial x size
                            WINDSIZEY(Rect),        // initial y size
                            NULL,                   // parent window handle
                            NULL,                   // window menu handle
                            hInstance,              // program instance handle
                            NULL                    // creation parameter

                        );

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    hdlgRotate = CreateDialog(hInstance, "RotateDlg", hwnd, DlgProcRotate);

    SetTimer(hwnd, 1, guiTimerTick, NULL);

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        if ( (hdlgRotate == 0) || !IsDialogMessage(hdlgRotate, &msg) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }

    return( msg.wParam );
}


long
WndProc (   HWND hWnd,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
        )
{
    HDC hDc;
    PAINTSTRUCT ps;
    int iWidth, iHeight;

    switch ( message )
    {
        case WM_PAINT:
            hDc = BeginPaint( hWnd, &ps );

            if (ghrc == (HGLRC) 0)
                ghrc = hrcInitGL(hWnd, hDc);

            DoGlStuff( hWnd, hDc );

            EndPaint( hWnd, &ps );
            return(0);

        case WM_SIZE:
            iWidth = LOWORD(lParam);
            iHeight = HIWORD(lParam);

            #if 0
            SetWindowPos (hWnd,                         // hwnd
                          HWND_TOP,                     // z-order
                          0, 0,                         // position
                          max(iWidth, iHeight),         // new width
                          max(iWidth, iHeight),         // new height
                          SWP_NOMOVE);   // keep old postion
            #endif

            hDc = GetDC(hWnd);
            vResizeDoubleBuffer(hWnd, hDc);
            ReleaseDC(hWnd, hDc);
            return(0);

        case WM_CHAR:
            switch(wParam)
            {
                case 'd':
                case 'D':
                    OffsetX += 0.2;
                    break;

                case 'a':
                case 'A':
                    OffsetX -= 0.2;
                    break;

            // !!! Note: currently the coordinate system is upside down, so
            // !!!       so up and down are reversed.

                case 's':
                case 'S':
                    OffsetY += 0.2;
                    break;

                case 'w':
                case 'W':
                    OffsetY -= 0.2;
                    break;

                case 'q':
                case 'Q':
                    OffsetZ += 0.2;
                    break;

                case 'e':
                case 'E':
                    OffsetZ -= 0.2;
                    break;

                case ',':
                case '<':
                    guiTimerTick = guiTimerTick << 1;
                    guiTimerTick = min(0x40000000, guiTimerTick);

                    KillTimer(hWnd, 1);
                    SetTimer(hWnd, 1, guiTimerTick, NULL);
                    break;

                case '.':
                case '>':
                    guiTimerTick = guiTimerTick >> 1;
                    guiTimerTick = max(1, guiTimerTick);

                    KillTimer(hWnd, 1);
                    SetTimer(hWnd, 1, guiTimerTick, NULL);
                    break;

                default:
                    break;
            }

            return 0;

        case WM_TIMER:
            AngleX += DeltaAngle[0];
            AngleY += DeltaAngle[1];
            AngleZ += DeltaAngle[2];

            hDc = GetDC(hWnd);

            if (ghrc == (HGLRC) 0)
                ghrc = hrcInitGL(hWnd, hDc);

            DoGlStuff( hWnd, hDc );

            ReleaseDC(hWnd, hDc);

            return 0;

        case WM_DESTROY:
            vCleanupGL(ghrc);
            KillTimer(hWnd, 1);
            PostQuitMessage( 0 );
            DestroyWindow(hdlgRotate);
            return( 0 );

    }
    return( DefWindowProc( hWnd, message, wParam, lParam ) );
}


BOOL
DlgProcRotate(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndCtrl;
    int  iCtrl, iIndex;
    long lPos, lVal;
    static char ach[80];

    switch(msg)
    {
        case WM_INITDIALOG:
            for (iCtrl = 10; iCtrl < 13; iCtrl += 1)
            {
                hwndCtrl = GetDlgItem(hwnd, iCtrl);
                SetScrollRange(hwndCtrl, SB_CTL, 0, 90, FALSE);
                SetScrollPos(hwndCtrl, SB_CTL, 45, FALSE);
            }

            return TRUE;

        case WM_VSCROLL:
            hwndCtrl = lParam;
            iCtrl = GetWindowLong(hwndCtrl, GWL_ID);
            iIndex = iCtrl - 10;

            lVal = (long) DeltaAngle[iIndex];

            switch(LOWORD(wParam))
            {
                case SB_BOTTOM:
                    lVal = -45;
                    lPos = 90;
                    DeltaAngle[iIndex] = -45.0;
                    break;

                case SB_TOP:
                    lVal = 45;
                    lPos = 0;
                    DeltaAngle[iIndex] = 45.0;
                    break;

                case SB_PAGEDOWN:
                    lVal -= 4;
                case SB_LINEDOWN:
                    lVal = max(-45, lVal - 1);
                    lPos = 45 - lVal;
                    DeltaAngle[iIndex] = (float) lVal;
                    break;

                case SB_PAGEUP:
                    lVal += 4;
                case SB_LINEUP:
                    lVal = min(45, lVal + 1);
                    lPos = 45 - lVal;
                    DeltaAngle[iIndex] = (float) lVal;
                    break;

                case SB_THUMBPOSITION:
                case SB_THUMBTRACK:
                    lPos = (long) HIWORD(wParam);
                    lVal = 45 - lPos;               // invert and unbias
                    DeltaAngle[iIndex] = (float) lVal;
                    break;

                default:
                    return FALSE;
            }

        // Update scroll bar.

            SetScrollPos(hwndCtrl, SB_CTL, lPos, TRUE);

        // Update the static text with new value.

            wsprintf(ach, "%ld", lVal);
            SetDlgItemText(hwnd, iCtrl + 10, ach);

            return TRUE;

        default:
            break;
    }

    return FALSE;
}


void vResizeDoubleBuffer(HWND hwnd, HDC hdc)
{
    RECT Rect;

    /* Get the size of the client area */

    GetClientRect( hwnd, &Rect );

    if (ghbmBackBuffer != (HBITMAP) 0)
        DeleteObject(SelectObject(ghdcMem, ghbmOld));

    ghbmBackBuffer = CreateCompatibleBitmap(hdc, WINDSIZEX(Rect), WINDSIZEY(Rect));
    ghbmOld = SelectObject(ghdcMem, ghbmBackBuffer);

    //!!! [GilmanW] OpenGL hack !!!
    //!!!
    //!!! For some reason we need to prepare the memory DC.  GL
    //!!! drawing seems limited to the area drawn to by GDI calls.
    //!!! By BitBlt'ing the entire memory DC, the whole thing is
    //!!! is available to GL.
    //!!!
    //!!! There must be something we need to update on the server
    //!!! side so that this is not necessary.
    BitBlt(ghdcMem, 0, 0, WINDSIZEX(Rect), WINDSIZEY(Rect), NULL, 0, 0, BLACKNESS);
}


HGLRC hrcInitGL(HWND hwnd, HDC hdc)
{
    HGLRC hrc;

#if !USE_COLOR_INDEX
    static GLfloat ClearColor[] =   {
                                        (GLfloat)0.0,   // Red
                                        (GLfloat)0.0,   // Green
                                        (GLfloat)0.0,   // Blue
                                        (GLfloat)1.0    // Alpha

                                    };

    static GLfloat Cyan[] =     {
                                    (GLfloat)0.0,   // Read
                                    (GLfloat)0.666, // Green
                                    (GLfloat)0.666, // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Yellow[] =   {
                                    (GLfloat)0.666, // Red
                                    (GLfloat)0.666, // Green
                                    (GLfloat)0.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Magenta[] =  {
                                    (GLfloat)0.666, // Red
                                    (GLfloat)0.0,   // Green
                                    (GLfloat)0.666, // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Red[] =      {
                                    (GLfloat)1.0,   // Red
                                    (GLfloat)0.0,   // Green
                                    (GLfloat)0.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Green[] =    {
                                    (GLfloat)0.0,   // Red
                                    (GLfloat)1.0,   // Green
                                    (GLfloat)0.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Blue[] =     {
                                    (GLfloat)0.0,   // Red
                                    (GLfloat)0.0,   // Green
                                    (GLfloat)1.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };
#endif

    /* Create a Rendering Context */

#if DBLBUFFER
    ghdcMem = CreateCompatibleDC(hdc);
    SelectObject(ghdcMem, GetStockObject(DEFAULT_PALETTE));

    vResizeDoubleBuffer(hwnd, hdc);

    hrc = wglCreateContext( ghdcMem );
#else
    hrc = wglCreateContext( hdc );
#endif

    /* Make it Current */

#if DBLBUFFER
    wglMakeCurrent( ghdcMem, hrc );
#else
    wglMakeCurrent( hdc, hrc );
#endif

    // !!! Note: currently the coordinate system is upside down, so we
    // !!!       need to reverse the default "front face" definition.

    glFrontFace(GL_CW);

    /* Set the clear color */

#if USE_COLOR_INDEX
    glClearIndex(BLACK_INDEX);
#else
    glClearColor( ClearColor[0], ClearColor[1], ClearColor[2], ClearColor[3] );
#endif

    /* Turn off dithering */

    glDisable(GL_DITHER);

    /* Turn on z-buffer */

#if ZBUFFER
    glEnable(GL_DEPTH_TEST);
#else
    glDisable(GL_DEPTH_TEST);
#endif

    /* Turn on backface culling */

    glEnable(GL_CULL_FACE);

    /* Generate a display list for a cube */

    DListCube = glGenLists(1);

    glNewList(DListCube, GL_COMPILE);
        glBegin(GL_QUADS);

#if USE_COLOR_INDEX
            glIndexi(BLUE_INDEX);
#else
            glColor4fv( Blue );
#endif
            glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) 0.7);
            glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) 0.7);
            glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) -0.7);
            glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) -0.7);

#if USE_COLOR_INDEX
            glIndexi(GREEN_INDEX);
#else
            glColor4fv( Green );
#endif
            glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) -0.7);
            glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) -0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) -0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) -0.7);

#if USE_COLOR_INDEX
            glIndexi(RED_INDEX);
#else
            glColor4fv( Red );
#endif
            glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) -0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) -0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) 0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) 0.7);

#if USE_COLOR_INDEX
            glIndexi(CYAN_INDEX);
#else
            glColor4fv( Cyan );
#endif
            glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) 0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) 0.7);
            glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) 0.7);
            glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) 0.7);

#if USE_COLOR_INDEX
            glIndexi(YELLOW_INDEX);
#else
            glColor4fv( Yellow );
#endif
            glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) 0.7);
            glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) -0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) -0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) 0.7);

#if USE_COLOR_INDEX
            glIndexi(MAGENTA_INDEX);
#else
            glColor4fv( Magenta );
#endif
            glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) 0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) 0.7);
            glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) -0.7);
            glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) -0.7);

        glEnd();
    glEndList();

    return hrc;
}

void
vCleanupGL(hrc)
{
    /*  Destroy our context */

    wglDeleteContext( hrc );

#if DBLBUFFER
    DeleteObject(SelectObject(ghdcMem, ghbmOld));
    DeleteDC(ghdcMem);
#endif
}

void
DoGlStuff( HWND hWnd, HDC hDc )
{
    RECT Rect;
    HGLRC hRc;

    /* Get the size of the client area */

    GetClientRect( hWnd, &Rect );

    /* Set up the projection matrix */

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.5, 20.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glTranslatef(OffsetX, OffsetY, OffsetZ);

    glRotatef(AngleX, 1.0, 0.0, 0.0);
    glRotatef(AngleY, 0.0, 1.0, 0.0);
    glRotatef(AngleZ, 0.0, 0.0, 1.0);

    glViewport(0, 0, WINDSIZEX(Rect), WINDSIZEY(Rect));

    /* Clear the color buffer */

#if ZBUFFER
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
#else
    glClear( GL_COLOR_BUFFER_BIT );
#endif

    /* Draw the cube */

    /* Draw the cube */

    glCallList(DListCube);
    glFlush();

#if DBLBUFFER
    BitBlt(hDc, 0, 0, Rect.right-Rect.left, Rect.bottom-Rect.top, ghdcMem, 0, 0, SRCCOPY);
    GdiFlush();
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\ci\trirast\trirast.c ===
#define SIMPLE_ORTHO
//#define UNIT_CUBE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ptypes32.h>
#include <pwin32.h>

long WndProc ( HWND hwnd, UINT message, DWORD wParam, LONG lParam );
void DrawGlStuff( );
void InitGL( HWND hWnd );

#include <GL\gl.h>

#define TERMINATE   DbgPrint("%s (%d)\n", __FILE__, __LINE__), ExitProcess(0)

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

// Default Logical Palette indexes
#define BLACK_INDEX	0
#define WHITE_INDEX	19
#define RED_INDEX	13
#define GREEN_INDEX	14
#define BLUE_INDEX	16
#define YELLOW_INDEX	15
#define MAGENTA_INDEX	17
#define CYAN_INDEX	18



// Globals
HDC hDc;
HGLRC hRc;

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "TriRast";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
        wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = 50;
    Rect.top    = 200;
    Rect.right  = 150;
    Rect.bottom = 300;

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

DbgPrint("CreateWindow in app\n");
    hwnd = CreateWindow  (  szAppName,              // window class name
                            "The TriRast Program",    // window caption
                            WS_OVERLAPPEDWINDOW,    // window style
                            Rect.left,              // initial x position
                            Rect.top,               // initial y position
                            WINDSIZEX(Rect),        // initial x size
                            WINDSIZEY(Rect),        // initial y size
                            NULL,                   // parent window handle
                            NULL,                   // window menu handle
                            hInstance,              // program instance handle
                            NULL                    // creation parameter

                        );
DbgPrint("Back CreateWindow in app\n");
    hDc = GetDC(hwnd);
DbgPrint("hDc in app is 0x%x\n", hDc);

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    return( msg.wParam );
}


long
WndProc (   HWND hWnd,
            UINT message,
            DWORD wParam,
            LONG lParam
        )
{
    PAINTSTRUCT ps;
    HDC paintdc;

    switch ( message )
    {
        case WM_PAINT:
DbgPrint("WM_PAINT\n");
            if (hRc == NULL)
                InitGL(hWnd);

            paintdc = BeginPaint( hWnd, &ps );
DbgPrint("paintdc is 0x%x\n", paintdc);

            DrawGlStuff();

            EndPaint( hWnd, &ps );
            return(0);

        case WM_DESTROY:
            wglDeleteContext( hRc );
            PostQuitMessage( 0 );
            return( 0 );


    }
    return( DefWindowProc( hWnd, message, wParam, lParam ) );

}

void
InitGL( HWND hWnd )
{
    RECT Rect;


    DbgPrint("InitGL");
    /* Get the size of the client area */

    GetClientRect( hWnd, &Rect );

    DbgPrint("GetClientRect: hdc 0x%x (%d, %d) (%d, %d)\n",
        hDc,
        Rect.left,
        Rect.top,
        Rect.right,
        Rect.bottom );

    /* Create a Rendering Context */

    hRc = wglCreateContext( hDc );

    /* Make it Current */

    wglMakeCurrent( hDc, hRc );

    /* Set up the projection matrix */

    //Ortho2D(0, WINDSIZEX(Rect), 0, WINDSIZEY(Rect));

#ifdef SIMPLE_ORTHO
    glOrtho(0, WINDSIZEX(Rect), 0, WINDSIZEY(Rect), -1, 1);
#endif

// the following should be the default
#ifdef X_UNIT_CUBE		
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
#endif

    glViewport(0, 0, WINDSIZEX(Rect), WINDSIZEY(Rect));

    /* Set the clear color */

    glClearIndex(BLACK_INDEX);

    glDisable(GL_DITHER); 		/* Turn off dithering */
    glShadeModel(GL_FLAT);		/* Flat shaded */

}


void
DrawGlStuff( )
{
    int i;


    DbgPrint("trirast: drawGLstuff\n");
    /* Clear the color buffer */

    glClear( GL_COLOR_BUFFER_BIT );


    /* Draw a single point */
    glBegin(GL_TRIANGLES);

#ifdef SIMPLE_ORTHO
        /*  Set the color */
        glIndexi(RED_INDEX);
        glVertex2f( (GLfloat)10, (GLfloat)10 );
        glVertex2f( (GLfloat)50, (GLfloat)20 );
        glVertex2f( (GLfloat)40, (GLfloat)60 );
#endif

#ifdef UNIT_CUBE
        /*  Set the color */
        glIndexi(RED_INDEX);
        glVertex2f( (GLfloat).1, (GLfloat).1 );
        glVertex2f( (GLfloat).2, (GLfloat).2 );
        glVertex2f( (GLfloat).3, (GLfloat).5 );
#endif

    glEnd();

    glFlush();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\ci\triz\triz.c ===
#define UNIT_CUBE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ptypes32.h>
#include <pwin32.h>

long WndProc ( HWND hwnd, UINT message, DWORD wParam, LONG lParam );
void DrawGlStuff( );
void InitGL( HWND hWnd );

#include <GL\gl.h>

#define TERMINATE   DbgPrint("%s (%d)\n", __FILE__, __LINE__), ExitProcess(0)

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

// Default Logical Palette indexes
#define BLACK_INDEX	0
#define WHITE_INDEX	19
#define RED_INDEX	13
#define GREEN_INDEX	14
#define BLUE_INDEX	16
#define YELLOW_INDEX	15
#define MAGENTA_INDEX	17
#define CYAN_INDEX	18



// Globals
HDC hDc;
HGLRC hRc;

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "TriRast";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
        wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = 50;
    Rect.top    = 200;
    Rect.right  = 150;
    Rect.bottom = 300;

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

DbgPrint("CreateWindow in app\n");
    hwnd = CreateWindow  (  szAppName,              // window class name
                            "The TriRast Program",    // window caption
                            WS_OVERLAPPEDWINDOW,    // window style
                            Rect.left,              // initial x position
                            Rect.top,               // initial y position
                            WINDSIZEX(Rect),        // initial x size
                            WINDSIZEY(Rect),        // initial y size
                            NULL,                   // parent window handle
                            NULL,                   // window menu handle
                            hInstance,              // program instance handle
                            NULL                    // creation parameter

                        );
DbgPrint("Back CreateWindow in app\n");
    hDc = GetDC(hwnd);
DbgPrint("hDc in app is 0x%x\n", hDc);

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    return( msg.wParam );
}


long
WndProc (   HWND hWnd,
            UINT message,
            DWORD wParam,
            LONG lParam
        )
{
    PAINTSTRUCT ps;
    HDC paintdc;

    switch ( message )
    {
        case WM_PAINT:
DbgPrint("WM_PAINT\n");
            if (hRc == NULL)
                InitGL(hWnd);

            paintdc = BeginPaint( hWnd, &ps );
DbgPrint("paintdc is 0x%x\n", paintdc);

            DrawGlStuff();

            EndPaint( hWnd, &ps );
            return(0);

        case WM_DESTROY:
            wglDeleteContext( hRc );
            PostQuitMessage( 0 );
            return( 0 );


    }
    return( DefWindowProc( hWnd, message, wParam, lParam ) );

}

void
InitGL( HWND hWnd )
{
    RECT Rect;


    DbgPrint("InitGL");
    /* Get the size of the client area */

    GetClientRect( hWnd, &Rect );

    DbgPrint("GetClientRect: hdc 0x%x (%d, %d) (%d, %d)\n",
        hDc,
        Rect.left,
        Rect.top,
        Rect.right,
        Rect.bottom );

    /* Create a Rendering Context */

    hRc = wglCreateContext( hDc );

    /* Make it Current */

    wglMakeCurrent( hDc, hRc );

    /* Set up the projection matrix */

    //Ortho2D(0, WINDSIZEX(Rect), 0, WINDSIZEY(Rect));

#ifdef SIMPLE_ORTHO
    glOrtho(0, WINDSIZEX(Rect), 0, WINDSIZEY(Rect), -1, 1);
#endif

// the following should be the default
#ifdef X_UNIT_CUBE		
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
#endif

    glViewport(0, 0, WINDSIZEX(Rect), WINDSIZEY(Rect));

    /* Set the clear color */

    glClearIndex(BLACK_INDEX);
    glClearDepth(1.0);

    glEnable(GL_DEPTH_TEST);
    glDisable(GL_DITHER); 		/* Turn off dithering */
    glShadeModel(GL_FLAT);		/* Flat shaded */

}


void
DrawGlStuff( )
{
    int i;


    DbgPrint("trirast: drawGLstuff\n");
    /* Clear the color buffer */

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );


    /* Draw a single point */
    glBegin(GL_TRIANGLES);

#ifdef SIMPLE_ORTHO
        /*  Set the color */
        glIndexi(RED_INDEX);
        glVertex2f( (GLfloat)10, (GLfloat)10 );
        glVertex2f( (GLfloat)50, (GLfloat)20 );
        glVertex2f( (GLfloat)40, (GLfloat)60 );
#endif

#ifdef UNIT_CUBE
        glIndexi(RED_INDEX);
        glVertex3f( (GLfloat)-.5, (GLfloat)-.5, (GLfloat).5 );
        glVertex3f( (GLfloat).5, (GLfloat)-.5, (GLfloat).5 );
        glVertex3f( (GLfloat).0, (GLfloat).5, (GLfloat)-.5 );

        glIndexi(GREEN_INDEX);
        glVertex3f( (GLfloat)-.5, (GLfloat)-.5, (GLfloat)-.5 );
        glVertex3f( (GLfloat).5, (GLfloat)-.5, (GLfloat)-.5 );
        glVertex3f( (GLfloat).0, (GLfloat).5, (GLfloat).5 );
#endif

    glEnd();

    glFlush();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\d3dmacs.h ===
/*
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dmacs.h
 *
 *  Useful macros for generating execute buffers.  Consult the D3D sample
 *  code for examples of their usage.
 *
 *  Use OP_NOP to QWORD align triangle and line instructions.
 */

#ifndef __D3DMACS_H__
#define __D3DMACS_H__

#undef RELEASE

#ifndef __cplusplus
#define MAKE_MATRIX(lpDev, handle, data) \
    if (lpDev->lpVtbl->CreateMatrix(lpDev, &handle) != D3D_OK) \
    	return FALSE; \
    if (lpDev->lpVtbl->SetMatrix(lpDev, handle, &data) != D3D_OK) \
    	return FALSE
#define RELEASE(x) if (x != NULL) {x->lpVtbl->Release(x); x = NULL;}
#endif

#ifdef __cplusplus
#define MAKE_MATRIX(lpDev, handle, data) \
    if (lpDev->CreateMatrix(&handle) != D3D_OK) \
    	return FALSE; \
    if (lpDev->SetMatrix(handle, &data) != D3D_OK) \
    	return FALSE
#define RELEASE(x) if (x != NULL) {x->Release(); x = NULL;}
#endif

#define PUTD3DINSTRUCTION(op, sz, cnt, ptr) \
    ((LPD3DINSTRUCTION) ptr)->bOpcode = op; \
    ((LPD3DINSTRUCTION) ptr)->bSize = sz; \
    ((LPD3DINSTRUCTION) ptr)->wCount = cnt; \
    ptr = (void *)(((LPD3DINSTRUCTION) ptr) + 1)

#define VERTEX_DATA(loc, cnt, ptr) \
    if ((ptr) != (loc)) memcpy((ptr), (loc), sizeof(D3DVERTEX) * (cnt)); \
    ptr = (void *)(((LPD3DVERTEX) (ptr)) + (cnt))

// OP_MATRIX_MULTIPLY size: 4 (sizeof D3DINSTRUCTION)
#define OP_MATRIX_MULTIPLY(cnt, ptr) \
    PUTD3DINSTRUCTION(D3DOP_MATRIXMULTIPLY, sizeof(D3DMATRIXMULTIPLY), cnt, ptr)

// MATRIX_MULTIPLY_DATA size: 12 (sizeof MATRIXMULTIPLY)
#define MATRIX_MULTIPLY_DATA(src1, src2, dest, ptr) \
    ((LPD3DMATRIXMULTIPLY) ptr)->hSrcMatrix1 = src1; \
    ((LPD3DMATRIXMULTIPLY) ptr)->hSrcMatrix2 = src2; \
    ((LPD3DMATRIXMULTIPLY) ptr)->hDestMatrix = dest; \
    ptr = (void *)(((LPD3DMATRIXMULTIPLY) ptr) + 1)

// OP_STATE_LIGHT size: 4 (sizeof D3DINSTRUCTION)
#define OP_STATE_LIGHT(cnt, ptr) \
    PUTD3DINSTRUCTION(D3DOP_STATELIGHT, sizeof(D3DSTATE), cnt, ptr)

// OP_STATE_TRANSFORM size: 4 (sizeof D3DINSTRUCTION)
#define OP_STATE_TRANSFORM(cnt, ptr) \
    PUTD3DINSTRUCTION(D3DOP_STATETRANSFORM, sizeof(D3DSTATE), cnt, ptr)

// OP_STATE_RENDER size: 4 (sizeof D3DINSTRUCTION)
#define OP_STATE_RENDER(cnt, ptr) \
    PUTD3DINSTRUCTION(D3DOP_STATERENDER, sizeof(D3DSTATE), cnt, ptr)

// STATE_DATA size: 8 (sizeof D3DSTATE)
#define STATE_DATA(type, arg, ptr) \
    ((LPD3DSTATE) ptr)->drstRenderStateType = (D3DRENDERSTATETYPE)type; \
    ((LPD3DSTATE) ptr)->dwArg[0] = arg; \
    ptr = (void *)(((LPD3DSTATE) ptr) + 1)

// OP_PROCESS_VERTICES size: 4 (sizeof D3DINSTRUCTION)
#define OP_PROCESS_VERTICES(cnt, ptr) \
    PUTD3DINSTRUCTION(D3DOP_PROCESSVERTICES, sizeof(D3DPROCESSVERTICES), cnt, ptr)

// PROCESSVERTICES_DATA size: 16 (sizeof D3DPROCESSVERTICES)
#define PROCESSVERTICES_DATA(flgs, strt, cnt, ptr) \
    ((LPD3DPROCESSVERTICES) ptr)->dwFlags = flgs; \
    ((LPD3DPROCESSVERTICES) ptr)->wStart = strt; \
    ((LPD3DPROCESSVERTICES) ptr)->wDest = strt; \
    ((LPD3DPROCESSVERTICES) ptr)->dwCount = cnt; \
    ((LPD3DPROCESSVERTICES) ptr)->dwReserved = 0; \
    ptr = (void *)(((LPD3DPROCESSVERTICES) ptr) + 1)

// OP_TRIANGLE_LIST size: 4 (sizeof D3DINSTRUCTION)
#define OP_TRIANGLE_LIST(cnt, ptr) \
    PUTD3DINSTRUCTION(D3DOP_TRIANGLE, sizeof(D3DTRIANGLE), cnt, ptr)

#define TRIANGLE_LIST_DATA(loc, count, ptr) \
    if ((ptr) != (loc)) memcpy((ptr), (loc), sizeof(D3DTRIANGLE) * (count)); \
    ptr = (void *)(((LPD3DTRIANGLE) (ptr)) + (count))

// OP_LINE_LIST size: 4 (sizeof D3DINSTRUCTION)
#define OP_LINE_LIST(cnt, ptr) \
    PUTD3DINSTRUCTION(D3DOP_LINE, sizeof(D3DLINE), cnt, ptr)

#define LINE_LIST_DATA(loc, count, ptr) \
    if ((ptr) != (loc)) memcpy((ptr), (loc), sizeof(D3DLINE) * (count)); \
    ptr = (void *)(((LPD3DLINE) (ptr)) + (count))

// OP_POINT_LIST size: 8 (sizeof D3DINSTRUCTION + sizeof D3DPOINT)
#define OP_POINT_LIST(first, cnt, ptr) \
    PUTD3DINSTRUCTION(D3DOP_POINT, sizeof(D3DPOINT), 1, ptr); \
    ((LPD3DPOINT)(ptr))->wCount = cnt; \
    ((LPD3DPOINT)(ptr))->wFirst = first; \
    ptr = (void*)(((LPD3DPOINT)(ptr)) + 1)

// OP_SPAN_LIST size: 8 (sizeof D3DINSTRUCTION + sizeof D3DSPAN)
#define OP_SPAN_LIST(first, cnt, ptr) \
    PUTD3DINSTRUCTION(D3DOP_SPAN, sizeof(D3DSPAN), 1, ptr); \
    ((LPD3DSPAN)(ptr))->wCount = cnt; \
    ((LPD3DSPAN)(ptr))->wFirst = first; \
    ptr = (void*)(((LPD3DSPAN)(ptr)) + 1)

// OP_BRANCH_FORWARD size: 18 (sizeof D3DINSTRUCTION + sizeof D3DBRANCH)
#define OP_BRANCH_FORWARD(tmask, tvalue, tnegate, toffset, ptr) \
    PUTD3DINSTRUCTION(D3DOP_BRANCHFORWARD, sizeof(D3DBRANCH), 1, ptr); \
    ((LPD3DBRANCH) ptr)->dwMask = tmask; \
    ((LPD3DBRANCH) ptr)->dwValue = tvalue; \
    ((LPD3DBRANCH) ptr)->bNegate = tnegate; \
    ((LPD3DBRANCH) ptr)->dwOffset = toffset; \
    ptr = (void *)(((LPD3DBRANCH) (ptr)) + 1)

// OP_SET_STATUS size: 20 (sizeof D3DINSTRUCTION + sizeof D3DSTATUS)
#define OP_SET_STATUS(flags, status, _x1, _y1, _x2, _y2, ptr) \
    PUTD3DINSTRUCTION(D3DOP_SETSTATUS, sizeof(D3DSTATUS), 1, ptr); \
    ((LPD3DSTATUS)(ptr))->dwFlags = flags; \
    ((LPD3DSTATUS)(ptr))->dwStatus = status; \
    ((LPD3DSTATUS)(ptr))->drExtent.x1 = _x1; \
    ((LPD3DSTATUS)(ptr))->drExtent.y1 = _y1; \
    ((LPD3DSTATUS)(ptr))->drExtent.x2 = _x2; \
    ((LPD3DSTATUS)(ptr))->drExtent.y2 = _y2; \
    ptr = (void *)(((LPD3DSTATUS) (ptr)) + 1)

// OP_NOP size: 4
#define OP_NOP(ptr) \
    PUTD3DINSTRUCTION(D3DOP_TRIANGLE, sizeof(D3DTRIANGLE), 0, ptr)

#define OP_EXIT(ptr) \
    PUTD3DINSTRUCTION(D3DOP_EXIT, 0, 0, ptr)

#define QWORD_ALIGNED(ptr) \
    !(0x00000007L & (ULONG)(ptr))

#endif // __D3DMACS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\d3dmath.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dmath.c
 *
 ***************************************************************************/

#include <d3d.h>
#include <math.h>

/*
 * Normalises the vector v
 */
LPD3DVECTOR 
D3DVECTORNormalise(LPD3DVECTOR v)
{
    float vx, vy, vz, inv_mod;
    vx = v->x;
    vy = v->y;
    vz = v->z;
    if ((vx == 0) && (vy == 0) && (vz == 0))
	return v;
    inv_mod = (float)(1.0 / sqrt(vx * vx + vy * vy + vz * vz));
    v->x = vx * inv_mod;
    v->y = vy * inv_mod;
    v->z = vz * inv_mod;
    return v;
}


/*
 * Calculates cross product of a and b.
 */
LPD3DVECTOR 
D3DVECTORCrossProduct(LPD3DVECTOR lpd, LPD3DVECTOR lpa, LPD3DVECTOR lpb)
{

    lpd->x = lpa->y * lpb->z - lpa->z * lpb->y;
    lpd->y = lpa->z * lpb->x - lpa->x * lpb->z;
    lpd->z = lpa->x * lpb->y - lpa->y * lpb->x;
    return lpd;
}


/*
 * lpDst = lpSrc1 * lpSrc2
 * lpDst can be equal to lpSrc1 or lpSrc2
 */
LPD3DMATRIX MultiplyD3DMATRIX(LPD3DMATRIX lpDst, LPD3DMATRIX lpSrc1, 
                              LPD3DMATRIX lpSrc2)
{
    D3DVALUE M1[4][4], M2[4][4], D[4][4];
    int i, r, c;

    memcpy(&M1[0][0], lpSrc1, sizeof(D3DMATRIX));
    memcpy(&M2[0][0], lpSrc2, sizeof(D3DMATRIX));
    for (r = 0; r < 4; r++) {
        for (c = 0; c < 4; c++) {
            D[r][c] = (float)0.0;
            for (i = 0; i < 4; i++)
                D[r][c] += M1[r][i] * M2[i][c];
        }
    }
    memcpy(lpDst, &D[0][0], sizeof(D3DMATRIX));
    return lpDst;
}



/*
 * -1 d = a
 */
LPD3DMATRIX 
D3DMATRIXInvert(LPD3DMATRIX d, LPD3DMATRIX a)
{
    d->_11 = a->_11;
    d->_12 = a->_21;
    d->_13 = a->_31;
    d->_14 = a->_14;

    d->_21 = a->_12;
    d->_22 = a->_22;
    d->_23 = a->_32;
    d->_24 = a->_24;

    d->_31 = a->_13;
    d->_32 = a->_23;
    d->_33 = a->_33;
    d->_34 = a->_34;

    d->_41 = a->_14;
    d->_42 = a->_24;
    d->_43 = a->_34;
    d->_44 = a->_44;

    return d;
}


/*
 * Set the rotation part of a matrix such that the vector lpD is the new
 * z-axis and lpU is the new y-axis.
 */
LPD3DMATRIX 
D3DMATRIXSetRotation(LPD3DMATRIX lpM, LPD3DVECTOR lpD, LPD3DVECTOR lpU)
{
    float t;
    D3DVECTOR d, u, r;

    /*
     * Normalise the direction vector.
     */
    d.x = lpD->x;
    d.y = lpD->y;
    d.z = lpD->z;
    D3DVECTORNormalise(&d);

    u.x = lpU->x;
    u.y = lpU->y;
    u.z = lpU->z;
    /*
     * Project u into the plane defined by d and normalise.
     */
    t = u.x * d.x + u.y * d.y + u.z * d.z;
    u.x -= d.x * t;
    u.y -= d.y * t;
    u.z -= d.z * t;
    D3DVECTORNormalise(&u);

    /*
     * Calculate the vector pointing along the matrix x axis (in a right
     * handed coordinate system) using cross product.
     */
    D3DVECTORCrossProduct(&r, &u, &d);

    lpM->_11 = r.x;
    lpM->_12 = r.y, lpM->_13 = r.z;
    lpM->_21 = u.x;
    lpM->_22 = u.y, lpM->_23 = u.z;
    lpM->_31 = d.x;
    lpM->_32 = d.y;
    lpM->_33 = d.z;

    return lpM;
}

/*
 * Calculates a point along a B-Spline curve defined by four points. p
 * n output, contain the point. t				 Position
 * along the curve between p2 and p3.  This position is a float between 0
 * and 1. p1, p2, p3, p4    Points defining spline curve. p, at parameter
 * t along the spline curve
 */
void 
spline(LPD3DVECTOR p, float t, LPD3DVECTOR p1, LPD3DVECTOR p2,
       LPD3DVECTOR p3, LPD3DVECTOR p4)
{
    double t2, t3;
    float m1, m2, m3, m4;

    t2 = (double)(t * t);
    t3 = t2 * (double)t;

    m1 = (float)((-1.0 * t3) + (2.0 * t2) + (-1.0 * (double)t));
    m2 = (float)((3.0 * t3) + (-5.0 * t2) + (0.0 * (double)t) + 2.0);
    m3 = (float)((-3.0 * t3) + (4.0 * t2) + (1.0 * (double)t));
    m4 = (float)((1.0 * t3) + (-1.0 * t2) + (0.0 * (double)t));

    m1 /= (float)2.0;
    m2 /= (float)2.0;
    m3 /= (float)2.0;
    m4 /= (float)2.0;

    p->x = p1->x * m1 + p2->x * m2 + p3->x * m3 + p4->x * m4;
    p->y = p1->y * m1 + p2->y * m2 + p3->y * m3 + p4->y * m4;
    p->z = p1->z * m1 + p2->z * m2 + p3->z * m3 + p4->z * m4;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\lclib.h ===
/*
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: lclib.h
 *
 */

#ifndef __LCLIB_H__
#define __LCLIB_H__

char* LSTRRCHR( const char*, int );
char* LSTRCHR( const char*, int );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\lclib.c ===
/*
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: lclib.h
 *
 */

#include	<windows.h>
#include	"lclib.h"


char* LSTRCHR( const char* lpString, int bChar )
{
    if( lpString != NULL )
    {
	while( *lpString != 0 )
	{
	    if( *lpString == bChar )
	    {
		return (char*)lpString;
	    }

	    lpString++;
	}
    }
    return NULL;

} /* LSTRCHR */

char* LSTRRCHR( const char* lpString, int bChar )
{
    if( lpString != NULL )
    {
	const char*	lpBegin;

	lpBegin = lpString;

	while( *lpString != 0 )
	{
	    lpString++;
	}

        while( 1 )
	{
	    if( *lpString == bChar )
	    {
		return (char*)lpString;
	    }
	    
	    if( lpString == lpBegin )
	    {
	 	break;
	    }

	    lpString--;
	}
    }

    return NULL;
} /* LSTRRCHR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\d3dmath.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dmath.h
 *
 ***************************************************************************/
#ifndef __D3DMATH_H__
#define __D3DMATH_H__

#include <math.h>

#ifdef __cplusplus
extern "C" {
#endif
/*
 * Normalises the vector v
 */
LPD3DVECTOR D3DVECTORNormalise(LPD3DVECTOR v);

/*
 * Calculates cross product of a and b.
 */
LPD3DVECTOR D3DVECTORCrossProduct(LPD3DVECTOR lpd, LPD3DVECTOR lpa, LPD3DVECTOR lpb);

/*
 * lpDst = lpSrc1 * lpSrc2
 * lpDst can be equal to lpSrc1 or lpSrc2
 */
LPD3DMATRIX MultiplyD3DMATRIX(LPD3DMATRIX lpDst, LPD3DMATRIX lpSrc1, 
                              LPD3DMATRIX lpSrc2);
/*
 * -1 d = a
 */
LPD3DMATRIX D3DMATRIXInvert(LPD3DMATRIX d, LPD3DMATRIX a);

/*
 * Set the rotation part of a matrix such that the vector lpD is the new
 * z-axis and lpU is the new y-axis.
 */
LPD3DMATRIX D3DMATRIXSetRotation(LPD3DMATRIX lpM, LPD3DVECTOR lpD, LPD3DVECTOR lpU);

/*
 * Calculates a point along a B-Spline curve defined by four points. p
 * n output, contain the point. t				 Position
 * along the curve between p2 and p3.  This position is a float between 0
 * and 1. p1, p2, p3, p4    Points defining spline curve. p, at parameter
 * t along the spline curve
 */
void spline(LPD3DVECTOR p, float t, LPD3DVECTOR p1, LPD3DVECTOR p2,
            LPD3DVECTOR p3, LPD3DVECTOR p4);

#ifdef __cplusplus
};
#endif

#endif // __D3DMATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\d3dsphr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dsphr.c
 *
 ***************************************************************************/

#include <math.h>
#include <d3d.h>

#define PI 3.1415

/*
 * Generates a sphere around the y-axis centered at the origin including
 * normals and texture coordiantes.  Returns TRUE on success and FALSE on
 * failure.
 *     sphere_r     Radius of the sphere.
 *     num_rings    Number of full rings not including the top and bottom
 *		    caps.
 *     num_sections Number of sections each ring is divided into.  Each
 *		    section contains two triangles on full rings and one 
 *		    on top and bottom caps.
 *     sx, sy, sz   Scaling along each axis.  Set each to 1.0 for a 
 *		    perfect sphere. 
 *     plpv         On exit points to the vertices of the sphere.  The
 *		    function allocates this space.  Not allocated if
 *		    function fails.
 *     plptri       On exit points to the triangles of the sphere which 
 *		    reference vertices in the vertex list.  The function
 *		    allocates this space. Not allocated if function fails.
 *     pnum_v       On exit contains the number of vertices.
 *     pnum_tri     On exit contains the number of triangles.
 */
BOOL 
GenerateSphere(float sphere_r, int num_rings, int num_sections, float sx, 
	       float sy, float sz, LPD3DVERTEX* plpv, 
	       LPD3DTRIANGLE* plptri, int* pnum_v, int* pnum_tri)
{

    float theta, phi;    /* Angles used to sweep around sphere */
    float dtheta, dphi;  /* Angle between each section and ring */
    float x, y, z, v, rsintheta; /* Temporary variables */
    int i, j, n, m;      /* counters */
    int num_v, num_tri;  /* Internal vertex and triangle count */
    LPD3DVERTEX lpv;     /* Internal pointer for vertices */
    LPD3DTRIANGLE lptri; /* Internal pointer for trianlges */

    /*
     * Check the parameters to make sure they are valid.
     */
    if ((sphere_r <= 0) || (num_rings < 1) || (num_sections < 3) ||
	(sx <= 0) || (sy <= 0) || (sz <= 0))
        return FALSE;
    /*
     * Generate space for the required triangles and vertices.
     */
    num_tri = (num_rings + 1) * num_sections * 2;
    num_v = (num_rings + 1) * num_sections + 2;
    *plpv = (LPD3DVERTEX) malloc(sizeof(D3DVERTEX) * num_v);
    *plptri = (LPD3DTRIANGLE) malloc(sizeof(D3DTRIANGLE) * num_tri);
    lpv = *plpv;
    lptri = *plptri;
    *pnum_v = num_v;
    *pnum_tri = num_tri;

    /*
     * Generate vertices at the top and bottom points.
     */
    lpv[0].x = D3DVAL(0.0);
    lpv[0].y = D3DVAL(sy * sphere_r);
    lpv[0].z = D3DVAL(0.0);
    lpv[0].nx = D3DVAL(0.0);
    lpv[0].ny = D3DVAL(1.0);
    lpv[0].nz = D3DVAL(0.0);
    lpv[0].tu = D3DVAL(0.0);
    lpv[0].tv = D3DVAL(0.0);
    lpv[num_v - 1].x = D3DVAL(0.0);
    lpv[num_v - 1].y = D3DVAL(sy * -sphere_r);
    lpv[num_v - 1].z = D3DVAL(0.0);
    lpv[num_v - 1].nx = D3DVAL(0.0);
    lpv[num_v - 1].ny = D3DVAL(-1.0);
    lpv[num_v - 1].nz = D3DVAL(0.0);
    lpv[num_v - 1].tu = D3DVAL(0.0);
    lpv[num_v - 1].tv = D3DVAL(1.0);


    /*
     * Generate vertex points for rings
     */
    dtheta = (float)(PI / (double)(num_rings + 2));
    dphi = (float)(2.0 * PI / (double) num_sections);
    n = 1; /* vertex being generated, begins at 1 to skip top point */
    theta = dtheta;
    for (i = 0; i <= num_rings; i++) {
	y = sphere_r * (float)cos(theta); /* y is the same for each ring */
	v = theta / (float)PI; 	   /* v is the same for each ring */
	rsintheta = sphere_r * (float)sin(theta);
	phi = (float)0.0;
	for (j = 0; j < num_sections; j++) {
	    x = rsintheta * (float)sin(phi);
	    z = rsintheta * (float)cos(phi);
	    lpv[n].x = D3DVAL(sx * x);
	    lpv[n].z = D3DVAL(sz * z);
	    lpv[n].y = D3DVAL(sy * y);
	    lpv[n].nx = D3DVAL(x / sphere_r);
	    lpv[n].ny = D3DVAL(y / sphere_r);
	    lpv[n].nz = D3DVAL(z / sphere_r);
	    lpv[n].tv = D3DVAL(v);
	    lpv[n].tu = D3DVAL((float)(1.0 - phi / (2.0 * PI)));
	    phi += dphi;
	    ++n;
	}
	theta += dtheta;
    }

    /*
     * Generate triangles for top and bottom caps.
     */
    if (num_sections < 30) {
    /*
     * we can put the whole cap in a tri fan.
     */
	for (i = 0; i < num_sections; i++) {
	    lptri[i].v1 = 0;
	    lptri[i].v2 = i + 1;
	    lptri[i].v3 = 1 + ((i + 1) % num_sections);
	    
	    lptri[num_tri - num_sections + i].v1 = num_v - 1;
	    lptri[num_tri - num_sections + i].v2 = num_v - 2 - i;
	    lptri[num_tri - num_sections + i].v3 = num_v - 2 - 
		    ((1 + i) % num_sections);
		    
		   
     	    /*
	     * Enable correct edges.
	     */
	    lptri[i].wFlags = D3DTRIFLAG_EDGEENABLE1 |
			      D3DTRIFLAG_EDGEENABLE2;
			      
	    lptri[num_tri - num_sections + i].wFlags= D3DTRIFLAG_EDGEENABLE1 |
						      D3DTRIFLAG_EDGEENABLE2;
	    /*
	     * build fans.
	     */
	    if (i == 0) {
		lptri[i].wFlags |= D3DTRIFLAG_START;
		lptri[num_tri - num_sections + i].wFlags |= D3DTRIFLAG_START;
	    } else {
		lptri[i].wFlags |= D3DTRIFLAG_EVEN;
		lptri[num_tri - num_sections + i].wFlags |= D3DTRIFLAG_EVEN;
	    }
	    
	}
    } else {
	for (i = 0; i < num_sections; i++) {
	    lptri[i].v1 = 0;
	    lptri[i].v2 = i + 1;
	    lptri[i].v3 = 1 + ((i + 1) % num_sections);
	    lptri[i].wFlags = D3DTRIFLAG_EDGEENABLE1;
			      D3DTRIFLAG_EDGEENABLE2;
	    lptri[num_tri - num_sections + i].v1 = num_v - 1;
	    lptri[num_tri - num_sections + i].v2 = num_v - 2 - i;
	    lptri[num_tri - num_sections + i].v3 = num_v - 2 - 
		    ((1 + i) % num_sections);
	    lptri[num_tri - num_sections + i].wFlags= D3DTRIFLAG_EDGEENABLE1 |
						      D3DTRIFLAG_EDGEENABLE2;
	}
    }

    /*
     * Generate triangles for the rings
     */
    m = 1; /* first vertex in current ring,begins at 1 to skip top point*/
    n = num_sections; /* triangle being generated, skip the top cap */
	for (i = 0; i < num_rings; i++) {
	for (j = 0; j < num_sections; j++) {
	    lptri[n].v1 = m + j;
	    lptri[n].v2 = m + num_sections + j;
	    lptri[n].v3 = m + num_sections + ((j + 1) % num_sections);
	    lptri[n].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
	    
	    /*
	     * Start a two triangle flat fan for each face.
	     */
		    
	    lptri[n].wFlags = D3DTRIFLAG_STARTFLAT(1);
	    
	    /*
	     * only need two edges for wireframe.
	     */ 
	    lptri[n].wFlags |= D3DTRIFLAG_EDGEENABLE1 |
			       D3DTRIFLAG_EDGEENABLE2;
	
	    
	    lptri[n + 1].v1 = lptri[n].v1;
	    lptri[n + 1].v2 = lptri[n].v3;
	    lptri[n + 1].v3 = m + ((j + 1) % num_sections);
	    
	    lptri[n + 1].wFlags = D3DTRIFLAG_EVEN;
	    /*
	     * only need two edges for wireframe.
	     */ 
	    lptri[n + 1].wFlags |= D3DTRIFLAG_EDGEENABLE2 |
				   D3DTRIFLAG_EDGEENABLE3;
	    n += 2;
	}
	m += num_sections;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\d3dsphr.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dsphr.h
 *
 ***************************************************************************/
#ifndef __D3DSPHR_H__
#define __D3DSPHR_H__

#ifdef __cplusplus
extern "C" {
#endif
/*
 * Generates a sphere around the y-axis centered at the origin including
 * normals and texture coordiantes.  Returns TRUE on success and FALSE on
 * failure.
 *     sphere_r     Radius of the sphere.
 *     num_rings    Number of full rings not including the top and bottom
 *		    caps.
 *     num_sections Number of sections each ring is divided into.  Each
 *		    section contains two triangles on full rings and one 
 *		    on top and bottom caps.
 *     sx, sy, sz   Scaling along each axis.  Set each to 1.0 for a 
 *		    perfect sphere. 
 *     plpv         On exit points to the vertices of the sphere.  The
 *		    function allocates this space.  Not allocated if
 *		    function fails.
 *     plptri       On exit points to the triangles of the sphere which 
 *		    reference vertices in the vertex list.  The function
 *		    allocates this space. Not allocated if function fails.
 *     pnum_v       On exit contains the number of vertices.
 *     pnum_tri     On exit contains the number of triangles.
 */
BOOL 
GenerateSphere(float sphere_r, int num_rings, int num_sections, float sx, 
	       float sy, float sz, LPD3DVERTEX* plpv, 
	       LPD3DTRIANGLE* plptri, int* pnum_v, int* pnum_tri);

#ifdef __cplusplus
};
#endif

#endif // __D3DSPHR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\rmerror.h ===
/*
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: rmerror.h
 *
 *  Error reporting code for D3DRM examples.
 *
 */

#ifndef __ERROR_H__
#define __ERROR_H__

#include <ddraw.h>
#include <d3d.h>
#include <d3drmwin.h>
#include <d3drm.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Msg
 * Displays a message box containing the given formatted string.
 */
void __cdecl
Msg( LPSTR fmt, ... );

/*
 * D3DRMErrorToString
 * Returns a pointer to a string describing the given DD, D3D or D3DRM error code.
 */
char*
D3DRMErrorToString(HRESULT error);

#ifdef __cplusplus
};
#endif
#endif // __ERROR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\rmdemo.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: rmdemo.h
 *
 ***************************************************************************/
#ifndef __RMDEMO_H__
#define __RMDEMO_H__

#include <d3drmwin.h>
#include <d3drm.h>
#include "rmerror.h"

#undef RELEASE
#ifdef __cplusplus
#define RELEASE(x) if (x != NULL) {x->Release(); x = NULL;}
#else
#define RELEASE(x) if (x != NULL) {x->lpVtbl->Release(x); x = NULL;}
#endif

#ifdef __cplusplus
extern "C" {
#endif
    /*
     * A copy of LPDIRECT3DRM for use by the examples.
     */
    extern LPDIRECT3DRM lpD3DRM;
    /*
     * Builds the scene.
     */
    BOOL BuildScene(LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view, LPDIRECT3DRMFRAME scene,
			LPDIRECT3DRMFRAME camera);

    /*
     * Allows each example to begin with different defaults
     */
    typedef struct Defaultstag {
	BOOL bNoTextures;
	BOOL bResizingDisabled;
	BOOL bConstRenderQuality;
	char Name[50];
    } Defaults;
    void OverrideDefaults(Defaults* defaults);

#ifdef __cplusplus
};
#endif

#endif  //__RMDEMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\rmmain.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: resource.h
 *
 ***************************************************************************/

#define MENU_ABOUT                      1
#define MENU_EXIT                       2
#define MENU_STEP                       27
#define MENU_GO                         28
#define MENU_FLAT                       12
#define MENU_GOURAUD                    13
#define MENU_PHONG                      14
#define MENU_POINT_FILTER               17
#define MENU_LINEAR_FILTER              18
#define MENU_POINT                      20
#define MENU_WIREFRAME                  21
#define MENU_SOLID                      22
#define MENU_DITHERING                  24
#define MENU_ANTIALIAS                  26
#define MENU_LIGHTING			29
#define MENU_FIRST_DRIVER               80

#define IDC_STATIC                     -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\rmerror.c ===
/*
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: rmerror.cpp
 *
 *  Error reporting code for D3DRM examples.
 *
 */

#include "rmerror.h"

/* Msg
 * Displays a message box containing the given formatted string.
 */
void __cdecl
Msg( LPSTR fmt, ... )
{
    char buff[256];
    va_list args;

    va_start(args, fmt);
    wvsprintf(buff, fmt, args);
    va_end(args);
    lstrcat(buff, "\r\n");
    MessageBox( NULL, buff, "D3DRM Example Message", MB_OK );
}

/*
 * D3DRMErrorToString
 * Returns a pointer to a string describing the given DD, D3D or D3DRM error code.
 */
char*
D3DRMErrorToString(HRESULT error)
{
    switch(error) {
	case DD_OK:
	    /* Also includes D3D_OK and D3DRM_OK */
	    return "No error.\0";
	case DDERR_ALREADYINITIALIZED:
	    return "This object is already initialized.\0";
	case DDERR_BLTFASTCANTCLIP:
	    return "Return if a clipper object is attached to the source surface passed into a BltFast call.\0";
	case DDERR_CANNOTATTACHSURFACE:
	    return "This surface can not be attached to the requested surface.\0";
	case DDERR_CANNOTDETACHSURFACE:
	    return "This surface can not be detached from the requested surface.\0";
	case DDERR_CANTCREATEDC:
	    return "Windows can not create any more DCs.\0";
	case DDERR_CANTDUPLICATE:
	    return "Can't duplicate primary & 3D surfaces, or surfaces that are implicitly created.\0";
	case DDERR_CLIPPERISUSINGHWND:
	    return "An attempt was made to set a cliplist for a clipper object that is already monitoring an hwnd.\0";
	case DDERR_COLORKEYNOTSET:
	    return "No src color key specified for this operation.\0";
	case DDERR_CURRENTLYNOTAVAIL:
	    return "Support is currently not available.\0";
	case DDERR_DIRECTDRAWALREADYCREATED:
	    return "A DirectDraw object representing this driver has already been created for this process.\0";
	case DDERR_EXCEPTION:
	    return "An exception was encountered while performing the requested operation.\0";
	case DDERR_EXCLUSIVEMODEALREADYSET:
	    return "An attempt was made to set the cooperative level when it was already set to exclusive.\0";
	case DDERR_GENERIC:
	    return "Generic failure.\0";
	case DDERR_HEIGHTALIGN:
	    return "Height of rectangle provided is not a multiple of reqd alignment.\0";
	case DDERR_HWNDALREADYSET:
	    return "The CooperativeLevel HWND has already been set. It can not be reset while the process has surfaces or palettes created.\0";
	case DDERR_HWNDSUBCLASSED:
	    return "HWND used by DirectDraw CooperativeLevel has been subclassed, this prevents DirectDraw from restoring state.\0";
	case DDERR_IMPLICITLYCREATED:
	    return "This surface can not be restored because it is an implicitly created surface.\0";
	case DDERR_INCOMPATIBLEPRIMARY:
	    return "Unable to match primary surface creation request with existing primary surface.\0";
	case DDERR_INVALIDCAPS:
	    return "One or more of the caps bits passed to the callback are incorrect.\0";
	case DDERR_INVALIDCLIPLIST:
	    return "DirectDraw does not support the provided cliplist.\0";
	case DDERR_INVALIDDIRECTDRAWGUID:
	    return "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver identifier.\0";
	case DDERR_INVALIDMODE:
	    return "DirectDraw does not support the requested mode.\0";
	case DDERR_INVALIDOBJECT:
	    return "DirectDraw received a pointer that was an invalid DIRECTDRAW object.\0";
	case DDERR_INVALIDPARAMS:
	    return "One or more of the parameters passed to the function are incorrect.\0";
	case DDERR_INVALIDPIXELFORMAT:
	    return "The pixel format was invalid as specified.\0";
	case DDERR_INVALIDPOSITION:
	    return "Returned when the position of the overlay on the destination is no longer legal for that destination.\0";
	case DDERR_INVALIDRECT:
	    return "Rectangle provided was invalid.\0";
	case DDERR_LOCKEDSURFACES:
	    return "Operation could not be carried out because one or more surfaces are locked.\0";
	case DDERR_NO3D:
	    return "There is no 3D present.\0";
	case DDERR_NOALPHAHW:
	    return "Operation could not be carried out because there is no alpha accleration hardware present or available.\0";
	case DDERR_NOBLTHW:
	    return "No blitter hardware present.\0";
	case DDERR_NOCLIPLIST:
	    return "No cliplist available.\0";
	case DDERR_NOCLIPPERATTACHED:
	    return "No clipper object attached to surface object.\0";
	case DDERR_NOCOLORCONVHW:
	    return "Operation could not be carried out because there is no color conversion hardware present or available.\0";
	case DDERR_NOCOLORKEY:
	    return "Surface doesn't currently have a color key\0";
	case DDERR_NOCOLORKEYHW:
	    return "Operation could not be carried out because there is no hardware support of the destination color key.\0";
	case DDERR_NOCOOPERATIVELEVELSET:
	    return "Create function called without DirectDraw object method SetCooperativeLevel being called.\0";
	case DDERR_NODC:
	    return "No DC was ever created for this surface.\0";
	case DDERR_NODDROPSHW:
	    return "No DirectDraw ROP hardware.\0";
	case DDERR_NODIRECTDRAWHW:
	    return "A hardware-only DirectDraw object creation was attempted but the driver did not support any hardware.\0";
	case DDERR_NOEMULATION:
	    return "Software emulation not available.\0";
	case DDERR_NOEXCLUSIVEMODE:
	    return "Operation requires the application to have exclusive mode but the application does not have exclusive mode.\0";
	case DDERR_NOFLIPHW:
	    return "Flipping visible surfaces is not supported.\0";
	case DDERR_NOGDI:
	    return "There is no GDI present.\0";
	case DDERR_NOHWND:
	    return "Clipper notification requires an HWND or no HWND has previously been set as the CooperativeLevel HWND.\0";
	case DDERR_NOMIRRORHW:
	    return "Operation could not be carried out because there is no hardware present or available.\0";
	case DDERR_NOOVERLAYDEST:
	    return "Returned when GetOverlayPosition is called on an overlay that UpdateOverlay has never been called on to establish a destination.\0";
	case DDERR_NOOVERLAYHW:
	    return "Operation could not be carried out because there is no overlay hardware present or available.\0";
	case DDERR_NOPALETTEATTACHED:
	    return "No palette object attached to this surface.\0";
	case DDERR_NOPALETTEHW:
	    return "No hardware support for 16 or 256 color palettes.\0";
	case DDERR_NORASTEROPHW:
	    return "Operation could not be carried out because there is no appropriate raster op hardware present or available.\0";
	case DDERR_NOROTATIONHW:
	    return "Operation could not be carried out because there is no rotation hardware present or available.\0";
	case DDERR_NOSTRETCHHW:
	    return "Operation could not be carried out because there is no hardware support for stretching.\0";
	case DDERR_NOT4BITCOLOR:
	    return "DirectDrawSurface is not in 4 bit color palette and the requested operation requires 4 bit color palette.\0";
	case DDERR_NOT4BITCOLORINDEX:
	    return "DirectDrawSurface is not in 4 bit color index palette and the requested operation requires 4 bit color index palette.\0";
	case DDERR_NOT8BITCOLOR:
	    return "DirectDrawSurface is not in 8 bit color mode and the requested operation requires 8 bit color.\0";
	case DDERR_NOTAOVERLAYSURFACE:
	    return "Returned when an overlay member is called for a non-overlay surface.\0";
	case DDERR_NOTEXTUREHW:
	    return "Operation could not be carried out because there is no texture mapping hardware present or available.\0";
	case DDERR_NOTFLIPPABLE:
	    return "An attempt has been made to flip a surface that is not flippable.\0";
	case DDERR_NOTFOUND:
	    return "Requested item was not found.\0";
	case DDERR_NOTLOCKED:
	    return "Surface was not locked.  An attempt to unlock a surface that was not locked at all, or by this process, has been attempted.\0";
	case DDERR_NOTPALETTIZED:
	    return "The surface being used is not a palette-based surface.\0";
	case DDERR_NOVSYNCHW:
	    return "Operation could not be carried out because there is no hardware support for vertical blank synchronized operations.\0";
	case DDERR_NOZBUFFERHW:
	    return "Operation could not be carried out because there is no hardware support for zbuffer blitting.\0";
	case DDERR_NOZOVERLAYHW:
	    return "Overlay surfaces could not be z layered based on their BltOrder because the hardware does not support z layering of overlays.\0";
	case DDERR_OUTOFCAPS:
	    return "The hardware needed for the requested operation has already been allocated.\0";
	case DDERR_OUTOFMEMORY:
	    return "DirectDraw does not have enough memory to perform the operation.\0";
	case DDERR_OUTOFVIDEOMEMORY:
	    return "DirectDraw does not have enough memory to perform the operation.\0";
	case DDERR_OVERLAYCANTCLIP:
	    return "The hardware does not support clipped overlays.\0";
	case DDERR_OVERLAYCOLORKEYONLYONEACTIVE:
	    return "Can only have ony color key active at one time for overlays.\0";
	case DDERR_OVERLAYNOTVISIBLE:
	    return "Returned when GetOverlayPosition is called on a hidden overlay.\0";
	case DDERR_PALETTEBUSY:
	    return "Access to this palette is being refused because the palette is already locked by another thread.\0";
	case DDERR_PRIMARYSURFACEALREADYEXISTS:
	    return "This process already has created a primary surface.\0";
	case DDERR_REGIONTOOSMALL:
	    return "Region passed to Clipper::GetClipList is too small.\0";
	case DDERR_SURFACEALREADYATTACHED:
	    return "This surface is already attached to the surface it is being attached to.\0";
	case DDERR_SURFACEALREADYDEPENDENT:
	    return "This surface is already a dependency of the surface it is being made a dependency of.\0";
	case DDERR_SURFACEBUSY:
	    return "Access to this surface is being refused because the surface is already locked by another thread.\0";
	case DDERR_SURFACEISOBSCURED:
	    return "Access to surface refused because the surface is obscured.\0";
	case DDERR_SURFACELOST:
	    return "Access to this surface is being refused because the surface memory is gone. The DirectDrawSurface object representing this surface should have Restore called on it.\0";
	case DDERR_SURFACENOTATTACHED:
	    return "The requested surface is not attached.\0";
	case DDERR_TOOBIGHEIGHT:
	    return "Height requested by DirectDraw is too large.\0";
	case DDERR_TOOBIGSIZE:
	    return "Size requested by DirectDraw is too large, but the individual height and width are OK.\0";
	case DDERR_TOOBIGWIDTH:
	    return "Width requested by DirectDraw is too large.\0";
	case DDERR_UNSUPPORTED:
	    return "Action not supported.\0";
	case DDERR_UNSUPPORTEDFORMAT:
	    return "FOURCC format requested is unsupported by DirectDraw.\0";
	case DDERR_UNSUPPORTEDMASK:
	    return "Bitmask in the pixel format requested is unsupported by DirectDraw.\0";
	case DDERR_VERTICALBLANKINPROGRESS:
	    return "Vertical blank is in progress.\0";
	case DDERR_WASSTILLDRAWING:
	    return "Informs DirectDraw that the previous Blt which is transfering information to or from this Surface is incomplete.\0";
	case DDERR_WRONGMODE:
	    return "This surface can not be restored because it was created in a different mode.\0";
	case DDERR_XALIGN:
	    return "Rectangle provided was not horizontally aligned on required boundary.\0";
	case D3DERR_BADMAJORVERSION:
	    return "D3DERR_BADMAJORVERSION\0";
	case D3DERR_BADMINORVERSION:
	    return "D3DERR_BADMINORVERSION\0";
	case D3DERR_EXECUTE_LOCKED:
	    return "D3DERR_EXECUTE_LOCKED\0";
	case D3DERR_EXECUTE_NOT_LOCKED:
	    return "D3DERR_EXECUTE_NOT_LOCKED\0";
	case D3DERR_EXECUTE_CREATE_FAILED:
	    return "D3DERR_EXECUTE_CREATE_FAILED\0";
	case D3DERR_EXECUTE_DESTROY_FAILED:
	    return "D3DERR_EXECUTE_DESTROY_FAILED\0";
	case D3DERR_EXECUTE_LOCK_FAILED:
	    return "D3DERR_EXECUTE_LOCK_FAILED\0";
	case D3DERR_EXECUTE_UNLOCK_FAILED:
	    return "D3DERR_EXECUTE_UNLOCK_FAILED\0";
	case D3DERR_EXECUTE_FAILED:
	    return "D3DERR_EXECUTE_FAILED\0";
	case D3DERR_EXECUTE_CLIPPED_FAILED:
	    return "D3DERR_EXECUTE_CLIPPED_FAILED\0";
	case D3DERR_TEXTURE_NO_SUPPORT:
	    return "D3DERR_TEXTURE_NO_SUPPORT\0";
	case D3DERR_TEXTURE_NOT_LOCKED:
	    return "D3DERR_TEXTURE_NOT_LOCKED\0";
	case D3DERR_TEXTURE_LOCKED:
	    return "D3DERR_TEXTURELOCKED\0";
	case D3DERR_TEXTURE_CREATE_FAILED:
	    return "D3DERR_TEXTURE_CREATE_FAILED\0";
	case D3DERR_TEXTURE_DESTROY_FAILED:
	    return "D3DERR_TEXTURE_DESTROY_FAILED\0";
	case D3DERR_TEXTURE_LOCK_FAILED:
	    return "D3DERR_TEXTURE_LOCK_FAILED\0";
	case D3DERR_TEXTURE_UNLOCK_FAILED:
	    return "D3DERR_TEXTURE_UNLOCK_FAILED\0";
	case D3DERR_TEXTURE_LOAD_FAILED:
	    return "D3DERR_TEXTURE_LOAD_FAILED\0";
	case D3DERR_MATRIX_CREATE_FAILED:
	    return "D3DERR_MATRIX_CREATE_FAILED\0";
	case D3DERR_MATRIX_DESTROY_FAILED:
	    return "D3DERR_MATRIX_DESTROY_FAILED\0";
	case D3DERR_MATRIX_SETDATA_FAILED:
	    return "D3DERR_MATRIX_SETDATA_FAILED\0";
	case D3DERR_SETVIEWPORTDATA_FAILED:
	    return "D3DERR_SETVIEWPORTDATA_FAILED\0";
	case D3DERR_MATERIAL_CREATE_FAILED:
	    return "D3DERR_MATERIAL_CREATE_FAILED\0";
	case D3DERR_MATERIAL_DESTROY_FAILED:
	    return "D3DERR_MATERIAL_DESTROY_FAILED\0";
	case D3DERR_MATERIAL_SETDATA_FAILED:
	    return "D3DERR_MATERIAL_SETDATA_FAILED\0";
	case D3DERR_LIGHT_SET_FAILED:
	    return "D3DERR_LIGHT_SET_FAILED\0";
	case D3DRMERR_BADOBJECT:
	    return "D3DRMERR_BADOBJECT\0";
	case D3DRMERR_BADTYPE:
	    return "D3DRMERR_BADTYPE\0";
	case D3DRMERR_BADALLOC:
	    return "D3DRMERR_BADALLOC\0";
	case D3DRMERR_FACEUSED:
	    return "D3DRMERR_FACEUSED\0";
	case D3DRMERR_NOTFOUND:
	    return "D3DRMERR_NOTFOUND\0";
	case D3DRMERR_NOTDONEYET:
	    return "D3DRMERR_NOTDONEYET\0";
	case D3DRMERR_FILENOTFOUND:
	    return "The file was not found.\0";
	case D3DRMERR_BADFILE:
	    return "D3DRMERR_BADFILE\0";
	case D3DRMERR_BADDEVICE:
	    return "D3DRMERR_BADDEVICE\0";
	case D3DRMERR_BADVALUE:
	    return "D3DRMERR_BADVALUE\0";
	case D3DRMERR_BADMAJORVERSION:
	    return "D3DRMERR_BADMAJORVERSION\0";
	case D3DRMERR_BADMINORVERSION:
	    return "D3DRMERR_BADMINORVERSION\0";
	case D3DRMERR_UNABLETOEXECUTE:
	    return "D3DRMERR_UNABLETOEXECUTE\0";
	default:
	    return "Unrecognized error value.\0";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dapp\rmmain.cpp ===
/*
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: rmmain.cpp
 *
 *  Each of the Direct3D retained mode (D3DRM) samples must be linked with
 *  this file.  It contains the code which allows them to run in the Windows
 *  environment.
 *
 *  A window is created using the rmmain.res which allows the user to select
 *  the Direct3D driver to use and change the render options.
 *
 *  Individual samples are executed through two functions, BuildScene and
 *  OverrideDefaults, as described in rmdemo.h.  Samples can also read
 *  mouse input via ReadMouse.
 */

#define INITGUID

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <math.h>
#include <direct.h>
#include <d3drmwin.h>
#include "rmdemo.h"             /* prototypes for functions to commumicate
                                   with each sample */
#include "rmmain.h"             /* defines constants used in rmmain.rc */
#include "rmerror.h"            /* prototypes for error reporting: error.c */

#define MAX_DRIVERS 5           /* maximum D3D drivers we ever expect to find */

/* 
 * GLOBAL VARIABLES
 */
LPDIRECT3DRM lpD3DRM;           /* Direct3DRM object */
LPDIRECTDRAWCLIPPER lpDDClipper;/* DirectDrawClipper object */

struct _myglobs {
    LPDIRECT3DRMDEVICE dev;     /* Direct3DRM device */
    LPDIRECT3DRMVIEWPORT view;  /* Direct3DRM viewport through which we view
                                   the scene */
    LPDIRECT3DRMFRAME scene;    /* Master frame in which others are placed */
    LPDIRECT3DRMFRAME camera;   /* Frame describing the users POV */

    GUID DriverGUID[MAX_DRIVERS];     /* GUIDs of the available D3D drivers */
    char DriverName[MAX_DRIVERS][50]; /* names of the available D3D drivers */
    int  NumDrivers;                  /* number of available D3D drivers */
    int  CurrDriver;                  /* number of D3D driver currently
                                         being used */

    D3DRMRENDERQUALITY RenderQuality;   /* current shade mode, fill mode and
                                           lighting state */
    D3DRMTEXTUREQUALITY TextureQuality; /* current texture interpolation */
    BOOL bDithering;                    /* is dithering on? */
    BOOL bAntialiasing;                 /* is antialiasing on? */

    BOOL bQuit;                 /* program is about to terminate */
    BOOL bInitialized;          /* all D3DRM objects have been initialized */
    BOOL bMinimized;            /* window is minimized */
    BOOL bSingleStepMode;       /* render one frame at a time */
    BOOL bDrawAFrame;           /* render on this pass of the main loop */
    BOOL bNoTextures;           /* this sample doesn't use any textures */
    BOOL bConstRenderQuality;   /* this sample is not constructed with
                                   MeshBuilders and so the RenderQuality
                                   cannot be changed */

    int BPP;                    /* bit depth of the current display mode */

    int mouse_buttons;          /* mouse button state */
    int mouse_x;                /* mouse cursor x position */
    int mouse_y;                /* mouse cursor y position */
} myglobs;

/*
 * PROTOTYPES
 */
static HWND InitApp(HINSTANCE, int);
static void InitGlobals(void);
long FAR PASCAL WindowProc(HWND, UINT, WPARAM, LPARAM);
static BOOL CreateDevAndView(LPDIRECTDRAWCLIPPER lpDDClipper, int driver, int width, int height);
static BOOL RenderLoop(void);
static void CleanUpAndPostQuit(void);
static BOOL SetRenderState(void);
static BOOL EnumDevices(HWND win);
extern "C" void ReadMouse(int*, int*, int*);

/****************************************************************************/
/*                               WinMain                                    */
/****************************************************************************/
/*
 * Initializes the application then enters a message loop which renders the
 * scene until a quit message is received.
 */
int PASCAL
WinMain (HINSTANCE this_inst, HINSTANCE prev_inst, LPSTR cmdline, int cmdshow)
{
    HWND    hwnd;
    MSG     msg;
    HACCEL  accel;
    int     failcount = 0;  /* number of times RenderLoop has failed */

    prev_inst;
    cmdline;

    /*
     * Create the window and initialize all objects needed to begin rendering
     */
    if (!(hwnd = InitApp(this_inst, cmdshow)))
        return 1;

    accel = LoadAccelerators(this_inst, "AppAccel");

    while (!myglobs.bQuit) {
        /* 
         * Monitor the message queue until there are no pressing
         * messages
         */
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) {
                CleanUpAndPostQuit();
                break;
            }
            if (!TranslateAccelerator(msg.hwnd, accel, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
	if (myglobs.bQuit)
	    break;
        /* 
         * If the app is not minimized, not about to quit and D3DRM has
         * been initialized, we can render
         */
        if (!myglobs.bMinimized && !myglobs.bQuit && myglobs.bInitialized) {
            /*
             * If were are not in single step mode or if we are and the
             * bDrawAFrame flag is set, render one frame
             */
            if (!(myglobs.bSingleStepMode && !myglobs.bDrawAFrame)) {
                /* 
                 * Attempt to render a frame, if it fails, take a note.  If
                 * rendering fails more than twice, abort execution.
                 */
                if (!RenderLoop())
                    ++failcount;
                if (failcount > 2) {
                    Msg("Rendering has failed too many times.  Aborting execution.\n");
                    CleanUpAndPostQuit();
                    break;
                }
            }
            /*
             * Reset the bDrawAFrame flag if we are in single step mode
             */
            if (myglobs.bSingleStepMode)
                myglobs.bDrawAFrame = FALSE;
        } else {
	    WaitMessage();
	}
    }
    DestroyWindow(hwnd);
    return msg.wParam;
}

/****************************************************************************/
/*                   Initialization and object creation                     */
/****************************************************************************/
/*
 * InitApp
 * Creates window and initializes all objects neccessary to begin rendering
 */
static HWND
InitApp(HINSTANCE this_inst, int cmdshow)
{
    HWND win;
    HDC hdc;
    DWORD flags;
    WNDCLASS wc;
    Defaults defaults;
    HRESULT rval;
    RECT rc;

    /*
     * set up and registers the window class
     */
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(DWORD);
    wc.hInstance = this_inst;
    wc.hIcon = LoadIcon(this_inst, "AppIcon");
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    wc.lpszMenuName = "AppMenu";
    wc.lpszClassName = "D3DRM Example";
    if (!RegisterClass(&wc))
        return FALSE;
    /*
     * Initialize the global variables and allow the sample code to override
     * some of these default settings.
     */
    InitGlobals();
    defaults.bNoTextures = myglobs.bNoTextures;
    defaults.bConstRenderQuality = myglobs.bConstRenderQuality;
    defaults.bResizingDisabled = FALSE;
    lstrcpy(defaults.Name, "D3DRM Example");
    OverrideDefaults(&defaults);
    myglobs.bNoTextures = defaults.bNoTextures;
    myglobs.bConstRenderQuality = defaults.bConstRenderQuality;
    /*
     * Create the window
     */
    if (defaults.bResizingDisabled)
        flags =  WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |
                 WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    else
        flags = WS_OVERLAPPEDWINDOW;
    win =
        CreateWindow
        (   "D3DRM Example",            /* class */
            defaults.Name,              /* caption */
            flags,                      /* style */
            CW_USEDEFAULT,              /* init. x pos */
            CW_USEDEFAULT,              /* init. y pos */
            300,                        /* init. x size */
            300,                        /* init. y size */
            NULL,                       /* parent window */
            NULL,                       /* menu handle */
            this_inst,                  /* program handle */
            NULL                        /* create parms */
        );
    if (!win)
        return FALSE;
    /*
     * Record the current display BPP
     */
    hdc = GetDC(win);
    myglobs.BPP = GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(win, hdc);
    /*
     * Enumerate the D3D drivers and select one
     */
    if (!EnumDevices(win))
        return FALSE;
    /*
     * Create the D3DRM object and the D3DRM window object
     */
    rval = Direct3DRMCreate(&lpD3DRM);
    if (rval != D3DRM_OK) {
        Msg("Failed to create Direct3DRM.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    /*
     * Create the master scene frame and camera frame
     */
    rval = lpD3DRM->CreateFrame(NULL, &myglobs.scene);
    if (rval != D3DRM_OK) {
        Msg("Failed to create the master scene frame.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    rval = lpD3DRM->CreateFrame(myglobs.scene, &myglobs.camera);
    if (rval != D3DRM_OK) {
        Msg("Failed to create the camera's frame.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    rval = myglobs.camera->SetPosition(myglobs.scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0));
    if (rval != D3DRM_OK) {
        Msg("Failed to position the camera in the frame.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    /*
     * Create a clipper and associate the window with it
     */
    rval = DirectDrawCreateClipper(0, &lpDDClipper, NULL);
    if (rval != DD_OK) {
        Msg("Failed to create DirectDrawClipper");
        return FALSE;
    }
    rval = lpDDClipper->SetHWnd(0, win);
    if (rval != DD_OK) {
        Msg("Failed to set hwnd on the clipper");
        return FALSE;
    }
    /*
     * Created the D3DRM device with the selected D3D driver
     */
    GetClientRect(win, &rc);
    if (!CreateDevAndView(lpDDClipper, myglobs.CurrDriver, rc.right, rc.bottom)) {
        return FALSE;
    }
    /*
     * Create the scene to be rendered by calling this sample's BuildScene
     */
    if (!BuildScene(myglobs.dev, myglobs.view, myglobs.scene, myglobs.camera))
        return FALSE;
    /*
     * Now we are ready to render
     */
    myglobs.bInitialized = TRUE;
    /*
     * Display the window
     */
    ShowWindow(win, cmdshow);
    UpdateWindow(win);

    return win;
}

/*
 * CreateDevAndView
 * Create the D3DRM device and viewport with the given D3D driver and of the
 * specified size.
 */
static BOOL
CreateDevAndView(LPDIRECTDRAWCLIPPER lpDDClipper, int driver, int width, int height)
{
    HRESULT rval;

    if (!width || !height) {
        Msg("Cannot create a D3DRM device with invalid window dimensions.");
        return FALSE;
    }
    /*
     * Create the D3DRM device from this window and using the specified D3D
     * driver.
     */
    rval = lpD3DRM->CreateDeviceFromClipper(lpDDClipper, &myglobs.DriverGUID[driver],
                                        width, height, &myglobs.dev);
    if (rval != D3DRM_OK) {
        Msg("Failed to create the D3DRM device from the clipper.\n%s",
            D3DRMErrorToString(rval));
        return FALSE;
    }
    /*
     * Create the D3DRM viewport using the camera frame.  Set the background
     * depth to a large number.  The width and height may be slightly
     * adjusted, so get them from the device to be sure.
     */
    width = myglobs.dev->GetWidth();
    height = myglobs.dev->GetHeight();
    rval = lpD3DRM->CreateViewport(myglobs.dev, myglobs.camera, 0, 0, width,
                                   height, &myglobs.view);
    if (rval != D3DRM_OK) {
        Msg("Failed to create the D3DRM viewport.\n%s",
            D3DRMErrorToString(rval));
        RELEASE(myglobs.dev);
        return FALSE;
    }
    rval = myglobs.view->SetBack(D3DVAL(5000.0));
    if (rval != D3DRM_OK) {
        Msg("Failed to set the background depth of the D3DRM viewport.\n%s",
            D3DRMErrorToString(rval));
        RELEASE(myglobs.dev);
        RELEASE(myglobs.view);
        return FALSE;
    }
    /*
     * Set the render quality, fill mode, lighting state and color shade info
     */
    if (!SetRenderState())
        return FALSE;
    return TRUE;
}

/****************************************************************************/
/*                         D3D Device Enumeration                           */
/****************************************************************************/
/*
 * BPPToDDBD
 * Converts bits per pixel to a DirectDraw bit depth flag
 */
static DWORD
BPPToDDBD(int bpp)
{
    switch(bpp) {
        case 1:
            return DDBD_1;
        case 2:
            return DDBD_2;
        case 4:
            return DDBD_4;
        case 8:
            return DDBD_8;
        case 16:
            return DDBD_16;
        case 24:
            return DDBD_24;
        case 32:
            return DDBD_32;
        default:
            return 0;
    }
}

/*
 * enumDeviceFunc
 * Callback function which records each usable D3D driver's name and GUID
 * Chooses a driver to begin with and sets *lpContext to this starting driver
 */
static HRESULT
WINAPI enumDeviceFunc(LPGUID lpGuid, LPSTR lpDeviceDescription, LPSTR lpDeviceName,
        LPD3DDEVICEDESC lpHWDesc, LPD3DDEVICEDESC lpHELDesc, LPVOID lpContext)
{
    static BOOL hardware = FALSE; /* current start driver is hardware */
    static BOOL mono = FALSE;     /* current start driver is mono light */
    LPD3DDEVICEDESC lpDesc;
    int *lpStartDriver = (int *)lpContext;
    /*
     * Decide which device description we should consult
     */
    lpDesc = lpHWDesc->dcmColorModel ? lpHWDesc : lpHELDesc;
    /*
     * If this driver cannot render in the current display bit depth skip
     * it and continue with the enumeration.
     */
    if (!(lpDesc->dwDeviceRenderBitDepth & BPPToDDBD(myglobs.BPP)))
        return D3DENUMRET_OK;
    /*
     * Record this driver's info
     */
    memcpy(&myglobs.DriverGUID[myglobs.NumDrivers], lpGuid, sizeof(GUID));
    lstrcpy(&myglobs.DriverName[myglobs.NumDrivers][0], lpDeviceName);
    /*
     * Choose hardware over software, RGB lights over mono lights
     */
    if (*lpStartDriver == -1) {
        /*
         * this is the first valid driver
         */
        *lpStartDriver = myglobs.NumDrivers;
        hardware = lpDesc == lpHWDesc ? TRUE : FALSE;
        mono = lpDesc->dcmColorModel & D3DCOLOR_MONO ? TRUE : FALSE;
    } else if (lpDesc == lpHWDesc && !hardware) {
        /*
         * this driver is hardware and start driver is not
         */
        *lpStartDriver = myglobs.NumDrivers;
        hardware = lpDesc == lpHWDesc ? TRUE : FALSE;
        mono = lpDesc->dcmColorModel & D3DCOLOR_MONO ? TRUE : FALSE;
    } else if ((lpDesc == lpHWDesc && hardware ) || (lpDesc == lpHELDesc
                                                     && !hardware)) {
        if (lpDesc->dcmColorModel == D3DCOLOR_MONO && !mono) {
            /*
             * this driver and start driver are the same type and this
             * driver is mono while start driver is not
             */
            *lpStartDriver = myglobs.NumDrivers;
            hardware = lpDesc == lpHWDesc ? TRUE : FALSE;
            mono = lpDesc->dcmColorModel & D3DCOLOR_MONO ? TRUE : FALSE;
        }
    }
    myglobs.NumDrivers++;
    if (myglobs.NumDrivers == MAX_DRIVERS)
        return (D3DENUMRET_CANCEL);
    return (D3DENUMRET_OK);
}

/*
 * EnumDevices
 * Enumerate the available D3D drivers, add them to the file menu, and choose
 * one to use.
 */
static BOOL
EnumDevices(HWND win)
{
    LPDIRECTDRAW lpDD;
    LPDIRECT3D lpD3D;
    HRESULT rval;
    HMENU hmenu;
    int i;

    /*
     * Create a DirectDraw object and query for the Direct3D interface to use
     * to enumerate the drivers.
     */
    rval = DirectDrawCreate(NULL, &lpDD, NULL);
    if (rval != DD_OK) {
        Msg("Creation of DirectDraw HEL failed.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    rval = lpDD->QueryInterface(IID_IDirect3D, (void**) &lpD3D);
    if (rval != DD_OK) {
        Msg("Creation of Direct3D interface failed.\n%s", D3DRMErrorToString(rval));
        lpDD->Release();
        return FALSE;
    }
    /*
     * Enumerate the drivers, setting CurrDriver to -1 to initialize the
     * driver selection code in enumDeviceFunc
     */
    myglobs.CurrDriver = -1;
    rval = lpD3D->EnumDevices(enumDeviceFunc, &myglobs.CurrDriver);
    if (rval != DD_OK) {
        Msg("Enumeration of drivers failed.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    /*
     * Make sure we found at least one valid driver
     */
    if (myglobs.NumDrivers == 0) {
        Msg("Could not find a D3D driver which is compatible with this display depth");
        return FALSE;
    }
    lpD3D->Release();
    lpDD->Release();
    /*
     * Add the driver names to the File menu
     */
    hmenu = GetSubMenu(GetMenu(win), 0);
    for (i = 0; i < myglobs.NumDrivers; i++) {
        InsertMenu(hmenu, 5 + i, MF_BYPOSITION | MF_STRING, MENU_FIRST_DRIVER + i,
                   myglobs.DriverName[i]);
    }
    return TRUE;
}

/****************************************************************************/
/*                             Render Loop                                  */
/****************************************************************************/
/*
 * Clear the viewport, render the next frame and update the window
 */
static BOOL
RenderLoop()
{
    HRESULT rval;
    /*
     * Tick the scene
     */
    rval = myglobs.scene->Move(D3DVAL(1.0));
    if (rval != D3DRM_OK) {
        Msg("Moving scene failed.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    /* 
     * Clear the viewport
     */
    rval = myglobs.view->Clear();
    if (rval != D3DRM_OK) {
        Msg("Clearing viewport failed.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    /*
     * Render the scene to the viewport
     */
    rval = myglobs.view->Render(myglobs.scene);
    if (rval != D3DRM_OK) {
        Msg("Rendering scene failed.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    /*
     * Update the window
     */
    rval = myglobs.dev->Update();
    if (rval != D3DRM_OK) {
        Msg("Updating device failed.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }
    return TRUE;
}


/****************************************************************************/
/*                    Windows Message Handlers                              */
/****************************************************************************/
/*
 * AppAbout
 * About box message handler
 */
BOOL
FAR PASCAL AppAbout(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lParam)
{
  switch (msg)
  {
    case WM_COMMAND:
      if (LOWORD(wparam) == IDOK)
        EndDialog(hwnd, TRUE);
      break;

    case WM_INITDIALOG:
      return TRUE;
  }
  return FALSE;
}

/*
 * WindowProc
 * Main window message handler
 */
LONG FAR PASCAL WindowProc(HWND win, UINT msg, WPARAM wparam, LPARAM lparam)
{
    int i;
    HRESULT rval;
    RECT rc;

    switch (msg)    {
        case WM_LBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_MOUSEMOVE:
            /*
             * Record the mouse state for ReadMouse
             */
            myglobs.mouse_buttons = wparam;
            myglobs.mouse_x = LOWORD(lparam);
            myglobs.mouse_y = HIWORD(lparam);
            break;
        case WM_INITMENUPOPUP:
            /*
             * Check and enable the appropriate menu items
             */
            CheckMenuItem((HMENU)wparam, MENU_STEP,(myglobs.bSingleStepMode) ? MF_CHECKED : MF_UNCHECKED);
            EnableMenuItem((HMENU)wparam, MENU_GO,(myglobs.bSingleStepMode) ? MF_ENABLED : MF_GRAYED);
            if (!myglobs.bConstRenderQuality) {
                CheckMenuItem((HMENU)wparam, MENU_LIGHTING, (myglobs.RenderQuality & D3DRMLIGHT_MASK) == D3DRMLIGHT_ON ? MF_CHECKED : MF_GRAYED);
                CheckMenuItem((HMENU)wparam, MENU_FLAT, (myglobs.RenderQuality & D3DRMSHADE_MASK) == D3DRMSHADE_FLAT ? MF_CHECKED : MF_UNCHECKED);
                CheckMenuItem((HMENU)wparam, MENU_GOURAUD, (myglobs.RenderQuality & D3DRMSHADE_MASK) == D3DRMSHADE_GOURAUD ? MF_CHECKED : MF_UNCHECKED);
                CheckMenuItem((HMENU)wparam, MENU_PHONG, (myglobs.RenderQuality & D3DRMSHADE_MASK) == D3DRMSHADE_PHONG ? MF_CHECKED : MF_UNCHECKED);
                EnableMenuItem((HMENU)wparam, MENU_PHONG, MF_GRAYED);
                CheckMenuItem((HMENU)wparam, MENU_POINT, (myglobs.RenderQuality & D3DRMFILL_MASK) == D3DRMFILL_POINTS ? MF_CHECKED : MF_UNCHECKED);
                CheckMenuItem((HMENU)wparam, MENU_WIREFRAME, (myglobs.RenderQuality & D3DRMFILL_MASK) == D3DRMFILL_WIREFRAME ? MF_CHECKED : MF_UNCHECKED);
                CheckMenuItem((HMENU)wparam, MENU_SOLID, (myglobs.RenderQuality & D3DRMFILL_MASK) == D3DRMFILL_SOLID ? MF_CHECKED : MF_UNCHECKED);
            } else {
                EnableMenuItem((HMENU)wparam, MENU_LIGHTING, MF_GRAYED);
                EnableMenuItem((HMENU)wparam, MENU_FLAT, MF_GRAYED);
                EnableMenuItem((HMENU)wparam, MENU_GOURAUD, MF_GRAYED);
                EnableMenuItem((HMENU)wparam, MENU_PHONG, MF_GRAYED);
                EnableMenuItem((HMENU)wparam, MENU_POINT, MF_GRAYED);
                EnableMenuItem((HMENU)wparam, MENU_WIREFRAME, MF_GRAYED);
                EnableMenuItem((HMENU)wparam, MENU_SOLID, MF_GRAYED);
            }
            if (!myglobs.bNoTextures) {
                CheckMenuItem((HMENU)wparam, MENU_POINT_FILTER, (myglobs.TextureQuality == D3DRMTEXTURE_NEAREST) ? MF_CHECKED : MF_UNCHECKED);
                CheckMenuItem((HMENU)wparam, MENU_LINEAR_FILTER, (myglobs.TextureQuality == D3DRMTEXTURE_LINEAR) ? MF_CHECKED : MF_UNCHECKED);
            } else {
                EnableMenuItem((HMENU)wparam, MENU_POINT_FILTER, MF_GRAYED);
                EnableMenuItem((HMENU)wparam, MENU_LINEAR_FILTER, MF_GRAYED);
            }
            CheckMenuItem((HMENU)wparam, MENU_DITHERING, (myglobs.bDithering) ? MF_CHECKED : MF_UNCHECKED);
            CheckMenuItem((HMENU)wparam, MENU_ANTIALIAS, (myglobs.bAntialiasing) ? MF_CHECKED : MF_UNCHECKED);
            EnableMenuItem((HMENU)wparam, MENU_ANTIALIAS, MF_GRAYED);
            for (i = 0; i < myglobs.NumDrivers; i++) {
                CheckMenuItem((HMENU)wparam, MENU_FIRST_DRIVER + i,
                       (i == myglobs.CurrDriver) ? MF_CHECKED : MF_UNCHECKED);
            }
            break;
        case WM_COMMAND:
            switch(LOWORD(wparam)) {
                case MENU_ABOUT:
                    DialogBox((HINSTANCE)GetWindowLong(win, GWL_HINSTANCE),
                              "AppAbout", win, (DLGPROC)AppAbout);
                    break;
                case MENU_EXIT:
                    CleanUpAndPostQuit();
                    break;
                case MENU_STEP:
                    /*
                     * Begin single step more or draw a frame if in single
                     * step mode
                     */
                    if (!myglobs.bSingleStepMode) {
                        myglobs.bSingleStepMode = TRUE;
                        myglobs.bDrawAFrame = TRUE;
                    } else if (!myglobs.bDrawAFrame) {
                        myglobs.bDrawAFrame = TRUE;
                    }
                    break;
                case MENU_GO:
                    /*
                     * Exit single step mode
                     */
                    myglobs.bSingleStepMode = FALSE;
                    break;
                /*
                 * Lighting toggle
                 */
                case MENU_LIGHTING:
                    myglobs.RenderQuality ^= D3DRMLIGHT_ON;
                    SetRenderState();
                    break;
                /*
                 * Fill mode selection
                 */
                case MENU_POINT:
                    myglobs.RenderQuality = (myglobs.RenderQuality & ~D3DRMFILL_MASK) | D3DRMFILL_POINTS;
                    SetRenderState();
                    break;
                case MENU_WIREFRAME:
                    myglobs.RenderQuality = (myglobs.RenderQuality & ~D3DRMFILL_MASK) | D3DRMFILL_WIREFRAME;
                    SetRenderState();
                    break;
                case MENU_SOLID:
                    myglobs.RenderQuality = (myglobs.RenderQuality & ~D3DRMFILL_MASK) | D3DRMFILL_SOLID;
                    SetRenderState();
                    break;
                /*
                 * Shade mode selection
                 */
                case MENU_FLAT:
                    myglobs.RenderQuality = (myglobs.RenderQuality & ~D3DRMSHADE_MASK) | D3DRMSHADE_FLAT;
                    SetRenderState();
                    break;
                case MENU_GOURAUD:
                    myglobs.RenderQuality = (myglobs.RenderQuality & ~D3DRMSHADE_MASK) | D3DRMSHADE_GOURAUD;
                    SetRenderState();
                    break;
                case MENU_PHONG:
                    myglobs.RenderQuality = (myglobs.RenderQuality & ~D3DRMSHADE_MASK) | D3DRMSHADE_PHONG;
                    SetRenderState();
                    break;

                case MENU_DITHERING:
                    myglobs.bDithering = !myglobs.bDithering;
                    SetRenderState();
                    break;
                case MENU_ANTIALIAS:
                    myglobs.bAntialiasing = !myglobs.bAntialiasing;
                    break;
                /*
                 * Texture filter selection
                 */
                case MENU_POINT_FILTER:
                    if (myglobs.TextureQuality == D3DRMTEXTURE_NEAREST)
                        break;
                    myglobs.TextureQuality = D3DRMTEXTURE_NEAREST;
                    SetRenderState();
                    break;
                case MENU_LINEAR_FILTER:
                    if (myglobs.TextureQuality == D3DRMTEXTURE_LINEAR)
                        break;
                    myglobs.TextureQuality = D3DRMTEXTURE_LINEAR;
                    SetRenderState();
                    break;
                }
                /*
                 * Changing the D3D Driver
                 */
                if (LOWORD(wparam) >= MENU_FIRST_DRIVER &&
                    LOWORD(wparam) < MENU_FIRST_DRIVER + MAX_DRIVERS &&
                    myglobs.CurrDriver != LOWORD(wparam) - MENU_FIRST_DRIVER){
                        /*
                         * Release the current viewport and device and create
                         * the new one
                         */
                        RELEASE(myglobs.view);
                        RELEASE(myglobs.dev);
                        myglobs.CurrDriver = LOWORD(wparam)-MENU_FIRST_DRIVER;
                        GetClientRect(win, &rc);
                        if (!CreateDevAndView(lpDDClipper, myglobs.CurrDriver,
                                              rc.right, rc.bottom)) {
                            CleanUpAndPostQuit();
                        }
                }
                /*
                 * Draw a frame in single step mode after ever command
                 */
                myglobs.bDrawAFrame = TRUE;
            break;
    case WM_DESTROY:
        CleanUpAndPostQuit();
        break;
    case WM_SIZE:
        /*
         * Handle resizing of the window
         */
        {
        int width = LOWORD(lparam);
        int height = HIWORD(lparam);
        if (width && height) {
            int view_width = myglobs.view->GetWidth();
            int view_height = myglobs.view->GetHeight();
            int dev_width = myglobs.dev->GetWidth();
            int dev_height = myglobs.dev->GetHeight();
            /*
             * If the window hasn't changed size and we aren't returning from
             * a minimize, there is nothing to do
             */
            if (view_width == width && view_height == height &&
                !myglobs.bMinimized)
                break;
            if (width <= dev_width && height <= dev_height) {
                /*
                 * If the window has shrunk, we can use the same device with a
                 * new viewport
                 */
                RELEASE(myglobs.view);
                rval = lpD3DRM->CreateViewport(myglobs.dev, myglobs.camera,
                                               0, 0, width, height,
                                               &myglobs.view);
                if (rval != D3DRM_OK) {
                    Msg("Failed to resize the viewport.\n%s",
                        D3DRMErrorToString(rval));
                    CleanUpAndPostQuit();
                    break;
                }
                rval = myglobs.view->SetBack(D3DVAL(5000.0));
                if (rval != D3DRM_OK) {
                    Msg("Failed to set background depth after viewport resize.\n%s",
                        D3DRMErrorToString(rval));
                    CleanUpAndPostQuit();
                    break;
                }
            } else {
                /*
                 * If the window got larger than the current device, create a
                 * new device.
                 */
                RELEASE(myglobs.view);
                RELEASE(myglobs.dev);
                if (!CreateDevAndView(lpDDClipper, myglobs.CurrDriver, width,
                    height)) {
                    CleanUpAndPostQuit();
                    break;
                }
            }
            /*
             * We must not longer be minimized
             */
            myglobs.bMinimized = FALSE;
        } else {
            /*
             * This is a minimize message
             */
            myglobs.bMinimized = TRUE;
        }
        }
        break;
    case WM_ACTIVATE:
        {
        /*
         * Create a Windows specific D3DRM window device to handle this
         * message
         */
        LPDIRECT3DRMWINDEVICE windev;
        if (!myglobs.dev)
            break;
        if (SUCCEEDED(myglobs.dev->QueryInterface(IID_IDirect3DRMWinDevice,
            (void **) &windev)))  {
                if (FAILED(windev->HandleActivate(wparam)))
                    Msg("Failed to handle WM_ACTIVATE.\n");
                windev->Release();
        } else {
            Msg("Failed to create Windows device to handle WM_ACTIVATE.\n");
        }
        }
        break;
    case WM_PAINT:
        if (!myglobs.bInitialized || !myglobs.dev)
            return DefWindowProc(win, msg, wparam, lparam);
        /*
         * Create a Windows specific D3DRM window device to handle this
         * message
         */
        RECT r;
        PAINTSTRUCT ps;
        LPDIRECT3DRMWINDEVICE windev;

        if (GetUpdateRect(win, &r, FALSE)) {
            BeginPaint(win, &ps);
            if (SUCCEEDED(myglobs.dev->QueryInterface(IID_IDirect3DRMWinDevice,
                (void **) &windev))) {
                if (FAILED(windev->HandlePaint(ps.hdc)))
                    Msg("Failed to handle WM_PAINT.\n");
                windev->Release();
            } else {
                Msg("Failed to create Windows device to handle WM_PAINT.\n");
            }
            EndPaint(win, &ps);
        }
        break;
    default:
        return DefWindowProc(win, msg, wparam, lparam);
    }
    return 0L;
}

/*
 * SetRenderState
 * Set the render quality, dither toggle and shade info if any of them has
 * changed
 */
BOOL
SetRenderState(void)
{
    HRESULT rval;
    /*
     * Set the render quality (light toggle, fill mode, shade mode)
     */
    if (myglobs.dev->GetQuality() != myglobs.RenderQuality) {
        rval = myglobs.dev->SetQuality(myglobs.RenderQuality);
        if (rval != D3DRM_OK) {
            Msg("Setting the render quality failed.\n%s",
                D3DRMErrorToString(rval));
            return FALSE;
        }
    }
    /*
     * Set dithering toggle
     */
    if (myglobs.dev->GetDither() != myglobs.bDithering) {
        rval = myglobs.dev->SetDither(myglobs.bDithering);
        if (rval != D3DRM_OK) {
            Msg("Setting dither mode failed.\n%s", D3DRMErrorToString(rval));
            return FALSE;
        }
    }
    /*
     * Set the texture quality (point or linear filtering)
     */
    if (myglobs.dev->GetTextureQuality() != myglobs.TextureQuality) {
        rval = myglobs.dev->SetTextureQuality(myglobs.TextureQuality);
        if (rval != D3DRM_OK) {
            Msg("Setting texture quality failed.\n%s",
                D3DRMErrorToString(rval));
            return FALSE;
        }
    }
    /*
     * Set shade info based on current bits per pixel
     */
    switch (myglobs.BPP) {
        case 1:
            if (FAILED(myglobs.dev->SetShades(4)))
                goto shades_error;
            if (FAILED(lpD3DRM->SetDefaultTextureShades(4)))
                goto shades_error;
            break;
        case 16:
            if (FAILED(myglobs.dev->SetShades(32)))
                goto shades_error;
            if (FAILED(lpD3DRM->SetDefaultTextureColors(64)))
                goto shades_error;
            if (FAILED(lpD3DRM->SetDefaultTextureShades(32)))
                goto shades_error;
            break;
        case 24:
        case 32:
            if (FAILED(myglobs.dev->SetShades(256)))
                goto shades_error;
            if (FAILED(lpD3DRM->SetDefaultTextureColors(64)))
                goto shades_error;
            if (FAILED(lpD3DRM->SetDefaultTextureShades(256)))
                goto shades_error;
            break;
    }
    return TRUE;
shades_error:
    Msg("A failure occurred while setting color shade information.\n");
    return FALSE;
}

/****************************************************************************/
/*                          Additional Functions                            */
/****************************************************************************/
/*
 * ReadMouse
 * Returns the mouse status for interaction with sample code
 */
void
ReadMouse(int* b, int* x, int* y)
{
    *b = myglobs.mouse_buttons;
    *x = myglobs.mouse_x;
    *y = myglobs.mouse_y;
}

/*
 * InitGlobals
 * Initialize the global variables
 */
void
InitGlobals(void)
{
    lpD3DRM = NULL;
    memset(&myglobs, 0, sizeof(myglobs));
    myglobs.RenderQuality = D3DRMLIGHT_ON | D3DRMFILL_SOLID |
                            D3DRMSHADE_GOURAUD;
    myglobs.TextureQuality = D3DRMTEXTURE_NEAREST;
}

/*
 * CleanUpAndPostQuit
 * Release all D3DRM objects, post a quit message and set the bQuit flag
 */
void
CleanUpAndPostQuit(void)
{
    myglobs.bInitialized = FALSE;
    RELEASE(myglobs.scene);
    RELEASE(myglobs.camera);
    RELEASE(myglobs.view);
    RELEASE(myglobs.dev);
    RELEASE(lpD3DRM);
    RELEASE(lpDDClipper);
    myglobs.bQuit = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\d3derror.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3derror.h
 *
 ***************************************************************************/
#ifndef __D3DERROR_H__
#define __D3DERROR_H__

#include <ddraw.h>
#include "d3d.h"

#ifdef __cplusplus
extern "C" {
#endif
    /*
     * Msg
     * Reports errors as dialog box.
     */
    void Msg( LPSTR fmt, ... );
    /*
     * Converts a DD or D3D error to a string
     */
    char* MyErrorToString(HRESULT error);
#ifdef __cplusplus
};
#endif
#endif // __D3DERROR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\d3dtextr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dtextr.c
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ddraw.h>
#include "d3d.h"
#include "d3derror.h"
#include "lclib.h"

#define MAXPATH    256
#define PATHSEP    ';'
#define FILESEP    '\\'
#define MAXCONTENTS 25

static int PathListInitialised = FALSE;

struct {
    int count;
    char *contents[MAXCONTENTS];
} PathList;


void 
AddPathList(const char *path)
{
    char *p;
    char *elt;
    int len;

    while (path) {
	p = LSTRCHR(path, PATHSEP);
	if (p)
	    len = p - path;
	else
	    len = lstrlen(path);
	elt = (char *) malloc(len + 1);
	if (elt == NULL)
	    return;
	lstrcpyn(elt, path, len + 1);
	elt[len] = '\0';
	PathList.contents[PathList.count] = elt;
	PathList.count++;
	if (p)
	    path = p + 1;
	else
	    path = NULL;
	if (PathList.count == MAXCONTENTS)
	    return;
    }
    return;
}

#define RESPATH     "Software\\Microsoft\\Direct3D"
static void 
InitialisePathList()
{
    long result;
    HKEY key;
    DWORD type, size;
    static char buf[512];
    char* path;

    if (PathListInitialised)
	return;
    PathListInitialised = TRUE;

    PathList.count = 0;
    path = getenv("D3DPATH");
    if (path != NULL) {
        AddPathList(path);
        return;
    }
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &key);
    if (result == ERROR_SUCCESS) {
        size = sizeof(buf);
	result = RegQueryValueEx(key, "D3D Path", NULL, &type, (LPBYTE) buf,
	                         &size);
	RegCloseKey(key);
	if (result == ERROR_SUCCESS && type == REG_SZ)
	    AddPathList(buf);
    }
}


/*
 * Open a file using the current search path.
 */
FILE *
FindFile(const char *name, const char *mode)
{
    FILE *fp;
    char buf[MAXPATH];
    static char filesep[] = {FILESEP, 0};
    int i;

    InitialisePathList();

    fp = fopen(name, mode);
    if (fp != NULL)
	return fp;

    for (i = 0; i < PathList.count; i++) {
	lstrcpy(buf, PathList.contents[i]);
	lstrcat(buf, filesep);
	lstrcat(buf, name);
	fp = fopen(buf, mode);
	if (fp)
	    return fp;
    }
    return NULL;
}

void
ReleasePathList(void)
{
    int i;
    for (i = 0; i < PathList.count; i++) {
        free(PathList.contents[i]);
        PathList.contents[i] = NULL;
    }
    PathList.count = 0;
    PathListInitialised = FALSE;
}

/*
 * LoadSurface
 * Loads a ppm file into a texture map DD surface in system memory.
 */
LPDIRECTDRAWSURFACE
LoadSurface(LPDIRECTDRAW lpDD, LPCSTR lpName, LPDDSURFACEDESC lpFormat)
{
    LPDIRECTDRAWSURFACE lpDDS;
    DDSURFACEDESC ddsd, format;
    D3DCOLOR colors[256];
    D3DCOLOR c;
    DWORD dwWidth, dwHeight;
    int i, j;
    FILE *fp;
    char *lpC;
    CHAR buf[100];
    LPDIRECTDRAWPALETTE lpDDPal;
    PALETTEENTRY ppe[256];
    int color_count;
    BOOL bQuant;
    HRESULT ddrval;

    fp = FindFile(lpName, "rb");
    if (fp == NULL) {
        Msg("Cannot find %s.\n", lpName);
	return NULL;
    }
    fgets(buf, sizeof buf, fp);
    if (lstrcmp(buf, "P6\n")) {
	fclose(fp);
        Msg("%s is not a PPM file.\n", lpName);
	return NULL;
    }

    /*
     * Skip comment
     */
    do {
	fgets(buf, sizeof buf, fp);
    } while (buf[0] == '#');
    sscanf(buf, "%d %d\n", &dwWidth, &dwHeight);
    fgets(buf, sizeof buf, fp);	/* skip next line */

    memcpy(&format, lpFormat, sizeof(DDSURFACEDESC));
    if (format.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
        bQuant = TRUE;
    else
        bQuant = FALSE;
    memcpy(&ddsd, &format, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY;
    ddsd.dwHeight = dwHeight;
    ddsd.dwWidth = dwWidth;
    ddrval = lpDD->lpVtbl->CreateSurface(lpDD, &ddsd, &lpDDS, NULL);
    if (ddrval != DD_OK) {
        /*
         * If we failed, it might be the pixelformat flag bug in some ddraw
         * hardware drivers.  Try again without the flag.
         */
        memcpy(&ddsd, &format, sizeof(DDSURFACEDESC));
        ddsd.dwSize = sizeof(DDSURFACEDESC);
        ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
        ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY;
        ddsd.dwHeight = dwHeight;
        ddsd.dwWidth = dwWidth;
        ddrval = lpDD->lpVtbl->CreateSurface(lpDD, &ddsd, &lpDDS, NULL);
        if (ddrval != DD_OK) {
            Msg("CreateSurface for texture failed (loadtex).\n%s", MyErrorToString(ddrval));
	    return NULL;
        }
    }
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddrval = lpDDS->lpVtbl->Lock(lpDDS, NULL, &ddsd, 0, NULL);
    if (ddrval != DD_OK) {
	lpDDS->lpVtbl->Release(lpDDS);
        Msg("Lock failed while loading surface (loadtex).\n%s", MyErrorToString(ddrval));
	return NULL;
    }

    /*
     * If the surface is not 8-bit quantized, it's easy
     */
    if (!bQuant) {
        unsigned long* lpLP;
	unsigned short* lpSP;
        unsigned long m;
        int s;
        int red_shift, red_scale;
        int green_shift, green_scale;
        int blue_shift, blue_scale;
        for (s = 0, m = format.ddpfPixelFormat.dwRBitMask; !(m & 1); s++, m >>= 1);
        red_shift = s;
        red_scale = 255 / (format.ddpfPixelFormat.dwRBitMask >> s);
        for (s = 0, m = format.ddpfPixelFormat.dwGBitMask; !(m & 1); s++, m >>= 1);
        green_shift = s;
        green_scale = 255 / (format.ddpfPixelFormat.dwGBitMask >> s);
        for (s = 0, m = format.ddpfPixelFormat.dwBBitMask; !(m & 1); s++, m >>= 1);
        blue_shift = s;
        blue_scale = 255 / (format.ddpfPixelFormat.dwBBitMask >> s);
	switch (format.ddpfPixelFormat.dwRGBBitCount) {
	    case 32 :
		for (j = 0; j < (int)dwHeight; j++) {
		    lpLP = (unsigned long*)(((char*)ddsd.lpSurface) + ddsd.lPitch * j);
		    for (i = 0; i < (int)dwWidth; i++) {
			int r, g, b;
			r = getc(fp) / red_scale;
			g = getc(fp) / green_scale;
			b = getc(fp) / blue_scale;
			*lpLP = (r << red_shift) | (g << green_shift) | (b << blue_shift);
			lpLP++;
		    }
		}
		break;
	    case 16 :
		for (j = 0; j < (int)dwHeight; j++) {
		    lpSP = (unsigned short*)(((char*)ddsd.lpSurface) + ddsd.lPitch * j);
		    for (i = 0; i < (int)dwWidth; i++) {
			int r, g, b;
			r = getc(fp) / red_scale;
			g = getc(fp) / green_scale;
			b = getc(fp) / blue_scale;
			*lpSP = (r << red_shift) | (g << green_shift) | (b << blue_shift);
			lpSP++;
		    }
		}
		break;
	    default:
	    	lpDDS->lpVtbl->Unlock(lpDDS, NULL);
		fclose(fp);
		lpDDS->lpVtbl->Release(lpDDS);
                Msg("Unknown pixel format (loadtex).");
		return NULL;
	}
	lpDDS->lpVtbl->Unlock(lpDDS, NULL);
        fclose(fp);
        return (lpDDS);
    }

    /*
     * Otherwise, we must palettize it
     */
    color_count = 0;
    for (j = 0; j < (int)dwHeight; j++) {
	lpC = ((char*)ddsd.lpSurface) + ddsd.lPitch * j;
	for (i = 0; i < (int)dwWidth; i++, lpC++) {
	    int r, g, b, k;
	    r = getc(fp);
	    g = getc(fp);
	    b = getc(fp);
            c = RGB_MAKE(r, g, b);
            for (k = 0; k < color_count; k++)
                if (c == colors[k]) break;
            if (k == color_count) {
                color_count++;
                if (color_count > 256)
                    goto burst_colors;
                colors[k] = c;
            }
            *lpC = (char)k;
        }
    }
    fclose(fp);
    lpDDS->lpVtbl->Unlock(lpDDS, NULL);

burst_colors:
    if (color_count > 256) {
        lpDDS->lpVtbl->Unlock(lpDDS, NULL);
	lpDDS->lpVtbl->Release(lpDDS);
        Msg("Palette burst. (loadtex).\n");
	return (NULL);
    }

    /*
     * Now to create a palette
     */
    memset(ppe, 0, sizeof(PALETTEENTRY) * 256);
    for (i = 0; i < color_count; i++) {
	ppe[i].peRed = (unsigned char)RGB_GETRED(colors[i]);
        ppe[i].peGreen = (unsigned char)RGB_GETGREEN(colors[i]);
	ppe[i].peBlue = (unsigned char)RGB_GETBLUE(colors[i]);
    }
    /*
     * D3DPAL_RESERVED entries are ignored by the renderer.
     */
    for (; i < 256; i++)
	ppe[i].peFlags = D3DPAL_RESERVED;
    ddrval = lpDD->lpVtbl->CreatePalette(lpDD, DDPCAPS_8BIT | DDPCAPS_INITIALIZE | DDPCAPS_ALLOW256,
    					 ppe, &lpDDPal, NULL);
    if (ddrval != DD_OK) {
        lpDDS->lpVtbl->Release(lpDDS);
        Msg("Create palette failed while loading surface (loadtex).\n%s", MyErrorToString(ddrval));
	return (NULL);
    }

    /*
     * Finally, bind the palette to the surface
     */
    ddrval = lpDDS->lpVtbl->SetPalette(lpDDS, lpDDPal);
    if (ddrval != DD_OK) {
	lpDDS->lpVtbl->Release(lpDDS);
	lpDDPal->lpVtbl->Release(lpDDPal);
        Msg("SetPalette failed while loading surface (loadtex).\n%s", MyErrorToString(ddrval));
	return (NULL);
    }

    return lpDDS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\d3dtextr.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dtextr.h
 *
 ***************************************************************************/

#ifndef __D3DTEXTR_H__
#define __D3DTEXTR_H__

#include <ddraw.h>

#ifdef __cplusplus
extern "C" {
#endif
    /*
     * LoadSurface
     * Loads an ppm file into a DirectDraw texture map surface in system memory.
     */
    LPDIRECTDRAWSURFACE LoadSurface(LPDIRECTDRAW, LPCSTR, LPDDSURFACEDESC);
    /*
     * ReleasePathList
     * Releases memory allocated when searching for files.
     */
    void ReleasePathList(void);
#ifdef __cplusplus
};
#endif

#endif // __D3DTEXTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\error.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: error.h
 *
 ***************************************************************************/
#ifndef __ERROR_H__
#define __ERROR_H__

#include <ddraw.h>
#include "d3d.h"

#ifdef __cplusplus
extern "C" {
#endif
    /*
     * Msg
     * Reports errors as dialog box.
     */
    void Msg( LPSTR fmt, ... );
    /*
     * Converts a DD or D3D error to a string
     */
    char* MyErrorToString(HRESULT error);
#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\d3dtest.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dtest.cpp
 *
 ***************************************************************************/

#define INITGUID

//#define NOTOPMOST_WINDOW

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <ddraw.h>
#include <d3d.h>
#include <assert.h>
#include "resource.h"
#include "polytest.h"
#include "pixtest.h"
#include "globals.h"
#include "d3dtextr.h"
#include "d3dmacs.h"
#include "error.h"

#define OVERDRAW_IN_PIXEL_TEST 5
#define OBJECTS_IN_THROUGHPUT_TEST 8
#define RINGS_IN_THROUGHPUT_TEST 30
#define SEGS_IN_THROUGHPUT_TEST 30
#define D_IN_THROUGHPUT_TEST 1.0f
#define DEPTH_IN_THROUGHPUT_TEST 0.6f
#define R_IN_THROUGHPUT_TEST 0.4f
#define DV_IN_THROUGHPUT_TEST 0.05f
#define DR_IN_THROUGHPUT_TEST 0.3f
#define OBJECTS_IN_INTERSECTION_TEST 16
#define RINGS_IN_INTERSECTION_TEST 5
#define SEGS_IN_INTERSECTION_TEST 6
#define D_IN_INTERSECTION_TEST 1.6f
#define DEPTH_IN_INTERSECTION_TEST 0.2f
#define R_IN_INTERSECTION_TEST 0.7f
#define DV_IN_INTERSECTION_TEST 0.06f
#define DR_IN_INTERSECTION_TEST 0.2f
#define TEST_INTERVAL 10
#define STARTUP_INTERVAL 2
 
 /*************************************************************************
  Internal Function Declarations
 *************************************************************************/

void CleanUpAndPostQuit(void);
void InitGlobals(void);
BOOL LoadTextures(void);
void ReleaseTextures(void);
BOOL RunPolyTest(float *lpResult);
BOOL RunPixelTest(UINT order, float *lpResult);
BOOL RunIntersectionTest(UINT order, float *lpResult);
BOOL SetRenderState(void);
long FreeVideoMemory(void);
HRESULT CreateDDSurface(LPDDSURFACEDESC lpDDSurfDesc,
                        LPDIRECTDRAWSURFACE FAR *lpDDSurface,
                        IUnknown FAR *pUnkOuter);
BOOL ReleaseD3D(void);
void ReleaseExeBuffers(void);
void dpf( LPSTR fmt, ... );

/************************************************************************
  Globals
 ************************************************************************/
/*
 * Info structures
 */
DDInfo dd;
D3DInfo d3d;
AppInfo app;
StatInfo stat;
TexInfo tex;

int NumTextureFormats;
DDSURFACEDESC TextureFormat[10];
int dx, dy;
/*
 * Last DD or D3D error
 */
HRESULT LastError;
/*
 * What it's all about
 */
#define RESET_TEST 0
#define THROUGHPUT_TEST 1
#define FILL_RATE_TEST 2
#define INTERSECTION_TEST 3
time_t StartTime;

float LastFillRate, PeakFillRateF2B, PeakFillRateB2F;
float LastIntersectionThroughput, PeakIntersectionThroughputF2B, PeakIntersectionThroughputB2F;
float LastThroughput, PeakThroughput;

BOOL IsHardware = FALSE;
DWORD ZDepth, ZType;
BOOL CanSpecular = FALSE;
BOOL CanCopy = FALSE;
BOOL CanMono = FALSE;
BOOL CanRGB = FALSE;
BOOL NoUpdates = FALSE;

/*************************************************************************
  Window shit
 *************************************************************************/

/*
 * WindowProc
 * Window message handler.
 */
long
FAR PASCAL WindowProc(HWND hWnd, UINT message, WPARAM wParam,
			   LPARAM lParam )
{
    POINT p1, p2;

    switch( message ) {
    	case WM_CREATE:
            break;
        case WM_ACTIVATEAPP:
            app.bAppActive = (BOOL)wParam;
            break;
        case WM_SETCURSOR:
            break;
    	case WM_DESTROY:
            break;
    	case WM_MOVE:
	    if (app.bFullscreen)
		break;
  	    p1.x = p1.y = 0;
  	    ClientToScreen(app.hWnd, &p1);
  	    p2.x = 400; p2.y = 400;
  	    ClientToScreen(app.hWnd, &p2);
	    SetRect(&app.rcClient, p1.x, p1.y, p2.x, p2.y);
	    break;
	case WM_SIZE:
            if (app.bIgnoreWM_SIZE)
                break;
            return TRUE;
	    break;
	case WM_ACTIVATE:         
	    if (stat.bHandleActivate && stat.bPrimaryPalettized) {
	    	dd.lpFrontBuffer->SetPalette(dd.lpPalette);
	    }
            break;
        default:
            break;
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

BOOL
CreateHWND(UINT x, UINT y)
{
    static int first = 1;
    RECT rc;
    POINT p1, p2;
    DWORD dwStyle;

    if (first) {
        WNDCLASS wc;
        first = 0;
        /*
         * set up and register window class
         */
        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = WindowProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = app.hInstApp;
        wc.hIcon = 0;
        wc.hCursor = LoadCursor( NULL, IDC_ARROW );
        wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = "Direct3D Test";
        if (!RegisterClass(&wc))
            return FALSE;
    }
    /*
     * create a window
     */
    app.bIgnoreWM_SIZE = TRUE;
    app.hWnd = CreateWindow(
	 "Direct3D Test",
	 "Direct3D Test",
         0,
         0,0,x,y,
         app.hDlg,       /* parent window */
	 NULL,		 /* menu handle */
	 app.hInstApp,	 /* program handle */
	 NULL);		 /* create parms */	
    if (!app.hWnd){
    	Msg("CreateWindow failed");
    	return FALSE;
    }
    UpdateWindow(app.hWnd);
    /*
     * Convert to a normal app window if we are still a WS_POPUP window.
     */
    dwStyle = GetWindowLong(app.hWnd, GWL_STYLE);
    dwStyle &= ~WS_POPUP;
    dwStyle |= WS_OVERLAPPED | WS_CAPTION | WS_THICKFRAME;
    SetWindowLong(app.hWnd, GWL_STYLE, dwStyle);
    SetRect(&rc, 0, 0, 400, 400);
    AdjustWindowRectEx(&rc, GetWindowLong(app.hWnd, GWL_STYLE),
        	       GetMenu(app.hWnd) != NULL,
        	       GetWindowLong(app.hWnd, GWL_EXSTYLE));
    SetWindowPos(app.hWnd, NULL, 0, 0, rc.right-rc.left,
        	 rc.bottom-rc.top,
        	 SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
#ifndef NOTOPMOST_WINDOW
    SetWindowPos(app.hWnd, HWND_TOPMOST, 0, 0, 0, 0,
                 SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);
#else
    SetWindowPos(app.hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
                 SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);
#endif
    app.bIgnoreWM_SIZE = FALSE;
    p1.x = p1.y = 0;
    ClientToScreen(app.hWnd, &p1);
    p2.x = 400; p2.y = 400;
    ClientToScreen(app.hWnd, &p2);
    SetRect(&app.rcClient, p1.x, p1.y, p2.x, p2.y);
    return TRUE;
}

/***********************************************************************************
  Initialization and release
 ***********************************************************************************/

/*
 * GetDDSurfaceDesc
 * Gets a surface description.
 */
BOOL
GetDDSurfaceDesc(LPDDSURFACEDESC lpDDSurfDesc, LPDIRECTDRAWSURFACE lpDDSurf)
{
    memset(lpDDSurfDesc, 0, sizeof(DDSURFACEDESC));
    lpDDSurfDesc->dwSize = sizeof(DDSURFACEDESC);
    LastError = lpDDSurf->GetSurfaceDesc(lpDDSurfDesc);
    if (LastError != DD_OK) {
        Msg("Error getting a surface description.\n%s", MyErrorToString(LastError));
        CleanUpAndPostQuit();
	return FALSE;
    }
    return TRUE;
}

/*
 * InitDD
 * Given an HWND, creates DD surfaces
 */
BOOL
InitDD(HWND hwnd, UINT x, UINT y)
{
    DDSURFACEDESC ddsd;
    if (app.bFullscreen) {
	DDSCAPS ddscaps;
        /*
         * Create a complex flipping surface for fullscreen mode.
         */
        app.bIgnoreWM_SIZE = TRUE;
        LastError = dd.lpDD->SetCooperativeLevel(hwnd, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
        app.bIgnoreWM_SIZE = FALSE;
        if (LastError != DD_OK ) {
            app.bFullscreen = FALSE;
	    Msg("SetCooperativeLevel failed.\n%s", MyErrorToString(LastError));
            return FALSE;
        }
        app.bIgnoreWM_SIZE = TRUE;
        LastError = dd.lpDD->SetDisplayMode(dd.ModeList[dd.CurrentMode].w, dd.ModeList[dd.CurrentMode].h, dd.ModeList[dd.CurrentMode].bpp);
        app.bIgnoreWM_SIZE = FALSE;
        if(LastError != DD_OK ) {
            app.bFullscreen = FALSE;
            Msg("SetDisplayMode (%dx%dx%d) failed\n%s", dd.ModeList[dd.CurrentMode].w, dd.ModeList[dd.CurrentMode].h, dd.ModeList[dd.CurrentMode].bpp, MyErrorToString(LastError));
            return FALSE;
        }
	dx = (int)((float)(dd.ModeList[dd.CurrentMode].w - x) / (float)2.0);
	dy = (int)((float)(dd.ModeList[dd.CurrentMode].h - y) / (float)2.0);
	SetRect(&app.rcClient, dx, dy, dx+400, dy+400);
        memset(&ddsd,0,sizeof(DDSURFACEDESC));
	ddsd.dwSize = sizeof( ddsd );
    	ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
    	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP |
    	    DDSCAPS_3DDEVICE | DDSCAPS_COMPLEX;
    	ddsd.dwBackBufferCount = 1;
        LastError = CreateDDSurface(&ddsd, &dd.lpFrontBuffer, NULL );
    	if(LastError != DD_OK) {
            Msg("CreateSurface for front/back fullscreen buffer failed.\n%s", MyErrorToString(LastError));
            return FALSE;
	}
    	ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
    	LastError = dd.lpFrontBuffer->GetAttachedSurface(&ddscaps, &dd.lpBackBuffer);
    	if(LastError != DD_OK) {
            Msg("GetAttachedSurface failed to get back buffer.\n%s", MyErrorToString(LastError));
    	    return FALSE;
	}
        if (!GetDDSurfaceDesc(&ddsd, dd.lpBackBuffer))
	    return FALSE;
        if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
	    RELEASE(dd.lpBackBuffer);
	    RELEASE(dd.lpFrontBuffer);
	    Msg("Backbuffer failed to go into video memory for fullscreen test.\n");
	    return FALSE;
	}
    } else {
	memset(&ddsd,0,sizeof(DDSURFACEDESC));
	ddsd.dwSize = sizeof(DDSURFACEDESC);
	ddsd.dwFlags = DDSD_CAPS;
	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
	LastError = CreateDDSurface(&ddsd, &dd.lpFrontBuffer, NULL);
	if(LastError != DD_OK ) {
	    Msg("CreateSurface for window front buffer failed.\n%s", MyErrorToString(LastError));
	    return FALSE;
	}
	ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS;
	ddsd.dwHeight = y;
	ddsd.dwWidth = x;
	ddsd.ddsCaps.dwCaps= DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE;
	if (stat.bOnlySystemMemory)
	    ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
	LastError = CreateDDSurface(&ddsd, &dd.lpBackBuffer, NULL);
	if (LastError != DD_OK) {
	    RELEASE(dd.lpFrontBuffer);
	    Msg("CreateSurface for window back buffer failed.\n%s", MyErrorToString(LastError));
	    return FALSE;
	}
	if (!GetDDSurfaceDesc(&ddsd, dd.lpBackBuffer))
	    return FALSE;
	if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
	    stat.bOnlySoftRender = TRUE;
	if (IsHardware && stat.bOnlySoftRender) {
	    RELEASE(dd.lpFrontBuffer);
	    RELEASE(dd.lpBackBuffer);
	    Msg("There was not enough free video memory for the front and/or back buffers for this hardware D3D device.\n");
	    return FALSE;
	}
	/*
	 * Create a DirectDrawClipper object.
	 */
	LastError = dd.lpDD->CreateClipper(0, &dd.lpClipper, NULL);
	if(LastError != DD_OK ) {
	    RELEASE(dd.lpFrontBuffer);
	    RELEASE(dd.lpBackBuffer);
	    Msg("CreateClipper failed.\n%s", MyErrorToString(LastError));
	    return FALSE;
	}
	LastError = dd.lpClipper->SetHWnd(0, hwnd);
	if(LastError != DD_OK ) {
	    RELEASE(dd.lpFrontBuffer);
	    RELEASE(dd.lpBackBuffer);
	    RELEASE(dd.lpClipper);
	    Msg("Clipper SetHWnd failed.\n%s", MyErrorToString(LastError));
	    return FALSE;
	}
	LastError = dd.lpFrontBuffer->SetClipper(dd.lpClipper);
	if(LastError != DD_OK ) {
	    RELEASE(dd.lpFrontBuffer);
	    RELEASE(dd.lpBackBuffer);
	    RELEASE(dd.lpClipper);
	    Msg("SetClipper failed.\n%s", MyErrorToString(LastError));
	    return FALSE;
	}
    }
    /*
     * Palettize if we are not in a 16-bit mode.
     */
    if (!GetDDSurfaceDesc(&ddsd, dd.lpBackBuffer))
	return FALSE;
    if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16) {
	stat.bPrimaryPalettized = TRUE;
    } else {
	stat.bPrimaryPalettized = FALSE;
    }
    if (stat.bPrimaryPalettized) {
	int i;
    	HDC hdc = GetDC(NULL);
	GetSystemPaletteEntries(hdc, 0, (1 << 8), dd.ppe);
	ReleaseDC(NULL, hdc);
        for (i = 0; i < 10; i++) dd.ppe[i].peFlags = D3DPAL_READONLY;
	for (i = 10; i < 256 - 10; i++) dd.ppe[i].peFlags = PC_RESERVED;
        for (i = 256 - 10; i < 256; i++) dd.ppe[i].peFlags = D3DPAL_READONLY;
	LastError = dd.lpDD->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE, dd.ppe, &dd.lpPalette, NULL);
	if (LastError != DD_OK) {
            RELEASE(dd.lpFrontBuffer);
            RELEASE(dd.lpBackBuffer);
            RELEASE(dd.lpClipper);
	    Msg("CreatePalette failed.\n%s", MyErrorToString(LastError));
            return FALSE;
	}
	LastError = dd.lpBackBuffer->SetPalette(dd.lpPalette);
        if(LastError != DD_OK ) {
            RELEASE(dd.lpFrontBuffer);
            RELEASE(dd.lpBackBuffer);
            RELEASE(dd.lpClipper);
            RELEASE(dd.lpPalette);
            Msg("SetPalette back failed.\n%s", MyErrorToString(LastError));
            return FALSE;
	}
	LastError = dd.lpFrontBuffer->SetPalette(dd.lpPalette);
        if(LastError != DD_OK ) {
            RELEASE(dd.lpFrontBuffer);
            RELEASE(dd.lpBackBuffer);
            RELEASE(dd.lpClipper);
            RELEASE(dd.lpPalette);
            Msg("SetPalette failed.\n%s", MyErrorToString(LastError));
            return FALSE;
	}
	stat.bHandleActivate = TRUE;
    }
    return TRUE;
}

BOOL
ReleaseDD(void)
{
    stat.bHandleActivate = FALSE;
    RELEASE(dd.lpPalette);
    RELEASE(dd.lpClipper);
    RELEASE(dd.lpBackBuffer);
    RELEASE(dd.lpFrontBuffer);
    if (app.bFullscreen && dd.lpDD) {
	dd.lpDD->SetCooperativeLevel(app.hWnd, DDSCL_NORMAL);
    }
    return TRUE;
}


BOOL
CreateZBuffer(UINT x, UINT y, DWORD depth, DWORD memorytype)
{
    LPDIRECTDRAWSURFACE lpZBuffer;
    DDSURFACEDESC ddsd;

    /*
     * Create a Z-Buffer and attach it to the back buffer.
     */
    if (app.bFullscreen) {
	x = dd.ModeList[dd.CurrentMode].w;
	y = dd.ModeList[dd.CurrentMode].h;
    }
    memset(&ddsd,0,sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_ZBUFFERBITDEPTH;
    ddsd.dwHeight = y;
    ddsd.dwWidth = x;
    ddsd.dwZBufferBitDepth = depth;
    ddsd.ddsCaps.dwCaps= DDSCAPS_ZBUFFER | memorytype;
    LastError = CreateDDSurface(&ddsd, &lpZBuffer, NULL);
    if (LastError != DD_OK) {
        Msg("CreateSurface for window Z-buffer failed.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    if (!GetDDSurfaceDesc(&ddsd, lpZBuffer))
	return FALSE;
    if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
        stat.bOnlySoftRender = TRUE;
    if (IsHardware && stat.bOnlySoftRender) {
        RELEASE(dd.lpZBuffer);
        Msg("Did not have enough free video memory for Z-buffer for this hardware D3D device.\n");
        return FALSE;
    }
    LastError = dd.lpBackBuffer->AddAttachedSurface(lpZBuffer);
    if(LastError != DD_OK) {
        Msg("AddAttachedBuffer failed for Z-buffer.\n%s",MyErrorToString(LastError));
        return FALSE;
    }
    dd.lpZBuffer = lpZBuffer;
    return TRUE;
}

HRESULT CALLBACK EnumTextureFormatsCallback(LPDDSURFACEDESC lpDDSD, LPVOID lpContext)
{
    if (lpDDSD->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4)
	return DDENUMRET_OK;
    memcpy(&TextureFormat[NumTextureFormats], lpDDSD, sizeof(DDSURFACEDESC));
    NumTextureFormats++;
    return DDENUMRET_OK;
}


BOOL
InitializeTextureLoad(LPDIRECT3DDEVICE lpD3DDevice)
{
    HRESULT ddrval;

    NumTextureFormats = 0;
    ddrval = lpD3DDevice->EnumTextureFormats(EnumTextureFormatsCallback,
                                               NULL);
    if(ddrval != D3D_OK ) {
        return FALSE;
    }
    return TRUE;
}

/*
 * InitD3D
 * Initializes the D3D device and creates the viewport.
 */
BOOL
InitD3D(LPGUID lpGuid, UINT x, UINT y)
{
    if (stat.bZBufferOn) {
        if (!CreateZBuffer(x, y, ZDepth, ZType))
            return FALSE;
    }
    /*
     * Create the device
     */
    LastError = dd.lpBackBuffer->QueryInterface(*lpGuid, (LPVOID*)&d3d.lpD3DDevice);
    if (LastError != DD_OK) {
    	Msg("Create D3D device failed.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    if (!stat.bTexturesDisabled && !InitializeTextureLoad(d3d.lpD3DDevice))
        return FALSE;
    /*
     * Create and setup the viewport which is scaled to the screen mode
     */
    LastError = d3d.lpD3D->CreateViewport(&d3d.lpD3DViewport, NULL);
    if (LastError != D3D_OK) {
    	Msg("Create D3D viewport failed.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    LastError = d3d.lpD3DDevice->AddViewport(d3d.lpD3DViewport);
    if (LastError != D3D_OK) {
    	Msg("Add D3D viewport failed.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    D3DVIEWPORT viewData;
    memset(&viewData, 0, sizeof(D3DVIEWPORT));
    viewData.dwSize = sizeof(D3DVIEWPORT);
    if (app.bFullscreen) {
	viewData.dwX = app.rcClient.left;
	viewData.dwY = app.rcClient.top;
    } else {
	viewData.dwX = viewData.dwY = 0;
    }
    viewData.dwWidth = x;
    viewData.dwHeight = y;
    viewData.dvScaleX = viewData.dwWidth / (float)2.0;
    viewData.dvScaleY = viewData.dwHeight / (float)2.0;
    viewData.dvMaxX = (float)D3DDivide(D3DVAL(viewData.dwWidth), D3DVAL(2 * viewData.dvScaleX));
    viewData.dvMaxY = (float)D3DDivide(D3DVAL(viewData.dwHeight),D3DVAL(2 * viewData.dvScaleY));
    LastError = d3d.lpD3DViewport->SetViewport(&viewData);
    if (LastError != D3D_OK) {
    	Msg("SetViewport failed.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    return TRUE;
}

BOOL
ReleaseD3D(void)
{
    RELEASE(d3d.lpD3DViewport);
    RELEASE(d3d.lpD3DDevice);
    RELEASE(dd.lpZBuffer);
    return TRUE;
}

/*
 * CreateD3DWindow
 * Creates a D3D window of the given size.
 * Load textures and sets the render state.
 */
BOOL
CreateD3DWindow(LPGUID lpDeviceGUID)
{
    stat.bOnlySoftRender = FALSE;

    if (!CreateHWND(400, 400))
        return FALSE;
    /* 
     * Initialize fullscreen DD and the D3DDevice
     */
    if (!(InitDD(app.hWnd, 400, 400))) {
        SetWindowPos(app.hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
        	     SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE| SWP_HIDEWINDOW);
        DestroyWindow(app.hWnd);
        return FALSE;
    }
    if (!(InitD3D(lpDeviceGUID, 400, 400))) {
        SetWindowPos(app.hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
        	     SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE| SWP_HIDEWINDOW);
        DestroyWindow(app.hWnd);
        ReleaseDD();
        return FALSE;
    }
    /*
     * Load the textures.
     */
    if (!(LoadTextures())) {
        SetWindowPos(app.hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
        	     SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE| SWP_HIDEWINDOW);
        DestroyWindow(app.hWnd);
        ReleaseD3D();
        ReleaseDD();
        return FALSE;
    }
    /*
     * Set the render state
     */
    if (!(SetRenderState())) {
        SetWindowPos(app.hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
        	     SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE| SWP_HIDEWINDOW);
        DestroyWindow(app.hWnd);
        ReleaseTextures();
        ReleaseD3D();
        ReleaseDD();
        return FALSE;
    }
    return TRUE;
}

BOOL
ReleaseD3DWindow(void)
{
    if (app.bFullscreen && dd.lpDD) {
	dd.lpDD->RestoreDisplayMode();
    }
    SetWindowPos(app.hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
        	 SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE| SWP_HIDEWINDOW);
    ReleaseTextures();
    ReleasePathList();
    if (!(ReleaseD3D()))
        return FALSE;
    if (!(ReleaseDD()))
        return FALSE;
    DestroyWindow(app.hWnd);
    return TRUE;
}

/*********************************************************************************
  Connection and disconnection
 *********************************************************************************/

BOOL FAR PASCAL DDEnumCallback(GUID FAR* lpGUID, LPSTR lpDriverDesc, LPSTR lpDriverName, LPVOID lpContext)
{
    LPDIRECTDRAW lpDD;
    DDCAPS DriverCaps, HELCaps;
    lpContext;

    if (lpGUID) {
	LastError = DirectDrawCreate(lpGUID, &lpDD, NULL);
	if (LastError != DD_OK) {
	    Msg("Failing while creating a DD device for testing.  Continuing with execution.\n%s", MyErrorToString(LastError));
	    return DDENUMRET_OK;
	}
	memset(&DriverCaps, 0, sizeof(DDCAPS));
	DriverCaps.dwSize = sizeof(DDCAPS);
	memset(&HELCaps, 0, sizeof(DDCAPS));
	HELCaps.dwSize = sizeof(DDCAPS);
	LastError = lpDD->GetCaps(&DriverCaps, &HELCaps);
	if (LastError != DD_OK) {
	    Msg("GetCaps failed in while testing a DD device.  Continuing with execution.\n%s", MyErrorToString(LastError));
	    RELEASE(dd.lpDD);
	    return DDENUMRET_OK;
	}
	RELEASE(dd.lpDD);
	if (DriverCaps.dwCaps & DDCAPS_3D) {
	    /*
	     * We have found a 3d hardware device
	     */
	    memcpy(&dd.Driver[dd.NumDrivers].guid, lpGUID, sizeof(GUID));
	    memcpy(&dd.Driver[dd.NumDrivers].HWCaps, &DriverCaps, sizeof(DDCAPS));
	    lstrcpy(dd.Driver[dd.NumDrivers].Name, lpDriverName);
	    dd.Driver[dd.NumDrivers].bIsPrimary = FALSE;
	    dd.CurrentDriver = dd.NumDrivers;
	    ++dd.NumDrivers;
	    if (dd.NumDrivers == 5)
		return (D3DENUMRET_CANCEL);
	}
    } else {
	/*
	 * It's the primary, fill in some fields.
	 */
	dd.Driver[dd.NumDrivers].bIsPrimary = TRUE;
	lstrcpy(dd.Driver[dd.NumDrivers].Name, "Primary Device");
	dd.CurrentDriver = dd.NumDrivers;
	++dd.NumDrivers;
	if (dd.NumDrivers == 5)
	    return (D3DENUMRET_CANCEL);
    }
    return DDENUMRET_OK;
}

BOOL
EnumDDDrivers()
{
    dd.NumDrivers = 0;
    dd.CurrentDriver = 0; 
    LastError = DirectDrawEnumerate(DDEnumCallback, NULL);
    if (LastError != DD_OK) {
	Msg("DirectDrawEnumerate failed.\n%s", MyErrorToString(LastError));
	return FALSE;
    }
    return TRUE;
}

/*
 * GetDDCaps
 * Determines Z buffer depth.
 */
BOOL
GetDDCaps(void)
{
    DDCAPS DriverCaps, HELCaps;

    memset(&DriverCaps, 0, sizeof(DriverCaps));
    DriverCaps.dwSize = sizeof(DDCAPS);
    memset(&HELCaps, 0, sizeof(HELCaps));
    HELCaps.dwSize = sizeof(DDCAPS);
    LastError = dd.lpDD->GetCaps(&DriverCaps, &HELCaps);
    if (LastError != DD_OK) {
        Msg("GetCaps failed in while checking driver capabilities.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    memcpy(&dd.HWddsCaps, &DriverCaps.ddsCaps, sizeof(DDSCAPS));
    return TRUE;
}

/*
 * enumDeviceFunc
 * Enumeration function for EnumDevices
 */
HRESULT WINAPI enumDeviceFunc(LPGUID lpGuid,
	LPSTR lpDeviceDescription, LPSTR lpDeviceName,
	LPD3DDEVICEDESC lpHWDesc, LPD3DDEVICEDESC lpHELDesc, LPVOID lpContext)
{
    d3d.Driver[d3d.NumDrivers].lpGuid = lpGuid;
    lstrcpy(d3d.Driver[d3d.NumDrivers].Desc, lpDeviceDescription);
    lstrcpy(d3d.Driver[d3d.NumDrivers].Name, lpDeviceName);
    memcpy(&d3d.Driver[d3d.NumDrivers].HWDesc, lpHWDesc, sizeof(D3DDEVICEDESC));
    memcpy(&d3d.Driver[d3d.NumDrivers].HELDesc, lpHELDesc, sizeof(D3DDEVICEDESC));
    d3d.NumDrivers++;
    if (d3d.NumDrivers == 5)
        return (D3DENUMRET_CANCEL);
    return (D3DENUMRET_OK);
}

/*
 * EnumDisplayModesCallback
 * Callback to save the display mode information.
 */
HRESULT CALLBACK EnumDisplayModesCallback(LPDDSURFACEDESC pddsd, LPVOID Context)
{
    if (pddsd->dwWidth >= 400 && pddsd->dwHeight >= 400 && pddsd->ddpfPixelFormat.dwRGBBitCount == 16) {
	dd.ModeList[dd.NumModes].w = pddsd->dwWidth;
	dd.ModeList[dd.NumModes].h = pddsd->dwHeight;
	dd.ModeList[dd.NumModes].bpp = pddsd->ddpfPixelFormat.dwRGBBitCount;
	dd.NumModes++;
    }
    return DDENUMRET_OK;
}

/*
 * CompareModes
 * Compare two display modes for sorting purposes.
 */
int _cdecl CompareModes(const void* element1, const void* element2) {
    ModeListElement *lpMode1, *lpMode2;

    lpMode1 = (ModeListElement*)element1;
    lpMode2 = (ModeListElement*)element2;

    // XXX
    if (lpMode1->w < lpMode2->w)
        return -1;
    else if (lpMode2->w < lpMode1->w)
        return 1;
    else if (lpMode1->h < lpMode2->h)
        return -1;
    else if (lpMode2->h < lpMode1->h)
        return 1;
    else
        return 0;
}


BOOL
EnumerateDisplayModes()
{
    LastError = dd.lpDD->EnumDisplayModes(0, NULL, 0, EnumDisplayModesCallback);
    if(LastError != DD_OK ) {
        Msg("EnumDisplayModes failed.\n%s", MyErrorToString(LastError));
         return FALSE;
    }
    qsort((void *)&dd.ModeList[0], (size_t) dd.NumModes, sizeof(ModeListElement),
          CompareModes);
    if (dd.NumModes == 0) {
	Msg("The available display modes are not of sufficient size or are not 16-bit\n");
	return FALSE;
    }
    dd.CurrentMode = 0;
    return TRUE;
}

/*
 * Connect
 * Creates the DD and D3D objects, enumerates available devices and
 * gets the DD capabilites.
 */
BOOL
Connect(void)
{
    if (dd.Driver[dd.CurrentDriver].bIsPrimary) {
	app.bFullscreen = FALSE;
	LastError = DirectDrawCreate(NULL, &dd.lpDD, NULL);
	if (LastError != DD_OK) {
	    Msg("DirectDrawCreate failed.\n%s", MyErrorToString(LastError));
	    return FALSE;
	}
    } else {
	/*
	 * If it's not the primary device, assume we can only do fullscreen.
	 */
	app.bFullscreen = TRUE;
	LastError = DirectDrawCreate(&dd.Driver[dd.CurrentDriver].guid, &dd.lpDD, NULL);
	if (LastError != DD_OK) {
	    Msg("DirectDrawCreate failed.\n%s", MyErrorToString(LastError));
	    return FALSE;
	}
        if (!EnumerateDisplayModes())
            return FALSE;
    }
    app.bIgnoreWM_SIZE = TRUE;
    LastError = dd.lpDD->SetCooperativeLevel(app.hDlg, DDSCL_NORMAL);
    if(LastError != DD_OK ) {
	Msg("SetCooperativeLevel failed.\n%s", MyErrorToString(LastError));
	return FALSE;
    }
    app.bIgnoreWM_SIZE = FALSE;
    LastError = dd.lpDD->QueryInterface(IID_IDirect3D, (LPVOID*)&d3d.lpD3D);
    if (LastError != DD_OK) {
        Msg("Creation of IDirect3D failed.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    GetDDCaps();
    d3d.NumDrivers = 0;
    LastError = d3d.lpD3D->EnumDevices(enumDeviceFunc, NULL);
    if (LastError != DD_OK) {
        Msg("EnumDevices failed.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    return TRUE;
}

BOOL
Disconnect(void)
{
    RELEASE(d3d.lpD3D);
    RELEASE(dd.lpDD);
    return TRUE;
}

/*************************************************************************
  Texture map loading
 *************************************************************************/

/*
 * CreateVidTex
 * Create a texture in video memory (if appropriate).
 * If no hardware exists, this will be created in system memory, but we
 * can still use load to swap textures.
 */
BOOL
CreateVidTex(LPDIRECTDRAWSURFACE lpSrcSurf,
             LPDIRECTDRAWSURFACE *lplpDstSurf, LPDIRECT3DTEXTURE *lplpDstTex)
{
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWPALETTE lpDDPal = NULL;
    PALETTEENTRY ppe[256];
    BOOL bQuant;

    if (!GetDDSurfaceDesc(&ddsd, lpSrcSurf))
	return FALSE;
    if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
        bQuant = TRUE;
    else
        bQuant = FALSE;
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    if (stat.bOnlySystemMemory)
        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
    LastError = CreateDDSurface(&ddsd, lplpDstSurf, NULL);
    if (LastError != DD_OK) {
        Msg("Create surface in CreateVidTexture failed.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    if (!GetDDSurfaceDesc(&ddsd, *lplpDstSurf))
	return FALSE;
    if (dd.HWddsCaps.dwCaps & DDSCAPS_TEXTURE && !(ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
        stat.bOnlySoftRender = TRUE;
    if (IsHardware && stat.bOnlySoftRender) {
        Msg("Failed to put texture surface in video memory for hardware D3D device.\n");
        return FALSE;
    }
    if (bQuant) {
        memset(ppe, 0, sizeof(PALETTEENTRY) * 256);
	LastError = dd.lpDD->CreatePalette(DDPCAPS_8BIT, ppe, &lpDDPal, NULL);
	if (LastError != DD_OK) {
            RELEASE((*lplpDstSurf));
            Msg("CreatePalette in CreateVidTexture failed.\n%s", MyErrorToString(LastError));
            return FALSE;
	}
	LastError = (*lplpDstSurf)->SetPalette(lpDDPal);
	if (LastError != DD_OK) {
            RELEASE((*lplpDstSurf));
            RELEASE(lpDDPal);
            Msg("SetPalette in CreateVidTexture failed.\n%s", MyErrorToString(LastError));
            return FALSE;
	}
    }
    LastError = (*lplpDstSurf)->QueryInterface(IID_IDirect3DTexture, (LPVOID*)lplpDstTex);
    if (LastError != D3D_OK) {
        RELEASE((*lplpDstSurf));
        RELEASE(lpDDPal);
        Msg("QueryInterface in CreateVidTexture failed.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    return TRUE;
}
                   
/*
 * LoadTextures
 * If textures are on, load textures from image files.
 */
BOOL
LoadTextures(void)
{
    int i, t;
    HRESULT ddrval;
    /*
     * If textures are not on or are disabled, set all the handles to zero.
     */
    if (!stat.bTexturesOn || stat.bTexturesDisabled) {
        for (i = 0; i < tex.NumTextures; i++)
            tex.TextureDstHandle[i] = 0;
        return TRUE;
    }
    /*
     * Load each image file as a "source" texture surface in system memory.
     * Load each source texture surface into a "destination" texture (in video
     * memory if appropriate).  The destination texture handles are used in
     * rendering.  This scheme demos the Load call and allows dynamic texture
     * swapping.
     */
    for (i = 0, t = tex.FirstTexture; i < tex.NumTextures; i++, t++) {
	PALETTEENTRY ppe[256];
	LPDIRECTDRAWPALETTE lpDDPalSrc, lpDDPalDst;
	DDSURFACEDESC ddsd;

        if (t >= tex.NumTextures)
            t = 0;
	if (stat.TextureBlend == D3DTBLEND_COPY) {
	    if (!GetDDSurfaceDesc(&ddsd, dd.lpFrontBuffer))
		return FALSE;
	    if (ddsd.ddpfPixelFormat.dwRGBBitCount != 8 && ddsd.ddpfPixelFormat.dwRGBBitCount != 16) {
		Msg("Copy mode cannot be tested in this display depth.  Change display mode and try again.");
		return FALSE;
	    }
	    ddsd.dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT;
	    ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
	    if (stat.bOnlySystemMemory)
		ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;   
	    if (!(tex.lpSrcTextureSurface[i] = LoadSurface(dd.lpDD, tex.ImageFile[i], &ddsd))) {
		    return FALSE;
	    }
	} else {
	    if (!(tex.lpSrcTextureSurface[i] = LoadSurface(dd.lpDD, tex.ImageFile[i], &TextureFormat[0]))) {
		    return FALSE;
	    }
	}
        LastError = tex.lpSrcTextureSurface[i]->QueryInterface(IID_IDirect3DTexture,
				       (LPVOID*)&tex.lpSrcTextureObject[i]);
	if (LastError != DD_OK) {
		Msg("Could not create texture.\n%s", MyErrorToString(LastError));
		return FALSE;;
	}
#if 0
	if (tex.lpSrcTextureObject[i]->GetHandle(d3d.lpD3DDevice, &tex.TextureSrcHandle[i])) {
		Msg("Could not get handle.");
		return FALSE;
	}
#endif
        if (!CreateVidTex(tex.lpSrcTextureSurface[i], &tex.lpDstTextureSurface[t],
                          &tex.lpDstTextureObject[t]))
            return FALSE;
	LastError = tex.lpDstTextureObject[t]->GetHandle(d3d.lpD3DDevice, &tex.TextureDstHandle[t]);
	if (LastError != DD_OK) {
		Msg("Could not get handle for destination texture handle.\n%s", MyErrorToString(LastError));
		return FALSE;
	}
	if (tex.lpDstTextureSurface[i]->Blt(NULL, tex.lpSrcTextureSurface[i], NULL, DDBLT_WAIT, NULL) != DD_OK) {
		Msg("Could not load src texture into dest.");
		return FALSE;
	}
	ddrval = tex.lpSrcTextureSurface[i]->GetPalette(&lpDDPalSrc);
	if (ddrval != DD_OK && ddrval == DDERR_NOPALETTEATTACHED) {
		continue;
	}
	if (ddrval != DD_OK) {
		Msg("Could not get source palette");
		return FALSE;
	}
	ddrval = tex.lpDstTextureSurface[i]->GetPalette(&lpDDPalDst);
	if (ddrval != DD_OK) {
		Msg("Could not get dest palette");
		return FALSE;
	}
	ddrval = lpDDPalSrc->GetEntries(0, 0, 256, ppe);
	if (ddrval != DD_OK) {
		Msg("Could not get source palette entries");
		return FALSE;
	}
	ddrval = lpDDPalDst->SetEntries(0, 0, 256, ppe);
	if (ddrval != DD_OK) {
		Msg("Could not get source palette entries");
		return FALSE;
	}
	lpDDPalDst->Release();
	lpDDPalSrc->Release();

    }
    return TRUE;
}

/***********************************************************************************
  Miscellaneous DirectDraw functions
 ***********************************************************************************/

/*
 * FreeVideoMemory
 * Checks to see if there is enough free video memory
 */
long
FreeVideoMemory(void)
{
    DDCAPS ddcaps;
    memset(&ddcaps, 0, sizeof(ddcaps));
    ddcaps.dwSize = sizeof( ddcaps );
    LastError = dd.lpDD->GetCaps(&ddcaps, NULL );
    if(LastError != DD_OK ){
        Msg("GetCaps failed while checking for free memory.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    return ddcaps.dwVidMemFree;
}
 

/*
 * CreateDDSurface
 * Used to create surfaces instead of calling DD directly.
 */
HRESULT
CreateDDSurface(LPDDSURFACEDESC lpDDSurfDesc,
                LPDIRECTDRAWSURFACE FAR *lpDDSurface,
                IUnknown FAR *pUnkOuter) {
    HRESULT result;
    result = dd.lpDD->CreateSurface(lpDDSurfDesc, lpDDSurface, pUnkOuter);
    return result;
}


/*************************************************************************
  Tests
 *************************************************************************/
/*
 * RestoreSurfaces
 * Restores any lost surfaces.
 */
BOOL
RestoreSurfaces()
{
    int i;
    if (dd.lpFrontBuffer->IsLost() == DDERR_SURFACELOST) {
        LastError = dd.lpFrontBuffer->Restore();
        if (LastError != DD_OK) {
            Msg("Restore of front buffer failed.\n%s", MyErrorToString(LastError));
            return FALSE;
        }
    }
    if (dd.lpBackBuffer->IsLost() == DDERR_SURFACELOST) {
        LastError = dd.lpBackBuffer->Restore();
        if (LastError != DD_OK) {
            Msg("Restore of back buffer failed.\n%s", MyErrorToString(LastError));
            return FALSE;
        }
    }
    if (dd.lpZBuffer && dd.lpZBuffer->IsLost() == DDERR_SURFACELOST) {
        LastError = dd.lpZBuffer->Restore();
        if (LastError != DD_OK) {
            Msg("Restore of Z-buffer failed.\n%s", MyErrorToString(LastError));
            return FALSE;
        }
    }
    if (stat.bTexturesOn && !stat.bTexturesDisabled) {
        for (i = 0; i < tex.NumTextures; i++) {
            if (tex.lpSrcTextureSurface[i]->IsLost() == DDERR_SURFACELOST) {
                LastError = tex.lpSrcTextureSurface[i]->Restore();
                if (LastError != DD_OK) {
                    Msg("Restore of a src texture surface failed.\n%s", MyErrorToString(LastError));
                    return FALSE;
                }
            }
            if (tex.lpDstTextureSurface[i]->IsLost() == DDERR_SURFACELOST) {
                LastError = tex.lpDstTextureSurface[i]->Restore();
                if (LastError != DD_OK) {
                    Msg("Restore of a dst texture surface failed.\n%s", MyErrorToString(LastError));
                    return FALSE;
                }
            }
        }
    }
    return TRUE;
}


/*
 * RenderLoop
 * Application idle loop which renders.
 */
BOOL
RenderLoop(UINT TestType)
{
    static D3DRECT last, lastlast;
    static BOOL clearlast, clearlastlast;
    UINT ClearFlags;
    RECT src, dst;

    if (TestType == RESET_TEST) {
        /*
         * Clear the screen and set clear flags to false
         */
	if (app.bFullscreen) {
#if 0
	    DDBLTFX ddbltfx;
	    memset(&ddbltfx, 0, sizeof(ddbltfx));
	    ddbltfx.dwSize = sizeof(DDBLTFX);
	    SetRect(&dst, 0, 0,
		    dd.ModeList[dd.CurrentMode].w,
		    dd.ModeList[dd.CurrentMode].h);
	    LastError = dd.lpFrontBuffer->Blt(&dst, NULL, 
					      NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx);
	    if (LastError != DD_OK) {
		Msg("Clearing blt failed.\n%s", MyErrorToString(LastError));
		return FALSE;
	    }
#endif
	    last.x1 = dx;
	    last.y1 = dy;
	    last.x2 = dx + 400;
	    last.y2 = dy + 400;
	    lastlast.x1 = dx;
	    lastlast.y1 = dy;
	    lastlast.x2 = dx + 400;
	    lastlast.y2 = dy + 400;
	} else {
	    last.x1 = last.y1 = 0;
	    last.x2 = 400;
	    last.y2 = 400;
	    ClearFlags = D3DCLEAR_TARGET;
	    if (stat.bZBufferOn)
		ClearFlags |= D3DCLEAR_ZBUFFER;
	    LastError = d3d.lpD3DViewport->Clear(1, &last, ClearFlags);
	    if (LastError != D3D_OK) {
		Msg("Initial viewport clear failed.\n%s", MyErrorToString(LastError));
		return FALSE();
	    }
	    SetRect(&src, 0, 0, 400, 400);
	    LastError = dd.lpFrontBuffer->Blt(&app.rcClient, dd.lpBackBuffer, 
					      &src, DDBLT_WAIT, NULL);
	    if (LastError != DD_OK) {
		Msg("Blt of back to front buffer failed.\n%s", MyErrorToString(LastError));
		return FALSE;
	    }
	    clearlast = FALSE;
	}
        return TRUE;
    }
    if (!RestoreSurfaces())
	return FALSE;
    /*
     * Clear back buffer and Z buffer if enabled
     */
    if (app.bFullscreen) {
	if (stat.bClearsOn) {
	    LPD3DRECT lpClearRect;
	    lpClearRect = &lastlast;
	    if (TestType == FILL_RATE_TEST || TestType == INTERSECTION_TEST)
		LastError = d3d.lpD3DViewport->Clear(1, lpClearRect, D3DCLEAR_ZBUFFER);
	    else {
		if (!NoUpdates)
		    // Clearing both is fine because both must be on or off
		    LastError = d3d.lpD3DViewport->Clear(1, lpClearRect, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER);
		else
		    LastError = d3d.lpD3DViewport->Clear(1, lpClearRect, D3DCLEAR_ZBUFFER);
	    }
	    if (LastError != D3D_OK) {
		Msg("Viewport clear failed.\n%s", MyErrorToString(LastError));
		return FALSE;
	    }
	}
        lastlast = last;
        clearlastlast = clearlast;
    } else {
	if (clearlast) {
	    LPD3DRECT lpClearRect;
	    lpClearRect = &last;
	    if (!NoUpdates)
		// Clearing both is fine because both must be on or off
		LastError = d3d.lpD3DViewport->Clear(1, lpClearRect, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER);
	    else
		LastError = d3d.lpD3DViewport->Clear(1, lpClearRect, D3DCLEAR_ZBUFFER);
	    if (LastError != D3D_OK) {
		Msg("Viewport clear failed.\n%s", MyErrorToString(LastError));
		return FALSE;
	    }
	    lastlast = last;
	}
    }
    if (TestType == THROUGHPUT_TEST || TestType == INTERSECTION_TEST) {
        if (!RenderScenePoly(d3d.lpD3DDevice, d3d.lpD3DViewport, &last)) {
                Msg("RenderScenePoly failed.\n");
                return FALSE;
        }
    } else if (TestType == FILL_RATE_TEST) {
        if (!RenderScenePix(d3d.lpD3DDevice, d3d.lpD3DViewport, &last)) {
                Msg("RenderScenePix failed.\n");
                return FALSE;
        }
	/*
	 * Because extents are not correct
	 */
	if (app.bFullscreen) {
	    last.x1 = dx;
	    last.y1 = dy;
	    last.x2 = dx+400;
	    last.y2 = dy+400;
	} else {
	    last.x1 = 0;
	    last.y1 = 0;
	    last.x2 = 400;
	    last.y2 = 400;
	}
    } else {
        Msg("Bad TestStatus.\n");
        return FALSE;
    }
    if (app.bFullscreen) {
	if (!NoUpdates) {
	    LastError = dd.lpFrontBuffer->Flip(dd.lpBackBuffer, 1);
	    if (LastError != DD_OK) {
		Msg("Flip failed.\n%s", MyErrorToString(LastError));
		return FALSE;
	    }
	}
    } else {
	if (clearlast) {
	    if (lastlast.x1 < last.x1)
		last.x1 = lastlast.x1;
	    if (lastlast.y1 < last.y1)
		last.y1 = lastlast.y1;
	    if (lastlast.x2 > last.x2)
		last.x2 = lastlast.x2;
	    if (lastlast.y2 > last.y2)
		last.y2 = lastlast.y2;
	}
	if (stat.bClearsOn) {
	    clearlast = TRUE;
	} else
	    clearlast = FALSE;
	SetRect(&src, last.x1, last.y1, last.x2, last.y2);
	SetRect(&dst,
		last.x1 + app.rcClient.left,
		last.y1 + app.rcClient.top,
		last.x2 + app.rcClient.left,
		last.y2 + app.rcClient.top);
	if (!NoUpdates) {
	    LastError = dd.lpFrontBuffer->Blt(&dst, dd.lpBackBuffer, 
					      &src, DDBLT_WAIT, NULL);
	    if (LastError != DD_OK) {
		Msg("Blt of back to front buffer failed.\n%s", MyErrorToString(LastError));
		return FALSE;
	    }
	}
    }
    return TRUE;
}

float
Timer()
{
    time_t now;
    now = clock();
    return ((float)(now - StartTime)) / (float)CLOCKS_PER_SEC;
}

void
ResetTimer()
{
    StartTime = clock();
}


BOOL
RunPolyTest(float *lpResult)
{
    unsigned long PolyCount;
    unsigned long framecount;
    unsigned long foo;
    D3DSTATS stats;
    float time;

    stats.dwSize = sizeof stats;
    d3d.lpD3DDevice->GetStats(&stats);
    foo = stats.dwTrianglesDrawn;

    PolyCount = InitViewPoly(dd.lpDD, d3d.lpD3D, d3d.lpD3DDevice, d3d.lpD3DViewport, tex.NumTextures,
    	          &tex.TextureDstHandle[0], OBJECTS_IN_THROUGHPUT_TEST,
                  RINGS_IN_THROUGHPUT_TEST, SEGS_IN_THROUGHPUT_TEST, NO_SORT, R_IN_THROUGHPUT_TEST,
		  D_IN_THROUGHPUT_TEST, DEPTH_IN_THROUGHPUT_TEST, DV_IN_THROUGHPUT_TEST,
		  DR_IN_THROUGHPUT_TEST);
    if (PolyCount == 0) {
        Msg("Initializing the scene for the polygon throughput test failed.\n");
        return FALSE;
    }
    app.bAbortTest = FALSE;
    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    if (!RenderLoop(RESET_TEST)) {
	goto error_ended_test;
    }
    ResetTimer();
    do {
	if (!RenderLoop(THROUGHPUT_TEST)) {
	    goto error_ended_test;
	}
    } while (Timer() < STARTUP_INTERVAL && !app.bAbortTest);
    if (app.bAbortTest) {
	goto abort_test;
    }
    framecount = 0;
    ResetTimer();
    do {
	if (!RenderLoop(THROUGHPUT_TEST)) {
	    goto error_ended_test;
	}
	++framecount;
	time = Timer();
    } while (time < TEST_INTERVAL && !app.bAbortTest);
    if (app.bAbortTest) {
	goto abort_test;
    }
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    ReleaseViewPoly();

    stats.dwSize = sizeof stats;
    d3d.lpD3DDevice->GetStats(&stats);
    foo = stats.dwTrianglesDrawn - foo;
    /* don't trust foo */
    *lpResult = (float)(PolyCount * framecount) / time;
    return TRUE;

abort_test:
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    ReleaseViewPoly();
    *lpResult = (float)0.0;
    return TRUE;
error_ended_test:
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    ReleaseViewPoly();
    *lpResult = (float)0.0;
   return FALSE;
}

BOOL
RunPixelTest(UINT order, float *lpResult)
{
    unsigned long PixelCount, framecount;
    float time, result;
    PixelCount = InitViewPix(dd.lpDD, d3d.lpD3D, d3d.lpD3DDevice,
                              d3d.lpD3DViewport, tex.NumTextures,
                              &tex.TextureDstHandle[0], 400, 400, 
			      OVERDRAW_IN_PIXEL_TEST, order);
    if (PixelCount == 0) {
        Msg("InitViewPix failed.\n");
        return FALSE;
    }
    app.bAbortTest = FALSE;
    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    if (!RenderLoop(RESET_TEST)) {
	goto error_ended_test;
    }
    ResetTimer();
    do {
	if (!RenderLoop(FILL_RATE_TEST)) {
	    goto error_ended_test;
	}
    } while (Timer() < STARTUP_INTERVAL && !app.bAbortTest);
    if (app.bAbortTest) {
	goto abort_test;
    }
    framecount = 0;
    ResetTimer();
    do {
	if (!RenderLoop(FILL_RATE_TEST)) {
	    goto error_ended_test;
	}
	++framecount;
	time = Timer();
    } while (time < TEST_INTERVAL && !app.bAbortTest);
    if (app.bAbortTest) {
	goto abort_test;
    }
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    ReleaseViewPix();
    result = (float)(PixelCount * framecount) / time;
    *lpResult = result;
    return TRUE;

abort_test:
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    ReleaseViewPix();
    *lpResult = (float)0.0;
    return TRUE;
error_ended_test:
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    ReleaseViewPix();
    *lpResult = (float)0.0;
   return FALSE;

}


BOOL
RunIntersectionTest(UINT order, float *lpResult)
{
    unsigned long PolyCount;
    unsigned long framecount;
    unsigned long foo;
    D3DSTATS stats;
    float time;

    stats.dwSize = sizeof stats;
    d3d.lpD3DDevice->GetStats(&stats);
    foo = stats.dwTrianglesDrawn;

    PolyCount = InitViewPoly(dd.lpDD, d3d.lpD3D, d3d.lpD3DDevice, d3d.lpD3DViewport, tex.NumTextures,
    	          &tex.TextureDstHandle[0], OBJECTS_IN_INTERSECTION_TEST,
                  RINGS_IN_INTERSECTION_TEST, SEGS_IN_INTERSECTION_TEST, order, R_IN_INTERSECTION_TEST,
		  D_IN_INTERSECTION_TEST, DEPTH_IN_INTERSECTION_TEST, DV_IN_INTERSECTION_TEST,
		  DR_IN_INTERSECTION_TEST);
    if (PolyCount == 0) {
        Msg("Initializing the scene for the intersection test failed.\n");
        return FALSE;
    }
    app.bAbortTest = FALSE;
    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    if (!RenderLoop(RESET_TEST)) {
	goto error_ended_test;
    }
    ResetTimer();
    do {
	if (!RenderLoop(INTERSECTION_TEST)) {
	    goto error_ended_test;
	}
    } while (Timer() < STARTUP_INTERVAL && !app.bAbortTest);
    if (app.bAbortTest) {
	goto abort_test;
    }
    framecount = 0;
    ResetTimer();
    do {
	if (!RenderLoop(INTERSECTION_TEST)) {
	    goto error_ended_test;
	}
	++framecount;
	time = Timer();
    } while (time < TEST_INTERVAL && !app.bAbortTest);
    if (app.bAbortTest) {
	goto abort_test;
    }
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    ReleaseViewPoly();

    stats.dwSize = sizeof stats;
    d3d.lpD3DDevice->GetStats(&stats);
    foo = stats.dwTrianglesDrawn - foo;
    /* don't trust foo */
    *lpResult = (float)(PolyCount * framecount) / time;
    return TRUE;

abort_test:
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    ReleaseViewPoly();
    *lpResult = (float)0.0;
    return TRUE;
error_ended_test:
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    ReleaseViewPoly();
    *lpResult = (float)0.0;
   return FALSE;
}


/*************************************************************************
  Windows specific functions
 *************************************************************************/

void SetStateFromDialog(void);

BOOL
FillRateInfo(void)
{
    char buf[35];
    sprintf(buf, "%.2f", (float)LastThroughput / (float)1000.0);
    SetWindowText(GetDlgItem(app.hDlg, LAST_THROUGHPUT_TEXT), buf);
    sprintf(buf, "%.2f", (float)LastFillRate / (float)1000000.0);
    SetWindowText(GetDlgItem(app.hDlg, LAST_FILL_RATE_TEXT), buf);
    sprintf(buf, "%.2f", (float)PeakThroughput/ (float)1000.0);
    SetWindowText(GetDlgItem(app.hDlg, PEAK_THROUGHPUT_TEXT), buf);
    sprintf(buf, "%.2f", (float)PeakFillRateF2B / (float)1000000.0);
    SetWindowText(GetDlgItem(app.hDlg, PEAK_FRONT_TO_BACK_FILL_RATE_TEXT), buf);
    sprintf(buf, "%.2f", (float)PeakFillRateB2F / (float)1000000.0);
    SetWindowText(GetDlgItem(app.hDlg, PEAK_BACK_TO_FRONT_FILL_RATE_TEXT), buf);
    sprintf(buf, "%.2f", (float)LastIntersectionThroughput / (float)10000.0);
    SetWindowText(GetDlgItem(app.hDlg, LAST_INTERSECTION_TEXT), buf);   
    sprintf(buf, "%.2f", (float)PeakIntersectionThroughputF2B / (float)10000.0);
    SetWindowText(GetDlgItem(app.hDlg, PEAK_FRONT_TO_BACK_INTERSECTION_TEXT), buf);
    sprintf(buf, "%.2f", (float)PeakIntersectionThroughputB2F / (float)10000.0);
    SetWindowText(GetDlgItem(app.hDlg, PEAK_BACK_TO_FRONT_INTERSECTION_TEXT), buf);
    return TRUE;
}

void
RefreshButtons(void)
{
    CheckDlgButton(app.hDlg, SYSTEM_MEMORY_CHECK, stat.bOnlySystemMemory);
    CheckDlgButton(app.hDlg, ZBUFFER_CHECK, stat.bZBufferOn);
    EnableWindow(GetDlgItem(app.hDlg, ZBUFFER_CHECK), ZDepth ? TRUE : FALSE);
    CheckDlgButton(app.hDlg, PERSP_CHECK, stat.bPerspCorrect);
    CheckDlgButton(app.hDlg, TEXTURES_CHECK, stat.bTexturesOn);
    CheckDlgButton(app.hDlg, SPECULAR_CHECK, stat.bSpecular);
    EnableWindow(GetDlgItem(app.hDlg, SPECULAR_CHECK), CanSpecular);
    CheckDlgButton(app.hDlg, NO_UPDATES_CHECK, NoUpdates);
    CheckDlgButton(app.hDlg, POINT_RADIO, (stat.TextureFilter == D3DFILTER_NEAREST) ? 1 : 0);
    CheckDlgButton(app.hDlg, BILINEAR_RADIO, (stat.TextureFilter == D3DFILTER_LINEAR) ? 1 : 0);
    CheckDlgButton(app.hDlg, GOURAUD_RADIO, (stat.ShadeMode == D3DSHADE_GOURAUD &&
					     stat.TextureBlend == D3DTBLEND_MODULATE) ? 1 : 0);
    CheckDlgButton(app.hDlg, FLAT_RADIO, (stat.ShadeMode == D3DSHADE_FLAT &&
					  stat.TextureBlend == D3DTBLEND_MODULATE) ? 1 : 0);
    CheckDlgButton(app.hDlg, COPY_RADIO, (stat.TextureBlend == D3DTBLEND_COPY) ? 1 : 0);
    EnableWindow(GetDlgItem(app.hDlg, COPY_RADIO), CanCopy);
    CheckDlgButton(app.hDlg, MONO_RADIO, stat.dcmColorModel == D3DCOLOR_MONO ? 1 : 0);
    EnableWindow(GetDlgItem(app.hDlg, MONO_RADIO), CanMono);
    CheckDlgButton(app.hDlg, RGB_RADIO, stat.dcmColorModel == D3DCOLOR_RGB ? 1 : 0);
    EnableWindow(GetDlgItem(app.hDlg, RGB_RADIO), CanRGB);
    CheckDlgButton(app.hDlg, FRONT_TO_BACK_RADIO, (stat.OverdrawOrder == FRONT_TO_BACK) ? 1 : 0);
    CheckDlgButton(app.hDlg, BACK_TO_FRONT_RADIO, (stat.OverdrawOrder == BACK_TO_FRONT) ? 1 : 0);
    EnableWindow(GetDlgItem(app.hDlg, SYSTEM_MEMORY_CHECK), !IsHardware);
    EnableWindow(GetDlgItem(app.hDlg, PERSP_CHECK), !stat.bTexturesDisabled);
    EnableWindow(GetDlgItem(app.hDlg, TEXTURES_CHECK), !stat.bTexturesDisabled);
    EnableWindow(GetDlgItem(app.hDlg, POINT_RADIO), !stat.bTexturesDisabled);
    EnableWindow(GetDlgItem(app.hDlg, BILINEAR_RADIO), !stat.bTexturesDisabled);
}
 
/*
 * GetCurrDevice
 * Gets selected device
 */
UINT
GetCurrDevice(void)
{
    UINT sel;
    
    sel = (UINT)SendDlgItemMessage(app.hDlg, DEVICE_LIST, CB_GETCURSEL, 0, 0L );
    if (sel < 0 || sel >= d3d.NumDrivers) {
        Msg("Invalid driver selected in list box.\n");
        // XXX just let it return
    }
    return sel;
}

/*
 * SetDeviceInfo
 * Sets the text and d3d.dcmColorModel for given driver
 */
BOOL
SetDeviceInfo(int i)
{
    SetStateFromDialog();
    if (d3d.Driver[i].HWDesc.dcmColorModel) {
        ZDepth = d3d.Driver[i].HWDesc.dwDeviceZBufferBitDepth;
        ZType = DDSCAPS_VIDEOMEMORY;
        IsHardware = TRUE;
        stat.bOnlySystemMemory = FALSE;
        if (d3d.Driver[i].HWDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_PERSPECTIVE)
            stat.bTexturesDisabled = FALSE;
        else
            stat.bTexturesDisabled = TRUE;
	CanSpecular = (d3d.Driver[i].HWDesc.dpcTriCaps.dwShadeCaps & D3DPSHADECAPS_SPECULARGOURAUDMONO ||
		       d3d.Driver[i].HWDesc.dpcTriCaps.dwShadeCaps & D3DPSHADECAPS_SPECULARGOURAUDRGB)
		       ? TRUE : FALSE;
	CanCopy =  (d3d.Driver[i].HWDesc.dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_COPY) ? TRUE : FALSE;
	CanMono = (d3d.Driver[i].HWDesc.dpcTriCaps.dwShadeCaps & D3DPSHADECAPS_COLORGOURAUDMONO) ? TRUE : FALSE;
	CanRGB = (d3d.Driver[i].HWDesc.dpcTriCaps.dwShadeCaps & D3DPSHADECAPS_COLORGOURAUDRGB) ? TRUE : FALSE;
    } else {
        IsHardware = FALSE;
        ZDepth = d3d.Driver[i].HELDesc.dwDeviceZBufferBitDepth;
        ZType = DDSCAPS_SYSTEMMEMORY;
        if (d3d.Driver[i].HELDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_PERSPECTIVE)
            stat.bTexturesDisabled = FALSE;
        else
            stat.bTexturesDisabled = TRUE;
	CanSpecular = (d3d.Driver[i].HELDesc.dpcTriCaps.dwShadeCaps & D3DPSHADECAPS_SPECULARGOURAUDMONO ||
		       d3d.Driver[i].HELDesc.dpcTriCaps.dwShadeCaps & D3DPSHADECAPS_SPECULARGOURAUDRGB)
		       ? TRUE : FALSE;
	CanCopy =  (d3d.Driver[i].HELDesc.dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_COPY) ? TRUE : FALSE;
	CanMono = (d3d.Driver[i].HELDesc.dpcTriCaps.dwShadeCaps & D3DPSHADECAPS_COLORGOURAUDMONO) ? TRUE : FALSE;
	CanRGB = (d3d.Driver[i].HELDesc.dpcTriCaps.dwShadeCaps & D3DPSHADECAPS_COLORGOURAUDRGB) ? TRUE : FALSE;
    }
    if (!CanSpecular)
	stat.bSpecular = FALSE;
    stat.TextureBlend = D3DTBLEND_MODULATE;
    stat.dcmColorModel = CanRGB ? D3DCOLOR_RGB : D3DCOLOR_MONO;
    if (ZDepth & DDBD_32)
	ZDepth = 32;
    else if (ZDepth & DDBD_24)
	ZDepth = 24;
    else if (ZDepth & DDBD_16)
	ZDepth = 16;
    else if (ZDepth & DDBD_8)
	ZDepth = 8;
    else {
	stat.bZBufferOn = FALSE;
    }
    RefreshButtons();  
    LastIntersectionThroughput = (float)0.0;
    PeakIntersectionThroughputF2B = (float)0.0;
    PeakIntersectionThroughputB2F = (float)0.0;
    PeakFillRateF2B = (float)0.0;
    LastFillRate = (float)0.0;
    PeakFillRateB2F = (float)0.0;
    LastThroughput = (float)0.0;
    PeakThroughput = (float)0.0;
    FillRateInfo();
    stat.bOnlySoftRender = FALSE;
    return TRUE;
}

/*
 * FillDeviceList
 * Fills in the list of devices
 */
BOOL
FillDeviceList(void)
{
    UINT i;
    SendDlgItemMessage(app.hDlg, DEVICE_LIST, CB_RESETCONTENT, 0, 0);
    for (i = 0; i < d3d.NumDrivers; i++)
        SendDlgItemMessage(app.hDlg, DEVICE_LIST, CB_ADDSTRING, 0,
                           (LONG)(LPSTR)&d3d.Driver[i].Name[0]);
    return TRUE;
}

/*
 * GetCurrDD
 * Gets selected dd driver
 */
UINT
GetCurrDD(void)
{
    int sel;
    
    sel = SendDlgItemMessage(app.hDlg, DD_LIST, CB_GETCURSEL, 0, 0L );
    if (sel < 0 || sel >= dd.NumDrivers) {
        Msg("Invalid DD driver selected in list box.\n");
        // XXX just let it return
    }
    return sel;
}

/*
 * SetDDInfo
 * Sets up the list of devices for this dd driver
 */
BOOL
SetDDInfo(int i)
{
    if (!FillDeviceList())
	return FALSE;
    SendDlgItemMessage(app.hDlg, DEVICE_LIST, CB_SETCURSEL, 0, 0L );
    if (!SetDeviceInfo(0))
	return FALSE;
    return TRUE;
}

/*
 * FillDDList
 * Fills the list of dd drivers
 */
BOOL
FillDDList(void)
{
    int i;
    for (i = 0; i < dd.NumDrivers; i++)
        SendDlgItemMessage(app.hDlg, DD_LIST, CB_ADDSTRING, 0,
                           (LONG)(LPSTR)&dd.Driver[i].Name[0]);
    return TRUE;
}


void
SetStateFromDialog(void)
{
    stat.bOnlySystemMemory = IsDlgButtonChecked(app.hDlg, SYSTEM_MEMORY_CHECK);
    stat.bZBufferOn = IsDlgButtonChecked(app.hDlg, ZBUFFER_CHECK);
    if (stat.bZBufferOn)
        stat.bClearsOn = TRUE;
    stat.bPerspCorrect = IsDlgButtonChecked(app.hDlg, PERSP_CHECK);
    stat.bSpecular = IsDlgButtonChecked(app.hDlg, SPECULAR_CHECK);
    stat.bTexturesOn =  IsDlgButtonChecked(app.hDlg, TEXTURES_CHECK);
    NoUpdates = IsDlgButtonChecked(app.hDlg, NO_UPDATES_CHECK);
    stat.TextureFilter = (IsDlgButtonChecked(app.hDlg, POINT_RADIO)) ? D3DFILTER_NEAREST : D3DFILTER_LINEAR;
    stat.ShadeMode = (IsDlgButtonChecked(app.hDlg, GOURAUD_RADIO)) ? D3DSHADE_GOURAUD : D3DSHADE_FLAT;
    stat.TextureBlend = IsDlgButtonChecked(app.hDlg, COPY_RADIO) ? D3DTBLEND_COPY : D3DTBLEND_MODULATE;
    stat.OverdrawOrder = (IsDlgButtonChecked(app.hDlg, FRONT_TO_BACK_RADIO)) ? FRONT_TO_BACK : BACK_TO_FRONT;
    stat.dcmColorModel = IsDlgButtonChecked(app.hDlg, MONO_RADIO) ? D3DCOLOR_MONO : D3DCOLOR_RGB;
}

/*
 * Control panel message handler
 */
BOOL FAR PASCAL PanelHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int i;
    BOOL succ;
    if (app.bTestInProgress) {
        return TRUE;
    }
    switch (msg) {
        case WM_INITDIALOG:
            app.hDlg = hDlg;
            RefreshButtons();
	    if (!EnumDDDrivers()) {
		CleanUpAndPostQuit();
		return FALSE;
	    }
            if (!(Connect())) {
		CleanUpAndPostQuit();
                return FALSE;
	    }
	    FillDDList();
	    SendDlgItemMessage(app.hDlg, DD_LIST, CB_SETCURSEL, dd.CurrentDriver, 0L );
	    SetDDInfo(dd.CurrentDriver);
            return TRUE;
	case WM_CLOSE:
	    if (app.bQuit)
		break;
	    CleanUpAndPostQuit();
	    EndDialog(hDlg, TRUE);
	    break;
        case WM_COMMAND:
	    if (app.bQuit)
		break;
            switch(LOWORD(wParam)) {
                case ALL_TESTS_BUTTON:
                    SetStateFromDialog();
                    i = GetCurrDevice();
                    app.bTestInProgress = TRUE;
                    if (!CreateD3DWindow(d3d.Driver[i].lpGuid)) {
			CleanUpAndPostQuit();
                        break;
		    }
                    succ = RunPixelTest(FRONT_TO_BACK, &LastFillRate);
                    if (!succ) {
                        ReleaseD3DWindow();
			app.bTestInProgress = FALSE;
			Msg("A test has failed.  Results are invalid.\n");
			break;
                    }
		    if (app.bAbortTest)
			break;
                    if (LastFillRate > PeakFillRateF2B)
                        PeakFillRateF2B = LastFillRate;
                    succ = RunPixelTest(BACK_TO_FRONT, &LastFillRate);
                    if (!succ) {
                        ReleaseD3DWindow();
			app.bTestInProgress = FALSE;
			Msg("A test has failed.  Results are invalid.\n");
			break;
                    }
		    if (app.bAbortTest)
			break;
                    if (LastFillRate > PeakFillRateB2F)
                        PeakFillRateB2F = LastFillRate;
                    succ = RunPolyTest(&LastThroughput);
                    if (!succ) {
                        ReleaseD3DWindow();
			app.bTestInProgress = FALSE;
			Msg("A test has failed.  Results are invalid.\n");
                        break;
                    }
		    if (app.bAbortTest)
			break;
                    if (LastThroughput > PeakThroughput)
                        PeakThroughput = LastThroughput;
                    succ = RunIntersectionTest(FRONT_TO_BACK, &LastIntersectionThroughput);
		    if (!succ) {
			ReleaseD3DWindow();
			app.bTestInProgress = FALSE;
			Msg("A test has failed.  Results are invalid.\n");
			break;
		    }
		    if (app.bAbortTest)
			break;
                    if (LastIntersectionThroughput > PeakIntersectionThroughputF2B)
                        PeakIntersectionThroughputF2B = LastIntersectionThroughput;
                    succ = RunIntersectionTest(BACK_TO_FRONT, &LastIntersectionThroughput);
		    if (!succ) {
			ReleaseD3DWindow();
			app.bTestInProgress = FALSE;
			Msg("A test has failed.  Results are invalid.\n");
			break;
		    }
		    if (app.bAbortTest)
			break;
                    if (LastIntersectionThroughput > PeakIntersectionThroughputB2F)
                        PeakIntersectionThroughputB2F = LastIntersectionThroughput;
                    ReleaseD3DWindow();
                    app.bTestInProgress = FALSE;
                    FillRateInfo();
                    break;
                case POLYGON_THROUGHPUT_BUTTON:
                    SetStateFromDialog();
                    i = GetCurrDevice();
                    app.bTestInProgress = TRUE;
                    if (!CreateD3DWindow(d3d.Driver[i].lpGuid)) {
			CleanUpAndPostQuit();
                        break;
		    }
                    succ = RunPolyTest(&LastThroughput);
                    ReleaseD3DWindow();
                    app.bTestInProgress = FALSE;
                    if (!succ) {
			Msg("A test has failed.  Results are invalid\n");
			break;
		    }
		    if (app.bAbortTest)
			break;
                    if (LastThroughput > PeakThroughput)
                        PeakThroughput = LastThroughput;
                    FillRateInfo();
                    break;
                case PIXEL_FILL_RATE_BUTTON:
                    SetStateFromDialog();
                    i = GetCurrDevice();
                    app.bTestInProgress = TRUE;
                    if (!CreateD3DWindow(d3d.Driver[i].lpGuid)) {
			CleanUpAndPostQuit();
                        break;
		    }
                    succ = RunPixelTest(stat.OverdrawOrder, &LastFillRate);
                    ReleaseD3DWindow();
                    app.bTestInProgress = FALSE;
                    if (!succ) {
			Msg("A test has failed.  Results are invalid.\n");
			break;
		    }
		    if (app.bAbortTest)
			break;
                    if (stat.OverdrawOrder == FRONT_TO_BACK && LastFillRate > PeakFillRateF2B)
                        PeakFillRateF2B = LastFillRate;
                    if (stat.OverdrawOrder == BACK_TO_FRONT && LastFillRate > PeakFillRateB2F)
                        PeakFillRateB2F = LastFillRate;
                    FillRateInfo();
                    break;
		case INTERSECTION_THROUGHPUT_BUTTON:
		    SetStateFromDialog();
		    i = GetCurrDevice();
                    app.bTestInProgress = TRUE;
                    if (!CreateD3DWindow(d3d.Driver[i].lpGuid)) {
			CleanUpAndPostQuit();
                        break;
		    }
                    succ = RunIntersectionTest(stat.OverdrawOrder, &LastIntersectionThroughput);
                    ReleaseD3DWindow();
                    app.bTestInProgress = FALSE;
                    if (!succ) {
			Msg("A test has failed.  Results are invalid.\n");
			break;
		    }
		    if (app.bAbortTest)
			break;
                    if (stat.OverdrawOrder == FRONT_TO_BACK && LastIntersectionThroughput > PeakIntersectionThroughputF2B)
                        PeakIntersectionThroughputF2B = LastIntersectionThroughput;
                    if (stat.OverdrawOrder == BACK_TO_FRONT && LastIntersectionThroughput > PeakIntersectionThroughputB2F)
                        PeakIntersectionThroughputB2F = LastIntersectionThroughput;
                    FillRateInfo();
		    break;
                case DEVICE_LIST:
    	            if( GET_WM_COMMAND_CMD( wParam, lParam ) == CBN_SELCHANGE ) {
                        i = GetCurrDevice();
                        SetDeviceInfo(i);
	            }
	            break;
		case DD_LIST:
		    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE) {
			if (!Disconnect()) {
			    CleanUpAndPostQuit();
			    break;
			}
			i = GetCurrDD();
			dd.CurrentDriver = i;
			if (!(Connect())) {
			    CleanUpAndPostQuit();
			    break;
			}
			SetDDInfo(i);
		    }
		    break;
                case EXIT_BUTTON:
                    CleanUpAndPostQuit();
                    EndDialog(hDlg, TRUE);
                    break;
            }
            return 0L;
    }
    return FALSE;
}

/*
 * AppInit
 * Initialize this instance.
 */
static BOOL
AppInit(HINSTANCE hInstance, int nCmdShow)
{
    HDC hdc;

    /* Save instance handle for DialogBoxes */
    app.hInstApp = hInstance;
    /*
     * Use current BPP
     */
    hdc = GetDC(NULL);
    ReleaseDC(NULL, hdc);
    return TRUE;
}


/*
 * ProcessCommandLine
 * Search command line for options. Valid options include:
 *      -systemmemory  Force all surfaces to be created in system memory.
 */
BOOL ProcessCommandLine(LPSTR lpCmdLine) {
    LPSTR option;

    option = strtok(lpCmdLine, " -");
    while(option != NULL )   {
        if (!lstrcmp(option, "systemmemory")) {
            stat.bOnlySystemMemory = TRUE;
        } else {
            Msg("Invalid command line options.");
            return FALSE;
        }
        option = strtok(NULL, " -");
   }
   return TRUE;
}

/*
 * WinMain - initialization, message loop
 */
int PASCAL
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
	int nCmdShow)
{
    InitGlobals();
    hPrevInstance = hPrevInstance;
    if(!ProcessCommandLine(lpCmdLine))
        return FALSE;
    if(!AppInit(hInstance, nCmdShow))
    	return FALSE;
    DialogBox(app.hInstApp, "ControlPanel", NULL, (DLGPROC)PanelHandler);
    DestroyWindow(app.hWnd);
    app.hWnd = NULL;
    return 0;
}

/*************************************************************************
  Options setting functions.
 *************************************************************************/

/*
 * Sets the render mode
 */
BOOL
SetRenderState(void)
{
    D3DEXECUTEBUFFERDESC debDesc;
    D3DEXECUTEDATA d3dExData;
    LPDIRECT3DEXECUTEBUFFER lpD3DExCmdBuf;
    LPVOID lpBuffer, lpInsStart;
    DDSURFACEDESC ddsd;
    BOOL bDithering;
    size_t size;

    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    LastError = dd.lpDD->GetDisplayMode(&ddsd);
    if (LastError != DD_OK) {
	Msg("Getting the current display mode failed.\n%s", MyErrorToString(LastError));
	return FALSE;
    }
    bDithering = ddsd.ddpfPixelFormat.dwRGBBitCount <= 8 && stat.dcmColorModel == D3DCOLOR_RGB ? TRUE : FALSE;

    size = 0;
    size += sizeof(D3DINSTRUCTION) * 2;
    size += sizeof(D3DSTATE) * 11;
    memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    debDesc.dwFlags = D3DDEB_BUFSIZE;
    debDesc.dwBufferSize = size;
    LastError = d3d.lpD3DDevice->CreateExecuteBuffer(&debDesc, &lpD3DExCmdBuf, NULL);
    if (LastError != D3D_OK) {
        Msg("CreateExecuteBuffer failed in SetRenderState.\n%s", MyErrorToString(LastError));
	return FALSE;
    }
    LastError = lpD3DExCmdBuf->Lock(&debDesc);
    if (LastError != D3D_OK) {
	Msg("Lock failed on execute buffer in SetRenderState.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    memset(debDesc.lpData, 0, size);

    lpInsStart = debDesc.lpData;
    lpBuffer = lpInsStart;
    OP_STATE_RENDER(11, lpBuffer);
        STATE_DATA(D3DRENDERSTATE_SHADEMODE, stat.ShadeMode, lpBuffer);
	STATE_DATA(D3DRENDERSTATE_TEXTUREMAPBLEND, stat.TextureBlend, lpBuffer);
        STATE_DATA(D3DRENDERSTATE_TEXTUREPERSPECTIVE, stat.bPerspCorrect, lpBuffer);
        STATE_DATA(D3DRENDERSTATE_ZENABLE, stat.bZBufferOn, lpBuffer);
        STATE_DATA(D3DRENDERSTATE_ZWRITEENABLE, stat.bZBufferOn, lpBuffer);
        STATE_DATA(D3DRENDERSTATE_ZFUNC, D3DCMP_LESSEQUAL, lpBuffer);
        STATE_DATA(D3DRENDERSTATE_TEXTUREMAG, stat.TextureFilter, lpBuffer);
        STATE_DATA(D3DRENDERSTATE_TEXTUREMIN, stat.TextureFilter, lpBuffer);
        STATE_DATA(D3DRENDERSTATE_SPECULARENABLE, stat.bSpecular, lpBuffer);
        STATE_DATA(D3DRENDERSTATE_DITHERENABLE, bDithering, lpBuffer);
	STATE_DATA(D3DRENDERSTATE_MONOENABLE, stat.dcmColorModel == D3DCOLOR_MONO ? TRUE : FALSE, lpBuffer);
    OP_EXIT(lpBuffer);

    LastError = lpD3DExCmdBuf->Unlock();
    if (LastError != D3D_OK) {
        Msg("Unlock failed on execute buffer in SetRenderState.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    memset(&d3dExData, 0, sizeof(D3DEXECUTEDATA));
    d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
    d3dExData.dwInstructionOffset = (ULONG) 0;
    d3dExData.dwInstructionLength = (ULONG) ((char*)lpBuffer - (char*)lpInsStart);
    lpD3DExCmdBuf->SetExecuteData(&d3dExData);

    LastError = d3d.lpD3DDevice->BeginScene();
    if (LastError != D3D_OK) {
        Msg("BeginScene failed in SetRenderState.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    LastError = d3d.lpD3DDevice->Execute(lpD3DExCmdBuf,
    					 d3d.lpD3DViewport, D3DEXECUTE_UNCLIPPED);
    if (LastError != D3D_OK) {
        Msg("Execute failed in SetRenderState.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    LastError = d3d.lpD3DDevice->EndScene();
    if (LastError != D3D_OK) {
        Msg("EndScene failed in SetRenderState.\n%s", MyErrorToString(LastError));
        return FALSE;
    }
    lpD3DExCmdBuf->Release();

    return TRUE;
}

/*************************************************************************
  Initialization functions.
 *************************************************************************/

/*
 * InitGlobals
 * Called once at program initialization to initialize global variables.
 */
void
InitGlobals(void)
{
    int i;

    LastFillRate = (float)0.0;
    PeakFillRateF2B = (float)0.0;
    PeakFillRateB2F = (float)0.0;
    LastThroughput = (float)0.0;
    PeakThroughput = (float)0.0;
    /*
     * DirectDraw globals
     */
    dd.lpFrontBuffer = NULL;
    dd.lpBackBuffer = NULL;
    dd.lpZBuffer;
    dd.lpClipper = NULL;
    dd.lpPalette = NULL;
    dd.lpDD = NULL;

    /*
     * Direct3D globals
     */
    d3d.lpD3D = NULL;
    d3d.NumDrivers = 0;
    for (i = 0; i < 5; i++)
        memset(&d3d.Driver[i], 0, sizeof(DeviceInfo));
    d3d.lpD3DDevice = NULL;
    d3d.lpD3DViewport = NULL;

    /*
     * Windows specific and application screen mode globals
     */
    app.hDlg = 0;
    app.bTestInProgress = FALSE;
    app.bAppActive = FALSE;
    app.bAppPaused = FALSE;
    app.bIgnoreWM_SIZE = FALSE;
    app.bQuit = FALSE;

    /*
     * Parameters and status flags
     */
    stat.bStopRendering = FALSE;
    stat.bHandleActivate = FALSE;
    stat.bTexturesOn = TRUE;
    stat.bTexturesDisabled = FALSE;
    stat.bZBufferOn = TRUE;
    stat.bClearsOn = TRUE;
    stat.bPerspCorrect = TRUE;
    stat.bSpecular = FALSE;
    stat.OverdrawOrder = FRONT_TO_BACK;
    stat.ShadeMode = D3DSHADE_GOURAUD;
    stat.TextureFilter = D3DFILTER_NEAREST;
    stat.bOnlySystemMemory = FALSE;
    stat.bOnlySoftRender = FALSE;

    /*
     * Textures
     */
    tex.NumTextures = 2;
    lstrcpy(tex.ImageFile[0], "checker.ppm\0");
    lstrcpy(tex.ImageFile[1], "tex2.ppm\0");
    tex.FirstTexture = 0;
}

/*************************************************************************
  Object release and termination functions and InitAll.
 *************************************************************************/

void
ReleaseExeBuffers(void)
{
    ReleaseViewPix();
    ReleaseViewPoly();
}

void
ReleaseTextures(void)
{
    int i;
    for (i = 0; i < tex.NumTextures; i++) {
        RELEASE(tex.lpSrcTextureObject[i]);
        RELEASE(tex.lpSrcTextureSurface[i]);
        RELEASE(tex.lpDstTextureObject[i]);
        RELEASE(tex.lpDstTextureSurface[i]);
    }
}

/*
 * CleanUpAndExit
 * Release everything and posts a quit message.  Used for program termination.
 */
void
CleanUpAndPostQuit(void)
{
    app.bTestInProgress = FALSE;
    ReleaseD3DWindow();
    Disconnect();
    PostQuitMessage( 0 );
    app.bQuit = TRUE;
}

/*************************************************************************
    Error reporting functions
 *************************************************************************/

void
dpf( LPSTR fmt, ... )
{
    char buff[256];

    lstrcpy(buff, "D3DTEST: " );
    wvsprintf(&buff[lstrlen(buff)], fmt, (char *)(&fmt+1));
    lstrcat(buff, "\r\n");
    OutputDebugString(buff);
}


/* Msg
 * Message output for error notification.
 */
void __cdecl
Msg( LPSTR fmt, ... )
{
    char buff[256];

    app.bTestInProgress = FALSE;
    lstrcpy(buff, "D3DTEST: " );
    wvsprintf(&buff[lstrlen(buff)], fmt, (char *)(&fmt+1));
    lstrcat(buff, "\r\n");
    OutputDebugString(buff);
    wvsprintf(buff, fmt, (char *)(&fmt+1));
    stat.bStopRendering = TRUE;
    if (app.bFullscreen && dd.lpDD) {
        dd.lpDD->FlipToGDISurface();
    }
    SetWindowPos(app.hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
                     SWP_NOSIZE | SWP_NOMOVE);
    MessageBox( NULL, buff, "D3DTest Message", MB_OK );
}


/*
 * MyErrorToString
 * Returns a pointer to a string describing the given error code.
 */
char*
MyErrorToString(HRESULT error)
{
    switch(error) {
        case DD_OK:
            return "No error.\0";
        case DDERR_ALREADYINITIALIZED:
            return "This object is already initialized.\0";
        case DDERR_BLTFASTCANTCLIP:
            return "Return if a clipper object is attached to the source surface passed into a BltFast call.\0";
        case DDERR_CANNOTATTACHSURFACE:
            return "This surface can not be attached to the requested surface.\0";
        case DDERR_CANNOTDETACHSURFACE:
            return "This surface can not be detached from the requested surface.\0";
        case DDERR_CANTCREATEDC:
            return "Windows can not create any more DCs.\0";
        case DDERR_CANTDUPLICATE:
            return "Can't duplicate primary & 3D surfaces, or surfaces that are implicitly created.\0";
        case DDERR_CLIPPERISUSINGHWND:
            return "An attempt was made to set a cliplist for a clipper object that is already monitoring an hwnd.\0";
        case DDERR_COLORKEYNOTSET:
            return "No src color key specified for this operation.\0";
        case DDERR_CURRENTLYNOTAVAIL:
            return "Support is currently not available.\0";
        case DDERR_DIRECTDRAWALREADYCREATED:
            return "A DirectDraw object representing this driver has already been created for this process.\0";
        case DDERR_EXCEPTION:
            return "An exception was encountered while performing the requested operation.\0";
        case DDERR_EXCLUSIVEMODEALREADYSET:
            return "An attempt was made to set the cooperative level when it was already set to exclusive.\0";
        case DDERR_GENERIC:
            return "Generic failure.\0";
        case DDERR_HEIGHTALIGN:
            return "Height of rectangle provided is not a multiple of reqd alignment.\0";
        case DDERR_HWNDALREADYSET:
            return "The CooperativeLevel HWND has already been set. It can not be reset while the process has surfaces or palettes created.\0";
        case DDERR_HWNDSUBCLASSED:
            return "HWND used by DirectDraw CooperativeLevel has been subclassed, this prevents DirectDraw from restoring state.\0";
        case DDERR_IMPLICITLYCREATED:
            return "This surface can not be restored because it is an implicitly created surface.\0";
        case DDERR_INCOMPATIBLEPRIMARY:
            return "Unable to match primary surface creation request with existing primary surface.\0";
        case DDERR_INVALIDCAPS:
            return "One or more of the caps bits passed to the callback are incorrect.\0";
        case DDERR_INVALIDCLIPLIST:
            return "DirectDraw does not support the provided cliplist.\0";
        case DDERR_INVALIDDIRECTDRAWGUID:
            return "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver identifier.\0";
        case DDERR_INVALIDMODE:
            return "DirectDraw does not support the requested mode.\0";
        case DDERR_INVALIDOBJECT:
            return "DirectDraw received a pointer that was an invalid DIRECTDRAW object.\0";
        case DDERR_INVALIDPARAMS:
            return "One or more of the parameters passed to the function are incorrect.\0";
        case DDERR_INVALIDPIXELFORMAT:
            return "The pixel format was invalid as specified.\0";
        case DDERR_INVALIDPOSITION:
            return "Returned when the position of the overlay on the destination is no longer legal for that destination.\0";
        case DDERR_INVALIDRECT:
            return "Rectangle provided was invalid.\0";
        case DDERR_LOCKEDSURFACES:
            return "Operation could not be carried out because one or more surfaces are locked.\0";
        case DDERR_NO3D:
            return "There is no 3D present.\0";
        case DDERR_NOALPHAHW:
            return "Operation could not be carried out because there is no alpha accleration hardware present or available.\0";
        case DDERR_NOBLTHW:
            return "No blitter hardware present.\0";
        case DDERR_NOCLIPLIST:
            return "No cliplist available.\0";
        case DDERR_NOCLIPPERATTACHED:
            return "No clipper object attached to surface object.\0";
        case DDERR_NOCOLORCONVHW:
            return "Operation could not be carried out because there is no color conversion hardware present or available.\0";
        case DDERR_NOCOLORKEY:
            return "Surface doesn't currently have a color key\0";
        case DDERR_NOCOLORKEYHW:
            return "Operation could not be carried out because there is no hardware support of the destination color key.\0";
        case DDERR_NOCOOPERATIVELEVELSET:
            return "Create function called without DirectDraw object method SetCooperativeLevel being called.\0";
        case DDERR_NODC:
            return "No DC was ever created for this surface.\0";
        case DDERR_NODDROPSHW:
            return "No DirectDraw ROP hardware.\0";
        case DDERR_NODIRECTDRAWHW:
            return "A hardware-only DirectDraw object creation was attempted but the driver did not support any hardware.\0";
        case DDERR_NOEMULATION:
            return "Software emulation not available.\0";
        case DDERR_NOEXCLUSIVEMODE:
            return "Operation requires the application to have exclusive mode but the application does not have exclusive mode.\0";
        case DDERR_NOFLIPHW:
            return "Flipping visible surfaces is not supported.\0";
        case DDERR_NOGDI:
            return "There is no GDI present.\0";
        case DDERR_NOHWND:
            return "Clipper notification requires an HWND or no HWND has previously been set as the CooperativeLevel HWND.\0";
        case DDERR_NOMIRRORHW:
            return "Operation could not be carried out because there is no hardware present or available.\0";
        case DDERR_NOOVERLAYDEST:
            return "Returned when GetOverlayPosition is called on an overlay that UpdateOverlay has never been called on to establish a destination.\0";
        case DDERR_NOOVERLAYHW:
            return "Operation could not be carried out because there is no overlay hardware present or available.\0";
        case DDERR_NOPALETTEATTACHED:
            return "No palette object attached to this surface.\0";
        case DDERR_NOPALETTEHW:
            return "No hardware support for 16 or 256 color palettes.\0";
        case DDERR_NORASTEROPHW:
            return "Operation could not be carried out because there is no appropriate raster op hardware present or available.\0";
        case DDERR_NOROTATIONHW:
            return "Operation could not be carried out because there is no rotation hardware present or available.\0";
        case DDERR_NOSTRETCHHW:
            return "Operation could not be carried out because there is no hardware support for stretching.\0";
        case DDERR_NOT4BITCOLOR:
            return "DirectDrawSurface is not in 4 bit color palette and the requested operation requires 4 bit color palette.\0";
        case DDERR_NOT4BITCOLORINDEX:
            return "DirectDrawSurface is not in 4 bit color index palette and the requested operation requires 4 bit color index palette.\0";
        case DDERR_NOT8BITCOLOR:
            return "DirectDrawSurface is not in 8 bit color mode and the requested operation requires 8 bit color.\0";
        case DDERR_NOTAOVERLAYSURFACE:
            return "Returned when an overlay member is called for a non-overlay surface.\0";
        case DDERR_NOTEXTUREHW:
            return "Operation could not be carried out because there is no texture mapping hardware present or available.\0";
        case DDERR_NOTFLIPPABLE:
            return "An attempt has been made to flip a surface that is not flippable.\0";
        case DDERR_NOTFOUND:
            return "Requested item was not found.\0";
        case DDERR_NOTLOCKED:
            return "Surface was not locked.  An attempt to unlock a surface that was not locked at all, or by this process, has been attempted.\0";
        case DDERR_NOTPALETTIZED:
            return "The surface being used is not a palette-based surface.\0";
        case DDERR_NOVSYNCHW:
            return "Operation could not be carried out because there is no hardware support for vertical blank synchronized operations.\0";
        case DDERR_NOZBUFFERHW:
            return "Operation could not be carried out because there is no hardware support for zbuffer blitting.\0";
        case DDERR_NOZOVERLAYHW:
            return "Overlay surfaces could not be z layered based on their BltOrder because the hardware does not support z layering of overlays.\0";
        case DDERR_OUTOFCAPS:
            return "The hardware needed for the requested operation has already been allocated.\0";
        case DDERR_OUTOFMEMORY:
            return "DirectDraw does not have enough memory to perform the operation.\0";
        case DDERR_OUTOFVIDEOMEMORY:
            return "DirectDraw does not have enough memory to perform the operation.\0";
        case DDERR_OVERLAYCANTCLIP:
            return "The hardware does not support clipped overlays.\0";
        case DDERR_OVERLAYCOLORKEYONLYONEACTIVE:
            return "Can only have ony color key active at one time for overlays.\0";
        case DDERR_OVERLAYNOTVISIBLE:
            return "Returned when GetOverlayPosition is called on a hidden overlay.\0";
        case DDERR_PALETTEBUSY:
            return "Access to this palette is being refused because the palette is already locked by another thread.\0";
        case DDERR_PRIMARYSURFACEALREADYEXISTS:
            return "This process already has created a primary surface.\0";
        case DDERR_REGIONTOOSMALL:
            return "Region passed to Clipper::GetClipList is too small.\0";
        case DDERR_SURFACEALREADYATTACHED:
            return "This surface is already attached to the surface it is being attached to.\0";
        case DDERR_SURFACEALREADYDEPENDENT:
            return "This surface is already a dependency of the surface it is being made a dependency of.\0";
        case DDERR_SURFACEBUSY:
            return "Access to this surface is being refused because the surface is already locked by another thread.\0";
        case DDERR_SURFACEISOBSCURED:
            return "Access to surface refused because the surface is obscured.\0";
        case DDERR_SURFACELOST:
            return "Access to this surface is being refused because the surface memory is gone. The DirectDrawSurface object representing this surface should have Restore called on it.\0";
        case DDERR_SURFACENOTATTACHED:
            return "The requested surface is not attached.\0";
        case DDERR_TOOBIGHEIGHT:
            return "Height requested by DirectDraw is too large.\0";
        case DDERR_TOOBIGSIZE:
            return "Size requested by DirectDraw is too large, but the individual height and width are OK.\0";
        case DDERR_TOOBIGWIDTH:
            return "Width requested by DirectDraw is too large.\0";
        case DDERR_UNSUPPORTED:
            return "Action not supported.\0";
        case DDERR_UNSUPPORTEDFORMAT:
            return "FOURCC format requested is unsupported by DirectDraw.\0";
        case DDERR_UNSUPPORTEDMASK:
            return "Bitmask in the pixel format requested is unsupported by DirectDraw.\0";
        case DDERR_VERTICALBLANKINPROGRESS:
            return "Vertical blank is in progress.\0";
        case DDERR_WASSTILLDRAWING:
            return "Informs DirectDraw that the previous Blt which is transfering information to or from this Surface is incomplete.\0";
        case DDERR_WRONGMODE:
            return "This surface can not be restored because it was created in a different mode.\0";
        case DDERR_XALIGN:
            return "Rectangle provided was not horizontally aligned on required boundary.\0";
        case D3DERR_BADMAJORVERSION:
            return "D3DERR_BADMAJORVERSION\0";
        case D3DERR_BADMINORVERSION:
            return "D3DERR_BADMINORVERSION\0";
        case D3DERR_EXECUTE_LOCKED:
            return "D3DERR_EXECUTE_LOCKED\0";
        case D3DERR_EXECUTE_NOT_LOCKED:
            return "D3DERR_EXECUTE_NOT_LOCKED\0";
        case D3DERR_EXECUTE_CREATE_FAILED:
            return "D3DERR_EXECUTE_CREATE_FAILED\0";
        case D3DERR_EXECUTE_DESTROY_FAILED:
            return "D3DERR_EXECUTE_DESTROY_FAILED\0";
        case D3DERR_EXECUTE_LOCK_FAILED:
            return "D3DERR_EXECUTE_LOCK_FAILED\0";
        case D3DERR_EXECUTE_UNLOCK_FAILED:
            return "D3DERR_EXECUTE_UNLOCK_FAILED\0";
        case D3DERR_EXECUTE_FAILED:
            return "D3DERR_EXECUTE_FAILED\0";
        case D3DERR_EXECUTE_CLIPPED_FAILED:
            return "D3DERR_EXECUTE_CLIPPED_FAILED\0";
        case D3DERR_TEXTURE_NO_SUPPORT:
            return "D3DERR_TEXTURE_NO_SUPPORT\0";
        case D3DERR_TEXTURE_NOT_LOCKED:
            return "D3DERR_TEXTURE_NOT_LOCKED\0";
        case D3DERR_TEXTURE_LOCKED:
            return "D3DERR_TEXTURELOCKED\0";
        case D3DERR_TEXTURE_CREATE_FAILED:
            return "D3DERR_TEXTURE_CREATE_FAILED\0";
        case D3DERR_TEXTURE_DESTROY_FAILED:
            return "D3DERR_TEXTURE_DESTROY_FAILED\0";
        case D3DERR_TEXTURE_LOCK_FAILED:
            return "D3DERR_TEXTURE_LOCK_FAILED\0";
        case D3DERR_TEXTURE_UNLOCK_FAILED:
            return "D3DERR_TEXTURE_UNLOCK_FAILED\0";
        case D3DERR_TEXTURE_LOAD_FAILED:
            return "D3DERR_TEXTURE_LOAD_FAILED\0";
        case D3DERR_MATRIX_CREATE_FAILED:
            return "D3DERR_MATRIX_CREATE_FAILED\0";
        case D3DERR_MATRIX_DESTROY_FAILED:
            return "D3DERR_MATRIX_DESTROY_FAILED\0";
        case D3DERR_MATRIX_SETDATA_FAILED:
            return "D3DERR_MATRIX_SETDATA_FAILED\0";
        case D3DERR_SETVIEWPORTDATA_FAILED:
            return "D3DERR_SETVIEWPORTDATA_FAILED\0";
        case D3DERR_MATERIAL_CREATE_FAILED:
            return "D3DERR_MATERIAL_CREATE_FAILED\0";
        case D3DERR_MATERIAL_DESTROY_FAILED:
            return "D3DERR_MATERIAL_DESTROY_FAILED\0";
        case D3DERR_MATERIAL_SETDATA_FAILED:
            return "D3DERR_MATERIAL_SETDATA_FAILED\0";
        case D3DERR_LIGHT_SET_FAILED:
            return "D3DERR_LIGHT_SET_FAILED\0";
        default:
            return "Unrecognized error value.\0";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\globals.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: globals.h
 *
 ***************************************************************************/
#ifndef __GLOBALS_H__
#define __GLOBALS_H__

#include <ddraw.h>
#include "d3d.h"

#define MAX_D3D_TEXTURES 10

typedef struct tagDriverInfo {
    GUID	guid;
    DDCAPS	HWCaps;
    char	Name[40];
    BOOL	bIsPrimary;
} DriverInfo;

typedef struct tagModeListElement {
    int     w, h, bpp;  
} ModeListElement;
 
/*
 * DirectDraw globals
 */
typedef struct tagDDInfo {
    LPDIRECTDRAWSURFACE lpFrontBuffer;
    LPDIRECTDRAWSURFACE lpBackBuffer;
    LPDIRECTDRAWSURFACE lpZBuffer;
    LPDIRECTDRAWCLIPPER lpClipper;
    LPDIRECTDRAWPALETTE lpPalette;
    PALETTEENTRY        ppe[256];
    PALETTEENTRY        Originalppe[256];
    LPDIRECTDRAW        lpDD;
    DDSCAPS             HWddsCaps;
    DWORD               dwZBufferBitDepth;
    DriverInfo		Driver[5];
    int			NumDrivers;
    int			CurrentDriver;
    ModeListElement	ModeList[20];
    int			NumModes;
    int			CurrentMode;
} DDInfo;

/*
 * Direct3D globals
 */
typedef struct tagDeviceInfo {
    char Desc[50], Name[30];
    D3DDEVICEDESC HWDesc, HELDesc;
    LPGUID lpGuid;
} DeviceInfo;

typedef struct tagD3DInfo {
    LPDIRECT3D          lpD3D;
    UINT                NumDrivers;
    DeviceInfo          Driver[5];
    LPDIRECT3DDEVICE    lpD3DDevice;
    LPDIRECT3DVIEWPORT  lpD3DViewport;
} D3DInfo;

typedef struct tagAppInfo {
    HWND        hDlg;
    HWND        hWnd;
    RECT        rcClient;
    HINSTANCE   hInstApp;
    BOOL	bFullscreen;
    BOOL        bTestInProgress;
    BOOL        bAppActive;
    BOOL        bAppPaused;
    BOOL        bIgnoreWM_SIZE;
    BOOL	bQuit;
    BOOL	bAbortTest;
} AppInfo;

/*
 * Parameters and status flags
 */
typedef struct tagStatInfo {
    BOOL             bPrimaryPalettized;
    BOOL             bStopRendering;
    BOOL             bHandleActivate;
    BOOL             bTexturesDisabled;
    BOOL             bTexturesOn;
    BOOL             bZBufferOn;
    BOOL             bClearsOn;
    BOOL             bPerspCorrect;
    BOOL	     bSpecular;
    UINT             OverdrawOrder;
    D3DSHADEMODE     ShadeMode;
    D3DTEXTUREFILTER TextureFilter;
    BOOL             bOnlySystemMemory;
    BOOL             bOnlySoftRender;
    D3DCOLORMODEL    dcmColorModel;
    D3DTEXTUREBLEND  TextureBlend;
} StatInfo;

/*
 * Textures
 */
typedef struct tagTexInfo {
    int                 NumTextures;
    char                ImageFile[MAX_D3D_TEXTURES][20];
    D3DTEXTUREHANDLE    TextureSrcHandle[MAX_D3D_TEXTURES];
    LPDIRECTDRAWSURFACE lpSrcTextureSurface[MAX_D3D_TEXTURES];
    LPDIRECT3DTEXTURE   lpSrcTextureObject[MAX_D3D_TEXTURES];
    D3DTEXTUREHANDLE    TextureDstHandle[MAX_D3D_TEXTURES];
    LPDIRECT3DTEXTURE   lpDstTextureObject[MAX_D3D_TEXTURES];
    LPDIRECTDRAWSURFACE lpDstTextureSurface[MAX_D3D_TEXTURES];
    int                 FirstTexture;
} TexInfo;

#endif // __GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\pixtest.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: pixtest.h
 *
 ***************************************************************************/

#define FRONT_TO_BACK 1
#define BACK_TO_FRONT 2
#define NO_SORT 0

#ifdef __cplusplus
extern "C" {
#endif
// Pixel fill rate test functions
BOOL RenderScenePix(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView,
                    LPD3DRECT lpExtent);
void ReleaseViewPix(void);
unsigned long
InitViewPix(LPDIRECTDRAW lpDD, LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpDev, 
	   LPDIRECT3DVIEWPORT lpView, int NumTextures, LPD3DTEXTUREHANDLE TextureHandle,
	   UINT w, UINT h, UINT overdraw, UINT order);

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\pixtest.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: pixtest.c
 *
 ***************************************************************************/

#include <math.h>
#include <malloc.h>
#include "d3d.h"
#include "d3dmath.h"
#include "d3dmacs.h"
#include "pixtest.h"

#define DSPIN 0.05
#define MAX_OVERDRAW 100

/*
 * External funtions which perform much of the math.
 */
extern LPD3DVECTOR D3DVECTORNormalise(LPD3DVECTOR v);
extern LPD3DVECTOR D3DVECTORCrossProduct(LPD3DVECTOR lpd, LPD3DVECTOR lpa,
					 LPD3DVECTOR lpb);
extern LPD3DMATRIX D3DMATRIXInvert(LPD3DMATRIX d, LPD3DMATRIX a);
extern LPD3DMATRIX D3DMATRIXSetRotation(LPD3DMATRIX lpM, LPD3DVECTOR lpD,
					LPD3DVECTOR lpU);
extern void spline(LPD3DVECTOR p, float t, LPD3DVECTOR p1, LPD3DVECTOR p2,
		   LPD3DVECTOR p3, LPD3DVECTOR p4);

extern void MakePosMatrix(LPD3DMATRIX lpM, float x, float y, float z);
extern void MakeRotMatrix(LPD3DMATRIX lpM, float rx, float ry, float rz);


/*
 * Globals to keep track of execute buffer
 */
static D3DEXECUTEDATA d3dExData;
static LPDIRECT3DEXECUTEBUFFER lpD3DExBuf;
static LPDIRECT3DEXECUTEBUFFER lpSpinBuffer;
static D3DEXECUTEBUFFERDESC debDesc;

/*
 * More globals
 */
static LPDIRECT3DMATERIAL lpbmat;
static LPDIRECT3DMATERIAL lpmat;   /* Material object */

/*
 * Global projection, view, world and identity matricies
 */
static D3DMATRIXHANDLE hProj;
static D3DMATRIX proj = {
    D3DVAL(4.25), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(4.25), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(3.0), D3DVAL(3.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(-3.0), D3DVAL(0.0)
};
static D3DMATRIXHANDLE hView;
static D3DMATRIX view = {
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(10.0), D3DVAL(1.0)
};
static D3DMATRIXHANDLE hWorld;
static D3DMATRIXHANDLE hDSpin;
static D3DMATRIXHANDLE hSpin;
static D3DMATRIX identity = {
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0)
};

#define PI 3.14159265359

/*
 * These defines describe the section of the tube in the execute buffer at
 * one time. (Note, tube and tunnel are used interchangeably).
 */
#define SEGMENTS 20   /* Number of segments in memory at one time.  Each
		       * segment is made up oftriangles spanning between
		       * two rings.
		       */ 
#define SIDES 4       /* Number of sides on each ring. */
#define TEX_RINGS 5   /* Number of rings to stretch the texture over. */
#define NUM_V (SIDES*(SEGMENTS+1)) // Number of vertices in memory at once
#define NUM_TRI (SIDES*SEGMENTS*2) // Number of triangles in memory
#define TUBE_R 1.4  	 /* Radius of the tube. */
#define SPLINE_POINTS 50 /* Number of spline points to initially
			  * calculate.  The section in memory represents
			  * only a fraction of this.
			  */
/*
 * Movement and track scalars given in terms of position along the spline
 * curve.
 */
#define SEGMENT_LENGTH 0.05 /* Length of each segment along curve. */
#define SPEED 0.02	    /* Amount to increment camera position along
			     * curve for each frame.
			     */
#define DEPTH 0.8	    /* How close the camera can get to the end of
			     * track before new segments are added.
			     */
#define PATH_LENGTH (SPLINE_POINTS - 1)	/*Total length of the tunnel.*/

/*
 * A global structure holding the tube data.
 */
static struct {
    LPD3DVERTEX lpV; 	    /* Points to the vertices. */
    LPD3DTRIANGLE lpTri;    /* Points to the triangles which make up the
    			     * segments.
			     */
    int TriOffset;	    /* Offset into the execute buffer were the
    			     * triangle list is found.
			     */
    LPD3DVECTOR lpPoints;   /* Points to the points defining the spline
    			     * curve.
			     */
    D3DMATERIALHANDLE hMat; /* Handle for the material on the tube. */
    D3DTEXTUREHANDLE hTex;  /* Handle for the texture on the material.*/
    D3DLIGHT light; 		/* Structure defining the light. */
    LPDIRECT3DLIGHT lpD3DLight; /* Object pointer for the light. */
    D3DVECTOR cameraP, cameraD, cameraN; /* Vectors defining the camera 
                                          * position, direction and up.
					  */
    float cameraPos;			 /* Camera position along the 
                                          * spline curve.
					  */
    D3DVECTOR endP, endD, endN; /* Vectors defining the position, 
    				 * direction and up at the foremost end of
    				 * the section in memory.
				 */
    float endPos; /* Position along the spline curve of the end. */
    int currentRing, currentSegment; /* Numbers of the ring and tube at 
				      * the back end of the section.
				      */
} tube;

static LPDIRECT3DEXECUTEBUFFER lpSetWorldExeBuf[MAX_OVERDRAW];
static D3DMATRIXHANDLE hPos[MAX_OVERDRAW];
static UINT OVERDRAW, ORDER;

/*
 * Creates a matrix which is equivalent to having the camera at a
 * specified position. This matrix can be used to convert vertices to
 * camera coordinates. lpP    Position of the camera. lpD    Direction of
 * view. lpN    Up vector. lpM    Matrix to update.
 */
void 
PositionCamera(LPD3DVECTOR lpP, LPD3DVECTOR lpD, LPD3DVECTOR lpN, 
	       LPD3DMATRIX lpM)
{
    D3DMATRIX tmp;

    /*
     * Set the rotation part of the matrix and invert it. Vertices must be
     * inverse rotated to achieve the same result of a corresponding 
     * camera rotation.
     */
    tmp._14 = tmp._24 = tmp._34 = tmp._41 = tmp._42 = tmp._43 = (float)0.0;
    tmp._44 = (float)1.0;
    D3DMATRIXSetRotation(&tmp, lpD, lpN);
    D3DMATRIXInvert(lpM, &tmp);
    /*
     * Multiply the rotation matrix by a translation transform.  The
     * translation matrix must be applied first (left of rotation).
     */
    lpM->_41=-(lpM->_11 * lpP->x + lpM->_21 * lpP->y + lpM->_31 * lpP->z);
    lpM->_42=-(lpM->_12 * lpP->x + lpM->_22 * lpP->y + lpM->_32 * lpP->z);
    lpM->_43=-(lpM->_13 * lpP->x + lpM->_23 * lpP->y + lpM->_33 * lpP->z);
}

/*
 * Updates the given position, direction and normal vectors to a given
 * position on the spline curve.  The given up vector is used to determine
 * the new up vector.
 */
void 
MoveToPosition(float position, LPD3DVECTOR lpP, LPD3DVECTOR lpD, 
	       LPD3DVECTOR lpN)
{
    LPD3DVECTOR lpSplinePoint[4];
    D3DVECTOR pp, x;
    int i, j;
    float t;

    /*
     * Find the four points along the curve which are around the position.
     */
    i = 0;
    t = position;
    while (t > 1.0) {
	i++;
	if (i == SPLINE_POINTS)
	    i = 0;
	t -= (float)1.0;
    }
    for (j = 0; j < 4; j++) {
	lpSplinePoint[j] = &tube.lpPoints[i];
	i++;
	if (i == SPLINE_POINTS)
	    i = 0;
    }
    /*
     * Get the point at the given position and one just before it.
     */
    spline(lpP, t, lpSplinePoint[0], lpSplinePoint[1], lpSplinePoint[2],
	   lpSplinePoint[3]);
    spline(&pp, t - (float)0.01, lpSplinePoint[0], lpSplinePoint[1],
    	   lpSplinePoint[2], lpSplinePoint[3]);
    /*
     * Calculate the direction.
     */
    lpD->x = lpP->x - pp.x;
    lpD->y = lpP->y - pp.y;
    lpD->z = lpP->z - pp.z;
    D3DVECTORNormalise(lpD);
    /*
     * Find the new normal.  This method will work provided the change in
     * the normal is not very large.
     */
    D3DVECTORNormalise(lpN);
    D3DVECTORCrossProduct(&x, lpN, lpD);
    D3DVECTORCrossProduct(lpN, &x, lpD);
    lpN->x = -lpN->x;
    lpN->y = -lpN->y;
    lpN->z = -lpN->z;
    D3DVECTORNormalise(lpN);
}


/*
 * Generates a ring of vertices in a plane defined by n and the cross
 * product of n and p.  On exit, joint contains the vertices.  Join must
 * be pre-allocated. Normals are generated pointing in.  Texture
 * coordinates are generated along tu axis and are given along tv.
 */
static void 
MakeRing(LPD3DVECTOR p, LPD3DVECTOR d, LPD3DVECTOR n, float tv,
	 LPD3DVERTEX joint)
{
    int spoke;
    float theta, u, v, x, y, z;
    D3DVECTOR nxd;

    D3DVECTORCrossProduct(&nxd, n, d);
    for (spoke = 0; spoke < SIDES; spoke++) {
	theta = (float)(2.0 * PI) * spoke / SIDES;
	/*
	 * v, u defines a unit vector in the plane define by vectors nxd
	 * and n.
	 */
	v = (float)sin(theta);
	u = (float)cos(theta);
	/*
	 * x, y, z define a unit vector in standard coordiante space
	 */
	x = u * nxd.x + v * n->x;
	y = u * nxd.y + v * n->y;
	z = u * nxd.z + v * n->z;
	/*
	 * Position, normals and texture coordiantes.
	 */
	joint[spoke].x = (float)TUBE_R * x + p->x;
	joint[spoke].y = (float)TUBE_R * y + p->y;
	joint[spoke].z = (float)TUBE_R * z + p->z;
	joint[spoke].nx = -x;
	joint[spoke].ny = -y;
	joint[spoke].nz = -z;
	joint[spoke].tu = (float)1.0 - theta / (float)(2.0 * PI);
	joint[spoke].tv = tv;

    }
}


/*
 * Defines the triangles which form a segment between ring1 and ring2 and
 * stores them at lpTri.  lpTri must be pre-allocated.
 */
void 
MakeSegment(int ring1, int ring2, LPD3DTRIANGLE lpTri)
{
    int side, triangle = 0;

    for (side = 0; side < SIDES; side++) {
	/*
	 * Each side consists of two triangles.
	 */
	lpTri[triangle].v1 = ring1 * SIDES + side;
	lpTri[triangle].v2 = ring2 * SIDES + side;
	lpTri[triangle].v3 = ring2 * SIDES + ((side + 1) % SIDES);
	lpTri[triangle].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
	triangle++;
	lpTri[triangle].v2 = ring2 * SIDES + ((side + 1) % SIDES);
	lpTri[triangle].v3 = ring1 * SIDES + ((side + 1) % SIDES);
	lpTri[triangle].v1 = ring1 * SIDES + side;
	lpTri[triangle].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
	triangle++;
    }
}


/*
 * Creates a new segment of the tunnel at the current end position.
 * Creates a new ring and segment.
 */
void 
UpdateTubeInMemory(void)
{
    static int texRing = 0; /* Static counter defining the position of
    			     * this ring on the texture.
			     */
    int endRing; /* The ring at the end of the tube in memory. */
    int RingOffset, SegmentOffset; /* Offsets into the vertex and triangle 
				    * lists for the new data.
				    */
    /*
     * Replace the back ring with a new ring at the front of the tube
     * in memory.
     */
    memmove(&tube.lpV[SIDES], &tube.lpV[0], sizeof(tube.lpV[0]) * (NUM_V - SIDES));
    MakeRing(&tube.endP, &tube.endD, &tube.endN, texRing/(float)TEX_RINGS,
    	     &tube.lpV[0]);
    /*
     * Replace the back segment with a new segment at the front of the
     * tube in memory. Update the current end position of the tube in
     * memory.
     */
    endRing = (tube.currentRing + SEGMENTS) % (SEGMENTS + 1);
    MoveToPosition(tube.endPos, &tube.endP, &tube.endD, &tube.endN);
    /*
     * Update the execute buffer with the new vertices and triangles.
     */
    RingOffset = sizeof(D3DVERTEX) * tube.currentRing * SIDES;
    SegmentOffset = sizeof(D3DTRIANGLE) * tube.currentSegment * SIDES * 2;
    memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    if (lpD3DExBuf->lpVtbl->Lock(lpD3DExBuf, &debDesc) != D3D_OK)
	return;
    memcpy((char *) debDesc.lpData,
    	   &tube.lpV[0], sizeof(D3DVERTEX) * NUM_V);
    lpD3DExBuf->lpVtbl->Unlock(lpD3DExBuf);
    /*
     * Update the position of the back of the tube in memory and texture
     * counter.
     */
    tube.currentRing = (tube.currentRing + 1) % (SEGMENTS + 1);
    tube.currentSegment = (tube.currentSegment + 1) % SEGMENTS;
    texRing = (texRing + 1) % TEX_RINGS;
}


/*
 * Move the camera through the tunnel.  Create new segments of the tunnel
 * when the camera gets close to the end of the section in memory.
 */
void 
MoveCamera(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView)
{
    /*
     * Update the position on curve and camera vectors.
     */
    tube.cameraPos += (float)SPEED;
    if (tube.cameraPos > PATH_LENGTH)
	tube.cameraPos -= PATH_LENGTH;
    MoveToPosition(tube.cameraPos, &tube.cameraP, &tube.cameraD,
    		   &tube.cameraN);
    /*
     * If the camera is close to the end, add a new segment.
     */
    if (tube.endPos - tube.cameraPos < DEPTH) {
	tube.endPos = tube.endPos + (float)SEGMENT_LENGTH;
	if (tube.endPos > PATH_LENGTH)
	    tube.endPos -= PATH_LENGTH;
	UpdateTubeInMemory();
    }
}


/*
 * Modify the buffer between rendering frames
 */
static void 
TickScene(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView)
{
    MoveCamera(lpDev, lpView);
}

/*
 * Each frame, renders the scene and calls TickScene to modify the object
 * for the next frame.
 */
BOOL
RenderScenePix(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView,
            LPD3DRECT lpExtent)
{
    HRESULT ddrval;
    int i;

    /*
     * Move the camera by updating the view matrix and move the light.
     */
    PositionCamera(&tube.cameraP, &tube.cameraD, &tube.cameraN, &view);
    ddrval = lpDev->lpVtbl->SetMatrix(lpDev, hView, &view);
    if (ddrval != D3D_OK)
        return FALSE;

    tube.light.dvPosition.x = tube.cameraP.x;
    tube.light.dvPosition.y = tube.cameraP.y;
    tube.light.dvPosition.z = tube.cameraP.z;
    ddrval = tube.lpD3DLight->lpVtbl->SetLight(tube.lpD3DLight, &tube.light);
    if (ddrval != D3D_OK)
        return FALSE;
    ddrval = lpDev->lpVtbl->BeginScene(lpDev);
    if (ddrval != D3D_OK)
	return FALSE;
    ddrval = lpDev->lpVtbl->Execute(lpDev, lpSpinBuffer,
    				    lpView, D3DEXECUTE_UNCLIPPED);
    if (ddrval != D3D_OK)
	return FALSE;
    for (i = 0; (unsigned)i < OVERDRAW; i++) {
	ddrval = lpDev->lpVtbl->Execute(lpDev, lpSetWorldExeBuf[i],
					lpView, D3DEXECUTE_UNCLIPPED);
	if (ddrval != D3D_OK)
	    return FALSE;
	ddrval = lpDev->lpVtbl->Execute(lpDev, lpD3DExBuf,
					lpView, D3DEXECUTE_CLIPPED);
	if (ddrval != D3D_OK)
	    return FALSE;
    }
    ddrval = lpDev->lpVtbl->EndScene(lpDev);
    if (ddrval != D3D_OK)
	return FALSE;
    ddrval = lpD3DExBuf->lpVtbl->GetExecuteData(lpD3DExBuf, &d3dExData);
    if (ddrval != D3D_OK)
	return FALSE;

    /*
     * By not chaning the extent, fullscreen in assumed.
     */
    /*
     * Modify for the next time around
     */
    TickScene(lpDev, lpView);
    return TRUE;
}


BOOL
InitOtherBuffers(LPDIRECT3DDEVICE lpDev, UINT overdraw, UINT order)
{    
    LPVOID lpBufStart, lpInsStart, lpPointer;
    DWORD size;
    D3DMATRIX temp;
    D3DVALUE scale;
    int i;

    MAKE_MATRIX(lpDev, hSpin, identity);
    MakeRotMatrix(&temp, (float)0, (float)0, (float)DSPIN);
    MAKE_MATRIX(lpDev, hDSpin, temp);

    size = 0;
    size += sizeof(D3DINSTRUCTION) * 2;
    size += sizeof(D3DMATRIXMULTIPLY) * 1;
    memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    debDesc.dwFlags = D3DDEB_BUFSIZE;
    debDesc.dwBufferSize = size;
    if (lpDev->lpVtbl->CreateExecuteBuffer(lpDev, &debDesc, &lpSpinBuffer,
    				       NULL) != D3D_OK)
	return 0L;
    if (lpSpinBuffer->lpVtbl->Lock(lpSpinBuffer, &debDesc) != D3D_OK)
    	return 0L;
    lpBufStart = debDesc.lpData;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;
    lpInsStart = lpPointer;
    OP_MATRIX_MULTIPLY(1, lpPointer);
	MATRIX_MULTIPLY_DATA(hDSpin, hSpin, hSpin, lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpSpinBuffer->lpVtbl->Unlock(lpSpinBuffer);
    memset(&d3dExData, 0, sizeof(D3DEXECUTEDATA));
    d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
    d3dExData.dwInstructionOffset = (ULONG) 0;
    d3dExData.dwInstructionLength = (ULONG) ((char*)lpPointer - (char*)lpInsStart);
    lpSpinBuffer->lpVtbl->SetExecuteData(lpSpinBuffer, &d3dExData);

    MAKE_MATRIX(lpDev, hWorld, identity);
    for (i = 0; (unsigned)i < overdraw; i++) {
	if (order == FRONT_TO_BACK) {
	    /*
	     * Each tunnel is slightly wider and further back
	     */
	    MakePosMatrix(&temp, 0.0f, 0.0f, (float)i / 5.0f);
	    scale = 1.0f + (float)i / 20.0f;
	    temp._11 = scale;
	    temp._22 = scale;
	} else if (order == BACK_TO_FRONT) {
	    /*
	     * Each tunnel is slightly thinner and closer
	     */
	    MakePosMatrix(&temp, 0.0f, 0.0f, (float)(overdraw - 1 - i) / 5.0f);
	    scale = 1.0f + (float)(overdraw - 1 - i) / 20.0f;
	    temp._11 = scale;
	    temp._22 = scale;
	} else {
	    MakePosMatrix(&temp, 0.0f, 0.0f, 0.0f);
	}
	MAKE_MATRIX(lpDev, hPos[i], temp);
	size = 0;
	size += sizeof(D3DINSTRUCTION) * 3;
	size += sizeof(D3DMATRIXMULTIPLY) * 1;
	size += sizeof(D3DSTATE) * 1;
	memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
	debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
	debDesc.dwFlags = D3DDEB_BUFSIZE;
	debDesc.dwBufferSize = size;
	if (lpDev->lpVtbl->CreateExecuteBuffer(lpDev, &debDesc, &lpSetWorldExeBuf[i],
    					   NULL) != D3D_OK)
	    return 0L;
	if (lpSetWorldExeBuf[i]->lpVtbl->Lock(lpSetWorldExeBuf[i], &debDesc) != D3D_OK)
    	    return 0L;
	lpBufStart = debDesc.lpData;
	memset(lpBufStart, 0, size);
	lpPointer = lpBufStart;
	lpInsStart = lpPointer;
	OP_MATRIX_MULTIPLY(1, lpPointer);
	    MATRIX_MULTIPLY_DATA(hSpin, hPos[i], hWorld, lpPointer);
	OP_STATE_TRANSFORM(1, lpPointer);
	    STATE_DATA(D3DTRANSFORMSTATE_WORLD, hWorld, lpPointer);
	OP_EXIT(lpPointer);
	/*
	 * Setup the execute data describing the buffer
	 */
	lpSetWorldExeBuf[i]->lpVtbl->Unlock(lpSetWorldExeBuf[i]);
	memset(&d3dExData, 0, sizeof(D3DEXECUTEDATA));
	d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
	d3dExData.dwInstructionOffset = (ULONG) 0;
	d3dExData.dwInstructionLength = (ULONG) ((char*)lpPointer - (char*)lpInsStart);
	lpSetWorldExeBuf[i]->lpVtbl->SetExecuteData(lpSetWorldExeBuf[i], &d3dExData);
    }
    return TRUE;    
}

BOOL
InitScene(void)
{
    float position;    		/* Curve position counter. */
    int i;    			/* counter */

    /*
     * Reserved memory for vertices, triangles and spline points.
     */
    tube.lpV = (LPD3DVERTEX) malloc(sizeof(D3DVERTEX) * NUM_V);
    tube.lpTri = (LPD3DTRIANGLE) malloc(sizeof(D3DTRIANGLE) * NUM_TRI);
    tube.lpPoints = (LPD3DVECTOR) malloc(sizeof(D3DVECTOR)*SPLINE_POINTS);
    /*
     * Generate spline points
     */
    for (i = 0; i < SPLINE_POINTS; i++) {
#if 0
	tube.lpPoints[i].x = (float)(cos(i * 4.0) * 20.0);
	tube.lpPoints[i].y = (float)(sin(i * 4.0) * 20.0);
	tube.lpPoints[i].z = i * (float)20.0;
#else
	tube.lpPoints[i].x = (float)0.0;
	tube.lpPoints[i].y = (float)0.0;
	tube.lpPoints[i].z = i * (float)20.0;
#endif
    }
    /*
     * Create the initial tube section in memory.
     */
    tube.endN.x = (float)0.0;
    tube.endN.y = (float)1.0;
    tube.endN.z = (float)0.0;
    position = (float)0.0;
    for (i = 0; i < SEGMENTS + 1; i++) {
	MoveToPosition(position, &tube.endP, &tube.endD, &tube.endN);
	position += (float)SEGMENT_LENGTH;
	MakeRing(&tube.endP, &tube.endD, &tube.endN, 
		 (float)(i % TEX_RINGS) / TEX_RINGS,
		 &tube.lpV[(SEGMENTS - i) * SIDES]);
    }
    for (i = 0; i < SEGMENTS; i++)
	MakeSegment(i + 1, i, &tube.lpTri[i * SIDES * 2]);
    /*
     * Move the camera to the begining and set some globals
     */
    tube.cameraN.x = (float)0.0;
    tube.cameraN.y = (float)1.0;
    tube.cameraN.z = (float)0.0;
    MoveToPosition((float)0.0, &tube.cameraP, &tube.cameraD, &tube.cameraN);
    tube.currentRing = 0;
    tube.currentSegment = 0;
    tube.cameraPos = (float)0.0;
    tube.endPos = position;
    return TRUE;
}

void
ReleaseScene(void)
{
    if (tube.lpPoints)
        free(tube.lpPoints);
    if (tube.lpTri)
        free(tube.lpTri);
    if (tube.lpV)
        free(tube.lpV);
}

void
ReleaseViewPix(void)
{
    RELEASE(lpD3DExBuf);
    RELEASE(tube.lpD3DLight);
    RELEASE(lpmat);
    RELEASE(lpbmat);
    ReleaseScene();
}


/*
 * Builds the scene and initializes the execute buffer for rendering.
 * Returns 0 on failure.
 */
unsigned long
InitViewPix(LPDIRECTDRAW lpDD, LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpDev, 
	   LPDIRECT3DVIEWPORT lpView, int NumTextures, 
	   LPD3DTEXTUREHANDLE TextureHandle, UINT w, UINT h, UINT overdraw, UINT order)
{
    /* Variables for exectue buffer generation */
    LPVOID lpBufStart, lpInsStart, lpPointer;
    LPDIRECT3DEXECUTEBUFFER lpD3DExCmdBuf;
    DWORD size;

    /* Background material variables */
    D3DMATERIAL bmat;
    D3DMATERIALHANDLE hbmat;
    D3DMATERIAL mat;

    if (!InitScene())
	return 0L;
    OVERDRAW = overdraw;
    ORDER = order;

    if (!InitOtherBuffers(lpDev, overdraw, order))
	return FALSE;
    
    /*
     * Set background to black material
     */
    if (lpD3D->lpVtbl->CreateMaterial(lpD3D, &lpbmat, NULL) != D3D_OK)
	return 0L;
    memset(&bmat, 0, sizeof(D3DMATERIAL));
    bmat.dwSize = sizeof(D3DMATERIAL);
    bmat.dwRampSize = 1;
    lpbmat->lpVtbl->SetMaterial(lpbmat, &bmat);
    lpbmat->lpVtbl->GetHandle(lpbmat, lpDev, &hbmat);
    lpView->lpVtbl->SetBackground(lpView, hbmat);
    /*
     * Set the view, projection and world matricies in an execute buffer
     */
    MAKE_MATRIX(lpDev, hView, view);
    MAKE_MATRIX(lpDev, hProj, proj);
    /*
     * Create an execute buffer
     */
    size = 0;
    size += sizeof(D3DINSTRUCTION) * 3;
    size += sizeof(D3DSTATE) * 3;
    memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    debDesc.dwFlags = D3DDEB_BUFSIZE;
    debDesc.dwBufferSize = size;
    if (lpDev->lpVtbl->CreateExecuteBuffer(lpDev, &debDesc, &lpD3DExCmdBuf,
    					   NULL) != D3D_OK)
	                                       return 0L;
    if (lpD3DExCmdBuf->lpVtbl->Lock(lpD3DExCmdBuf, &debDesc) != D3D_OK)
	return 0L;
    lpBufStart = debDesc.lpData;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;
    /*
     * Fill the execute buffer with instructions
     */
    lpInsStart = lpPointer;
    OP_STATE_TRANSFORM(2, lpPointer);
        STATE_DATA(D3DTRANSFORMSTATE_VIEW, hView, lpPointer);
        STATE_DATA(D3DTRANSFORMSTATE_PROJECTION, hProj, lpPointer);
    OP_STATE_LIGHT(1, lpPointer);
        STATE_DATA(D3DLIGHTSTATE_AMBIENT, RGBA_MAKE(40, 40, 40, 40), lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpD3DExCmdBuf->lpVtbl->Unlock(lpD3DExCmdBuf);
    memset(&d3dExData, 0, sizeof(D3DEXECUTEDATA));
    d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
    d3dExData.dwInstructionOffset = (ULONG) 0;
    d3dExData.dwInstructionLength = (ULONG) ((char *)lpPointer - (char*)lpInsStart);
    lpD3DExCmdBuf->lpVtbl->SetExecuteData(lpD3DExCmdBuf, &d3dExData);
    lpDev->lpVtbl->BeginScene(lpDev);
    lpDev->lpVtbl->Execute(lpDev, lpD3DExCmdBuf, lpView, D3DEXECUTE_UNCLIPPED);
    lpDev->lpVtbl->EndScene(lpDev);
    /*
     * We are done with the command buffer.
     */
    lpD3DExCmdBuf->lpVtbl->Release(lpD3DExCmdBuf);
    /*
     * Setup materials and lights
     */
    tube.hTex = TextureHandle[1];
    if (lpD3D->lpVtbl->CreateMaterial(lpD3D, &lpmat, NULL) != D3D_OK)
	return 0L;
    memset(&mat, 0, sizeof(D3DMATERIAL));
    mat.dwSize = sizeof(D3DMATERIAL);
    mat.diffuse.r = (D3DVALUE)1.0;
    mat.diffuse.g = (D3DVALUE)1.0;
    mat.diffuse.b = (D3DVALUE)1.0;
    mat.diffuse.a = (D3DVALUE)1.0;
    mat.ambient.r = (D3DVALUE)1.0;
    mat.ambient.g = (D3DVALUE)1.0;
    mat.ambient.b = (D3DVALUE)1.0;
    mat.specular.r = (D3DVALUE)1.0;
    mat.specular.g = (D3DVALUE)1.0;
    mat.specular.b = (D3DVALUE)1.0;
    mat.power = (float)20.0;
    mat.dwRampSize = 16;
    mat.hTexture = tube.hTex;
    lpmat->lpVtbl->SetMaterial(lpmat, &mat);
    lpmat->lpVtbl->GetHandle(lpmat, lpDev, &tube.hMat);
    memset(&tube.light, 0, sizeof(D3DLIGHT));
    tube.light.dwSize = sizeof(D3DLIGHT);
    tube.light.dltType = D3DLIGHT_POINT;
    tube.light.dvPosition.x = tube.cameraP.x;
    tube.light.dvPosition.y = tube.cameraP.y;
    tube.light.dvPosition.z = tube.cameraP.z;
    tube.light.dcvColor.r = D3DVAL(0.9);
    tube.light.dcvColor.g = D3DVAL(0.9);
    tube.light.dcvColor.b = D3DVAL(0.9);
    tube.light.dvAttenuation0 = (float)0.0;
    tube.light.dvAttenuation1 = (float)0.0;
    tube.light.dvAttenuation2 = (float)0.05;
    if (lpD3D->lpVtbl->CreateLight(lpD3D, &tube.lpD3DLight, NULL)!=D3D_OK)
	return 0L;
    if (tube.lpD3DLight->lpVtbl->SetLight(tube.lpD3DLight, &tube.light)
    	!=D3D_OK)
	return 0L;
    if (lpView->lpVtbl->AddLight(lpView, tube.lpD3DLight) != D3D_OK)
	return 0L;

    /*
     * Create an execute buffer
     */
    size = sizeof(D3DVERTEX) * NUM_V;
    size += sizeof(D3DPROCESSVERTICES);
    size += sizeof(D3DINSTRUCTION) * 40;
    size += sizeof(D3DSTATE) * 7;
    size += sizeof(D3DTRIANGLE) * NUM_TRI;
    memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    debDesc.dwFlags = D3DDEB_BUFSIZE;
    debDesc.dwBufferSize = size;
    if (lpDev->lpVtbl->CreateExecuteBuffer(lpDev, &debDesc, &lpD3DExBuf,
    					   NULL) != D3D_OK)
	return 0L;
    /*
     * lock it so it can be filled
     */
    if (lpD3DExBuf->lpVtbl->Lock(lpD3DExBuf, &debDesc) != D3D_OK)
	return FALSE;
    lpBufStart = debDesc.lpData;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;
    VERTEX_DATA(tube.lpV, NUM_V, lpPointer);
    /*
     * Save the location of the first instruction and add instructions to
     * execute buffer.
     */
    lpInsStart = lpPointer;
    OP_STATE_LIGHT(1, lpPointer);
        STATE_DATA(D3DLIGHTSTATE_MATERIAL, tube.hMat, lpPointer);
    OP_PROCESS_VERTICES(1, lpPointer);
        PROCESSVERTICES_DATA(D3DPROCESSVERTICES_TRANSFORMLIGHT, 0, NUM_V, lpPointer);
    OP_STATE_RENDER(3, lpPointer);
        STATE_DATA(D3DRENDERSTATE_TEXTUREHANDLE, tube.hTex, lpPointer);
        STATE_DATA(D3DRENDERSTATE_WRAPU, TRUE, lpPointer);
        STATE_DATA(D3DRENDERSTATE_WRAPV, TRUE, lpPointer);
    /*
     * Make sure that the triangle data (not OP) will be QWORD aligned
     */
    if (QWORD_ALIGNED(lpPointer)) {
	OP_NOP(lpPointer);
    }
    OP_TRIANGLE_LIST(NUM_TRI, lpPointer);
        tube.TriOffset = (char *)lpPointer - (char *)lpBufStart;
        TRIANGLE_LIST_DATA(tube.lpTri, NUM_TRI, lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpD3DExBuf->lpVtbl->Unlock(lpD3DExBuf);
    memset(&d3dExData, 0, sizeof(D3DEXECUTEDATA));
    d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
    d3dExData.dwVertexCount = NUM_V;
    d3dExData.dwInstructionOffset = (ULONG) ((char *)lpInsStart - (char *)lpBufStart);
    d3dExData.dwInstructionLength = (ULONG) ((char *)lpPointer - (char *)lpInsStart);
    lpD3DExBuf->lpVtbl->SetExecuteData(lpD3DExBuf, &d3dExData);

    return w * h * overdraw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\dciinfo\dciinfo.c ===
/******************************Module*Header*******************************\
* Module Name: dciinfo.c
*
* DCIMAN32 test program.
*
* Created: 15-Dec-1994 23:50:46
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <dciman.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "dciinfo.h"

// Window functions.

void MyCreateWindows(HINSTANCE);
long FAR PASCAL MainWndProc(HWND, UINT, WPARAM, LPARAM);
long FAR PASCAL TestWndProc(HWND, UINT, WPARAM, LPARAM);
void MainUpdateMenu(HWND);

// DCI functions.

void InitDCI(void);
void CloseDCI(void);
void DCISurfInfo(void);
void PrintRegionData(LPRGNDATA);
void DCIRgnInfoDCRegion(HDC);
void DCIRgnInfoWindowRegion(HWND);
void DCIRgnInfoWinWatch(HWND);
void DCIRgnInfoNotify(HWND);
void CALLBACK WinWatchNotifyProc(HWINWATCH, HWND, DWORD, LPARAM);

// ListBox functions.

void LBprintf(PCH, ...);
void LBreset(void);

// Global window handles.  Always handy to have around.

HWND hwndMain = (HWND) NULL;
HWND hwndList = (HWND) NULL;
HWND hwndTest = (HWND) NULL;
HWND hwndTrack = (HWND) NULL;

// Global DCI data.
// Note: hdcDCI and pDCISurfInfo valid iff DCI initialized.
//       wt control the type of function used to get visrgn data.

HDC  hdcDCI = (HDC) NULL;
LPDCISURFACEINFO pDCISurfInfo = (LPDCISURFACEINFO) NULL;
typedef enum tagWATCHTYPE {
    WT_WINWATCH, WT_WINRGN, WT_DCRGN, WT_NOTIFY
} WATCHTYPE;
WATCHTYPE wt = WT_WINWATCH;
HWINWATCH hww = (HWINWATCH) NULL;
BOOL bNewWatchMode = TRUE;  // allow first time to update no matter what

/******************************Public*Routine******************************\
* WinMain
*
* Main loop.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
        int nCmdShow)
{
    MSG msg;

    MyCreateWindows(hInstance);

    while ( GetMessage(&msg, (HWND) NULL, (UINT) NULL, (UINT) NULL) )
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return (msg.wParam);
}

/******************************Public*Routine******************************\
* MyCreateWindows
*
* Setup the windows.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void MyCreateWindows(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    RECT rcl;

// Register and create the main window, which contains the info listbox.

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, "DciInfoIcon");
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  "DciInfoMenu";
    wc.lpszClassName = "MainWClass";
    RegisterClass(&wc);

    hwndMain = CreateWindow(
        "MainWClass",
        "DCI info",
        WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
        20,
        50,
        300,
        300,
        NULL,
        NULL,
        hInstance,
        NULL
        );

    if (hwndMain)
    {
        ShowWindow(hwndMain, SW_NORMAL);
        UpdateWindow(hwndMain);

    // Create the list box to fill the main window.

        GetClientRect(hwndMain, &rcl);

        hwndList = CreateWindow(
            "LISTBOX",
            "DCI info",
            WS_CHILD | WS_VISIBLE | WS_VSCROLL
            | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            hwndMain,
            NULL,
            hInstance,
            NULL
            );

        if (hwndList)
        {
            SendMessage(
                hwndList,
                WM_SETFONT,
                (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                (LPARAM) FALSE
                );

            LBreset();

            ShowWindow(hwndList, SW_NORMAL);
            UpdateWindow(hwndList);
        }
    }

// Create the test window to which we will do the DCI stuff.

    wc.style = 0;
    wc.lpfnWndProc = TestWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = "TestWClass";
    RegisterClass(&wc);

    hwndTest = CreateWindow(
        "TestWClass",
        "WinWatch this window",
        WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
        330,
        50,
        300,
        300,
        NULL,
        NULL,
        hInstance,
        NULL
        );

    if (hwndTest)
    {
        ShowWindow(hwndTest, SW_NORMAL);
        UpdateWindow(hwndTest);

        hwndTrack = hwndTest;
        if ( (wt == WT_DCRGN) || (wt == WT_WINRGN) || (wt == WT_WINWATCH) )
            SetTimer(hwndMain, 1, 500, NULL);
        if ( !(hww = WinWatchOpen(hwndTrack)) )
            MessageBox(NULL, "WinWatchOpen failed", "ERROR", MB_OK);
    }
}

/******************************Public*Routine******************************\
* MainWndProc
*
* WndProc for the main window.  List box is maintained here.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

long FAR PASCAL MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    HDC     hdc;
    long    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_CREATE:
        MainUpdateMenu(hwnd);
        break;

    case WM_COMMAND:
        switch (wParam)
        {
        case IDM_WINWATCHGETCLIPLIST:
            if ( wt == WT_NOTIFY )
                WinWatchNotify(hww, (WINWATCHNOTIFYPROC) NULL, 0);
            wt = WT_WINWATCH;
            SetTimer(hwndTest, 1, 500, NULL);
            bNewWatchMode = TRUE;
            break;

        case IDM_GETDCREGION:
            if ( wt == WT_NOTIFY )
                WinWatchNotify(hww, (WINWATCHNOTIFYPROC) NULL, 0);
            wt = WT_DCRGN;
            SetTimer(hwndTest, 1, 500, NULL);
            break;

        case IDM_GETWINDOWREGION:
            if ( wt == WT_NOTIFY )
                WinWatchNotify(hww, (WINWATCHNOTIFYPROC) NULL, 0);
            wt = WT_WINRGN;
            SetTimer(hwndTest, 1, 500, NULL);
            break;

        case IDM_WINWATCHNOTIFY:
            if ( (wt == WT_DCRGN) || (wt == WT_WINRGN) || (wt == WT_WINWATCH) )
                KillTimer(hwndTest, 1);
            wt = WT_NOTIFY;
            if (!WinWatchNotify(hww, WinWatchNotifyProc, 0))
            {
                LBreset();
                LBprintf("WinWatchNotify failed");
            }
            break;

        case IDM_HWNDTEST:
            if (hww)
                WinWatchClose(hww);

            hwndTrack = hwndTest;
            if ( !(hww = WinWatchOpen(hwndTrack)) )
                MessageBox(NULL, "WinWatchOpen failed", "ERROR", MB_OK);

            break;

        case IDM_HWNDNULL:
            if (hww)
                WinWatchClose(hww);

            hwndTrack = NULL;
            if ( !(hww = WinWatchOpen(hwndTrack)) )
                MessageBox(NULL, "WinWatchOpen failed", "ERROR", MB_OK);

            break;
        }
        MainUpdateMenu(hwnd);
        break;

    case WM_SIZE:
        lRet = DefWindowProc(hwndList, message, wParam, lParam);
        GetClientRect(hwndMain, &rcl);
        MoveWindow(
            hwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(hwndList);
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_ESCAPE:     // <ESC> is quick exit

            PostMessage(hwnd, WM_DESTROY, 0, 0);
            break;

        default:
            break;
        }
        break;

    case WM_TIMER:
        switch (wt)
        {
        case WT_WINWATCH:
            DCIRgnInfoWinWatch(hwndTrack);
            break;

        case WT_WINRGN:
            DCIRgnInfoWindowRegion(hwndTrack);
            break;

        case WT_DCRGN:
            hdc = GetDC(hwndTrack);
            DCIRgnInfoDCRegion(hdc);
            ReleaseDC(hwndTrack, hdc);
            break;
        }

        break;

    case WM_DESTROY:
        if ( (wt == WT_DCRGN) || (wt == WT_WINRGN) || (wt == WT_WINWATCH) )
            KillTimer(hwnd, 1);
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* MainUpdateMenu
*
* History:
*  31-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void MainUpdateMenu(HWND hwnd)
{
    HMENU hmen = GetMenu(hwnd);

    CheckMenuItem(hmen, IDM_WINWATCHGETCLIPLIST, wt == WT_WINWATCH ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_GETDCREGION        , wt == WT_DCRGN    ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_GETWINDOWREGION    , wt == WT_WINRGN   ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_WINWATCHNOTIFY     , wt == WT_NOTIFY   ? MF_CHECKED : MF_UNCHECKED);

    CheckMenuItem(hmen, IDM_HWNDTEST, hwndTrack == hwndTest ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_HWNDNULL, hwndTrack == NULL     ? MF_CHECKED : MF_UNCHECKED);
}

/******************************Public*Routine******************************\
* TestWndProc
*
* WndProc for the test window.  This is where we do our DCI stuff.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

long FAR PASCAL TestWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    long    lRet = 0;
    RECT    rcl;
    HDC     hdc;
    static HPALETTE hpal = (HPALETTE) NULL;

// Process window message.

    switch (message)
    {
    case WM_CREATE:
        InitDCI();
        MainUpdateMenu(hwnd);
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_ESCAPE:     // <ESC> is quick exit

            PostMessage(hwnd, WM_DESTROY, 0, 0);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
        CloseDCI();
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* InitDCI
*
* Initialize DCI.  hdcDCI and pDCISurfInfo are global data which are valid
* only if this function succeeds.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void InitDCI()
{
    if ( hdcDCI = DCIOpenProvider() )
    {
        if (
            (DCICreatePrimary(hdcDCI, &pDCISurfInfo) == DCI_OK) &&
            (pDCISurfInfo != (LPDCISURFACEINFO) NULL)
           )
        {
            DCISurfInfo();
        }
        else
            LBprintf("DCICreatePrimary failed");
    }
    else
        LBprintf("DCIOpenPrimary failed");
}

/******************************Public*Routine******************************\
* CloseDCI
*
* Shutdown DCI access.  hdcDCI and pDCISurfInfo will be invalid afterwards.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void CloseDCI()
{
    if (hww)
        WinWatchClose(hww);

    if (pDCISurfInfo)
    {
        DCIDestroy(pDCISurfInfo);
        pDCISurfInfo = (LPDCISURFACEINFO) NULL;
    }

    if (hdcDCI)
    {
        DCICloseProvider(hdcDCI);
        hdcDCI = (HDC) NULL;
    }
}

/******************************Public*Routine******************************\
* DCISurfInfo
*
* Output information about the DCI primary surface.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void DCISurfInfo()
{
// If DCI surface info exists, output it to the list box.

    if ( pDCISurfInfo )
    {
        LBprintf("DCISURFACEINFO:");
        LBprintf("    dwSize        = 0x%lx",pDCISurfInfo->dwSize       );
        LBprintf("    dwDCICaps     = 0x%lx",pDCISurfInfo->dwDCICaps    );
        LBprintf("    dwCompression = %ld"  ,pDCISurfInfo->dwCompression);
        LBprintf("    dwMask        = (0x%lx, 0x%lx, 0x%lx)",
                                      pDCISurfInfo->dwMask[0],
                                      pDCISurfInfo->dwMask[1],
                                      pDCISurfInfo->dwMask[2]           );
        LBprintf("    dwWidth       = %ld"  ,pDCISurfInfo->dwWidth      );
        LBprintf("    dwHeight      = %ld"  ,pDCISurfInfo->dwHeight     );
        LBprintf("    lStride       = 0x%lx",pDCISurfInfo->lStride      );
        LBprintf("    dwBitCount    = %ld"  ,pDCISurfInfo->dwBitCount   );
        LBprintf("    dwOffSurface  = 0x%lx",pDCISurfInfo->dwOffSurface );
    }
}

/******************************Public*Routine******************************\
* PrintRegionData
*
* Output to the listbox information about the RGNDATA structure.
*
* History:
*  31-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void PrintRegionData(LPRGNDATA prd)
{
    if (prd)
    {
        RECT *prc, *prcEnd;

        prc = (RECT *) prd->Buffer;
        prcEnd = prc + prd->rdh.nCount;

        LBprintf("Rectangles: %ld", prd->rdh.nCount);
        LBprintf("    (  left,  right,    top, bottom)");
        LBprintf("");

        if (prd->rdh.nCount)
        {
            for ( ; prc < prcEnd; prc++)
            {
                LBprintf("    (%6ld, %6ld, %6ld, %6ld)",
                    prc->left, prc->right, prc->top, prc->bottom);
            }
        }
        else
        {
            LBprintf("    rclBounds (%6ld, %6ld, %6ld, %6ld)",
                prd->rdh.rcBound.left, prd->rdh.rcBound.right,
                prd->rdh.rcBound.top, prd->rdh.rcBound.bottom);
        }
    }
}

/******************************Public*Routine******************************\
* DCIRgnInfoDCRegion
*
* Get and print visible region information using GetDCRegionData.
*
* History:
*  31-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void DCIRgnInfoDCRegion(HDC hdc)
{
    UINT cj;
    LPRGNDATA prd;

// Quick out -- is DCI enabled?

    if ( !pDCISurfInfo )
        return;

// Print general DCI info.

    LBreset();
    DCISurfInfo();
    LBprintf("");
    LBprintf("GetDCRegionData");

// Query the visible region.

    cj = GetDCRegionData(hdc, 0, (LPRGNDATA) NULL);
    if (!cj)
        LBprintf("ERROR: failed to get size of clip region data");

    prd = (LPRGNDATA) LocalAlloc(LMEM_ZEROINIT|LMEM_FIXED, cj);
    if (prd)
    {
        cj = GetDCRegionData(hdc, cj, prd);
        if ( cj )
            PrintRegionData(prd);
        else
            LBprintf("ERROR: failed to get clip region");

        LocalFree(prd);
    }
    else
    {
        if ( cj )
            LBprintf("ERROR: out of memory");
    }
}

/******************************Public*Routine******************************\
* DCIRgnInfoWindowRegion
*
* Get and print visible region information using GetWindowRegionData.
*
* History:
*  31-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void DCIRgnInfoWindowRegion(HWND hwnd)
{
    UINT cj;
    LPRGNDATA prd;

// Quick out -- is DCI enabled?

    if ( !pDCISurfInfo )
        return;

// Print general DCI info.

    LBreset();
    DCISurfInfo();
    LBprintf("");
    LBprintf("GetWindowRegionData");

// Query the visible region.

    cj = GetWindowRegionData(hwnd, 0, (LPRGNDATA) NULL);
    if (!cj)
        LBprintf("ERROR: failed to get size of clip region data");

    prd = (LPRGNDATA) LocalAlloc(LMEM_ZEROINIT|LMEM_FIXED, cj);
    if (prd)
    {
        cj = GetWindowRegionData(hwnd, cj, prd);
        if ( cj )
            PrintRegionData(prd);
        else
            LBprintf("ERROR: failed to get clip region");

        LocalFree(prd);
    }
    else
    {
        if ( cj )
            LBprintf("ERROR: out of memory");
    }
}

/******************************Public*Routine******************************\
* DCIRgnInfoWinWatch
*
* Get and print visible region information using WinWatchGetClipList.
*
* History:
*  31-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define _NOERROR_       0
#define _MEMERROR_      1
#define _DCIERROR_SIZE_ 2
#define _DCIERROR_RGN_  3

DCIRVAL MyDCIBeginAccess(LPDCISURFACEINFO *lplpSurfInfo, int x, int y, int width, int height)
{
    DCIRVAL dciRet;

    dciRet = DCIBeginAccess(*lplpSurfInfo, x, y, width, height);

    if ( dciRet == DCI_FAIL_INVALIDSURFACE )
    {
        DCIDestroy(*lplpSurfInfo);
        if ( (DCICreatePrimary(hdcDCI, lplpSurfInfo) == DCI_OK) &&
             (*lplpSurfInfo != (LPDCISURFACEINFO) NULL) )
        {
            dciRet = DCIBeginAccess(*lplpSurfInfo, x, y, width, height);
        }
    }

    return dciRet;
}

void DCIRgnInfoWinWatch(HWND hwnd)
{
    DCIRVAL dciRet = 0;
    RECT    rc;
    POINT   pt;
    ULONG   ulError = _NOERROR_;

// Quick out -- is DCI enabled?

    if ( !pDCISurfInfo )
        return;

// Lock the DCI surface.

    GetClientRect(hwnd, &rc);
    pt.x = 0; pt.y = 0;
    ClientToScreen(hwnd, &pt);

// For NT, cannot hold the DCI lock when calling GetWindowRegionData
// or GetDCRegionData.

    //dciRet = DCIBeginAccess(
    //            pDCISurfInfo,
    //            pt.x,
    //            pt.y,
    //            rc.right - rc.left,
    //            rc.bottom - rc.top
    //           );
    dciRet = MyDCIBeginAccess(
                &pDCISurfInfo,
                pt.x,
                pt.y,
                rc.right - rc.left,
                rc.bottom - rc.top
               );

    if ( dciRet >= 0 )
    {
        UINT cj;
        LPRGNDATA prd;
        BOOL bChanged;

    // In WT_WINWATCH mode, we query WinWatch for a status change.

        if ( bNewWatchMode || WinWatchDidStatusChange(hww) )
        {
        // Query the visible region.

            cj = WinWatchGetClipList(hww, &rc, 0, (LPRGNDATA) NULL);
            if (!cj)
                ulError = ulError ? ulError : _DCIERROR_SIZE_;

            prd = (LPRGNDATA) LocalAlloc(LMEM_ZEROINIT|LMEM_FIXED, cj);
            if (prd)
            {
                cj = WinWatchGetClipList(hww, &rc, cj, prd);

            // Failed.  Delete data buffer and set to NULL so we don't output
            // anything.

                if ( !cj )
                {
                    ulError = ulError ? ulError : _DCIERROR_RGN_;
                    LocalFree(prd);
                    prd = (LPRGNDATA) NULL;
                }
            }
            else
            {
                if ( cj )
                    ulError = ulError ? ulError : _MEMERROR_;
            }

        // If we have the DCI lock, it must be released before we
        // draw to the screen via GDI.

            DCIEndAccess(pDCISurfInfo);

        // Print general DCI info.  Must wait until after DCIEndAccess
        // before we can output to the listbox.

            LBreset();
            DCISurfInfo();
            LBprintf("");

        // Print the method.

            LBprintf("Function: (%ld) WinWatchGetClipList", GetTickCount());

            if ( ulError != _NOERROR_ )
            {
                switch(ulError)
                {
                    case _MEMERROR_     :
                        LBprintf("ERROR: out of memory");
                        break;
                    case _DCIERROR_SIZE_:
                        LBprintf("ERROR: failed to get size of clip region data");
                        break;
                    case _DCIERROR_RGN_ :
                        LBprintf("ERROR: failed to get clip region");
                        break;
                }
            }

        // If region data retrieved, output the data to the listbox window.

            if (prd)
            {
                PrintRegionData(prd);
                LocalFree(prd);
            }
        }
        else
            DCIEndAccess(pDCISurfInfo);
    }
    else
    {
        LBprintf("ERROR: DCIBeginAccess failed, retcode = %ld (%s)\n", dciRet,
            (dciRet == DCI_FAIL_GENERIC           ) ? "DCI_FAIL_GENERIC           " :
            (dciRet == DCI_FAIL_UNSUPPORTEDVERSION) ? "DCI_FAIL_UNSUPPORTEDVERSION" :
            (dciRet == DCI_FAIL_INVALIDSURFACE    ) ? "DCI_FAIL_INVALIDSURFACE    " :
            (dciRet == DCI_FAIL_UNSUPPORTED       ) ? "DCI_FAIL_UNSUPPORTED       " :
            (dciRet == DCI_ERR_CURRENTLYNOTAVAIL  ) ? "DCI_ERR_CURRENTLYNOTAVAIL  " :
            (dciRet == DCI_ERR_INVALIDRECT        ) ? "DCI_ERR_INVALIDRECT        " :
            (dciRet == DCI_ERR_UNSUPPORTEDFORMAT  ) ? "DCI_ERR_UNSUPPORTEDFORMAT  " :
            (dciRet == DCI_ERR_UNSUPPORTEDMASK    ) ? "DCI_ERR_UNSUPPORTEDMASK    " :
            (dciRet == DCI_ERR_TOOBIGHEIGHT       ) ? "DCI_ERR_TOOBIGHEIGHT       " :
            (dciRet == DCI_ERR_TOOBIGWIDTH        ) ? "DCI_ERR_TOOBIGWIDTH        " :
            (dciRet == DCI_ERR_TOOBIGSIZE         ) ? "DCI_ERR_TOOBIGSIZE         " :
            (dciRet == DCI_ERR_OUTOFMEMORY        ) ? "DCI_ERR_OUTOFMEMORY        " :
            (dciRet == DCI_ERR_INVALIDPOSITION    ) ? "DCI_ERR_INVALIDPOSITION    " :
            (dciRet == DCI_ERR_INVALIDSTRETCH     ) ? "DCI_ERR_INVALIDSTRETCH     " :
            (dciRet == DCI_ERR_INVALIDCLIPLIST    ) ? "DCI_ERR_INVALIDCLIPLIST    " :
            (dciRet == DCI_ERR_SURFACEISOBSCURED  ) ? "DCI_ERR_SURFACEISOBSCURED  " :
            (dciRet == DCI_ERR_XALIGN             ) ? "DCI_ERR_XALIGN             " :
            (dciRet == DCI_ERR_YALIGN             ) ? "DCI_ERR_YALIGN             " :
            (dciRet == DCI_ERR_XYALIGN            ) ? "DCI_ERR_XYALIGN            " :
            (dciRet == DCI_ERR_WIDTHALIGN         ) ? "DCI_ERR_WIDTHALIGN         " :
            (dciRet == DCI_ERR_HEIGHTALIGN        ) ? "DCI_ERR_HEIGHTALIGN        " :
                                                      "unknown");
    }

    bNewWatchMode = FALSE;
}

/******************************Public*Routine******************************\
* DCIRgnInfoNotify
*
* Get and print visible region information using WinWatchNotify and
* GetWindowRegionData.
*
* History:
*  31-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void DCIRgnInfoNotify(HWND hwnd)
{
    UINT cj;
    LPRGNDATA prd;

// Quick out -- is DCI enabled?

    if ( !pDCISurfInfo )
        return;

// Print general DCI info.

    DCISurfInfo();
    LBprintf("");
    LBprintf("WinWatchNotify/GetWindowRegionData");

// Query the visible region.

    cj = GetWindowRegionData(hwnd, 0, (LPRGNDATA) NULL);
    if (!cj)
        LBprintf("ERROR: failed to get size of clip region data");

    prd = (LPRGNDATA) LocalAlloc(LMEM_ZEROINIT|LMEM_FIXED, cj);
    if (prd)
    {
        cj = GetWindowRegionData(hwnd, cj, prd);
        if ( cj )
            PrintRegionData(prd);
        else
            LBprintf("ERROR: failed to get clip region");

        LocalFree(prd);
    }
    else
    {
        if ( cj )
            LBprintf("ERROR: out of memory");
    }
}

/******************************Public*Routine******************************\
* WinWatchNotifyProc
*
* WinWatchNotify callback function.
* Effects:
*
* Warnings:
*
* History:
*  31-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void CALLBACK WinWatchNotifyProc(HWINWATCH hww, HWND hwnd, DWORD code, LPARAM lParam)
{
    switch(code)
    {
    case WINWATCHNOTIFY_START:
        LBreset();
        LBprintf("WINWATCHNOTIFY_START");
        break;
    case WINWATCHNOTIFY_STOP:
        LBprintf("WINWATCHNOTIFY_STOP");
        break;
    case WINWATCHNOTIFY_DESTROY:
        LBprintf("WINWATCHNOTIFY_DESTROY");
        break;
    case WINWATCHNOTIFY_CHANGING:
        LBprintf("WINWATCHNOTIFY_CHANGING");
        break;
    case WINWATCHNOTIFY_CHANGED:
        LBprintf("WINWATCHNOTIFY_CHANGED");
        DCIRgnInfoNotify(hwnd);
        break;
    }
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, msg);

    vsprintf(buffer, msg, ap);

    SendMessage(hwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
    SendMessage(hwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
    InvalidateRect(hwndList, NULL, TRUE);
    UpdateWindow(hwndList);

    va_end(ap);
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    SendMessage(hwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\dciinfo\dciinfo.h ===
#define IDM_WINWATCHGETCLIPLIST 1000
#define IDM_GETDCREGION         1001
#define IDM_GETWINDOWREGION     1002
#define IDM_WINWATCHNOTIFY      1003

#define IDM_HWNDTEST            2000
#define IDM_HWNDNULL            2001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\polytest.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: polytest.c
 *
 ***************************************************************************/

#include <math.h>
#include <malloc.h>
#include <time.h>
#include <ddraw.h>
#include <d3d.h>
#include "error.h"
#include "d3dsphr.h"
#include "d3dmacs.h"
#include "d3dmath.h"
#include "polytest.h"

#define MAX_OBJECTS 20
#define CAMERA_POS_POLYGON 7.0f
#define CAMERA_POS_INTERSECTION 2.0f
/*
 * Globals to keep track of execute buffer
 */
static D3DEXECUTEDATA d3dExData;
static LPDIRECT3DEXECUTEBUFFER lpD3DExBuf;
static D3DEXECUTEBUFFERDESC debDesc;
/*
 * Gobals for materials and lights
 */
static LPDIRECT3DMATERIAL lpbmat;
static LPDIRECT3DLIGHT lpD3DLight;		
/*
 * Global projection, view, world and identity matricies
 */
static D3DMATRIXHANDLE hProj;
static D3DMATRIXHANDLE hView;

static D3DMATRIX proj = {
    D3DVAL(2.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(2.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(1.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(-1.0), D3DVAL(0.0)
};
static D3DMATRIX view = {
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(7.0), D3DVAL(1.0)
};
static D3DMATRIX identity = {
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0)
};

/*
 * A structure which holds the object's data
 */
static struct {
    LPD3DVERTEX lpV;		           /* object's vertices    */
    LPD3DTRIANGLE lpTri;		   /* object's triangles   */
    int num_vertices, num_faces;
} objData;

typedef struct _orderElt {
    float	z;
    LPDIRECT3DEXECUTEBUFFER		exeBuff;
} orderElt;
static orderElt order[MAX_OBJECTS]; 

static int NumSpheres;
typedef struct tagSphereData {
    float vx, vy, vz;
    float rx, ry, rz;
    int age;
    D3DMATRIXHANDLE hMr;
    D3DMATRIXHANDLE hMdr;
    D3DMATRIXHANDLE hMp;
    D3DMATRIXHANDLE hMdp;
    D3DMATRIXHANDLE hM;
    D3DTEXTUREHANDLE hTex;
    D3DMATERIALHANDLE hmat;
    LPDIRECT3DMATERIAL lpmat;
    LPDIRECT3DEXECUTEBUFFER lpSetWorldExeBuf;
} SphereData;
static SphereData* sphere;

#define PI 3.14159265359
static float D, R, DMINUSR, DV, DR, DEPTH;
static UINT ORDER;

void MakePosMatrix(LPD3DMATRIX lpM, float x, float y, float z);
void MakeRotMatrix(LPD3DMATRIX lpM, float rx, float ry, float rz);

void
initrandom(void)
{
    srand( (unsigned)8269362521);
}

float
random(float x) {
    return ((float)rand() / RAND_MAX) * x;
}

void
tick_sphere(LPDIRECT3DDEVICE lpDev, int n)
{
    float x, y, z;
    D3DMATRIX Mp, Mdr, Mdp;
    lpDev->lpVtbl->GetMatrix(lpDev, sphere[n].hMp, &Mp);
    x = (float)Mp._41;
    y = (float)Mp._42;
    z = (float)Mp._43;
    if (x > DMINUSR || x < -DMINUSR) {
	sphere[n].vx = -sphere[n].vx;
	sphere[n].rz = -sphere[n].rz;
	sphere[n].ry = -sphere[n].ry;
	++sphere[n].age;
    }
    if (y > DMINUSR || y < -DMINUSR) {
	sphere[n].vy = -sphere[n].vy;
	sphere[n].rz = -sphere[n].rz;
	sphere[n].rx = -sphere[n].rx;
	++sphere[n].age;
    }
    if (z > DEPTH || z < -DEPTH) {
	sphere[n].vz = -sphere[n].vz;
	sphere[n].rx = -sphere[n].rx;
	sphere[n].ry = -sphere[n].ry;
	++sphere[n].age;
    }
    if (sphere[n].age) {
	MakeRotMatrix(&Mdr, sphere[n].rx, sphere[n].ry, sphere[n].rz);
	lpDev->lpVtbl->SetMatrix(lpDev, sphere[n].hMdr, &Mdr);
	MakePosMatrix(&Mdp, sphere[n].vx, sphere[n].vy, sphere[n].vz);
	lpDev->lpVtbl->SetMatrix(lpDev, sphere[n].hMdp, &Mdp);
	sphere[n].age = 0;
    }
}

static int __cdecl compareZ(const void* p1, const void* p2)
{
    orderElt* h1 = (orderElt*) p1;
    orderElt* h2 = (orderElt*) p2;
    if (ORDER == FRONT_TO_BACK) {
	if (h1->z > h2->z) return -1;
	if (h1->z < h2->z) return 1;
    } else {
	if (h1->z < h2->z) return -1;
	if (h1->z > h2->z) return 1;
    }
    return 0;
}

void
sortObjects(LPDIRECT3DDEVICE lpDev)
{
    int i;
    D3DMATRIX M;
    
    for (i = 0; i < NumSpheres; i++) {
	lpDev->lpVtbl->GetMatrix(lpDev, sphere[i].hMp, &M);
	order[i].z = (float)M._43;
	order[i].exeBuff = sphere[i].lpSetWorldExeBuf;
    }
    qsort(order, NumSpheres, sizeof(orderElt), compareZ);
}

#define MIN(x, y) (x > y) ? y : x
#define MAX(x, y) (x > y) ? x : y
/*
 * Each frame, renders the scene and calls mod_buffer to modify the object
 * for the next frame.
 */
BOOL
RenderScenePoly(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView,
                LPD3DRECT lpExtent)
{
    D3DRECT extent;
    int j;

    /*
     * Execute the instruction buffer
     */
    if (lpDev->lpVtbl->BeginScene(lpDev) != D3D_OK)
        return FALSE;
    if (ORDER != NO_SORT)
    	    sortObjects(lpDev);
    for (j = 0; j < NumSpheres; j++) {
 	tick_sphere(lpDev, j);
	if (ORDER == NO_SORT) {
	    /* we can also be sure this is the poly throughput test */
	    if (lpDev->lpVtbl->Execute(lpDev, sphere[j].lpSetWorldExeBuf,
	    				lpView, D3DEXECUTE_UNCLIPPED) != D3D_OK)
		return FALSE;
	    if (lpDev->lpVtbl->Execute(lpDev, lpD3DExBuf, lpView, D3DEXECUTE_UNCLIPPED) != D3D_OK)
		return FALSE;
	} else {
	    /* must be intersection test */
	    if (lpDev->lpVtbl->Execute(lpDev, order[j].exeBuff,
	    			       lpView, D3DEXECUTE_UNCLIPPED) != D3D_OK)
		return FALSE;
	    if (lpDev->lpVtbl->Execute(lpDev, lpD3DExBuf,
	    			       lpView, D3DEXECUTE_CLIPPED) != D3D_OK)
		return FALSE;
	}
	if (lpD3DExBuf->lpVtbl->GetExecuteData(lpD3DExBuf, &d3dExData)!= D3D_OK)
	    return FALSE;
	extent = d3dExData.dsStatus.drExtent;
    }
    if (lpDev->lpVtbl->EndScene(lpDev) != D3D_OK)
        return FALSE;
    *lpExtent = extent;
    return TRUE;
}

/*
 * Release the memory allocated for the scene and all D3D objects created.
 */
void
ReleaseViewPoly(void)
{
    int i;
    RELEASE(lpD3DLight);
    RELEASE(lpD3DExBuf);
    for (i = 0; i < NumSpheres; i++) {
	RELEASE(sphere[i].lpmat);
    }
    RELEASE(lpbmat);
    if (objData.lpV)
        free(objData.lpV);
    if (objData.lpTri)
        free(objData.lpTri);
    free(sphere);
}

void
MakePosMatrix(LPD3DMATRIX lpM, float x, float y, float z)
{
    memcpy(lpM, &identity, sizeof(D3DMATRIX));
    lpM->_41 = D3DVAL(x);
    lpM->_42 = D3DVAL(y);
    lpM->_43 = D3DVAL(z);
}

void
MakeRotMatrix(LPD3DMATRIX lpM, float rx, float ry, float rz)
{
    float ct, st;
    D3DMATRIX My, Mx, Mz, T;
    memcpy(&My, &identity, sizeof(D3DMATRIX));
    ct = D3DVAL(cos(ry));
    st = D3DVAL(sin(ry));
    My._11 = ct;
    My._13 = -st;
    My._31 = st;
    My._33 = ct;
    memcpy(&Mx, &identity, sizeof(D3DMATRIX));
    ct = D3DVAL(cos(rx));
    st = D3DVAL(sin(rx));
    Mx._22 = ct;
    Mx._23 = st;
    Mx._32 = -st;
    Mx._33 = ct;
    memcpy(&Mz, &identity, sizeof(D3DMATRIX));
    ct = D3DVAL(cos(rz));
    st = D3DVAL(sin(rz));
    Mz._11 = ct;
    Mz._12 = st;
    Mz._21 = -st;
    Mz._22 = ct;
    MultiplyD3DMATRIX(&T, &My, &Mx);
    MultiplyD3DMATRIX(lpM, &T, &Mz);
}

unsigned long
init_spheres(LPDIRECT3DDEVICE lpDev, int n)
{
    D3DMATRIX Mp, Mdp, Mdr;
    int i;
    initrandom();
    sphere = (SphereData*)malloc(n*sizeof(SphereData));
    memset(sphere, 0, n*sizeof(SphereData));
    for (i = 0; i < n; i++) {
	MakePosMatrix(&Mp, (float)DMINUSR - (float)random(2 * DMINUSR),
		      (float)DMINUSR - (float)random(2 * DMINUSR),
		      (float)-DEPTH + (float)random(2 * DEPTH));
	MAKE_MATRIX(lpDev, sphere[i].hMp, Mp);
	sphere[i].vx = (float)DV - (float)random(2 * DV);
	sphere[i].vy = (float)DV - (float)random(2 * DV);
	sphere[i].vz = (float)DV - (float)random(2 * DV);
	MakePosMatrix(&Mdp, sphere[i].vx, sphere[i].vy, sphere[i].vz);
	MAKE_MATRIX(lpDev, sphere[i].hMdp, Mdp);
	sphere[i].rx = (float)DR - (float)random(2 * DR);
	sphere[i].ry = (float)DR - (float)random(2 * DR);
	sphere[i].rz = (float)DR - (float)random(2 * DR);
	MakeRotMatrix(&Mdr, sphere[i].rx, sphere[i].ry, sphere[i].rz);
	MAKE_MATRIX(lpDev, sphere[i].hMdr, Mdr);
	MAKE_MATRIX(lpDev, sphere[i].hMr, identity);
	MAKE_MATRIX(lpDev, sphere[i].hM, identity);
    }
    return 1;
}

/*
 * Builds the scene and initializes the execute buffer for rendering.  Returns 0 on failure.
 */
 
unsigned long
InitViewPoly(LPDIRECTDRAW lpDD, LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpDev,
	     LPDIRECT3DVIEWPORT lpView, int NumTextures, LPD3DTEXTUREHANDLE TextureHandle,
             UINT num, UINT rings, UINT segs, UINT order, float radius, float d, float depth,
	     float dv, float dr)
{
    /* Pointers into the exectue buffer. */
    LPVOID lpBufStart, lpInsStart, lpPointer;
    LPDIRECT3DEXECUTEBUFFER lpD3DExCmdBuf;
    size_t size;
    int i;

    /* Light and materials */
    D3DLIGHT light;					
    D3DMATERIAL bmat;
    D3DMATERIALHANDLE hbmat;
    D3DMATERIAL mat;

    /* This sucks, but I'm tired */
    D = d;
    R = radius;
    DMINUSR = d - radius;
    DV = dv;
    DR = dr;
    DEPTH = depth;
    ORDER = order;

    NumSpheres = (int)num;

    /*
     * Generate the sphere.
     */
    if (!(GenerateSphere(R, rings, segs, (float)1.0, (float)1.0,
                         (float)1.0, &objData.lpV, &objData.lpTri,
                         &objData.num_vertices, &objData.num_faces)))
    				return 0L;
    /*
     * Set the view and projection matrices, make the world matricies
     */
    if (order == NO_SORT) {
	view._43 = CAMERA_POS_POLYGON;
    } else {
	view._43 = CAMERA_POS_INTERSECTION;
    }
    MAKE_MATRIX(lpDev, hView, view);
    MAKE_MATRIX(lpDev, hProj, proj);

    /*
     * Create buffers for world matrix set commands
     */
    init_spheres(lpDev, NumSpheres);
    for (i = 0; i < NumSpheres; i++) {
	
	/*
	 * Create a material, set its description and obtain a handle to it.
	 */
	sphere[i].hTex = TextureHandle[i % NumTextures];
	if (lpD3D->lpVtbl->CreateMaterial(lpD3D, &sphere[i].lpmat, NULL) != D3D_OK)
	    return 0L;
	memset(&mat, 0, sizeof(D3DMATERIAL));
	mat.dwSize = sizeof(D3DMATERIAL);
	mat.diffuse.r = D3DVAL(1.0);
	mat.diffuse.g = D3DVAL(1.0);
	mat.diffuse.b = D3DVAL(1.0);
	mat.diffuse.a = D3DVAL(1.0);
	mat.ambient.r = D3DVAL(1.0);
	mat.ambient.g = D3DVAL(1.0);
	mat.ambient.b = D3DVAL(1.0);
	mat.specular.r = D3DVAL(1.0);
	mat.specular.g = D3DVAL(1.0);
	mat.specular.b = D3DVAL(1.0);
	mat.power = (float)40.0;
	mat.dwRampSize = 32;
	mat.hTexture = sphere[i].hTex;
	sphere[i].lpmat->lpVtbl->SetMaterial(sphere[i].lpmat, &mat);
	sphere[i].lpmat->lpVtbl->GetHandle(sphere[i].lpmat, lpDev, &sphere[i].hmat);

        size = 0;
        size += sizeof(D3DINSTRUCTION) * 5;
        size += sizeof(D3DMATRIXMULTIPLY) * 3;
        size += sizeof(D3DSTATE) * 4;
        memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
        debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
        debDesc.dwFlags = D3DDEB_BUFSIZE;
        debDesc.dwBufferSize = size;
        if (lpDev->lpVtbl->CreateExecuteBuffer(lpDev, &debDesc, &sphere[i].lpSetWorldExeBuf,
    					   NULL) != D3D_OK)
	    return 0L;
        if (sphere[i].lpSetWorldExeBuf->lpVtbl->Lock(sphere[i].lpSetWorldExeBuf, &debDesc) != D3D_OK)
    	    return 0L;
        lpBufStart = debDesc.lpData;
        memset(lpBufStart, 0, size);
        lpPointer = lpBufStart;
        lpInsStart = lpPointer;
        OP_MATRIX_MULTIPLY(3, lpPointer);
	    MATRIX_MULTIPLY_DATA(sphere[i].hMdr, sphere[i].hMr, sphere[i].hMr, lpPointer);
	    MATRIX_MULTIPLY_DATA(sphere[i].hMdp, sphere[i].hMp, sphere[i].hMp, lpPointer);
	    MATRIX_MULTIPLY_DATA(sphere[i].hMr, sphere[i].hMp, sphere[i].hM, lpPointer);
        OP_STATE_TRANSFORM(1, lpPointer);
            STATE_DATA(D3DTRANSFORMSTATE_WORLD, sphere[i].hM, lpPointer);
	OP_STATE_LIGHT(1, lpPointer);
	    STATE_DATA(D3DLIGHTSTATE_MATERIAL, sphere[i].hmat, lpPointer);
	OP_STATE_RENDER(2, lpPointer);
	    STATE_DATA(D3DRENDERSTATE_TEXTUREHANDLE, sphere[i].hTex, lpPointer);
	    STATE_DATA(D3DRENDERSTATE_WRAPU, TRUE, lpPointer);
        OP_EXIT(lpPointer);
        /*
         * Setup the execute data describing the buffer
         */
        sphere[i].lpSetWorldExeBuf->lpVtbl->Unlock(sphere[i].lpSetWorldExeBuf);
        memset(&d3dExData, 0, sizeof(D3DEXECUTEDATA));
        d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
        d3dExData.dwInstructionOffset = (ULONG) 0;
        d3dExData.dwInstructionLength = (ULONG) ((char*)lpPointer - (char*)lpInsStart);
        sphere[i].lpSetWorldExeBuf->lpVtbl->SetExecuteData(sphere[i].lpSetWorldExeBuf, &d3dExData);
    }
    /*
     * Create a buffer for matrix set commands etc.
     */
    size = 0;
    size += sizeof(D3DINSTRUCTION) * 3;
    size += sizeof(D3DSTATE) * 3;
    memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    debDesc.dwFlags = D3DDEB_BUFSIZE;
    debDesc.dwBufferSize = size;
    if (lpDev->lpVtbl->CreateExecuteBuffer(lpDev, &debDesc, &lpD3DExCmdBuf,
    					   NULL) != D3D_OK)
	return 0L;
    if (lpD3DExCmdBuf->lpVtbl->Lock(lpD3DExCmdBuf, &debDesc) != D3D_OK)
	return 0L;
    lpBufStart = debDesc.lpData;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;

    lpInsStart = lpPointer;
    OP_STATE_TRANSFORM(2, lpPointer);
        STATE_DATA(D3DTRANSFORMSTATE_VIEW, hView, lpPointer);
        STATE_DATA(D3DTRANSFORMSTATE_PROJECTION, hProj, lpPointer);
    OP_STATE_LIGHT(1, lpPointer);
        STATE_DATA(D3DLIGHTSTATE_AMBIENT, RGBA_MAKE(10, 10, 10, 10), lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpD3DExCmdBuf->lpVtbl->Unlock(lpD3DExCmdBuf);
    memset(&d3dExData, 0, sizeof(D3DEXECUTEDATA));
    d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
    d3dExData.dwInstructionOffset = (ULONG) 0;
    d3dExData.dwInstructionLength = (ULONG) ((char*)lpPointer - (char*)lpInsStart);
    lpD3DExCmdBuf->lpVtbl->SetExecuteData(lpD3DExCmdBuf, &d3dExData);
    lpDev->lpVtbl->BeginScene(lpDev);
    lpDev->lpVtbl->Execute(lpDev, lpD3DExCmdBuf, lpView, D3DEXECUTE_UNCLIPPED);
    lpDev->lpVtbl->EndScene(lpDev);
    /*
     * We are done with the command buffer.
     */
    lpD3DExCmdBuf->lpVtbl->Release(lpD3DExCmdBuf);
    /*
     * Set background to black material
     */
    if (lpD3D->lpVtbl->CreateMaterial(lpD3D, &lpbmat, NULL) != D3D_OK)
        return 0L;
    memset(&bmat, 0, sizeof(D3DMATERIAL));
    bmat.dwSize = sizeof(D3DMATERIAL);
    bmat.dwRampSize = 1;
    lpbmat->lpVtbl->SetMaterial(lpbmat, &bmat);
    lpbmat->lpVtbl->GetHandle(lpbmat, lpDev, &hbmat);
    lpView->lpVtbl->SetBackground(lpView, hbmat);

    /*
     * Create the object execute buffer
     */
    size = sizeof(D3DVERTEX) * objData.num_vertices;
    size += sizeof(D3DPROCESSVERTICES) * 1;
    size += sizeof(D3DINSTRUCTION) * 4;
    size += sizeof(D3DTRIANGLE) * objData.num_faces;
    memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    debDesc.dwFlags = D3DDEB_BUFSIZE;
    debDesc.dwBufferSize = size;
    if (lpDev->lpVtbl->CreateExecuteBuffer(lpDev, &debDesc, &lpD3DExBuf, 
    					   NULL) != D3D_OK)
    					       return 0L;
    /*
     * lock it so it can be filled
     */
    if (lpD3DExBuf->lpVtbl->Lock(lpD3DExBuf, &debDesc) != D3D_OK)
        return 0L;
    lpBufStart = debDesc.lpData;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;

    VERTEX_DATA(objData.lpV, objData.num_vertices, lpPointer);
    /*
     * Save the location of the first instruction and add instructions to 
     * execute buffer.
     */
    lpInsStart = lpPointer;
    OP_PROCESS_VERTICES(1, lpPointer);
        PROCESSVERTICES_DATA(D3DPROCESSVERTICES_TRANSFORMLIGHT, 0, objData.num_vertices, lpPointer);
    /*
     * Make sure that the triangle data (not OP) will be QWORD aligned
     */
    if (QWORD_ALIGNED(lpPointer)) {
	OP_NOP(lpPointer);
    }
    OP_TRIANGLE_LIST(objData.num_faces, lpPointer);
        TRIANGLE_LIST_DATA(objData.lpTri, objData.num_faces, lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpD3DExBuf->lpVtbl->Unlock(lpD3DExBuf);
    memset(&d3dExData, 0, sizeof(D3DEXECUTEDATA));
    d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
    d3dExData.dwVertexCount = objData.num_vertices;
    d3dExData.dwInstructionOffset = (ULONG)((char*)lpInsStart - (char*)lpBufStart);
    d3dExData.dwInstructionLength = (ULONG)((char*)lpPointer - (char*)lpInsStart);
    lpD3DExBuf->lpVtbl->SetExecuteData(lpD3DExBuf, &d3dExData);
    /*
     *  Create the light
     */
    memset(&light, 0, sizeof(D3DLIGHT));
    light.dwSize = sizeof(D3DLIGHT);
    light.dltType = D3DLIGHT_DIRECTIONAL;
    light.dcvColor.r = D3DVAL(0.9);
    light.dcvColor.g = D3DVAL(0.9);
    light.dcvColor.b = D3DVAL(0.9);
    light.dcvColor.a = D3DVAL(1.0);
    light.dvDirection.x = D3DVALP(0.0, 12);
    light.dvDirection.y = D3DVALP(0.0, 12);
    light.dvDirection.z = D3DVALP(1.0, 12);
    light.dvAttenuation0 = (float)1.0;
    light.dvAttenuation1 = (float)0.0;
    light.dvAttenuation2 = (float)0.0;
    if (lpD3D->lpVtbl->CreateLight(lpD3D, &lpD3DLight, NULL) != D3D_OK)
    	return 0L;
    if (lpD3DLight->lpVtbl->SetLight(lpD3DLight, &light) != D3D_OK)
    	return 0L;
    if (lpView->lpVtbl->AddLight(lpView, lpD3DLight) != D3D_OK)
    	return 0L;
    return NumSpheres * objData.num_faces;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\polytest.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: polytest.h
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif
#define FRONT_TO_BACK 1
#define BACK_TO_FRONT 2
#define NO_SORT 0

// Polygon throughput test functions
BOOL RenderScenePoly(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView,
                     LPD3DRECT lpExtent);
void ReleaseViewPoly(void);
unsigned long
InitViewPoly(LPDIRECTDRAW lpDD, LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpDev,
	     LPDIRECT3DVIEWPORT lpView, int NumTextures, LPD3DTEXTUREHANDLE TextureHandle,
             UINT num, UINT rings, UINT segs, UINT order, float radius, float d, float depth,
	     float dv, float dr);



#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\d3dtest.3\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by d3dtest.rc
//
#define IDI_ICON1                       105
#define DD_LIST                         1001
#define ZBUFFER_CHECK                   1002
#define TEXTURES_CHECK                  1003
#define PERSP_CHECK                     1004
#define FLAT_RADIO                      1007
#define GOURAUD_RADIO                   1008
#define EXIT_BUTTON                     1010
#define PEAK_THROUGHPUT_TEXT            1016
#define POINT_RADIO                     1022
#define BILINEAR_RADIO                  1023
#define DEVICE_LIST                     1029
#define SYSTEM_MEMORY_CHECK             1031
#define FRONT_TO_BACK_RADIO             1032
#define BACK_TO_FRONT_RADIO             1033
#define PIXEL_FILL_RATE_BUTTON          1034
#define POLYGON_THROUGHPUT_BUTTON       1035
#define ALL_TESTS_BUTTON                1036
#define PEAK_FRONT_TO_BACK_FILL_RATE_TEXT 1037
#define PEAK_BACK_TO_FRONT_FILL_RATE_TEXT 1038
#define LAST_FILL_RATE_TEXT             1039
#define LAST_THROUGHPUT_TEXT            1040
#define INTERSECTION_THROUGHPUT_BUTTON  1042
#define LAST_INTERSECTION_TEXT          1043
#define PEAK_FRONT_TO_BACK_INTERSECTION_TEXT 1044
#define PEAK_BACK_TO_FRONT_INTERSECTION_TEXT 1045
#define COPY_RADIO                      1046
#define NO_UPDATES_CHECK                1047
#define MONO_RADIO                      1048
#define RGB_RADIO                       1049
#define SPECULAR_CHECK                  1050
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1051
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\dino\glxdino.c ===
/* $Revision: 1.4 $ */
/* compile: cc -o glxdino glxdino.c -lGLU -lGL -lX11 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>		/* for cos() and sin() */
#include <GL/glx.h>		/* this includes the necessary X and gl.h headers */
#include <GL/glu.h>

typedef enum {
    RESERVED, BODY_SIDE, BODY_EDGE, BODY_WHOLE, ARM_SIDE, ARM_EDGE, ARM_WHOLE,
    LEG_SIDE, LEG_EDGE, LEG_WHOLE, EYE_SIDE, EYE_EDGE, EYE_WHOLE, DINOSAUR
}               displayLists;

Display        *dpy;
Window          win;
GLfloat         angle = 0.5; /* in radians */
GLboolean       doubleBuffer = GL_TRUE, iconic = GL_FALSE, keepAspect = GL_FALSE;
int             W = 300, H = 300;
XSizeHints      sizeHints = {0};
GLdouble        bodyWidth = 2.0;

int             dblBuf[] = {GLX_DOUBLEBUFFER, GLX_RGBA, GLX_DEPTH_SIZE, 16, None};
GLfloat         lightGreen[] = {0.1, 1.0, 0.3}, darkGreen[] = {0.0, 0.4, 0.1},
		anotherGreen[] = {0.0, 0.8, 0.1}, bloodRed[] = {1.0, 0.0, 0.1};
GLfloat         body[][2] = { {0, 3}, {1, 1}, {5, 1}, {8, 4}, {10, 4}, {11, 5}, {11, 11.5},
		{13, 12}, {13, 13}, {10, 13.5}, {13, 14}, {13, 15}, {11, 16}, {8, 16}, {7, 15},
		{7, 13}, {8, 12}, {7, 11}, {6, 6}, {4, 3}, {3, 2}, {1, 2}};
GLfloat         arm[][2] = { {8, 10}, {9, 9}, {10, 9}, {13, 8}, {14, 9}, {16, 9}, {15, 9.5},
		{16, 10}, {15, 10}, {15.5, 11}, {14.5, 10}, {14, 11}, {14, 10}, {13, 9}, {11, 11},
		{9, 11}};
GLfloat         leg[][2] = { {8, 6}, {8, 4}, {9, 3}, {9, 2}, {8, 1}, {8, 0.5}, {9, 0}, {12, 0},
		{10, 1}, {10, 2}, {12, 4}, {11, 6}, {10, 7}, {9, 7}};
GLfloat         eye[][2] = { {8.75, 15}, {9, 14.7}, {9.6, 14.7}, {10.1, 15}, {9.6, 15.25},
		{9, 15.25}};

void
fatalError(char *message)
{
    fprintf(stderr, "glxdino: %s\n", message);
    exit(1);
}

void
extrudeSolidFromPolygon(GLfloat data[][2], unsigned int dataSize, GLdouble thickness, GLuint side,
                        GLuint edge, GLuint whole, GLfloat * sideColor, GLfloat * edgeColor)
{
    static GLUtriangulatorObj *tobj = NULL;
    GLdouble        vertex[3];
    int             i;

    if (tobj == NULL) {
	tobj = gluNewTess(); /* create and initialize a GLU polygon tesselation object */
	gluTessCallback(tobj, GLU_BEGIN, glBegin);
	gluTessCallback(tobj, GLU_VERTEX, glVertex2fv); /* semi-tricky */
	gluTessCallback(tobj, GLU_END, glEnd);
    }
    glNewList(side, GL_COMPILE);
        gluBeginPolygon(tobj);
            for (i = 0; i < dataSize / (2 * sizeof(GLfloat)); i++) {
	        vertex[0] = data[i][0]; vertex[1] = data[i][1]; vertex[2] = 0;
	        gluTessVertex(tobj, vertex, &data[i]);
            }
        gluEndPolygon(tobj);
    glEndList();
    glNewList(edge, GL_COMPILE);
        glBegin(GL_QUAD_STRIP);
            for (i = 0; i < dataSize / (2 * sizeof(GLfloat)); i++) {
	        vertex[0] = data[i][0]; vertex[1] = data[i][1]; vertex[2] = 0;
	        glVertex3dv(vertex);
	        vertex[2] = thickness;
	        glVertex3dv(vertex);
            }
            vertex[0] = data[0][0]; vertex[1] = data[0][1]; vertex[2] = 0;
            glVertex3dv(vertex);
            vertex[2] = thickness;
            glVertex3dv(vertex);
        glEnd();
    glEndList();
    glNewList(whole, GL_COMPILE);
        glColor3fv(edgeColor);
        glFrontFace(GL_CW);
        glCallList(edge);
        glColor3fv(sideColor);
        glCallList(side);
        glPushMatrix();
            glTranslatef(0.0, 0.0, thickness);
            glFrontFace(GL_CCW);
            glCallList(side);
        glPopMatrix();
    glEndList();
}

void
makeDinosaur(void)
{
    GLfloat         bodyWidth = 3.0;

    extrudeSolidFromPolygon(body, sizeof(body), bodyWidth, BODY_SIDE, BODY_EDGE,
			    BODY_WHOLE, lightGreen, darkGreen);
    extrudeSolidFromPolygon(arm, sizeof(arm), bodyWidth / 4, ARM_SIDE, ARM_EDGE,
			    ARM_WHOLE, darkGreen, anotherGreen);
    extrudeSolidFromPolygon(leg, sizeof(leg), bodyWidth / 2, LEG_SIDE, LEG_EDGE,
			    LEG_WHOLE, darkGreen, anotherGreen);
    extrudeSolidFromPolygon(eye, sizeof(eye), bodyWidth + 0.2, EYE_SIDE, EYE_EDGE,
			    EYE_WHOLE, bloodRed, bloodRed);
    glNewList(DINOSAUR, GL_COMPILE);
        glCallList(BODY_WHOLE);
        glPushMatrix();
            glTranslatef(0.0, 0.0, -0.1);
            glCallList(EYE_WHOLE);
            glTranslatef(0.0, 0.0, bodyWidth + 0.1);
            glCallList(ARM_WHOLE);
            glCallList(LEG_WHOLE);
            glTranslatef(0.0, 0.0, -bodyWidth - bodyWidth / 4);
            glCallList(ARM_WHOLE);
            glTranslatef(0.0, 0.0, -bodyWidth / 4);
            glCallList(LEG_WHOLE);
        glPopMatrix();
    glEndList();
}

void
redraw(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glCallList(DINOSAUR);
    if (doubleBuffer) glXSwapBuffers(dpy, win);	/* buffer swap does implicit glFlush */
        else glFlush();				/* explicit flush for single buffered case */
}

void
main(int argc, char **argv)
{
    XVisualInfo    *vi;
    Colormap        cmap;
    XSetWindowAttributes swa;
    XWMHints       *wmHints;
    Atom            wmDeleteWindow;
    GLXContext      cx;
    XEvent          event;
    GLboolean       needRedraw = GL_FALSE, recalcModelView = GL_TRUE;
    char           *display = NULL, *geometry = NULL;
    int             dummy, flags, x, y, width, height, lastX, i;

    /*** (1) process normal X command line arguments ***/
    for (i = 1; i < argc; i++) {
	if (!strcmp(argv[i], "-geometry")) {
	    i++;
	    if (i >= argc) fatalError("follow -geometry option with geometry parameter");
	    geometry = argv[i];
	} else if (!strcmp(argv[i], "-display")) {
	    i++;
	    if (i >= argc) fatalError("follow -display option with display parameter");
	    display = argv[i];
	} else if (!strcmp(argv[i], "-iconic")) iconic = GL_TRUE;
	else if (!strcmp(argv[i], "-keepaspect")) keepAspect = GL_TRUE;
	else fatalError("bad option");
    }

    /*** (2) open a connection to the X server ***/
    dpy = XOpenDisplay(display);
    if (dpy == NULL) fatalError("could not open display");

    /*** (3) make sure OpenGL's GLX extension supported ***/
    if (!glXQueryExtension(dpy, &dummy, &dummy)) fatalError("X server has no OpenGL GLX extension");

    /*** (4) find an appropriate visual ***/
    /* find an OpenGL-capable RGB visual with depth buffer */
    vi = glXChooseVisual(dpy, DefaultScreen(dpy), dblBuf);
    if (vi == NULL) {
	vi = glXChooseVisual(dpy, DefaultScreen(dpy), &dblBuf[1]);
	if (vi == NULL) fatalError("no RGB visual with depth buffer");
	doubleBuffer = GL_FALSE;
    }
    if (vi->class != TrueColor) fatalError("TrueColor visual required for this program");

    /*** (5) create an OpenGL rendering context  ***/
    /* create an OpenGL rendering context */
    cx = glXCreateContext(dpy, vi, /* no sharing of display lists */ None,
			   /* direct rendering if possible */ GL_TRUE);
    if (cx == NULL) fatalError("could not create rendering context");

    /*** (6) create an X window with the selected visual and right properties ***/
    flags = XParseGeometry(geometry, &x, &y, (unsigned int *) &width, (unsigned int *) &height);
    if (WidthValue & flags) {
	sizeHints.flags |= USSize;
	sizeHints.width = width;
	W = width;
    }
    if (HeightValue & flags) {
	sizeHints.flags |= USSize;
	sizeHints.height = height;
	H = height;
    }
    if (XValue & flags) {
	if (XNegative & flags) x = DisplayWidth(dpy, DefaultScreen(dpy)) + x - sizeHints.width;
	sizeHints.flags |= USPosition;
	sizeHints.x = x;
    }
    if (YValue & flags) {
	if (YNegative & flags) y = DisplayHeight(dpy, DefaultScreen(dpy)) + y - sizeHints.height;
	sizeHints.flags |= USPosition;
	sizeHints.y = y;
    }
    if (keepAspect) {
	sizeHints.flags |= PAspect;
	sizeHints.min_aspect.x = sizeHints.max_aspect.x = W;
	sizeHints.min_aspect.y = sizeHints.max_aspect.y = H;
    }
    /* create an X colormap since probably not using default visual */
    cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen), vi->visual, AllocNone);
    swa.colormap = cmap;
    swa.border_pixel = 0;
    swa.event_mask = ExposureMask | ButtonPressMask | Button1MotionMask | StructureNotifyMask;
    win = XCreateWindow(dpy, RootWindow(dpy, vi->screen), sizeHints.x, sizeHints.y, W, H,
                        0, vi->depth, InputOutput, vi->visual,
			CWBorderPixel|CWColormap|CWEventMask, &swa);
    XSetStandardProperties(dpy, win, "OpenGLosaurus", "glxdino", None, argv, argc, &sizeHints);
    wmHints = XAllocWMHints();
    wmHints->initial_state = iconic ? IconicState : NormalState;
    wmHints->flags = StateHint;
    XSetWMHints(dpy, win, wmHints);
    wmDeleteWindow = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
    XSetWMProtocols(dpy, win, &wmDeleteWindow, 1);

    /*** (7) bind the rendering context to the window ***/
    glXMakeCurrent(dpy, win, cx);

    /*** (8) make the desired display lists ***/
    makeDinosaur();

    /*** (9) request the X window to be displayed on the screen ***/
    XMapWindow(dpy, win);

    /*** (10) configure the OpenGL context for rendering ***/
    glEnable(GL_CULL_FACE);	/* ~50% better perfomance than non-face culled on Starter Indigo */
    glEnable(GL_DEPTH_TEST);		/* enable depth buffering */
    glClearColor(0.0, 0.0, 0.0, 0.0);	/* frame buffer clears should be to black */
    glMatrixMode(GL_PROJECTION);	/* set up projection transform */
    glLoadIdentity();
    gluPerspective(40.0, 1, 1.0, 40.0);
    glMatrixMode(GL_MODELVIEW);		/* now change to modelview */

    /*** (11) dispatch X events ***/
    while (1) {
	do {
	    XNextEvent(dpy, &event);
	    switch (event.type) {
	    case ButtonPress:
		lastX = event.xbutton.x;
		break;
	    case MotionNotify:
		recalcModelView = GL_TRUE;
		angle += (lastX - event.xmotion.x) / (GLfloat) 50; /* fifty is empirical scale factor */
		lastX = event.xmotion.x;
		break;
	    case ConfigureNotify:
		glViewport(0, 0, event.xconfigure.width, event.xconfigure.height);
		/* fall through... */
	    case Expose:
		needRedraw = GL_TRUE;
		break;
	    case ClientMessage:
		if (event.xclient.data.l[0] == wmDeleteWindow) exit(0);
		break;
	    }
	} while (XPending(dpy));/* loop to compress events */
	if (recalcModelView) {
	    /* reset modelview matrix to the identity matrix */
	    glLoadIdentity();
	    gluLookAt(30 * sin(angle), 0, 30 * cos(angle), 0, 0, 0, 0, 1, 0);
	    glTranslatef(-8, -8, -bodyWidth / 2);
	    recalcModelView = GL_FALSE;
	    needRedraw = GL_TRUE;
	}
	if (needRedraw) {
	    redraw();
	    needRedraw = GL_FALSE;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\dino\dino.c ===
#define SIMPLE_ORTHO
//#define UNIT_CUBE

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ptypes32.h>
#include <pwin32.h>

#include <math.h>
#include <GL\gl.h>
#include <GL/glu.h>

long WndProc ( HWND hwnd, UINT message, DWORD wParam, LONG lParam );
void DrawGLStuff( );
void InitGL( HWND hWnd );


#define TERMINATE   DbgPrint("%s (%d)\n", __FILE__, __LINE__), ExitProcess(0)

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

int	STARTX = 200, STARTY = 50;
int     W = 300, H = 300;

// Globals
HDC hDc;
HGLRC hRc;

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "TriRast";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
        wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = STARTX;
    Rect.top    = STARTY;
    Rect.right  = STARTX + W;
    Rect.bottom = STARTY + H;

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

DbgPrint("CreateWindow in app\n");
printf("CreateWindow in app\n");

    hwnd = CreateWindow  (  szAppName,              // window class name
                            "The Dino Program",     // window caption
                            WS_OVERLAPPEDWINDOW,    // window style
                            Rect.left,              // initial x position
                            Rect.top,               // initial y position
                            WINDSIZEX(Rect),        // initial x size
                            WINDSIZEY(Rect),        // initial y size
                            NULL,                   // parent window handle
                            NULL,                   // window menu handle
                            hInstance,              // program instance handle
                            NULL                    // creation parameter

                        );
DbgPrint("Back CreateWindow in app\n");
    hDc = GetDC(hwnd);
DbgPrint("hDc in app is 0x%x\n", hDc);

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    return( msg.wParam );
}


long
WndProc (   HWND hWnd,
            UINT message,
            DWORD wParam,
            LONG lParam
        )
{
    PAINTSTRUCT ps;
    HDC paintdc;

    switch ( message )
    {
        case WM_PAINT:
DbgPrint("WM_PAINT\n");
            if (hRc == NULL)
                InitGL(hWnd);

            paintdc = BeginPaint( hWnd, &ps );
DbgPrint("paintdc is 0x%x\n", paintdc);

            DrawGLStuff();

            EndPaint( hWnd, &ps );
            return(0);

        case WM_DESTROY:
            wglDeleteContext( hRc );
            PostQuitMessage( 0 );
            return( 0 );


    }
    return( DefWindowProc( hWnd, message, wParam, lParam ) );

}

typedef enum {
    RESERVED, BODY_SIDE, BODY_EDGE, BODY_WHOLE, ARM_SIDE, ARM_EDGE, ARM_WHOLE,
    LEG_SIDE, LEG_EDGE, LEG_WHOLE, EYE_SIDE, EYE_EDGE, EYE_WHOLE, DINOSAUR
}               displayLists;

GLfloat         angle = 0.5; /* in radians */
GLboolean       doubleBuffer = GL_FALSE, iconic = GL_FALSE, keepAspect = GL_FALSE;
GLdouble        bodyWidth = 2.0;

GLfloat         lightGreen[] = {0.1, 1.0, 0.3}, darkGreen[] = {0.0, 0.4, 0.1},
		anotherGreen[] = {0.0, 0.8, 0.1}, bloodRed[] = {1.0, 0.0, 0.1};
GLfloat         body[][2] = { {0, 3}, {1, 1}, {5, 1}, {8, 4}, {10, 4}, {11, 5}, {11, 11.5},
		{13, 12}, {13, 13}, {10, 13.5}, {13, 14}, {13, 15}, {11, 16}, {8, 16}, {7, 15},
		{7, 13}, {8, 12}, {7, 11}, {6, 6}, {4, 3}, {3, 2}, {1, 2}};
GLfloat         arm[][2] = { {8, 10}, {9, 9}, {10, 9}, {13, 8}, {14, 9}, {16, 9}, {15, 9.5},
		{16, 10}, {15, 10}, {15.5, 11}, {14.5, 10}, {14, 11}, {14, 10}, {13, 9}, {11, 11},
		{9, 11}};
GLfloat         leg[][2] = { {8, 6}, {8, 4}, {9, 3}, {9, 2}, {8, 1}, {8, 0.5}, {9, 0}, {12, 0},
		{10, 1}, {10, 2}, {12, 4}, {11, 6}, {10, 7}, {9, 7}};
GLfloat         eye[][2] = { {8.75, 15}, {9, 14.7}, {9.6, 14.7}, {10.1, 15}, {9.6, 15.25},
		{9, 15.25}};

void
extrudeSolidFromPolygon(GLfloat data[][2], unsigned int dataSize, GLdouble thickness, GLuint side,
                        GLuint edge, GLuint whole, GLfloat * sideColor, GLfloat * edgeColor)
{
    static GLUtriangulatorObj *tobj = NULL;
    GLdouble        vertex[3];
    int             i;

    if (tobj == NULL) {
	tobj = gluNewTess(); /* create and initialize a GLU polygon tesselation object */
	gluTessCallback(tobj, GLU_BEGIN, glBegin);
	gluTessCallback(tobj, GLU_VERTEX, glVertex2fv); /* semi-tricky */
	gluTessCallback(tobj, GLU_END, glEnd);
    }
    glNewList(side, GL_COMPILE);
        gluBeginPolygon(tobj);
            for (i = 0; i < dataSize / (2 * sizeof(GLfloat)); i++) {
	        vertex[0] = data[i][0]; vertex[1] = data[i][1]; vertex[2] = 0;
	        gluTessVertex(tobj, vertex, &data[i]);
            }
        gluEndPolygon(tobj);
    glEndList();
    glNewList(edge, GL_COMPILE);
        glBegin(GL_QUAD_STRIP);
            for (i = 0; i < dataSize / (2 * sizeof(GLfloat)); i++) {
	        vertex[0] = data[i][0]; vertex[1] = data[i][1]; vertex[2] = 0;
	        glVertex3dv(vertex);
	        vertex[2] = thickness;
	        glVertex3dv(vertex);
            }
            vertex[0] = data[0][0]; vertex[1] = data[0][1]; vertex[2] = 0;
            glVertex3dv(vertex);
            vertex[2] = thickness;
            glVertex3dv(vertex);
        glEnd();
    glEndList();
    glNewList(whole, GL_COMPILE);
        glColor3fv(edgeColor);
        glFrontFace(GL_CW);
        glCallList(edge);
        glColor3fv(sideColor);
        glCallList(side);
        glPushMatrix();
            glTranslatef(0.0, 0.0, thickness);
            glFrontFace(GL_CCW);
            glCallList(side);
        glPopMatrix();
    glEndList();
}

void
makeDinosaur(void)
{
    GLfloat         bodyWidth = 3.0;

DbgPrint("makeDino\n");
    extrudeSolidFromPolygon(body, sizeof(body), bodyWidth, BODY_SIDE, BODY_EDGE,
			    BODY_WHOLE, lightGreen, darkGreen);
    extrudeSolidFromPolygon(arm, sizeof(arm), bodyWidth / 4, ARM_SIDE, ARM_EDGE,
			    ARM_WHOLE, darkGreen, anotherGreen);
    extrudeSolidFromPolygon(leg, sizeof(leg), bodyWidth / 2, LEG_SIDE, LEG_EDGE,
			    LEG_WHOLE, darkGreen, anotherGreen);
    extrudeSolidFromPolygon(eye, sizeof(eye), bodyWidth + 0.2, EYE_SIDE, EYE_EDGE,
			    EYE_WHOLE, bloodRed, bloodRed);
    glNewList(DINOSAUR, GL_COMPILE);
        glCallList(BODY_WHOLE);
        glPushMatrix();
            glTranslatef(0.0, 0.0, -0.1);
            glCallList(EYE_WHOLE);
            glTranslatef(0.0, 0.0, bodyWidth + 0.1);
            glCallList(ARM_WHOLE);
            glCallList(LEG_WHOLE);
            glTranslatef(0.0, 0.0, -bodyWidth - bodyWidth / 4);
            glCallList(ARM_WHOLE);
            glTranslatef(0.0, 0.0, -bodyWidth / 4);
            glCallList(LEG_WHOLE);
        glPopMatrix();
    glEndList();
}

void
InitGL( HWND hWnd )
{
    RECT Rect;


    DbgPrint("InitGL");
    /* Get the size of the client area */

    GetClientRect( hWnd, &Rect );

    DbgPrint("GetClientRect: hdc 0x%x (%d, %d) (%d, %d)\n",
        hDc,
        Rect.left,
        Rect.top,
        Rect.right,
        Rect.bottom );

    /* Create a Rendering Context */

    hRc = wglCreateContext( hDc );

    /* Make it Current */

    wglMakeCurrent( hDc, hRc );

    makeDinosaur();

    glEnable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);		/* enable depth buffering */
    glClearColor(0.0, 0.0, 0.0, 0.0);	/* frame buffer clears to black */
    glMatrixMode(GL_PROJECTION);	/* set up projection transform */
    glLoadIdentity();
    gluPerspective(40.0, 1, 1.0, 40.0);
    glMatrixMode(GL_MODELVIEW);		/* now change to modelview */


}

void
DrawGLStuff( )
{
DbgPrint("DrawGLStuff\n");
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glCallList(DINOSAUR);
    glFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\d3dexbuf.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "d3drend.h"
#include "util.h"

D3dExecuteBuffer::D3dExecuteBuffer(void)
{
    _pdeb = NULL;
}

BOOL D3dExecuteBuffer::Initialize(LPDIRECT3DDEVICE pd3dev, UINT cbSize,
                                  UINT uiFlags)
{
    D3DEXECUTEBUFFERDESC debd;
    LPDIRECT3DEXECUTEBUFFER pdeb;
    
    memset(&debd, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debd.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    debd.dwFlags = D3DDEB_BUFSIZE;
    debd.dwBufferSize = cbSize;
    if (uiFlags & REND_BUFFER_VIDEO_MEMORY)
    {
        debd.dwCaps = D3DDEBCAPS_VIDEOMEMORY;
        debd.dwFlags |= D3DDEB_CAPS;
    }
    if (pd3dev->CreateExecuteBuffer(&debd, &_pdeb, NULL) != D3D_OK)
    {
        return FALSE;
    }
    
    SetData(0, 0, cbSize);
    return TRUE;
}

D3dExecuteBuffer::~D3dExecuteBuffer(void)
{
    RELEASE(_pdeb);
}

void D3dExecuteBuffer::Release(void)
{
    delete this;
}
    
void* D3dExecuteBuffer::Lock(void)
{
    D3DEXECUTEBUFFERDESC debd;
    
    memset(&debd, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debd.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    debd.dwFlags = 0;
    hrLast = _pdeb->Lock(&debd);
    if (hrLast != D3D_OK)
    {
        return FALSE;
    }
    return debd.lpData;
}

void D3dExecuteBuffer::Unlock(void)
{
    _pdeb->Unlock();
}
    
void D3dExecuteBuffer::SetData(UINT nVertices, UINT cbStart, UINT cbSize)
{
    D3DEXECUTEDATA ded;

    memset(&ded, 0, sizeof(D3DEXECUTEDATA));
    ded.dwSize = sizeof(D3DEXECUTEDATA);
    ded.dwVertexCount = nVertices;
    ded.dwInstructionOffset = cbStart;
    ded.dwInstructionLength = cbSize;
    hrLast = _pdeb->SetExecuteData(&ded);
}

BOOL D3dExecuteBuffer::Process(void)
{
    // Nothing to do
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\d3dmatrx.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "d3drend.h"
#include "util.h"

D3dMatrix::D3dMatrix(void)
{
    _dmh = 0;
}

BOOL D3dMatrix::Initialize(LPDIRECT3DDEVICE pd3dev)
{
    _pd3dev = pd3dev;
    hrLast = pd3dev->CreateMatrix(&_dmh);
    return hrLast == D3D_OK;
}

D3dMatrix::~D3dMatrix(void)
{
    if (_dmh != NULL)
    {
        _pd3dev->DeleteMatrix(_dmh);
    }
}

void D3dMatrix::Release(void)
{
    delete this;
}
    
D3DMATRIXHANDLE D3dMatrix::Handle(void)
{
    return _dmh;
}

void D3dMatrix::Get(D3DMATRIX *pdm)
{
    _pd3dev->GetMatrix(_dmh, pdm);
}

void D3dMatrix::Set(D3DMATRIX *pdm)
{
    _pd3dev->SetMatrix(_dmh, pdm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\d3dmatrl.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "d3drend.h"
#include "util.h"

D3dMaterial::D3dMaterial(void)
{
    _pdmat = NULL;
}

BOOL D3dMaterial::Initialize(LPDIRECT3D pd3d, LPDIRECT3DDEVICE pd3dev,
                             UINT nColorEntries)
{
    D3DCOLORVALUE dcol;

    _pd3dev = pd3dev;
    hrLast = pd3d->CreateMaterial(&_pdmat, NULL);
    if (hrLast != D3D_OK)
    {
        return FALSE;
    }

    memset(&_dmat, 0, sizeof(_dmat));
    _dmat.dwSize = sizeof(_dmat);
    dcol.r = D3DVAL(1);
    dcol.g = D3DVAL(1);
    dcol.b = D3DVAL(1);
    dcol.a = D3DVAL(1);
    _dmat.dcvDiffuse = dcol;
    _dmat.dcvAmbient = dcol;
    _dmat.dcvSpecular = dcol;
    _dmat.dwRampSize = nColorEntries;
    hrLast = _pdmat->SetMaterial(&_dmat);
    return hrLast == D3D_OK;
}

D3dMaterial::~D3dMaterial(void)
{
    _pdmat->Release();
}

void D3dMaterial::Release(void)
{
    delete this;
}

D3DMATERIALHANDLE D3dMaterial::Handle(void)
{
    D3DMATERIALHANDLE dmath;

    hrLast = _pdmat->GetHandle(_pd3dev, &dmath);
    if (hrLast != D3D_OK)
    {
        return NULL;
    }
    return dmath;
}

void D3dMaterial::SetDiffuse(D3DCOLORVALUE* pdcol)
{
    _dmat.dcvAmbient = *pdcol;
    _dmat.dcvDiffuse = *pdcol;
    hrLast = _pdmat->SetMaterial(&_dmat);
}

void D3dMaterial::SetSpecular(D3DCOLORVALUE* pdcol, float fPower)
{
    _dmat.dcvSpecular = *pdcol;
    _dmat.dvPower = D3DVAL(fPower);
    hrLast = _pdmat->SetMaterial(&_dmat);
}

void D3dMaterial::SetTexture(RendTexture *prtex)
{
    if (prtex != NULL)
    {
        _dmat.hTexture = prtex->Handle();
    }
    else
    {
        _dmat.hTexture = NULL;
    }
    hrLast = _pdmat->SetMaterial(&_dmat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\d3drend.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "d3drend.h"
#include "util.h"
#include "globals.h"

/*
 * Last DD or D3D error
 */
HRESULT hrLast = S_OK;

D3dRenderer::D3dRenderer(void)
{
    int i;
    
    /*
     * Direct3D globals
     */
    _nD3dDrivers = 0;
    for (i = 0; i < D3D_DRIVER_COUNT; i++)
    {
        memset(&_d3diDriver[i], 0, sizeof(D3dDriverInfo));
    }

    _iDD = -1;
    _iD3D = -1;
    _pdd = NULL;
    _pd3d = NULL;
    _bCurrentFullscreenMode = FALSE;
}

void D3dRenderer::Name(char* psz)
{
    strcpy(psz, "Direct3D");
}

char* D3dRenderer::LastErrorString(void)
{
    return D3dErrorString(hrLast);
}
 
BOOL D3dRenderer::Initialize(HWND hwndParent)
{
    return TRUE;
}

void D3dRenderer::Uninitialize(void)
{
}

BOOL FAR PASCAL DDEnumCallback(GUID FAR* lpGUID, LPSTR lpDriverDesc,
                               LPSTR lpDriverName, LPVOID lpContext)
{
    LPDIRECTDRAW lpDD;
    DDCAPS DriverCaps, HELCaps;
    D3dRenderer *pdrend = (D3dRenderer *)lpContext;

    if (lpGUID) {
	hrLast = DirectDrawCreate(lpGUID, &lpDD, NULL);
	if (hrLast != DD_OK) {
	    Msg("Failing while creating a DD device for testing.  "
                "Continuing with execution.\n%s", D3dErrorString(hrLast));
	    return DDENUMRET_OK;
	}
	memset(&DriverCaps, 0, sizeof(DDCAPS));
	DriverCaps.dwSize = sizeof(DDCAPS);
	memset(&HELCaps, 0, sizeof(DDCAPS));
	HELCaps.dwSize = sizeof(DDCAPS);
	hrLast = lpDD->GetCaps(&DriverCaps, &HELCaps);
	if (hrLast != DD_OK) {
	    Msg("GetCaps failed in while testing a DD device.  "
                "Continuing with execution.\n%s", D3dErrorString(hrLast));
	    RELEASE(lpDD);
	    return DDENUMRET_OK;
	}
	RELEASE(lpDD);
	if (DriverCaps.dwCaps & DDCAPS_3D) {
	    /*
	     * We have found a 3d hardware device
	     */
	    memcpy(&pdrend->_ddiDriver[pdrend->_nDdDrivers].guid,
                   lpGUID, sizeof(GUID));
	    memcpy(&pdrend->_ddiDriver[pdrend->_nDdDrivers].ddcapsHw,
                   &DriverCaps,
                   sizeof(DDCAPS));
	    lstrcpy(pdrend->_ddiDriver[pdrend->_nDdDrivers].achName,
                   lpDriverName);
	    pdrend->_ddiDriver[pdrend->_nDdDrivers].bIsPrimary = FALSE;
	    pdrend->_iDD = pdrend->_nDdDrivers;
	    ++pdrend->_nDdDrivers;
	    if (pdrend->_nDdDrivers == 5)
		return (D3DENUMRET_CANCEL);
	}
    } else {
	/*
	 * It's the primary, fill in some fields.
	 */
	pdrend->_ddiDriver[pdrend->_nDdDrivers].bIsPrimary = TRUE;
	lstrcpy(pdrend->_ddiDriver[pdrend->_nDdDrivers].achName,
                "Primary Device");
	pdrend->_iDD = pdrend->_nDdDrivers;
	++pdrend->_nDdDrivers;
	if (pdrend->_nDdDrivers == 5)
	    return (D3DENUMRET_CANCEL);
    }
    return DDENUMRET_OK;
}

BOOL D3dRenderer::EnumDisplayDrivers(RendEnumDriversFn pfn,
                                     void* pvArg)
{
    int i;
    RendDriverDescription rdd;
    
    _nDdDrivers = 0;
    _iDD = 0; 
    hrLast = DirectDrawEnumerate(DDEnumCallback, this);
    if (hrLast != DD_OK) {
	Msg("DirectDrawEnumerate failed.\n%s", D3dErrorString(hrLast));
	return FALSE;
    }

    for (i = 0; i < _nDdDrivers; i++)
    {
        rdd.rid = (RendId)i;
        strcpy(rdd.achName, _ddiDriver[i].achName);
        if (!pfn(&rdd, pvArg))
        {
            return FALSE;
        }
    }
    
    return TRUE;
}

BOOL D3dRenderer::EnumGraphicsDrivers(RendEnumDriversFn pfn,
                                     void* pvArg)
{
    UINT i;
    RendDriverDescription rdd;

    for (i = 0; i < _nD3dDrivers; i++)
    {
        rdd.rid = (RendId)i;
        strcpy(rdd.achName, _d3diDriver[i].achName);
        if (!pfn(&rdd, pvArg))
        {
            return FALSE;
        }
    }
    
    return TRUE;
}

/*
 * enumDeviceFunc
 * Enumeration function for EnumDevices
 */
HRESULT WINAPI EnumDeviceFunc(LPGUID pguid,
	LPSTR lpDeviceDescription, LPSTR lpDeviceName,
	LPD3DDEVICEDESC pd3ddHw, LPD3DDEVICEDESC pd3ddHel, LPVOID lpContext)
{
    D3dRenderer *pdrend = (D3dRenderer *)lpContext;
    
    if (pdrend->_ddiDriver[pdrend->_iDD].bIsPrimary)
    {
	if (pd3ddHw->dcmColorModel &&
            !(pd3ddHw->dwDeviceRenderBitDepth & pdrend->_dwWinBpp))
        {
	    return (D3DENUMRET_OK);
	}
	if (pd3ddHel->dcmColorModel &&
            !(pd3ddHel->dwDeviceRenderBitDepth & pdrend->_dwWinBpp))
        {
	    return (D3DENUMRET_OK);
	}
    }
    pdrend->_d3diDriver[pdrend->_nD3dDrivers].pguid = pguid;
    lstrcpy(pdrend->_d3diDriver[pdrend->_nD3dDrivers].achDesc,
            lpDeviceDescription);
    lstrcpy(pdrend->_d3diDriver[pdrend->_nD3dDrivers].achName, lpDeviceName);
    memcpy(&pdrend->_d3diDriver[pdrend->_nD3dDrivers].d3ddHw, pd3ddHw,
           sizeof(D3DDEVICEDESC));
    memcpy(&pdrend->_d3diDriver[pdrend->_nD3dDrivers].d3ddHel, pd3ddHel,
           sizeof(D3DDEVICEDESC));
    pdrend->_nD3dDrivers++;
    if (pdrend->_nD3dDrivers == 5)
        return (D3DENUMRET_CANCEL);
    return (D3DENUMRET_OK);
}

/*
 * EnumDisplayModesCallback
 * Callback to save the display mode information.
 */
HRESULT CALLBACK EnumDisplayModesCallback(LPDDSURFACEDESC pddsd,
                                          LPVOID Context)
{
    D3dRenderer *pdrend = (D3dRenderer *)Context;
    
    // ATTENTION - Why the bpp restriction?
    if (pddsd->dwWidth >= WIN_WIDTH && pddsd->dwHeight >= WIN_HEIGHT &&
        pddsd->ddpfPixelFormat.dwRGBBitCount == 16)
    {
	pdrend->_mleModeList[pdrend->_nModes].iWidth = pddsd->dwWidth;
	pdrend->_mleModeList[pdrend->_nModes].iHeight = pddsd->dwHeight;
	pdrend->_mleModeList[pdrend->_nModes].iDepth =
            pddsd->ddpfPixelFormat.dwRGBBitCount;
	pdrend->_nModes++;
    }
    return DDENUMRET_OK;
}

/*
 * CompareModes
 * Compare two display modes for sorting purposes.
 */
int __cdecl CompareModes(const void* element1, const void* element2) {
    ModeListElement *lpMode1, *lpMode2;

    lpMode1 = (ModeListElement*)element1;
    lpMode2 = (ModeListElement*)element2;

    // XXX
    if (lpMode1->iWidth < lpMode2->iWidth)
        return -1;
    else if (lpMode2->iWidth < lpMode1->iWidth)
        return 1;
    else if (lpMode1->iHeight < lpMode2->iHeight)
        return -1;
    else if (lpMode2->iHeight < lpMode1->iHeight)
        return 1;
    else
        return 0;
}

BOOL
D3dRenderer::EnumerateDisplayModes(void)
{
    hrLast = _pdd->EnumDisplayModes(0, NULL, this, EnumDisplayModesCallback);
    if(hrLast != DD_OK ) {
        Msg("EnumDisplayModes failed.\n%s", D3dErrorString(hrLast));
        return FALSE;
    }
    qsort((void *)&_mleModeList[0], (size_t) _nModes,
          sizeof(ModeListElement), CompareModes);
    if (_nModes == 0) {
	Msg("The available display modes are not of sufficient "
            "size or are not 16-bit\n");
	return FALSE;
    }
    _iCurrentMode = 0;
    return TRUE;
}

/*
 * GetDDCaps
 * Determines Z buffer depth.
 */
BOOL
D3dRenderer::GetDDCaps(void)
{
    DDCAPS DriverCaps, HELCaps;

    memset(&DriverCaps, 0, sizeof(DriverCaps));
    DriverCaps.dwSize = sizeof(DDCAPS);
    memset(&HELCaps, 0, sizeof(HELCaps));
    HELCaps.dwSize = sizeof(DDCAPS);
    hrLast = _pdd->GetCaps(&DriverCaps, &HELCaps);
    if (hrLast != DD_OK) {
        Msg("GetCaps failed in while checking driver capabilities.\n%s",
            D3dErrorString(hrLast));
        return FALSE;
    }
    memcpy(&_ddscapsHw, &DriverCaps.ddsCaps, sizeof(DDSCAPS));
    return TRUE;
}

/*
 * BPPToDDBD
 * Convert an integer bit per pixel number to a DirectDraw bit depth flag
 */
DWORD
BPPToDDBD(int bpp)
{
    switch(bpp) {
	case 1:
	    return DDBD_1;
	case 2:
	    return DDBD_2;
	case 4:
	    return DDBD_4;
	case 8:
	    return DDBD_8;
	case 16:
	    return DDBD_16;
	case 24:
	    return DDBD_24;
	case 32:
	    return DDBD_32;
	default:
	    return (DWORD)0;
    }
}

BOOL D3dRenderer::SelectDisplayDriver(RendId rid)
{
    if (_iDD >= 0)
    {
        RELEASE(_pd3d);
        RELEASE(_pdd);
    }

    _iDD = (int)rid;
    
    if (_ddiDriver[_iDD].bIsPrimary) {
        _bCurrentFullscreenMode = FALSE;
	hrLast = DirectDrawCreate(NULL, &_pdd, NULL);
	if (hrLast != DD_OK) {
	    Msg("DirectDrawCreate failed.\n%s", D3dErrorString(hrLast));
	    return FALSE;
	}
    } else {
	/*
	 * If it's not the primary device, assume we can only do fullscreen.
	 */
        _bCurrentFullscreenMode = TRUE;
	hrLast = DirectDrawCreate(&_ddiDriver[_iDD].guid, &_pdd, NULL);
	if (hrLast != DD_OK) {
	    Msg("DirectDrawCreate failed.\n%s", D3dErrorString(hrLast));
	    return FALSE;
	}
        if (!EnumerateDisplayModes())
            return FALSE;
    }
    hrLast = _pdd->SetCooperativeLevel(app.hDlg, DDSCL_NORMAL);
    if(hrLast != DD_OK ) {
	Msg("SetCooperativeLevel failed.\n%s", D3dErrorString(hrLast));
	return FALSE;
    }
    hrLast = _pdd->QueryInterface(IID_IDirect3D, (LPVOID*)&_pd3d);
    if (hrLast != DD_OK) {
        Msg("Creation of IDirect3D failed.\n%s", D3dErrorString(hrLast));
        return FALSE;
    }
    GetDDCaps();
    
    if (_ddiDriver[_iDD].bIsPrimary) {
        DDSURFACEDESC ddsd;
        
	memset(&ddsd, 0, sizeof(DDSURFACEDESC));
	ddsd.dwSize = sizeof(DDSURFACEDESC);
	hrLast = _pdd->GetDisplayMode(&ddsd);
	if (hrLast != DD_OK)
        {
	    Msg("Getting the current display mode failed.\n%s",
                D3dErrorString(hrLast));
	    return FALSE;
	}
	_dwWinBpp = BPPToDDBD(ddsd.ddpfPixelFormat.dwRGBBitCount);
    } // else _dwWinBpp is not used
    
    _nD3dDrivers = 0;
    hrLast = _pd3d->EnumDevices(EnumDeviceFunc, this);
    if (hrLast != DD_OK) {
        Msg("EnumDevices failed.\n%s", D3dErrorString(hrLast));
        return FALSE;
    }
    return TRUE;
}

BOOL D3dRenderer::SelectGraphicsDriver(RendId rid)
{
    _iD3D = (int)rid;
    if (_d3diDriver[_iD3D].d3ddHw.dcmColorModel)
    {
        _dwZDepth = _d3diDriver[_iD3D].d3ddHw.dwDeviceZBufferBitDepth;
        _dwZType = DDSCAPS_VIDEOMEMORY;
    }
    else
    {
        _dwZDepth = _d3diDriver[_iD3D].d3ddHel.dwDeviceZBufferBitDepth;
        _dwZType = DDSCAPS_SYSTEMMEMORY;
    }
    if (_dwZDepth & DDBD_32)
    {
	_dwZDepth = 32;
    }
    else if (_dwZDepth & DDBD_24)
    {
	_dwZDepth = 24;
    }
    else if (_dwZDepth & DDBD_16)
    {
	_dwZDepth = 16;
    }
    else if (_dwZDepth & DDBD_8)
    {
	_dwZDepth = 8;
    }
    else
    {
        _dwZDepth = 0;
    }
    return TRUE;
}

BOOL D3dRenderer::DescribeDisplay(RendDisplayDescription* prdd)
{
    DDSURFACEDESC ddsd;
    
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    hrLast = _pdd->GetDisplayMode(&ddsd);
    if (hrLast != DD_OK)
    {
        return FALSE;
    }

    prdd->bPrimary = _ddiDriver[_iDD].bIsPrimary;
    prdd->nColorBits = ddsd.ddpfPixelFormat.dwRGBBitCount;
    if (prdd->bPrimary)
    {
        prdd->uiWidth = ddsd.dwWidth;
        prdd->uiHeight = ddsd.dwHeight;
    }
    else
    {
        prdd->uiWidth = _mleModeList[_iCurrentMode].iWidth;
        prdd->uiHeight = _mleModeList[_iCurrentMode].iHeight;
    }
    
    return TRUE;
}
    
BOOL D3dRenderer::DescribeGraphics(RendGraphicsDescription* prgd)
{
    D3DDEVICEDESC *pd3dd;
    
    if (_d3diDriver[_iD3D].d3ddHw.dcmColorModel)
    {
        prgd->bHardwareAssisted = TRUE;
        pd3dd = &_d3diDriver[_iD3D].d3ddHw;
    }
    else
    {
        prgd->bHardwareAssisted = FALSE;
        pd3dd = &_d3diDriver[_iD3D].d3ddHel;
    }
    prgd->uiColorTypes =
        ((pd3dd->dpcTriCaps.dwShadeCaps &
          D3DPSHADECAPS_COLORGOURAUDMONO) ? REND_COLOR_MONO : 0) |
        ((pd3dd->dpcTriCaps.dwShadeCaps &
          D3DPSHADECAPS_COLORGOURAUDRGB) ? REND_COLOR_RGBA : 0);
    prgd->nZBits = _dwZDepth;
    prgd->uiExeBufFlags =
        ((pd3dd->dwDevCaps & D3DDEVCAPS_EXECUTESYSTEMMEMORY) ?
         REND_BUFFER_SYSTEM_MEMORY : 0) |
        ((pd3dd->dwDevCaps & D3DDEVCAPS_EXECUTEVIDEOMEMORY) ?
         REND_BUFFER_VIDEO_MEMORY : 0);
    prgd->bPerspectiveCorrect = (pd3dd->dpcTriCaps.dwTextureCaps &
                                 D3DPTEXTURECAPS_PERSPECTIVE) != 0;
    prgd->bSpecularLighting = (pd3dd->dpcTriCaps.dwShadeCaps &
                               (D3DPSHADECAPS_SPECULARGOURAUDMONO |
                                D3DPSHADECAPS_SPECULARGOURAUDRGB)) != 0;
    prgd->bCopyTextureBlend = (pd3dd->dpcTriCaps.dwTextureBlendCaps &
                               D3DPTBLENDCAPS_COPY) != 0;

    return TRUE;
}

BOOL D3dRenderer::FlipToDesktop(void)
{
    return _pdd->FlipToGDISurface() == DD_OK;
}

BOOL D3dRenderer::RestoreDesktop(void)
{
#if 0
    // ATTENTION - Window has been destroyed at this point
    // Is this really necessary?
    _pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL);
#endif
    return _pdd->RestoreDisplayMode() == DD_OK;
}

RendWindow* D3dRenderer::NewWindow(int x, int y, UINT uiWidth, UINT uiHeight,
                                   UINT uiBuffers)
{
    D3dWindow *pdwinRend;
    
    pdwinRend = new D3dWindow;
    if (pdwinRend == NULL)
    {
        return NULL;
    }

    if (!pdwinRend->Initialize(this, _pdd, _pd3d, _d3diDriver[_iD3D].pguid,
                               x, y, uiWidth, uiHeight, uiBuffers))
    {
        delete pdwinRend;
        return NULL;
    }

    return pdwinRend;
}

static D3dRenderer d3drend;

Renderer* GetD3dRenderer(void)
{
    return &d3drend;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\d3dlight.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "d3drend.h"
#include "util.h"

D3dLight::D3dLight(void)
{
    _pdl = NULL;
}

BOOL D3dLight::Initialize(LPDIRECT3D pd3d, LPDIRECT3DVIEWPORT pdvw, int iType)
{
    hrLast = pd3d->CreateLight(&_pdl, NULL);
    if (hrLast != D3D_OK)
    {
        return FALSE;
    }
    hrLast = pdvw->AddLight(_pdl);
    if (hrLast != D3D_OK)
    {
        return FALSE;
    }
    
    memset(&_dl, 0, sizeof(_dl));
    _dl.dwSize = sizeof(_dl);
    switch(iType)
    {
    case REND_LIGHT_DIRECTIONAL:
        _dl.dltType = D3DLIGHT_DIRECTIONAL;
        _dl.dvDirection.x = D3DVAL(0);
        _dl.dvDirection.y = D3DVAL(0);
        _dl.dvDirection.z = D3DVAL(1);
        break;
    case REND_LIGHT_POINT:
        _dl.dltType = D3DLIGHT_POINT;
        _dl.dvPosition.x = D3DVAL(0);
        _dl.dvPosition.y = D3DVAL(0);
        _dl.dvPosition.z = D3DVAL(1);
        break;
    }
    _dl.dcvColor.r = D3DVAL(1);
    _dl.dcvColor.g = D3DVAL(1);
    _dl.dcvColor.b = D3DVAL(1);
    _dl.dcvColor.a = D3DVAL(1);
    _dl.dvAttenuation0 = D3DVAL(1);
    return _pdl->SetLight(&_dl) == D3D_OK;
}

D3dLight::~D3dLight(void)
{
    RELEASE(_pdl);
}

void D3dLight::Release(void)
{
    delete this;
}

void D3dLight::SetColor(D3DCOLORVALUE *pdcol)
{
    _dl.dcvColor = *pdcol;
    hrLast = _pdl->SetLight(&_dl);
}

void D3dLight::SetVector(D3DVECTOR *pdvec)
{
    switch(_dl.dltType)
    {
    case D3DLIGHT_DIRECTIONAL:        
        _dl.dvDirection = *pdvec;
        break;
    case D3DLIGHT_POINT:
        _dl.dvPosition = *pdvec;
        break;
    }
    hrLast = _pdl->SetLight(&_dl);
}

void D3dLight::SetAttenuation(float fConstant, float fLinear,
                              float fQuadratic)
{
    _dl.dvAttenuation0 = D3DVAL(fConstant);
    _dl.dvAttenuation1 = D3DVAL(fLinear);
    _dl.dvAttenuation2 = D3DVAL(fQuadratic);
    hrLast = _pdl->SetLight(&_dl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\d3drend.h ===
#ifndef __D3DREND_H__
#define __D3DREND_H__

#include "rend.h"

class D3dRenderer;

class D3dExecuteBuffer : public RendExecuteBuffer
{
public:
    D3dExecuteBuffer(void);
    BOOL Initialize(LPDIRECT3DDEVICE pd3dev, UINT cbSize, UINT uiFlags);
    ~D3dExecuteBuffer(void);

    virtual void  Release(void);
    
    virtual void* Lock(void);
    virtual void  Unlock(void);
    
    virtual void  SetData(UINT nVertices, UINT cbStart, UINT cbSize);

    virtual BOOL  Process(void);

    LPDIRECT3DEXECUTEBUFFER _pdeb;
};

class D3dLight : public RendLight
{
public:
    D3dLight(void);
    BOOL Initialize(LPDIRECT3D pd3d, LPDIRECT3DVIEWPORT pdvw, int iType);
    ~D3dLight(void);
    
    virtual void Release(void);

    virtual void SetColor(D3DCOLORVALUE *pdcol);
    virtual void SetVector(D3DVECTOR *pdvec);
    virtual void SetAttenuation(float fConstant, float fLinear,
                                float fQuadratic);

    LPDIRECT3DLIGHT _pdl;
    D3DLIGHT _dl;
};

class D3dTexture : public RendTexture
{
public:
    D3dTexture(void);
    BOOL Initialize(D3dRenderer *pdrend,
                    LPDIRECTDRAW pdd, LPDIRECT3DDEVICE pd3dev,
                    DDSURFACEDESC *pddsd, char* pszFile, UINT uiFlags,
                    D3dTexture *pdtexNext);
    ~D3dTexture(void);
    
    virtual void Release(void);
    
    virtual D3DTEXTUREHANDLE Handle(void);

    BOOL CreateVidTex(LPDIRECTDRAW pdd, UINT uiFlags);
    BOOL RestoreSurface(void);

    D3dRenderer *_pdrend;
    LPDIRECTDRAWSURFACE _pddsSrc;
    LPDIRECT3DTEXTURE _pdtexSrc;
    D3DTEXTUREHANDLE _dthDst;
    LPDIRECTDRAWSURFACE _pddsDst;
    LPDIRECT3DTEXTURE _pdtexDst;
    D3dTexture* _pdtexNext;
};

class D3dMatrix : public RendMatrix
{
public:
    D3dMatrix(void);
    BOOL Initialize(LPDIRECT3DDEVICE pd3dev);
    ~D3dMatrix(void);

    virtual void Release(void);
    
    virtual D3DMATRIXHANDLE Handle(void);

    virtual void Get(D3DMATRIX *pdm);
    virtual void Set(D3DMATRIX *pdm);

    LPDIRECT3DDEVICE _pd3dev;
    D3DMATRIXHANDLE _dmh;
};

class D3dMaterial : public RendMaterial
{
public:
    D3dMaterial(void);
    BOOL Initialize(LPDIRECT3D pd3d, LPDIRECT3DDEVICE pd3dev,
                    UINT nColorEntries);
    ~D3dMaterial(void);
    
    virtual void Release(void);

    virtual D3DMATERIALHANDLE Handle(void);

    virtual void SetDiffuse(D3DCOLORVALUE* pdcol);
    virtual void SetSpecular(D3DCOLORVALUE* pdcol, float fPower);
    virtual void SetTexture(RendTexture *prtex);

    LPDIRECT3DDEVICE _pd3dev;
    LPDIRECT3DMATERIAL _pdmat;
    D3DMATERIAL _dmat;
};

class D3dWindow : public RendWindow
{
public:
    D3dWindow(void);
    BOOL Initialize(D3dRenderer *pdrend,
                    LPDIRECTDRAW pdd, LPDIRECT3D pd3d, LPGUID pguid,
                    int x, int y, UINT uiWidth, UINT uiHeight, UINT uiBuffers);
    ~D3dWindow(void);
    
    virtual void Release(void);
    
    virtual BOOL SetViewport(int x, int y, UINT uiWidth, UINT uiHeight);

    virtual RendLight*         NewLight(int iType);
    virtual RendTexture*       NewTexture(char *pszFile, UINT uiFlags);
    virtual RendExecuteBuffer* NewExecuteBuffer(UINT uiSize, UINT uiFlags);
    virtual RendMatrix*        NewMatrix(void);
    virtual RendMaterial*      NewMaterial(UINT nColorEntries);
    
    virtual BOOL BeginScene(void);
    virtual BOOL Execute(RendExecuteBuffer* preb);
    virtual BOOL ExecuteClipped(RendExecuteBuffer* preb);
    virtual BOOL EndScene(D3DRECT* pdrcBound);

    virtual BOOL Clear(UINT uiBuffers, D3DRECT* pdrc);
    virtual BOOL Flip(void);
    virtual BOOL CopyForward(D3DRECT* pdrc);

    virtual HWND Handle(void);
    
    LRESULT WindowProc(HWND hwnd, UINT uiMessage, WPARAM wpm, LPARAM lpm);
    BOOL CreateZBuffer(UINT uiWidth, UINT uiHeight, DWORD dwDepth,
                       DWORD dwMemoryType);
    HWND CreateHWND(int x, int y, UINT uiWidth, UINT uiHeight);
    BOOL InitDD(UINT uiWidth, UINT uiHeight, UINT uiBuffers);
    BOOL InitializeTextureLoad(void);
    BOOL InitD3D(LPGUID pguid, UINT uiWidth, UINT uiHeight, UINT uiBuffers);
    BOOL RestoreSurfaces(void);

    D3dRenderer *_pdrend;
    HWND _hwnd;
    LPDIRECTDRAW _pdd;
    LPDIRECT3D _pd3d;
    LPDIRECT3DDEVICE _pd3dev;
    LPDIRECT3DVIEWPORT _pdvw;
    LPDIRECT3DEXECUTEBUFFER _pdebLast;
    LPDIRECT3DMATERIAL _pdmatBackground;
    LPDIRECTDRAWSURFACE _pddsFrontBuffer;
    LPDIRECTDRAWSURFACE _pddsBackBuffer;
    LPDIRECTDRAWSURFACE _pddsZBuffer;
    LPDIRECTDRAWCLIPPER _pddcClipper;
    LPDIRECTDRAWPALETTE _pddpPalette;
    RECT _rcClient;
    D3dTexture* _pdtex;
    int _nTextureFormats;
    // Only use one currently
    DDSURFACEDESC _ddsdTextureFormat[1];
    BOOL _bHandleActivate;
    BOOL _bPrimaryPalettized;
    BOOL _bIgnoreWM_SIZE;
};

#define DD_DRIVER_COUNT         5
#define DD_MODE_LIST_COUNT      20
#define D3D_DRIVER_COUNT        5

struct DdDriverInfo
{
    GUID   guid;
    DDCAPS ddcapsHw;
    char   achName[40];
    BOOL   bIsPrimary;
};

struct ModeListElement
{
    int iWidth, iHeight, iDepth;  
};

struct D3dDriverInfo
{
    char achDesc[50];
    char achName[30];
    D3DDEVICEDESC d3ddHw, d3ddHel;
    LPGUID pguid;
};

class D3dRenderer : public Renderer
{
public:
    D3dRenderer(void);
    
    virtual void Name(char* psz);
    
    virtual char* LastErrorString(void);
    
    virtual BOOL Initialize(HWND hwndParent);
    virtual void Uninitialize(void);
    
    virtual BOOL EnumDisplayDrivers(RendEnumDriversFn pfn,
                                    void* pvArg);
    virtual BOOL EnumGraphicsDrivers(RendEnumDriversFn pfn,
                                     void* pvArg);
    
    virtual BOOL SelectDisplayDriver(RendId rid);
    virtual BOOL SelectGraphicsDriver(RendId rid);
    
    virtual BOOL DescribeDisplay(RendDisplayDescription* prdd);
    virtual BOOL DescribeGraphics(RendGraphicsDescription* prgd);
    
    virtual BOOL FlipToDesktop(void);
    virtual BOOL RestoreDesktop(void);
    
    virtual RendWindow* NewWindow(int x, int y,
                                  UINT uiWidth, UINT uiHeight,
                                  UINT uiBuffers);

    BOOL GetDDCaps(void);
    BOOL EnumerateDisplayModes(void);
    
    int _iDD;
    int _iD3D;
    LPDIRECTDRAW _pdd;
    LPDIRECT3D _pd3d;
    DDSCAPS _ddscapsHw;
    DdDriverInfo _ddiDriver[DD_DRIVER_COUNT];
    int _nDdDrivers;
    ModeListElement _mleModeList[DD_MODE_LIST_COUNT];
    int	_nModes;
    int	_iCurrentMode;
    BOOL _bCurrentFullscreenMode;
    UINT _nD3dDrivers;
    D3dDriverInfo _d3diDriver[D3D_DRIVER_COUNT];
    DWORD _dwZDepth;
    DWORD _dwZType;
    DWORD _dwWinBpp;
};

// ATTENTION - Technically this should be on the renderer but that's a huge
// pain
extern HRESULT hrLast;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\d3dwin.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "d3drend.h"
#include "util.h"
#include "globals.h"

//#define NOTOPMOST_WINDOW

D3dWindow::D3dWindow(void)
{
    _pdmatBackground = NULL;
    _pdvw = NULL;
    _pd3dev = NULL;
    _pddpPalette = NULL;
    _pddcClipper = NULL;
    _pddsBackBuffer = NULL;
    _pddsFrontBuffer = NULL;
    _pddsZBuffer = NULL;
    _hwnd = NULL;
    _pdebLast = NULL;
    _pdtex = NULL;
    _nTextureFormats = 0;
}

LRESULT D3dWindow::WindowProc(HWND hwnd, UINT uiMessage,
                              WPARAM wpm, LPARAM lpm)
{
    switch( uiMessage )
    {
    case WM_DESTROY:
        _hwnd = NULL;
        break;
    case WM_MOVE:
#if 0
        // ATTENTION - How would we get a move in fullscreen mode?
        if (app.bFullscreen)
            break;
#endif
        _rcClient.right += LOWORD(lpm)-_rcClient.left;
        _rcClient.bottom += HIWORD(lpm)-_rcClient.top;
        _rcClient.left = LOWORD(lpm);
        _rcClient.top = HIWORD(lpm);
        break;
    case WM_SIZE:
        if (_bIgnoreWM_SIZE)
        {
            break;
        }
        // Currently ignored since the test render size
        // stays constant so increasing the flip area
        // wouldn't buy anything
        break;
    case WM_ACTIVATE:
        if (_bHandleActivate && _bPrimaryPalettized)
        {
            hrLast = _pddsFrontBuffer->SetPalette(_pddpPalette);
        }
        break;
    default:
        return DefWindowProc(hwnd, uiMessage, wpm, lpm);
    }
    return 0;
}

/*
 * WindowProc
 * Window message handler.
 */
long
FAR PASCAL WindowProc(HWND hWnd, UINT message, WPARAM wParam,
                      LPARAM lParam )
{
    D3dWindow *pdwin = (D3dWindow *)GetWindowLong(hWnd, GWL_USERDATA);

    if (pdwin != NULL)
    {
        return pdwin->WindowProc(hWnd, message, wParam, lParam);
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

HWND
D3dWindow::CreateHWND(int x, int y, UINT uiWidth, UINT uiHeight)
{
    static BOOL bFirst = TRUE;
    RECT rc;
    DWORD dwStyle;

    if (bFirst)
    {
        WNDCLASS wc;
        bFirst = FALSE;
        /*
         * set up and register window class
         */
        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = ::WindowProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = app.hInstApp;
        wc.hIcon = 0;
        wc.hCursor = LoadCursor( NULL, IDC_ARROW );
        wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = "Direct3D Test";
        if (!RegisterClass(&wc))
            return NULL;
    }
    /*
     * create a window
     */
    _bIgnoreWM_SIZE = TRUE;
    _hwnd = CreateWindow(
	 "Direct3D Test",
	 "Direct3D Test",
         0,
         x,y,uiWidth,uiHeight,
         app.hDlg,       /* parent window */
	 NULL,		 /* menu handle */
	 app.hInstApp,	 /* program handle */
	 NULL);		 /* create parms */	
    if (!_hwnd){
    	Msg("CreateWindow failed");
    	return _hwnd;
    }
    UpdateWindow(_hwnd);
    /*
     * Convert to a normal app window if we are still a WS_POPUP window.
     */
    dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    dwStyle &= ~WS_POPUP;
    dwStyle |= WS_OVERLAPPED | WS_CAPTION | WS_THICKFRAME;
    SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
    SetRect(&rc, 0, 0, uiWidth, uiHeight);
    AdjustWindowRectEx(&rc, GetWindowLong(_hwnd, GWL_STYLE),
        	       GetMenu(_hwnd) != NULL,
        	       GetWindowLong(_hwnd, GWL_EXSTYLE));
    SetWindowPos(_hwnd, NULL, x, y, rc.right-rc.left,
        	 rc.bottom-rc.top,
        	 SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
#ifndef NOTOPMOST_WINDOW
    SetWindowPos(_hwnd, HWND_TOPMOST, 0, 0, 0, 0,
                 SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);
#else
    SetWindowPos(_hwnd, HWND_NOTOPMOST, 0, 0, 0, 0,
                 SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);
#endif
    _bIgnoreWM_SIZE = FALSE;
    SetWindowLong(_hwnd, GWL_USERDATA, (LONG)this);
    return _hwnd;
}

/*
 * InitDD
 * Given an HWND, creates DD surfaces
 */
BOOL
D3dWindow::InitDD(UINT uiWidth, UINT uiHeight, UINT uiBuffers)
{
    DDSURFACEDESC ddsd;
    BOOL bOnlySoftRender;
    PALETTEENTRY ppe[256];
    
    if (_pdrend->_bCurrentFullscreenMode) {
	DDSCAPS ddscaps;
        /*
         * Create a complex flipping surface for fullscreen mode.
         */
        _bIgnoreWM_SIZE = TRUE;
        hrLast = _pdd->SetCooperativeLevel(_hwnd, DDSCL_EXCLUSIVE |
                                           DDSCL_FULLSCREEN);
        _bIgnoreWM_SIZE = FALSE;
        if (hrLast != DD_OK ) {
            _pdrend->_bCurrentFullscreenMode = FALSE;
	    Msg("SetCooperativeLevel failed.\n%s", D3dErrorString(hrLast));
            return FALSE;
        }
        _bIgnoreWM_SIZE = TRUE;
        hrLast = _pdd->SetDisplayMode(
                _pdrend->_mleModeList[_pdrend->_iCurrentMode].iWidth,
                _pdrend->_mleModeList[_pdrend->_iCurrentMode].iHeight,
                _pdrend->_mleModeList[_pdrend->_iCurrentMode].iDepth);
        _bIgnoreWM_SIZE = FALSE;
        if(hrLast != DD_OK ) {
            _pdrend->_bCurrentFullscreenMode = FALSE;
            Msg("SetDisplayMode (%dx%dx%d) failed\n%s",
                _pdrend->_mleModeList[_pdrend->_iCurrentMode].iWidth,
                _pdrend->_mleModeList[_pdrend->_iCurrentMode].iHeight,
                _pdrend->_mleModeList[_pdrend->_iCurrentMode].iDepth,
                D3dErrorString(hrLast));
            return FALSE;
        }
        memset(&ddsd,0,sizeof(DDSURFACEDESC));
	ddsd.dwSize = sizeof( ddsd );
    	ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
    	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP |
    	    DDSCAPS_COMPLEX | DDSCAPS_3DDEVICE;
    	ddsd.dwBackBufferCount = 1;
        hrLast = _pdd->CreateSurface(&ddsd, &_pddsFrontBuffer, NULL);
    	if(hrLast != DD_OK) {
            Msg("CreateSurface for front/back fullscreen buffer failed.\n%s",
                D3dErrorString(hrLast));
            return FALSE;
	}
    	ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
    	hrLast = _pddsFrontBuffer->GetAttachedSurface(&ddscaps,
                                                         &_pddsBackBuffer);
    	if(hrLast != DD_OK) {
            Msg("GetAttachedSurface failed to get back buffer.\n%s",
                D3dErrorString(hrLast));
    	    return FALSE;
	}
        if (!GetDDSurfaceDesc(&ddsd, _pddsBackBuffer))
	    return FALSE;
        if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
	    Msg("Backbuffer failed to go into video memory for "
                "fullscreen test.\n");
	    return FALSE;
	}
    } else {
	memset(&ddsd,0,sizeof(DDSURFACEDESC));
	ddsd.dwSize = sizeof(DDSURFACEDESC);
	ddsd.dwFlags = DDSD_CAPS;
	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
	hrLast = _pdd->CreateSurface(&ddsd, &_pddsFrontBuffer, NULL);
	if(hrLast != DD_OK ) {
	    Msg("CreateSurface for window front buffer failed.\n%s",
                D3dErrorString(hrLast));
	    return FALSE;
	}
	ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS;
	ddsd.dwHeight = uiHeight;
	ddsd.dwWidth = uiWidth;
	ddsd.ddsCaps.dwCaps= DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE;
	if (uiBuffers & REND_BUFFER_SYSTEM_MEMORY)
	    ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
	hrLast = _pdd->CreateSurface(&ddsd, &_pddsBackBuffer, NULL);
	if (hrLast != DD_OK) {
	    Msg("CreateSurface for window back buffer failed.\n%s",
                D3dErrorString(hrLast));
	    return FALSE;
	}
	if (!GetDDSurfaceDesc(&ddsd, _pddsBackBuffer))
	    return FALSE;
        bOnlySoftRender = FALSE;
	if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
	    bOnlySoftRender = TRUE;
	if (stat.rgd.bHardwareAssisted && bOnlySoftRender) {
	    Msg("There was not enough free video memory for the front and/or "
                "back buffers for this hardware D3D device.\n");
	    return FALSE;
	}
	/*
	 * Create a DirectDrawClipper object.
	 */
	hrLast = _pdd->CreateClipper(0, &_pddcClipper, NULL);
	if(hrLast != DD_OK ) {
	    Msg("CreateClipper failed.\n%s", D3dErrorString(hrLast));
	    return FALSE;
	}
	hrLast = _pddcClipper->SetHWnd(0, _hwnd);
	if(hrLast != DD_OK ) {
	    Msg("Clipper SetHWnd failed.\n%s", D3dErrorString(hrLast));
	    return FALSE;
	}
	hrLast = _pddsFrontBuffer->SetClipper(_pddcClipper);
	if(hrLast != DD_OK ) {
	    Msg("SetClipper failed.\n%s", D3dErrorString(hrLast));
	    return FALSE;
	}
    }
    /*
     * Palettize if we are not in a 16-bit mode.
     */
    if (!GetDDSurfaceDesc(&ddsd, _pddsBackBuffer))
	return FALSE;
    if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16) {
	_bPrimaryPalettized = TRUE;
    } else {
	_bPrimaryPalettized = FALSE;
    }
    if (_bPrimaryPalettized) {
	int i;
    	HDC hdc = GetDC(NULL);
	GetSystemPaletteEntries(hdc, 0, (1 << 8), ppe);
	ReleaseDC(NULL, hdc);
        for (i = 0; i < 10; i++) ppe[i].peFlags = D3DPAL_READONLY;
	for (i = 10; i < 256 - 10; i++) ppe[i].peFlags = PC_RESERVED;
        for (i = 256 - 10; i < 256; i++) ppe[i].peFlags = D3DPAL_READONLY;
	hrLast = _pdd->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE,
                                     ppe, &_pddpPalette, NULL);
	if (hrLast != DD_OK) {
	    Msg("CreatePalette failed.\n%s", D3dErrorString(hrLast));
            return FALSE;
	}
	hrLast = _pddsBackBuffer->SetPalette(_pddpPalette);
        if(hrLast != DD_OK ) {
            Msg("SetPalette back failed.\n%s", D3dErrorString(hrLast));
            return FALSE;
	}
	hrLast = _pddsFrontBuffer->SetPalette(_pddpPalette);
        if(hrLast != DD_OK ) {
            Msg("SetPalette failed.\n%s", D3dErrorString(hrLast));
            return FALSE;
	}
	_bHandleActivate = TRUE;
    }
    return TRUE;
}

BOOL
D3dWindow::CreateZBuffer(UINT uiWidth, UINT uiHeight, DWORD dwDepth,
                         DWORD dwMemoryType)
{
    LPDIRECTDRAWSURFACE lpZBuffer;
    DDSURFACEDESC ddsd;
    BOOL bOnlySoftRender;

    /*
     * Create a Z-Buffer and attach it to the back buffer.
     */
    if (_pdrend->_bCurrentFullscreenMode) {
	uiWidth = _pdrend->_mleModeList[_pdrend->_iCurrentMode].iWidth;
	uiHeight = _pdrend->_mleModeList[_pdrend->_iCurrentMode].iHeight;
    }
    memset(&ddsd,0,sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_ZBUFFERBITDEPTH;
    ddsd.dwHeight = uiHeight;
    ddsd.dwWidth = uiWidth;
    ddsd.dwZBufferBitDepth = dwDepth;
    ddsd.ddsCaps.dwCaps= DDSCAPS_ZBUFFER | dwMemoryType;
    hrLast = _pdd->CreateSurface(&ddsd, &lpZBuffer, NULL);
    if (hrLast != DD_OK) {
        Msg("CreateSurface for window Z-buffer failed.\n%s",
            D3dErrorString(hrLast));
        return FALSE;
    }
    if (!GetDDSurfaceDesc(&ddsd, lpZBuffer))
	return FALSE;
    bOnlySoftRender = FALSE;
    if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
        bOnlySoftRender = TRUE;
    if (stat.rgd.bHardwareAssisted && bOnlySoftRender) {
        lpZBuffer->Release();
        Msg("Did not have enough free video memory for Z-buffer "
            "for this hardware D3D device.\n");
        return FALSE;
    }
    hrLast = _pddsBackBuffer->AddAttachedSurface(lpZBuffer);
    if(hrLast != DD_OK) {
        Msg("AddAttachedBuffer failed for Z-buffer.\n%s",
            D3dErrorString(hrLast));
        return FALSE;
    }
    _pddsZBuffer = lpZBuffer;
    return TRUE;
}

HRESULT CALLBACK EnumTextureFormatsCallback(LPDDSURFACEDESC pddsd, LPVOID pv)
{
    D3dWindow *pdwin = (D3dWindow *)pv;
    
    if (pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4)
    {
	return DDENUMRET_OK;
    }

    memcpy(&pdwin->_ddsdTextureFormat[pdwin->_nTextureFormats], pddsd,
           sizeof(DDSURFACEDESC));
    pdwin->_nTextureFormats++;
    // We only care about one format right now
    return DDENUMRET_CANCEL;
}

BOOL
D3dWindow::InitializeTextureLoad(void)
{
    _nTextureFormats = 0;
    hrLast = _pd3dev->EnumTextureFormats(EnumTextureFormatsCallback, this);
    return hrLast == D3D_OK;
}

/*
 * InitD3D
 * Initializes the D3D device and creates the viewport.
 */
BOOL
D3dWindow::InitD3D(LPGUID pguid, UINT uiWidth, UINT uiHeight, UINT uiBuffers)
{
    if (uiBuffers & REND_BUFFER_Z) {
        if (!CreateZBuffer(uiWidth, uiHeight, _pdrend->_dwZDepth,
                           _pdrend->_dwZType))
            return FALSE;
    }
    /*
     * Create the device
     */
    hrLast = _pddsBackBuffer->QueryInterface(*pguid, (LPVOID*)&_pd3dev);
    if (hrLast != DD_OK) {
    	Msg("Create D3D device failed.\n%s", D3dErrorString(hrLast));
        return FALSE;
    }
    if (!stat.bTexturesDisabled && !InitializeTextureLoad())
        return FALSE;
    /*
     * Create and setup the viewport which is scaled to the screen mode
     */
    hrLast = _pd3d->CreateViewport(&_pdvw, NULL);
    if (hrLast != D3D_OK) {
    	Msg("Create D3D viewport failed.\n%s", D3dErrorString(hrLast));
        return FALSE;
    }
    hrLast = _pd3dev->AddViewport(_pdvw);
    if (hrLast != D3D_OK) {
    	Msg("Add D3D viewport failed.\n%s", D3dErrorString(hrLast));
        return FALSE;
    }

    return TRUE;
}

BOOL D3dWindow::Initialize(D3dRenderer *pdrend,
                           LPDIRECTDRAW pdd, LPDIRECT3D pd3d, LPGUID pguid,
                           int x, int y, UINT uiWidth, UINT uiHeight,
                           UINT uiBuffers)
{
    D3DMATERIAL dmat;
    D3DMATERIALHANDLE hdmat;

    _pdrend = pdrend;
    _pdd = pdd;
    _pd3d = pd3d;
    
    if (CreateHWND(x, y, uiWidth, uiHeight) == NULL)
    {
        return FALSE;
    }
    
    /* 
     * Initialize fullscreen DD and the D3DDevice
     */
    if (!InitDD(uiWidth, uiHeight, uiBuffers))
    {
        return FALSE;
    }
    
    if (!InitD3D(pguid, uiWidth, uiHeight, uiBuffers))
    {
        return FALSE;
    }

    if (pd3d->CreateMaterial(&_pdmatBackground, NULL) != D3D_OK)
    {
        return NULL;
    }

    /*
     * Set background to black material
     */
    memset(&dmat, 0, sizeof(D3DMATERIAL));
    dmat.dwSize = sizeof(D3DMATERIAL);
    dmat.dwRampSize = 1;
    _pdmatBackground->SetMaterial(&dmat);
    _pdmatBackground->GetHandle(_pd3dev, &hdmat);
    _pdvw->SetBackground(hdmat);

    return SetViewport(0, 0, uiWidth, uiHeight);
}

D3dWindow::~D3dWindow(void)
{
    _bHandleActivate = FALSE;
    SetWindowPos(_hwnd, HWND_NOTOPMOST, 0, 0, 0, 0,
        	 SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE| SWP_HIDEWINDOW);
    RELEASE(_pdmatBackground);
    RELEASE(_pdvw);
    RELEASE(_pd3dev);
    RELEASE(_pddpPalette);
    RELEASE(_pddcClipper);
    RELEASE(_pddsBackBuffer);
    RELEASE(_pddsFrontBuffer);
    RELEASE(_pddsZBuffer);
    if (_hwnd != NULL)
    {
        DestroyWindow(_hwnd);
    }
}

void D3dWindow::Release(void)
{
    delete this;
}

BOOL D3dWindow::SetViewport(int x, int y, UINT uiWidth, UINT uiHeight)
{
    D3DVIEWPORT viewData;
    
    memset(&viewData, 0, sizeof(D3DVIEWPORT));
    viewData.dwSize = sizeof(D3DVIEWPORT);
    viewData.dwX = x;
    viewData.dwY = y;
    viewData.dwWidth = uiWidth;
    viewData.dwHeight = uiHeight;
    viewData.dvScaleX = viewData.dwWidth / (float)2.0;
    viewData.dvScaleY = viewData.dwHeight / (float)2.0;
    viewData.dvMaxX = (float)D3DDivide(D3DVAL(viewData.dwWidth),
                                       D3DVAL(2 * viewData.dvScaleX));
    viewData.dvMaxY = (float)D3DDivide(D3DVAL(viewData.dwHeight),
                                       D3DVAL(2 * viewData.dvScaleY));
    hrLast = _pdvw->SetViewport(&viewData);
    if (hrLast != D3D_OK)
    {
    	Msg("SetViewport failed.\n%s", D3dErrorString(hrLast));
        return FALSE;
    }

    // If in fullscreen mode, assume the coordinates are in screen space
    if (_pdrend->_bCurrentFullscreenMode)
    {
        _rcClient.left = x;
        _rcClient.top = y;
    }
    else
    {
        POINT pt;

        pt.x = x;
        pt.y = y;
        ClientToScreen(_hwnd, &pt);
        _rcClient.left = pt.x;
        _rcClient.top = pt.y;
    }
    _rcClient.right = _rcClient.left+uiWidth;
    _rcClient.bottom = _rcClient.top+uiHeight;
    
    return TRUE;
}

RendLight* D3dWindow::NewLight(int iType)
{
    D3dLight *pdlRend;

    pdlRend = new D3dLight;
    if (pdlRend == NULL)
    {
        return NULL;
    }

    if (!pdlRend->Initialize(_pd3d, _pdvw, iType))
    {
        delete pdlRend;
        return NULL;
    }
    
    return pdlRend;
}


RendTexture *D3dWindow::NewTexture(char *pszFile, UINT uiFlags)
{
    D3dTexture *pdtRend;
    DDSURFACEDESC ddsd, *pddsd;

    pdtRend = new D3dTexture;
    if (pdtRend == NULL)
    {
        return NULL;
    }

    if (stat.dtbTextureBlend == D3DTBLEND_COPY)
    {
        if (!GetDDSurfaceDesc(&ddsd, _pddsFrontBuffer))
        {
            return NULL;
        }
        if (ddsd.ddpfPixelFormat.dwRGBBitCount != 8 &&
            ddsd.ddpfPixelFormat.dwRGBBitCount != 16)
        {
            Msg("Copy mode cannot be tested in this display depth.  "
                "Change display mode and try again.");
            return NULL;
        }
        ddsd.dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT;
        ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        if (stat.bOnlySystemMemory)
        {
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        }
        pddsd = &ddsd;
    }
    else
    {
        pddsd = &_ddsdTextureFormat[0];
    }
    
    if (!pdtRend->Initialize(_pdrend, _pdd, _pd3dev, pddsd, pszFile,
                             uiFlags, _pdtex))
    {
        delete pdtRend;
        return NULL;
    }
    
    return pdtRend;
}

RendExecuteBuffer *D3dWindow::NewExecuteBuffer(UINT cbSize, UINT uiFlags)
{
    D3dExecuteBuffer *pdebRend;
    
    pdebRend = new D3dExecuteBuffer;
    if (pdebRend == NULL)
    {
        return NULL;
    }

    if (!pdebRend->Initialize(_pd3dev, cbSize, uiFlags))
    {
        delete pdebRend;
        return NULL;
    }

    return pdebRend;
}

RendMatrix *D3dWindow::NewMatrix(void)
{
    D3dMatrix *pdmRend;

    pdmRend = new D3dMatrix;
    if (pdmRend == NULL)
    {
        return NULL;
    }

    if (!pdmRend->Initialize(_pd3dev))
    {
        delete pdmRend;
        return NULL;
    }
    
    return pdmRend;
}

RendMaterial* D3dWindow::NewMaterial(UINT nColorEntries)
{
    D3dMaterial *pdmatRend;

    pdmatRend = new D3dMaterial;
    if (pdmatRend == NULL)
    {
        return NULL;
    }

    if (!pdmatRend->Initialize(_pd3d, _pd3dev, nColorEntries))
    {
        delete pdmatRend;
        return NULL;
    }
    
    return pdmatRend;
}

BOOL D3dWindow::BeginScene(void)
{
    _pdebLast = NULL;
    return _pd3dev->BeginScene() == D3D_OK;
}

BOOL D3dWindow::Execute(RendExecuteBuffer* preb)
{
    _pdebLast = ((D3dExecuteBuffer *)preb)->_pdeb;
    return _pd3dev->Execute(_pdebLast, _pdvw, D3DEXECUTE_UNCLIPPED) == D3D_OK;
}

BOOL D3dWindow::ExecuteClipped(RendExecuteBuffer* preb)
{
    _pdebLast = ((D3dExecuteBuffer *)preb)->_pdeb;
    return _pd3dev->Execute(_pdebLast, _pdvw, D3DEXECUTE_CLIPPED) == D3D_OK;
}

BOOL D3dWindow::EndScene(D3DRECT* pdrcBound)
{
    if (pdrcBound != NULL)
    {
        // This whole _pdebLast scheme is an ugly hack but it makes
        // the rendering interface cleaner
        if (_pdebLast != NULL)
        {
            D3DEXECUTEDATA ded;
            
            if (_pdebLast->GetExecuteData(&ded) != D3D_OK)
            {
                return FALSE;
            }

            *pdrcBound = ded.dsStatus.drExtent;
        }
        else
        {
            memset(pdrcBound, 0, sizeof(D3DRECT));
        }
    }
    
    return _pd3dev->EndScene() == D3D_OK;
}

BOOL D3dWindow::Clear(UINT uiBuffers, D3DRECT* pdrc)
{
    DWORD ClearFlags;
    RECT src;

    if (pdrc == NULL)
    {
        pdrc = &app.drcViewport;
    }
    
    ClearFlags = D3DCLEAR_TARGET;
    if (uiBuffers & REND_BUFFER_Z)
    {
        ClearFlags |= D3DCLEAR_ZBUFFER;
    }
    hrLast = _pdvw->Clear(1, pdrc, ClearFlags);
    if (hrLast != D3D_OK)
    {
        Msg("Viewport clear failed.\n%s",
            D3dErrorString(hrLast));
        return FALSE;
    }
    
    if (uiBuffers & REND_BUFFER_FRONT)
    {
        SetRect(&src, 0, 0,
                _rcClient.right-_rcClient.left,
                _rcClient.bottom-_rcClient.top);
        hrLast = _pddsFrontBuffer->Blt(&_rcClient, _pddsBackBuffer, 
                                       &src, DDBLT_WAIT, NULL);
        if (hrLast != DD_OK)
        {
            Msg("Blt of back to front buffer failed.\n%s",
                D3dErrorString(hrLast));
            return FALSE;
        }

        // ATTENTION - Make a RendWindow call for this?
        // Front clear marks the start of a test
        // Use this opportunity to restore lost surfaces
        // It's not optimal but it works
        if (!RestoreSurfaces())
        {
            return FALSE;
        }
    }
    
    return TRUE;
}

BOOL D3dWindow::Flip(void)
{
    hrLast = _pddsFrontBuffer->Flip(_pddsBackBuffer, 1);
    if (hrLast != DD_OK) {
        Msg("Flip failed.\n%s", D3dErrorString(hrLast));
        return FALSE;
    }
    return TRUE;
}

BOOL D3dWindow::CopyForward(D3DRECT* pdrc)
{
    RECT src, dst;

    if (pdrc == NULL)
    {
        pdrc = &app.drcViewport;
    }
        
    SetRect(&src, pdrc->x1, pdrc->y1, pdrc->x2, pdrc->y2);
    SetRect(&dst,
            pdrc->x1 + _rcClient.left,
            pdrc->y1 + _rcClient.top,
            pdrc->x2 + _rcClient.left,
            pdrc->y2 + _rcClient.top);
    hrLast = _pddsFrontBuffer->Blt(&dst, _pddsBackBuffer, 
                                   &src, DDBLT_WAIT, NULL);
    if (hrLast != DD_OK) {
        Msg("Blt of back to front buffer failed.\n%s",
            D3dErrorString(hrLast));
        return FALSE;
    }
    return TRUE;
}

HWND D3dWindow::Handle(void)
{
    return _hwnd;
}

/*
 * RestoreSurfaces
 * Restores any lost surfaces.
 */
BOOL
D3dWindow::RestoreSurfaces(void)
{
    D3dTexture *pdtex;
    
    if (_pddsFrontBuffer->IsLost() == DDERR_SURFACELOST) {
        hrLast = _pddsFrontBuffer->Restore();
        if (hrLast != DD_OK) {
            Msg("Restore of front buffer failed.\n%s",
                D3dErrorString(hrLast));
            return FALSE;
        }
    }
    if (_pddsBackBuffer->IsLost() == DDERR_SURFACELOST) {
        hrLast = _pddsBackBuffer->Restore();
        if (hrLast != DD_OK) {
            Msg("Restore of back buffer failed.\n%s",
                D3dErrorString(hrLast));
            return FALSE;
        }
    }
    if (_pddsZBuffer && _pddsZBuffer->IsLost() == DDERR_SURFACELOST) {
        hrLast = _pddsZBuffer->Restore();
        if (hrLast != DD_OK) {
            Msg("Restore of Z-buffer failed.\n%s", D3dErrorString(hrLast));
            return FALSE;
        }
    }

    for (pdtex = _pdtex; pdtex != NULL; pdtex = pdtex->_pdtexNext)
    {
        if (!pdtex->RestoreSurface())
        {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\glexbuf.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "glrend.h"
#include "util.h"

GlExecuteBuffer::GlExecuteBuffer(void)
{
    _pbData = NULL;
    _dlist = 0;
}

BOOL GlExecuteBuffer::Initialize(UINT cbSize, UINT uiFlags)
{
    _pbData = new BYTE[cbSize];
    if (_pbData == NULL)
    {
        return FALSE;
    }
    
    _nVertices = 0;
    _cbStart = 0;
    _cbSize = cbSize;
    return TRUE;
}

GlExecuteBuffer::~GlExecuteBuffer(void)
{
    D3DINSTRUCTION* pdinst;
    BOOL bExit;

    if (_pbData != NULL)
    {
        pdinst = (D3DINSTRUCTION *)(_pbData+_cbStart);
        bExit = FALSE;
        // This loop will stop at the first exit so any exits
        // that are skipped by branching during execution will
        // cause problems
        // This is safer than not checking for exit, though,
        // and no branching is currently used
        while (!bExit && (BYTE *)pdinst < (_pbData+_cbStart+_cbSize))
        {
            switch(pdinst->bOpcode)
            {
            case D3DOP_EXIT:
                bExit = TRUE;
                break;
            case PROCESSED_TRIANGLE:
                delete [] *(GLuint **)(pdinst+1);
                break;
            }

            pdinst = NEXT_PDINST(pdinst);
        }
    }
    
    delete [] _pbData;

    if (_dlist != 0)
    {
        glDeleteLists(_dlist, 1);
    }
}

void GlExecuteBuffer::Release(void)
{
    delete this;
}
    
void* GlExecuteBuffer::Lock(void)
{
    // Invalidate the display list since the buffer data is changing
    if (_dlist != 0)
    {
        glDeleteLists(_dlist, 1);
        _dlist = 0;
    }
    
    return _pbData;
}

void GlExecuteBuffer::Unlock(void)
{
    // Nothing to do
}
    
void GlExecuteBuffer::SetData(UINT nVertices, UINT cbStart, UINT cbSize)
{
    _nVertices = nVertices;
    _cbStart = cbStart;
    _cbSize = cbSize;
}

BOOL GlExecuteBuffer::Process(void)
{
    D3DINSTRUCTION* pdinst;
    D3DTRIANGLE* pdtri;
    GLuint* puiIndices,* pui;
    ULONG i;
    BOOL bExit;
    
    // ATTENTION - This can easily be broken by applications which
    // make changes to their execute buffers which change or
    // move the instructions
    // If only the vertex data changes this works and that's all
    // we need right now
    pdinst = (D3DINSTRUCTION *)(_pbData+_cbStart);
    bExit = FALSE;
    // This loop will stop at the first exit so any exits
    // that are skipped by branching during execution will
    // cause problems
    // This is safer than not checking for exit, though,
    // and no branching is currently used
    while (!bExit && (BYTE *)pdinst < (_pbData+_cbStart+_cbSize))
    {
        switch(pdinst->bOpcode)
        {
        case D3DOP_TRIANGLE:
            if (pdinst->wCount < 1)
            {
                break;
            }
            
            puiIndices = new GLuint[pdinst->wCount*3L];
            if (puiIndices == NULL)
            {
                return FALSE;
            }
            
            pui = puiIndices;
            pdtri = (D3DTRIANGLE *)(pdinst+1);
            for (i = 0; i < pdinst->wCount; i++)
            {
                // Reverse the triangle vertex order to account
                // for right vs. left-handed coordinates
                *pui++ = pdtri->v1;
                *pui++ = pdtri->v3;
                *pui++ = pdtri->v2;
                pdtri++;
            }
            
            pdinst->bOpcode = PROCESSED_TRIANGLE;
            *(GLuint **)(pdinst+1) = puiIndices;
            break;

        case D3DOP_PROCESSVERTICES:
            D3DPROCESSVERTICES* pdpv;

            pdpv = (D3DPROCESSVERTICES *)(pdinst+1);
            for (i = 0; i < pdinst->wCount; i++)
            {
                if ((pdpv->dwFlags & D3DPROCESSVERTICES_OPMASK) ==
                    D3DPROCESSVERTICES_COPY &&
                    (pdpv->dwFlags & PROCESSED_TLVERTEX) == 0)
                {
                    DWORD v;

                    D3DTLVERTEX* pdtlvtx;
                    
                    pdtlvtx = (D3DTLVERTEX *)(_pbData+pdpv->wStart);
                    for (v = 0; v < pdpv->dwCount; v++)
                    {
                        // Flip color ordering from D3D's BGRA to
                        // OpenGL's RGBA
                        pdtlvtx->color =
                            (((pdtlvtx->color >> 24) & 0xff) << 24) |
                            (((pdtlvtx->color >> 16) & 0xff) <<  0) |
                            (((pdtlvtx->color >>  8) & 0xff) <<  8) |
                            (((pdtlvtx->color >>  0) & 0xff) << 16);
                        pdtlvtx++;
                    }

                    pdpv->dwFlags |= PROCESSED_TLVERTEX;
                }

                pdpv++;
            }
            break;
            
        case D3DOP_EXIT:
            bExit = TRUE;
            break;
        }

        pdinst = NEXT_PDINST(pdinst);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\d3dtex.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "d3drend.h"
#include "util.h"
#include "loadppm.h"
#include "globals.h"

D3dTexture::D3dTexture(void)
{
    _pddsSrc = NULL;
    _pdtexSrc = NULL;
    _pddsDst = NULL;
    _pdtexDst = NULL;
    _pdtexNext = NULL;
}

/*
 * D3dLoadSurface
 * Loads a ppm file into a texture map DD surface in system memory.
 */
LPDIRECTDRAWSURFACE
D3dLoadSurface(LPDIRECTDRAW lpDD, LPCSTR lpName, LPDDSURFACEDESC lpFormat)
{
    LPDIRECTDRAWSURFACE lpDDS;
    DDSURFACEDESC ddsd;
    int i, j;
    LPDIRECTDRAWPALETTE lpDDPal;
    PALETTEENTRY ppe[256];
    HRESULT ddrval;
    Image im;
    ImageFormat ifmt;
    BYTE *pbSrc, *pbDst;
    UINT cbRow;

    ifmt.nColorBits = lpFormat->ddpfPixelFormat.dwRGBBitCount;
    ifmt.bQuantize =
        (lpFormat->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) != 0;
    if (!ifmt.bQuantize)
    {
        unsigned long m;
        int s;
        
        m = lpFormat->ddpfPixelFormat.dwRBitMask;
        for (s = 0; !(m & 1); s++, m >>= 1) ;
        ifmt.iRedShift = s;
        for (s = 0; m != 0; s++, m >>= 1) ;
        ifmt.iRedBits = s;
        m = lpFormat->ddpfPixelFormat.dwGBitMask;
        for (s = 0; !(m & 1); s++, m >>= 1) ;
        ifmt.iGreenShift = s;
        for (s = 0; m != 0; s++, m >>= 1) ;
        ifmt.iGreenBits = s;
        m = lpFormat->ddpfPixelFormat.dwBBitMask;
        for (s = 0; !(m & 1); s++, m >>= 1) ;
        ifmt.iBlueShift = s;
        for (s = 0; m != 0; s++, m >>= 1) ;
        ifmt.iBlueBits = s;
    }

    if (!LoadPPM(lpName, &ifmt, &im))
    {
        return NULL;
    }

    memcpy(&ddsd, lpFormat, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY;
    ddsd.dwHeight = im.uiHeight;
    ddsd.dwWidth = im.uiWidth;
    ddrval = lpDD->CreateSurface(&ddsd, &lpDDS, NULL);
    if (ddrval != DD_OK) {
        /*
         * If we failed, it might be the pixelformat flag bug in some ddraw
         * hardware drivers.  Try again without the flag.
         */
        memcpy(&ddsd, lpFormat, sizeof(DDSURFACEDESC));
        ddsd.dwSize = sizeof(DDSURFACEDESC);
        ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
        ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY;
        ddsd.dwHeight = im.uiHeight;
        ddsd.dwWidth = im.uiWidth;
        ddrval = lpDD->CreateSurface(&ddsd, &lpDDS, NULL);
        if (ddrval != DD_OK) {
            Msg("CreateSurface for texture failed (loadtex).\n%s",
                D3dErrorString(ddrval));
	    return NULL;
        }
    }
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddrval = lpDDS->Lock(NULL, &ddsd, 0, NULL);
    if (ddrval != DD_OK) {
        delete [] im.pvImage;
	lpDDS->Release();
        Msg("Lock failed while loading surface (loadtex).\n%s",
            D3dErrorString(ddrval));
	return NULL;
    }

    pbSrc = (BYTE *)im.pvImage;
    pbDst = (BYTE *)ddsd.lpSurface;
    cbRow = ((ifmt.nColorBits+7)/8)*im.uiWidth;
    for (j = 0; (UINT)j < im.uiHeight; j++)
    {
        memcpy(pbDst, pbSrc, cbRow);
        pbSrc += cbRow;
        pbDst += ddsd.lPitch;
    }
    delete [] im.pvImage;
    lpDDS->Unlock(NULL);

    if (ifmt.bQuantize)
    {
        /*
         * Now to create a palette
         */
        memset(ppe, 0, sizeof(PALETTEENTRY) * 256);
        for (i = 0; (UINT)i < im.nColors; i++) {
            ppe[i].peRed = (unsigned char)RGB_GETRED(im.dcolPalette[i]);
            ppe[i].peGreen = (unsigned char)RGB_GETGREEN(im.dcolPalette[i]);
            ppe[i].peBlue = (unsigned char)RGB_GETBLUE(im.dcolPalette[i]);
        }
        /*
         * D3DPAL_RESERVED entries are ignored by the renderer.
         */
        for (; i < 256; i++)
            ppe[i].peFlags = D3DPAL_RESERVED;
        ddrval = lpDD->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE |
                                     DDPCAPS_ALLOW256,
                                     ppe, &lpDDPal, NULL);
        if (ddrval != DD_OK) {
            lpDDS->Release();
            Msg("Create palette failed while loading surface (loadtex).\n%s",
                D3dErrorString(ddrval));
            return (NULL);
        }

        /*
         * Finally, bind the palette to the surface
         */
        ddrval = lpDDS->SetPalette(lpDDPal);
        if (ddrval != DD_OK) {
            lpDDS->Release();
            lpDDPal->Release();
            Msg("SetPalette failed while loading surface (loadtex).\n%s",
                D3dErrorString(ddrval));
            return (NULL);
        }
    }

    return lpDDS;
}

/*
 * CreateVidTex
 * Create a texture in video memory (if appropriate).
 * If no hardware exists, this will be created in system memory, but we
 * can still use load to swap textures.
 */
BOOL
D3dTexture::CreateVidTex(LPDIRECTDRAW pdd, UINT uiFlags)
{
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWPALETTE lpDDPal = NULL;
    PALETTEENTRY ppe[256];
    BOOL bQuant;
    BOOL bOnlySoftRender;

    if (!GetDDSurfaceDesc(&ddsd, _pddsSrc))
	return FALSE;
    if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
        bQuant = TRUE;
    else
        bQuant = FALSE;
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    if (uiFlags & REND_BUFFER_SYSTEM_MEMORY)
        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
    hrLast = pdd->CreateSurface(&ddsd, &_pddsDst, NULL);
    if (hrLast != DD_OK) {
        Msg("Create surface in CreateVidTexture failed.\n%s",
            D3dErrorString(hrLast));
        return FALSE;
    }
    if (!GetDDSurfaceDesc(&ddsd, _pddsDst))
	return FALSE;
    bOnlySoftRender = FALSE;
    if ((_pdrend->_ddscapsHw.dwCaps & DDSCAPS_TEXTURE) &&
        !(ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
        bOnlySoftRender = TRUE;
    if (stat.rgd.bHardwareAssisted && bOnlySoftRender) {
        Msg("Failed to put texture surface in video memory for "
            "hardware D3D device.\n");
        return FALSE;
    }
    if (bQuant) {
        memset(ppe, 0, sizeof(PALETTEENTRY) * 256);
	hrLast = pdd->CreatePalette(DDPCAPS_8BIT, ppe, &lpDDPal, NULL);
	if (hrLast != DD_OK) {
            Msg("CreatePalette in CreateVidTexture failed.\n%s",
                D3dErrorString(hrLast));
            return FALSE;
	}
	hrLast = _pddsDst->SetPalette(lpDDPal);
	if (hrLast != DD_OK) {
            RELEASE(lpDDPal);
            Msg("SetPalette in CreateVidTexture failed.\n%s",
                D3dErrorString(hrLast));
            return FALSE;
	}
    }
    hrLast = _pddsDst->QueryInterface(IID_IDirect3DTexture,
                                      (LPVOID*)&_pdtexDst);
    if (hrLast != D3D_OK) {
        RELEASE(lpDDPal);
        Msg("QueryInterface in CreateVidTexture failed.\n%s",
            D3dErrorString(hrLast));
        return FALSE;
    }
    return TRUE;
}
                   
BOOL D3dTexture::Initialize(D3dRenderer* pdrend,
                            LPDIRECTDRAW pdd, LPDIRECT3DDEVICE pd3dev,
                            DDSURFACEDESC* pddsd, char* pszFile, UINT uiFlags,
                            D3dTexture* pdtexNext)
{
    HRESULT ddrval;
    PALETTEENTRY ppe[256];
    LPDIRECTDRAWPALETTE lpDDPalSrc, lpDDPalDst;
    BOOL bSucc;

    bSucc = FALSE;
    _pdrend = pdrend;
    
    /*
     * Load each image file as a "source" texture surface in system memory.
     * Load each source texture surface into a "destination" texture (in video
     * memory if appropriate).  The destination texture handles are used in
     * rendering.  This scheme demos the Load call and allows dynamic texture
     * swapping.
     */
    
    if (!(_pddsSrc = D3dLoadSurface(pdd, pszFile, pddsd)))
    {
        return FALSE;
    }

    hrLast = _pddsSrc->QueryInterface(IID_IDirect3DTexture,
                                            (LPVOID*)&_pdtexSrc);
    if (hrLast != DD_OK) {
        Msg("Could not create texture.\n%s", D3dErrorString(hrLast));
        return FALSE;;
    }
    if (!CreateVidTex(pdd, uiFlags))
        return FALSE;
    hrLast = _pdtexDst->GetHandle(pd3dev, &_dthDst);
    if (hrLast != D3D_OK) {
        Msg("Could not get dest texture handle.\n%s",
            D3dErrorString(hrLast));
        return FALSE;
    }
    if (_pddsDst->Blt(NULL, _pddsSrc, NULL,
                         DDBLT_WAIT, NULL) != DD_OK) {
        Msg("Could not load src texture into dest.");
        return FALSE;
    }
    ddrval = _pddsSrc->GetPalette(&lpDDPalSrc);
    if (ddrval == DDERR_NOPALETTEATTACHED) {
        return TRUE;
    }
    if (ddrval != DD_OK) {
        Msg("Could not get source palette");
        return FALSE;
    }
    ddrval = _pddsDst->GetPalette(&lpDDPalDst);
    if (ddrval != DD_OK) {
        Msg("Could not get dest palette");
        goto EH_lpDDPalSrc;
    }
    ddrval = lpDDPalSrc->GetEntries(0, 0, 256, ppe);
    if (ddrval != DD_OK) {
        Msg("Could not get source palette entries");
        goto EH_lpDDPalDst;
    }
    ddrval = lpDDPalDst->SetEntries(0, 0, 256, ppe);
    if (ddrval != DD_OK)
    {
        Msg("Could not get source palette entries");
    }
    else
    {
        bSucc = TRUE;
        _pdtexNext = pdtexNext;
    }
 EH_lpDDPalDst:
    lpDDPalDst->Release();
 EH_lpDDPalSrc:
    lpDDPalSrc->Release();

    return bSucc;
}

D3dTexture::~D3dTexture(void)
{
    // ATTENTION - Tanks the texture list because the window isn't
    // notified but it works for now
    RELEASE(_pddsSrc);
    RELEASE(_pdtexSrc);
    RELEASE(_pddsDst);
    RELEASE(_pdtexDst);
}

void D3dTexture::Release(void)
{
    delete this;
}

D3DTEXTUREHANDLE D3dTexture::Handle(void)
{
    return _dthDst;
}

BOOL D3dTexture::RestoreSurface(void)
{
    if (_pddsSrc->IsLost() == DDERR_SURFACELOST)
    {
        hrLast = _pddsSrc->Restore();
        if (hrLast != DD_OK)
        {
            Msg("Restore of a src texture surface failed.\n%s",
                D3dErrorString(hrLast));
            return FALSE;
        }
    }
    if (_pddsDst->IsLost() == DDERR_SURFACELOST)
    {
        hrLast = _pddsDst->Restore();
        if (hrLast != DD_OK)
        {
            Msg("Restore of a dst texture surface failed.\n%s",
                D3dErrorString(hrLast));
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\glmatrl.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "glrend.h"
#include "util.h"

#define GLMAT_DIFFUSE   0x0001
#define GLMAT_SPECULAR  0x0002

GlMaterial::GlMaterial(void)
{
    _uiFlags = 0;
}

void GlMaterial::Release(void)
{
    delete this;
}

D3DMATERIALHANDLE GlMaterial::Handle(void)
{
    return (D3DMATERIALHANDLE)this;
}

void GlMaterial::SetDiffuse(D3DCOLORVALUE* pdcol)
{
    _uiFlags |= GLMAT_DIFFUSE;
    _afDiffuse[0] = pdcol->r;
    _afDiffuse[1] = pdcol->g;
    _afDiffuse[2] = pdcol->b;
    _afDiffuse[3] = pdcol->a;
}

void GlMaterial::SetSpecular(D3DCOLORVALUE* pdcol, float fPower)
{
    _uiFlags |= GLMAT_SPECULAR;
    _afSpecular[0] = pdcol->r;
    _afSpecular[1] = pdcol->g;
    _afSpecular[2] = pdcol->b;
    _afSpecular[3] = pdcol->a;
    _fPower = fPower;
}

void GlMaterial::SetTexture(RendTexture* prtex)
{
    // Nothing to do
}

void GlMaterial::Apply(void)
{
    if (_uiFlags & GLMAT_DIFFUSE)
    {
        // ATTENTION - This should be AMBIENT_AND_DIFFUSE but doing so
        // causes complete color overload
        glMaterialfv(GL_FRONT, GL_DIFFUSE, _afDiffuse);
    }
    if (_uiFlags & GLMAT_SPECULAR)
    {
        glMaterialfv(GL_FRONT, GL_SPECULAR, _afSpecular);
        glMaterialf(GL_FRONT, GL_SHININESS, _fPower);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\gfxperf.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation. All Rights Reserved.
 *
 *  File: d3dtest.cpp
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "rend.h"
#include "resource.h"
#include "polytest.h"
#include "pixtest.h"
#include "sfiltest.h"
#include "globals.h"
#include "util.h"
#include "loadppm.h"

#define OVERDRAW_IN_PIXEL_TEST 5

#define OBJECTS_IN_THROUGHPUT_TEST 8
#define RINGS_IN_THROUGHPUT_TEST 30
#define SEGS_IN_THROUGHPUT_TEST 30
#define D_IN_THROUGHPUT_TEST 1.0f
#define DEPTH_IN_THROUGHPUT_TEST 0.6f
#define R_IN_THROUGHPUT_TEST 0.4f
#define DV_IN_THROUGHPUT_TEST 0.05f
#define DR_IN_THROUGHPUT_TEST 0.3f
#define ALPHA_IN_THROUGHPUT_TEST FALSE

#define OBJECTS_IN_INTERSECTION_TEST 16
#define RINGS_IN_INTERSECTION_TEST 5
#define SEGS_IN_INTERSECTION_TEST 6
#define D_IN_INTERSECTION_TEST 1.6f
#define DEPTH_IN_INTERSECTION_TEST 0.2f
#define R_IN_INTERSECTION_TEST 0.7f
#define DV_IN_INTERSECTION_TEST 0.06f
#define DR_IN_INTERSECTION_TEST 0.2f
#define ALPHA_IN_INTERSECTION_TEST FALSE

#define AREA_IN_SIMPLE_FILL_TEST 10000.0f
#define OVERDRAW_IN_SIMPLE_FILL_TEST 50

#define OBJECTS_IN_TRANSPARENCY_TEST 8
#define RINGS_IN_TRANSPARENCY_TEST 30
#define SEGS_IN_TRANSPARENCY_TEST 30
#define D_IN_TRANSPARENCY_TEST 1.0f
#define DEPTH_IN_TRANSPARENCY_TEST 0.6f
#define R_IN_TRANSPARENCY_TEST 0.4f
#define DV_IN_TRANSPARENCY_TEST 0.05f
#define DR_IN_TRANSPARENCY_TEST 0.3f
#define ALPHA_IN_TRANSPARENCY_TEST TRUE

#define DEF_TEST_INTERVAL 10.0f
#define DEF_STARTUP_INTERVAL 2.0f
 
/*************************************************************************
  Internal Function Declarations
 *************************************************************************/

BOOL RunPolyTest(UINT uiTest, float *pfResult);
BOOL RunPixelTest(UINT uiTest, float *pfResult);
BOOL RunIntersectionTest(UINT uiTest, float *pfResult);
BOOL RunSimpleFillTest(UINT uiTest, float *pfResult);
BOOL RunTransparencyTest(UINT uiTest, float *pfResult);

/************************************************************************
  Globals
 ************************************************************************/

Renderer *prend[RENDERER_COUNT];

/*
 * Info structures
 */
AppInfo app;
StatInfo stat;
TexInfo tex;

struct Results
{
    float fLast;
    float fPeak;
};

struct Test
{
    char *pszName;
    char *pszUnits;
    float fScale;
    BOOL bHasOrder;
    BOOL (*pfnRun)(UINT uiTest, float *pfResult);
    Results res[ORDER_COUNT];
};

Test atest[TEST_COUNT] =
{
    "Polygon Fill", "mpps", 1000000.0f, TRUE, RunPixelTest,
        0.0f, 0.0f, 0.0f, 0.0f,
    "Intersecting Polygons", "kpps", 1000.0f, TRUE, RunIntersectionTest,
        0.0f, 0.0f, 0.0f, 0.0f,
    "Simple Fill", "mpps", 1000000.0f, TRUE, RunSimpleFillTest,
        0.0f, 0.0f, 0.0f, 0.0f,
    "Transparent Polygons", "kpps", 1000.0f, FALSE, RunTransparencyTest,
        0.0f, 0.0f, 0.0f, 0.0f,
    "Polygon Drawing", "kpps", 1000.0f, FALSE, RunPolyTest,
        0.0f, 0.0f, 0.0f, 0.0f,
};

/*************************************************************************
  Tests
 *************************************************************************/

BOOL WaitForInput(void)
{
    MSG msg;
    HWND hwnd;

    hwnd = app.prwin->Handle();
    while (GetMessage(&msg, hwnd, 0, 0))
    {
        TranslateMessage(&msg);
        if (msg.message == WM_KEYDOWN ||
            msg.message == WM_LBUTTONDOWN)
        {
            if (msg.wParam == VK_ESCAPE)
            {
                app.bAbortTest = TRUE;
            }
            return TRUE;
        }
        DispatchMessage(&msg);
    }
    return FALSE;
}

D3DRECT drcDirtyLast, drcDirtyBeforeLast;
BOOL bDirtyLast;

BOOL ResetDirtyRects(void)
{
    UINT uiBuffers;
    BOOL bSucc;
    
    drcDirtyLast = app.drcViewport;
    if (app.bFullscreen)
    {
        drcDirtyBeforeLast = app.drcViewport;
    }
    else
    {
        uiBuffers = REND_BUFFER_FRONT | REND_BUFFER_BACK;
        if (stat.bZBufferOn)
        {
            uiBuffers |= REND_BUFFER_Z;
        }
        bSucc = app.prwin->Clear(uiBuffers, NULL);
        if (!bSucc)
        {
            Msg("Initial viewport clear failed.\n%s",
                app.prend->LastErrorString());
            return FALSE;
        }

        bDirtyLast = FALSE;
    }

    return TRUE;
}

/*
 * RenderLoop
 * Application idle loop which renders.
 */
BOOL
RenderLoop(UINT uiTest)
{
    BOOL bSucc;
    LPD3DRECT pdrcClear;
    UINT uiBuffers;
    
    /*
     * Clear back buffer and Z buffer if enabled
     */
    if (stat.bClearsOn)
    {
        if (app.bFullscreen)
        {
	    pdrcClear = &drcDirtyBeforeLast;
	    if (uiTest == FILL_RATE_TEST ||
                uiTest == INTERSECTION_TEST)
            {
                bSucc = app.prwin->Clear(REND_BUFFER_Z, pdrcClear);
            }
	    else
            {
                uiBuffers = (stat.bUpdates ? REND_BUFFER_BACK : 0) |
                    REND_BUFFER_Z;
		bSucc = app.prwin->Clear(uiBuffers, pdrcClear);
            }
	    if (!bSucc)
            {
		Msg("Viewport clear failed.\n%s",
                    app.prend->LastErrorString());
		return FALSE;
	    }
        }
        else
        {
            if (bDirtyLast)
            {
                pdrcClear = &drcDirtyLast;
                uiBuffers = (stat.bUpdates ? REND_BUFFER_BACK : 0) |
                    REND_BUFFER_Z;
                bSucc = app.prwin->Clear(uiBuffers, pdrcClear);
                if (!bSucc)
                {
                    Msg("Viewport clear failed.\n%s",
                        app.prend->LastErrorString());
                    return FALSE;
                }
            }
        }
            
        drcDirtyBeforeLast = drcDirtyLast;
    }
    
    if (uiTest == THROUGHPUT_TEST ||
        uiTest == INTERSECTION_TEST ||
        uiTest == TRANSPARENCY_TEST)
    {
        if (!RenderScenePoly(app.prwin, &drcDirtyLast))
        {
            Msg("RenderScenePoly failed.\n");
            return FALSE;
        }
    }
    else if (uiTest == FILL_RATE_TEST)
    {
        if (!RenderScenePix(app.prwin, &drcDirtyLast))
        {
            Msg("RenderScenePix failed.\n");
            return FALSE;
        }
        
	/*
	 * Because extents are not correct
	 */
        drcDirtyLast = app.drcViewport;
    }
    else if (uiTest == SIMPLE_FILL_TEST)
    {
        if (!RenderSceneSimple(app.prwin, &drcDirtyLast))
        {
            Msg("RenderSceneSimple failed.\n");
            return FALSE;
        }
        
	/*
	 * Because extents are not correct
	 */
        drcDirtyLast = app.drcViewport;
    }
    else
    {
        Msg("Bad uiTest.\n");
        return FALSE;
    }
    
    if (app.bFullscreen)
    {
        if (stat.bUpdates)
        {
            bSucc = app.prwin->Flip();
            if (!bSucc)
            {
                Msg("Flip failed.\n%s", app.prend->LastErrorString());
                return FALSE;
            }
        }
    }
    else
    {
	if (bDirtyLast)
        {
	    if (drcDirtyBeforeLast.x1 < drcDirtyLast.x1)
            {
		drcDirtyLast.x1 = drcDirtyBeforeLast.x1;
            }
	    if (drcDirtyBeforeLast.y1 < drcDirtyLast.y1)
            {
		drcDirtyLast.y1 = drcDirtyBeforeLast.y1;
            }
	    if (drcDirtyBeforeLast.x2 > drcDirtyLast.x2)
            {
		drcDirtyLast.x2 = drcDirtyBeforeLast.x2;
            }
	    if (drcDirtyBeforeLast.y2 > drcDirtyLast.y2)
            {
		drcDirtyLast.y2 = drcDirtyBeforeLast.y2;
            }
	}
        
	bDirtyLast = stat.bClearsOn;

        if (stat.bUpdates)
        {
            bSucc = app.prwin->CopyForward(&drcDirtyLast);
            if (!bSucc)
            {
                Msg("Blt of back to front buffer failed.\n%s",
                    app.prend->LastErrorString());
                return FALSE;
            }
        }
    }

    if (app.bWaitForInput)
    {
        return WaitForInput();
    }
    else
    {
        return TRUE;
    }
}

BOOL RunRenderLoop(UINT uiTest, ULONG ulScale, float *pfResult)
{
    ULONG ulFrames;
    float fElapsed;
    BOOL bSucc;

    bSucc = FALSE;
    ulFrames = 0;
    fElapsed = 0.0f;
    app.bAbortTest = FALSE;
    app.uiCurrentTest = uiTest;
    
    ResetDirtyRects();
    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    
    ResetTimer();
    do
    {
	if (!RenderLoop(uiTest))
        {
	    goto Exit;
	}
    } while (!app.bAbortTest &&
             (app.bWaitForInput || Timer() < app.fStartupInterval));
    if (app.bAbortTest)
    {
        bSucc = TRUE;
        goto Exit;
    }
    
    ResetTimer();
    do
    {
	if (!RenderLoop(uiTest))
        {
            goto Exit;
	}
        
	++ulFrames;
	fElapsed = Timer();
    } while (!app.bAbortTest &&
             (app.bWaitForInput || Timer() < app.fTestInterval));
    
    bSucc = TRUE;

 Exit:
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);

    if (fElapsed > 0.0f)
    {
        *pfResult = (float)(ulScale * ulFrames) / fElapsed;
    }
    else
    {
        *pfResult = 0.0f;
    }
    return bSucc;
}

BOOL
RunPolyTest(UINT uiTest, float *pfResult)
{
    BOOL bSucc;
    ULONG ulPolys;
    
    ulPolys = InitViewPoly(app.prwin, tex.nTextures,
                           &tex.prtex[0], OBJECTS_IN_THROUGHPUT_TEST,
                           RINGS_IN_THROUGHPUT_TEST, SEGS_IN_THROUGHPUT_TEST,
                           NO_SORT, R_IN_THROUGHPUT_TEST,
                           D_IN_THROUGHPUT_TEST, DEPTH_IN_THROUGHPUT_TEST,
                           DV_IN_THROUGHPUT_TEST, DR_IN_THROUGHPUT_TEST,
                           ALPHA_IN_THROUGHPUT_TEST);
    if (ulPolys == 0)
    {
        Msg("Initializing the scene for the polygon "
            "throughput test failed.\n");
        return FALSE;
    }

    bSucc = RunRenderLoop(uiTest, ulPolys, pfResult);
    
    ReleaseViewPoly();

    return bSucc;
}

BOOL
RunPixelTest(UINT uiTest, float *pfResult)
{
    ULONG ulPixels;
    BOOL bSucc;

    ulPixels = InitViewPix(app.prwin, tex.nTextures,
                           &tex.prtex[0], WIN_WIDTH, WIN_HEIGHT, 
                           OVERDRAW_IN_PIXEL_TEST, stat.uiOverdrawOrder);
    if (ulPixels == 0)
    {
        Msg("InitViewPix failed.\n");
        return FALSE;
    }

    bSucc = RunRenderLoop(uiTest, ulPixels, pfResult);

    ReleaseViewPix();

    return bSucc;
}

BOOL
RunIntersectionTest(UINT uiTest, float *pfResult)
{
    ULONG ulPolys;
    BOOL bSucc;

    ulPolys = InitViewPoly(app.prwin, tex.nTextures,
                           &tex.prtex[0], OBJECTS_IN_INTERSECTION_TEST,
                           RINGS_IN_INTERSECTION_TEST,
                           SEGS_IN_INTERSECTION_TEST, stat.uiOverdrawOrder,
                           R_IN_INTERSECTION_TEST, D_IN_INTERSECTION_TEST,
                           DEPTH_IN_INTERSECTION_TEST, DV_IN_INTERSECTION_TEST,
                           DR_IN_INTERSECTION_TEST,
                           ALPHA_IN_INTERSECTION_TEST);
    if (ulPolys == 0)
    {
        Msg("Initializing the scene for the polygon "
            "throughput test failed.\n");
        return FALSE;
    }

    bSucc = RunRenderLoop(uiTest, ulPolys, pfResult);
    
    ReleaseViewPoly();

    return bSucc;
}

BOOL RunSimpleFillTest(UINT uiTest, float *pfResult)
{
    BOOL bSucc;
    ULONG ulPixels;

    ulPixels = InitViewSimple(app.prwin, tex.nTextures, &tex.prtex[0],
                              WIN_WIDTH, WIN_HEIGHT, AREA_IN_SIMPLE_FILL_TEST,
                              stat.uiOverdrawOrder,
                              OVERDRAW_IN_SIMPLE_FILL_TEST);
    if (ulPixels == 0)
    {
        Msg("Initializing the scene for the simple "
            "fill test failed.\n");
        return FALSE;
    }

    bSucc = RunRenderLoop(uiTest, ulPixels, pfResult);
    
    ReleaseViewSimple();

    return bSucc;
}

BOOL
RunTransparencyTest(UINT uiTest, float *pfResult)
{
    BOOL bSucc;
    ULONG ulPolys;

    ulPolys = InitViewPoly(app.prwin, tex.nTextures,
                           &tex.prtex[0], OBJECTS_IN_TRANSPARENCY_TEST,
                           RINGS_IN_TRANSPARENCY_TEST,
                           SEGS_IN_TRANSPARENCY_TEST,
                           NO_SORT, R_IN_TRANSPARENCY_TEST,
                           D_IN_TRANSPARENCY_TEST, DEPTH_IN_TRANSPARENCY_TEST,
                           DV_IN_TRANSPARENCY_TEST, DR_IN_TRANSPARENCY_TEST,
                           ALPHA_IN_TRANSPARENCY_TEST);
    if (ulPolys == 0)
    {
        Msg("Initializing the scene for the polygon "
            "transparency test failed.\n");
        return FALSE;
    }

    bSucc = RunRenderLoop(uiTest, ulPolys, pfResult);
    
    ReleaseViewPoly();

    return bSucc;
}

/*************************************************************************
  Windows specific functions
 *************************************************************************/

void
SetStateFromDialog(void)
{
    stat.bOnlySystemMemory = IsDlgButtonChecked(app.hDlg, SYSTEM_MEMORY_CHECK);
    if (stat.bOnlySystemMemory)
    {
        stat.uiExeBufFlags = REND_BUFFER_SYSTEM_MEMORY;
    }
    else
    {
        stat.uiExeBufFlags = 0;
    }
    stat.bZBufferOn = IsDlgButtonChecked(app.hDlg, ZBUFFER_CHECK);
    if (stat.bZBufferOn)
    {
        stat.bClearsOn = TRUE;
    }
    stat.bPerspCorrect = IsDlgButtonChecked(app.hDlg, PERSP_CHECK);
    stat.bSpecular = IsDlgButtonChecked(app.hDlg, SPECULAR_CHECK);
    stat.bTexturesOn = IsDlgButtonChecked(app.hDlg, TEXTURES_CHECK);
    stat.bUpdates = !IsDlgButtonChecked(app.hDlg, NO_UPDATES_CHECK);
    stat.dtfTextureFilter = (IsDlgButtonChecked(app.hDlg, POINT_RADIO)) ?
        D3DFILTER_NEAREST : D3DFILTER_LINEAR;
    stat.dsmShadeMode = (IsDlgButtonChecked(app.hDlg, GOURAUD_RADIO)) ?
        D3DSHADE_GOURAUD : D3DSHADE_FLAT;
    stat.dtbTextureBlend = IsDlgButtonChecked(app.hDlg, COPY_RADIO) ?
        D3DTBLEND_COPY : D3DTBLEND_MODULATE;
    stat.uiOverdrawOrder =
        (IsDlgButtonChecked(app.hDlg, FRONT_TO_BACK_RADIO)) ?
        FRONT_TO_BACK : BACK_TO_FRONT;
    app.bWaitForInput = IsDlgButtonChecked(app.hDlg, SINGLE_STEP_CHECK);
}

void ShowRateInfo(void)
{
    char achText[80];
    Test *ptest;
    Results *pres;

    ptest = &atest[app.uiCurrentTest];
    pres = ptest->bHasOrder ?
        &ptest->res[stat.uiOverdrawOrder] :
        &ptest->res[0];

    if (ptest->bHasOrder)
    {
        sprintf(achText, "%s (%s)", ptest->pszName,
                stat.uiOverdrawOrder == FRONT_TO_BACK ? "FtB" : "BtF");
        SetWindowText(GetDlgItem(app.hDlg, TEST_NAME_TEXT), achText);
    }
    else
    {
        SetWindowText(GetDlgItem(app.hDlg, TEST_NAME_TEXT), ptest->pszName);
    }
    
    sprintf(achText, "%.2f", pres->fLast / ptest->fScale);
    SetWindowText(GetDlgItem(app.hDlg, LAST_RESULT_TEXT), achText);
    SetWindowText(GetDlgItem(app.hDlg, LAST_RESULT_UNITS), ptest->pszUnits);
    
    sprintf(achText, "%.2f", pres->fPeak / ptest->fScale);
    SetWindowText(GetDlgItem(app.hDlg, PEAK_RESULT_TEXT), achText);
    SetWindowText(GetDlgItem(app.hDlg, PEAK_RESULT_UNITS), ptest->pszUnits);
}

void
RefreshButtons(void)
{
    CheckDlgButton(app.hDlg, SYSTEM_MEMORY_CHECK, stat.bOnlySystemMemory);
    CheckDlgButton(app.hDlg, ZBUFFER_CHECK, stat.bZBufferOn);
    EnableWindow(GetDlgItem(app.hDlg, ZBUFFER_CHECK), stat.rgd.nZBits > 0);
    CheckDlgButton(app.hDlg, PERSP_CHECK, stat.bPerspCorrect);
    CheckDlgButton(app.hDlg, TEXTURES_CHECK, stat.bTexturesOn);
    CheckDlgButton(app.hDlg, SPECULAR_CHECK, stat.bSpecular);
    EnableWindow(GetDlgItem(app.hDlg, SPECULAR_CHECK),
                 stat.rgd.bSpecularLighting);
    CheckDlgButton(app.hDlg, NO_UPDATES_CHECK, !stat.bUpdates);
    CheckDlgButton(app.hDlg, POINT_RADIO,
                   (stat.dtfTextureFilter == D3DFILTER_NEAREST) ? 1 : 0);
    CheckDlgButton(app.hDlg, BILINEAR_RADIO,
                   (stat.dtfTextureFilter == D3DFILTER_LINEAR) ? 1 : 0);
    CheckDlgButton(app.hDlg, GOURAUD_RADIO,
                   (stat.dsmShadeMode == D3DSHADE_GOURAUD &&
                    stat.dtbTextureBlend == D3DTBLEND_MODULATE) ? 1 : 0);
    CheckDlgButton(app.hDlg, FLAT_RADIO,
                   (stat.dsmShadeMode == D3DSHADE_FLAT &&
                    stat.dtbTextureBlend == D3DTBLEND_MODULATE) ? 1 : 0);
    CheckDlgButton(app.hDlg, FRONT_TO_BACK_RADIO,
                   (stat.uiOverdrawOrder == FRONT_TO_BACK) ? 1 : 0);
    CheckDlgButton(app.hDlg, BACK_TO_FRONT_RADIO,
                   (stat.uiOverdrawOrder == BACK_TO_FRONT) ? 1 : 0);
    CheckDlgButton(app.hDlg, COPY_RADIO,
                   (stat.dtbTextureBlend == D3DTBLEND_COPY) ? 1 : 0);
    EnableWindow(GetDlgItem(app.hDlg, COPY_RADIO), stat.rgd.bCopyTextureBlend);
    CheckDlgButton(app.hDlg, MONO_RADIO,
                   (stat.dcmColorModel == D3DCOLOR_MONO ? 1 : 0));
    EnableWindow(GetDlgItem(app.hDlg, MONO_RADIO),
                 (stat.rgd.uiColorTypes & REND_COLOR_MONO) != 0);
    CheckDlgButton(app.hDlg, RGB_RADIO,
                   (stat.dcmColorModel == D3DCOLOR_RGB ? 1 : 0));
    EnableWindow(GetDlgItem(app.hDlg, RGB_RADIO),
                 (stat.rgd.uiColorTypes & REND_COLOR_RGBA) != 0);
    CheckDlgButton(app.hDlg, MODULATE_RADIO,
                   (stat.dtbTextureBlend == D3DTBLEND_MODULATE) ? 1 : 0);
    CheckDlgButton(app.hDlg, SINGLE_STEP_CHECK, app.bWaitForInput);
    EnableWindow(GetDlgItem(app.hDlg, SYSTEM_MEMORY_CHECK),
                 !stat.rgd.bHardwareAssisted);
    EnableWindow(GetDlgItem(app.hDlg, PERSP_CHECK), !stat.bTexturesDisabled);
    EnableWindow(GetDlgItem(app.hDlg, TEXTURES_CHECK),
                 !stat.bTexturesDisabled);
    EnableWindow(GetDlgItem(app.hDlg, POINT_RADIO), !stat.bTexturesDisabled);
    EnableWindow(GetDlgItem(app.hDlg, BILINEAR_RADIO),
                 !stat.bTexturesDisabled);
    EnableWindow(GetDlgItem(app.hDlg, COPY_RADIO), !stat.bTexturesDisabled);
    EnableWindow(GetDlgItem(app.hDlg, MODULATE_RADIO),
                 !stat.bTexturesDisabled);
}
 
BOOL EnumAddDriver(RendDriverDescription *prdd, void *pvArg)
{
    int n;
    
    n = SendDlgItemMessage(app.hDlg, (int)pvArg, CB_ADDSTRING,
                           0, (LPARAM)prdd->achName);
    SendDlgItemMessage(app.hDlg, (int)pvArg, CB_SETITEMDATA,
                       n, (LPARAM)prdd->rid);
    return TRUE;
}

int GetCurrGraphics(void)
{
    int n;
    
    n = SendDlgItemMessage(app.hDlg, GRAPHICS_LIST, CB_GETCURSEL, 0, 0);
    if (n < 0)
    {
        Msg("Invalid graphics selected.\n");
        n = 0;
    }
    return n;
}

void FillGraphics(void)
{
    SendDlgItemMessage(app.hDlg, GRAPHICS_LIST, CB_RESETCONTENT, 0, 0);
    app.prend->EnumGraphicsDrivers(EnumAddDriver, (void *)GRAPHICS_LIST);
}

BOOL ChangeGraphics(int iGraphics)
{
    RendId rid;
    int i;

    rid = (RendId)SendDlgItemMessage(app.hDlg, GRAPHICS_LIST, CB_GETITEMDATA,
                                     iGraphics, 0);
    if (!app.prend->SelectGraphicsDriver(rid) ||
        !app.prend->DescribeGraphics(&stat.rgd))
    {
        CleanUpAndPostQuit();
        return FALSE;
    }

    app.iGraphics = iGraphics;
    SendDlgItemMessage(app.hDlg, GRAPHICS_LIST, CB_SETCURSEL,
                       app.iGraphics, 0);

    stat.dcmColorModel = (stat.rgd.uiColorTypes & REND_COLOR_RGBA) ?
        D3DCOLOR_RGB : D3DCOLOR_MONO;
    stat.dtbTextureBlend = D3DTBLEND_MODULATE;
    if (!stat.rgd.bSpecularLighting)
    {
        stat.bSpecular = FALSE;
    }
    if (stat.rgd.nZBits == 0)
    {
        stat.bZBufferOn = FALSE;
    }
    if (!stat.rgd.bPerspectiveCorrect)
    {
        stat.bTexturesDisabled = TRUE;
    }
    else
    {
        stat.bTexturesDisabled = FALSE;
    }
    if ((stat.rgd.uiExeBufFlags & REND_BUFFER_VIDEO_MEMORY) &&
        !stat.bOnlySystemMemory)
    {
        stat.uiExeBufFlags = REND_BUFFER_VIDEO_MEMORY;
    }
    else
    {
        stat.uiExeBufFlags = REND_BUFFER_SYSTEM_MEMORY;
    }
    RefreshButtons();
    
    for (i = 0; i < TEST_COUNT; i++)
    {
        atest[i].res[0].fLast = 0.0f;
        atest[i].res[1].fLast = 0.0f;
        atest[i].res[0].fPeak = 0.0f;
        atest[i].res[1].fPeak = 0.0f;
    }
    ShowRateInfo();
    
    return TRUE;
}

int GetCurrDisplay(void)
{
    int n;
    
    n = SendDlgItemMessage(app.hDlg, DISPLAY_LIST, CB_GETCURSEL, 0, 0);
    if (n < 0)
    {
        Msg("Invalid display selected.\n");
        n = 0;
    }
    return n;
}

void FillDisplay(void)
{
    SendDlgItemMessage(app.hDlg, DISPLAY_LIST, CB_RESETCONTENT, 0, 0);
    app.prend->EnumDisplayDrivers(EnumAddDriver, (void *)DISPLAY_LIST);
}

BOOL ChangeDisplay(int iDisplay)
{
    RendId rid;

    rid = (RendId)SendDlgItemMessage(app.hDlg, DISPLAY_LIST, CB_GETITEMDATA,
                                     iDisplay, 0);
    if (!app.prend->SelectDisplayDriver(rid) ||
        !app.prend->DescribeDisplay(&stat.rdd))
    {
        CleanUpAndPostQuit();
        return FALSE;
    }
    
    app.iDisplay = iDisplay;
    SendDlgItemMessage(app.hDlg, DISPLAY_LIST, CB_SETCURSEL,
                       app.iDisplay, 0);

    FillGraphics();
    return ChangeGraphics(0);
}

int GetCurrRenderer(void)
{
    int n;
    
    n = SendDlgItemMessage(app.hDlg, RENDERER_LIST, CB_GETCURSEL, 0, 0);
    if (n < 0)
    {
        Msg("Invalid renderer selected.\n");
        n = 0;
    }
    return n;
}

void FillRenderer(void)
{
    char achName[REND_DRIVER_NAME_LENGTH];
    int i;
    
    SendDlgItemMessage(app.hDlg, RENDERER_LIST, CB_RESETCONTENT, 0, 0);
    for (i = 0; i < RENDERER_COUNT; i++)
    {
        prend[i]->Name(achName);
        SendDlgItemMessage(app.hDlg, RENDERER_LIST, CB_ADDSTRING,
                           0, (LPARAM)achName);
    }
}

BOOL ChangeRenderer(int iRend)
{
    if (app.prend != NULL)
    {
        app.prend->Uninitialize();
        app.prend = NULL;
    }
    
    if (!prend[iRend]->Initialize(app.hDlg))
    {
        CleanUpAndPostQuit();
        return FALSE;
    }
    
    app.iRend = iRend;
    app.prend = prend[iRend];
    SendDlgItemMessage(app.hDlg, RENDERER_LIST, CB_SETCURSEL, app.iRend, 0);
    
    FillDisplay();
    return ChangeDisplay(0);
}

BOOL LoadTextures(void)
{
    int i, t;

    /*
     * If textures are not on or are disabled, set all the handles to zero.
     */
    if (!stat.bTexturesOn || stat.bTexturesDisabled)
    {
        for (i = 0; i < tex.nTextures; i++)
        {
            tex.prtex[i] = NULL;
        }
        return TRUE;
    }
    
    for (i = 0, t = tex.iFirstTexture; i < tex.nTextures; i++, t++)
    {
        if (t >= tex.nTextures)
        {
            t = 0;
        }
        
        tex.prtex[t] =
            app.prwin->NewTexture(tex.achImageFile[i],
                                  stat.bOnlySystemMemory ?
                                  REND_BUFFER_SYSTEM_MEMORY : 0);
        if (tex.prtex[t] == NULL)
        {
            return FALSE;
        }
    }

    return TRUE;
}

void ReleaseTextures(void)
{
    int i;

    for (i = 0; i < tex.nTextures; i++)
    {
        RELEASE(tex.prtex[i]);
    }
}

/*
 * Sets the render mode
 */
BOOL
SetRenderState(void)
{
    RendExecuteBuffer* preb;
    void* pvBuffer;
    void* pvStart;
    BOOL bDithering;
    size_t size;

    bDithering = stat.rdd.nColorBits <= 8 &&
        stat.dcmColorModel == D3DCOLOR_RGB ? TRUE : FALSE;

    size = 0;
    size += sizeof(D3DINSTRUCTION) * 2;
    size += sizeof(D3DSTATE) * 11;
    preb = app.prwin->NewExecuteBuffer(size, stat.uiExeBufFlags);
    if (preb == NULL)
    {
        Msg("NewExecuteBuffer failed in SetRenderState.\n%s",
            app.prend->LastErrorString());
	return FALSE;
    }
    pvBuffer = preb->Lock();
    if (pvBuffer == NULL)
    {
	Msg("Lock failed on execute buffer in SetRenderState.\n%s",
            app.prend->LastErrorString());
        return FALSE;
    }
    memset(pvBuffer, 0, size);

    pvStart = pvBuffer;
    OP_STATE_RENDER(11, pvBuffer);
        STATE_DATA(D3DRENDERSTATE_SHADEMODE, stat.dsmShadeMode, pvBuffer);
	STATE_DATA(D3DRENDERSTATE_TEXTUREMAPBLEND, stat.dtbTextureBlend,
                   pvBuffer);
        STATE_DATA(D3DRENDERSTATE_TEXTUREPERSPECTIVE, stat.bPerspCorrect,
                   pvBuffer);
        STATE_DATA(D3DRENDERSTATE_ZENABLE, stat.bZBufferOn, pvBuffer);
        STATE_DATA(D3DRENDERSTATE_ZWRITEENABLE, stat.bZBufferOn, pvBuffer);
        STATE_DATA(D3DRENDERSTATE_ZFUNC, D3DCMP_LESSEQUAL, pvBuffer);
        STATE_DATA(D3DRENDERSTATE_TEXTUREMAG, stat.dtfTextureFilter, pvBuffer);
        STATE_DATA(D3DRENDERSTATE_TEXTUREMIN, stat.dtfTextureFilter, pvBuffer);
        STATE_DATA(D3DRENDERSTATE_SPECULARENABLE, stat.bSpecular, pvBuffer);
        STATE_DATA(D3DRENDERSTATE_DITHERENABLE, bDithering, pvBuffer);
        STATE_DATA(D3DRENDERSTATE_MONOENABLE,
                   stat.dcmColorModel == D3DCOLOR_MONO ? TRUE : FALSE,
                   pvBuffer);
    OP_EXIT(pvBuffer);

    preb->Unlock();

    if (!app.prwin->BeginScene())
    {
        Msg("BeginScene failed in SetRenderState.\n%s",
            app.prend->LastErrorString());
        return FALSE;
    }
    if (!app.prwin->Execute(preb))
    {
        Msg("Execute failed in SetRenderState.\n%s",
            app.prend->LastErrorString());
        return FALSE;
    }
    if (!app.prwin->EndScene(NULL))
    {
        Msg("EndScene failed in SetRenderState.\n%s",
            app.prend->LastErrorString());
        return FALSE;
    }
    
    preb->Release();

    return TRUE;
}

void RunTest(UINT uiTest)
{
    BOOL bSucc;
    UINT uiBuffers;
    UINT uiViewX, uiViewY;
    Results *pres;
    
    app.bTestInProgress = TRUE;

    uiBuffers = REND_BUFFER_FRONT | REND_BUFFER_BACK;
    if (stat.bZBufferOn)
    {
        uiBuffers |= REND_BUFFER_Z;
    }
    app.prwin = app.prend->NewWindow(8, 8, WIN_WIDTH, WIN_HEIGHT,
                                     uiBuffers);
    if (app.prwin == NULL ||
        !LoadTextures() ||
        !SetRenderState())
    {
        Msg("Unable to create window\n%s",
            app.prend->LastErrorString());
        CleanUpAndPostQuit();
        return;
    }

    // If we've gone fullscreen then adjust the viewport
    // to center the rendering area
    if (!stat.rdd.bPrimary)
    {
        uiViewX = (stat.rdd.uiWidth-WIN_WIDTH)/2;
        uiViewY = (stat.rdd.uiHeight-WIN_HEIGHT)/2;
        if (!app.prwin->SetViewport(uiViewX, uiViewY,
                                    WIN_WIDTH, WIN_HEIGHT))
        {
            Msg("Unable to set viewport\n%s",
                app.prend->LastErrorString());
            CleanUpAndPostQuit();
            return;
        }
    }
    else
    {
        uiViewX = 0;
        uiViewY = 0;
    }
    app.drcViewport.x1 = uiViewX;
    app.drcViewport.y1 = uiViewY;
    app.drcViewport.x2 = uiViewX+WIN_WIDTH;
    app.drcViewport.y2 = uiViewX+WIN_HEIGHT;

    pres = atest[uiTest].bHasOrder ?
        &atest[uiTest].res[stat.uiOverdrawOrder] :
        &atest[uiTest].res[0];
            
    bSucc = atest[uiTest].pfnRun(uiTest, &pres->fLast);

    ReleaseTextures();
    RELEASE(app.prwin);
    if (app.bFullscreen)
    {
        app.prend->RestoreDesktop();
    }

    app.bTestInProgress = FALSE;
            
    if (!bSucc)
    {
        Msg("A test has failed.  Results are invalid.\n");
    }
            
    if (bSucc && !app.bAbortTest)
    {
        if (pres->fLast > pres->fPeak)
        {
            pres->fPeak = pres->fLast;
        }
    }
    
    ShowRateInfo();
}

void FillTests(void)
{
    int i;
    HWND hwndLb;

    hwndLb = GetDlgItem(app.hDlg, TEST_LISTBOX);
    SendMessage(hwndLb, LB_RESETCONTENT, 0, 0);
    for (i = 0; i < TEST_COUNT; i++)
    {
        SendMessage(hwndLb, LB_ADDSTRING, 0, (LPARAM)atest[i].pszName);
    }
    SendMessage(hwndLb, LB_SETCURSEL, app.uiCurrentTest, 0);
}

/*
 * Control panel message handler
 */
BOOL FAR PASCAL PanelHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (app.iRend == RENDERER_D3D && app.bTestInProgress)
    {
        // This hack seems necessary to get the palette correct
        // during the test run
        // It screws up OpenGL, so only do it for D3D
        return 1L;
    }
    
    switch (msg)
    {
    case WM_INITDIALOG:
        app.hDlg = hDlg;

        FillTests();
        RefreshButtons();
        ShowRateInfo();

        FillRenderer();
        if (!ChangeRenderer(app.iRend))
        {
            return FALSE;
        }
        
        return TRUE;

    case WM_CLOSE:
        if (app.bQuit)
            break;
        CleanUpAndPostQuit();
        EndDialog(hDlg, TRUE);
        break;
        
    case WM_COMMAND:
        if (app.bQuit ||
            app.bTestInProgress)
        {
            break;
        }

        SetStateFromDialog();
        switch(LOWORD(wParam))
        {
        case ALL_TESTS_BUTTON:
            UINT uiCurrentOrder;
            int i;

            uiCurrentOrder = stat.uiOverdrawOrder;
            stat.uiOverdrawOrder = FRONT_TO_BACK;
            for (i = 0; i < TEST_COUNT; i++)
            {
                RunTest(i);
            }
            stat.uiOverdrawOrder = BACK_TO_FRONT;
            for (i = 0; i < TEST_COUNT; i++)
            {
                if (atest[i].bHasOrder)
                {
                    RunTest(i);
                }
            }
            stat.uiOverdrawOrder = uiCurrentOrder;
            ShowRateInfo();
            break;
        case TEST_LISTBOX:
            switch(GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_SELCHANGE:
                app.uiCurrentTest =
                    (UINT)SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0);
                ShowRateInfo();
                break;
            case LBN_DBLCLK:
                RunTest(app.uiCurrentTest);
                break;
            }
            break;
        case RUN_TEST_BUTTON:
            RunTest(app.uiCurrentTest);
            break;

        case FRONT_TO_BACK_RADIO:
        case BACK_TO_FRONT_RADIO:
            ShowRateInfo();
            break;
            
        case RENDERER_LIST:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
            {
                ChangeRenderer(GetCurrRenderer());
            }
            break;
            
        case DISPLAY_LIST:
            if( GET_WM_COMMAND_CMD( wParam, lParam ) == CBN_SELCHANGE ) {
                ChangeDisplay(GetCurrDisplay());
            }
            break;
            
        case GRAPHICS_LIST:
            if( GET_WM_COMMAND_CMD( wParam, lParam ) == CBN_SELCHANGE ) {
                ChangeGraphics(GetCurrGraphics());
            }
            break;
            
        case EXIT_BUTTON:
            CleanUpAndPostQuit();
            EndDialog(hDlg, TRUE);
            break;
            
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

/*
 * AppInit
 * Initialize this instance.
 */
static BOOL
AppInit(HINSTANCE hInstance, int nCmdShow)
{
    /* Save instance handle for DialogBoxes */
    app.hInstApp = hInstance;
    return TRUE;
}

/*
 * ProcessCommandLine
 * Search command line for options. Valid options include:
 *      -systemmemory   Force all surfaces to be created in system memory.
 *      -d3d            Default renderer is Direct3D
 *      -gl             Default renderer is OpenGL
 *      -wait           Wait for input between test frames
 *      -testtm<secs>   Timing interval for tests
 *      -starttm<secs>  Untimed startup interval for tests
 */
BOOL ProcessCommandLine(LPSTR lpCmdLine) {
    LPSTR option;
    int i;

    option = strtok(lpCmdLine, " -");
    while(option != NULL )   {
        if (!strcmp(option, "systemmemory")) {
            stat.bOnlySystemMemory = TRUE;
        } else if (!strcmp(option, "d3d")) {
            app.iRend = RENDERER_D3D;
        } else if (!strcmp(option, "gl")) {
            app.iRend = RENDERER_GL;
	} else if (!strcmp(option, "glpaltex")) {
	    gl_bUsePalettedTexture = TRUE;
        } else if (!strcmp(option, "wait")) {
            app.bWaitForInput = TRUE;
        } else if (!strncmp(option, "testtm", 6)) {
            sscanf(option+6, "%d", &i);
            app.fTestInterval = (float)i;
        } else if (!strncmp(option, "starttm", 7)) {
            sscanf(option+7, "%d", &i);
            app.fStartupInterval = (float)i;
        } else {
            Msg("Invalid command line options.");
            return FALSE;
        }
        option = strtok(NULL, " -");
    }

    return TRUE;
}

/*
 * InitGlobals
 * Called once at program initialization to initialize global variables.
 */
void
InitGlobals(void)
{
    int i;

    // Set renderer pointers
    prend[RENDERER_D3D] = GetD3dRenderer();
    prend[RENDERER_GL] = GetGlRenderer();

    /*
     * Windows specific and application screen mode globals
     */
    app.hDlg = 0;
    app.bTestInProgress = FALSE;
    app.bQuit = FALSE;
    app.fStartupInterval = DEF_STARTUP_INTERVAL;
    app.fTestInterval = DEF_TEST_INTERVAL;
    app.bWaitForInput = FALSE;
    app.iRend = RENDERER_GL;
    app.iDisplay = 0;
    app.iGraphics = 0;
    app.prend = NULL;
    app.uiCurrentTest = 0;

    /*
     * Parameters and status flags
     */
    stat.bStopRendering = FALSE;
    stat.bTexturesOn = TRUE;
    stat.bTexturesDisabled = FALSE;
    stat.bZBufferOn = TRUE;
    stat.bClearsOn = TRUE;
    stat.bPerspCorrect = TRUE;
    stat.bSpecular = FALSE;
    stat.bUpdates = TRUE;
    stat.uiOverdrawOrder = FRONT_TO_BACK;
    stat.dsmShadeMode = D3DSHADE_FLAT;
    stat.dtfTextureFilter = D3DFILTER_NEAREST;
    stat.dtbTextureBlend = D3DTBLEND_MODULATE;
    stat.bOnlySystemMemory = FALSE;
    stat.uiExeBufFlags = REND_BUFFER_SYSTEM_MEMORY;
    
    /*
     * Textures
     */
    tex.nTextures = 2;
    lstrcpy(tex.achImageFile[0], "checker.ppm\0");
    lstrcpy(tex.achImageFile[1], "tex2.ppm\0");
    tex.iFirstTexture = 0;
}

/*
 * WinMain - initialization, message loop
 */
int PASCAL
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
	int nCmdShow)
{
    InitGlobals();
    hPrevInstance = hPrevInstance;
    if(!ProcessCommandLine(lpCmdLine))
        return FALSE;
    if(!AppInit(hInstance, nCmdShow))
    	return FALSE;
    DialogBox(app.hInstApp, "ControlPanel", NULL, PanelHandler);
    return 0;
}

/*************************************************************************
  Object release and termination functions
 *************************************************************************/

/*
 * CleanUpAndPostQuit
 * Release everything and posts a quit message.  Used for program termination.
 */
void
CleanUpAndPostQuit(void)
{
    ReleasePathList();
    app.bTestInProgress = FALSE;
    if (app.prend != NULL)
    {
        if (app.prwin != NULL)
        {
            RELEASE(app.prwin);
        }
        app.prend->Uninitialize();
    }
    PostQuitMessage( 0 );
    app.bQuit = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\glmatrx.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "glrend.h"
#include "util.h"

GlMatrix::GlMatrix(GlWindow* pgwin)
{
    _pgwin = pgwin;
    _dm = dmIdentity;
}

void GlMatrix::Release(void)
{
    delete this;
}
    
D3DMATRIXHANDLE GlMatrix::Handle(void)
{
    return (D3DMATRIXHANDLE)&_dm;
}

void GlMatrix::Get(D3DMATRIX* pdm)
{
    *pdm = _dm;
}

void GlMatrix::Set(D3DMATRIX* pdm)
{
    _dm = *pdm;
    _pgwin->MatrixChanged((float *)&_dm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\globals.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation. All Rights Reserved.
 *
 *  File: globals.h
 *
 ***************************************************************************/
#ifndef __GLOBALS_H__
#define __GLOBALS_H__

#include "rend.h"

#define PI 3.14159265359

#define WIN_WIDTH  400
#define WIN_HEIGHT 400

#define MAX_TEXTURES 8

#define FRONT_TO_BACK   0
#define BACK_TO_FRONT   1
#define NO_SORT         2
#define ORDER_COUNT     2

/*
 * Tests
 */
#define FILL_RATE_TEST          0
#define INTERSECTION_TEST       1
#define SIMPLE_FILL_TEST        2
#define TRANSPARENCY_TEST       3
#define THROUGHPUT_TEST         4
#define TEST_COUNT              5

typedef struct tagAppInfo {
    HWND        hDlg;
    HINSTANCE   hInstApp;
    BOOL	bFullscreen;
    BOOL        bTestInProgress;
    BOOL	bQuit;
    BOOL	bAbortTest;
    float       fStartupInterval;
    float       fTestInterval;
    BOOL        bWaitForInput;
    UINT        uiCurrentTest;
    int         iRend;
    int         iDisplay;
    int         iGraphics;
    Renderer    *prend;
    RendWindow  *prwin;
    D3DRECT     drcViewport;
} AppInfo;

extern AppInfo app;

/*
 * Parameters and status flags
 */
typedef struct tagStatInfo {
    BOOL             bStopRendering;
    BOOL             bTexturesDisabled;
    BOOL             bTexturesOn;
    BOOL             bZBufferOn;
    BOOL             bClearsOn;
    BOOL             bPerspCorrect;
    BOOL             bSpecular;
    BOOL             bUpdates;
    UINT             uiOverdrawOrder;
    D3DSHADEMODE     dsmShadeMode;
    D3DTEXTUREFILTER dtfTextureFilter;
    BOOL             bOnlySystemMemory;
    D3DTEXTUREBLEND  dtbTextureBlend;
    D3DCOLORMODEL    dcmColorModel;
    UINT             uiExeBufFlags;
    RendDisplayDescription rdd;
    RendGraphicsDescription rgd;
} StatInfo;

extern StatInfo stat;

/*
 * Textures
 */
typedef struct tagTexInfo {
    int          nTextures;
    char         achImageFile[MAX_TEXTURES][20];
    RendTexture* prtex[MAX_TEXTURES];
    int          iFirstTexture;
} TexInfo;

extern TexInfo tex;

/*
 * Renderer specific setup
 */
extern BOOL gl_bUsePalettedTexture;

#endif // __GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\gllight.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "glrend.h"
#include "util.h"

GlLight::GlLight(int iType, GLenum eLight)
{
    float fv4[4];
    
    _iType = iType;
    _eLight = eLight;
    glEnable(_eLight);
    
    fv4[0] = 1.0f;
    fv4[1] = 1.0f;
    fv4[2] = 1.0f;
    fv4[3] = 1.0f;
    glLightfv(_eLight, GL_AMBIENT, fv4);
    glLightfv(_eLight, GL_DIFFUSE, fv4);
    glLightfv(_eLight, GL_SPECULAR, fv4);
}
    
void GlLight::Release(void)
{
    delete this;
}

void GlLight::SetColor(D3DCOLORVALUE* pdcol)
{
    glLightfv(_eLight, GL_AMBIENT, (float *)pdcol);
    glLightfv(_eLight, GL_DIFFUSE, (float *)pdcol);
}

void GlLight::SetVector(D3DVECTOR* pdvec)
{
    float fv4[4];
    
    fv4[0] = pdvec->x;
    fv4[1] = pdvec->y;
    switch(_iType)
    {
    case REND_LIGHT_DIRECTIONAL:
        // Account for RH vs. LH
        fv4[2] = -pdvec->z;
        fv4[3] = 0.0f;
        break;
    case REND_LIGHT_POINT:
        // ATTENTION - Shouldn't this need tweaking also?  It
        // doesn't work if a tweak is added
        fv4[2] = pdvec->z;
        fv4[3] = 1.0f;
        break;
    }
    // ATTENTION - D3D gives light positions in world coordinates
    // Should the modelview matrix be set to identity?
    glLightfv(_eLight, GL_POSITION, fv4);
}

void GlLight::SetAttenuation(float fConstant, float fLinear,
                             float fQuadratic)
{
    glLightf(_eLight, GL_CONSTANT_ATTENUATION, fConstant);
    glLightf(_eLight, GL_LINEAR_ATTENUATION, fLinear);
    glLightf(_eLight, GL_QUADRATIC_ATTENUATION, fQuadratic);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\glrend.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "glrend.h"
#include "util.h"

#ifdef GL_WIN_swap_hint
PFNGLADDSWAPHINTRECTWINPROC glAddSwapHintRectWIN;
#endif

GlRenderer::GlRenderer(void)
{
    _hdcInit = NULL;
    _hrcInit = NULL;
}

void GlRenderer::Name(char* psz)
{
    strcpy(psz, "OpenGL");
}

char* GlRenderer::LastErrorString(void)
{
    return "OpenGL Error";
}
    
BOOL GlRenderer::Initialize(HWND hwndParent)
{
    PIXELFORMATDESCRIPTOR pfd;
    int iFmt;

    _hwndParent = hwndParent;
    
    // Create a context for the parent so that we have a context around
    // to make OpenGL calls on even when a rendering window isn't up
    _hdcInit = GetDC(hwndParent);
    if (_hdcInit == NULL)
    {
        Msg("GetDC failed, %d\n", GetLastError());
        return FALSE;
    }

    memset(&pfd, 0, sizeof(pfd));
    pfd.nSize = sizeof(pfd);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = GetDeviceCaps(_hdcInit, BITSPIXEL)*
        GetDeviceCaps(_hdcInit, PLANES);
    pfd.iLayerType = PFD_MAIN_PLANE;
    iFmt = ChoosePixelFormat(_hdcInit, &pfd);
    if (iFmt == 0)
    {
        Msg("ChoosePixelFormat failed, %d\n", GetLastError());
        return FALSE;
    }
    if (!SetPixelFormat(_hdcInit, iFmt, &pfd))
    {
        Msg("SetPixelFormat failed, %d\n", GetLastError());
        return FALSE;
    }
    DescribePixelFormat(_hdcInit, iFmt, sizeof(_pfd), &_pfd);
    
    _hrcInit = wglCreateContext(_hdcInit);
    if (_hrcInit == NULL)
    {
        Msg("wglCreateContext failed, %d\n", GetLastError());
        return FALSE;
    }

    wglMakeCurrent(_hdcInit, _hrcInit);

#ifdef GL_WIN_swap_hint
    glAddSwapHintRectWIN =
        (PFNGLADDSWAPHINTRECTWINPROC)wglGetProcAddress("glAddSwapHintRectWIN");
#endif
    
    wglMakeCurrent(_hdcInit, NULL);
    
    return TRUE;
}

void GlRenderer::Uninitialize(void)
{
    if (_hrcInit != NULL)
    {
        wglDeleteContext(_hrcInit);
    }
    if (_hdcInit != NULL)
    {
        ReleaseDC(_hwndParent, _hdcInit);
    }
}

BOOL GlRenderer::EnumDisplayDrivers(RendEnumDriversFn pfn,
                                    void* pvArg)
{
    RendDriverDescription rdd;

    rdd.rid = (RendId)1;
    strcpy(rdd.achName, "GDI");
    return pfn(&rdd, pvArg);
}

BOOL GlRenderer::EnumGraphicsDrivers(RendEnumDriversFn pfn,
                                     void* pvArg)
{
    RendDriverDescription rdd;
    BOOL bSucc;
    HGLRC hrcOld;
    HDC hdcOld;

    hrcOld = wglGetCurrentContext();
    hdcOld = wglGetCurrentDC();
    wglMakeCurrent(_hdcInit, _hrcInit);
    
    rdd.rid = (RendId)1;
    strcpy(rdd.achName, (char *)glGetString(GL_RENDERER));
    strcat(rdd.achName, " ");
    strcat(rdd.achName, (char *)glGetString(GL_VERSION));
    bSucc = pfn(&rdd, pvArg);

    wglMakeCurrent(hdcOld, hrcOld);

    return bSucc;
}
    
BOOL GlRenderer::SelectDisplayDriver(RendId rid)
{
    // Nothing to do
    return TRUE;
}

BOOL GlRenderer::SelectGraphicsDriver(RendId rid)
{
    // Nothing to do
    return TRUE;
}

BOOL GlRenderer::DescribeDisplay(RendDisplayDescription* prdd)
{
    HDC hdcScreen;
    RECT rcClient;
    
    prdd->bPrimary = TRUE;
    hdcScreen = GetDC(NULL);
    prdd->nColorBits = GetDeviceCaps(hdcScreen, BITSPIXEL)*
        GetDeviceCaps(hdcScreen, PLANES);
    prdd->uiWidth = GetDeviceCaps(hdcScreen, HORZRES);
    prdd->uiHeight = GetDeviceCaps(hdcScreen, VERTRES);
    return TRUE;
}

BOOL GlRenderer::DescribeGraphics(RendGraphicsDescription* prgd)
{
    prgd->uiColorTypes = REND_COLOR_RGBA;
    prgd->nZBits = _pfd.cDepthBits;
    prgd->uiExeBufFlags = REND_BUFFER_SYSTEM_MEMORY;
    // ATTENTION - No easy way to determine this
    prgd->bHardwareAssisted = FALSE;
    prgd->bPerspectiveCorrect = TRUE;
    prgd->bSpecularLighting = TRUE;
    prgd->bCopyTextureBlend = TRUE;
    return TRUE;
}
    
BOOL GlRenderer::FlipToDesktop(void)
{
    // Nothing to do
    return TRUE;
}

BOOL GlRenderer::RestoreDesktop(void)
{
    // Nothing to do
    return TRUE;
}

RendWindow* GlRenderer::NewWindow(int x, int y,
                                  UINT uiWidth, UINT uiHeight,
                                  UINT uiBuffers)
{
    GlWindow* pgwin;

    pgwin = new GlWindow;
    if (pgwin == NULL)
    {
        return NULL;
    }

    if (!pgwin->Initialize(x, y, uiWidth, uiHeight, uiBuffers))
    {
        delete pgwin;
        return NULL;
    }

    return pgwin;
}

static GlRenderer glrend;

Renderer* GetGlRenderer(void)
{
    return &glrend;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\gltk.h ===
#ifndef __GLTK_H__
#define __GLTK_H__

struct gltkWindow
{
    SHORT cbSize;
    SHORT wPad;
    HWND hwnd;
    HDC hdc;
    HPALETTE hpal;
    UINT x, y, width, height;
};

HWND gltkCreateWindow(HWND hwndParent, char *title,
                      int x, int y, UINT uiWidth, UINT uiHeight,
                      gltkWindow *gltkw);
HPALETTE
gltkCreateRGBPalette( gltkWindow *gltkw );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\glrend.h ===
#ifndef __GLREND_H__
#define __GLREND_H__

#include "rend.h"
#include "loadppm.h"
#include "gltk.h"

// Fake value for marking processed TLVERTEX data
#define PROCESSED_TLVERTEX 0x80000000

// Fake opcode for marking processed triangle lists
#define PROCESSED_TRIANGLE 0xff

class GlExecuteBuffer : public RendExecuteBuffer
{
public:
    GlExecuteBuffer(void);
    BOOL Initialize(UINT cbSize, UINT uiFlags);
    ~GlExecuteBuffer(void);

    virtual void  Release(void);
    
    virtual void* Lock(void);
    virtual void  Unlock(void);
    
    virtual void  SetData(UINT nVertices, UINT cbStart, UINT cbSize);

    virtual BOOL  Process(void);

    BYTE*  _pbData;
    UINT   _nVertices;
    UINT   _cbStart;
    UINT   _cbSize;
    GLuint _dlist;
};

class GlLight : public RendLight
{
public:
    GlLight(int iType, GLenum eLight);
    
    virtual void Release(void);

    virtual void SetColor(D3DCOLORVALUE* pdcol);
    virtual void SetVector(D3DVECTOR* pdvec);
    virtual void SetAttenuation(float fConstant, float fLinear,
                                float fQuadratic);

    int _iType;
    GLenum _eLight;
};

class GlTexture : public RendTexture
{
public:
    GlTexture(void);
    BOOL Initialize(char* pszFile);
    ~GlTexture(void);
    
    virtual void Release(void);
    
    virtual D3DTEXTUREHANDLE Handle(void);

    GLuint _uiTexObj;
    Image _im;
};

class GlWindow;

class GlMatrix : public RendMatrix
{
public:
    GlMatrix(GlWindow* pgwin);

    virtual void Release(void);
    
    virtual D3DMATRIXHANDLE Handle(void);

    virtual void Get(D3DMATRIX* pdm);
    virtual void Set(D3DMATRIX* pdm);

    GlWindow* _pgwin;
    D3DMATRIX _dm;
};

class GlMaterial : public RendMaterial
{
public:
    GlMaterial(void);
    
    virtual void Release(void);

    virtual D3DMATERIALHANDLE Handle(void);

    virtual void SetDiffuse(D3DCOLORVALUE* pdcol);
    virtual void SetSpecular(D3DCOLORVALUE* pdcol, float fPower);
    virtual void SetTexture(RendTexture* prtex);

    void Apply(void);
    
    UINT _uiFlags;
    float _afDiffuse[4];
    float _afSpecular[4];
    float _fPower;
};

// Default texture modes
#define DEF_TEX_MIN     GL_NEAREST
#define DEF_TEX_MAG     GL_NEAREST
#define DEF_TEX_MODE    GL_MODULATE

class GlWindow : public RendWindow
{
public:
    GlWindow(void);
    BOOL Initialize(int x, int y, UINT uiWidth, UINT uiHeight, UINT uiBuffers);
    ~GlWindow(void);
    
    virtual void Release(void);
    
    virtual BOOL SetViewport(int x, int y, UINT uiWidth, UINT uiHeight);

    virtual RendLight*         NewLight(int iType);
    virtual RendTexture*       NewTexture(char* pszFile, UINT uiFlags);
    virtual RendExecuteBuffer* NewExecuteBuffer(UINT cbSize, UINT uiFlags);
    virtual RendMatrix*        NewMatrix(void);
    virtual RendMaterial*      NewMaterial(UINT nColorEntries);
    
    virtual BOOL BeginScene(void);
    virtual BOOL Execute(RendExecuteBuffer* preb);
    virtual BOOL ExecuteClipped(RendExecuteBuffer* preb);
    virtual BOOL EndScene(D3DRECT* pdrcBound);

    virtual BOOL Clear(UINT uiBuffers, D3DRECT* pdrc);
    virtual BOOL Flip(void);
    virtual BOOL CopyForward(D3DRECT* pdrc);

    virtual HWND Handle(void);

    BOOL DoExecute(RendExecuteBuffer* preb);

    void ChangeWorld(float *pfMatrix);
    void ChangeView(float *pfMatrix);
    void ChangeProjection(float *pfMatrix);
    void MatrixChanged(float *pfMatrix);
    
    int _iLight;
    D3DRECT _drcBound;
    D3DMATRIX _dmView;
    D3DMATRIX _dmProjection;
    float *_pfWorld;
    float *_pfView;
    float *_pfProjection;
    GLenum _eTexMin;
    GLenum _eTexMag;
    GLenum _eSrcBlend;
    GLenum _eDstBlend;
    gltkWindow _gltkw;
    HGLRC _hrc;
};

class GlRenderer : public Renderer
{
public:
    GlRenderer(void);
        
    virtual void Name(char* psz);
    
    virtual char* LastErrorString(void);
    
    virtual BOOL Initialize(HWND hwndParent);
    virtual void Uninitialize(void);

    virtual BOOL EnumDisplayDrivers(RendEnumDriversFn pfn,
                                    void* pvArg);
    virtual BOOL EnumGraphicsDrivers(RendEnumDriversFn pfn,
                                     void* pvArg);
    
    virtual BOOL SelectDisplayDriver(RendId rid);
    virtual BOOL SelectGraphicsDriver(RendId rid);
    
    virtual BOOL DescribeDisplay(RendDisplayDescription* prdd);
    virtual BOOL DescribeGraphics(RendGraphicsDescription* prgd);
    
    virtual BOOL FlipToDesktop(void);
    virtual BOOL RestoreDesktop(void);
    
    virtual RendWindow* NewWindow(int x, int y,
                                  UINT uiWidth, UINT uiHeight,
                                  UINT uiBuffers);

    HWND _hwndParent;
    HDC _hdcInit;
    HGLRC _hrcInit;
    PIXELFORMATDESCRIPTOR _pfd;
};

#ifdef GL_WIN_swap_hint
extern PFNGLADDSWAPHINTRECTWINPROC glAddSwapHintRectWIN;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\gltex.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "glrend.h"
#include "util.h"

BOOL gl_bUsePalettedTexture = FALSE;

GlTexture::GlTexture(void)
{
    _uiTexObj = 0;
    _im.pvImage = NULL;
}

BOOL GlTexture::Initialize(char* pszFile)
{
    ImageFormat ifmt;

    if (gl_bUsePalettedTexture)
    {
	ifmt.nColorBits = 8;
	ifmt.bQuantize = TRUE;
    }
    else
    {
	ifmt.nColorBits = 24;
	ifmt.bQuantize = FALSE;
	ifmt.iRedBits = 8;
	ifmt.iRedShift = 0;
	ifmt.iGreenBits = 8;
	ifmt.iGreenShift = 8;
	ifmt.iBlueBits = 8;
	ifmt.iBlueShift = 16;
    }

    if (!LoadPPM(pszFile, &ifmt, &_im))
    {
        return FALSE;
    }

    glGenTextures(1, &_uiTexObj);
    glBindTexture(GL_TEXTURE_2D, _uiTexObj);
    // ATTENTION - polytest wants clamping on T but that's pig slow
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, DEF_TEX_MAG);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, DEF_TEX_MIN);
    // ATTENTION - We have to use modulate for correct visual results
    // but this is bad for performance
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, DEF_TEX_MODE);
    if (gl_bUsePalettedTexture)
    {
	PFNGLCOLORTABLEEXTPROC pfnColorTableEXT;

	pfnColorTableEXT = (PFNGLCOLORTABLEEXTPROC)
	    wglGetProcAddress("glColorTableEXT");
	if (pfnColorTableEXT != NULL)
	{
	    glTexImage2D(GL_TEXTURE_2D, 0, GL_COLOR_INDEX8_EXT,
			 _im.uiWidth, _im.uiHeight, 0,
			 GL_COLOR_INDEX, GL_UNSIGNED_BYTE, _im.pvImage);
	    pfnColorTableEXT(GL_TEXTURE_2D, GL_RGB, 256,
			     GL_BGRA_EXT, GL_UNSIGNED_BYTE, _im.dcolPalette);
	}
	else
	{
	    dpf("OpenGL unable to use paletted texture\n");    
	    glTexImage2D(GL_TEXTURE_2D, 0, 3, _im.uiWidth, _im.uiHeight, 0,
			 GL_RGB, GL_UNSIGNED_BYTE, _im.pvImage);
	}
    }
    else
    {
	glTexImage2D(GL_TEXTURE_2D, 0, 3, _im.uiWidth, _im.uiHeight, 0,
		     GL_RGB, GL_UNSIGNED_BYTE, _im.pvImage);
    }

    // Keep the image data around in case we want to support
    // non-texture-object rendering
    
    return TRUE;
}

GlTexture::~GlTexture(void)
{
    if (_uiTexObj != 0)
    {
        glDeleteTextures(1, &_uiTexObj);
    }
    delete [] _im.pvImage;
}

void GlTexture::Release(void)
{
    delete this;
}

D3DTEXTUREHANDLE GlTexture::Handle(void)
{
    return (D3DTEXTUREHANDLE)_uiTexObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\loadppm.h ===
#ifndef __LOADPPM_H__
#define __LOADPPM_H__

/*
 * ReleasePathList
 * Releases memory allocated when searching for files.
 */
void ReleasePathList(void);

typedef struct _Image
{
    UINT uiWidth, uiHeight;
    void *pvImage;
    UINT nColors;
    D3DCOLOR dcolPalette[256];
} Image;

typedef struct _ImageFormat
{
    int nColorBits;
    BOOL bQuantize;
    int iRedShift, iRedBits;
    int iGreenShift, iGreenBits;
    int iBlueShift, iBlueBits;
} ImageFormat;

BOOL LoadPPM(LPCSTR pszFile, ImageFormat *pifDst, Image *pim);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\gltk.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "gltk.h"

static char *lpszClassName = "gltkLibWClass";
static ATOM aWndClass = 0;

static long tkWndProc(HWND hWnd, UINT message, DWORD wParam, LONG lParam);
static unsigned char ComponentFromIndex(int i, int nbits, int shift );
static PALETTEENTRY *FillRgbPaletteEntries( PIXELFORMATDESCRIPTOR *Pfd, PALETTEENTRY *Entries, UINT Count );
static void CleanUp( gltkWindow *gltkw );
static long RealizePaletteNow( HDC Dc, HPALETTE Palette, BOOL bForceBackground );
static int PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd );
static void *AllocateMemory( size_t Size );
static void *AllocateZeroedMemory( size_t Size );
static void FreeMemory( void *Chunk );

HWND gltkCreateWindow(HWND hwndParent, char *title,
                      int x, int y, UINT uiWidth, UINT uiHeight,
                      gltkWindow *gltkw)
{
    WNDCLASS wndclass;
    RECT     WinRect;
    HINSTANCE hInstance;
    HWND hwnd;

    memset(gltkw, 0, sizeof(*gltkw));
    gltkw->cbSize = sizeof(*gltkw);
    
    hInstance = GetModuleHandle(NULL);

    if (aWndClass == 0)
    {
        // Must not define CS_PARENTDC style.
        wndclass.style         = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = (WNDPROC)tkWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = 0;
        wndclass.hInstance     = hInstance;
        wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = (LPCSTR)lpszClassName;
        aWndClass = RegisterClass(&wndclass);

        /*
         *  If the window failed to register, then there's no
         *  need to continue further.
         */
        
        if(0 == aWndClass)
        {
            return NULL;
        }
    }

    /*
     *  Make window large enough to hold a client area as large as windInfo
     */

    WinRect.left   = x;
    WinRect.right  = x+uiWidth;
    WinRect.top    = y;
    WinRect.bottom = y+uiHeight;

    AdjustWindowRect(&WinRect, WS_OVERLAPPEDWINDOW, FALSE);

    /*
     *  Must use WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles.
     */

    gltkw->x = x;
    gltkw->y = y;
    gltkw->width = WinRect.right-WinRect.left;
    gltkw->height = WinRect.bottom-WinRect.top;
    
    hwnd = CreateWindow(
            lpszClassName,
            title,
            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
            gltkw->x, gltkw->y, gltkw->width, gltkw->height,
            hwndParent,
            NULL,
            hInstance,
            gltkw);

    if ( NULL != hwnd )
    {
        ShowWindow(hwnd, SW_SHOWDEFAULT);
        UpdateWindow(hwnd);
    }

    return hwnd;
}

static long
tkWndProc(HWND hWnd, UINT message, DWORD wParam, LONG lParam)
{
    int key;
    PAINTSTRUCT paint;
    HDC hdc;
    PIXELFORMATDESCRIPTOR pfd;
    gltkWindow *gltkw = (gltkWindow *)GetWindowLong(hWnd, GWL_USERDATA);

    switch (message) {

    case WM_CREATE:
        gltkw = (gltkWindow *)((CREATESTRUCT *)lParam)->lpCreateParams;
        SetWindowLong(hWnd, GWL_USERDATA, (LONG)gltkw);
        gltkw->hwnd = hWnd;
        gltkw->hdc = GetDC(hWnd);
        break;
        
    case WM_USER:
        RealizePaletteNow( gltkw->hdc, gltkw->hpal, FALSE );
        return(0);

    case WM_SIZE:
        gltkw->width  = LOWORD(lParam);
        gltkw->height = HIWORD(lParam);
        return (0);

    case WM_MOVE:
        gltkw->x = LOWORD(lParam);
        gltkw->y = HIWORD(lParam);
        return (0);

    case WM_PAINT:
        /*
         *  Validate the region even if there are no DisplayFunc.
         *  Otherwise, USER will not stop sending WM_PAINT messages.
         */

        hdc = BeginPaint(hWnd, &paint);
        EndPaint(hWnd, &paint);
        return (0);

    case WM_QUERYNEWPALETTE:

    // We don't actually realize the palette here (we do it at WM_ACTIVATE
    // time), but we need the system to think that we have so that a
    // WM_PALETTECHANGED message is generated.

        return (1);

    case WM_PALETTECHANGED:

    // Respond to this message only if the window that changed the palette
    // is not this app's window.

    // We are not the foreground window, so realize palette in the
    // background.  We cannot call RealizePaletteNow to do this because
    // we should not do any of the tkUseStaticColors processing while
    // in background.

        if ( hWnd != (HWND) wParam )
        {
            if ( NULL != gltkw->hpal &&
                 NULL != SelectPalette( gltkw->hdc, gltkw->hpal, TRUE ) )
                RealizePalette( gltkw->hdc );
        }

        return (0);

    case WM_SYSCOLORCHANGE:

    // If the system colors have changed and we have a palette
    // for an RGB surface then we need to recompute the static
    // color mapping because they might have been changed in
    // the process of changing the system colors.

        if (gltkw->hdc != NULL && gltkw->hpal != NULL &&
            PixelFormatDescriptorFromDc(gltkw->hdc, &pfd) &&
            (pfd.dwFlags & PFD_NEED_PALETTE) &&
            pfd.iPixelType == PFD_TYPE_RGBA)
        {
            HPALETTE hpalTmp;

            hpalTmp = gltkw->hpal;
            gltkw->hpal = NULL;
            if (gltkCreateRGBPalette(gltkw) != NULL)
            {
                DeleteObject(hpalTmp);
            }
            else
            {
                gltkw->hpal = hpalTmp;
            }
        }
        break;
            
    case WM_ACTIVATE:

    // If the window is going inactive, the palette must be realized to
    // the background.  Cannot depend on WM_PALETTECHANGED to be sent since
    // the window that comes to the foreground may or may not be palette
    // managed.

        if ( LOWORD(wParam) == WA_INACTIVE )
        {
            if ( NULL != gltkw->hpal )
            {
            // Realize as a background palette.  Need to call
            // RealizePaletteNow rather than RealizePalette directly to
            // because it may be necessary to release usage of the static
            // system colors.

                RealizePaletteNow( gltkw->hdc, gltkw->hpal, TRUE );
            }
        }

    // Window is going active.  If we are not iconized, realize palette
    // to the foreground.  If management of the system static colors is
    // needed, RealizePaletteNow will take care of it.

        else if ( HIWORD(wParam) == 0 )
        {
            if ( NULL != gltkw->hpal )
            {
                RealizePaletteNow( gltkw->hdc, gltkw->hpal, FALSE );

                return (1);
            }
        }

    // Allow DefWindowProc() to finish the default processing (which includes
    // changing the keyboard focus).

        break;

    case WM_CLOSE:
        DestroyWindow(hWnd);
        return(0);

    case WM_DESTROY:
        CleanUp(gltkw);
        return 0;
    }
    return(DefWindowProc( hWnd, message, wParam, lParam));
}

// Default palette entry flags
#define PALETTE_FLAGS PC_NOCOLLAPSE

// Gamma correction factor * 10
#define GAMMA_CORRECTION 14

// Maximum color distance with 8-bit components
#define MAX_COL_DIST (3*256*256L)

// Number of static colors
#define STATIC_COLORS 20

// Flags used when matching colors
#define EXACT_MATCH 1
#define COLOR_USED 1

// Conversion tables for n bits to eight bits

#if GAMMA_CORRECTION == 10
// These tables are corrected for a gamma of 1.0
static unsigned char abThreeToEight[8] =
{
    0, 0111 >> 1, 0222 >> 1, 0333 >> 1, 0444 >> 1, 0555 >> 1, 0666 >> 1, 0377
};
static unsigned char abTwoToEight[4] =
{
    0, 0x55, 0xaa, 0xff
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#else
// These tables are corrected for a gamma of 1.4
static unsigned char abThreeToEight[8] =
{
    0, 63, 104, 139, 171, 200, 229, 255
};
static unsigned char abTwoToEight[4] =
{
    0, 116, 191, 255
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#endif

// Table which indicates which colors in a 3-3-2 palette should be
// replaced with the system default colors
#if GAMMA_CORRECTION == 10
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 4, 32, 36, 128, 132, 160, 173, 181, 245,
    247, 164, 156, 7, 56, 63, 192, 199, 248, 255
};
#else
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 3, 24, 27, 64, 67, 88, 173, 181, 236,
    247, 164, 91, 7, 56, 63, 192, 199, 248, 255
};
#endif

static unsigned char
ComponentFromIndex(int i, int nbits, int shift)
{
    unsigned char val;

    val = i >> shift;
    switch (nbits)
    {
    case 1:
        return abOneToEight[val & 1];

    case 2:
        return abTwoToEight[val & 3];

    case 3:
        return abThreeToEight[val & 7];
    }
    
    return 0;
}

// System default colors
static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },

    { 192, 220, 192,  0 },
    { 166, 202, 240,  0 },
    { 255, 251, 240,  0 },
    { 160, 160, 164,  0 },

    { 0x80,0x80,0x80, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/******************************Public*Routine******************************\
*
* UpdateStaticMapping
*
* Computes the best match between the current system static colors
* and a 3-3-2 palette
*
* History:
*  Tue Aug 01 18:18:12 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static void
UpdateStaticMapping(PALETTEENTRY *pe332Palette)
{
    HPALETTE hpalStock;
    int iStatic, i332;
    int iMinDist, iDist;
    int iDelta;
    int iMinEntry;
    PALETTEENTRY *peStatic, *pe332;

    hpalStock = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    // Get the current static colors
    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry);

    // Zero the flags in the static colors because they are used later
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Zero the flags in the incoming palette because they are used later
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = 0;
        pe332++;
    }

    // Try to match each static color exactly
    // This saves time by avoiding the least-squares match for each
    // exact match
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            if (peStatic->peRed == pe332->peRed &&
                peStatic->peGreen == pe332->peGreen &&
                peStatic->peBlue == pe332->peBlue)
            {
                peStatic->peFlags = EXACT_MATCH;
                pe332->peFlags = COLOR_USED;
                aiDefaultOverride[iStatic] = i332;
                
                break;
            }

            pe332++;
        }

        peStatic++;
    }
    
    // Match each static color as closely as possible to an entry
    // in the 332 palette by minimized the square of the distance
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        // Skip colors already matched exactly
        if (peStatic->peFlags == EXACT_MATCH)
        {
            peStatic++;
            continue;
        }
        
        iMinDist = MAX_COL_DIST+1;
#if DBG
        iMinEntry = -1;
#endif

        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            // Skip colors already used
            if (pe332->peFlags == COLOR_USED)
            {
                pe332++;
                continue;
            }
            
            // Compute Euclidean distance squared
            iDelta = pe332->peRed-peStatic->peRed;
            iDist = iDelta*iDelta;
            iDelta = pe332->peGreen-peStatic->peGreen;
            iDist += iDelta*iDelta;
            iDelta = pe332->peBlue-peStatic->peBlue;
            iDist += iDelta*iDelta;

            if (iDist < iMinDist)
            {
                iMinDist = iDist;
                iMinEntry = i332;
            }

            pe332++;
        }

        // Remember the best match
        aiDefaultOverride[iStatic] = iMinEntry;
        pe332Palette[iMinEntry].peFlags = COLOR_USED;
        
        peStatic++;
    }

    // Zero the flags in the static colors because they may have been
    // set.  We want them to be zero so the colors can be remapped
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Reset the 332 flags because we may have set them
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = PALETTE_FLAGS;
        pe332++;
    }

#if 0
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        PrintMessage("Static color %2d maps to %d\n",
                     iStatic, aiDefaultOverride[iStatic]);
    }
#endif
}

/******************************Public*Routine******************************\
* FillRgbPaletteEntries
*
* Fills a PALETTEENTRY array with values required for a logical rgb palette.
* If tkSetStaticColorUsage has been called with TRUE, the static system
* colors will be overridden.  Otherwise, the PALETTEENTRY array will be
* fixed up to contain the default static system colors.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY *
FillRgbPaletteEntries(  PIXELFORMATDESCRIPTOR *Pfd,
                        PALETTEENTRY *Entries,
                        UINT Count
                     )
{
    PALETTEENTRY *Entry;
    UINT i;

    if ( NULL != Entries )
    {
        for ( i = 0, Entry = Entries ; i < Count ; i++, Entry++ )
        {
            Entry->peRed   = ComponentFromIndex(i, Pfd->cRedBits,
                                    Pfd->cRedShift);
            Entry->peGreen = ComponentFromIndex(i, Pfd->cGreenBits,
                                    Pfd->cGreenShift);
            Entry->peBlue  = ComponentFromIndex(i, Pfd->cBlueBits,
                                    Pfd->cBlueShift);
            Entry->peFlags = PALETTE_FLAGS;
        }

        if ( 256 == Count)
        {
        // If app set static system color usage for fixed palette support,
        // setup to take over the static colors.  Otherwise, fixup the
        // static system colors.

            // The defaultOverride array is computed assuming a 332
            // palette where red has zero shift, etc.

            if ( (3 == Pfd->cRedBits)   && (0 == Pfd->cRedShift)   &&
                 (3 == Pfd->cGreenBits) && (3 == Pfd->cGreenShift) &&
                 (2 == Pfd->cBlueBits)  && (6 == Pfd->cBlueShift) )
            {
                UpdateStaticMapping(Entries);
                
                for ( i = 0 ; i < STATIC_COLORS ; i++)
                {
                    Entries[aiDefaultOverride[i]] = apeDefaultPalEntry[i];
                }
            }
        }
    }
    return( Entries );
}

/******************************Public*Routine******************************\
* FlushPalette
*
* Because of Win 3.1 compatibility, GDI palette mapping always starts
* at zero and stops at the first exact match.  So if there are duplicates,
* the higher colors aren't mapped to--which is often a problem if we
* are trying to make to any of the upper 10 static colors.  To work around
* this, we flush the palette to all black.
*
* This only needs to be done for the 8BPP (256 color) case.
*
\**************************************************************************/

static void
FlushPalette(HDC hdc, int nColors)
{
    LOGPALETTE *pPal;
    HPALETTE hpal, hpalOld;
    int i;

    if (nColors == 256)
    {
        pPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
                                         sizeof(LOGPALETTE) + nColors * sizeof(PALETTEENTRY));

        if (pPal)
        {
	    pPal->palVersion = 0x300;
	    pPal->palNumEntries = nColors;

        // Mark everything PC_NOCOLLAPSE and PC_RESERVED to force every thing
        // into the palette.  Colors are already black because we zero initialized
        // during memory allocation.

            for (i = 0; i < nColors; i++)
            {
                pPal->palPalEntry[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
            }

            hpal = CreatePalette(pPal);
            LocalFree(pPal);

            hpalOld = SelectPalette(hdc, hpal, FALSE);
            RealizePalette(hdc);

            SelectPalette(hdc, hpalOld, FALSE);
            DeleteObject(hpal);
        }
    }
}

HPALETTE
gltkCreateRGBPalette( gltkWindow *gltkw )
{
    PIXELFORMATDESCRIPTOR Pfd, *pPfd;
    LOGPALETTE *LogPalette;
    UINT Count;

    if ( NULL == gltkw->hpal )
    {
        pPfd = &Pfd;

        if ( PixelFormatDescriptorFromDc( gltkw->hdc, pPfd ) )
        {
            /*
             *  Make sure we need a palette
             */

            if ( (pPfd->iPixelType == PFD_TYPE_RGBA) &&
                 (pPfd->dwFlags & PFD_NEED_PALETTE) )
            {
                /*
                 *  Note how palette is to be realized.  Take over the
                 *  system colors if either the pixel format requires it
                 *  or the app wants it.
                 */
                Count       = 1 << pPfd->cColorBits;
                LogPalette  =
                    (LOGPALETTE *)AllocateMemory( sizeof(LOGPALETTE) +
                                                  Count *
                                                  sizeof(PALETTEENTRY));

                if ( NULL != LogPalette )
                {
                    LogPalette->palVersion    = 0x300;
                    LogPalette->palNumEntries = Count;

                    FillRgbPaletteEntries( pPfd,
                                           &LogPalette->palPalEntry[0],
                                           Count );

                    gltkw->hpal = CreatePalette(LogPalette);
                    FreeMemory(LogPalette);

                    FlushPalette(gltkw->hdc, Count);
                    
                    RealizePaletteNow( gltkw->hdc, gltkw->hpal, FALSE );
                }
            }
        }
    }
    return( gltkw->hpal );
}

/******************************Public*Routine******************************\
* RealizePaletteNow
*
* Select the given palette in background or foreground mode (as specified
* by the bForceBackground flag), and realize the palette.
*
* If static system color usage is set, the system colors are replaced.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static long
RealizePaletteNow( HDC Dc, HPALETTE Palette, BOOL bForceBackground )
{
    long Result = -1;
    BOOL bHaveSysPal = TRUE;

// If static system color usage is set, prepare to take over the
// system palette.

    {
        if ( NULL != SelectPalette( Dc, Palette, FALSE ) )
        {
            Result = RealizePalette( Dc );
        }
    }

    return( Result );
}

static int
PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd )
{
    int PfdIndex;

    if ( 0 < (PfdIndex = GetPixelFormat( Dc )) )
    {
        if ( 0 < DescribePixelFormat( Dc, PfdIndex, sizeof(*Pfd), Pfd ) )
        {
            return(PfdIndex);
        }
    }
    return( 0 );
}

/*
 *  This Should be called in response to a WM_DESTROY message
 */

static void
CleanUp( gltkWindow *gltkw )
{
    HPALETTE hStock;

// Cleanup the palette.

    if ( NULL != gltkw->hpal )
    {
    // If static system color usage is set, restore the system colors.

        if ( hStock = (HPALETTE)GetStockObject( DEFAULT_PALETTE ) )
            SelectPalette( gltkw->hdc, hStock, FALSE );

        DeleteObject( gltkw->hpal );
    }

// Cleanup the DC.

    if ( NULL != gltkw->hdc )
    {
        ReleaseDC( gltkw->hwnd, gltkw->hdc );
    }
}

static void *
AllocateMemory( size_t Size )
{
    return( LocalAlloc( LMEM_FIXED, Size ) );
}

static void *
AllocateZeroedMemory( size_t Size )
{
    return( LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size ) );
}

static void
FreeMemory( void *Chunk )
{
    LocalFree( Chunk );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\pch.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <math.h>
#include <malloc.h>

#include <windows.h>
#include <windowsx.h>

#include <ddraw.h>
#include <d3d.h>

#include <d3dmath.h>
#include <d3dmacs.h>

#include <gl\gl.h>
#include <gl\glaux.h>
#include <gl\glu.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\glwin.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "glrend.h"
#include "util.h"
#include "globals.h"
#include "gltk.h"

// #define NO_LIGHTING

// Translation tables for D3D -> OpenGL
GLenum eDepthFuncTranslate[] =
{
    0,
    GL_NEVER,
    GL_LESS,
    GL_EQUAL,
    GL_LEQUAL,
    GL_GREATER,
    GL_NOTEQUAL,
    GL_GEQUAL,
    GL_ALWAYS
};
GLenum eTextureFilterTranslate[] =
{
    0,
    GL_NEAREST,
    GL_LINEAR,
    GL_NEAREST_MIPMAP_NEAREST,
    GL_NEAREST_MIPMAP_LINEAR,
    GL_LINEAR_MIPMAP_NEAREST,
    GL_LINEAR_MIPMAP_LINEAR
};
GLenum eBlendFuncTranslate[] =
{
    0,
    GL_ZERO,
    GL_ONE,
    GL_SRC_COLOR,
    GL_ONE_MINUS_SRC_COLOR,
    GL_SRC_ALPHA,
    GL_ONE_MINUS_SRC_ALPHA,
    GL_DST_ALPHA,
    GL_ONE_MINUS_DST_ALPHA,
    GL_DST_COLOR,
    GL_ONE_MINUS_DST_COLOR,
    GL_SRC_ALPHA_SATURATE
};

GlWindow::GlWindow(void)
{
    _iLight = 0;
    memset(&_drcBound, 0, sizeof(_drcBound));

    _dmView = dmIdentity;
    _dmProjection = dmIdentity;

    _pfWorld = NULL;
    _pfView = NULL;
    _pfProjection = NULL;
    memset(&_gltkw, 0, sizeof(_gltkw));
    _hrc = NULL;
}

BOOL GlWindow::Initialize(int x, int y,
                          UINT uiWidth, UINT uiHeight, UINT uiBuffers)
{
    PIXELFORMATDESCRIPTOR pfd;
    int iFmt;
    
    if (gltkCreateWindow(app.hDlg, "OpenGL Performance Test",
                         x, y, uiWidth, uiHeight, &_gltkw) == NULL)
    {
        return FALSE;
    }

    memset(&pfd, 0, sizeof(pfd));
    pfd.nSize = sizeof(pfd);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
    if (uiBuffers & REND_BUFFER_BACK)
    {
        pfd.dwFlags |= PFD_DOUBLEBUFFER;
    }
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = GetDeviceCaps(_gltkw.hdc, BITSPIXEL)*
        GetDeviceCaps(_gltkw.hdc, PLANES);
    if (uiBuffers & REND_BUFFER_Z)
    {
        pfd.cDepthBits = 16;
    }
    pfd.cAuxBuffers = 0;
    pfd.iLayerType  = PFD_MAIN_PLANE;
    iFmt = ChoosePixelFormat(_gltkw.hdc, &pfd);
    if (iFmt == 0)
    {
        return FALSE;
    }
    if (DescribePixelFormat(_gltkw.hdc, iFmt, sizeof(pfd), &pfd) == 0)
    {
        return FALSE;
    }
    if (!SetPixelFormat(_gltkw.hdc, iFmt, &pfd))
    {
        return FALSE;
    }
    if ((pfd.dwFlags & PFD_NEED_PALETTE) &&
        gltkCreateRGBPalette(&_gltkw) == NULL)
    {
        return FALSE;
    }
    _hrc = wglCreateContext(_gltkw.hdc);
    if (_hrc == NULL)
    {
        return FALSE;
    }
    if (!wglMakeCurrent(_gltkw.hdc, _hrc))
    {
        return FALSE;
    }
    
    if (!SetViewport(0, 0, uiWidth, uiHeight))
    {
        return FALSE;
    }
    
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);

    glEnable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

#if 0
    // Unclear what D3D's model is
    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
#endif
    
    return TRUE;
}

GlWindow::~GlWindow(void)
{
    if (_hrc != NULL)
    {
        wglDeleteContext(_hrc);
    }
    if (_gltkw.hwnd != NULL)
    {
        DestroyWindow(_gltkw.hwnd);
    }
}

void GlWindow::Release(void)
{
    delete this;
}

BOOL GlWindow::SetViewport(int x, int y, UINT uiWidth, UINT uiHeight)
{
    _drcBound.x1 = x;
    _drcBound.y1 = y;
    _drcBound.x2 = x+uiWidth;
    _drcBound.y2 = y+uiHeight;
    
    glViewport(x, y, uiWidth, uiHeight);
    
    return TRUE;
}

RendLight* GlWindow::NewLight(int iType)
{
    GlLight* prlight;
    GLenum eLight;

    eLight = GL_LIGHT0+_iLight;
    prlight = new GlLight(iType, eLight);
    if (prlight != NULL)
    {
        _iLight++;
    }
    return prlight;
}

RendTexture* GlWindow::NewTexture(char* pszFile, UINT uiFlags)
{
    GlTexture* pgtex;
    GLuint uiTexObj;
    Image im;
    ImageFormat ifmt;

    pgtex = new GlTexture;
    if (pgtex == NULL)
    {
        return NULL;
    }

    if (!pgtex->Initialize(pszFile))
    {
        delete pgtex;
        return NULL;
    }

    return pgtex;
}

RendExecuteBuffer* GlWindow::NewExecuteBuffer(UINT cbSize, UINT uiFlags)
{
    GlExecuteBuffer* pgeb;

    pgeb = new GlExecuteBuffer;
    if (pgeb == NULL)
    {
        return NULL;
    }

    if (!pgeb->Initialize(cbSize, uiFlags))
    {
        delete pgeb;
        return NULL;
    }
    
    return pgeb;
}

RendMatrix* GlWindow::NewMatrix(void)
{
    return new GlMatrix(this);
}

RendMaterial* GlWindow::NewMaterial(UINT nColorEntries)
{
    return new GlMaterial;
}

BOOL GlWindow::BeginScene(void)
{
    _eTexMin = DEF_TEX_MIN;
    _eTexMag = DEF_TEX_MAG;
    _eSrcBlend = GL_ONE;
    _eDstBlend = GL_ZERO;
    glDisable(GL_TEXTURE_2D);
    
    return TRUE;
}

BOOL GlWindow::Execute(RendExecuteBuffer* preb)
{
    BOOL bSucc;

#ifdef GL_EXT_clip_volume_hint
    int i;
    
    glGetIntegerv(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, &i);
    glHint(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, GL_FASTEST);
#endif

    bSucc = DoExecute(preb);
    
#ifdef GL_EXT_clip_volume_hint
    glHint(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, i);
#endif

    return bSucc;
}

BOOL GlWindow::ExecuteClipped(RendExecuteBuffer* preb)
{
    return DoExecute(preb);
}

BOOL GlWindow::EndScene(D3DRECT* pdrcBound)
{
    if (pdrcBound != NULL)
    {
        if (app.uiCurrentTest == THROUGHPUT_TEST)
        {
            // The throughput test only draws on a small portion of the
            // viewport so it's critical that we provide a small
            // bound
            pdrcBound->x1 = _drcBound.x1+(WIN_WIDTH*34/100);
            pdrcBound->y1 = _drcBound.y1+(WIN_HEIGHT*34/100);
            pdrcBound->x2 = _drcBound.x2-(WIN_WIDTH*34/100);
            pdrcBound->y2 = _drcBound.y2-(WIN_HEIGHT*34/100);
        }
        else
        {
            // All other tests fill the whole viewport
            *pdrcBound = _drcBound;
        }
    }
    
    return TRUE;
}

BOOL GlWindow::Clear(UINT uiBuffers, D3DRECT* pdrc)
{
    GLbitfield grfMask;

    if (pdrc != NULL)
    {
        glEnable(GL_SCISSOR_TEST);
        glScissor(pdrc->x1, pdrc->y1, pdrc->x2-pdrc->x1, pdrc->y2-pdrc->y1);
    }
   
    // Assumes window is always double-buffered
    if (uiBuffers & REND_BUFFER_FRONT)
    {
        glDrawBuffer(GL_FRONT);
        glClear(GL_COLOR_BUFFER_BIT);
        glDrawBuffer(GL_BACK);
    }
    
    grfMask = 0;
    if (uiBuffers & REND_BUFFER_BACK)
    {
        grfMask |= GL_COLOR_BUFFER_BIT;
    }
    if (uiBuffers & REND_BUFFER_Z)
    {
        grfMask |= GL_DEPTH_BUFFER_BIT;
    }
    glClear(grfMask);

    if (pdrc != NULL)
    {
        glDisable(GL_SCISSOR_TEST);
    }
    
    return TRUE;
}

BOOL GlWindow::Flip(void)
{
    SwapBuffers(_gltkw.hdc);
    return TRUE;
}

// #define SHOW_BOUND

BOOL GlWindow::CopyForward(D3DRECT* pdrc)
{
#ifdef GL_WIN_swap_hint
    if (pdrc != NULL && glAddSwapHintRectWIN != NULL)
    {
        glAddSwapHintRectWIN(pdrc->x1, pdrc->y1,
                             pdrc->x2-pdrc->x1, pdrc->y2-pdrc->y1);
    }
#endif
        
    SwapBuffers(_gltkw.hdc);

#ifdef SHOW_BOUND
    SelectObject(_gltkw.hdc, GetStockObject(WHITE_PEN));
    MoveToEx(_gltkw.hdc, pdrc->x1, pdrc->y1, NULL);
    LineTo(_gltkw.hdc, pdrc->x1, pdrc->y2);
    LineTo(_gltkw.hdc, pdrc->x2, pdrc->y2);
    LineTo(_gltkw.hdc, pdrc->x2, pdrc->y1);
    LineTo(_gltkw.hdc, pdrc->x1, pdrc->y1);
#endif
    
    return TRUE;
}

HWND GlWindow::Handle(void)
{
    return _gltkw.hwnd;
}

static D3DMATRIX dmFlipZ =
{
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(-1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0)
};

void GlWindow::ChangeWorld(float *pfMatrix)
{
    glLoadMatrixf(pfMatrix);
    _pfWorld = pfMatrix;
}

void GlWindow::ChangeView(float *pfMatrix)
{
    memcpy(&_dmView, pfMatrix, sizeof(_dmView));
    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf((float *)&_dmProjection);
    glMultMatrixf((float *)&_dmView);
    glMatrixMode(GL_MODELVIEW);
    _pfView = pfMatrix;
}

void GlWindow::ChangeProjection(float *pfMatrix)
{
    // D3D is left-handed while OpenGL is right-handed
    // Flip the Z direction to account for this
    // Could just change row three's signs but this
    // matrix doesn't change often
    MultiplyD3DMATRIX(&_dmProjection, (D3DMATRIX *)pfMatrix, &dmFlipZ);
    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf((float *)&_dmProjection);
    glMultMatrixf((float *)&_dmView);
    glMatrixMode(GL_MODELVIEW);
    _pfProjection = pfMatrix;
}

void GlWindow::MatrixChanged(float *pfMatrix)
{
    if (pfMatrix == _pfWorld)
    {
        ChangeWorld(pfMatrix);
    }
    else if (pfMatrix == _pfView)
    {
        ChangeView(pfMatrix);
    }
    else if (pfMatrix == _pfProjection)
    {
        ChangeProjection(pfMatrix);
    }
}

BOOL GlWindow::DoExecute(RendExecuteBuffer* preb)
{
    D3DINSTRUCTION* pdinst;
    GlExecuteBuffer* pgeb;
    BOOL bExit;
    ULONG i;
    D3DSTATE* pdst;
    float fv4[4];
    BOOL bProcessedVertices;
    BOOL bDisplayList;
#if DBG
    D3DINSTRUCTION *pdinstPrev;
#endif

    pgeb = (GlExecuteBuffer *)preb;
    bDisplayList = FALSE;
    if (pgeb->_dlist != 0)
    {
        glCallList(pgeb->_dlist);
        return TRUE;
    }
    else if (pgeb->_nVertices > 0)
    {
        // Create a display list for any execute buffer with vertices
        // This is a performance win for glDrawElements
        
        // This is wasted time in the full fill test since
        // the vertex data changes all the time
        if (app.uiCurrentTest != FILL_RATE_TEST)
        {
            pgeb->_dlist = glGenLists(1);
            glNewList(pgeb->_dlist, GL_COMPILE_AND_EXECUTE);
            bDisplayList = TRUE;
        }
    }
    
    pdinst = (D3DINSTRUCTION *)(pgeb->_pbData+pgeb->_cbStart);
    bProcessedVertices = FALSE;

    // Account for RH vs. LH
    glDepthRange(1, 0);
    glEnableClientState(GL_NORMAL_ARRAY);
    glDisableClientState(GL_COLOR_ARRAY);
#ifndef NO_LIGHTING
    if (_iLight > 0)
    {
        glEnable(GL_LIGHTING);
    }
#endif
    
    bExit = FALSE;
#if DBG
    pdinstPrev = NULL;
#endif
    while (!bExit &&
           (BYTE *)pdinst < (pgeb->_pbData+pgeb->_cbStart+pgeb->_cbSize))
    {
#if 0
        printf("Op %d, size %d, count %d\n",
               pdinst->bOpcode, pdinst->bSize, pdinst->wCount);
#endif
        
        switch(pdinst->bOpcode)
        {
        case D3DOP_POINT:
            // Consider implementing
            break;

        case D3DOP_LINE:
            // Consider implementing
            break;

        case D3DOP_TRIANGLE:
            if (pdinst->wCount > 0)
            {
                Msg("Unprocessed execute buffer");
                return FALSE;
            }
            break;
            
        case D3DOP_MATRIXLOAD:
            D3DMATRIXLOAD* pdml;
            
            pdml = (D3DMATRIXLOAD *)(pdinst+1);
            for (i = 0; i < pdinst->wCount; i++)
            {
                memcpy((BYTE *)pdml->hDestMatrix,
                       (BYTE *)pdml->hSrcMatrix,
                       sizeof(D3DMATRIX));
#if 0
                // Should we check here also?
                MatrixChanged((float *)pdml->hDestMatrix);
#endif
                pdml++;
            }
            break;

        case D3DOP_MATRIXMULTIPLY:
            D3DMATRIXMULTIPLY* pdmm;

            pdmm = (D3DMATRIXMULTIPLY *)(pdinst+1);
            for (i = 0; i < pdinst->wCount; i++)
            {
                MultiplyD3DMATRIX((D3DMATRIX *)pdmm->hDestMatrix,
                                  (D3DMATRIX *)pdmm->hSrcMatrix1,
                                  (D3DMATRIX *)pdmm->hSrcMatrix2);
#if 0
                // Should we check here also?
                MatrixChanged((float *)pdmm->hDestMatrix);
#endif
                pdmm++;
            }
            break;

        case D3DOP_STATETRANSFORM:
            pdst = (D3DSTATE *)(pdinst+1);
            for (i = 0; i < pdinst->wCount; i++)
            {
                switch(pdst->dtstTransformStateType)
                {
                case D3DTRANSFORMSTATE_WORLD:
                    ChangeWorld((float *)pdst->dwArg[0]);
                    break;
                case D3DTRANSFORMSTATE_VIEW:
                    ChangeView((float *)pdst->dwArg[0]);
                    break;
                case D3DTRANSFORMSTATE_PROJECTION:
                    ChangeProjection((float *)pdst->dwArg[0]);
                    break;
                }

                pdst++;
            }
            break;

        case D3DOP_STATELIGHT:
            pdst = (D3DSTATE *)(pdinst+1);
            for (i = 0; i < pdinst->wCount; i++)
            {
                switch(pdst->dlstLightStateType)
                {
                case D3DLIGHTSTATE_MATERIAL:
                    // Should probably optimize this so
                    // that work is done only when material properties
                    // change
                    ((GlMaterial *)pdst->dwArg[0])->Apply();
                    break;
                case D3DLIGHTSTATE_AMBIENT:
                    fv4[0] = (float)((pdst->dwArg[0] >> 16) & 0xff) / 255.0f;
                    fv4[1] = (float)((pdst->dwArg[0] >>  8) & 0xff) / 255.0f;
                    fv4[2] = (float)((pdst->dwArg[0] >>  0) & 0xff) / 255.0f;
                    fv4[3] = (float)((pdst->dwArg[0] >> 24) & 0xff) / 255.0f;
                    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, fv4);
                    break;
                    // Others
                }

                pdst++;
            }
            break;

        case D3DOP_STATERENDER:
            pdst = (D3DSTATE *)(pdinst+1);
            for (i = 0; i < pdinst->wCount; i++)
            {
                switch(pdst->drstRenderStateType)
                {
                    // Many to implement but all currently
                    // used values are handled
                case D3DRENDERSTATE_TEXTUREHANDLE:
                    if (pdst->dwArg[0] == 0)
                    {
                        glDisable(GL_TEXTURE_2D);
                    }
                    else
                    {
                        glEnable(GL_TEXTURE_2D);
                        glBindTexture(GL_TEXTURE_2D, (GLuint)pdst->dwArg[0]);
                        // Establish current texture params
                        glTexParameteri(GL_TEXTURE_2D,
                                        GL_TEXTURE_MIN_FILTER, _eTexMin);
                        glTexParameteri(GL_TEXTURE_2D,
                                        GL_TEXTURE_MAG_FILTER, _eTexMag);
                    }
                    break;
                case D3DRENDERSTATE_WRAPU:
                case D3DRENDERSTATE_WRAPV:
                    // These should probably be supported
                    // but it's non-trivial plus the default state
                    // is currently wrap and that's what the tests
                    // care about
                    break;
                case D3DRENDERSTATE_SHADEMODE:
                    switch(pdst->dwArg[0])
                    {
                    case D3DSHADE_FLAT:
                        glShadeModel(GL_FLAT);
                        break;
                    case D3DSHADE_GOURAUD:
                        glShadeModel(GL_SMOOTH);
                        break;
                    default:
                        Msg("Unsupported SHADEMODE %d", pdst->dwArg[0]);
                        return FALSE;
                    }
                    break;
                case D3DRENDERSTATE_TEXTUREMAPBLEND:
                    GLenum eTexMode;
                        
                    switch(pdst->dwArg[0])
                    {
                    case D3DTBLEND_DECAL:
                        // Technically D3DTBLEND_DECAL doesn't match
                        // GL_DECAL, but it's close enough
                    case D3DTBLEND_DECALALPHA:
                        eTexMode = GL_DECAL;
                        break;
                    case D3DTBLEND_MODULATE:
                        // Technically D3DTBLEND_MODULATE doesn't match
                        // GL_MODULATE, but it's close enough
                    case D3DTBLEND_MODULATEALPHA:
                        eTexMode = GL_MODULATE;
                        break;
                    case D3DTBLEND_COPY:
                        eTexMode = GL_REPLACE;
                        break;
                    default:
                        Msg("Unsupported TEXTUREMAPBLEND %d", pdst->dwArg[0]);
                        return FALSE;
                    }
                    if (eTexMode != DEF_TEX_MODE)
                    {
                        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE,
                                  eTexMode);
                    }
                    break;
                case D3DRENDERSTATE_TEXTUREPERSPECTIVE:
                    glHint(GL_PERSPECTIVE_CORRECTION_HINT,
                           pdst->dwArg[0] ? GL_NICEST : GL_FASTEST);
                    break;
                case D3DRENDERSTATE_ZENABLE:
                    if (pdst->dwArg[0])
                    {
                        glEnable(GL_DEPTH_TEST);
                    }
                    else
                    {
                        glDisable(GL_DEPTH_TEST);
                    }
                    break;
                case D3DRENDERSTATE_ZWRITEENABLE:
                    glDepthMask((GLboolean)pdst->dwArg[0]);
                    break;
                case D3DRENDERSTATE_ZFUNC:
                    glDepthFunc(eDepthFuncTranslate[pdst->dwArg[0]]);
                    break;
                case D3DRENDERSTATE_TEXTUREMAG:
                    _eTexMag = eTextureFilterTranslate[pdst->dwArg[0]];
                    break;
                case D3DRENDERSTATE_TEXTUREMIN:
                    _eTexMin = eTextureFilterTranslate[pdst->dwArg[0]];
                    break;
                case D3DRENDERSTATE_DITHERENABLE:
                    if (pdst->dwArg[0])
                    {
                        glEnable(GL_DITHER);
                        break;
                    }
                    else
                    {
                        glDisable(GL_DITHER);
                        break;
                    }
                    break;
                case D3DRENDERSTATE_BLENDENABLE:
                    if (pdst->dwArg[0])
                    {
                        glEnable(GL_BLEND);
                        break;
                    }
                    else
                    {
                        glDisable(GL_BLEND);
                        break;
                    }
                    break;
                case D3DRENDERSTATE_SRCBLEND:
                    if (pdst->dwArg[0] == D3DBLEND_BOTHSRCALPHA)
                    {
                        _eSrcBlend = GL_SRC_ALPHA;
                        _eDstBlend = GL_ONE_MINUS_SRC_ALPHA;
                    }
                    else if (pdst->dwArg[0] == D3DBLEND_BOTHINVSRCALPHA)
                    {
                        _eSrcBlend = GL_ONE_MINUS_SRC_ALPHA;
                        _eDstBlend = GL_SRC_ALPHA;
                    }
                    else
                    {
                        _eSrcBlend = eBlendFuncTranslate[pdst->dwArg[0]];
                    }
                    glBlendFunc(_eSrcBlend, _eDstBlend);
                    break;
                case D3DRENDERSTATE_DESTBLEND:
                    _eDstBlend = eBlendFuncTranslate[pdst->dwArg[0]];
                    glBlendFunc(_eSrcBlend, _eDstBlend);
                    break;
                case D3DRENDERSTATE_SPECULARENABLE:
                    // Can't turn this off
                    break;
                case D3DRENDERSTATE_MONOENABLE:
                    if (pdst->dwArg[0] != 0)
                    {
                        Msg("Can't render in MONO mode");
                    }
                    break;

                default:
                    Msg("Unhandled RENDERSTATE %d", pdst->drstRenderStateType);
                    break;
                }

                pdst++;
            }
            break;

        case D3DOP_PROCESSVERTICES:
            D3DPROCESSVERTICES* pdpv;

            pdpv = (D3DPROCESSVERTICES *)(pdinst+1);
            for (i = 0; i < pdinst->wCount; i++)
            {
                if (bProcessedVertices)
                {
                    Msg("Multiple PROCESSVERTICES in execute buffer");
                    return FALSE;
                }
                
                switch(pdpv->dwFlags & D3DPROCESSVERTICES_OPMASK)
                {
                case D3DPROCESSVERTICES_TRANSFORMLIGHT:
                    D3DVERTEX* pdvtx;
                    
                    pdvtx = (D3DVERTEX *)(pgeb->_pbData+pdpv->wStart);
                    glVertexPointer(3, GL_FLOAT, sizeof(D3DVERTEX),
                                    &pdvtx[0].x);
                    glNormalPointer(GL_FLOAT, sizeof(D3DVERTEX), &pdvtx[0].nx);
                    glTexCoordPointer(2, GL_FLOAT, sizeof(D3DVERTEX),
                                      &pdvtx[0].tu);
                    break;

                case D3DPROCESSVERTICES_COPY:
                    D3DTLVERTEX* pdtlvtx;
                    
                    pdtlvtx = (D3DTLVERTEX *)(pgeb->_pbData+pdpv->wStart);
                    glVertexPointer(3, GL_FLOAT, sizeof(D3DTLVERTEX),
                                    &pdtlvtx[0].sx);
                    glTexCoordPointer(2, GL_FLOAT, sizeof(D3DTLVERTEX),
                                      &pdtlvtx[0].tu);
                    glColorPointer(4, GL_UNSIGNED_BYTE, sizeof(D3DTLVERTEX),
                                   &pdtlvtx[0].color);
                    glDisableClientState(GL_NORMAL_ARRAY);
                    glEnableClientState(GL_COLOR_ARRAY);
                    glDisable(GL_LIGHTING);
                    glLoadIdentity();
                    glMatrixMode(GL_PROJECTION);
                    glLoadIdentity();
                    // Flip Y, Z to match D3D
                    glOrtho(0, WIN_WIDTH, WIN_HEIGHT, 0, 0, 1);
                    // Flip Z to match D3D
                    glMultMatrixf((float *)&dmFlipZ);
                    glDepthRange(0, 1);
                    glMatrixMode(GL_MODELVIEW);
                    break;

                default:
                    Msg("Unsupported vertex processing type %X",
                        pdpv->dwFlags & D3DPROCESSVERTICES_OPMASK);
                    return FALSE;
                }
                
                bProcessedVertices = TRUE;
                pdpv++;
            }
            break;

        case D3DOP_TEXTURELOAD:
            D3DTEXTURELOAD* pdtl;

            pdtl = (D3DTEXTURELOAD *)(pdinst+1);
            for (i = 0; i < pdinst->wCount; i++)
            {
                // Consider implementing
                pdtl++;
            }
            break;

        case D3DOP_EXIT:
            bExit = TRUE;
            break;
            
        case D3DOP_BRANCHFORWARD:
            // Consider implementing
            break;

        case D3DOP_SPAN:
            // Consider implementing
            break;

        case D3DOP_SETSTATUS:
            // Consider implementing
            break;

        case PROCESSED_TRIANGLE:
            if (!bProcessedVertices)
            {
                Msg("Triangles without vertex data");
                return FALSE;
            }
            
            glDrawElements(GL_TRIANGLES, pdinst->wCount*3L, GL_UNSIGNED_INT,
                           *(GLuint **)(pdinst+1));
            break;

        default:
#if DBG
            if (pdinstPrev != NULL)
            {
                Msg("Invalid execute buffer opcode %d:%d (%08lX), "
                    "prev %d:%d (%08lX)",
                    pdinst->bOpcode, pdinst->wCount, pdinst,
                    pdinstPrev->bOpcode, pdinstPrev->wCount, pdinstPrev);
            }
            else
            {
                Msg("Invalid execute buffer opcode %d", pdinst->bOpcode);
            }
#else
            Msg("Invalid execute buffer opcode %d", pdinst->bOpcode);
#endif
            return FALSE;
        }

#if DBG
        pdinstPrev = pdinst;
#endif
        
        // Could eliminate this, it has a multiply
        pdinst = NEXT_PDINST(pdinst);
    }

    if (bDisplayList)
    {
        glEndList();
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\loadppm.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: loadppm.c
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "util.h"
#include "loadppm.h"

#define MAXPATH    256
#define PATHSEP    ';'
#define FILESEP    '\\'
#define MAXCONTENTS 25

static int PathListInitialised = FALSE;

struct {
    int count;
    char *contents[MAXCONTENTS];
} PathList;


void 
AddPathList(const char *path)
{
    char *p;
    char *elt;
    int len;

    while (path) {
	p = strchr(path, PATHSEP);
	if (p)
	    len = p - path;
	else
	    len = lstrlen(path);
	elt = (char *) malloc(len + 1);
	if (elt == NULL)
	    return;
	lstrcpyn(elt, path, len + 1);
	elt[len] = '\0';
	PathList.contents[PathList.count] = elt;
	PathList.count++;
	if (p)
	    path = p + 1;
	else
	    path = NULL;
	if (PathList.count == MAXCONTENTS)
	    return;
    }
    return;
}

#define RESPATH     "Software\\Microsoft\\Direct3D"
static void 
InitialisePathList()
{
    long result;
    HKEY key;
    DWORD type, size;
    static char buf[512];
    char* path;

    if (PathListInitialised)
	return;
    PathListInitialised = TRUE;

    PathList.count = 0;
    path = getenv("D3DPATH");
    if (path != NULL) {
        AddPathList(path);
        return;
    }
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &key);
    if (result == ERROR_SUCCESS) {
        size = sizeof(buf);
	result = RegQueryValueEx(key, "D3D Path", NULL, &type, (LPBYTE) buf,
	                         &size);
	RegCloseKey(key);
	if (result == ERROR_SUCCESS && type == REG_SZ)
	    AddPathList(buf);
    }
}

/*
 * Open a file using the current search path.
 */
FILE *
FindFile(const char *name, const char *mode)
{
    FILE *fp;
    char buf[MAXPATH];
    static char filesep[] = {FILESEP, 0};
    int i;

    InitialisePathList();

    fp = fopen(name, mode);
    if (fp != NULL)
	return fp;

    for (i = 0; i < PathList.count; i++) {
	lstrcpy(buf, PathList.contents[i]);
	lstrcat(buf, filesep);
	lstrcat(buf, name);
	fp = fopen(buf, mode);
	if (fp)
	    return fp;
    }
    return NULL;
}

void
ReleasePathList(void)
{
    int i;
    for (i = 0; i < PathList.count; i++) {
        free(PathList.contents[i]);
        PathList.contents[i] = NULL;
    }
    PathList.count = 0;
    PathListInitialised = FALSE;
}

/*
 * LoadPPM
 * Loads a ppm file into memory
 * Performs quantization if requested
 */
BOOL LoadPPM(LPCSTR pszFile, ImageFormat *pifDst, Image *pim)
{
    int i;
    FILE *pfile;
    char achLine[100];
    int nPixels;
    int cbBytes;
    int cbPixelSize;
    BYTE *pbRgb, *pbFinal;
    BYTE *pbSrc, *pbDst;
    BOOL bSucc;

    bSucc = FALSE;
    
    pfile = FindFile(pszFile, "rb");
    if (pfile == NULL)
    {
        Msg("LoadPPM: Cannot find %s.\n", pszFile);
	return FALSE;
    }
    fgets(achLine, sizeof(achLine), pfile);
    if (lstrcmp(achLine, "P6\n"))
    {
        Msg("LoadPPM: %s is not a PPM file.\n", pszFile);
        goto EH_pfile;
    }

    /*
     * Skip comment
     */
    do
    {
	fgets(achLine, sizeof(achLine), pfile);
    } while (achLine[0] == '#');
    sscanf(achLine, "%d %d\n", &pim->uiWidth, &pim->uiHeight);
    fgets(achLine, sizeof(achLine), pfile);	/* skip next line */

    cbPixelSize = (pifDst->nColorBits+7)/8;
    nPixels = pim->uiWidth*pim->uiHeight;
    cbBytes = nPixels*cbPixelSize;

    // Allocate space for raw RGB data and final data
    pbRgb = new BYTE[nPixels*3];
    if (pbRgb == NULL)
    {
        Msg("LoadPPM: Unable to allocate memory.\n");
        goto EH_pfile;
    }
    pbSrc = pbRgb;
    
    pbFinal = new BYTE[cbBytes];
    if (pbFinal == NULL)
    {
        Msg("LoadPPM: Unable to allocate memory.\n");
        goto EH_pbRgb;
    }
    pbDst = pbFinal;

    // Read in raw RGB data
    fread(pbRgb, 3, nPixels, pfile);

    /*
     * If the surface is not 8-bit quantized, it's easy
     */
    if (!pifDst->bQuantize)
    {
        ULONG *pul;
	USHORT *pus;
        ULONG ulTmp;
        int iRedScale;
        int iGreenScale;
        int iBlueScale;
        
        iRedScale = 255 / ((1 << pifDst->iRedBits)-1);
        iGreenScale = 255 / ((1 << pifDst->iGreenBits)-1);
        iBlueScale = 255 / ((1 << pifDst->iBlueBits)-1);
	switch (pifDst->nColorBits)
        {
        case 32:
            pul = (unsigned long *)pbDst;
            for (i = 0; i < nPixels; i++)
            {
                *pul++ =
                    ((((ULONG)*(pbSrc+0)) / iRedScale) <<
                     pifDst->iRedShift) |
                    ((((ULONG)*(pbSrc+1)) / iGreenScale) <<
                     pifDst->iGreenShift) |
                    ((((ULONG)*(pbSrc+2)) / iBlueScale) <<
                     pifDst->iBlueShift);
                pbSrc += 3;
            }
            break;
        case 24:
            // Even though both source and destination are 24bpp
            // the byte ordering may be different so we still need
            // to do the shifts
            for (i = 0; i < nPixels; i++)
            {
                ulTmp =
                    (((ULONG)*(pbSrc+0)) << pifDst->iRedShift) |
                    (((ULONG)*(pbSrc+1)) << pifDst->iGreenShift) |
                    (((ULONG)*(pbSrc+2)) << pifDst->iBlueShift);
                pbSrc += 3;
                *pbDst++ = *((BYTE *)&ulTmp+0);
                *pbDst++ = *((BYTE *)&ulTmp+1);
                *pbDst++ = *((BYTE *)&ulTmp+2);
            }
            break;
        case 16:
            pus = (unsigned short *)pbDst;
            for (i = 0; i < nPixels; i++)
            {
                *pus++ =
                    ((((USHORT)*(pbSrc+0)) / iRedScale) <<
                     pifDst->iRedShift) |
                    ((((USHORT)*(pbSrc+1)) / iGreenScale) <<
                     pifDst->iGreenShift) |
                    ((((USHORT)*(pbSrc+2)) / iBlueScale) <<
                     pifDst->iBlueShift);
                pbSrc += 3;
            }
            break;
            
        default:
            Msg("LoadPPM: Unknown pixel format.");
            goto EH_pbFinal;
	}
    }
    else
    {
        UINT uiIdx;
        UINT nColors;
        UINT nColMax;
        D3DCOLOR dcol;
        D3DCOLOR *pdcol;
        
        /*
         * Otherwise, we must palettize it
         */
        nColMax = 1 << pifDst->nColorBits;
        nColors = 0;
        pdcol = pim->dcolPalette;
        for (i = 0; i < nPixels; i++)
        {
            dcol = RGB_MAKE(*pbSrc, *(pbSrc+1), *(pbSrc+2));
            pbSrc += 3;
            for (uiIdx = 0; uiIdx < nColors; uiIdx++)
            {
                if (dcol == pdcol[uiIdx])
                {
                    break;
                }
            }
            if (uiIdx == nColors)
            {
                if (nColors == nColMax)
                {
                    Msg("LoadPPM: Palette overflow in quantization.\n");
                    goto EH_pbFinal;
                }

                pdcol[nColors++] = dcol;
            }

            *pbDst++ = (BYTE)uiIdx;
        }

        pim->nColors = nColors;
    }

    pim->pvImage = pbFinal;
    bSucc = TRUE;
    
 EH_pbRgb:
    delete [] pbRgb;
 EH_pfile:
    fclose(pfile);
    return bSucc;
    
 EH_pbFinal:
    delete [] pbFinal;
    goto EH_pbRgb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\pixtest.h ===
#ifndef __PIXTEST_H__
#define __PIXTEST_H__

// Pixel fill rate test functions
BOOL RenderScenePix(RendWindow *prwin, LPD3DRECT pdrc);
void ReleaseViewPix(void);
unsigned long
InitViewPix(RendWindow *prwin,
            int nTextures, RendTexture **pptex,
            UINT uiWidth, UINT uiHeight, UINT uiOverdraw, UINT uiOrder);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\polytest.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation. All Rights Reserved.
 *
 *  File: polytest.c
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "rend.h"
#include "globals.h"
#include "util.h"
#include "d3dsphr.h"
#include "polytest.h"

#define MAX_OBJECTS 20
#define CAMERA_POS_POLYGON 7.0f
#define CAMERA_POS_INTERSECTION 2.0f

/*
 * Global to keep track of execute buffer
 */
static RendExecuteBuffer *lpExBuf;

/*
 * Global for light
 */
static RendLight *prlight;

/*
 * Global projection and view matrices
 */
static RendMatrix *pProj;
static RendMatrix *pView;
static D3DMATRIX proj = {
    D3DVAL(2.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(2.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(1.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(-1.0), D3DVAL(0.0)
};
static D3DMATRIX view = {
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(7.0), D3DVAL(1.0)
};

/*
 * A structure which holds the object's data
 */
static struct {
    LPD3DVERTEX lpV;		           /* object's vertices    */
    LPD3DTRIANGLE lpTri;		   /* object's triangles   */
    int num_vertices, num_faces;
} objData;

typedef struct _orderElt {
    float	z;
    RendExecuteBuffer *exeBuff;
} orderElt;
static orderElt order[MAX_OBJECTS]; 

static int NumSpheres;
typedef struct tagSphereData {
    float vx, vy, vz;
    float rx, ry, rz;
    int age;
    RendMatrix *pMr;
    RendMatrix *pMdr;
    RendMatrix *pMp;
    RendMatrix *pMdp;
    RendMatrix *pM;
    RendTexture *pTex;
    RendMaterial *lpmat;
    RendExecuteBuffer *lpSetWorldExeBuf;
} SphereData;
static SphereData* sphere;

static float D, R, DMINUSR, DV, DR, DEPTH;
static UINT ORDER;

void
tick_sphere(int n)
{
    float x, y, z;
    D3DMATRIX Mp, Mdr, Mdp;
    sphere[n].pMp->Get(&Mp);
    x = (float)Mp._41;
    y = (float)Mp._42;
    z = (float)Mp._43;
    if (x > DMINUSR || x < -DMINUSR) {
	sphere[n].vx = -sphere[n].vx;
	sphere[n].rz = -sphere[n].rz;
	sphere[n].ry = -sphere[n].ry;
	++sphere[n].age;
    }
    if (y > DMINUSR || y < -DMINUSR) {
	sphere[n].vy = -sphere[n].vy;
	sphere[n].rz = -sphere[n].rz;
	sphere[n].rx = -sphere[n].rx;
	++sphere[n].age;
    }
    if (z > DEPTH || z < -DEPTH) {
	sphere[n].vz = -sphere[n].vz;
	sphere[n].rx = -sphere[n].rx;
	sphere[n].ry = -sphere[n].ry;
	++sphere[n].age;
    }
    if (sphere[n].age) {
	MakeRotMatrix(&Mdr, sphere[n].rx, sphere[n].ry, sphere[n].rz);
	sphere[n].pMdr->Set(&Mdr);
	MakePosMatrix(&Mdp, sphere[n].vx, sphere[n].vy, sphere[n].vz);
	sphere[n].pMdp->Set(&Mdp);
	sphere[n].age = 0;
    }
}

static int __cdecl compareZ(const void* p1, const void* p2)
{
    orderElt* h1 = (orderElt*) p1;
    orderElt* h2 = (orderElt*) p2;
    if (ORDER == FRONT_TO_BACK) {
	if (h1->z > h2->z) return -1;
	if (h1->z < h2->z) return 1;
    } else {
	if (h1->z < h2->z) return -1;
	if (h1->z > h2->z) return 1;
    }
    return 0;
}

void
sortObjects(void)
{
    int i;
    D3DMATRIX M;
    
    for (i = 0; i < NumSpheres; i++) {
	sphere[i].pMp->Get(&M);
	order[i].z = (float)M._43;
	order[i].exeBuff = sphere[i].lpSetWorldExeBuf;
    }
    qsort(order, NumSpheres, sizeof(orderElt), compareZ);
}

/*
 * Each frame, renders the scene and calls mod_buffer to modify the object
 * for the next frame.
 */
BOOL
RenderScenePoly(RendWindow *prwin, LPD3DRECT lpExtent)
{
    D3DRECT extent;
    int j;

    /*
     * Execute the instruction buffer
     */
    if (!prwin->BeginScene())
        return FALSE;
    
    if (ORDER != NO_SORT)
        sortObjects();
    
    for (j = 0; j < NumSpheres; j++) {
 	tick_sphere(j);
        
	if (ORDER == NO_SORT) {
	    /* we can also be sure this is the poly throughput test */
            if (!prwin->Execute(sphere[j].lpSetWorldExeBuf))
		return FALSE;
	    if (!prwin->Execute(lpExBuf))
		return FALSE;
	} else {
	    /* must be intersection test */
	    if (!prwin->Execute(order[j].exeBuff))
		return FALSE;
	    if (!prwin->ExecuteClipped(lpExBuf))
		return FALSE;
	}
    }
    
    if (!prwin->EndScene(&extent))
        return FALSE;
    
    *lpExtent = extent;
    return TRUE;
}

/*
 * Release the memory allocated for the scene and all D3D objects created.
 */
void
ReleaseViewPoly(void)
{
    int i;
    
    RELEASE(lpExBuf);
    RELEASE(prlight);
    
    for (i = 0; i < NumSpheres; i++) {
	RELEASE(sphere[i].lpmat);
    }
    
    if (objData.lpV)
        free(objData.lpV);
    if (objData.lpTri)
        free(objData.lpTri);
    free(sphere);
}

unsigned long
init_spheres(RendWindow *prwin, int n)
{
    D3DMATRIX Mp, Mdp, Mdr;
    int i;
    
    InitRandom();
    sphere = (SphereData*)malloc(n*sizeof(SphereData));
    memset(sphere, 0, n*sizeof(SphereData));
    for (i = 0; i < n; i++) {
	MakePosMatrix(&Mp, (float)DMINUSR - Random(2 * DMINUSR),
		      (float)DMINUSR - Random(2 * DMINUSR),
		      (float)-DEPTH + Random(2 * DEPTH));
	MAKE_REND_MATRIX(prwin, sphere[i].pMp, Mp);
	sphere[i].vx = (float)DV - Random(2 * DV);
	sphere[i].vy = (float)DV - Random(2 * DV);
	sphere[i].vz = (float)DV - Random(2 * DV);
	MakePosMatrix(&Mdp, sphere[i].vx, sphere[i].vy, sphere[i].vz);
	MAKE_REND_MATRIX(prwin, sphere[i].pMdp, Mdp);
	sphere[i].rx = (float)DR - Random(2 * DR);
	sphere[i].ry = (float)DR - Random(2 * DR);
	sphere[i].rz = (float)DR - Random(2 * DR);
	MakeRotMatrix(&Mdr, sphere[i].rx, sphere[i].ry, sphere[i].rz);
	MAKE_REND_MATRIX(prwin, sphere[i].pMdr, Mdr);
	MAKE_REND_MATRIX(prwin, sphere[i].pMr, dmIdentity);
	MAKE_REND_MATRIX(prwin, sphere[i].pM, dmIdentity);
    }
    return 1;
}

/*
 * Builds the scene and initializes the execute buffer for rendering.  Returns 0 on failure.
 */

#define ALPHA_COLOR_COUNT 3
static D3DCOLORVALUE dcvAlphaColors[ALPHA_COLOR_COUNT] =
{
    1.0f, 0.0f, 0.0f, 0.25f,
    0.0f, 1.0f, 0.0f, 0.50f,
    0.0f, 0.0f, 1.0f, 0.75f
};

unsigned long
InitViewPoly(RendWindow *prwin,
             int NumTextures, RendTexture **pprtex,
             UINT num, UINT rings, UINT segs, UINT order,
             float radius, float d, float depth,
	     float dv, float dr, BOOL bAlpha)
{
    /* Pointers into the exectue buffer. */
    LPVOID lpBufStart, lpInsStart, lpPointer;
    RendExecuteBuffer *lpExCmdBuf;
    size_t size;
    int i;

    D3DCOLORVALUE dcol;
    D3DVECTOR dvec;

    /* This sucks, but I'm tired */
    D = d;
    R = radius;
    DMINUSR = d - radius;
    DV = dv;
    DR = dr;
    DEPTH = depth;
    ORDER = order;

    NumSpheres = (int)num;

    /*
     * Generate the sphere.
     */
    if (!(GenerateSphere(R, rings, segs, (float)1.0, (float)1.0,
                         (float)1.0, &objData.lpV, &objData.lpTri,
                         &objData.num_vertices, &objData.num_faces)))
        return 0L;
    
    /*
     * Set the view and projection matrices, make the world matricies
     */
    if (order == NO_SORT) {
	view._43 = CAMERA_POS_POLYGON;
    } else {
	view._43 = CAMERA_POS_INTERSECTION;
    }
    
    MAKE_REND_MATRIX(prwin, pView, view);
    MAKE_REND_MATRIX(prwin, pProj, proj);

    /*
     * Create buffers for world matrix set commands
     */
    init_spheres(prwin, NumSpheres);
    for (i = 0; i < NumSpheres; i++) {
	
	/*
	 * Create a material, set its description and obtain a handle to it.
	 */
        sphere[i].lpmat = prwin->NewMaterial(32);
        if (sphere[i].lpmat == NULL)
	    return 0L;
        if (bAlpha)
        {
            dcol = dcvAlphaColors[i % ALPHA_COLOR_COUNT];
        }
        else
        {
            dcol.r = D3DVAL(1.0);
            dcol.g = D3DVAL(1.0);
            dcol.b = D3DVAL(1.0);
            dcol.a = D3DVAL(1.0);
        }
        sphere[i].lpmat->SetDiffuse(&dcol);
        sphere[i].lpmat->SetSpecular(&dcol, 40.0f);
        sphere[i].pTex = pprtex[i % NumTextures];
        sphere[i].lpmat->SetTexture(sphere[i].pTex);

        size = 0;
        size += sizeof(D3DINSTRUCTION) * 5;
        size += sizeof(D3DMATRIXMULTIPLY) * 3;
        size += sizeof(D3DSTATE) * 4;
        sphere[i].lpSetWorldExeBuf =
            prwin->NewExecuteBuffer(size, stat.uiExeBufFlags);
        if (sphere[i].lpSetWorldExeBuf == NULL)
	    return 0L;
        lpBufStart = sphere[i].lpSetWorldExeBuf->Lock();
        if (lpBufStart == NULL)
    	    return 0L;
        memset(lpBufStart, 0, size);
        lpPointer = lpBufStart;
        lpInsStart = lpPointer;
        OP_MATRIX_MULTIPLY(3, lpPointer);
	    MATRIX_MULTIPLY_REND_DATA(sphere[i].pMdr, sphere[i].pMr,
                                      sphere[i].pMr, lpPointer);
	    MATRIX_MULTIPLY_REND_DATA(sphere[i].pMdp, sphere[i].pMp,
                                      sphere[i].pMp, lpPointer);
	    MATRIX_MULTIPLY_REND_DATA(sphere[i].pMr, sphere[i].pMp,
                                      sphere[i].pM, lpPointer);
        OP_STATE_TRANSFORM(1, lpPointer);
            STATE_DATA(D3DTRANSFORMSTATE_WORLD, sphere[i].pM->Handle(),
                       lpPointer);
	OP_STATE_LIGHT(1, lpPointer);
	    STATE_DATA(D3DLIGHTSTATE_MATERIAL, sphere[i].lpmat->Handle(),
                       lpPointer);
	OP_STATE_RENDER(2, lpPointer);
	    STATE_DATA(D3DRENDERSTATE_TEXTUREHANDLE,
                       (sphere[i].pTex != NULL ? sphere[i].pTex->Handle() : 0),
                       lpPointer);
	    STATE_DATA(D3DRENDERSTATE_WRAPU, TRUE, lpPointer);
        OP_EXIT(lpPointer);
        /*
         * Setup the execute data describing the buffer
         */
        sphere[i].lpSetWorldExeBuf->Unlock();
        if (!sphere[i].lpSetWorldExeBuf->Process())
        {
            return 0L;
        }
    }
    /*
     * Create a buffer for matrix set commands etc.
     */
    size = 0;
    size += sizeof(D3DINSTRUCTION) * 6;
    size += sizeof(D3DSTATE) * 6;
    lpExCmdBuf = prwin->NewExecuteBuffer(size, stat.uiExeBufFlags);
    if (lpExCmdBuf == NULL)
	return 0L;
    lpBufStart = lpExCmdBuf->Lock();
    if (lpBufStart == NULL)
	return 0L;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;

    lpInsStart = lpPointer;
    OP_STATE_TRANSFORM(2, lpPointer);
        STATE_DATA(D3DTRANSFORMSTATE_VIEW, pView->Handle(), lpPointer);
        STATE_DATA(D3DTRANSFORMSTATE_PROJECTION, pProj->Handle(), lpPointer);
    OP_STATE_LIGHT(1, lpPointer);
        STATE_DATA(D3DLIGHTSTATE_AMBIENT, RGBA_MAKE(10, 10, 10, 10),
                   lpPointer);
    OP_STATE_RENDER(3, lpPointer);
        STATE_DATA(D3DRENDERSTATE_BLENDENABLE, bAlpha, lpPointer);
        STATE_DATA(D3DRENDERSTATE_SRCBLEND, D3DBLEND_SRCALPHA, lpPointer);
        STATE_DATA(D3DRENDERSTATE_DESTBLEND, D3DBLEND_INVSRCALPHA, lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpExCmdBuf->Unlock();
    if (!lpExCmdBuf->Process())
    {
        return 0L;
    }
    prwin->BeginScene();
    prwin->Execute(lpExCmdBuf);
    prwin->EndScene(NULL);
    /*
     * We are done with the command buffer.
     */
    lpExCmdBuf->Release();

    /*
     * Create the object execute buffer
     */
    size = sizeof(D3DVERTEX) * objData.num_vertices;
    size += sizeof(D3DPROCESSVERTICES) * 1;
    size += sizeof(D3DINSTRUCTION) * 4;
    size += sizeof(D3DTRIANGLE) * objData.num_faces;
    lpExBuf = prwin->NewExecuteBuffer(size, stat.uiExeBufFlags);
    if (lpExBuf == NULL)
        return 0L;

    /*
     * lock it so it can be filled
     */
    lpBufStart = lpExBuf->Lock();
    if (lpBufStart == NULL)
        return 0L;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;

    VERTEX_DATA(objData.lpV, objData.num_vertices, lpPointer);
    /*
     * Save the location of the first instruction and add instructions to 
     * execute buffer.
     */
    lpInsStart = lpPointer;
    OP_PROCESS_VERTICES(1, lpPointer);
        PROCESSVERTICES_DATA(D3DPROCESSVERTICES_TRANSFORMLIGHT, 0,
                             objData.num_vertices, lpPointer);
    /*
     * Make sure that the triangle data (not OP) will be QWORD aligned
     */
    if (QWORD_ALIGNED(lpPointer)) {
	OP_NOP(lpPointer);
    }
    OP_TRIANGLE_LIST(objData.num_faces, lpPointer);
        TRIANGLE_LIST_DATA(objData.lpTri, objData.num_faces, lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpExBuf->Unlock();
    lpExBuf->SetData(objData.num_vertices,
                     (ULONG)((char*)lpInsStart - (char*)lpBufStart),
                     (ULONG)((char*)lpPointer - (char*)lpInsStart));
    if (!lpExBuf->Process())
    {
        return 0L;
    }

    /*
     *  Create the light
     */
    prlight = prwin->NewLight(REND_LIGHT_DIRECTIONAL);
    if (prlight == NULL)
        return 0L;
    dcol.r = 0.9f;
    dcol.g = 0.9f;
    dcol.b = 0.9f;
    dcol.a = 1.0f;
    prlight->SetColor(&dcol);
    dvec.x = 0.0f;
    dvec.y = 0.0f;
    dvec.z = 1.0f;
    prlight->SetVector(&dvec);

    return NumSpheres * objData.num_faces;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\pixtest.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation. All Rights Reserved.
 *
 *  File: pixtest.c
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "rend.h"
#include "globals.h"
#include "pixtest.h"
#include "util.h"
#include "d3dmath.h"

#define DSPIN 0.05
#define MAX_OVERDRAW 100

/*
 * Globals to keep track of execute buffer
 */
static RendExecuteBuffer *lpExBuf;
static RendExecuteBuffer *lpSpinBuffer;

/*
 * More globals
 */
static RendMaterial *lpmat;   /* Material object */

/*
 * Global projection, view, world and spin matrices
 */
static RendMatrix *pProj;
static RendMatrix *pView;
static D3DMATRIX proj = {
    D3DVAL(4.25), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(4.25), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(3.0), D3DVAL(3.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(-3.0), D3DVAL(0.0)
};
static D3DMATRIX view = {
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(10.0), D3DVAL(1.0)
};
static RendMatrix *pWorld;
static RendMatrix *pDSpin;
static RendMatrix *pSpin;

/*
 * These defines describe the section of the tube in the execute buffer at
 * one time. (Note, tube and tunnel are used interchangeably).
 */
#define SEGMENTS 20   /* Number of segments in memory at one time.  Each
		       * segment is made up oftriangles spanning between
		       * two rings.
		       */ 
#define SIDES 4       /* Number of sides on each ring. */
#define TEX_RINGS 5   /* Number of rings to stretch the texture over. */
#define NUM_V (SIDES*(SEGMENTS+1)) // Number of vertices in memory at once
#define NUM_TRI (SIDES*SEGMENTS*2) // Number of triangles in memory
#define TUBE_R 1.4  	 /* Radius of the tube. */
#define SPLINE_POINTS 50 /* Number of spline points to initially
			  * calculate.  The section in memory represents
			  * only a fraction of this.
			  */
/*
 * Movement and track scalars given in terms of position along the spline
 * curve.
 */
#define SEGMENT_LENGTH 0.05 /* Length of each segment along curve. */
#define SPEED 0.02	    /* Amount to increment camera position along
			     * curve for each frame.
			     */
#define DEPTH 0.8	    /* How close the camera can get to the end of
			     * track before new segments are added.
			     */
#define PATH_LENGTH (SPLINE_POINTS - 1)	/*Total length of the tunnel.*/

/*
 * A global structure holding the tube data.
 */
static struct {
    LPD3DVERTEX lpV; 	    /* Points to the vertices. */
    LPD3DTRIANGLE lpTri;    /* Points to the triangles which make up the
    			     * segments.
			     */
    int TriOffset;	    /* Offset into the execute buffer were the
    			     * triangle list is found.
			     */
    LPD3DVECTOR lpPoints;   /* Points to the points defining the spline
    			     * curve.
			     */
    RendMaterial *pMat;     /* Handle for the material on the tube. */
    RendTexture *pTex;      /* Handle for the texture on the material.*/
    RendLight *prlight;     /* Light object */
    D3DVECTOR cameraP, cameraD, cameraN; /* Vectors defining the camera 
                                          * position, direction and up.
					  */
    float cameraPos;			 /* Camera position along the 
                                          * spline curve.
					  */
    D3DVECTOR endP, endD, endN; /* Vectors defining the position, 
    				 * direction and up at the foremost end of
    				 * the section in memory.
				 */
    float endPos; /* Position along the spline curve of the end. */
    int currentRing, currentSegment; /* Numbers of the ring and tube at 
				      * the back end of the section.
				      */
} tube;

static RendExecuteBuffer *lpSetWorldExeBuf[MAX_OVERDRAW];
static RendMatrix *pPos[MAX_OVERDRAW];
static UINT OVERDRAW, ORDER;

/*
 * Creates a matrix which is equivalent to having the camera at a
 * specified position. This matrix can be used to convert vertices to
 * camera coordinates. lpP    Position of the camera. lpD    Direction of
 * view. lpN    Up vector. lpM    Matrix to update.
 */
void 
PositionCamera(LPD3DVECTOR lpP, LPD3DVECTOR lpD, LPD3DVECTOR lpN, 
	       LPD3DMATRIX lpM)
{
    D3DMATRIX tmp;

    /*
     * Set the rotation part of the matrix and invert it. Vertices must be
     * inverse rotated to achieve the same result of a corresponding 
     * camera rotation.
     */
    tmp._14 = tmp._24 = tmp._34 = tmp._41 = tmp._42 = tmp._43 = (float)0.0;
    tmp._44 = (float)1.0;
    D3DMATRIXSetRotation(&tmp, lpD, lpN);
    D3DMATRIXInvert(lpM, &tmp);
    /*
     * Multiply the rotation matrix by a translation transform.  The
     * translation matrix must be applied first (left of rotation).
     */
    lpM->_41=-(lpM->_11 * lpP->x + lpM->_21 * lpP->y + lpM->_31 * lpP->z);
    lpM->_42=-(lpM->_12 * lpP->x + lpM->_22 * lpP->y + lpM->_32 * lpP->z);
    lpM->_43=-(lpM->_13 * lpP->x + lpM->_23 * lpP->y + lpM->_33 * lpP->z);
}

/*
 * Updates the given position, direction and normal vectors to a given
 * position on the spline curve.  The given up vector is used to determine
 * the new up vector.
 */
void 
MoveToPosition(float position, LPD3DVECTOR lpP, LPD3DVECTOR lpD, 
	       LPD3DVECTOR lpN)
{
    LPD3DVECTOR lpSplinePoint[4];
    D3DVECTOR pp, x;
    int i, j;
    float t;

    /*
     * Find the four points along the curve which are around the position.
     */
    i = 0;
    t = position;
    while (t > 1.0) {
	i++;
	if (i == SPLINE_POINTS)
	    i = 0;
	t -= (float)1.0;
    }
    for (j = 0; j < 4; j++) {
	lpSplinePoint[j] = &tube.lpPoints[i];
	i++;
	if (i == SPLINE_POINTS)
	    i = 0;
    }
    /*
     * Get the point at the given position and one just before it.
     */
    spline(lpP, t, lpSplinePoint[0], lpSplinePoint[1], lpSplinePoint[2],
	   lpSplinePoint[3]);
    spline(&pp, t - (float)0.01, lpSplinePoint[0], lpSplinePoint[1],
    	   lpSplinePoint[2], lpSplinePoint[3]);
    /*
     * Calculate the direction.
     */
    lpD->x = lpP->x - pp.x;
    lpD->y = lpP->y - pp.y;
    lpD->z = lpP->z - pp.z;
    D3DVECTORNormalise(lpD);
    /*
     * Find the new normal.  This method will work provided the change in
     * the normal is not very large.
     */
    D3DVECTORNormalise(lpN);
    D3DVECTORCrossProduct(&x, lpN, lpD);
    D3DVECTORCrossProduct(lpN, &x, lpD);
    lpN->x = -lpN->x;
    lpN->y = -lpN->y;
    lpN->z = -lpN->z;
    D3DVECTORNormalise(lpN);
}

/*
 * Generates a ring of vertices in a plane defined by n and the cross
 * product of n and p.  On exit, joint contains the vertices.  Join must
 * be pre-allocated. Normals are generated pointing in.  Texture
 * coordinates are generated along tu axis and are given along tv.
 */
static void 
MakeRing(LPD3DVECTOR p, LPD3DVECTOR d, LPD3DVECTOR n, float tv,
	 LPD3DVERTEX joint)
{
    int spoke;
    float theta, u, v, x, y, z;
    D3DVECTOR nxd;

    D3DVECTORCrossProduct(&nxd, n, d);
    for (spoke = 0; spoke < SIDES; spoke++) {
	theta = (float)(2.0 * PI) * spoke / SIDES;
	/*
	 * v, u defines a unit vector in the plane define by vectors nxd
	 * and n.
	 */
	v = (float)sin(theta);
	u = (float)cos(theta);
	/*
	 * x, y, z define a unit vector in standard coordiante space
	 */
	x = u * nxd.x + v * n->x;
	y = u * nxd.y + v * n->y;
	z = u * nxd.z + v * n->z;
	/*
	 * Position, normals and texture coordiantes.
	 */
	joint[spoke].x = (float)TUBE_R * x + p->x;
	joint[spoke].y = (float)TUBE_R * y + p->y;
	joint[spoke].z = (float)TUBE_R * z + p->z;
	joint[spoke].nx = -x;
	joint[spoke].ny = -y;
	joint[spoke].nz = -z;
	joint[spoke].tu = (float)1.0 - theta / (float)(2.0 * PI);
	joint[spoke].tv = tv;

    }
}


/*
 * Defines the triangles which form a segment between ring1 and ring2 and
 * stores them at lpTri.  lpTri must be pre-allocated.
 */
void 
MakeSegment(int ring1, int ring2, LPD3DTRIANGLE lpTri)
{
    int side, triangle = 0;

    for (side = 0; side < SIDES; side++) {
	/*
	 * Each side consists of two triangles.
	 */
	lpTri[triangle].v1 = ring1 * SIDES + side;
	lpTri[triangle].v2 = ring2 * SIDES + side;
	lpTri[triangle].v3 = ring2 * SIDES + ((side + 1) % SIDES);
	lpTri[triangle].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
	triangle++;
	lpTri[triangle].v2 = ring2 * SIDES + ((side + 1) % SIDES);
	lpTri[triangle].v3 = ring1 * SIDES + ((side + 1) % SIDES);
	lpTri[triangle].v1 = ring1 * SIDES + side;
	lpTri[triangle].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
	triangle++;
    }
}

/*
 * Creates a new segment of the tunnel at the current end position.
 * Creates a new ring and segment.
 */
void 
UpdateTubeInMemory(void)
{
    static int texRing = 0; /* Static counter defining the position of
    			     * this ring on the texture.
			     */
    int endRing; /* The ring at the end of the tube in memory. */
    int RingOffset, SegmentOffset; /* Offsets into the vertex and triangle 
				    * lists for the new data.
				    */
    void *pvBuf;
    
    /*
     * Replace the back ring with a new ring at the front of the tube
     * in memory.
     */
    memmove(&tube.lpV[SIDES], &tube.lpV[0], sizeof(tube.lpV[0]) * (NUM_V - SIDES));
    MakeRing(&tube.endP, &tube.endD, &tube.endN, texRing/(float)TEX_RINGS,
    	     &tube.lpV[0]);
    /*
     * Replace the back segment with a new segment at the front of the
     * tube in memory. Update the current end position of the tube in
     * memory.
     */
    endRing = (tube.currentRing + SEGMENTS) % (SEGMENTS + 1);
    MoveToPosition(tube.endPos, &tube.endP, &tube.endD, &tube.endN);
    /*
     * Update the execute buffer with the new vertices and triangles.
     */
    RingOffset = sizeof(D3DVERTEX) * tube.currentRing * SIDES;
    SegmentOffset = sizeof(D3DTRIANGLE) * tube.currentSegment * SIDES * 2;
    pvBuf = lpExBuf->Lock();
    if (pvBuf == NULL)
	return;
    memcpy(pvBuf, &tube.lpV[0], sizeof(D3DVERTEX) * NUM_V);
    lpExBuf->Unlock();
    if (!lpExBuf->Process())
    {
        // Nothing can be done
    }
    /*
     * Update the position of the back of the tube in memory and texture
     * counter.
     */
    tube.currentRing = (tube.currentRing + 1) % (SEGMENTS + 1);
    tube.currentSegment = (tube.currentSegment + 1) % SEGMENTS;
    texRing = (texRing + 1) % TEX_RINGS;
}


/*
 * Move the camera through the tunnel.  Create new segments of the tunnel
 * when the camera gets close to the end of the section in memory.
 */
void 
MoveCamera(void)
{
    /*
     * Update the position on curve and camera vectors.
     */
    tube.cameraPos += (float)SPEED;
    if (tube.cameraPos > PATH_LENGTH)
	tube.cameraPos -= PATH_LENGTH;
    MoveToPosition(tube.cameraPos, &tube.cameraP, &tube.cameraD,
    		   &tube.cameraN);
    /*
     * If the camera is close to the end, add a new segment.
     */
    if (tube.endPos - tube.cameraPos < DEPTH) {
	tube.endPos = tube.endPos + (float)SEGMENT_LENGTH;
	if (tube.endPos > PATH_LENGTH)
	    tube.endPos -= PATH_LENGTH;
	UpdateTubeInMemory();
    }
}


/*
 * Modify the buffer between rendering frames
 */
static void 
TickScene(void)
{
    MoveCamera();
}

/*
 * Each frame, renders the scene and calls TickScene to modify the object
 * for the next frame.
 */
BOOL
RenderScenePix(RendWindow *prwin, LPD3DRECT lpExtent)
{
    int i;

    /*
     * Move the camera by updating the view matrix and move the light.
     */
    PositionCamera(&tube.cameraP, &tube.cameraD, &tube.cameraN, &view);
    pView->Set(&view);

    tube.prlight->SetVector(&tube.cameraP);
    if (!prwin->BeginScene())
	return FALSE;
    if (!prwin->Execute(lpSpinBuffer))
	return FALSE;
    for (i = 0; (unsigned)i < OVERDRAW; i++) {
	if (!prwin->Execute(lpSetWorldExeBuf[i]))
	    return FALSE;
	if (!prwin->ExecuteClipped(lpExBuf))
	    return FALSE;
    }
    if (!prwin->EndScene(lpExtent))
	return FALSE;

    /*
     * By not chaning the extent, fullscreen in assumed.
     */
    /*
     * Modify for the next time around
     */
    TickScene();
    return TRUE;
}


BOOL
InitOtherBuffers(RendWindow *prwin, UINT overdraw, UINT order)
{    
    LPVOID lpBufStart, lpInsStart, lpPointer;
    DWORD size;
    D3DMATRIX temp;
    D3DVALUE scale;
    int i;

    MAKE_REND_MATRIX(prwin, pSpin, dmIdentity);
    MakeRotMatrix(&temp, (float)0, (float)0, (float)DSPIN);
    MAKE_REND_MATRIX(prwin, pDSpin, temp);

    size = 0;
    size += sizeof(D3DINSTRUCTION) * 2;
    size += sizeof(D3DMATRIXMULTIPLY) * 1;
    lpSpinBuffer = prwin->NewExecuteBuffer(size, stat.uiExeBufFlags);
    if (lpSpinBuffer == NULL)
	return FALSE;
    lpBufStart = lpSpinBuffer->Lock();
    if (lpBufStart == NULL)
    	return FALSE;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;
    lpInsStart = lpPointer;
    OP_MATRIX_MULTIPLY(1, lpPointer);
	MATRIX_MULTIPLY_REND_DATA(pDSpin, pSpin, pSpin, lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpSpinBuffer->Unlock();
    if (!lpSpinBuffer->Process())
    {
        return FALSE;
    }

    MAKE_REND_MATRIX(prwin, pWorld, dmIdentity);
    for (i = 0; (unsigned)i < overdraw; i++) {
	if (order == FRONT_TO_BACK) {
	    /*
	     * Each tunnel is slightly wider and further back
	     */
	    MakePosMatrix(&temp, 0.0f, 0.0f, (float)i / 5.0f);
	    scale = 1.0f + (float)i / 20.0f;
	    temp._11 = scale;
	    temp._22 = scale;
	} else if (order == BACK_TO_FRONT) {
	    /*
	     * Each tunnel is slightly thinner and closer
	     */
	    MakePosMatrix(&temp, 0.0f, 0.0f, (float)(overdraw - 1 - i) / 5.0f);
	    scale = 1.0f + (float)(overdraw - 1 - i) / 20.0f;
	    temp._11 = scale;
	    temp._22 = scale;
	} else {
	    MakePosMatrix(&temp, 0.0f, 0.0f, 0.0f);
	}
	MAKE_REND_MATRIX(prwin, pPos[i], temp);
	size = 0;
	size += sizeof(D3DINSTRUCTION) * 3;
	size += sizeof(D3DMATRIXMULTIPLY) * 1;
	size += sizeof(D3DSTATE) * 1;
        lpSetWorldExeBuf[i] = prwin->NewExecuteBuffer(size,
                                                      stat.uiExeBufFlags);
        if (lpSetWorldExeBuf[i] == NULL)
	    return FALSE;
        lpBufStart = lpSetWorldExeBuf[i]->Lock();
        if (lpBufStart == NULL)
            return FALSE;
	memset(lpBufStart, 0, size);
	lpPointer = lpBufStart;
	lpInsStart = lpPointer;
	OP_MATRIX_MULTIPLY(1, lpPointer);
	    MATRIX_MULTIPLY_REND_DATA(pSpin, pPos[i], pWorld, lpPointer);
	OP_STATE_TRANSFORM(1, lpPointer);
	    STATE_DATA(D3DTRANSFORMSTATE_WORLD, pWorld->Handle(), lpPointer);
	OP_EXIT(lpPointer);
	/*
	 * Setup the execute data describing the buffer
	 */
	lpSetWorldExeBuf[i]->Unlock();
	if (!lpSetWorldExeBuf[i]->Process())
        {
            return FALSE;
        }
    }
    return TRUE;    
}

BOOL
InitScene(void)
{
    float position;    		/* Curve position counter. */
    int i;    			/* counter */

    /*
     * Reserved memory for vertices, triangles and spline points.
     */
    tube.lpV = (LPD3DVERTEX) malloc(sizeof(D3DVERTEX) * NUM_V);
    tube.lpTri = (LPD3DTRIANGLE) malloc(sizeof(D3DTRIANGLE) * NUM_TRI);
    tube.lpPoints = (LPD3DVECTOR) malloc(sizeof(D3DVECTOR)*SPLINE_POINTS);
    /*
     * Generate spline points
     */
    for (i = 0; i < SPLINE_POINTS; i++) {
#if 0
	tube.lpPoints[i].x = (float)(cos(i * 4.0) * 20.0);
	tube.lpPoints[i].y = (float)(sin(i * 4.0) * 20.0);
	tube.lpPoints[i].z = i * (float)20.0;
#else
	tube.lpPoints[i].x = (float)0.0;
	tube.lpPoints[i].y = (float)0.0;
	tube.lpPoints[i].z = i * (float)20.0;
#endif
    }
    /*
     * Create the initial tube section in memory.
     */
    tube.endN.x = (float)0.0;
    tube.endN.y = (float)1.0;
    tube.endN.z = (float)0.0;
    position = (float)0.0;
    for (i = 0; i < SEGMENTS + 1; i++) {
	MoveToPosition(position, &tube.endP, &tube.endD, &tube.endN);
	position += (float)SEGMENT_LENGTH;
	MakeRing(&tube.endP, &tube.endD, &tube.endN, 
		 (float)(i % TEX_RINGS) / TEX_RINGS,
		 &tube.lpV[(SEGMENTS - i) * SIDES]);
    }
    for (i = 0; i < SEGMENTS; i++)
	MakeSegment(i + 1, i, &tube.lpTri[i * SIDES * 2]);
    /*
     * Move the camera to the begining and set some globals
     */
    tube.cameraN.x = (float)0.0;
    tube.cameraN.y = (float)1.0;
    tube.cameraN.z = (float)0.0;
    MoveToPosition((float)0.0, &tube.cameraP, &tube.cameraD, &tube.cameraN);
    tube.currentRing = 0;
    tube.currentSegment = 0;
    tube.cameraPos = (float)0.0;
    tube.endPos = position;
    return TRUE;
}

void
ReleaseScene(void)
{
    if (tube.lpPoints)
        free(tube.lpPoints);
    if (tube.lpTri)
        free(tube.lpTri);
    if (tube.lpV)
        free(tube.lpV);
}

void
ReleaseViewPix(void)
{
    RELEASE(lpExBuf);
    RELEASE(tube.prlight);
    RELEASE(lpmat);
    ReleaseScene();
}

/*
 * Builds the scene and initializes the execute buffer for rendering.
 * Returns 0 on failure.
 */
unsigned long
InitViewPix(RendWindow *prwin, int NumTextures,
            RendTexture **pprtex, UINT w, UINT h, UINT overdraw, UINT order)
{
    /* Variables for exectue buffer generation */
    LPVOID lpBufStart, lpInsStart, lpPointer;
    RendExecuteBuffer *lpExCmdBuf;
    DWORD size;
    D3DCOLORVALUE dcol;

    if (!InitScene())
	return 0L;
    OVERDRAW = overdraw;
    ORDER = order;

    if (!InitOtherBuffers(prwin, overdraw, order))
	return FALSE;
    
    /*
     * Set the view, projection and world matricies in an execute buffer
     */
    MAKE_REND_MATRIX(prwin, pView, view);
    MAKE_REND_MATRIX(prwin, pProj, proj);
    /*
     * Create an execute buffer
     */
    size = 0;
    size += sizeof(D3DINSTRUCTION) * 3;
    size += sizeof(D3DSTATE) * 3;
    lpExCmdBuf = prwin->NewExecuteBuffer(size, stat.uiExeBufFlags);
    if (lpExCmdBuf == NULL)
        return 0L;
    lpBufStart = lpExCmdBuf->Lock();
    if (lpBufStart == NULL)
	return 0L;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;
    /*
     * Fill the execute buffer with instructions
     */
    lpInsStart = lpPointer;
    OP_STATE_TRANSFORM(2, lpPointer);
        STATE_DATA(D3DTRANSFORMSTATE_VIEW, pView->Handle(), lpPointer);
        STATE_DATA(D3DTRANSFORMSTATE_PROJECTION, pProj->Handle(), lpPointer);
    OP_STATE_LIGHT(1, lpPointer);
        STATE_DATA(D3DLIGHTSTATE_AMBIENT, RGBA_MAKE(40, 40, 40, 40),
                   lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpExCmdBuf->Unlock();
    if (!lpExCmdBuf->Process())
    {
        return 0L;
    }
    prwin->BeginScene();
    prwin->Execute(lpExCmdBuf);
    prwin->EndScene(NULL);
    /*
     * We are done with the command buffer.
     */
    lpExCmdBuf->Release();
    /*
     * Setup materials and lights
     */
    tube.pTex = pprtex[1];
    lpmat = prwin->NewMaterial(16);
    if (lpmat == NULL)
	return 0L;
    dcol.r = D3DVAL(1);
    dcol.g = D3DVAL(1);
    dcol.b = D3DVAL(1);
    dcol.a = D3DVAL(1);
    lpmat->SetDiffuse(&dcol);
    lpmat->SetSpecular(&dcol, 20.0f);
    lpmat->SetTexture(tube.pTex);
    tube.pMat = lpmat;
    tube.prlight = prwin->NewLight(REND_LIGHT_POINT);
    if (tube.prlight == NULL)
        return 0L;
    dcol.r = D3DVAL(0.9);
    dcol.g = D3DVAL(0.9);
    dcol.b = D3DVAL(0.9);
    dcol.a = D3DVAL(1.0);
    tube.prlight->SetColor(&dcol);
    tube.prlight->SetVector(&tube.cameraP);
    tube.prlight->SetAttenuation(0.0f, 0.0f, 0.05f);

    /*
     * Create an execute buffer
     */
    size = sizeof(D3DVERTEX) * NUM_V;
    size += sizeof(D3DPROCESSVERTICES);
    size += sizeof(D3DINSTRUCTION) * 40;
    size += sizeof(D3DSTATE) * 7;
    size += sizeof(D3DTRIANGLE) * NUM_TRI;
    lpExBuf = prwin->NewExecuteBuffer(size, stat.uiExeBufFlags);
    if (lpExBuf == NULL)
	return 0L;
    /*
     * lock it so it can be filled
     */
    lpBufStart = lpExBuf->Lock();
    if (lpBufStart == NULL)
	return FALSE;
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;
    VERTEX_DATA(tube.lpV, NUM_V, lpPointer);
    /*
     * Save the location of the first instruction and add instructions to
     * execute buffer.
     */
    lpInsStart = lpPointer;
    OP_STATE_LIGHT(1, lpPointer);
        STATE_DATA(D3DLIGHTSTATE_MATERIAL, tube.pMat->Handle(), lpPointer);
    OP_PROCESS_VERTICES(1, lpPointer);
        PROCESSVERTICES_DATA(D3DPROCESSVERTICES_TRANSFORMLIGHT,
                             0, NUM_V, lpPointer);
    OP_STATE_RENDER(3, lpPointer);
        STATE_DATA(D3DRENDERSTATE_TEXTUREHANDLE,
                   (tube.pTex != NULL ? tube.pTex->Handle() : 0),
                   lpPointer);
        STATE_DATA(D3DRENDERSTATE_WRAPU, TRUE, lpPointer);
        STATE_DATA(D3DRENDERSTATE_WRAPV, TRUE, lpPointer);
    /*
     * Make sure that the triangle data (not OP) will be QWORD aligned
     */
    if (QWORD_ALIGNED(lpPointer)) {
	OP_NOP(lpPointer);
    }
    OP_TRIANGLE_LIST(NUM_TRI, lpPointer);
        tube.TriOffset = (char *)lpPointer - (char *)lpBufStart;
        TRIANGLE_LIST_DATA(tube.lpTri, NUM_TRI, lpPointer);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data describing the buffer
     */
    lpExBuf->Unlock();
    lpExBuf->SetData(NUM_V,
                     (ULONG) ((char *)lpInsStart - (char *)lpBufStart),
                     (ULONG) ((char *)lpPointer - (char *)lpInsStart));
    if (!lpExBuf->Process())
    {
        return 0L;
    }

    return w * h * overdraw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\polytest.h ===
#ifndef __POLYTEST_H__
#define __POLYTEST_H__

// Polygon throughput test functions
BOOL RenderScenePoly(RendWindow *prwin, LPD3DRECT pdrc);
void ReleaseViewPoly(void);
unsigned long
InitViewPoly(RendWindow *prwin,
	     int nTextures, RendTexture **pptex,
             UINT uiSpheres, UINT uiRings, UINT uiSegs, UINT uiOrder,
             float fRadius, float fD, float fDepth,
	     float fDv, float fDr, BOOL bAlpha);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\sfiltest.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: sfiltest.cpp
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "rend.h"
#include "globals.h"

static RendExecuteBuffer *lpExBuf;
static RendMaterial *lpMat;
static UINT NumTri;
static long TriArea;

BOOL
RenderSceneSimple(RendWindow *prwin, LPD3DRECT lpExtent)
{
    /*
     * Execute the instruction buffer
     */
    if (!prwin->BeginScene())
        return FALSE;
    if (!prwin->Execute(lpExBuf))
        return FALSE;
    if (!prwin->EndScene(lpExtent))
        return FALSE;
    return TRUE;
}

void
ReleaseViewSimple(void)
{
    RELEASE(lpExBuf);
    RELEASE(lpMat);
}

#define TAN_60 1.732

static float ox, oy;

void
SetTriangleVertices(LPD3DTLVERTEX v, float z, UINT ww, UINT wh, float a)
{
    float dx, dy;
    float b = (float)sqrt((4 * a) / TAN_60);
    float h = (2 * a) / b;
    float x = (float)((b / 2) * (TAN_60 / 2));
    float cx, cy;
    
    dx = (float)ww;
    dy = (float)wh;
    
    cx = dx / 2;
    cy = dy / 2;
    
    /* V 0 */
    v[0].sx = cx;
    v[0].sy = cy - (h - x);
    v[0].sz = z;
    v[0].rhw = D3DVAL(1.0);
    v[0].color = RGB_MAKE(255, 0, 0);
    v[0].tu = D3DVAL(0.5);
    v[0].tv = D3DVAL(0.0);
    /* V 1 */
    v[1].sx = cx + (b / 2);
    v[1].sy = cy + x;
    v[1].sz = z;
    v[1].rhw = D3DVAL(1.0);
    v[1].color = RGB_MAKE(255, 255, 255);
    v[1].tu = D3DVAL(1.0);
    v[1].tv = D3DVAL(1.0);
    /* V 2 */
    v[2].sx = cx - (b / 2);
    v[2].sy = cy + x;
    v[2].sz = z;
    v[2].rhw = D3DVAL(1.0);
    v[2].color = RGB_MAKE(255, 255, 0);
    v[2].tu = D3DVAL(0.0);
    v[2].tv = D3DVAL(1.0);

#ifdef OFFSET
    v[0].sx += ox;
    v[0].sy += oy;
    v[1].sx += ox;
    v[1].sy += oy;
    v[2].sx += ox;
    v[2].sy += oy;
    ox += 4;
    oy += 4;
#endif
}

LPVOID
SetTriangleData(LPVOID lpPointer, int v)
{
    ((LPD3DTRIANGLE)lpPointer)->v1 = v;
    ((LPD3DTRIANGLE)lpPointer)->v2 = v + 1;
    ((LPD3DTRIANGLE)lpPointer)->v3 = v + 2;
    ((LPD3DTRIANGLE)lpPointer)->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
    lpPointer = ((char*)lpPointer) + sizeof(D3DTRIANGLE);
    return lpPointer;
}

unsigned long
InitViewSimple(RendWindow *prwin, int nTextures,
               RendTexture **pprtex, UINT w, UINT h, float area,
               UINT order, UINT num)
{
    LPVOID lpBufStart, lpInsStart, lpPointer;
    size_t size;
    LPD3DTLVERTEX src_v;
    UINT i;
    float z;
    D3DCOLORVALUE dcv;

    NumTri = num;
    src_v = (LPD3DTLVERTEX)malloc(3 * NumTri * sizeof(D3DTLVERTEX));
    TriArea = (long)(area + 0.5);

    lpMat = prwin->NewMaterial(1);
    if (lpMat == NULL)
    {
	return FALSE;
    }
    dcv.r = D3DVAL(1.0);
    dcv.g = D3DVAL(1.0);
    dcv.b = D3DVAL(1.0);
    dcv.a = D3DVAL(1.0);
    lpMat->SetDiffuse(&dcv);

    /*
     * Setup vertices
     */
#ifdef OFFSET
    ox = -100.0f;
    oy = -100.0f;
#endif
    memset(&src_v[0], 0, sizeof(D3DTLVERTEX) * 3 * NumTri);
    if (order == FRONT_TO_BACK) {
	for (i = 0, z = (float)0.0; i < NumTri; i++, z += (float)0.9 / NumTri)
	    SetTriangleVertices(&src_v[3*i], z, w, h, area);
    } else {
	for (i = 0, z = (float)0.9; i < NumTri; i++, z -= (float)0.9 / NumTri)
	    SetTriangleVertices(&src_v[3*i], z, w, h, area);

    }
    /*
     * Create an execute buffer
     */
    size = sizeof(D3DTLVERTEX) * 3 * NumTri;
    size += sizeof(D3DINSTRUCTION) * 5;
    size += sizeof(D3DPROCESSVERTICES);
    size += sizeof(D3DSTATE) * 4;
    size += sizeof(D3DTRIANGLE) * NumTri;
    lpExBuf = prwin->NewExecuteBuffer(size, stat.uiExeBufFlags);
    if (lpExBuf == NULL)
    {
	return 0L;
    }
    lpBufStart = lpExBuf->Lock();
    if (lpBufStart == NULL)
    {
	return 0L;
    }
    memset(lpBufStart, 0, size);
    lpPointer = lpBufStart;
    /*
     * Copy vertices to execute buffer
     */
    memcpy(lpPointer, &src_v[0], 3 * NumTri * sizeof(D3DTLVERTEX));
    lpPointer = &((LPD3DTLVERTEX)lpPointer)[3 * NumTri];
    /*
     * Setup instructions in execute buffer
     */
    lpInsStart = lpPointer;
    OP_STATE_LIGHT(1, lpPointer);
        STATE_DATA(D3DLIGHTSTATE_MATERIAL, lpMat->Handle(), lpPointer);
    OP_PROCESS_VERTICES(1, lpPointer);
        PROCESSVERTICES_DATA(D3DPROCESSVERTICES_COPY, 0, 3 * NumTri,
                             lpPointer);
    OP_STATE_RENDER(3, lpPointer);
        STATE_DATA(D3DRENDERSTATE_TEXTUREHANDLE,
                   pprtex[1] != NULL ? pprtex[1]->Handle() : 0,
                   lpPointer);
        STATE_DATA(D3DRENDERSTATE_WRAPU, FALSE, lpPointer);
        STATE_DATA(D3DRENDERSTATE_WRAPV, FALSE, lpPointer);
    OP_TRIANGLE_LIST(NumTri, lpPointer);
        for (i = 0; i < NumTri; i++)
            lpPointer = SetTriangleData(lpPointer, 3 * i);
    OP_EXIT(lpPointer);
    /*
     * Setup the execute data
     */
    lpExBuf->Unlock();
    lpExBuf->SetData(3 * NumTri,
                     (ULONG) ((char *)lpInsStart - (char *)lpBufStart),
                     (ULONG) ((char *)lpPointer - (char *)lpInsStart));
    if (!lpExBuf->Process())
    {
        return 0;
    }
    free(src_v);
    return TriArea * NumTri;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gfxperf.rc
//
#define IDI_ICON1                       105
#define DISPLAY_LIST                    1001
#define ZBUFFER_CHECK                   1002
#define TEXTURES_CHECK                  1003
#define PERSP_CHECK                     1004
#define FLAT_RADIO                      1007
#define GOURAUD_RADIO                   1008
#define RENDER_MONO_RADIO               1009
#define MONO_RADIO                      1009
#define EXIT_BUTTON                     1010
#define RENDER_RGB_RADIO                1011
#define RGB_RADIO                       1011
#define LAST_RESULT_TEXT                1016
#define PEAK_RESULT_TEXT                1017
#define POINT_RADIO                     1022
#define BILINEAR_RADIO                  1023
#define GRAPHICS_LIST                   1029
#define SPECULAR_CHECK                  1031
#define FRONT_TO_BACK_RADIO             1032
#define BACK_TO_FRONT_RADIO             1033
#define SYSTEM_MEMORY_CHECK             1034
#define NO_UPDATES_CHECK                1035
#define ALL_TESTS_BUTTON                1036
#define RUN_TEST_BUTTON                 1037
#define COPY_RADIO                      1046
#define RENDERER_LIST                   1047
#define MODULATE_RADIO                  1048
#define TEST_LISTBOX                    1049
#define TEST_NAME_TEXT                  1050
#define SINGLE_STEP_CHECK               1052
#define LAST_RESULT_UNITS               1054
#define PEAK_RESULT_UNITS               1055

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1056
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\util.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation. All Rights Reserved.
 *
 *  File: util.h
 *
 ***************************************************************************/
#ifndef __UTIL_H__
#define __UTIL_H__

#define MIN(x, y) (((x) > (y)) ? (y) : (x))
#define MAX(x, y) (((x) > (y)) ? (x) : (y))

#define NEXT_PDINST(pdinst) \
    ((D3DINSTRUCTION *) \
     ((BYTE *)(pdinst)+(ULONG)(pdinst)->bSize*(pdinst)->wCount+ \
     sizeof(D3DINSTRUCTION)))

extern D3DMATRIX dmIdentity;

void TransposeMatrix(D3DMATRIX* pdmSrc, D3DMATRIX* pdmDst);

float Timer(void);
void ResetTimer(void);

void InitRandom(void);
float Random(float fRange);

void MakePosMatrix(LPD3DMATRIX lpM, float x, float y, float z);
void MakeRotMatrix(LPD3DMATRIX lpM, float rx, float ry, float rz);

void dpf( LPSTR fmt, ... );

/*
 * Msg
 * Reports errors as dialog box.
 */
void Msg( LPSTR fmt, ... );

BOOL
GetDDSurfaceDesc(LPDDSURFACEDESC lpDDSurfDesc, LPDIRECTDRAWSURFACE lpDDSurf);

/*
 * Converts a DD or D3D error to a string
 */
char* D3dErrorString(HRESULT error);

void CleanUpAndPostQuit(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\sfiltest.h ===
#ifndef __SFILTEST_H__
#define __SFILTEST_H__

unsigned long
InitViewSimple(RendWindow *prwin, int nTextures,
               RendTexture **pprtex, UINT uiWidth, UINT uiHeight, float fArea,
               UINT uiOrder, UINT uiOverdraw);
BOOL
RenderSceneSimple(RendWindow *prwin, LPD3DRECT pdrc);
void
ReleaseViewSimple(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\rend.h ===
#ifndef __REND_H__
#define __REND_H__

// An opaque object handle for something returned by a renderer
// RendIds are persistent as long as the referenced object is alive
typedef void* RendId;

// A simple driver description callback
// The rid must be persistent so an app can enumerate and use it later
#define REND_DRIVER_NAME_LENGTH 64
struct RendDriverDescription
{
    RendId rid;
    char achName[REND_DRIVER_NAME_LENGTH];
};
typedef BOOL (*RendEnumDriversFn)(RendDriverDescription* prdd, void* pvArg);

#define REND_BUFFER_FRONT               0x0001
#define REND_BUFFER_BACK                0x0002
#define REND_BUFFER_Z                   0x0004
#define REND_BUFFER_VIDEO_MEMORY        0x4000
#define REND_BUFFER_SYSTEM_MEMORY       0x8000

#define REND_LIGHT_DIRECTIONAL  0
#define REND_LIGHT_POINT        1

// Very simple display description
struct RendDisplayDescription
{
    BOOL bPrimary;
    UINT nColorBits;
    UINT uiWidth, uiHeight;
};

// Very simple graphics description
#define REND_COLOR_RGBA         1
#define REND_COLOR_MONO         2
struct RendGraphicsDescription
{
    UINT uiColorTypes;
    UINT nZBits;
    UINT uiExeBufFlags;
    BOOL bHardwareAssisted;
    BOOL bPerspectiveCorrect;
    BOOL bSpecularLighting;
    BOOL bCopyTextureBlend;
};
    
class RendExecuteBuffer
{
public:
    virtual void  Release(void) = 0;
    
    virtual void* Lock(void) = 0;
    virtual void  Unlock(void) = 0;

    // Data defaults to no vertices, start at zero and size equal
    // to the execubte buffer size
    virtual void  SetData(UINT nVertices, UINT cbStart, UINT cbSize) = 0;

    // Process must be called after data is put into or changed in
    // the execute buffer, after any SetData calls and before Execute
    // is called on the buffer
    virtual BOOL  Process(void) = 0;
};

class RendLight
{
public:
    virtual void Release(void) = 0;

    // Defaults to 1,1,1,1
    // Affects both ambient and diffuse
    // Specular is always set to 1,1,1,1
    virtual void SetColor(D3DCOLORVALUE *pdcol) = 0;
    // Defaults to 0,0,1
    virtual void SetVector(D3DVECTOR *pdvec) = 0;
    // Defaults to 1,0,0
    virtual void SetAttenuation(float fConstant, float fLinear,
                                float fQuadratic) = 0;
};

class RendTexture
{
public:
    virtual void Release(void) = 0;
    
    virtual D3DTEXTUREHANDLE Handle(void) = 0;
};

class RendMatrix
{
public:
    virtual void Release(void) = 0;
    
    virtual D3DMATRIXHANDLE Handle(void) = 0;

    virtual void Get(D3DMATRIX* pdm) = 0;
    virtual void Set(D3DMATRIX* pdm) = 0;
};

class RendMaterial
{
public:
    virtual void Release(void) = 0;

    virtual D3DMATERIALHANDLE Handle(void) = 0;

    // Defaults to 1,1,1,1, also used for ambient light
    virtual void SetDiffuse(D3DCOLORVALUE* pdcol) = 0;
    // Defaults to 0,0,0,0, power 0
    virtual void SetSpecular(D3DCOLORVALUE* pdcol, float fPower) = 0;
    
    // Defaults to nothing
    virtual void SetTexture(RendTexture *prtex) = 0;
};

class RendWindow
{
public:
    virtual void Release(void) = 0;

    // Defaults to the size of the window
    virtual BOOL SetViewport(int x, int y, UINT uiWidth, UINT uiHeight) = 0;

    virtual RendLight*         NewLight(int iType) = 0;
    virtual RendTexture*       NewTexture(char *pszFile, UINT uiFlags) = 0;
    virtual RendExecuteBuffer* NewExecuteBuffer(UINT cbSize, UINT uiFlags) = 0;
    virtual RendMatrix*        NewMatrix(void) = 0;
    virtual RendMaterial*      NewMaterial(UINT nColorEntries) = 0;
    
    virtual BOOL BeginScene(void) = 0;
    virtual BOOL Execute(RendExecuteBuffer* preb) = 0;
    virtual BOOL ExecuteClipped(RendExecuteBuffer* preb) = 0;
    // pdrcBound can be NULL
    virtual BOOL EndScene(D3DRECT* pdrcBound) = 0;

    // pdrc can be NULL
    virtual BOOL Clear(UINT uiBuffers, D3DRECT* pdrc) = 0;
    virtual BOOL Flip(void) = 0;
    // pdrc can be NULL
    virtual BOOL CopyForward(D3DRECT* pdrc) = 0;

    // Waits for a key or button press
    virtual HWND Handle(void) = 0;
};

class Renderer
{
public:
    // Buffer must be at least REND_DRIVER_NAME_LENGTH
    // Called outside initialize
    virtual void Name(char* psz) = 0;

    // Can be called at any time
    virtual char* LastErrorString(void) = 0;
    
    virtual BOOL Initialize(HWND hwndParent) = 0;
    virtual void Uninitialize(void) = 0;

    virtual BOOL EnumDisplayDrivers(RendEnumDriversFn pfn,
                                    void* pvArg) = 0;
    virtual BOOL EnumGraphicsDrivers(RendEnumDriversFn pfn,
                                     void* pvArg) = 0;
    
    virtual BOOL SelectDisplayDriver(RendId rid) = 0;
    virtual BOOL SelectGraphicsDriver(RendId rid) = 0;

    virtual BOOL DescribeDisplay(RendDisplayDescription* prdd) = 0;
    virtual BOOL DescribeGraphics(RendGraphicsDescription* prgd) = 0;
    
    virtual BOOL FlipToDesktop(void) = 0;
    virtual BOOL RestoreDesktop(void) = 0;
    
    virtual RendWindow* NewWindow(int x, int y,
                                  UINT uiWidth, UINT uiHeight,
                                  UINT uiBuffers) = 0;
};

#define MAKE_REND_MATRIX(prwin, prm, dm) \
    if (((prm) = (prwin)->NewMatrix()) == NULL) \
    { \
        return FALSE; \
    } \
    else \
    { \
        (prm)->Set(&(dm)); \
    }
#define MATRIX_MULTIPLY_REND_DATA(prm1, prm2, prm3, pv) \
    MATRIX_MULTIPLY_DATA((prm1)->Handle(), (prm2)->Handle(), \
                         (prm3)->Handle(), (pv))

#define RENDERER_D3D    0
#define RENDERER_GL     1
#define RENDERER_COUNT  2

Renderer* GetD3dRenderer(void);
Renderer* GetGlRenderer(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\uuid.c ===
#define INITGUID
#include <d3d.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\gfxperf\util.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include <stdarg.h>

#include "globals.h"
#include "util.h"

D3DMATRIX dmIdentity =
{
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0)
};

// Utility function for transposing matrices
// Src can not equal Dst
void TransposeMatrix(D3DMATRIX* pdmSrc, D3DMATRIX* pdmDst)
{
    int i, j;

    for (i = 0; i < 4; i++)
    {
	for (j = 0; j < 4; j++)
	{
	    *((D3DVALUE *)pdmDst+j+i*4) = *((D3DVALUE *)pdmSrc+i+j*4);
	}
    }
}

static time_t tmStartTime;

float
Timer(void)
{
    time_t tmNow;
    
    tmNow = clock();
    return ((float)(tmNow - tmStartTime)) / (float)CLOCKS_PER_SEC;
}

void
ResetTimer(void)
{
    tmStartTime = clock();
}

void
InitRandom(void)
{
    srand( (unsigned)8269362521);
}

float
Random(float fRange)
{
    return ((float)rand() / RAND_MAX) * fRange;
}

void
MakePosMatrix(LPD3DMATRIX lpM, float x, float y, float z)
{
    memcpy(lpM, &dmIdentity, sizeof(D3DMATRIX));
    lpM->_41 = D3DVAL(x);
    lpM->_42 = D3DVAL(y);
    lpM->_43 = D3DVAL(z);
}

void
MakeRotMatrix(LPD3DMATRIX lpM, float rx, float ry, float rz)
{
    float ct, st;
    D3DMATRIX My, Mx, Mz, T;
    
    memcpy(&My, &dmIdentity, sizeof(D3DMATRIX));
    ct = D3DVAL(cos(ry));
    st = D3DVAL(sin(ry));
    My._11 = ct;
    My._13 = -st;
    My._31 = st;
    My._33 = ct;
    memcpy(&Mx, &dmIdentity, sizeof(D3DMATRIX));
    ct = D3DVAL(cos(rx));
    st = D3DVAL(sin(rx));
    Mx._22 = ct;
    Mx._23 = st;
    Mx._32 = -st;
    Mx._33 = ct;
    memcpy(&Mz, &dmIdentity, sizeof(D3DMATRIX));
    ct = D3DVAL(cos(rz));
    st = D3DVAL(sin(rz));
    Mz._11 = ct;
    Mz._12 = st;
    Mz._21 = -st;
    Mz._22 = ct;
    MultiplyD3DMATRIX(&T, &My, &Mx);
    MultiplyD3DMATRIX(lpM, &T, &Mz);
}

/*************************************************************************
    Error reporting functions
 *************************************************************************/

void
dpf( LPSTR fmt, ... )
{
    char buff[256];
    va_list args;

    lstrcpy(buff, "GFXPERF: " );
    va_start(args, fmt);
    wvsprintf(&buff[lstrlen(buff)], fmt, args);
    va_end(args);
    lstrcat(buff, "\r\n");
    OutputDebugString(buff);
}

/* Msg
 * Message output for error notification.
 */
void __cdecl
Msg( LPSTR fmt, ... )
{
    char buff[256];
    va_list args;

    app.bTestInProgress = FALSE;
    lstrcpy(buff, "GFXPERF: " );
    va_start(args, fmt);
    wvsprintf(&buff[lstrlen(buff)], fmt, args);
    lstrcat(buff, "\r\n");
    OutputDebugString(buff);
    va_end(args);
    va_start(args, fmt);
    wvsprintf(buff, fmt, args);
    va_end(args);
    stat.bStopRendering = TRUE;
    if (app.bFullscreen) {
	app.prend->FlipToDesktop();
    }
    MessageBox( NULL, buff, "GfxPerf Message", MB_OK );
}

/*
 * GetDDSurfaceDesc
 * Gets a surface description.
 */
BOOL
GetDDSurfaceDesc(LPDDSURFACEDESC lpDDSurfDesc, LPDIRECTDRAWSURFACE lpDDSurf)
{
    HRESULT hr;
    
    memset(lpDDSurfDesc, 0, sizeof(DDSURFACEDESC));
    lpDDSurfDesc->dwSize = sizeof(DDSURFACEDESC);
    hr = lpDDSurf->GetSurfaceDesc(lpDDSurfDesc);
    if (hr != DD_OK) {
	Msg("Error getting a surface description.\n%s",
	    D3dErrorString(hr));
	CleanUpAndPostQuit();
	return FALSE;
    }
    return TRUE;
}

/*
 * D3dErrorString
 * Returns a pointer to a string describing the given error code.
 */
char*
D3dErrorString(HRESULT error)
{
    switch(error) {
	case DD_OK:
	    return "No error.\0";
	case DDERR_ALREADYINITIALIZED:
	    return "This object is already initialized.\0";
	case DDERR_BLTFASTCANTCLIP:
	    return "Return if a clipper object is attached to the source surface passed into a BltFast call.\0";
	case DDERR_CANNOTATTACHSURFACE:
	    return "This surface can not be attached to the requested surface.\0";
	case DDERR_CANNOTDETACHSURFACE:
	    return "This surface can not be detached from the requested surface.\0";
	case DDERR_CANTCREATEDC:
	    return "Windows can not create any more DCs.\0";
	case DDERR_CANTDUPLICATE:
	    return "Can't duplicate primary & 3D surfaces, or surfaces that are implicitly created.\0";
	case DDERR_CLIPPERISUSINGHWND:
	    return "An attempt was made to set a cliplist for a clipper object that is already monitoring an hwnd.\0";
	case DDERR_COLORKEYNOTSET:
	    return "No src color key specified for this operation.\0";
	case DDERR_CURRENTLYNOTAVAIL:
	    return "Support is currently not available.\0";
	case DDERR_DIRECTDRAWALREADYCREATED:
	    return "A DirectDraw object representing this driver has already been created for this process.\0";
	case DDERR_EXCEPTION:
	    return "An exception was encountered while performing the requested operation.\0";
	case DDERR_EXCLUSIVEMODEALREADYSET:
	    return "An attempt was made to set the cooperative level when it was already set to exclusive.\0";
	case DDERR_GENERIC:
	    return "Generic failure.\0";
	case DDERR_HEIGHTALIGN:
	    return "Height of rectangle provided is not a multiple of reqd alignment.\0";
	case DDERR_HWNDALREADYSET:
	    return "The CooperativeLevel HWND has already been set. It can not be reset while the process has surfaces or palettes created.\0";
	case DDERR_HWNDSUBCLASSED:
	    return "HWND used by DirectDraw CooperativeLevel has been subclassed, this prevents DirectDraw from restoring state.\0";
	case DDERR_IMPLICITLYCREATED:
	    return "This surface can not be restored because it is an implicitly created surface.\0";
	case DDERR_INCOMPATIBLEPRIMARY:
	    return "Unable to match primary surface creation request with existing primary surface.\0";
	case DDERR_INVALIDCAPS:
	    return "One or more of the caps bits passed to the callback are incorrect.\0";
	case DDERR_INVALIDCLIPLIST:
	    return "DirectDraw does not support the provided cliplist.\0";
	case DDERR_INVALIDDIRECTDRAWGUID:
	    return "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver identifier.\0";
	case DDERR_INVALIDMODE:
	    return "DirectDraw does not support the requested mode.\0";
	case DDERR_INVALIDOBJECT:
	    return "DirectDraw received a pointer that was an invalid DIRECTDRAW object.\0";
	case DDERR_INVALIDPARAMS:
	    return "One or more of the parameters passed to the function are incorrect.\0";
	case DDERR_INVALIDPIXELFORMAT:
	    return "The pixel format was invalid as specified.\0";
	case DDERR_INVALIDPOSITION:
	    return "Returned when the position of the overlay on the destination is no longer legal for that destination.\0";
	case DDERR_INVALIDRECT:
	    return "Rectangle provided was invalid.\0";
	case DDERR_LOCKEDSURFACES:
	    return "Operation could not be carried out because one or more surfaces are locked.\0";
	case DDERR_NO3D:
	    return "There is no 3D present.\0";
	case DDERR_NOALPHAHW:
	    return "Operation could not be carried out because there is no alpha accleration hardware present or available.\0";
	case DDERR_NOBLTHW:
	    return "No blitter hardware present.\0";
	case DDERR_NOCLIPLIST:
	    return "No cliplist available.\0";
	case DDERR_NOCLIPPERATTACHED:
	    return "No clipper object attached to surface object.\0";
	case DDERR_NOCOLORCONVHW:
	    return "Operation could not be carried out because there is no color conversion hardware present or available.\0";
	case DDERR_NOCOLORKEY:
	    return "Surface doesn't currently have a color key\0";
	case DDERR_NOCOLORKEYHW:
	    return "Operation could not be carried out because there is no hardware support of the destination color key.\0";
	case DDERR_NOCOOPERATIVELEVELSET:
	    return "Create function called without DirectDraw object method SetCooperativeLevel being called.\0";
	case DDERR_NODC:
	    return "No DC was ever created for this surface.\0";
	case DDERR_NODDROPSHW:
	    return "No DirectDraw ROP hardware.\0";
	case DDERR_NODIRECTDRAWHW:
	    return "A hardware-only DirectDraw object creation was attempted but the driver did not support any hardware.\0";
	case DDERR_NOEMULATION:
	    return "Software emulation not available.\0";
	case DDERR_NOEXCLUSIVEMODE:
	    return "Operation requires the application to have exclusive mode but the application does not have exclusive mode.\0";
	case DDERR_NOFLIPHW:
	    return "Flipping visible surfaces is not supported.\0";
	case DDERR_NOGDI:
	    return "There is no GDI present.\0";
	case DDERR_NOHWND:
	    return "Clipper notification requires an HWND or no HWND has previously been set as the CooperativeLevel HWND.\0";
	case DDERR_NOMIRRORHW:
	    return "Operation could not be carried out because there is no hardware present or available.\0";
	case DDERR_NOOVERLAYDEST:
	    return "Returned when GetOverlayPosition is called on an overlay that UpdateOverlay has never been called on to establish a destination.\0";
	case DDERR_NOOVERLAYHW:
	    return "Operation could not be carried out because there is no overlay hardware present or available.\0";
	case DDERR_NOPALETTEATTACHED:
	    return "No palette object attached to this surface.\0";
	case DDERR_NOPALETTEHW:
	    return "No hardware support for 16 or 256 color palettes.\0";
	case DDERR_NORASTEROPHW:
	    return "Operation could not be carried out because there is no appropriate raster op hardware present or available.\0";
	case DDERR_NOROTATIONHW:
	    return "Operation could not be carried out because there is no rotation hardware present or available.\0";
	case DDERR_NOSTRETCHHW:
	    return "Operation could not be carried out because there is no hardware support for stretching.\0";
	case DDERR_NOT4BITCOLOR:
	    return "DirectDrawSurface is not in 4 bit color palette and the requested operation requires 4 bit color palette.\0";
	case DDERR_NOT4BITCOLORINDEX:
	    return "DirectDrawSurface is not in 4 bit color index palette and the requested operation requires 4 bit color index palette.\0";
	case DDERR_NOT8BITCOLOR:
	    return "DirectDrawSurface is not in 8 bit color mode and the requested operation requires 8 bit color.\0";
	case DDERR_NOTAOVERLAYSURFACE:
	    return "Returned when an overlay member is called for a non-overlay surface.\0";
	case DDERR_NOTEXTUREHW:
	    return "Operation could not be carried out because there is no texture mapping hardware present or available.\0";
	case DDERR_NOTFLIPPABLE:
	    return "An attempt has been made to flip a surface that is not flippable.\0";
	case DDERR_NOTFOUND:
	    return "Requested item was not found.\0";
	case DDERR_NOTLOCKED:
	    return "Surface was not locked.  An attempt to unlock a surface that was not locked at all, or by this process, has been attempted.\0";
	case DDERR_NOTPALETTIZED:
	    return "The surface being used is not a palette-based surface.\0";
	case DDERR_NOVSYNCHW:
	    return "Operation could not be carried out because there is no hardware support for vertical blank synchronized operations.\0";
	case DDERR_NOZBUFFERHW:
	    return "Operation could not be carried out because there is no hardware support for zbuffer blitting.\0";
	case DDERR_NOZOVERLAYHW:
	    return "Overlay surfaces could not be z layered based on their BltOrder because the hardware does not support z layering of overlays.\0";
	case DDERR_OUTOFCAPS:
	    return "The hardware needed for the requested operation has already been allocated.\0";
	case DDERR_OUTOFMEMORY:
	    return "DirectDraw does not have enough memory to perform the operation.\0";
	case DDERR_OUTOFVIDEOMEMORY:
	    return "DirectDraw does not have enough memory to perform the operation.\0";
	case DDERR_OVERLAYCANTCLIP:
	    return "The hardware does not support clipped overlays.\0";
	case DDERR_OVERLAYCOLORKEYONLYONEACTIVE:
	    return "Can only have ony color key active at one time for overlays.\0";
	case DDERR_OVERLAYNOTVISIBLE:
	    return "Returned when GetOverlayPosition is called on a hidden overlay.\0";
	case DDERR_PALETTEBUSY:
	    return "Access to this palette is being refused because the palette is already locked by another thread.\0";
	case DDERR_PRIMARYSURFACEALREADYEXISTS:
	    return "This process already has created a primary surface.\0";
	case DDERR_REGIONTOOSMALL:
	    return "Region passed to Clipper::GetClipList is too small.\0";
	case DDERR_SURFACEALREADYATTACHED:
	    return "This surface is already attached to the surface it is being attached to.\0";
	case DDERR_SURFACEALREADYDEPENDENT:
	    return "This surface is already a dependency of the surface it is being made a dependency of.\0";
	case DDERR_SURFACEBUSY:
	    return "Access to this surface is being refused because the surface is already locked by another thread.\0";
	case DDERR_SURFACEISOBSCURED:
	    return "Access to surface refused because the surface is obscured.\0";
	case DDERR_SURFACELOST:
	    return "Access to this surface is being refused because the surface memory is gone. The DirectDrawSurface object representing this surface should have Restore called on it.\0";
	case DDERR_SURFACENOTATTACHED:
	    return "The requested surface is not attached.\0";
	case DDERR_TOOBIGHEIGHT:
	    return "Height requested by DirectDraw is too large.\0";
	case DDERR_TOOBIGSIZE:
	    return "Size requested by DirectDraw is too large, but the individual height and width are OK.\0";
	case DDERR_TOOBIGWIDTH:
	    return "Width requested by DirectDraw is too large.\0";
	case DDERR_UNSUPPORTED:
	    return "Action not supported.\0";
	case DDERR_UNSUPPORTEDFORMAT:
	    return "FOURCC format requested is unsupported by DirectDraw.\0";
	case DDERR_UNSUPPORTEDMASK:
	    return "Bitmask in the pixel format requested is unsupported by DirectDraw.\0";
	case DDERR_VERTICALBLANKINPROGRESS:
	    return "Vertical blank is in progress.\0";
	case DDERR_WASSTILLDRAWING:
	    return "Informs DirectDraw that the previous Blt which is transfering information to or from this Surface is incomplete.\0";
	case DDERR_WRONGMODE:
	    return "This surface can not be restored because it was created in a different mode.\0";
	case DDERR_XALIGN:
	    return "Rectangle provided was not horizontally aligned on required boundary.\0";
	case D3DERR_BADMAJORVERSION:
	    return "D3DERR_BADMAJORVERSION\0";
	case D3DERR_BADMINORVERSION:
	    return "D3DERR_BADMINORVERSION\0";
	case D3DERR_EXECUTE_LOCKED:
	    return "D3DERR_EXECUTE_LOCKED\0";
	case D3DERR_EXECUTE_NOT_LOCKED:
	    return "D3DERR_EXECUTE_NOT_LOCKED\0";
	case D3DERR_EXECUTE_CREATE_FAILED:
	    return "D3DERR_EXECUTE_CREATE_FAILED\0";
	case D3DERR_EXECUTE_DESTROY_FAILED:
	    return "D3DERR_EXECUTE_DESTROY_FAILED\0";
	case D3DERR_EXECUTE_LOCK_FAILED:
	    return "D3DERR_EXECUTE_LOCK_FAILED\0";
	case D3DERR_EXECUTE_UNLOCK_FAILED:
	    return "D3DERR_EXECUTE_UNLOCK_FAILED\0";
	case D3DERR_EXECUTE_FAILED:
	    return "D3DERR_EXECUTE_FAILED\0";
	case D3DERR_EXECUTE_CLIPPED_FAILED:
	    return "D3DERR_EXECUTE_CLIPPED_FAILED\0";
	case D3DERR_TEXTURE_NO_SUPPORT:
	    return "D3DERR_TEXTURE_NO_SUPPORT\0";
	case D3DERR_TEXTURE_NOT_LOCKED:
	    return "D3DERR_TEXTURE_NOT_LOCKED\0";
	case D3DERR_TEXTURE_LOCKED:
	    return "D3DERR_TEXTURELOCKED\0";
	case D3DERR_TEXTURE_CREATE_FAILED:
	    return "D3DERR_TEXTURE_CREATE_FAILED\0";
	case D3DERR_TEXTURE_DESTROY_FAILED:
	    return "D3DERR_TEXTURE_DESTROY_FAILED\0";
	case D3DERR_TEXTURE_LOCK_FAILED:
	    return "D3DERR_TEXTURE_LOCK_FAILED\0";
	case D3DERR_TEXTURE_UNLOCK_FAILED:
	    return "D3DERR_TEXTURE_UNLOCK_FAILED\0";
	case D3DERR_TEXTURE_LOAD_FAILED:
	    return "D3DERR_TEXTURE_LOAD_FAILED\0";
	case D3DERR_MATRIX_CREATE_FAILED:
	    return "D3DERR_MATRIX_CREATE_FAILED\0";
	case D3DERR_MATRIX_DESTROY_FAILED:
	    return "D3DERR_MATRIX_DESTROY_FAILED\0";
	case D3DERR_MATRIX_SETDATA_FAILED:
	    return "D3DERR_MATRIX_SETDATA_FAILED\0";
	case D3DERR_SETVIEWPORTDATA_FAILED:
	    return "D3DERR_SETVIEWPORTDATA_FAILED\0";
	case D3DERR_MATERIAL_CREATE_FAILED:
	    return "D3DERR_MATERIAL_CREATE_FAILED\0";
	case D3DERR_MATERIAL_DESTROY_FAILED:
	    return "D3DERR_MATERIAL_DESTROY_FAILED\0";
	case D3DERR_MATERIAL_SETDATA_FAILED:
	    return "D3DERR_MATERIAL_SETDATA_FAILED\0";
	case D3DERR_LIGHT_SET_FAILED:
	    return "D3DERR_LIGHT_SET_FAILED\0";
	default:
	    return "Unrecognized error value.\0";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\input.c ===
#include <windows.h>
#include <stdio.h>
#include <GL\gl.h>
#include <GL\glu.h>

#include "math.h"
#include "mesh.h"
#include "globals.h"

typedef enum enumINPUTSTATE { IS_EMPTY, IS_INPUT, IS_REALIZED } INPUTSTATE;
INPUTSTATE gInputState = IS_EMPTY;

#define MAX_CURVE_POINTS    128

typedef struct _INPUT_CURVE {
    ULONG   cPoints;
    POINTL  pptl[MAX_CURVE_POINTS];
} INPUT_CURVE;

INPUT_CURVE gInputCurve;
POINT3D *gppt3d = (POINT3D *) NULL;

HWND ghwndInput = NULL;
HPEN ghpenCurve = NULL, ghpenAxis = NULL, ghpenGrid = NULL;
HCURSOR ghcurCross = NULL, ghcurArrow = NULL;
SHORT gsMouseX, gsMouseY;

RECT grcClient;

void DrawCurve(HWND, HDC, BOOL);
void InitCurve(void);
void DeleteCurve(void);
void AddPointToCurve(POINTL *);
void RealizeCurve(HWND);
void SnapPointToGrid(POINTL *, int);

#define GRID_SIZE   5

void CreateInputWindow( HINSTANCE   hInstance,
                        HINSTANCE   hPrevInstance,
                        LPSTR       lpCmdLine,
                        int         nCmdShow
                      )
{
    static char szInputWindow[] = "Input curve";
    static char szIniFile[] = "lathe.ini";
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        wndclass.style          = CS_OWNDC;
        wndclass.lpfnWndProc    = (WNDPROC)InputProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        //wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hCursor        = NULL;
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szInputWindow;

        // With a NULL icon handle, app will paint into the icon window.
        wndclass.hIcon          = NULL;
        //wndclass.hIcon          = LoadIcon(hInstance, "CubeIcon");

        RegisterClass(&wndclass);
    }

    ghcurArrow = LoadCursor(NULL, IDC_ARROW);
    ghcurCross = LoadCursor(hInstance, "WhiteCross");

    Rect.left   = GetPrivateProfileInt("InputWindow", "left",   50, szIniFile);
    Rect.top    = GetPrivateProfileInt("InputWindow", "top",    50, szIniFile);
    Rect.right  = GetPrivateProfileInt("InputWindow", "right",  450, szIniFile);
    Rect.bottom = GetPrivateProfileInt("InputWindow", "bottom", 450, szIniFile);

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

    ghwndInput = CreateWindow(szInputWindow,          // window class name
                              "Input Curve",          // window caption
                              WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                              Rect.left,              // initial x position
                              Rect.top,               // initial y position
                              WINDSIZEX(Rect),        // initial x size
                              WINDSIZEY(Rect),        // initial y size
                              NULL,                   // parent window handle
                              NULL,                   // window menu handle
                              hInstance,              // program instance handle
                              NULL                    // creation parameter
                             );

    ShowWindow( ghwndInput, nCmdShow );
    UpdateWindow( ghwndInput );
}


long
InputProc (   HWND hwnd,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
        )
{
    HDC hdc;
    PAINTSTRUCT ps;
    POINTL ptl, *pptlCur;

    switch ( message )
    {
        case WM_CREATE:
            GetClientRect(hwnd, &grcClient);
            ghpenGrid = CreatePen(PS_SOLID, 1, PALETTERGB(0x7F, 0x7F, 0x7F));
            ghpenAxis = CreatePen(PS_SOLID, 1, PALETTERGB(0x00, 0xFF, 0x00));
            ghpenCurve = CreatePen(PS_SOLID, 1, PALETTERGB(0xFF, 0x00, 0x00));

            InitCurve();
            if(hdc = GetDC(hwnd))
            {
                DrawCurve(hwnd, hdc, TRUE);
                ReleaseDC(hwnd, hdc);
            }
            return(0);

        case WM_PAINT:
            hdc = BeginPaint( hwnd, &ps );
            DrawCurve(hwnd, hdc, TRUE);
            EndPaint( hwnd, &ps );
            return(0);

        case WM_SIZE:
            GetClientRect(hwnd, &grcClient);
            return(0);

        case WM_ACTIVATE:
            if ( gInputState == IS_INPUT )
            {
                if ( LOWORD(wParam) & WA_INACTIVE )
                {
                    SetCursor(ghcurArrow);
                    ReleaseCapture();
                }
                else
                {
                        SetCursor(ghcurCross);
                        SetCapture(hwnd);
                }
            }
            return(0);

        case WM_LBUTTONDOWN:

            switch (gInputState)
            {
                case IS_EMPTY:
                    gInputState = IS_INPUT;
                    SetCursor(ghcurCross);

                // Fall into code below.

                case IS_INPUT:
                    SetCapture(hwnd);

                    ptl.x = LOWORD(lParam);
                    ptl.y = HIWORD(lParam);
                    SnapPointToGrid(&ptl, GRID_SIZE);
                    AddPointToCurve(&ptl);
                    gsMouseX = ptl.x;
                    gsMouseY = ptl.y;

                    if(hdc = GetDC(hwnd))
                    {
                        DrawCurve(hwnd, hdc, FALSE);
                        ReleaseDC(hwnd, hdc);
                    }

                    break;

                case IS_REALIZED:
                default:
                    break;
            }
            return (0);

        case WM_MOUSEMOVE:

            if ( gInputState == IS_INPUT )
            {
                ptl.x = LOWORD(lParam);
                ptl.y = HIWORD(lParam);

                if ( ptl.x < grcClient.right && ptl.y < grcClient.bottom )
                {
                    SnapPointToGrid(&ptl, GRID_SIZE);

                    SetCursor(ghcurCross);

                    if (hdc = GetDC(hwnd))
                    {
                        pptlCur = &gInputCurve.pptl[gInputCurve.cPoints-1];

                        SetROP2(hdc, R2_NOT);
                        SelectObject(hdc, ghpenCurve);
                        MoveToEx(hdc, pptlCur->x, pptlCur->y, NULL);
                        LineTo(hdc, gsMouseX, gsMouseY);

                        gsMouseX = ptl.x;
                        gsMouseY = ptl.y;

                        MoveToEx(hdc, pptlCur->x, pptlCur->y, NULL);
                        LineTo(hdc, gsMouseX, gsMouseY);
                        SetROP2(hdc, R2_COPYPEN);

                        ReleaseDC(hwnd, hdc);
                    }
                }
                else
                {
                    if (hdc = GetDC(hwnd))
                    {
                        pptlCur = &gInputCurve.pptl[gInputCurve.cPoints-1];

                        SetROP2(hdc, R2_NOT);
                        SelectObject(hdc, ghpenCurve);
                        MoveToEx(hdc, pptlCur->x, pptlCur->y, NULL);
                        LineTo(hdc, gsMouseX, gsMouseY);
                        SetROP2(hdc, R2_COPYPEN);

                        ReleaseDC(hwnd, hdc);
                    }
                    SetCursor(ghcurArrow);
                    ReleaseCapture();
                }
            }
            return (0);

        case WM_RBUTTONDOWN:

            switch (gInputState)
            {
                case IS_INPUT:
                    RealizeCurve(hwnd);
                    if (hdc = GetDC(hwnd))
                    {
                        pptlCur = &gInputCurve.pptl[gInputCurve.cPoints-1];

                        SetROP2(hdc, R2_NOT);
                        SelectObject(hdc, ghpenCurve);
                        MoveToEx(hdc, pptlCur->x, pptlCur->y, NULL);
                        LineTo(hdc, gsMouseX, gsMouseY);
                        SetROP2(hdc, R2_COPYPEN);

                        ReleaseDC(hwnd, hdc);
                    }
                    gInputState = IS_REALIZED;
                    SetCursor(ghcurArrow);
                    ReleaseCapture();
                    break;

                case IS_REALIZED:
                    DeleteCurve();
                    gInputState = IS_EMPTY;

                    if(hdc = GetDC(hwnd))
                    {
                        DrawCurve(hwnd, hdc, TRUE);
                        ReleaseDC(hwnd, hdc);
                    }

                    break;

                default:
                    SetCursor(ghcurArrow);
                    ReleaseCapture();
                    break;
            }
            return (0);

        case WM_KEYDOWN:
            switch (wParam)
            {
            case VK_ESCAPE:
                PostMessage(hwnd, WM_DESTROY, 0, 0);
                break;
            default:
                break;
            }
            return(0);

        case WM_CHAR:
            switch(wParam)
            {
                case 'w':
                case 'W':
                    DestroyWindow(ghwndObject);
                    break;
                default:
                    break;
            }

            return 0;

        case WM_DESTROY:
            PostQuitMessage( 0 );
            PostMessage(ghwndObject, WM_QUIT, 0, 0); // quit object thread too
            return(0);

    }
    return( DefWindowProc( hwnd, message, wParam, lParam ) );
}

void InitCurve()
{
    gInputCurve.cPoints = 0;
}

void DeleteCurve()
{
    gInputCurve.cPoints = 0;
}

void AddPointToCurve(POINTL *pptl)
{
    if (gInputCurve.cPoints < MAX_CURVE_POINTS)
    {
        gInputCurve.pptl[gInputCurve.cPoints] = *pptl;
        gInputCurve.cPoints++;
    }
    else
        MessageBox(NULL, "Too many points", "Temp hack warning", MB_OK);
}

void DrawCurve(HWND hwnd, HDC hdc, BOOL bClear)
{
    POINTL *pptl, *pptlEnd;

    if (bClear)
    {
        BitBlt(hdc, grcClient.left, grcClient.top,
               WINDSIZEX(grcClient), WINDSIZEY(grcClient),
               NULL, 0, 0, BLACKNESS);

        SelectObject(hdc, ghpenAxis);
        MoveToEx(hdc, grcClient.right/2, 0, NULL);
        LineTo(hdc, grcClient.right/2, grcClient.bottom);
        MoveToEx(hdc, 0, grcClient.bottom/2, NULL);
        LineTo(hdc, grcClient.right, grcClient.bottom/2);

    }

    #if 0
    if (gInputCurve.cPoints)
    {
        SelectObject(hdc, ghpen);

        pptl = gInputCurve.pptl;
        pptlEnd = pptl + gInputCurve.cPoints;

        MoveToEx(hdc, pptl->x, pptl->y, NULL);
        pptl += 1;

        while (pptl < pptlEnd)
        {
            LineTo(hdc, pptl->x, pptl->y);
            pptl += 1;
        }
    }
    #else
    if ( gInputCurve.cPoints )
    {
        SelectObject(hdc, ghpenCurve);
        Polyline(hdc, gInputCurve.pptl, gInputCurve.cPoints);
    }
    #endif
}

void RealizeCurve(HWND hwnd)
{
    POINTL *pptl, *pptlEnd;
    POINT3D *ppt3dNew;
    GLfloat w, h;

    if (!gInputCurve.cPoints)
        return;

    w = (GLfloat) (WINDSIZEX(grcClient) / 2);
    h = (GLfloat) (WINDSIZEY(grcClient) / 2);

    pptl = gInputCurve.pptl;
    pptlEnd = pptl + gInputCurve.cPoints;

// Allocate new 3d curve data array.

    if (gppt3d)
        LocalFree(gppt3d);

    gppt3d = (POINT3D *) LocalAlloc(LMEM_FIXED,
                                   gInputCurve.cPoints * sizeof(POINT3D));
    if (!gppt3d)
    {
        MessageBox(NULL, "Out of memory.", "Error", MB_OK);
        return;
    }

    for (ppt3dNew = gppt3d; pptl < pptlEnd; pptl+=1, ppt3dNew += 1)
    {
        ppt3dNew->x = ((GLfloat) pptl->x - w) / w;
        ppt3dNew->y = (h - (GLfloat) pptl->y) / h;
        ppt3dNew->z = 0.0f;
    }

// Stick it into the 3D curve structure.

    curve.pts = gppt3d;
    curve.numPoints = gInputCurve.cPoints;

    vInputThreadMakeObject();
}


void SnapPointToGrid(POINTL *pptl, int iGridSize)
{
    int xOrg = WINDSIZEX(grcClient), yOrg = WINDSIZEY(grcClient);
    int xRel = pptl->x - xOrg;
    int yRel = pptl->y - yOrg;
    int xDelt, yDelt;

    xDelt = abs(xRel) % iGridSize;
    yDelt = abs(yRel) % iGridSize;

    if ( xDelt <= (iGridSize / 2) )
        pptl->x -= xDelt * (xRel >= 0 ? 1 : -1);
    else
        pptl->x += (iGridSize - xDelt) * (xRel >= 0 ? 1 : -1);

    if ( yDelt <= (iGridSize / 2) )
        pptl->y -= yDelt * (yRel >= 0 ? 1 : -1);
    else
        pptl->y += (iGridSize - yDelt) * (yRel >= 0 ? 1 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\glcube\glcube.c ===
#define DBLBUFFER       1
#define USE_COLOR_INDEX 0

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ptypes32.h>
#include <pwin32.h>

long WndProc ( HWND hwnd, UINT message, DWORD wParam, LONG lParam );
void DoGlStuff( HWND hWnd, HDC hDc );
HGLRC hrcInitGL(HWND hwnd, HDC hdc);
void vCleanupGL(HGLRC hrc);

#include <GL\gl.h>

#define TERMINATE   DbgPrint("%s (%d)\n", __FILE__, __LINE__), ExitProcess(0)

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

// Default Logical Palette indexes
#define BLACK_INDEX	0
#define WHITE_INDEX	19
#define RED_INDEX	13
#define GREEN_INDEX	14
#define BLUE_INDEX	16
#define YELLOW_INDEX	15
#define MAGENTA_INDEX	17
#define CYAN_INDEX      18

// Global variables defining current position and orientation.
GLfloat AngleX = 0.0;
GLfloat AngleY = 0.0;
GLfloat AngleZ = 0.0;
GLfloat OffsetX = 0.0;
GLfloat OffsetY = 0.0;
GLfloat OffsetZ = -3.0;

HGLRC ghrc = (HGLRC) 0;

#ifdef DBLBUFFER
HDC     ghdcMem;
HBITMAP ghbmBackBuffer, ghbmOld;
#endif

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "GL Cube";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        //wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.style          = 0;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
        wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = 100;
    Rect.top    = 100;
    Rect.right  = 200;
    Rect.bottom = 200;

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

    hwnd = CreateWindow  (  szAppName,              // window class name
                            "GL Cube",              // window caption
                            WS_OVERLAPPEDWINDOW,    // window style
                            Rect.left,              // initial x position
                            Rect.top,               // initial y position
                            WINDSIZEX(Rect),        // initial x size
                            WINDSIZEY(Rect),        // initial y size
                            NULL,                   // parent window handle
                            NULL,                   // window menu handle
                            hInstance,              // program instance handle
                            NULL                    // creation parameter

                        );

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    return( msg.wParam );
}


long
WndProc (   HWND hWnd,
            UINT message,
            DWORD wParam,
            LONG lParam
        )
{
    HDC hDc;
    PAINTSTRUCT ps;
    BOOL bValidKey = TRUE;

    switch ( message )
    {
        case WM_PAINT:
            hDc = BeginPaint( hWnd, &ps );

            if (ghrc == (HGLRC) 0)
                ghrc = hrcInitGL(hWnd, hDc);

            DoGlStuff( hWnd, hDc );

            EndPaint( hWnd, &ps );
            return(0);

        case WM_CHAR:
            switch(wParam)
            {
                case 'u':
                case 'U':
                    AngleX += 10.0;
                    AngleX = (AngleX > 360.0) ? 0.0 : AngleX;
                    break;

                case 'j':
                case 'J':
                    AngleX -= 10.0;
                    AngleX = (AngleX < 0.0) ? 360.0 : AngleX;
                    break;

                case 'i':
                case 'I':
                    AngleY += 10.0;
                    AngleY = (AngleY > 360.0) ? 0.0 : AngleY;
                    break;

                case 'k':
                case 'K':
                    AngleY -= 10.0;
                    AngleY = (AngleY < 0.0) ? 360.0 : AngleY;
                    break;

                case 'o':
                case 'O':
                    AngleZ += 10.0;
                    AngleZ = (AngleZ > 360.0) ? 0.0 : AngleZ;
                    break;

                case 'l':
                case 'L':
                    AngleZ -= 10.0;
                    AngleZ = (AngleZ < 0.0) ? 360.0 : AngleZ;
                    break;

                case 'd':
                case 'D':
                    OffsetX += 0.2;
                    break;

                case 'a':
                case 'A':
                    OffsetX -= 0.2;
                    break;

            // !!! Note: currently the coordinate system is upside down, so
            // !!!       so up and down are reversed.

                case 's':
                case 'S':
                    OffsetY += 0.2;
                    break;

                case 'w':
                case 'W':
                    OffsetY -= 0.2;
                    break;

                case 'q':
                case 'Q':
                    OffsetZ += 0.2;
                    break;

                case 'e':
                case 'E':
                    OffsetZ -= 0.2;
                    break;

                default:
                    bValidKey = FALSE;
            }

            if (bValidKey)
            {
                hDc = GetDC(hWnd);

                if (ghrc == (HGLRC) 0)
                    ghrc = hrcInitGL(hWnd, hDc);

                DoGlStuff( hWnd, hDc );

                ReleaseDC(hWnd, hDc);
            }

            return 0;

        case WM_DESTROY:
            vCleanupGL(ghrc);
            PostQuitMessage( 0 );
            return( 0 );

    }
    return( DefWindowProc( hWnd, message, wParam, lParam ) );

}

HGLRC hrcInitGL(HWND hwnd, HDC hdc)
{
    RECT Rect;
    HGLRC hrc;
    int iWidth, iHeight;

#if !USE_COLOR_INDEX
    static GLfloat ClearColor[] =   {
                                        (GLfloat)0.0,   // Red
                                        (GLfloat)0.0,   // Green
                                        (GLfloat)0.0,   // Blue
                                        (GLfloat)1.0    // Alpha

                                    };
#endif

    /* Get the size of the client area */

    GetClientRect( hwnd, &Rect );
    iWidth  = Rect.right-Rect.left;
    iHeight = Rect.bottom-Rect.top;

    /* Create a Rendering Context */

#if DBLBUFFER
    ghdcMem = CreateCompatibleDC(hdc);
    SelectObject(ghdcMem, GetStockObject(DEFAULT_PALETTE));

    ghbmBackBuffer = CreateCompatibleBitmap(hdc, iWidth, iHeight);
    ghbmOld = SelectObject(ghdcMem, ghbmBackBuffer);

    //!!! [GilmanW] OpenGL hack !!!
    //!!!
    //!!! For some reason we need to prepare the memory DC.  GL
    //!!! drawing seems limited to the area drawn to by GDI calls.
    //!!! By BitBlt'ing the entire memory DC, the whole thing is
    //!!! is available to GL.
    //!!!
    //!!! There must be something we need to update on the server
    //!!! side so that this is not necessary.
    BitBlt(ghdcMem, 0, 0, iWidth, iHeight, NULL, 0, 0, BLACKNESS);

    hrc = wglCreateContext( ghdcMem );
#else
    hrc = wglCreateContext( hdc );
#endif

    /* Make it Current */

#if DBLBUFFER
    wglMakeCurrent( ghdcMem, hrc );
#else
    wglMakeCurrent( hdc, hrc );
#endif

    // !!! Note: currently the coordinate system is upside down, so we
    // !!!       need to reverse the default "front face" definition.

    glFrontFace(GL_CW);

    /* Set the clear color */

#if USE_COLOR_INDEX
    glClearIndex(BLACK_INDEX);
#else
    glClearColor( ClearColor[0], ClearColor[1], ClearColor[2], ClearColor[3] );
#endif

    /* Turn off dithering */

    glDisable(GL_DITHER);

    /* Turn on z-buffer */

    glEnable(GL_DEPTH_TEST);

    return hrc;
}

void
vCleanupGL(hrc)
{
    /*  Destroy our context */

    wglDeleteContext( hrc );

#if DBLBUFFER
    DeleteObject(SelectObject(ghdcMem, ghbmOld));
    DeleteDC(ghdcMem);
#endif
}

void
DoGlStuff( HWND hWnd, HDC hDc )
{
    RECT Rect;
    HGLRC hRc;

#if !USE_COLOR_INDEX
    static GLfloat Cyan[] =     {
                                    (GLfloat)0.0,   // Read
                                    (GLfloat)0.666, // Green
                                    (GLfloat)0.666, // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Yellow[] =   {
                                    (GLfloat)0.666, // Red
                                    (GLfloat)0.666, // Green
                                    (GLfloat)0.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Magenta[] =  {
                                    (GLfloat)0.666, // Red
                                    (GLfloat)0.0,   // Green
                                    (GLfloat)0.666, // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Red[] =      {
                                    (GLfloat)1.0,   // Red
                                    (GLfloat)0.0,   // Green
                                    (GLfloat)0.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Green[] =    {
                                    (GLfloat)0.0,   // Red
                                    (GLfloat)1.0,   // Green
                                    (GLfloat)0.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };

    static GLfloat Blue[] =     {
                                    (GLfloat)0.0,   // Red
                                    (GLfloat)0.0,   // Green
                                    (GLfloat)1.0,   // Blue
                                    (GLfloat)1.0    // Alpha
                                };
#endif

    /* Get the size of the client area */

    GetClientRect( hWnd, &Rect );

    /* Set up the projection matrix */

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.5, 20.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glTranslatef(OffsetX, OffsetY, OffsetZ);

    glRotatef(AngleX, 1.0, 0.0, 0.0);
    glRotatef(AngleY, 0.0, 1.0, 0.0);
    glRotatef(AngleZ, 0.0, 0.0, 1.0);

    glViewport(0, 0, WINDSIZEX(Rect), WINDSIZEY(Rect));

    /* Clear the color buffer */

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    /* Draw the cube */

    glBegin(GL_QUADS);

#if USE_COLOR_INDEX
        glIndexi(BLUE_INDEX);
#else
        glColor4fv( Blue );
#endif
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) -0.7);

#if USE_COLOR_INDEX
        glIndexi(GREEN_INDEX);
#else
        glColor4fv( Green );
#endif
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) -0.7);

#if USE_COLOR_INDEX
        glIndexi(RED_INDEX);
#else
        glColor4fv( Red );
#endif
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) 0.7);

#if USE_COLOR_INDEX
        glIndexi(CYAN_INDEX);
#else
        glColor4fv( Cyan );
#endif
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) 0.7);

#if USE_COLOR_INDEX
        glIndexi(YELLOW_INDEX);
#else
        glColor4fv( Yellow );
#endif
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) 0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) 0.7, (GLfloat) 0.7);

#if USE_COLOR_INDEX
        glIndexi(MAGENTA_INDEX);
#else
        glColor4fv( Magenta );
#endif
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) 0.7);
        glVertex3f( (GLfloat) -0.7, (GLfloat) -0.7, (GLfloat) -0.7);
        glVertex3f( (GLfloat) 0.7, (GLfloat) -0.7, (GLfloat) -0.7);

    glEnd();
    glFlush();

#if DBLBUFFER
    BitBlt(hDc, 0, 0, Rect.right-Rect.left, Rect.bottom-Rect.top, ghdcMem, 0, 0, SRCCOPY);
    GdiFlush();
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\ssopengl.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\globals.h ===
#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

#define ZERO            ((GLfloat)0.0)
#define ONE             ((GLfloat)1.0)
#define POINT_TWO       ((GLfloat)0.2)
#define POINT_SEVEN     ((GLfloat)0.7)
#define THREE           ((GLfloat)3.0)
#define FIVE            ((GLfloat)5.0)
#define TEN             ((GLfloat)10.0)
#define FORTY_FIVE      ((GLfloat)45.0)
#define FIFTY           ((GLfloat)50.0)

// From object.c ------------------------------------------------------------

typedef enum enumPOLYDRAW {
    POLYDRAW_FILLED = 0,
    POLYDRAW_LINES  = 1,
    POLYDRAW_POINTS = 2
    } POLYDRAW;

typedef enum enumSHADE {
    SHADE_FLAT          = 0,
    SHADE_SMOOTH_AROUND = 1,
    SHADE_SMOOTH_BOTH   = 2
    } SHADE;

extern HWND ghwndObject;
extern CURVE curve;

extern SHADE gShadeMode;
extern POLYDRAW gPolyDrawMode;

extern long WndProc(HWND, UINT, WPARAM, LPARAM);
extern void DoGlStuff(HWND, HDC);
extern HGLRC hrcInitGL(HWND, HDC);
extern void vCleanupGL(HGLRC);
extern BOOL bSetupPixelFormat(HDC);
extern void CreateRGBPalette(HDC);
extern VOID vSetSize(HWND);
extern void ForceRedraw(HWND);
extern VOID vMakeObject(void);
extern VOID vInputThreadMakeObject(void);
extern VOID vMeshToList(void);

#define WM_USER_INPUTMESH   WM_USER

// From input.c -------------------------------------------------------------

extern HWND ghwndInput;

extern long InputProc(HWND, UINT, WPARAM, LPARAM);
extern void CreateInputWindow(HINSTANCE, HINSTANCE, LPSTR, int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\trackbal.c ===
/*
 * Trackball code:
 *
 * Implementation of a virtual trackball.
 * Implemented by Gavin Bell, lots of ideas from Thant Tessman and
 *   the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129.
 *
 * Vector manip code:
 *
 * Original code from:
 * David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli
 *
 * Much mucking with by:
 * Gavin Bell
 */
#include <math.h>
#include "trackbal.h"

/*
 * This size should really be based on the distance from the center of
 * rotation to the point on the object underneath the mouse.  That
 * point would then track the mouse as closely as possible.  This is a
 * simple example, though, so that is left as an Exercise for the
 * Programmer.
 */
#define TRACKBALLSIZE  (0.8)

/*
 * Local function prototypes (not defined in trackball.h)
 */
static float tb_project_to_sphere(float, float, float);
static void normalize_quat(float [4]);

void
vzero(float *v)
{
    v[0] = 0.0;
    v[1] = 0.0;
    v[2] = 0.0;
}

void
vset(float *v, float x, float y, float z)
{
    v[0] = x;
    v[1] = y;
    v[2] = z;
}

void
vsub(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] - src2[0];
    dst[1] = src1[1] - src2[1];
    dst[2] = src1[2] - src2[2];
}

void
vcopy(const float *v1, float *v2)
{
    register int i;
    for (i = 0 ; i < 3 ; i++)
        v2[i] = v1[i];
}

void
vcross(const float *v1, const float *v2, float *cross)
{
    float temp[3];

    temp[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    temp[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    temp[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    vcopy(temp, cross);
}

float
vlength(const float *v)
{
    return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

void
vscale(float *v, float div)
{
    v[0] *= div;
    v[1] *= div;
    v[2] *= div;
}

void
vnormal(float *v)
{
    vscale(v,1.0/vlength(v));
}

float
vdot(const float *v1, const float *v2)
{
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

void
vadd(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] + src2[0];
    dst[1] = src1[1] + src2[1];
    dst[2] = src1[2] + src2[2];
}

/*
 * Ok, simulate a track-ball.  Project the points onto the virtual
 * trackball, then figure out the axis of rotation, which is the cross
 * product of P1 P2 and O P1 (O is the center of the ball, 0,0,0)
 * Note:  This is a deformed trackball-- is a trackball in the center,
 * but is deformed into a hyperbolic sheet of rotation away from the
 * center.  This particular function was chosen after trying out
 * several variations.
 * 
 * It is assumed that the arguments to this routine are in the range
 * (-1.0 ... 1.0)
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y)
{
    float a[3]; /* Axis of rotation */
    float phi;  /* how much to rotate about axis */
    float p1[3], p2[3], d[3];
    float t;

    if (p1x == p2x && p1y == p2y) {
	/* Zero rotation */
        vzero(q); 
	q[3] = 1.0; 
        return;
    }

    /*
     * First, figure out z-coordinates for projection of P1 and P2 to
     * deformed sphere
     */
    vset(p1,p1x,p1y,tb_project_to_sphere(TRACKBALLSIZE,p1x,p1y));
    vset(p2,p2x,p2y,tb_project_to_sphere(TRACKBALLSIZE,p2x,p2y));

    /*
     *  Now, we want the cross product of P1 and P2
     */
    vcross(p2,p1,a);

    /*
     *  Figure out how much to rotate around that axis.
     */
    vsub(p1,p2,d);
    t = vlength(d) / (2.0*TRACKBALLSIZE);

    /*
     * Avoid problems with out-of-control values...
     */
    if (t > 1.0) t = 1.0;
    if (t < -1.0) t = -1.0;
    phi = 2.0 * asin(t);

    axis_to_quat(a,phi,q);
}

/*
 *  Given an axis and angle, compute quaternion.
 */
void
axis_to_quat(float a[3], float phi, float q[4])
{
    vnormal(a);
    vcopy(a,q);
    vscale(q,sin(phi/2.0));
    q[3] = cos(phi/2.0);
}

/*
 * Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet
 * if we are away from the center of the sphere.
 */
static float
tb_project_to_sphere(float r, float x, float y)
{
    float d, t, z;

    d = sqrt(x*x + y*y);
    if (d < r * 0.70710678118654752440) {    /* Inside sphere */
	z = sqrt(r*r - d*d);
    } else {           /* On hyperbola */
        t = r / 1.41421356237309504880;
        z = t*t / d;
    }
    return z;
}

/*
 * Given two rotations, e1 and e2, expressed as quaternion rotations,
 * figure out the equivalent single rotation and stuff it into dest.
 * 
 * This routine also normalizes the result every RENORMCOUNT times it is
 * called, to keep error from creeping in.
 *
 * NOTE: This routine is written so that q1 or q2 may be the same
 * as dest (or each other).
 */

#define RENORMCOUNT 97

void
add_quats(float q1[4], float q2[4], float dest[4])
{
    static int count=0;
    int i;
    float t1[4], t2[4], t3[4];
    float tf[4];

    vcopy(q1,t1); 
    vscale(t1,q2[3]);

    vcopy(q2,t2); 
    vscale(t2,q1[3]);

    vcross(q2,q1,t3);
    vadd(t1,t2,tf);
    vadd(t3,tf,tf);
    tf[3] = q1[3] * q2[3] - vdot(q1,q2);

    dest[0] = tf[0];
    dest[1] = tf[1];
    dest[2] = tf[2];
    dest[3] = tf[3];

    if (++count > RENORMCOUNT) {
        count = 0;
        normalize_quat(dest);
    }
}

/*
 * Quaternions always obey:  a^2 + b^2 + c^2 + d^2 = 1.0
 * If they don't add up to 1.0, dividing by their magnitued will
 * renormalize them.
 *
 * Note: See the following for more information on quaternions:
 * 
 * - Shoemake, K., Animating rotation with quaternion curves, Computer
 *   Graphics 19, No 3 (Proc. SIGGRAPH'85), 245-254, 1985.
 * - Pletinckx, D., Quaternion calculus as a basic tool in computer
 *   graphics, The Visual Computer 5, 2-13, 1989.
 */
static void
normalize_quat(float q[4])
{
    int i;
    float mag;

    mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
    for (i = 0; i < 4; i++) q[i] /= mag;
}

/*
 * Build a rotation matrix, given a quaternion rotation.
 *
 */
void
build_rotmatrix(float m[4][4], float q[4])
{
    m[0][0] = 1.0 - 2.0 * (q[1] * q[1] + q[2] * q[2]);
    m[0][1] = 2.0 * (q[0] * q[1] - q[2] * q[3]);
    m[0][2] = 2.0 * (q[2] * q[0] + q[1] * q[3]);
    m[0][3] = 0.0;

    m[1][0] = 2.0 * (q[0] * q[1] + q[2] * q[3]);
    m[1][1]= 1.0 - 2.0 * (q[2] * q[2] + q[0] * q[0]);
    m[1][2] = 2.0 * (q[1] * q[2] - q[0] * q[3]);
    m[1][3] = 0.0;

    m[2][0] = 2.0 * (q[2] * q[0] - q[1] * q[3]);
    m[2][1] = 2.0 * (q[1] * q[2] + q[0] * q[3]);
    m[2][2] = 1.0 - 2.0 * (q[1] * q[1] + q[0] * q[0]);
    m[2][3] = 0.0;

    m[3][0] = 0.0;
    m[3][1] = 0.0;
    m[3][2] = 0.0;
    m[3][3] = 1.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\trackbal.h ===
/*
 * trackball.h
 * A virtual trackball implementation
 * Written by Gavin Bell for Silicon Graphics, November 1988.
 */

/*
 * Pass the x and y coordinates of the last and current positions of
 * the mouse, scaled so they are from (-1.0 ... 1.0).
 *
 * if ox,oy is the window's center and sizex,sizey is its size, then
 * the proper transformation from screen coordinates (sc) to world
 * coordinates (wc) is:
 * wcx = (2.0 * (scx-ox)) / (float)sizex - 1.0
 * wcy = (2.0 * (scy-oy)) / (float)sizey - 1.0
 *
 * The resulting rotation is returned as a quaternion rotation in the
 * first paramater.
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y);

/*
 * Given two quaternions, add them together to get a third quaternion.
 * Adding quaternions to get a compound rotation is analagous to adding
 * translations to get a compound translation.  When incrementally
 * adding rotations, the first argument here should be the new
 * rotation, the second and third the total rotation (which will be
 * over-written with the resulting new total rotation).
 */
void
add_quats(float *q1, float *q2, float *dest);

/*
 * A useful function, builds a rotation matrix in Matrix based on
 * given quaternion.
 */
void
build_rotmatrix(float m[4][4], float q[4]);

/*
 * This function computes a quaternion based on an axis (defined by
 * the given vector) and an angle about which to rotate.  The angle is
 * expressed in radians.  The result is put into the third argument.
 */
void
axis_to_quat(float a[3], float phi, float q[4]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\mesh.c ===
/******************************Module*Header*******************************\
* Module Name: mesh.c
*
* Surface of revolution support routines.  Adapted from OttoB's screen saver
* code.
*
* Created: 14-May-1994 17:40:51
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <GL\gl.h>
#include <string.h>
#include <math.h>
#include "mesh.h"
#include "globals.h"

/******************************Public*Routine******************************\
* newMesh
*
* Allocate memory for the mesh structure to accomodate the specified number
* of points and faces.
*
* numAxial is the number of tiers (or rings) in the surface of revolution
* (can be thought of as the number of faces "high" in the axial direction.
*
* numCircum is the number of faces around the circumference.
*
* In other words, if the surface of revolution were unrolled, the dimensions
* of the mesh would by numAxial by numCircum.
*
* History:
*  14-May-1994 -by- Gilman Wong [gilmanw]
* Taken from OttoB's screen saver utility code.
\**************************************************************************/

BOOL newMesh(MESH *mesh, int numAxial, int numCircum)
{
    int nFaces = numAxial * numCircum;
    int nPts = 4 * nFaces;

    mesh->numFaces       = 0;
    mesh->numPoints      = 0;
    mesh->numFacesAxial  = numAxial;
    mesh->numFacesCircum = numCircum;

    if (nPts) {
        mesh->pts = LocalAlloc(LMEM_FIXED, (LONG)nPts * (LONG)sizeof(POINT3D));
        mesh->norms = LocalAlloc(LMEM_FIXED, (LONG)nPts * (LONG)sizeof(POINT3D));
    }
    mesh->faces = LocalAlloc(LMEM_FIXED, (LONG)nFaces * (LONG)sizeof(MFACE));

// Did all the memory get allocated?

    if ( (!nPts || (mesh->pts && mesh->norms))
         && mesh->faces )
        return TRUE;
    else
    {
        if (nPts)
        {
            if (mesh->pts)
                LocalFree(mesh->pts);
            if (mesh->norms)
                LocalFree(mesh->norms);
        }
        if (mesh->faces)
            LocalFree(mesh->faces);

        return FALSE;
    }
}

/******************************Public*Routine******************************\
* delMesh
*
* Delete the allocated portions of the MESH structure.
*
* History:
*  14-May-1994 -by- Gilman Wong [gilmanw]
* Taken from OttoB's screen saver utility code.
\**************************************************************************/

void delMesh(MESH *mesh)
{
    LocalFree(mesh->pts);
    LocalFree(mesh->norms);
    LocalFree(mesh->faces);
}

/******************************Public*Routine******************************\
* iPtInList
*
* Add a vertex and its normal to the mesh.  If the vertex already exists,
* add in the normal to the existing normal (we want the average normal
* at the vertex).
*
* History:
*  14-May-1994 -by- Gilman Wong [gilmanw]
* Taken from OttoB's screen saver utility code.
\**************************************************************************/

static int iPtInList(MESH *mesh, POINT3D *p, POINT3D *norm, int start)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    for (i = start; i < mesh->numPoints; i++, pts++) {
        //if ((pts->x == p->x) && (pts->y == p->y) && (pts->z == p->z)) {
        if ( fabs(pts->x - p->x) < ZERO_EPS &&
             fabs(pts->y - p->y) < ZERO_EPS &&
             fabs(pts->z - p->z) < ZERO_EPS )
        {
            mesh->norms[i].x += norm->x;
            mesh->norms[i].y += norm->y;
            mesh->norms[i].z += norm->z;
            return i;
        }
    }

    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}


/******************************Public*Routine******************************\
* revolveSurface
*
* Takes the set of points in curve and fills the mesh structure with a
* surface of revolution.  The surface consists of quads made up of the
* points in curve rotated about the y-axis.  The number of increments
* in the revolution is determined by the steps parameter.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  14-May-1994 -by- Gilman Wong [gilmanw]
* Taken from OttoB's screen saver utility code.
\**************************************************************************/

BOOL revolveSurface(MESH *mesh, CURVE *curve, int steps)
{
    BOOL bRet = FALSE;
    int i;
    int j;
    int facecount = 0;
    double rotation = 0.0;
    double rotInc;
    double cosVal;
    double sinVal;
    POINT3D norm;
    POINT3D *a = (POINT3D *) NULL;
    POINT3D *b = (POINT3D *) NULL;

// Allocate temp memory for curve points rotated about y-axis.

    a = (POINT3D *) LocalAlloc(LMEM_FIXED, 2*curve->numPoints*sizeof(POINT3D));
    if (!a)
        goto revolveSurface_cleanup;

    b = a + curve->numPoints;

// Rotation increment.

    //rotInc = (2.0 * PI) / (double)(steps - 1);
    rotInc = (2.0 * PI) / (double) steps;

// Allocate mesh structure.

    if (!newMesh(mesh, (curve->numPoints - 1), steps))
        goto revolveSurface_cleanup;

// Rotate the curve in increments of rotInc.

    for (j = 0; j < steps; j++, rotation += rotInc)
    {
    // Compute the quads at the current rotation.  To do this, we need to
    // compute the curve at rotation and rotation+rotInc.

        cosVal = cos(rotation);
        sinVal = sin(rotation);
        for (i = 0; i < curve->numPoints; i++)
        {
            a[i].x = (float) (curve->pts[i].x * cosVal + curve->pts[i].z * sinVal);
            a[i].y = (float) (curve->pts[i].y);
            a[i].z = (float) (curve->pts[i].z * cosVal - curve->pts[i].x * sinVal);
        }

        cosVal = cos(rotation + rotInc);
        sinVal = sin(rotation + rotInc);
        for (i = 0; i < curve->numPoints; i++)
        {
            b[i].x = (float) (curve->pts[i].x * cosVal + curve->pts[i].z * sinVal);
            b[i].y = (float) (curve->pts[i].y);
            b[i].z = (float) (curve->pts[i].z * cosVal - curve->pts[i].x * sinVal);
        }

        for (i = 0; i < (curve->numPoints - 1); i++)
        {
            calcNorm(&norm, &b[i + 1], &b[i], &a[i]);
            if ((norm.x * norm.x) + (norm.y * norm.y) + (norm.z * norm.z) < 0.9)
                calcNorm(&norm, &a[i], &a[i+1], &b[i + 1]);
            mesh->faces[facecount].material = j & 7;
            mesh->faces[facecount].norm = norm;
            mesh->faces[facecount].p[0] = iPtInList(mesh, &b[i], &norm, 0);
            mesh->faces[facecount].p[1] = iPtInList(mesh, &a[i], &norm, 0);
            mesh->faces[facecount].p[2] = iPtInList(mesh, &b[i + 1], &norm, 0);
            mesh->faces[facecount].p[3] = iPtInList(mesh, &a[i + 1], &norm, 0);
            mesh->numFaces++;
            facecount++;
        }
    }

    normalizeNorms(mesh->norms, mesh->numPoints);

    bRet = TRUE;

revolveSurface_cleanup:
    if (a)
        LocalFree(a);

    return bRet;
}


void updateObject(MESH *mesh, BOOL bSmooth)
{
    int i, j;
    int cnt;
    int a, b, c, d;
    int aOffs, bOffs, cOffs, dOffs;
    MFACE *faces;
    POINT3D *pp;
    POINT3D *pn;
    MATERIAL *pmatl;
    int lastC, lastD;

    pp = mesh->pts;
    pn = mesh->norms;

    glBegin(GL_QUAD_STRIP);
    for (i = 0, faces = mesh->faces, lastC = faces->p[0], lastD = faces->p[1];
         i < mesh->numFaces; i++, faces++) {

        a = faces->p[0];
        b = faces->p[1];

        if (!bSmooth) {
            if ((a != lastC) || (b != lastD)) {
                glNormal3fv((GLfloat *)&(faces - 1)->norm);

                glVertex3fv((GLfloat *)((char *)pp +
                            (lastC << 3) + (lastC << 2)));
                glVertex3fv((GLfloat *)((char *)pp +
                            (lastD << 3) + (lastD << 2)));
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            glNormal3fv((GLfloat *)&faces->norm);
            glVertex3fv((GLfloat *)((char *)pp + (a << 3) + (a << 2)));
            glVertex3fv((GLfloat *)((char *)pp + (b << 3) + (b << 2)));
        } else {
            if ((a != lastC) || (b != lastD)) {
                cOffs = (lastC << 3) + (lastC << 2);
                dOffs = (lastD << 3) + (lastD << 2);

                glNormal3fv((GLfloat *)((char *)pn + cOffs));
                glVertex3fv((GLfloat *)((char *)pp + cOffs));
                glNormal3fv((GLfloat *)((char *)pn + dOffs));
                glVertex3fv((GLfloat *)((char *)pp + dOffs));
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            aOffs = (a << 3) + (a << 2);
            bOffs = (b << 3) + (b << 2);

            glNormal3fv((GLfloat *)((char *)pn + aOffs));
            glVertex3fv((GLfloat *)((char *)pp + aOffs));
            glNormal3fv((GLfloat *)((char *)pn + bOffs));
            glVertex3fv((GLfloat *)((char *)pp + bOffs));
        }

        lastC = faces->p[2];
        lastD = faces->p[3];
    }

    if (!bSmooth) {
        glNormal3fv((GLfloat *)&(faces - 1)->norm);
        glVertex3fv((GLfloat *)((char *)pp + (lastC << 3) + (lastC << 2)));
        glVertex3fv((GLfloat *)((char *)pp + (lastD << 3) + (lastD << 2)));
    } else {
        cOffs = (lastC << 3) + (lastC << 2);
        dOffs = (lastD << 3) + (lastD << 2);

        glNormal3fv((GLfloat *)((char *)pn + cOffs));
        glVertex3fv((GLfloat *)((char *)pp + cOffs));
        glNormal3fv((GLfloat *)((char *)pn + dOffs));
        glVertex3fv((GLfloat *)((char *)pp + dOffs));
    }

    glEnd();
}


void MakeList(GLuint listID, MESH *mesh)
{
    int i, j;
    int cnt;
    int a, b, c, d;
    int aOffs, bOffs, cOffs, dOffs;
    MFACE *faces;
    BOOL bSmooth;
    POINT3D *pp;
    POINT3D *pn;
    MATERIAL *pmatl;
    GLint shadeModel;
    int lastC, lastD;

    //glGetIntegerv(GL_SHADE_MODEL, &shadeModel);
    //bSmooth = (shadeModel == GL_SMOOTH);
    bSmooth = (gShadeMode == SHADE_SMOOTH_BOTH);
    if (bSmooth)
        MakeListAxial(listID, mesh);

    glNewList(listID, GL_COMPILE);

    pp = mesh->pts;
    pn = mesh->norms;

    glBegin(GL_QUAD_STRIP);
    for (i = 0; i < mesh->numFacesAxial; i++)
    {
        for (j = 0, faces = &mesh->faces[i], lastC = faces->p[1], lastD = faces->p[3];
             j < mesh->numFacesCircum; j++, faces += mesh->numFacesAxial)
        {
            a = faces->p[1];
            b = faces->p[3];

            if (!bSmooth) {

                if ((a != lastC) || (b != lastD)) {
                    //glNormal3fv((GLfloat *)&((faces - 1)->norm));
                    glNormal3fv((GLfloat *)&(mesh->faces[i].norm));

                    glVertex3fv((GLfloat *) &pp[lastC]);
                    glVertex3fv((GLfloat *) &pp[lastD]);

                    //glVertex3fv((GLfloat *)((char *)pp +
                    //            (lastC << 3) + (lastC << 2)));
                    //glVertex3fv((GLfloat *)((char *)pp +
                    //            (lastD << 3) + (lastD << 2)));

                    glEnd();
                    glBegin(GL_QUAD_STRIP);
                }

                glNormal3fv((GLfloat *)&faces->norm);

                glVertex3fv((GLfloat *) &pp[a]);
                glVertex3fv((GLfloat *) &pp[b]);

                //glVertex3fv((GLfloat *)((char *)pp + (a << 3) + (a << 2)));
                //glVertex3fv((GLfloat *)((char *)pp + (b << 3) + (b << 2)));
            } else {
                if ((a != lastC) || (b != lastD)) {
                    cOffs = (lastC << 3) + (lastC << 2);
                    dOffs = (lastD << 3) + (lastD << 2);

                    glNormal3fv((GLfloat *) &pn[lastC]);
                    glVertex3fv((GLfloat *) &pp[lastC]);
                    glNormal3fv((GLfloat *) &pn[lastD]);
                    glVertex3fv((GLfloat *) &pp[lastD]);

                    //glNormal3fv((GLfloat *)((char *)pn + cOffs));
                    //glVertex3fv((GLfloat *)((char *)pp + cOffs));
                    //glNormal3fv((GLfloat *)((char *)pn + dOffs));
                    //glVertex3fv((GLfloat *)((char *)pp + dOffs));

                    glEnd();
                    glBegin(GL_QUAD_STRIP);
                }

                aOffs = (a << 3) + (a << 2);
                bOffs = (b << 3) + (b << 2);

                glNormal3fv((GLfloat *) &pn[a]);
                glVertex3fv((GLfloat *) &pp[a]);
                glNormal3fv((GLfloat *) &pn[b]);
                glVertex3fv((GLfloat *) &pp[b]);

                //glNormal3fv((GLfloat *)((char *)pn + aOffs));
                //glVertex3fv((GLfloat *)((char *)pp + aOffs));
                //glNormal3fv((GLfloat *)((char *)pn + bOffs));
                //glVertex3fv((GLfloat *)((char *)pp + bOffs));
            }

            lastC = faces->p[0];
            lastD = faces->p[2];
        }

        if (!bSmooth) {
            glNormal3fv((GLfloat *)&(mesh->faces[i].norm));

            glVertex3fv((GLfloat *) &pp[lastC]);
            glVertex3fv((GLfloat *) &pp[lastD]);

            //glVertex3fv((GLfloat *)((char *)pp + (lastC << 3) + (lastC << 2)));
            //glVertex3fv((GLfloat *)((char *)pp + (lastD << 3) + (lastD << 2)));
        } else {
            cOffs = (lastC << 3) + (lastC << 2);
            dOffs = (lastD << 3) + (lastD << 2);

            glNormal3fv((GLfloat *) &pn[lastC]);
            glVertex3fv((GLfloat *) &pp[lastC]);
            glNormal3fv((GLfloat *) &pn[lastD]);
            glVertex3fv((GLfloat *) &pp[lastD]);

            //glNormal3fv((GLfloat *)((char *)pn + cOffs));
            //glVertex3fv((GLfloat *)((char *)pp + cOffs));
            //glNormal3fv((GLfloat *)((char *)pn + dOffs));
            //glVertex3fv((GLfloat *)((char *)pp + dOffs));
        }
    }

    glEnd();

    glEndList();
}

// This version builds the strip along the axial direction.

void MakeListAxial(GLuint listID, MESH *mesh)
{
    int i, j;
    int cnt;
    int a, b, c, d;
    int aOffs, bOffs, cOffs, dOffs;
    MFACE *faces;
    BOOL bSmooth;
    POINT3D *pp;
    POINT3D *pn;
    MATERIAL *pmatl;
    GLint shadeModel;
    int lastC, lastD;

    glGetIntegerv(GL_SHADE_MODEL, &shadeModel);

    bSmooth = (shadeModel == GL_SMOOTH);

    glNewList(listID, GL_COMPILE);

    pp = mesh->pts;
    pn = mesh->norms;

    glBegin(GL_QUAD_STRIP);
    for (i = 0, faces = mesh->faces, lastC = faces->p[0], lastD = faces->p[1];
         i < mesh->numFaces; i++, faces++) {

        a = faces->p[0];
        b = faces->p[1];

        if (!bSmooth) {

            if ((a != lastC) || (b != lastD)) {
                glNormal3fv((GLfloat *)&((faces - 1)->norm));

                glVertex3fv((GLfloat *)((char *)pp +
                            (lastC << 3) + (lastC << 2)));
                glVertex3fv((GLfloat *)((char *)pp +
                            (lastD << 3) + (lastD << 2)));
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            glNormal3fv((GLfloat *)&faces->norm);

            //glVertex3fv((GLfloat *) &pp[a]);
            //glVertex3fv((GLfloat *) &pp[b]);

            glVertex3fv((GLfloat *)((char *)pp + (a << 3) + (a << 2)));
            glVertex3fv((GLfloat *)((char *)pp + (b << 3) + (b << 2)));
        } else {
            if ((a != lastC) || (b != lastD)) {
                cOffs = (lastC << 3) + (lastC << 2);
                dOffs = (lastD << 3) + (lastD << 2);

                //glNormal3fv((GLfloat *) &pn[c]);
                //glVertex3fv((GLfloat *) &pp[c]);
                //glNormal3fv((GLfloat *) &pn[d]);
                //glVertex3fv((GLfloat *) &pp[d]);

                glNormal3fv((GLfloat *)((char *)pn + cOffs));
                glVertex3fv((GLfloat *)((char *)pp + cOffs));
                glNormal3fv((GLfloat *)((char *)pn + dOffs));
                glVertex3fv((GLfloat *)((char *)pp + dOffs));

                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            aOffs = (a << 3) + (a << 2);
            bOffs = (b << 3) + (b << 2);

            //glNormal3fv((GLfloat *) &pn[a]);
            //glVertex3fv((GLfloat *) &pp[a]);
            //glNormal3fv((GLfloat *) &pn[b]);
            //glVertex3fv((GLfloat *) &pp[b]);

            glNormal3fv((GLfloat *)((char *)pn + aOffs));
            glVertex3fv((GLfloat *)((char *)pp + aOffs));
            glNormal3fv((GLfloat *)((char *)pn + bOffs));
            glVertex3fv((GLfloat *)((char *)pp + bOffs));
        }

        lastC = faces->p[2];
        lastD = faces->p[3];
    }

    if (!bSmooth) {
        glNormal3fv((GLfloat *)&((faces - 1)->norm));
        glVertex3fv((GLfloat *)((char *)pp + (lastC << 3) + (lastC << 2)));
        glVertex3fv((GLfloat *)((char *)pp + (lastD << 3) + (lastD << 2)));
    } else {
        cOffs = (lastC << 3) + (lastC << 2);
        dOffs = (lastD << 3) + (lastD << 2);

        glNormal3fv((GLfloat *)((char *)pn + cOffs));
        glVertex3fv((GLfloat *)((char *)pp + cOffs));
        glNormal3fv((GLfloat *)((char *)pn + dOffs));
        glVertex3fv((GLfloat *)((char *)pp + dOffs));
    }

    glEnd();

    glEndList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\math.c ===
#include <windows.h>
#include <GL\gl.h>
#include <math.h>
#include "mesh.h"

POINT3D ptZero = {0.0f, 0.0f, 0.0f};


void xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]) + mat->M[0][3];

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]) + mat->M[1][3];

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]) + mat->M[2][3];

    ptOut->x = (float) x;
    ptOut->y = (float) y;
    ptOut->z = (float) z;
}

void xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;
    double len;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]);

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]);

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]);

    len = (x * x) + (y * y) + (z * z);
    if (len >= ZERO_EPS)
        len = 1.0 / sqrt(len);
    else
        len = 1.0;

    ptOut->x = (float) (x * len);
    ptOut->y = (float) (y * len);
    ptOut->z = (float) (z * len);
    return;
}

void matrixIdent(MATRIX *mat)
{
    mat->M[0][0] = 1.0f; mat->M[0][1] = 0.0f;
    mat->M[0][2] = 0.0f; mat->M[0][3] = 0.0f;

    mat->M[1][0] = 0.0f; mat->M[1][1] = 1.0f;
    mat->M[1][2] = 0.0f; mat->M[1][3] = 0.0f;

    mat->M[2][0] = 0.0f; mat->M[2][1] = 0.0f;
    mat->M[2][2] = 1.0f; mat->M[2][3] = 0.0f;

    mat->M[3][0] = 0.0f; mat->M[3][1] = 0.0f;
    mat->M[3][2] = 0.0f; mat->M[3][3] = 1.0f;
}

void matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta)
{
    float xScale, yScale, zScale;
    float sinX, cosX;
    float sinY, cosY;
    float sinZ, cosZ;

    xScale = m->M[0][0];
    yScale = m->M[1][1];
    zScale = m->M[2][2];
    sinX = (float) sin(xTheta);
    cosX = (float) cos(xTheta);
    sinY = (float) sin(yTheta);
    cosY = (float) cos(yTheta);
    sinZ = (float) sin(zTheta);
    cosZ = (float) cos(zTheta);

    m->M[0][0] = (float) ((cosZ * cosY) * xScale);
    m->M[0][1] = (float) ((cosZ * -sinY * -sinX + sinZ * cosX) * yScale);
    m->M[0][2] = (float) ((cosZ * -sinY * cosX + sinZ * sinX) * zScale);

    m->M[1][0] = (float) (-sinZ * cosY * xScale);
    m->M[1][1] = (float) ((-sinZ * -sinY * -sinX + cosZ * cosX) * yScale);
    m->M[1][2] = (float) ((-sinZ * -sinY * cosX + cosZ * sinX) * zScale);

    m->M[2][0] = (float) (sinY * xScale);
    m->M[2][1] = (float) (cosY * -sinX * yScale);
    m->M[2][2] = (float) (cosY * cosX * zScale);
}

void matrixTranslate(MATRIX *m, double xTrans, double yTrans,
                     double zTrans)
{
    m->M[0][3] = (float) xTrans;
    m->M[1][3] = (float) yTrans;
    m->M[2][3] = (float) zTrans;
}

void calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3)
{
    float crossX, crossY, crossZ;
    float abX, abY, abZ;
    float acX, acY, acZ;
    float sqrLength;
    float invLength;

    abX = p2->x - p1->x;       // calculate p2 - p1
    abY = p2->y - p1->y;
    abZ = p2->z - p1->z;

    acX = p3->x - p1->x;       // calculate p3 - p1
    acY = p3->y - p1->y;
    acZ = p3->z - p1->z;

    crossX = (abY * acZ) - (abZ * acY);    // get cross product
    crossY = (abZ * acX) - (abX * acZ);    // (p2 - p1) X (p3 - p1)
    crossZ = (abX * acY) - (abY * acX);

    sqrLength = (crossX * crossX) + (crossY * crossY) +
                 (crossZ * crossZ);

    if (sqrLength > ZERO_EPS)
        invLength = (float) (1.0 / sqrt(sqrLength));
    else
        invLength = 1.0f;

    norm->x = crossX * invLength;
    norm->y = crossY * invLength;
    norm->z = crossZ * invLength;
}

void normalizeNorms(POINT3D *p, ULONG cPts)
{
    float len;
    ULONG i;

    for (i = 0; i < cPts; i++, p++) {
        len = (p->x * p->x) + (p->y * p->y) + (p->z * p->z);
        if (len > ZERO_EPS)
            len = (float) (1.0 / sqrt(len));
        else
            len = 1.0f;

        p->x *= len;
        p->y *= len;
        p->z *= len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\mesh.h ===
#define ZERO_EPS    0.00000001

#define PI      3.14159265358979323846

typedef struct strpoint3d {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} POINT3D;

typedef struct _MATRIX {
    GLfloat M[4][4];
} MATRIX;

typedef struct strRGBA {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
} RGBA;

typedef struct strMATERIAL {
    RGBA ka;
    RGBA kd;
    RGBA ks;
    GLfloat specExp;
    GLfloat indexStart;
} MATERIAL;

typedef struct strFACE {
    POINT3D p[4];
    POINT3D n[4];
    POINT3D fn;
    int idMatl;
} FACE;

typedef struct strMFACE {
    int p[4];
    int material;
    POINT3D norm;
} MFACE;

typedef struct strMESH {
    int numFaces;
    int numFacesAxial;
    int numFacesCircum;
    int numPoints;
    POINT3D *pts;
    POINT3D *norms;
    MFACE *faces;
    GLint listID;
} MESH;

typedef struct strCURVE {
    int numPoints;
    POINT3D *pts;
} CURVE;

extern void xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void matrixIdent(MATRIX *);
extern void matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta);
extern void matrixTranslate(MATRIX *, double xTrans, double yTrans, double zTrans);
extern void calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3);
extern void normalizeNorms(POINT3D *, ULONG);

extern BOOL newMesh(MESH *mesh, int numAxial, int numCircum);
extern void delMesh(MESH *mesh);
extern BOOL revolveSurface(MESH *mesh, CURVE *curve, int steps);
extern void updateObject(MESH *mesh, BOOL bSmooth);
extern void MakeList(GLuint listID, MESH *mesh);
extern void MakeListAxial(GLuint listID, MESH *mesh);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\lathe.c ===
#include <windows.h>

#include <GL\gl.h>
#include <GL\glu.h>

#include "mesh.h"
#include "globals.h"

typedef struct _WINDOWINFO {
    HINSTANCE   hInstance;
    HINSTANCE   hPrevInstance;
    LPSTR       lpCmdLine;
    int         nCmdShow;
} WINDOWINFO;

HANDLE hInputThread;

LPTHREAD_START_ROUTINE InputThread(WINDOWINFO *pwinfo)
{
    MSG msg;

    CreateObjectWindow(
        pwinfo->hInstance,
        pwinfo->hPrevInstance,
        pwinfo->lpCmdLine,
        pwinfo->nCmdShow
        );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    return( msg.wParam );
}

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    MSG msg;
    DWORD tidInput;
    WINDOWINFO winfo;

    CreateInputWindow(
        hInstance,
        hPrevInstance,
        lpCmdLine,
        nCmdShow
        );

    winfo.hInstance     = hInstance;
    winfo.hPrevInstance = hPrevInstance;
    winfo.lpCmdLine     = lpCmdLine;
    winfo.nCmdShow      = nCmdShow;

    hInputThread = CreateThread(
                        (LPSECURITY_ATTRIBUTES) NULL,
                        0,
                        InputThread,
                        (LPVOID) &winfo,
                        0,
                        &tidInput
                        );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    return( msg.wParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\lathe\object.c ===
#include <windows.h>
#include <stdio.h>
#include <math.h>

#include <GL\gl.h>
#include <GL\glu.h>

#include "mesh.h"
#include "trackbal.h"
#include "globals.h"

static const RGBA lightAmbient   = {0.21f, 0.21f, 0.21f, 1.0f};
static const RGBA light0Ambient  = {0.0f, 0.0f, 0.0f, 1.0f};
static const RGBA light0Diffuse  = {0.7f, 0.7f, 0.7f, 1.0f};
static const RGBA light0Specular = {1.0f, 1.0f, 1.0f, 1.0f};
static const GLfloat light0Pos[]      = {100.0f, 100.0f, 100.0f, 0.0f};

#define PALETTE_PER_MATL    32
#define PALETTE_PER_DIFF    26
#define PALETTE_PER_SPEC    6
#define MATL_MAX            7
MATERIAL Material[16];
static RGBA matlColors[MATL_MAX] = {{1.0f, 0.0f, 0.0f, 1.0f},
                                    {0.0f, 1.0f, 0.0f, 1.0f},
                                    {0.0f, 0.0f, 1.0f, 1.0f},
                                    {1.0f, 1.0f, 0.0f, 1.0f},
                                    {0.0f, 1.0f, 1.0f, 1.0f},
                                    {1.0f, 0.0f, 1.0f, 1.0f},
                                    {0.235f, 0.0f, 0.78f, 1.0f},
                                   };

// Global variables defining current position and orientation.
GLuint  DListCube;
UINT    guiTimerTick = 1;
POINT   gptWindow;
SIZE    gszWindow;
RECT    grcCurWindow;
float   curquat[4], lastquat[4];
LONG    glMouseDownX, glMouseDownY;
BOOL    gbLeftMouse = FALSE;
BOOL    gbSpinning = FALSE;
SHADE   gShadeMode = SHADE_FLAT;
POLYDRAW gPolyDrawMode = POLYDRAW_FILLED;
GLfloat gfCurEyeZ = 5.0f, gfGoToEyeZ = 5.0f;

MESH  mesh;
CURVE curve;
POINT3D apt[] = {
//    {0.0f, 1.0f, 0.0f},
//    {1.0f, 0.8f, 0.0f},
//    {0.5f, -0.8f, 0.0f},
//    {0.0f, -1.0f, 0.0f}
    {0.3f, 0.5f, 0.0f},
    {1.0f, 0.4f, 0.0f},
    {0.5f, -0.4f, 0.0f},
    {0.3f, -0.5f, 0.0f},
    {0.3f, 0.5f, 0.0f}
    };
int steps = 12;

HGLRC ghrc = (HGLRC) 0;

HPALETTE ghpalOld, ghPalette = (HPALETTE) 0;

HWND ghwndObject;

void CreateObjectWindow( HINSTANCE   hInstance,
                        HINSTANCE   hPrevInstance,
                        LPSTR       lpCmdLine,
                        int         nCmdShow
                      )
{
    static char szAppName[] = "Lathe";
    static char szIniFile[] = "lathe.ini";
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        wndclass.style          = CS_OWNDC;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        //wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hCursor        = NULL;
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        // With a NULL icon handle, app will paint into the icon window.
        wndclass.hIcon          = NULL;
        //wndclass.hIcon          = LoadIcon(hInstance, "CubeIcon");

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = GetPrivateProfileInt("ObjectWindow", "left",   500, szIniFile);
    Rect.top    = GetPrivateProfileInt("ObjectWindow", "top",    50, szIniFile);
    Rect.right  = GetPrivateProfileInt("ObjectWindow", "right",  900, szIniFile);
    Rect.bottom = GetPrivateProfileInt("ObjectWindow", "bottom", 450, szIniFile);
    guiTimerTick= GetPrivateProfileInt("Animate", "Timer", 1,  szIniFile);

    gptWindow.x = Rect.left;
    gptWindow.y = Rect.top;
    gszWindow.cx = WINDSIZEX(Rect);
    gszWindow.cy = WINDSIZEY(Rect);

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

    ghwndObject = CreateWindow(szAppName,              // window class name
                               "Lathe",                // window caption
                               WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                               Rect.left,              // initial x position
                               Rect.top,               // initial y position
                               WINDSIZEX(Rect),        // initial x size
                               WINDSIZEY(Rect),        // initial y size
                               NULL,                   // parent window handle
                               NULL,                   // window menu handle
                               hInstance,              // program instance handle
                               NULL                    // creation parameter
                               );

    ShowWindow( ghwndObject, nCmdShow );
    UpdateWindow( ghwndObject );

    SetTimer(ghwndObject, 1, guiTimerTick, NULL);
}

long
WndProc (   HWND hwnd,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
        )
{
    HDC hdc;
    PAINTSTRUCT ps;

    switch ( message )
    {
        case WM_CREATE:
            if(hdc = GetDC(hwnd))
            {
                if (ghrc == (HGLRC) 0)
                    ghrc = hrcInitGL(hwnd, hdc);

                ReleaseDC(hwnd,hdc);
            }
            break;

        case WM_PAINT:
            hdc = BeginPaint( hwnd, &ps );

            if (ghrc == (HGLRC) 0)
                ghrc = hrcInitGL(hwnd, hdc);

            DoGlStuff( hwnd, hdc );

            EndPaint( hwnd, &ps );
            return 0;

        case WM_MOVE:
            gptWindow.x = (int) LOWORD(lParam);
            gptWindow.y = (int) HIWORD(lParam);

            return 0;

        case WM_SIZE:
            gszWindow.cx = LOWORD(lParam);
            gszWindow.cy = HIWORD(lParam);
            vSetSize(hwnd);
            ForceRedraw(hwnd);

            return 0;

        case WM_PALETTECHANGED:
            if (hwnd != (HWND) wParam)
            {
                if (hdc = GetDC(hwnd))
                {
                    UnrealizeObject(ghPalette);
                    SelectPalette(hdc, ghPalette, TRUE);
                    if (RealizePalette(hdc) != GDI_ERROR)
                        return 1;
                }
            }
            return 0;

        case WM_QUERYNEWPALETTE:

            if (hdc = GetDC(hwnd))
            {
                UnrealizeObject(ghPalette);
                SelectPalette(hdc, ghPalette, FALSE);
                if (RealizePalette(hdc) != GDI_ERROR)
                    return 1;
            }
            return 0;

        case WM_KEYDOWN:
            switch (wParam)
            {
            case VK_ESCAPE:
                PostMessage(hwnd, WM_DESTROY, 0, 0);
                break;
            case VK_UP:
                gfGoToEyeZ -= 1.0f;
                break;
            case VK_DOWN:
                gfGoToEyeZ += 1.0f;
                break;
            default:
                break;
            }
            return 0;

        case WM_LBUTTONDOWN:

            SetCapture(hwnd);

            glMouseDownX = LOWORD(lParam);
            glMouseDownY = HIWORD(lParam);
            gbLeftMouse = TRUE;

            ForceRedraw(hwnd);

            return 0;

        case WM_LBUTTONUP:

            ReleaseCapture();

            gbLeftMouse = FALSE;

            ForceRedraw(hwnd);

            return 0;

        case WM_CHAR:
            switch(wParam)
            {
                case '[':
                case '{':
                    guiTimerTick = guiTimerTick << 1;
                    guiTimerTick = min(0x40000000, guiTimerTick);

                    KillTimer(hwnd, 1);
                    SetTimer(hwnd, 1, guiTimerTick, NULL);
                    break;

                case ']':
                case '}':
                    guiTimerTick = guiTimerTick >> 1;
                    guiTimerTick = max(1, guiTimerTick);

                    KillTimer(hwnd, 1);
                    SetTimer(hwnd, 1, guiTimerTick, NULL);
                    break;

                case ',':
                case '<':
                    if (steps > 4)  // also have at least 3 sides -- its 3D!
                    {
                        steps--;
                        vMakeObject();
                    }
                    break;

                case '.':
                case '>':
                    steps++;
                    vMakeObject();
                    break;

                case 's':
                case 'S':
                    gShadeMode = (gShadeMode + 1) % 3;
                    switch (gShadeMode)
                    {
                        case SHADE_SMOOTH_AROUND:
                        case SHADE_SMOOTH_BOTH:
                            glShadeModel(GL_SMOOTH);
                            break;
                        case SHADE_FLAT:
                        default:
                            glShadeModel(GL_FLAT);
                            break;
                    }
                    vMakeObject();
                    break;

                case 'w':
                case 'W':
                    gPolyDrawMode = (gPolyDrawMode + 1) % 3;
                    switch (gPolyDrawMode)
                    {
                        case POLYDRAW_POINTS:
                            glDisable(GL_LIGHTING);
                            glDisable(GL_CULL_FACE);
                            glEnable(GL_FOG);
                            //glDisable(GL_STENCIL_TEST);
                            glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
                            break;
                        case POLYDRAW_LINES:
                            glDisable(GL_LIGHTING);
                            glDisable(GL_CULL_FACE);
                            glEnable(GL_FOG);
                            //glEnable(GL_STENCIL_TEST);
                            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
                            break;
                        case POLYDRAW_FILLED:
                        default:
                            glEnable(GL_LIGHTING);
                            glEnable(GL_CULL_FACE);
                            glDisable(GL_FOG);
                            //glDisable(GL_STENCIL_TEST);
                            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
                            break;
                    }
                    break;

                default:
                    break;
            }

            return 0;

        case WM_TIMER:

            hdc = GetDC(hwnd);

            if (ghrc == (HGLRC) 0)
                ghrc = hrcInitGL(hwnd, hdc);

            if ( fabs(gfCurEyeZ - gfGoToEyeZ) > 0.1f )
            {
                gfCurEyeZ += (gfCurEyeZ < gfGoToEyeZ) ? 0.2f : -0.2f;
                vSetSize(hwnd);
            }

            DoGlStuff( hwnd, hdc );

            ReleaseDC(hwnd, hdc);

            return 0;

        #if 1
        case WM_DESTROY:
            vCleanupGL(ghrc);
            KillTimer(hwnd, 1);
            PostQuitMessage( 0 );
            PostMessage(ghwndInput, WM_QUIT, 0, 0);  // quit input thread too
            return 0;
        #endif

        case WM_USER_INPUTMESH:
            vMeshToList();
            return 0;

        default:
            break;
    }
    return( DefWindowProc( hwnd, message, wParam, lParam ) );
}

unsigned char threeto8[8] = {
    0, 0111>>1, 0222>>1, 0333>>1, 0444>>1, 0555>>1, 0666>>1, 0377
};

unsigned char twoto8[4] = {
    0, 0x55, 0xaa, 0xff
};

unsigned char oneto8[2] = {
    0, 255
};

unsigned char
ComponentFromIndex(i, nbits, shift)
{
    unsigned char val;

    val = i >> shift;
    switch (nbits) {

    case 1:
        val &= 0x1;
        return oneto8[val];

    case 2:
        val &= 0x3;
        return twoto8[val];

    case 3:
        val &= 0x7;
        return threeto8[val];

    default:
        return 0;
    }
}

void
CreateRGBPalette(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    LOGPALETTE *pPal;
    int n, i;

    ppfd = &pfd;
    n = GetPixelFormat(hdc);
    DescribePixelFormat(hdc, n, sizeof(PIXELFORMATDESCRIPTOR), ppfd);

    if (ppfd->dwFlags & PFD_NEED_PALETTE) {
        n = 1 << ppfd->cColorBits;
        pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
                n * sizeof(PALETTEENTRY));
        pPal->palVersion = 0x300;
        pPal->palNumEntries = n;
        for (i=0; i<n; i++) {
            pPal->palPalEntry[i].peRed =
                    ComponentFromIndex(i, ppfd->cRedBits, ppfd->cRedShift);
            pPal->palPalEntry[i].peGreen =
                    ComponentFromIndex(i, ppfd->cGreenBits, ppfd->cGreenShift);
            pPal->palPalEntry[i].peBlue =
                    ComponentFromIndex(i, ppfd->cBlueBits, ppfd->cBlueShift);
            pPal->palPalEntry[i].peFlags = (i == 0 || i == 255) ? 0 : PC_NOCOLLAPSE;
        }
        ghPalette = CreatePalette(pPal);
        LocalFree(pPal);

        //SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC);

        ghpalOld = SelectPalette(hdc, ghPalette, FALSE);
        n = RealizePalette(hdc);
        UnrealizeObject(ghPalette);
        n = RealizePalette(hdc);
    }
}

BOOL bSetupPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    int pixelformat;

    ppfd = &pfd;

    ppfd->nSize = sizeof(PIXELFORMATDESCRIPTOR);
    ppfd->nVersion = 1;
    ppfd->dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    ppfd->dwLayerMask = PFD_MAIN_PLANE;

    ppfd->iPixelType = PFD_TYPE_RGBA;
    ppfd->cColorBits = 24;

    ppfd->cDepthBits = 16;
    ppfd->cAccumBits = 0;
    ppfd->cStencilBits = 0;

    pixelformat = ChoosePixelFormat(hdc, ppfd);

    if ( (pixelformat = ChoosePixelFormat(hdc, ppfd)) == 0 )
    {
        MessageBox(NULL, "ChoosePixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    if (SetPixelFormat(hdc, pixelformat, ppfd) == FALSE)
    {
        MessageBox(NULL, "SetPixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    CreateRGBPalette(hdc);

    return TRUE;
}


void initMaterial(int id, float r, float g, float b, float a)
{
    Material[id].ka.r = r;
    Material[id].ka.g = g;
    Material[id].ka.b = b;
    Material[id].ka.a = a;

    Material[id].kd.r = r;
    Material[id].kd.g = g;
    Material[id].kd.b = b;
    Material[id].kd.a = a;

    Material[id].ks.r = 1.0f;
    Material[id].ks.g = 1.0f;
    Material[id].ks.b = 1.0f;
    Material[id].ks.a = 1.0f;

    Material[id].specExp = 128.0f;
    Material[id].indexStart = (float) (id * PALETTE_PER_MATL);
}

HGLRC hrcInitGL(HWND hwnd, HDC hdc)
{
    HGLRC hrc;
    int i;
    GLfloat fDens = 0.25;

    /* Create a Rendering Context */

    bSetupPixelFormat( hdc );
    hrc = wglCreateContext( hdc );

    /* Make it Current */

    wglMakeCurrent( hdc, hrc );

    glDrawBuffer(GL_BACK);

    /* Set the clear color */

    glClearColor( ZERO, ZERO, ZERO, ONE );

    /* Turn on z-buffer */

    glEnable(GL_DEPTH_TEST);

    /* Turn on backface culling */

    glEnable(GL_CULL_FACE);

    /* Shading */

    //glShadeModel(GL_SMOOTH);
    glShadeModel(GL_FLAT);

    /* Initialize materials */

    for (i = 0; i < 7; i++)
        initMaterial(i, matlColors[i].r, matlColors[i].g,
                     matlColors[i].b, matlColors[i].a);

    /* Turn on the lights */

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (GLfloat *) &lightAmbient);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);
    glLightfv(GL_LIGHT0, GL_AMBIENT, (GLfloat *) &light0Ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, (GLfloat *) &light0Diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, (GLfloat *) &light0Specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (GLfloat *) &Material[0].ks);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, (GLfloat *) &Material[0].specExp);
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, (GLfloat *) &Material[0].kd);

    glColor4f( ONE, ONE, ONE, ONE );
    glFogi(GL_FOG_MODE, GL_EXP);
    glFogfv(GL_FOG_DENSITY, &fDens);
    //glFogi(GL_FOG_MODE, GL_LINEAR);
    //glFogi(GL_FOG_END, 10);

    /* Generate a display list for a cube */

    DListCube = glGenLists(1);

    curve.numPoints = sizeof(apt) / sizeof(POINT3D);
    curve.pts = apt;
    vMakeObject();

    vSetSize(hwnd);

    trackball(curquat, 0.0, 0.0, 0.0, 0.0);

    return hrc;
}

VOID vMakeObject()
{
    if (glIsList(DListCube))
    {
        glDeleteLists(DListCube, 1);
        delMesh(&mesh);
    }

    revolveSurface(&mesh, &curve, steps);
    MakeList(DListCube, &mesh);
}

VOID vInputThreadMakeObject()
{
    delMesh(&mesh);
    revolveSurface(&mesh, &curve, steps);
    SendMessage(ghwndObject, WM_USER_INPUTMESH, 0, 0);
}

VOID vMeshToList()
{
    if (glIsList(DListCube))
    {
        glDeleteLists(DListCube, 1);
    }

    MakeList(DListCube, &mesh);
}

VOID vSetSize(HWND hwnd)
{
    /* Set up viewport extents */

    glViewport(0, 0, gszWindow.cx, gszWindow.cy);

    /* Set up the projection matrix */

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45, 1.0, 0.1, 100.0);

    /* Set up the model matrix */

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(0,0,gfCurEyeZ, 0,0,0, 0,-1,0);
}

void
vCleanupGL(HGLRC hrc)
{
    glDeleteLists(DListCube, 1);
    delMesh(&mesh);

    //if (ghPalette)
    //    DeleteObject(SelectObject(ghdcMem, ghpalOld));

    /*  Destroy our context */

    wglDeleteContext( hrc );

}

void
ForceRedraw(HWND hwnd)
{
    MSG msg;

    if (!PeekMessage(&msg, hwnd, WM_PAINT, WM_PAINT, PM_NOREMOVE) )
    {
        InvalidateRect(hwnd, NULL, FALSE);
    }
}

void
DoGlStuff( HWND hwnd, HDC hdc )
{
    USHORT usMouseCurX, usMouseCurY;
    POINT  pt;
    float  matRot[4][4];

    if (gbLeftMouse)
    {
        if (GetCursorPos(&pt))
        {
        // Subtract current window origin to convert to window coordinates.

            pt.x -= gptWindow.x;
            pt.y -= gptWindow.y;

        // If mouse has moved since button was pressed, change quaternion.

            if (pt.x != glMouseDownX || pt.y != glMouseDownY)
            {
                trackball(lastquat,
                          2.0*(gszWindow.cx-glMouseDownX)/gszWindow.cx-1.0,
                          2.0*glMouseDownY/gszWindow.cy-1.0,
                          2.0*(gszWindow.cx-pt.x)/gszWindow.cx-1.0,
                          2.0*pt.y/gszWindow.cy-1.0);

                gbSpinning = TRUE;
            }
            else
                gbSpinning = FALSE;

            glMouseDownX = pt.x;
            glMouseDownY = pt.y;
        }
    }

    glPushMatrix();

    if (gbSpinning)
        add_quats(lastquat, curquat, curquat);

    build_rotmatrix(matRot, curquat);
    glMultMatrixf(&(matRot[0][0]));

#if 0
    if (gPolyDrawMode == POLYDRAW_LINES)
    {
    // Use stencil buffer technique to do hidden line removal.

        glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT );

#if 1
    // Create a stencil mask using the lines.

        glStencilFunc( GL_ALWAYS, 0, 1 );
        glStencilOp( GL_INVERT, GL_INVERT, GL_INVERT );
        glColor4f( ONE, ONE, ONE, ONE );
        glCallList(DListCube);

    // Fill in the faces where there aren't already lines.

        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

        glStencilFunc( GL_EQUAL, 0, 1 );
        glStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
        glColor4f( ZERO, ZERO, ZERO, ONE );
        glCallList(DListCube);

    // ????

        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

        glStencilFunc( GL_ALWAYS, 0, 1 );
        glStencilOp( GL_INVERT, GL_INVERT, GL_INVERT );
        glColor4f( ONE, ONE, ONE, ONE );
        glCallList(DListCube);
#else
        glDisable(GL_STENCIL_TEST);
        glDepthFunc(GL_LEQUAL);

        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

        glColor4f( ZERO, ZERO, ZERO, ONE );
        glCallList(DListCube);

        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

        glColor4f( ONE, ONE, ONE, ONE );
        glCallList(DListCube);

        glDepthFunc(GL_LESS);
#endif
    }
    else
#endif
    {
        glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
        glCallList(DListCube);
    }

    glPopMatrix();

    SwapBuffers(hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\alpha3d.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  alpha3D.c
 *  This program demonstrates how to intermix opaque and
 *  alpha blended polygons in the same scene, by using glDepthMask.
 *  Pressing the left mouse button toggles the eye position.
 */
#include "pch.c"
#pragma hdrstop

static void myinit(void)
{
    GLfloat mat_ambient[] = { 0.0, 0.0, 0.0, 0.15 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 0.15 };
    GLfloat mat_shininess[] = { 15.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    glEnable (GL_LIGHTING);
    glEnable (GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

static GLboolean eyePosition = GL_FALSE;

static void toggleEye (AUX_EVENTREC *event)
{
    if (eyePosition)
	eyePosition = GL_FALSE;
    else
	eyePosition = GL_TRUE;
}

static void display(void)
{
    GLfloat position[] = { 0.0, 0.0, 1.0, 1.0 };
    GLfloat mat_torus[] = { 0.75, 0.75, 0.0, 1.0 };
    GLfloat mat_cylinder[] = { 0.0, 0.75, 0.75, 0.15 };

    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLightfv (GL_LIGHT0, GL_POSITION, position);
    glPushMatrix ();
	if (eyePosition)
	    gluLookAt (0.0, 0.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0); 
	else 
	    gluLookAt (0.0, 0.0, -9.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0); 
	glPushMatrix ();
	glTranslatef (0.0, 0.0, 1.0);    
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_torus);
	auxSolidTorus (0.275, 0.85);
	glPopMatrix ();

	glEnable (GL_BLEND);
	glDepthMask (GL_FALSE);
	glBlendFunc (GL_SRC_ALPHA, GL_ONE);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_cylinder);
	glTranslatef (0.0, 0.0, -1.0);    
	auxSolidCylinder (1.0, 2.0);
	glDepthMask (GL_TRUE);
	glDisable (GL_BLEND);
    glPopMatrix ();

    glFlush ();
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(30.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

static void OglBounds(int *w, int *h)
{
    *w = 500;
    *h = 500;
}

static void OglInit(HDC hdc)
{
    SetHdcPixelFormat(hdc, 8, 0, 16, 0);
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_alpha3d =
{
    "alpha3d",
    NULL,
    OglBounds,
    OglInit,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mandel\mandel.c ===
#include <windows.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>
#include <commdlg.h>
#include "mandel.h"

#undef FLOAT
#define FLOAT double

#if DBG
#define MESSAGEBOX(a, b, c, d)  MessageBox((a), (b), (c), (d))
#else
#define MESSAGEBOX(a, b, c, d)
#endif

typedef struct _RECTF_ {
    FLOAT left;
    FLOAT top;
    FLOAT right;
    FLOAT bottom;
} RECTF, *PRECTF;

LONG WndProc(HWND, UINT, WPARAM, LPARAM);
VOID vDrawMandelbrot(HDC, RECTL *, RECTF *, PBYTE);
VOID vUpdateMenuState(HWND, FLONG);
HPALETTE hpalSetupPalette(HDC);
VOID vRotatePalette(HDC, HPALETTE, int);
BOOL bNewArea(SHORT, SHORT, SHORT, SHORT, RECTL *, RECTF *);
VOID vSetPaletteEntries(LPPALETTEENTRY, UINT, WPARAM);
BOOL bOpenFile(HWND, RECTF *);
BOOL bSaveFile(HWND, RECTF *);
BOOL bSaveTex(HWND, HDC, RECTL *, RECTF *);
BOOL bGetRGBQuads(HDC, RGBQUAD *, int, int);
HBITMAP hbmCreateBitmap(HDC, SIZEL, PVOID *);
VOID SaveBMP(LPTSTR, RGBQUAD *, HBITMAP, PVOID);

PALETTEENTRY gpale[256];

/******************************Public*Routine******************************\
* WinMain
*
* History:
*  03-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "Mandelbrot Set";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;
    char ach[256];
    int  size;

    if ( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
        wndclass.lpfnWndProc    = WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
        wndclass.hbrBackground  = GetStockObject( WHITE_BRUSH );
        wndclass.lpszMenuName   = "MandelMenu";
        wndclass.lpszClassName  = szAppName;
        wndclass.hIcon          = NULL;

        RegisterClass(&wndclass);
    }

// Parse cmd line for size.

    if (lpCmdLine && *lpCmdLine)
        size = atoi(lpCmdLine);
    else
        size = 256;

// Specify a 100 x 100 client area.

    Rect.left   = 0;
    Rect.top    = 0;
    Rect.right  = size;
    Rect.bottom = size;

// Adjust the rectangle based on style.

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, TRUE );

// Create the window.

    hwnd = CreateWindow( szAppName,              // window class name
                         "Mandelbrot",           // window caption
                         WS_OVERLAPPEDWINDOW
                         | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,  // window style
                         CW_USEDEFAULT,          // initial x position
                         CW_USEDEFAULT,          // initial y position
                         Rect.right - Rect.left, // initial x size
                         Rect.bottom - Rect.top, // initial y size
                         //GetDesktopWindow(),                   // parent window handle
                         NULL,                   // parent window handle
                         NULL,                   // window menu handle
                         hInstance,              // program instance handle
                         NULL                    // creation parameter
                       );

// Show the window.

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

// Message loop.

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    return( 0 );
}

/******************************Public*Routine******************************\
* WndProc
*
* History:
*  03-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG
WndProc (   HWND hwnd,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
        )
{
    long lRet = 0;
    PAINTSTRUCT ps;
    HDC hdc;
    RECTL rcl;
    static RECTF rcfReset = { -2.25f, -1.75f, 1.00f, 1.75f };
    static RECTF rcfPrev = { -2.25f, -1.75f, 1.00f, 1.75f };
    static RECTF rcf = { -2.25f, -1.75f, 1.00f, 1.75f };
    static SHORT xMouseStart, yMouseStart, xMouseCur, yMouseCur;
    static BOOL bMouseCapture = FALSE;
    static HPALETTE hpal;
    static BOOL bFirst = TRUE;
    static BOOL bTimer = FALSE;
    static int iPalDelta = -1;
    static FLONG fMenuState = MENUSTATE_COLORBANDS | MENUSTATE_DONTMOVE |
                              MENUSTATE_SLOW;
    static UINT uiTick = 100;

    switch ( message )
    {
        case WM_COMMAND:
            switch (wParam)
            {
                case IDM_GRAYRAMP:
                    fMenuState &= ~MENUSTATE_PALMASK;
                    fMenuState |= MENUSTATE_GRAYRAMP;
                    break;
                case IDM_GRAYBAND:
                    fMenuState &= ~MENUSTATE_PALMASK;
                    fMenuState |= MENUSTATE_GRAYBAND;
                    break;
                case IDM_COLORBANDS:
                    fMenuState &= ~MENUSTATE_PALMASK;
                    fMenuState |= MENUSTATE_COLORBANDS;
                    break;
                case IDM_COPPER:
                    fMenuState &= ~MENUSTATE_PALMASK;
                    fMenuState |= MENUSTATE_COPPER;
                    break;

                case IDM_DONTMOVE:
                    fMenuState &= ~MENUSTATE_ROTMASK;
                    fMenuState |= MENUSTATE_DONTMOVE;
                    break;
                case IDM_ROTATEUP:
                    fMenuState &= ~MENUSTATE_ROTMASK;
                    fMenuState |= MENUSTATE_ROTATEUP;
                    iPalDelta = 1;
                    break;
                case IDM_ROTATEDOWN:
                    fMenuState &= ~MENUSTATE_ROTMASK;
                    fMenuState |= MENUSTATE_ROTATEDOWN;
                    iPalDelta = -1;
                    break;

                case IDM_SLOW:
                    fMenuState &= ~MENUSTATE_SPEEDMASK;
                    fMenuState |= MENUSTATE_SLOW;
                    uiTick = 100;
                    break;
                case IDM_MED:
                    fMenuState &= ~MENUSTATE_SPEEDMASK;
                    fMenuState |= MENUSTATE_MED;
                    uiTick = 50;
                    break;
                case IDM_FAST:
                    fMenuState &= ~MENUSTATE_SPEEDMASK;
                    fMenuState |= MENUSTATE_FAST;
                    uiTick = 1;
                    break;

                case IDM_RESET_POS:
                    rcf = rcfReset;
                    break;
                case IDM_PREV_POS:
                    {
                        RECTF rcfTmp;

                        rcfTmp  = rcf;
                        rcf     = rcfPrev;
                        rcfPrev = rcfTmp;
                    }
                    break;

                default:
                    break;
            }

            vUpdateMenuState(hwnd, fMenuState);

            switch (wParam)
            {
                case IDM_OPENFILE:
                    {
                        RECTF rcfTmp = rcf;

                        if (bOpenFile(hwnd, &rcf))
                        {
                            rcfPrev = rcfTmp;

                        // Force redraw with new coordiates.

                            InvalidateRect(hwnd, NULL, FALSE);
                        }
                    }
                    break;

                case IDM_SAVEFILE:
                    bSaveFile(hwnd, &rcf);
                    break;

                case IDM_SAVETEX:
                    GetClientRect(hwnd, (LPRECT) &rcl);
                    hdc = GetDC(hwnd);
                    if (hdc)
                    {
                        bSaveTex(hwnd, hdc, &rcl, &rcf);
                        ReleaseDC(hwnd, hdc);
                    }
                    break;

                case IDM_GRAYRAMP:
                case IDM_GRAYBAND:
                case IDM_COLORBANDS:
                case IDM_COPPER:
                    vSetPaletteEntries(gpale, 256, wParam);
                    hdc = GetDC(hwnd);
                    if (hdc)
                    {
                        vRotatePalette(hdc, hpal, 0);
                        ReleaseDC(hwnd, hdc);
                    }
                    break;

                case IDM_DONTMOVE:
                    if (bTimer)
                    {
                        KillTimer(hwnd, 1);
                        bTimer = FALSE;
                    }
                    break;

                case IDM_ROTATEUP:
                case IDM_ROTATEDOWN:
                    if (!bTimer)
                    {
                        SetTimer(hwnd, 1, uiTick, NULL);
                        bTimer = TRUE;
                    }
                    break;

                case IDM_ROTRESET:
                    if (!bTimer)
                    {
                        hdc = GetDC(hwnd);
                        if (hdc)
                        {
                            vRotatePalette(hdc, hpal, 0);
                            ReleaseDC(hwnd, hdc);
                        }
                    }
                    break;

                case IDM_SLOW:
                case IDM_MED:
                case IDM_FAST:
                    if (bTimer)
                    {
                        KillTimer(hwnd, 1);
                        SetTimer(hwnd, 1, uiTick, NULL);
                    }
                    break;

                case IDM_RESET_POS:
                case IDM_PREV_POS:

                // Force redraw with new coordiates.

                    InvalidateRect(hwnd, NULL, FALSE);
                    break;

                default:
                    break;
            }

            break;

        #if 0
        case WM_CREATE:
            hdc = GetDC(hwnd);
            if (hdc)
            {
                hpal = hpalSetupPalette(hdc);
                ReleaseDC(hwnd, hdc);
            }
            break;
        #endif

        case WM_PAINT:
            if (bFirst)
            {
                hdc = GetDC(hwnd);
                if (hdc)
                {
                    hpal = hpalSetupPalette(hdc);
                    ReleaseDC(hwnd, hdc);
                }
                bFirst = FALSE;
            }

            GetClientRect(hwnd, (LPRECT) &rcl);

            hdc = BeginPaint(hwnd, &ps);
            if (hdc)
            {
                vDrawMandelbrot(hdc, &rcl, &rcf, NULL);
                EndPaint(hwnd, &ps);
            }
            break;

        case WM_LBUTTONDOWN:

        // Capture mouse.

            SetCapture(hwnd);
            bMouseCapture = TRUE;

            xMouseStart = LOWORD(lParam);
            yMouseStart = HIWORD(lParam);
            xMouseCur = xMouseStart;
            yMouseCur = yMouseStart;

            break;

        case WM_LBUTTONUP:
            GetClientRect(hwnd, (LPRECT) &rcl);

            xMouseCur = LOWORD(lParam);
            yMouseCur = HIWORD(lParam);

            {
                RECTF rcfTmp = rcf;

                if ( bNewArea(xMouseStart, yMouseStart, xMouseCur, yMouseCur,
                              &rcl, &rcf) )
                {
                    rcfPrev = rcfTmp;

                // Force redraw with new coordinates.

                    InvalidateRect(hwnd, NULL, FALSE);
                }
            }

        // Release mouse.

            bMouseCapture = FALSE;
            ReleaseCapture();

            break;

        case WM_MOUSEMOVE:
            if (bMouseCapture)
            {
                if ( hdc = GetDC(hwnd) )
                {
                // Erase previous rectangle if necessary.

                    if ( (xMouseStart != xMouseCur) &&
                         (yMouseStart != yMouseCur) )
                    {
                        BitBlt(hdc,
                               min(xMouseStart, xMouseCur),
                               min(yMouseStart, yMouseCur),
                               abs(xMouseCur - xMouseStart),
                               abs(yMouseCur - yMouseStart),
                               NULL,
                               0,
                               0,
                               DSTINVERT);
                    }

                // Get current position.

                    xMouseCur = LOWORD(lParam);
                    yMouseCur = HIWORD(lParam);

                // Draw new rectangle.

                    if ( (xMouseStart != xMouseCur) &&
                         (yMouseStart != yMouseCur) )
                    {
                        BitBlt(hdc,
                               min(xMouseStart, xMouseCur),
                               min(yMouseStart, yMouseCur),
                               abs(xMouseCur - xMouseStart),
                               abs(yMouseCur - yMouseStart),
                               NULL,
                               0,
                               0,
                               DSTINVERT);
                    }

                    ReleaseDC(hwnd, hdc);
                }
            }
            break;

        case WM_TIMER:
            hdc = GetDC(hwnd);
            if (hdc)
            {
                vRotatePalette(hdc, hpal, iPalDelta);
                ReleaseDC(hwnd, hdc);
            }
            break;

        case WM_KEYDOWN:
            switch (wParam)
            {
            case VK_ESCAPE:     // <ESC> is quick exit

                PostMessage(hwnd, WM_DESTROY, 0, 0);
                break;

            default:
                break;
            }
            break;

        case WM_DESTROY:
            DeleteObject(hpal);
            if (bTimer)
                KillTimer(hwnd, 1);
            PostQuitMessage( 0 );
            break;

        default:
            lRet = DefWindowProc( hwnd, message, wParam, lParam );
            break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* vUpdateMenuState
*
* Make menu consistent with given state (checked/unchecked, grayed/ungrayed,
* etc.).
*
* History:
*  03-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vUpdateMenuState(HWND hwnd, FLONG flState)
{
    HMENU hmen;

    hmen = GetMenu(hwnd);

    CheckMenuItem(hmen, IDM_GRAYRAMP  , (flState & MENUSTATE_GRAYRAMP  ) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_GRAYBAND  , (flState & MENUSTATE_GRAYBAND  ) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_COLORBANDS, (flState & MENUSTATE_COLORBANDS) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_COPPER    , (flState & MENUSTATE_COPPER    ) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_DONTMOVE  , (flState & MENUSTATE_DONTMOVE  ) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_ROTATEUP  , (flState & MENUSTATE_ROTATEUP  ) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_ROTATEDOWN, (flState & MENUSTATE_ROTATEDOWN) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_SLOW      , (flState & MENUSTATE_SLOW      ) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_MED       , (flState & MENUSTATE_MED       ) ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmen, IDM_FAST      , (flState & MENUSTATE_FAST      ) ? MF_CHECKED : MF_UNCHECKED);
}

/******************************Public*Routine******************************\
* vDrawMandelbrot
*
* Plot Mandelbrot set in the complex region described by prcf.  The prcl
* describes the dimensions of the window bound to the hdc.
*
* !!!dbug
* There is a problem with using SetPixel with the memdc (unknown at this
* time whether it is an app or GDI bug).  As a workaround, the pjBits
* and iDir parameters are added.  If pjBits is non-NULL, then we draw
* directly into the bitmap array.
*
* History:
*  03-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void vDrawMandelbrot(HDC hdc, RECTL *prcl, RECTF *prcf, PBYTE pjBits)
{
    FLOAT x, y, x2, y2, dp, dq, p;
    FLOAT *q;
    LONG xWnd, yWnd;
    LONG cx, cy;
    LONG jColor, jMax = 256;

    cx = prcl->right - prcl->left;
    cy = prcl->bottom - prcl->top;

    if ( !cx || !cy )
        return;

    q = (FLOAT *) LocalAlloc(LMEM_FIXED, sizeof(FLOAT) * cy);
    if (!q)
    {
        MESSAGEBOX(NULL, TEXT("vDrawMandelbrot: LocalAlloc failed"),
                   TEXT("ERROR"), MB_OK);
        return;
    }

    dp = (prcf->right - prcf->left) / cx;
    dq = (prcf->bottom - prcf->top) / cy;

    for (yWnd = 0; yWnd < cy; yWnd++)
        q[yWnd] = prcf->top + (yWnd * dq);

    for (xWnd = 0; xWnd < cx; xWnd++)
    {
        p = prcf->left + (xWnd * dp);

        for (yWnd = 0; yWnd < cy; yWnd++)
        {
            x = 0.0f;
            y = 0.0f;

            for (jColor = 0; jColor < jMax; jColor++)
            {
                x2 = x * x;
                y2 = y * y;

                if ( (x2 + y2) > 4.0f )
                    break;

                y = (2 * x * y) + q[yWnd];
                x = x2 - y2 + p;
            }

            //!!!dbug -- SetPixel does not seem to work when used with my
            //!!!dbug    memdc.  I don't know if this is an NT bug or an
            //!!!dbug    app bug.  For now, pass pointer to bitmap bits in
            //!!!dbug    and draw directly into bitmap.

            if (pjBits)
            {
                PBYTE pjDst;

                // Note: bitmap has bottom-up orientation, hence we "flip"
                //       the y.

                pjDst = pjBits + xWnd + (((prcl->bottom - prcl->top - 1) - yWnd)
                                         * (prcl->right - prcl->left));
                *pjDst = (BYTE) (jColor & 255);
            }
            else
                SetPixel(hdc, xWnd, yWnd, PALETTEINDEX(jColor & 255));
        }
    }

    LocalFree(q);
}

/******************************Public*Routine******************************\
* hpalSetupPalette
*
* Create and select palette into DC.
*
* Returns:
*   Palette handle if successful, NULL otherwise.
*
* History:
*  03-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HPALETTE hpalSetupPalette(HDC hdc)
{
    HPALETTE hpal = (HPALETTE) NULL;
    LOGPALETTE *ppal;
    int i;

    ppal = (PLOGPALETTE) LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
                                                256 * sizeof(PALETTEENTRY));
    if (ppal)
    {
        ppal->palVersion = 0x300;
        ppal->palNumEntries = 256;

        vSetPaletteEntries(ppal->palPalEntry, 256, IDM_COLORBANDS);
        vSetPaletteEntries(gpale, 256, IDM_COLORBANDS);

        hpal = CreatePalette(ppal);
        if (hpal)
        {
            SelectPalette(hdc, hpal, FALSE);
            RealizePalette(hdc);
        }

        LocalFree(ppal);
    }

    return hpal;
}

/******************************Public*Routine******************************\
* vRotatePalette
*
* Animate palette by shifting palette by given increment (can be +/-).
* If the given increment is 0, reset the offset back to 0.
*
* History:
*  03-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vRotatePalette(HDC hdc, HPALETTE hpal, int iIncr)
{
    PALETTEENTRY pale[256];
    int i;
    static int iOffset = 0;

    if (iIncr)
        iOffset = (iOffset + iIncr) & 255;
    else
        iOffset = 0;

    for (i = 0; i < 256; i++)
    {
        pale[(i + iOffset) & 255] = gpale[i];
    }

    AnimatePalette(hpal, 0, 256, pale);
}

/******************************Public*Routine******************************\
* bNewArea
*
* Compute new complex region corresponding to the given window coordinates.
*
* Returns:
*   TRUE if new region is valid, FALSE otherwise.
*
* History:
*  03-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bNewArea(SHORT xMouseStart, SHORT yMouseStart,
              SHORT xMouseCur, SHORT yMouseCur,
              RECTL *prcl, RECTF *prcf)
{
    BOOL bRet = FALSE;
    FLOAT fStart, fCur;

    if ( (xMouseCur != xMouseStart) && (yMouseCur != yMouseStart) )
    {
    // Compute new left/right complex coordinates.

        fStart = prcf->left + ((((FLOAT) (xMouseStart - prcl->left)) /
                                ((FLOAT) (prcl->right - prcl->left))) *
                               (prcf->right - prcf->left));
        fCur   = prcf->left + ((((FLOAT) (xMouseCur - prcl->left)) /
                                ((FLOAT) (prcl->right - prcl->left))) *
                               (prcf->right - prcf->left));

        if (xMouseCur > xMouseStart)
        {
            prcf->left  = fStart;
            prcf->right = fCur;
        }
        else
        {
            prcf->left  = fCur;
            prcf->right = fStart;
        }

    // Compute new top/bottom complex coordinates.

        fStart = prcf->top + ((((FLOAT) (yMouseStart - prcl->top)) /
                               ((FLOAT) (prcl->bottom - prcl->top))) *
                              (prcf->bottom - prcf->top));
        fCur   = prcf->top + ((((FLOAT) (yMouseCur - prcl->top)) /
                               ((FLOAT) (prcl->bottom - prcl->top))) *
                              (prcf->bottom - prcf->top));

        if (yMouseCur > yMouseStart)
        {
            prcf->top    = fStart;
            prcf->bottom = fCur;
        }
        else
        {
            prcf->top    = fCur;
            prcf->bottom = fStart;
        }

        bRet = TRUE;
    }

    return bRet;
}

/******************************Public*Routine******************************\
* vSetRamp
*
* Initialize the specified PALETTEENTRY array starting with the index
* specified by iStart and for the number of entries specified by cpal.
* The data is a linear interpolation of the colors between the start
* and end colors specified by crStart and crEnd, respectively.
*
* History:
*  04-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vSetRamp(LPPALETTEENTRY ppal, int iStart, int cpal,
              COLORREF crStart, COLORREF crEnd)
{
    BYTE rStart, gStart, bStart;
    BYTE rEnd, gEnd, bEnd;
    int i;

    rStart = GetRValue(crStart);
    gStart = GetGValue(crStart);
    bStart = GetBValue(crStart);

    rEnd = GetRValue(crEnd);
    gEnd = GetGValue(crEnd);
    bEnd = GetBValue(crEnd);

    for (i = 0; i < cpal; i++)
    {
        ppal[i+iStart].peRed   = rStart + (i * (rEnd-rStart) / (cpal-1));
        ppal[i+iStart].peGreen = gStart + (i * (gEnd-gStart) / (cpal-1));
        ppal[i+iStart].peBlue  = bStart + (i * (bEnd-bStart) / (cpal-1));
        ppal[i+iStart].peFlags = PC_RESERVED | PC_NOCOLLAPSE;
    }
}

/******************************Public*Routine******************************\
* vSetPaletteEntries
*
* Intialize the specified PALETTEENTRY array (pointed to by ppal and cpal
* entries long) with the type of color data indicated by wType.
*
* wType:
*
*   IDM_GRAYRAMP    a simple gray scale ramp from black to white
*
*   IDM_GRAYBAND    a gray scale from black to white and then back to black
*
*   IDM_COLORBANDS  several different color bands each of which ramp from
*                   black to max and back to black.
*
* History:
*  03-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vSetPaletteEntries(LPPALETTEENTRY ppal, UINT cpal, WPARAM wType)
{
    int i, iStep;
    COLORREF crBlack, crMixed;

    switch (wType)
    {
        case IDM_GRAYRAMP:
            vSetRamp(ppal, 0, cpal, RGB(0,0,0), RGB(255,255,255));
            break;

        case IDM_GRAYBAND:
            vSetRamp(ppal, 0, cpal/2, RGB(0,0,0), RGB(255,255,255));
            vSetRamp(ppal, cpal/2, cpal/2, RGB(255,255,255), RGB(0,0,0));
            break;

        case IDM_COLORBANDS:
            i = 0;
            iStep = cpal/16;
            crBlack = RGB(0,0,0);

            crMixed = RGB(255,0,0);
            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            crMixed = RGB(255,127,0);
            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            crMixed = RGB(255,255,0);
            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            crMixed = RGB(0,255,0);
            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            crMixed = RGB(0,255,255);
            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            crMixed = RGB(0,0,255);
            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            crMixed = RGB(127,0,255);
            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            crMixed = RGB(255,0,255);
            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            break;

        case IDM_COPPER:
            i = 0;
            iStep = cpal/16;
            crBlack = RGB(0,0,0);

            crMixed = RGB(255,127,0);
            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            vSetRamp(ppal, i        , iStep, crBlack, crMixed);
            vSetRamp(ppal, i + iStep, iStep, crMixed, crBlack);
            i += 2*iStep;

            break;

        default:
            break;
    }
}

/******************************Public*Routine******************************\
* bOpenFile
*
* Prompt user to open a file.  Initialize the specified RECTF file with the
* contents of the file.
*
* History:
*  04-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bOpenFile(HWND hwnd, RECTF *prcf)
{
    BOOL bRet = FALSE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = (HANDLE) NULL;
    PVOID pvFile = (PVOID) NULL;
    static OPENFILENAME ofn;
    static TCHAR achFileName[MAX_PATH] = "";

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = TEXT("Mandelbrot Region (*.MND)\0*.MND\0");
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = achFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = (LPTSTR) NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = (LPTSTR) NULL;
    ofn.lpstrTitle = TEXT("Open Mandelbrot Region");
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_EXPLORER | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = TEXT("mnd");
    ofn.lCustData = 0;
    ofn.lpfnHook = (LPOFNHOOKPROC) NULL;
    ofn.lpTemplateName = (LPTSTR) NULL;

    if (!GetOpenFileName(&ofn))
    {
        goto bOpenFile_exit;
    }

    hFile = CreateFile(achFileName, GENERIC_READ,
                       FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES) NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE) NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        MESSAGEBOX(NULL, TEXT("bOpenFile: CreateFile failed"),
                   TEXT("ERROR"), MB_OK);
        goto bOpenFile_exit;
    }

    hMap = CreateFileMapping(hFile, (LPSECURITY_ATTRIBUTES) NULL,
                             PAGE_READONLY, 0, 0, (LPCTSTR) NULL);
    if (!hMap)
    {
        MESSAGEBOX(NULL, TEXT("bOpenFile: CreateFileMapping failed"),
                   TEXT("ERROR"), MB_OK);
        goto bOpenFile_exit;
    }

    pvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (!pvFile)
    {
        MESSAGEBOX(NULL, TEXT("bOpenFile: MapViewOfFile failed"),
                   TEXT("ERROR"), MB_OK);
        goto bOpenFile_exit;
    }

    *prcf = *((RECTF *) pvFile);

    bRet = TRUE;

bOpenFile_exit:

    if (pvFile)
        UnmapViewOfFile(pvFile);

    if (hMap)
        CloseHandle(hMap);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return bRet;
}

/******************************Public*Routine******************************\
* bSaveFile
*
* Prompt user for a save file name.  Save the specified RECTF file to the
* file, creating or overwriting as necessary.
*
* History:
*  04-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bSaveFile(HWND hwnd, RECTF *prcf)
{
    BOOL bRet = FALSE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = (HANDLE) NULL;
    PVOID pvFile = (PVOID) NULL;
    DWORD dwBytes;
    static OPENFILENAME ofn;
    static TCHAR achFileName[MAX_PATH] = "";

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = TEXT("Mandelbrot Region (*.MND)\0*.MND\0");
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = achFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = (LPTSTR) NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = (LPTSTR) NULL;
    ofn.lpstrTitle = TEXT("Save Mandelbrot Region");
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_EXPLORER | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = TEXT("mnd");
    ofn.lCustData = 0;
    ofn.lpfnHook = (LPOFNHOOKPROC) NULL;
    ofn.lpTemplateName = (LPTSTR) NULL;

    if (!GetSaveFileName(&ofn))
    {
        goto bSaveFile_exit;
    }

    hFile = CreateFile(achFileName, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES) NULL,
                       CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE) NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        MESSAGEBOX(NULL, TEXT("bSaveFile: CreateFile failed"),
                   TEXT("ERROR"), MB_OK);
        goto bSaveFile_exit;
    }

    if (WriteFile(hFile, (LPCVOID) prcf, sizeof(*prcf), &dwBytes,
                  (LPOVERLAPPED) NULL) && dwBytes)
    {
        bRet = TRUE;
    }
    else
    {
        MESSAGEBOX(NULL, TEXT("bSaveFile: WriteFile failed"),
                   TEXT("ERROR"), MB_OK);
    }

bSaveFile_exit:

    if (pvFile)
        UnmapViewOfFile(pvFile);

    if (hMap)
        CloseHandle(hMap);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return bRet;
}

/******************************Public*Routine******************************\
* bSaveTex
*
* History:
*  04-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LPTSTR achExt[] = { TEXT("a8"), TEXT("bmp") };
LPTSTR achDotExt[] = { TEXT(".a8"), TEXT(".bmp") };

BOOL bSaveTex(HWND hwnd, HDC hdc, RECTL *prcl, RECTF *prcf)
{
    BOOL bRet = FALSE;
    HDC hdcMem = (HDC) NULL;
    HBITMAP hbm = (HBITMAP) NULL;
    PVOID pvBits;
    SIZEL sizl;
    RGBQUAD rgb[256];
    TCHAR achFileName[MAX_PATH] = TEXT("");
    static OPENFILENAME ofn;
    static DWORD nFilterIndex = 1;

// Query user for name of texture file.

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = TEXT("8 bit Alpha-Texture Format (*.A8)\0*.A8\0Bitmap Format (*.BMP)\0*.BMP\0");
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = nFilterIndex;
    ofn.lpstrFile = achFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = (LPTSTR) NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = (LPTSTR) NULL;
    ofn.lpstrTitle = TEXT("Save Image");
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_EXPLORER | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = (LPTSTR) NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = (LPOFNHOOKPROC) NULL;
    ofn.lpTemplateName = (LPTSTR) NULL;

    if (!GetSaveFileName(&ofn))
    {
        goto bSaveTex_exit;
    }
    nFilterIndex = ofn.nFilterIndex;    // save for next time

// Append the correct extension if needed.

    if (ofn.nFileExtension)
    {
    // If the file extension offset points to a NULL, then filename has
    // no extension.  Use the filter index (1-based) to choose the correct
    // extension to append.

        if (!achFileName[ofn.nFileExtension])
            lstrcpy(&achFileName[ofn.nFileExtension], achDotExt[ofn.nFilterIndex - 1]);
    }
    else
    {
    // Filename has no extension and ends in a period (eg., "foo.").

        lstrcat(achFileName, achExt[ofn.nFilterIndex - 1]);
    }

// Create a memory DC and DIB section into which we will draw the
// Mandelbrot plot.

    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem)
    {
        MESSAGEBOX(NULL, TEXT("bSaveTex: CreateCompatibleDC failed"),
                   TEXT("ERROR"), MB_OK);
        goto bSaveTex_exit;
    }

    sizl.cx = prcl->right - prcl->left;
    sizl.cy = prcl->bottom - prcl->top;

    hbm = hbmCreateBitmap(hdc, sizl, &pvBits);
    if (!hbm)
    {
        MESSAGEBOX(NULL, TEXT("bSaveTex: hbmCreateBitmap failed"),
                   TEXT("ERROR"), MB_OK);
        goto bSaveTex_exit;
    }

    if (!SelectObject(hdcMem, hbm))
    {
        MESSAGEBOX(NULL, TEXT("bSaveTex: SelectObject failed"),
                   TEXT("ERROR"), MB_OK);
        goto bSaveTex_exit;
    }

// Draw and save the results to the file using the palettized text format (A8).

    vDrawMandelbrot(hdcMem, prcl, prcf, (PBYTE) pvBits);
    bGetRGBQuads(hdc, rgb, 0, 256);
    if (ofn.nFilterIndex == 1)
        SaveA8(achFileName, sizl.cx, sizl.cy, rgb, (DWORD) -1, pvBits);
    else
        SaveBMP(achFileName, rgb, hbm, pvBits);

    bRet = TRUE;

bSaveTex_exit:
    if (hbm)
        DeleteObject(hbm);

    if (hdcMem)
        DeleteDC(hdcMem);

    return bRet;
}

/******************************Public*Routine******************************\
* hbmCreateBitmap
*
* Create an 8bpp DIB section with a color table equal to the logical
* palette in the specified DC.
*
* Returns:
*   If successful, returns a valid bitmap handle and sets ppvBits to point
*   to the DIB section memory.  Otherwise, returns NULL.
*
* History:
*  04-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP hbmCreateBitmap(HDC hdc, SIZEL sizl, PVOID *ppvBits)
{
    BITMAPINFO *pbmi;
    HBITMAP    hbmRet = (HBITMAP) NULL;
    size_t     cjbmi;

// Allocate the BITMAPINFO structure and color table.

    *ppvBits = (PVOID) NULL;
    cjbmi = sizeof(BITMAPINFO) + 256*sizeof(RGBQUAD);
    pbmi = LocalAlloc(LMEM_FIXED, cjbmi);
    if (pbmi)
    {
        pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth         = sizl.cx;
        pbmi->bmiHeader.biHeight        = sizl.cy;
        pbmi->bmiHeader.biPlanes        = 1;
        pbmi->bmiHeader.biBitCount      = 8;
        pbmi->bmiHeader.biCompression   = BI_RGB;
        pbmi->bmiHeader.biSizeImage     = 0;
        pbmi->bmiHeader.biXPelsPerMeter = 0;
        pbmi->bmiHeader.biYPelsPerMeter = 0;
        pbmi->bmiHeader.biClrUsed       = 0;
        pbmi->bmiHeader.biClrImportant  = 0;

    // Initialize DIB color table.

        if (bGetRGBQuads(hdc, &pbmi->bmiColors[0], 0, 256))
        {
        // Create DIB section.

            hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);
            if ( hbmRet == (HBITMAP) NULL )
            {
                MESSAGEBOX(NULL, TEXT("hbmCreateBitmap: CreateDIBSection failed"),
                           TEXT("ERROR"), MB_OK);
            }
        }
        else
        {
            MESSAGEBOX(NULL, TEXT("hbmCreateBitmap: bGetRGBQuads failed"),
                       TEXT("ERROR"), MB_OK);
        }

        LocalFree(pbmi);
    }
    else
    {
        MESSAGEBOX(NULL, TEXT("hbmCreateBitmap: LocalAlloc failed"),
                   TEXT("ERROR"), MB_OK);
    }

    return hbmRet;
}

/******************************Public*Routine******************************\
* bGetRBBQuads
*
* Fills the specified RGBQUAD array with the contents of the logical palette
* selected into the specified HDC.
*
* History:
*  04-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bGetRGBQuads(HDC hdc, RGBQUAD *prgb, int iStart, int crgb)
{
    BOOL bRet = FALSE;
    PALETTEENTRY lppe[256];

    if ( GetPaletteEntries(GetCurrentObject(hdc, OBJ_PAL),
                           iStart, crgb, lppe) )
    {
        UINT i;

    // Convert to RGBQUAD.

        for (i = 0; i < 256; i++)
        {
            prgb[i].rgbRed      = lppe[i].peRed;
            prgb[i].rgbGreen    = lppe[i].peGreen;
            prgb[i].rgbBlue     = lppe[i].peBlue;
            prgb[i].rgbReserved = 0;
        }

        bRet = TRUE;
    }
    else
    {
        MESSAGEBOX(NULL, TEXT("bGetRGBQuads: GetPaletteEntries failed"),
                   TEXT("ERROR"), MB_OK);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* SaveBMP
*
* Save bitmap to a bitmap (.BMP) file.  Only 8bpp is supported.
*
* History:
*  05-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID SaveBMP(LPTSTR achFileName, RGBQUAD *rgb, HBITMAP hbm, PVOID pvBits)
{
    BITMAPFILEHEADER bmf;
    BITMAPINFO bmi;
    BITMAP bm;
    HANDLE hFile = INVALID_HANDLE_VALUE;

// Open the file.

    hFile = CreateFile(achFileName, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES) NULL,
                       CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE) NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        MESSAGEBOX(NULL, TEXT("SaveBMP: CreateFile failed"),
                   TEXT("ERROR"), MB_OK);
        goto SaveBMP_exit;
    }

// Get bitmap info.

    if (GetObject(hbm, sizeof(bm), &bm))
    {
    // Only bother supporting 8bpp for now.

        if (bm.bmBitsPixel == 8)
        {
            DWORD dwBytes;

            bmf.bfType      = 0x4d42;   // 'BM'
            bmf.bfReserved1 = 0;
            bmf.bfReserved2 = 0;
            bmf.bfOffBits   = sizeof(bmf) + offsetof(BITMAPINFO, bmiColors)
                              + 256*sizeof(RGBQUAD);
            bmf.bfSize      = bmf.bfOffBits + (bm.bmWidthBytes * bm.bmHeight);

            bmi.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
            bmi.bmiHeader.biWidth         = bm.bmWidth;
            bmi.bmiHeader.biHeight        = bm.bmHeight;
            bmi.bmiHeader.biPlanes        = 1;
            bmi.bmiHeader.biBitCount      = bm.bmBitsPixel;
            bmi.bmiHeader.biCompression   = BI_RGB;
            bmi.bmiHeader.biSizeImage     = 0;
            bmi.bmiHeader.biXPelsPerMeter = 0;
            bmi.bmiHeader.biYPelsPerMeter = 0;
            bmi.bmiHeader.biClrUsed       = 0;
            bmi.bmiHeader.biClrImportant  = 0;

            if (!WriteFile(hFile, (LPCVOID) &bmf, sizeof(bmf),
                           &dwBytes, (LPOVERLAPPED) NULL) && dwBytes)
            {
                MESSAGEBOX(NULL, TEXT("SaveBMP: WriteFile BITMAPFILEHEADER failed"),
                           TEXT("ERROR"), MB_OK);
            }

            if (!WriteFile(hFile, (LPCVOID) &bmi, offsetof(BITMAPINFO, bmiColors),
                           &dwBytes, (LPOVERLAPPED) NULL) && dwBytes)
            {
                MESSAGEBOX(NULL, TEXT("SaveBMP: WriteFile BITMAPINFO failed"),
                           TEXT("ERROR"), MB_OK);
            }

            if (!WriteFile(hFile, (LPCVOID) rgb, 256*sizeof(RGBQUAD),
                           &dwBytes, (LPOVERLAPPED) NULL) && dwBytes)
            {
                MESSAGEBOX(NULL, TEXT("SaveBMP: WriteFile color table failed"),
                           TEXT("ERROR"), MB_OK);
            }

            if (!WriteFile(hFile, (LPCVOID) pvBits, bm.bmWidthBytes * bm.bmHeight,
                           &dwBytes, (LPOVERLAPPED) NULL) && dwBytes)
            {
                MESSAGEBOX(NULL, TEXT("SaveBMP: WriteFile bitmap bits failed"),
                           TEXT("ERROR"), MB_OK);
            }
        }
        else
        {
            MESSAGEBOX(NULL, TEXT("SaveBMP: only 8bpp supported"),
                       TEXT("ERROR"), MB_OK);
        }
    }

SaveBMP_exit:

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\antipnt.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  antipoint.c
 *  The program draws antialiased points, in RGBA mode.
 */
#include "pch.c"
#pragma hdrstop

/*  Initialize point anti-aliasing for RGBA mode, including alpha 
 *  blending, hint, and point size.  These points are 3.0 pixels big.
 */
static void myinit(void)
{
    glEnable (GL_POINT_SMOOTH);
    glEnable (GL_BLEND);
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glHint (GL_POINT_SMOOTH_HINT, GL_DONT_CARE);
    glPointSize (3.0);

    glClearColor(0.0, 0.0, 0.0, 0.0);
}

/*  display() draws several points.
 */
static void display(void)
{
    int i;

    glClear (GL_COLOR_BUFFER_BIT);
    glColor4f (1.0, 1.0, 1.0, 1.0);
    glBegin (GL_POINTS);
	for (i = 1; i < 10; i++) {
	    glVertex2f ((GLfloat) i * 10.0, (GLfloat) i * 10.0);
	}
    glEnd ();
    glFlush();
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w < h) 
	glOrtho (0.0, 100.0, 
	    0.0, 100.0*(GLfloat) h/(GLfloat) w, -1.0, 1.0);
    else
	glOrtho (0.0, 100.0*(GLfloat) w/(GLfloat) h, 
	    0.0, 100.0, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
}

static void OglBounds(int *w, int *h)
{
    *w = 100;
    *h = 100;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_antipnt =
{
    "antipnt",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\anti.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  anti.c
 *  This program draws antialiased lines in RGBA mode.
 */
#include "pch.c"
#pragma hdrstop

/*  Initialize antialiasing for RGBA mode, including alpha
 *  blending, hint, and line width.  Print out implementation
 *  specific info on line width granularity and width.
 */
static void myinit(void)
{
    GLfloat values[2];
    glGetFloatv (GL_LINE_WIDTH_GRANULARITY, values);
    printf ("GL_LINE_WIDTH_GRANULARITY value is %3.1f\n", values[0]);

    glGetFloatv (GL_LINE_WIDTH_RANGE, values);
    printf ("GL_LINE_WIDTH_RANGE values are %3.1f %3.1f\n",
        values[0], values[1]);

    glEnable (GL_LINE_SMOOTH);
    glEnable (GL_BLEND);
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glHint (GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
    glLineWidth (1.5);

    glShadeModel(GL_FLAT);
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

/*  display() draws an icosahedron with a large alpha value, 1.0.
 */
static void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor4f (1.0, 1.0, 1.0, 1.0);
    auxWireIcosahedron(1.0);
    glFlush();
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective (45.0, (GLfloat) w/(GLfloat) h, 3.0, 5.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
    glTranslatef (0.0, 0.0, -4.0);  /*  move object into view   */
}

static void OglBounds(int *w, int *h)
{
    *w = 400;
    *h = 400;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_anti =
{
    "anti",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\accanti.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  accanti.c
 */
#include "pch.c"
#pragma hdrstop

#include "jitter.h"

/*  Initialize lighting and other values.
 */
static void myinit(void)
{
    GLfloat mat_ambient[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_position[] = { 0.0, 0.0, 10.0, 1.0 };
    GLfloat lm_ambient[] = { 0.2, 0.2, 0.2, 1.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialf(GL_FRONT, GL_SHININESS, 50.0);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lm_ambient);
    
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glShadeModel (GL_FLAT);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearAccum(0.0, 0.0, 0.0, 0.0);
}

static void displayObjects(void) 
{
    GLfloat torus_diffuse[] = { 0.7, 0.7, 0.0, 1.0 };
    GLfloat cube_diffuse[] = { 0.0, 0.7, 0.7, 1.0 };
    GLfloat sphere_diffuse[] = { 0.7, 0.0, 0.7, 1.0 };
    GLfloat octa_diffuse[] = { 0.7, 0.4, 0.4, 1.0 };
    
    glPushMatrix ();
    glRotatef (30.0, 1.0, 0.0, 0.0);

    glPushMatrix ();
    glTranslatef (-0.80, 0.35, 0.0); 
    glRotatef (100.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, torus_diffuse);
    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (-0.75, -0.50, 0.0); 
    glRotatef (45.0, 0.0, 0.0, 1.0);
    glRotatef (45.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, cube_diffuse);
    auxSolidCube (1.5);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.75, 0.60, 0.0); 
    glRotatef (30.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, sphere_diffuse);
    auxSolidSphere (1.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.70, -0.90, 0.25); 
    glMaterialfv(GL_FRONT, GL_DIFFUSE, octa_diffuse);
    auxSolidOctahedron (1.0);
    glPopMatrix ();

    glPopMatrix ();
}

#define ACSIZE	8

static void display(void)
{
    GLint viewport[4];
    int jitter;

    glGetIntegerv (GL_VIEWPORT, viewport);

    glClear(GL_ACCUM_BUFFER_BIT);
    for (jitter = 0; jitter < ACSIZE; jitter++) {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glPushMatrix ();
/*	Note that 4.5 is the distance in world space between
 *	left and right and bottom and top.
 *	This formula converts fractional pixel movement to 
 *	world coordinates.
 */
	glTranslatef (j8[jitter].x*4.5/viewport[2],
	    j8[jitter].y*4.5/viewport[3], 0.0);
	displayObjects ();
	glPopMatrix ();
	glAccum(GL_ACCUM, 1.0/ACSIZE);
        glFlush();
//        auxSwapBuffers();
    }
    glAccum (GL_RETURN, 1.0);
    glFlush();
//    auxSwapBuffers();
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-2.25, 2.25, -2.25*h/w, 2.25*h/w, -10.0, 10.0);
    else 
	glOrtho (-2.25*w/h, 2.25*w/h, -2.25, 2.25, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

static GLenum OglDisplayMode(void)
{
    return AUX_RGB | AUX_ACCUM | AUX_DEPTH16;
}

static void OglBounds(int *w, int *h)
{
    *w = 250;
    *h = 250;
}

static void OglInit(HDC hdc)
{
    SetHdcPixelFormat(hdc, 0, 32, 16, 0);
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_accanti =
{
    "accanti",
    OglDisplayMode,
    OglBounds,
    OglInit,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mandel\mandel.h ===
#define MENUSTATE_PALMASK       0x000f
#define MENUSTATE_GRAYRAMP      0x0001
#define MENUSTATE_GRAYBAND      0x0002
#define MENUSTATE_COLORBANDS    0x0004
#define MENUSTATE_COPPER        0x0008

#define MENUSTATE_ROTMASK       0x0700
#define MENUSTATE_DONTMOVE      0x0100
#define MENUSTATE_ROTATEUP      0x0200
#define MENUSTATE_ROTATEDOWN    0x0400

#define MENUSTATE_SPEEDMASK     0x070000
#define MENUSTATE_SLOW          0x010000
#define MENUSTATE_MED           0x020000
#define MENUSTATE_FAST          0x040000

#define IDM_GRAYRAMP        1000
#define IDM_GRAYBAND        1001
#define IDM_COLORBANDS      1002
#define IDM_COPPER          1003
#define IDM_DONTMOVE        2000
#define IDM_ROTATEUP        2001
#define IDM_ROTATEDOWN      2002
#define IDM_ROTRESET        2003
#define IDM_SLOW            3000
#define IDM_MED             3001
#define IDM_FAST            3002
#define IDM_RESET_POS       4000
#define IDM_PREV_POS        4001
#define IDM_OPENFILE        5000
#define IDM_SAVEFILE        5001
#define IDM_SAVETEX         5002

extern BOOL SaveA8(TCHAR *file, DWORD width, DWORD height,
                   RGBQUAD *rgb_pal, DWORD transp_index, void *data);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mandel\savea8.c ===
#include <windows.h>
#include "mandel.h"

#define ESCAPE 0
#define ESC_ENDLINE 0
#define ESC_ENDBITMAP 1
#define ESC_DELTA 2
#define ESC_RANDOM 3
#define RANDOM_COUNT(c) ((c)-(ESC_RANDOM-1))

#define COUNT_SIZE 256
#define MAXRUN (COUNT_SIZE-1)
#define MAXRND (RANDOM_COUNT(COUNT_SIZE)-1)

typedef unsigned char *HwMem;
typedef unsigned long HwMemSize;
#define HW_UNALIGNED UNALIGNED

static HwMem prle, rndcnt;
static unsigned char prev;
static HwMemSize repeat;

static void RleWrite(unsigned char cur)
{
    if (repeat > 1)
    {
        /*
          A single unique byte will be represented as ESCAPE, ESC_RANDOM,
          <byte>.  This can be more efficiently encoded as a run of 1 byte.

          We can achieve this effect in two ways:  intially encode single
          bytes as runs and then change them to random if random bytes
          come in a sequence.  Alternately, when we start a run we
          can check for an existing random and change it to a run.

          The second version is implemented here
          */
        if (rndcnt && RANDOM_COUNT(*rndcnt) == 1)
        {
	    /* Change ESCAPE to a length one run */
            *(rndcnt-1) = 1;
	    /* Move run byte into proper position */
            *rndcnt = *(rndcnt+1);
            prle--;
        }
        
	if (prev == 0 && repeat > MAXRUN)
	{
	    while (repeat > 0)
	    {
                unsigned short d;
                
		*prle++ = ESCAPE;
		*prle++ = ESC_DELTA;
                d = (unsigned short)min(0xffff, repeat);
                *((unsigned short HW_UNALIGNED *)prle)++ = d;
                repeat -= d;
	    }
	}
	else
	{
	    *prle++ = (unsigned char)repeat;
	    *prle++ = prev;
	}
	rndcnt = NULL;
	repeat = 1;
    }
    else
    {
	if (rndcnt == NULL || RANDOM_COUNT(*rndcnt) >= MAXRND)
	{
	    *prle++ = ESCAPE;
	    rndcnt = prle++;
	    *rndcnt = ESC_RANDOM-1;
	}
	(*rndcnt)++;
	*prle++ = prev;
    }
    prev = cur;
}

HwMemSize HwuRle(HwMem src, HwMem dest, HwMemSize size, HwMemSize stride)
{
    unsigned char cur;
    HwMem f;
    HwMemSize count;
    
    f = src;
    prle = dest;
    prev = *f;
    f += stride;
    repeat = 1;
    count = size-stride;
    rndcnt = NULL;
    while (count > 0)
    {
	cur = *f;
        f += stride;
	if (prev != cur || (repeat >= MAXRUN && prev != 0))
        {
	    RleWrite(cur);
        }
	else
        {
	    repeat++;
        }

        count -= stride;
    }
    RleWrite(cur);
    *prle++ = ESCAPE;
    *prle++ = ESC_ENDBITMAP;
    return prle-dest;
}

#define ALPHA_SIGNATURE 0xa0a1a2a3
#define COMPRESS_NONE 0
#define COMPRESS_RLE  1

BOOL SaveA8(TCHAR *file, DWORD width, DWORD height,
            RGBQUAD *rgb_pal, DWORD transp_index, void *data)
{
    HANDLE fho;
    DWORD *out_image, dw, dwWrite;
    DWORD pixels, i;
    HwMemSize msize;
    RGBQUAD full_pal[256];
    BOOL success = FALSE;
    
    fho = CreateFile(file, GENERIC_WRITE, 0, NULL,
                     CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fho == NULL || fho == INVALID_HANDLE_VALUE)
    {
        goto Fail;
    }

    pixels = width*height;

    for (i = 0; i < 256; i++)
    {
        full_pal[i] = rgb_pal[i];
        
        if (i == transp_index)
        {
            full_pal[i].rgbReserved = 0;
        }
        else
        {
            full_pal[i].rgbReserved = 0xff;
        }
    }
        
    out_image = LocalAlloc(LMEM_FIXED, pixels);
    if (out_image == NULL)
    {
        goto Fail_fho;
    }

    msize = HwuRle((HwMem)data, (HwMem)out_image, pixels, 1);
    if (msize > (HwMemSize)pixels)
    {
        goto Fail_out_image;
    }
    
    dw = ALPHA_SIGNATURE;
    WriteFile(fho, &dw, sizeof(dw), &dwWrite, NULL);
    WriteFile(fho, &width, sizeof(DWORD), &dwWrite, NULL);
    WriteFile(fho, &height, sizeof(DWORD), &dwWrite, NULL);
    dw = 8;
    WriteFile(fho, &dw, sizeof(dw), &dwWrite, NULL);
    dw = COMPRESS_RLE;
    WriteFile(fho, &dw, sizeof(dw), &dwWrite, NULL);
    WriteFile(fho, &msize, sizeof(msize), &dwWrite, NULL);
    WriteFile(fho, full_pal, 256*sizeof(RGBQUAD), &dwWrite, NULL);
    WriteFile(fho, out_image, msize, &dwWrite, NULL);

    success = TRUE;
    
 Fail_out_image:
    LocalFree(out_image);

 Fail_fho:
    CloseHandle(fho);

 Fail:
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\jitter.h ===
/*
jitter.h

This file contains jitter point arrays for 2,3,4,8,15,24 and 66 jitters.

The arrays are named j2, j3, etc. Each element in the array has the form,
for example, j8[0].x and j8[0].y

Values are floating point in the range -.5 < x < .5, -.5 < y < .5, and
have a gaussian distribution around the origin.

Use these to do model jittering for scene anti-aliasing and view volume
jittering for depth of field effects. Use in conjunction with the 
accwindow() routine.
*/

typedef struct 
{
	GLfloat x, y;
} jitter_point;

#define MAX_SAMPLES  66


/* 2 jitter points */
jitter_point j2[] =
{
	{ 0.246490,  0.249999},
	{-0.246490, -0.249999}
};


/* 3 jitter points */
jitter_point j3[] =
{
	{-0.373411, -0.250550},
	{ 0.256263,  0.368119},
	{ 0.117148, -0.117570}
};


/* 4 jitter points */
jitter_point j4[] =
{
	{-0.208147,  0.353730},
	{ 0.203849, -0.353780},
	{-0.292626, -0.149945},
	{ 0.296924,  0.149994}
};


/* 8 jitter points */
jitter_point j8[] =
{
	{-0.334818,  0.435331},
	{ 0.286438, -0.393495},
	{ 0.459462,  0.141540},
	{-0.414498, -0.192829},
	{-0.183790,  0.082102},
	{-0.079263, -0.317383},
	{ 0.102254,  0.299133},
	{ 0.164216, -0.054399}
};


/* 15 jitter points */
jitter_point j15[] =
{
	{ 0.285561,  0.188437},
	{ 0.360176, -0.065688},
	{-0.111751,  0.275019},
	{-0.055918, -0.215197},
	{-0.080231, -0.470965},
	{ 0.138721,  0.409168},
	{ 0.384120,  0.458500},
	{-0.454968,  0.134088},
	{ 0.179271, -0.331196},
	{-0.307049, -0.364927},
	{ 0.105354, -0.010099},
	{-0.154180,  0.021794},
	{-0.370135, -0.116425},
	{ 0.451636, -0.300013},
	{-0.370610,  0.387504}
};


/* 24 jitter points */
jitter_point j24[] =
{
	{ 0.030245,  0.136384},
	{ 0.018865, -0.348867},
	{-0.350114, -0.472309},
	{ 0.222181,  0.149524},
	{-0.393670, -0.266873},
	{ 0.404568,  0.230436},
	{ 0.098381,  0.465337},
	{ 0.462671,  0.442116},
	{ 0.400373, -0.212720},
	{-0.409988,  0.263345},
	{-0.115878, -0.001981},
	{ 0.348425, -0.009237},
	{-0.464016,  0.066467},
	{-0.138674, -0.468006},
	{ 0.144932, -0.022780},
	{-0.250195,  0.150161},
	{-0.181400, -0.264219},
	{ 0.196097, -0.234139},
	{-0.311082, -0.078815},
	{ 0.268379,  0.366778},
	{-0.040601,  0.327109},
	{-0.234392,  0.354659},
	{-0.003102, -0.154402},
	{ 0.297997, -0.417965}
};


/* 66 jitter points */
jitter_point j66[] =
{
	{ 0.266377, -0.218171},
	{-0.170919, -0.429368},
	{ 0.047356, -0.387135},
	{-0.430063,  0.363413},
	{-0.221638, -0.313768},
	{ 0.124758, -0.197109},
	{-0.400021,  0.482195},
	{ 0.247882,  0.152010},
	{-0.286709, -0.470214},
	{-0.426790,  0.004977},
	{-0.361249, -0.104549},
	{-0.040643,  0.123453},
	{-0.189296,  0.438963},
	{-0.453521, -0.299889},
	{ 0.408216, -0.457699},
	{ 0.328973, -0.101914},
	{-0.055540, -0.477952},
	{ 0.194421,  0.453510},
	{ 0.404051,  0.224974},
	{ 0.310136,  0.419700},
	{-0.021743,  0.403898},
	{-0.466210,  0.248839},
	{ 0.341369,  0.081490},
	{ 0.124156, -0.016859},
	{-0.461321, -0.176661},
	{ 0.013210,  0.234401},
	{ 0.174258, -0.311854},
	{ 0.294061,  0.263364},
	{-0.114836,  0.328189},
	{ 0.041206, -0.106205},
	{ 0.079227,  0.345021},
	{-0.109319, -0.242380},
	{ 0.425005, -0.332397},
	{ 0.009146,  0.015098},
	{-0.339084, -0.355707},
	{-0.224596, -0.189548},
	{ 0.083475,  0.117028},
	{ 0.295962, -0.334699},
	{ 0.452998,  0.025397},
	{ 0.206511, -0.104668},
	{ 0.447544, -0.096004},
	{-0.108006, -0.002471},
	{-0.380810,  0.130036},
	{-0.242440,  0.186934},
	{-0.200363,  0.070863},
	{-0.344844, -0.230814},
	{ 0.408660,  0.345826},
	{-0.233016,  0.305203},
	{ 0.158475, -0.430762},
	{ 0.486972,  0.139163},
	{-0.301610,  0.009319},
	{ 0.282245, -0.458671},
	{ 0.482046,  0.443890},
	{-0.121527,  0.210223},
	{-0.477606, -0.424878},
	{-0.083941, -0.121440},
	{-0.345773,  0.253779},
	{ 0.234646,  0.034549},
	{ 0.394102, -0.210901},
	{-0.312571,  0.397656},
	{ 0.200906,  0.333293},
	{ 0.018703, -0.261792},
	{-0.209349, -0.065383},
	{ 0.076248,  0.478538},
	{-0.073036, -0.355064},
	{ 0.145087,  0.221726}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\bfont.h ===
#define STROKEMAX 60

short chrtbl[200][STROKEMAX] = {
/* c0 */	{0},
/* c1 */	{2,
		 3, 0,4, 2,2, 4,4,
		 2, 2,8, 2,2},
/* c2 */	{3,
		 6, 0,3, 0,5, 1,6, 2,6, 3,5, 4,6,
		 3, 3,5, 3,3, 4,2,
		 4, 3,3, 2,2, 1,2, 0,3},
/* c3 */	{2,
		 8, 0,0, 1,1, 1,5, 2,6, 4,6, 5,5, 4,4, 1,4,
		 4, 4,4, 5,3, 4,2, 1,2},
/* c4 */	{1,
		 3, 0,4, 2,6, 4,4},
/* c5 */	{1,
		 3, 0,5, 4,5, 4,4},
/* c6 */	{2,
		 2, 1,4, 3,4,
		 6, 3,6, 2,6, 1,5, 1,3, 2,2, 3,2},
/* c7 */	{3,
		 2, 1,2, 1,6,
		 2, 0,6, 4,6,
		 2, 3,6, 3,2},
/* c8 */	{2,
		 2, 0,2, 2,4,
		 3, 0,7, 0,6, 4,2},
/* c9 */	{0},
/* c10 */	{0},
/* c11 */	{1,
		 6, 0,2, 1,1, 2,2, 2,7, 3,8, 4,7},
/* c12 */	{3,
		 2, 0,3, 4,3,
		 2, 4,6, 0,6,
		 2, 2,8, 2,4},
/* c13 */	{0},
/* c14 */	{2,
		 8, 1,3, 2,4, 2,5, 3,6, 4,5, 4,4, 3,3, 2,4,
		 5, 2,5, 1,6, 0,5, 0,4, 1,3},
/* c15 */	{2,
		 8, 0,3, 0,4, 1,5, 3,5, 4,4, 4,6, 2,8, 1,8,
		 5, 4,4, 4,3, 3,2, 1,2, 0,3},
/* c16 */	{1,
		 6, 4,7, 1,7, 0,6, 0,4, 1,3, 4,3},
/* c17 */	{1,
		 6, 0,3, 3,3, 4,4, 4,6, 3,7, 0,7},
/* c18 */	{1,
		 6, 0,4, 0,6, 1,7, 3,7, 4,6, 4,4},
/* c19 */	{1,
		 6, 0,7, 0,5, 1,4, 3,4, 4,5, 4,7},
/* c20 */	{2,
		 3, 0,8, 2,2, 4,8,
		 2, 3,6, 1,6},
/* c21 */	{2,
		 4, 0,2, 4,2, 4,5, 1,5,
		 3, 0,8, 4,8, 4,5},
/* c22 */	{3,
		 9, 0,4, 0,6, 1,7, 3,7, 4,6, 4,4, 3,3, 1,3, 0,4,
		 2, 1,4, 3,6,
		 2, 1,6, 3,4},
/* c23 */	{3,
		 4, 2,0, 0,2, 4,6, 2,8,
		 2, 0,6, 4,6,
		 2, 0,2, 4,2},
/* c24 */	{1,
		 2, 0,0, 4,0},
/* c25 */	{2,
		 3, 2,3, 4,5, 2,7,
		 2, 0,5, 4,5},
/* c26 */	{1,
		 6, 0,8, 1,9, 2,9, 2,8, 3,8, 4,9},
/* c27 */	{3,
		 2, 0,1, 4,7,
		 2, 4,5, 0,5,
		 2, 0,3, 4,3},
/* c28 */	{2,
		 2, 1,2, 3,2,
		 3, 3,4, 1,6, 3,8},
/* c29 */	{2,
		 2, 1,2, 3,2,
		 3, 1,4, 3,6, 1,8},
/* c30 */	{3,
		 2, 0,3, 4,3,
		 2, 4,5, 0,5,
		 2, 0,7, 4,7},
/* c31 */	{1,
		 3, 0,6, 2,4, 4,6},
/* c32 */	{0},
/* c33 */	{2,
		 2, 2,1, 2,2,
		 2, 2,4, 2,8},
/* c34 */	{2,
		 2, 1,7, 1,9,
		 2, 3,9, 3,7},
/* c35 */	{4,
		 2, 1,2, 1,7,
		 2, 3,7, 3,2,
		 2, 4,3, 0,3,
		 2, 0,6, 4,6},
/* c36 */	{2,
		 2, 2,1, 2,9,
		 12, 4,7, 3,8, 1,8, 0,7, 0,6, 1,5, 3,5, 4,4, 4,2, 3,1, 1,1, 0,2},
/* c37 */	{3,
		 4, 0,2, 0,3, 4,7, 4,8,
		 5, 1,8, 0,8, 0,7, 1,7, 1,8,
		 5, 4,3, 5,3, 5,2, 4,2, 5,2},
/* c38 */	{1,
		 11, 4,4, 2,2, 1,2, 0,3, 0,4, 2,6, 2,7, 1,8, 0,7, 0,6, 4,2},
/* c39 */	{1,
		 6, 0,7, 1,8, 1,9, 2,9, 2,8, 1,8},
/* c40 */	{1,
		 4, 4,2, 2,4, 2,6, 4,8},
/* c41 */	{1,
		 4, 0,2, 2,4, 2,6, 0,8},
/* c42 */	{4,
		 2, 2,2, 2,8,
		 2, 0,7, 4,3,
		 2, 4,5, 0,5,
		 2, 0,3, 4,7},
/* c43 */	{2,
		 2, 2,3, 2,7,
		 2, 0,5, 4,5},
/* c44 */	{1,
		 3, 0,1, 1,2, 1,3},
/* c45 */	{1,
		 2, 0,5, 4,5},
/* c46 */	{1,
		 2, 1,2, 2,2},
/* c47 */	{1,
		 2, 0,3, 4,7},
/* c48 */	{1,
		 10, 0,3, 4,7, 3,8, 1,8, 0,7, 0,3, 1,2, 3,2, 4,3, 4,7},
/* c49 */	{2,
		 2, 1,2, 3,2,
		 3, 2,2, 2,8, 1,7},
/* c50 */	{1,
		 7, 0,7, 1,8, 3,8, 4,7, 4,6, 0,2, 4,2},
/* c51 */	{2,
		 7, 0,3, 1,2, 3,2, 4,3, 4,4, 3,5, 2,5,
		 6, 3,5, 4,6, 4,7, 3,8, 1,8, 0,7},
/* c52 */	{1,
		 5, 3,2, 3,8, 0,5, 0,4, 4,4},
/* c53 */	{1,
		 9, 0,3, 1,2, 3,2, 4,3, 4,5, 3,6, 0,6, 0,8, 4,8},
/* c54 */	{1,
		 11, 0,5, 0,3, 1,2, 3,2, 4,3, 4,4, 3,5, 0,5, 0,6, 2,8, 3,8},
/* c55 */	{1,
		 4, 0,8, 4,8, 2,4, 2,2},
/* c56 */	{1,
		 16, 1,5, 0,4, 0,3, 1,2, 3,2, 4,3, 4,4, 3,5, 1,5, 0,6, 0,7, 1,8, 3,8, 4,7, 4,6, 3,5},
/* c57 */	{1,
		 10, 1,2, 2,2, 4,4, 4,7, 3,8, 1,8, 0,7, 0,6, 1,5, 4,5},
/* c58 */	{2,
		 2, 0,3, 1,3,
		 2, 1,6, 0,6},
/* c59 */	{2,
		 3, 0,1, 1,2, 1,3,
		 2, 1,6, 0,6},
/* c60 */	{1,
		 3, 3,3, 1,5, 3,7},
/* c61 */	{2,
		 2, 0,4, 4,4,
		 2, 4,6, 0,6},
/* c62 */	{1,
		 3, 1,7, 3,5, 1,3},
/* c63 */	{2,
		 2, 1,2, 2,2,
		 6, 2,4, 2,5, 4,7, 3,8, 1,8, 0,7},
/* c64 */	{1,
		 11, 3,2, 1,2, 0,3, 0,7, 1,8, 3,8, 4,7, 4,4, 2,4, 2,6, 4,6},
/* c65 */	{2,
		 6, 0,2, 0,7, 1,8, 3,8, 4,7, 4,2,
		 2, 0,5, 4,5},
/* c66 */	{2,
		 6, 0,2, 3,2, 4,3, 4,4, 3,5, 0,5,
		 6, 3,5, 4,6, 4,7, 3,8, 0,8, 0,2},
/* c67 */	{1,
		 8, 4,7, 3,8, 1,8, 0,7, 0,3, 1,2, 3,2, 4,3},
/* c68 */	{2,
		 6, 0,2, 3,2, 4,3, 4,7, 3,8, 0,8,
		 2, 1,8, 1,2},
/* c69 */	{2,
		 4, 4,2, 0,2, 0,8, 4,8,
		 2, 3,5, 0,5},
/* c70 */	{2,
		 3, 0,2, 0,8, 4,8,
		 2, 3,5, 0,5},
/* c71 */	{1,
		 10, 3,4, 4,4, 4,3, 3,2, 1,2, 0,3, 0,7, 1,8, 3,8, 4,7},
/* c72 */	{3,
		 2, 0,2, 0,8,
		 2, 0,5, 4,5,
		 2, 4,8, 4,2},
/* c73 */	{3,
		 2, 1,2, 3,2,
		 2, 2,2, 2,8,
		 2, 1,8, 3,8},
/* c74 */	{1,
		 5, 0,3, 1,2, 3,2, 4,3, 4,8},
/* c75 */	{2,
		 2, 0,2, 0,8,
		 3, 4,8, 1,5, 4,2},
/* c76 */	{1,
		 3, 0,8, 0,2, 4,2},
/* c77 */	{1,
		 5, 0,2, 0,8, 2,6, 4,8, 4,2},
/* c78 */	{1,
		 4, 0,2, 0,8, 4,2, 4,8},
/* c79 */	{1,
		 9, 0,3, 0,7, 1,8, 3,8, 4,7, 4,3, 3,2, 1,2, 0,3},
/* c80 */	{1,
		 7, 0,2, 0,8, 3,8, 4,7, 4,6, 3,5, 0,5},
/* c81 */	{2,
		 9, 0,3, 0,7, 1,8, 3,8, 4,7, 4,4, 2,2, 1,2, 0,3,
		 2, 2,5, 4,3},
/* c82 */	{2,
		 7, 0,2, 0,8, 3,8, 4,7, 4,6, 3,5, 0,5,
		 2, 1,5, 4,2},
/* c83 */	{1,
		 12, 4,7, 3,8, 1,8, 0,7, 0,6, 1,5, 3,5, 4,4, 4,3, 3,2, 1,2, 0,3},
/* c84 */	{2,
		 2, 0,8, 4,8,
		 2, 2,8, 2,2},
/* c85 */	{2,
		 2, 0,3, 0,8,
		 5, 4,8, 4,3, 3,2, 1,2, 0,3},
/* c86 */	{1,
		 5, 0,8, 0,5, 2,2, 4,5, 4,8},
/* c87 */	{2,
		 2, 0,2, 0,8,
		 4, 4,8, 4,2, 2,4, 0,2},
/* c88 */	{2,
		 2, 0,2, 4,8,
		 2, 0,8, 4,2},
/* c89 */	{2,
		 3, 2,2, 2,5, 0,8,
		 2, 4,8, 2,5},
/* c90 */	{1,
		 4, 0,8, 4,8, 0,2, 4,2},
/* c91 */	{1,
		 4, 3,1, 1,1, 1,9, 3,9},
/* c92 */	{1,
		 2, 0,7, 4,3},
/* c93 */	{1,
		 4, 1,9, 3,9, 3,1, 1,1},
/* c94 */	{2,
		 2, 2,2, 2,8,
		 3, 0,6, 2,8, 4,6},
/* c95 */	{2,
		 3, 2,3, 0,5, 2,7,
		 2, 0,5, 4,5},
/* c96 */	{1,
		 6, 3,8, 2,8, 2,9, 3,9, 3,8, 4,7},
/* c97 */	{1,
		 8, 1,6, 3,6, 4,5, 4,2, 1,2, 0,3, 1,4, 4,4},
/* c98 */	{1,
		 7, 0,8, 0,2, 3,2, 4,3, 4,5, 3,6, 0,6},
/* c99 */	{1,
		 7, 4,5, 3,6, 1,6, 0,5, 0,3, 1,2, 4,2},
/* c100 */	{1,
		 7, 4,8, 4,2, 1,2, 0,3, 0,5, 1,6, 4,6},
/* c101 */	{1,
		 9, 3,2, 1,2, 0,3, 0,5, 1,6, 3,6, 4,5, 3,4, 0,4},
/* c102 */	{2,
		 5, 1,2, 1,7, 2,8, 3,8, 4,7,
		 2, 2,5, 0,5},
/* c103 */	{1,
		 10, 1,0, 3,0, 4,1, 4,5, 3,6, 1,6, 0,5, 0,3, 1,2, 4,2},
/* c104 */	{2,
		 2, 0,2, 0,8,
		 4, 0,6, 3,6, 4,5, 4,2},
/* c105 */	{2,
		 2, 2,2, 2,5,
		 2, 2,6, 2,7},
/* c106 */	{2,
		 5, 0,1, 1,0, 3,0, 4,1, 4,5,
		 2, 4,6, 4,7},
/* c107 */	{3,
		 2, 0,2, 0,8,
		 3, 4,6, 2,4, 0,4,
		 2, 2,4, 4,2},
/* c108 */	{1,
		 2, 1,2, 1,8},
/* c109 */	{2,
		 7, 0,2, 0,6, 1,6, 2,5, 3,6, 4,5, 4,2,
		 2, 2,2, 2,5},
/* c110 */	{1,
		 7, 0,2, 0,6, 1,5, 2,6, 3,6, 4,5, 4,2},
/* c111 */	{1,
		 9, 0,3, 0,5, 1,6, 3,6, 4,5, 4,3, 3,2, 1,2, 0,3},
/* c112 */	{1,
		 7, 0,0, 0,6, 3,6, 4,5, 4,3, 3,2, 0,2},
/* c113 */	{1,
		 8, 4,2, 1,2, 0,3, 0,5, 1,6, 3,6, 4,5, 4,0},
/* c114 */	{2,
		 2, 0,2, 0,6,
		 4, 0,4, 2,6, 3,6, 4,5},
/* c115 */	{1,
		 8, 0,2, 3,2, 4,3, 3,4, 1,4, 0,5, 1,6, 4,6},
/* c116 */	{2,
		 2, 0,6, 4,6,
		 4, 2,8, 2,3, 3,2, 4,2},
/* c117 */	{1,
		 6, 0,6, 0,3, 1,2, 3,2, 4,3, 4,6},
/* c118 */	{1,
		 5, 0,6, 0,4, 2,2, 4,4, 4,6},
/* c119 */	{1,
		 7, 0,6, 0,3, 1,2, 2,3, 3,2, 4,3, 4,6},
/* c120 */	{2,
		 2, 0,2, 4,6,
		 2, 0,6, 4,2},
/* c121 */	{2,
		 3, 0,0, 4,4, 4,6,
		 3, 0,6, 0,4, 2,2},
/* c122 */	{1,
		 4, 0,6, 4,6, 0,2, 4,2},
/* c123 */	{1,
		 7, 4,9, 3,8, 3,6, 2,5, 3,4, 3,2, 4,1},
/* c124 */	{1,
		 2, 2,9, 2,0},
/* c125 */	{2,
		 5, 2,2, 2,3, 0,5, 2,7, 2,8,
		 3, 2,7, 4,5, 2,3},
/* c126 */	{1,
		 7, 0,9, 1,8, 1,6, 2,5, 1,4, 1,2, 0,1},
/* c127 */	{0}
		};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\cullver.c ===
#include "pch.c"
#include <math.h>

#pragma hdrstop

static int    wsizex;           // Window size X
static int    wsizey;           // Window size Y
static float  alpha = 0.0f;     // Rotation angle

#define widthp   100.0          // Width of triangle strip
#define height   40.0           // Height of triangle strip
#define n        20             // Number of segments in triangle strip
#define delta    widthp/n
#define z        0.0            // Z for triangle strip
#define nCell    6              // Number of cells: nCell*nCell
//-------------------------------------------------------------------
typedef struct Vector3_
{
   double  xx;
   double  yy;
   double  zz;
}  Vector3;

void SetVector(Vector3* v, double x, double y, double zz)
{
    v->xx= x;
    v->yy= y;
    v->zz= zz;
}
//-------------------------------------------------------------------
void Polygons()
{
    int     i;
    double  firstx =  -widthp/2.0;
    double  firsty =  -height/2.0;

    for (i=0; i <= n; i++)
    {
        if (i % 4 < 2)
            glNormal3d(0.0, 0.0, 1.0);
        else
            glNormal3d(0.0, 0.0, -1.0);
        if (i < n)
        {
            glBegin(GL_POLYGON);
            glVertex3d(firstx, firsty+height, z);
            glVertex3d(firstx, firsty, z);
            glVertex3d(firstx+delta, firsty, z);
            glVertex3d(firstx+delta, firsty+height, z);
            glEnd();
        }
        firstx+= delta;
    }
}
//-------------------------------------------------------------------
void TriangleStrip()
{
    int     i;
    double  firstx =  -widthp/2.0;
    double  firsty =  -height/2.0;

    glBegin(GL_TRIANGLE_STRIP);
    for (i=0; i <= n; i++)
    {
        if (i % 4 < 2)
            glNormal3d(0.0, 0.0, 1.0);
        else
            glNormal3d(0.0, 0.0, -1.0);
        glVertex3d(firstx, firsty+height, z);
        glVertex3d(firstx, firsty, z);
        firstx+= delta;
    }
    glEnd();
}
//-------------------------------------------------------------------
void TriangleFan()
{
    int     i;
    double  pi = 3.1415926535;
    double  alfa = 0.0;
    double  dalfa = 2.0*pi/n;
    Vector3 vertex[n+2];
    Vector3 normal[n+2];

    SetVector(&vertex[0], 0.0, 0.0,  z);
    SetVector(&normal[0], 0.0, 0.0, -1.0);
    for (i=1; i <= n+1; i++)
    {
        SetVector(&vertex[i], cos(alfa)*40, sin(alfa)*40,  z);
        if (i % 4 < 2)
           SetVector(&normal[i], 0.0, 0.0,  1.0);
        else
           SetVector(&normal[i], 0.0, 0.0, -1.0);
        alfa+= dalfa;
    }

    glBegin(GL_TRIANGLE_FAN);
    for (i=0; i <= n+1; i++)
    {
        glNormal3dv((double*)&normal[i].xx);
        glVertex3dv((double*)&vertex[i].xx);
    }
    glEnd();
}
//-------------------------------------------------------------------
void TriangleFanIndex()
{
    int     i;
    double  pi = 3.1415926535;
    double  alfa = 0.0;
    double  dalfa = 2.0*pi/n;
    Vector3 vertex[n+2];
    Vector3 normal[n+2];
    int     indices[n+2];

    SetVector(&vertex[0], 0.0, 0.0,  z);
    SetVector(&normal[0], 0.0, 0.0, -1.0);
    for (i=1; i <= n+1; i++)
    {
        SetVector(&vertex[i], cos(alfa)*40, sin(alfa)*40,  z);
        if (i % 4 < 2)
           SetVector(&normal[i], 0.0, 0.0,  1.0);
        else
           SetVector(&normal[i], 0.0, 0.0, -1.0);
        alfa+= dalfa;
    }

    for (i=0; i <= n+1; i++)
        indices[i] = i;

    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glVertexPointer(3, GL_DOUBLE, 0, vertex);
    glNormalPointer(GL_DOUBLE, 0, normal);
    glDrawElements(GL_TRIANGLE_FAN, n+2, GL_UNSIGNED_INT, indices); 
}
//-------------------------------------------------------------------
void TriangleStripIndex()
{
    int     i;
    double  firstx =  -widthp/2.0;
    double  firsty =  -height/2.0;
    Vector3 vertex[(n+1)*2];
    Vector3 normal[(n+1)*2];
    int     indices[(n+1)*2];

    for (i=0; i <= n; i++)
    {
        int  k = i*2;
        if (i % 4 < 2)
        {
            SetVector(&normal[k  ], 0.0, 0.0, 1.0);
            SetVector(&normal[k+1], 0.0, 0.0, 1.0);
        }
        else
        {
            SetVector(&normal[k  ], 0.0, 0.0, -1.0);
            SetVector(&normal[k+1], 0.0, 0.0, -1.0);
        }
        SetVector(&vertex[k  ], firstx, firsty+height, z);
        SetVector(&vertex[k+1], firstx, firsty, z);
        firstx+= delta;
        indices[k]   = k;
        indices[k+1] = k+1;
    }

    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glVertexPointer(3, GL_DOUBLE, 0, vertex);
    glNormalPointer(GL_DOUBLE, 0, normal);
    glDrawElements(GL_TRIANGLE_STRIP, (n+1)*2, GL_UNSIGNED_INT, indices);
}
//-------------------------------------------------------------------
void QuadStripIndex()
{
    int     i;
    double  firstx =  -widthp/2.0;
    double  firsty =  -height/2.0;
    Vector3 vertex[(n+1)*2];
    Vector3 normal[(n+1)*2];
    int     indices[(n+1)*2];

    for (i=0; i <= n; i++)
    {
        int  k = i*2;
        if (i % 4 < 2)
        {
            SetVector(&normal[k  ], 0.0, 0.0, 1.0);
            SetVector(&normal[k+1], 0.0, 0.0, 1.0);
        }
        else
        {
            SetVector(&normal[k  ], 0.0, 0.0, -1.0);
            SetVector(&normal[k+1], 0.0, 0.0, -1.0);
        }
        SetVector(&vertex[k  ], firstx, firsty+height, z);
        SetVector(&vertex[k+1], firstx, firsty, z);
        firstx+= delta;
        indices[k]   = k;
        indices[k+1] = k+1;
    }

    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glVertexPointer(3, GL_DOUBLE, 0, vertex);
    glNormalPointer(GL_DOUBLE, 0, normal);
    glDrawElements(GL_QUAD_STRIP, (n+1)*2, GL_UNSIGNED_INT, indices); 
}
//-------------------------------------------------------------------
void QuadStrip()
{
    int     i;
    double  firstx =  -widthp/2.0;
    double  firsty =  -height/2.0;

    glBegin(GL_QUAD_STRIP);
    for (i=0; i <= n; i++)
    {
        if (i % 4 < 2)
            glNormal3d(0.0, 0.0, 1.0);
        else
            glNormal3d(0.0, 0.0, -1.0);
        glVertex3d(firstx, firsty+height, z);
        glVertex3d(firstx, firsty, z);
        firstx+= delta;
    }
    glEnd();
}
//-------------------------------------------------------------------
void SeparateTriangles()
{
    int     i;
    double  firstx =  -widthp/2.0;
    double  firsty =  -height/2.0;

    glBegin(GL_TRIANGLES);
    for (i=0; i <= n; i++)
    {
        if (i % 4 < 2)
            glNormal3d(0.0, 0.0, 1.0);
        else
            glNormal3d(0.0, 0.0, -1.0);
        if (i < n)
        {
            glVertex3d(firstx, firsty+height, z);
            glVertex3d(firstx, firsty, z);
            glVertex3d(firstx+delta, firsty+height, z);
            glVertex3d(firstx+delta, firsty+height, z);
            glVertex3d(firstx, firsty, z);
            glVertex3d(firstx+delta, firsty, z);
        }
        firstx+= delta;
    }
    glEnd();
}
//-------------------------------------------------------------------
void SeparateTrianglesIndex()
{
    int     i;
    double  firstx =  -widthp/2.0;
    double  firsty =  -height/2.0;
    Vector3 vertex[(n+1)*2];
    Vector3 normal[(n+1)*2];
    int     indices[n*2*3];
    int     index = 0;

    for (i=0; i <= n; i++)
    {
        int  k = i*2;
        if (i % 4 < 2)
        {
            SetVector(&normal[k  ], 0.0, 0.0, 1.0);
            SetVector(&normal[k+1], 0.0, 0.0, 1.0);
        }
        else
        {
            SetVector(&normal[k  ], 0.0, 0.0, -1.0);
            SetVector(&normal[k+1], 0.0, 0.0, -1.0);
        }
        SetVector(&vertex[k  ], firstx, firsty+height, z);
        SetVector(&vertex[k+1], firstx, firsty, z);
        firstx+= delta;
        if (i < n)
        {
            indices[index++] = k;
            indices[index++] = k+1;
            indices[index++] = k+2;
            indices[index++] = k+2;
            indices[index++] = k+1;
            indices[index++] = k+3;
        }
    }

    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glVertexPointer(3, GL_DOUBLE, 0, vertex);
    glNormalPointer(GL_DOUBLE, 0, normal);
    glDrawElements(GL_TRIANGLES, n*2*3, GL_UNSIGNED_INT, indices); 
}
//-------------------------------------------------------------------
void SeparateQuads()
{
    int     i;
    double  firstx =  -widthp/2.0;
    double  firsty =  -height/2.0;

    glBegin(GL_QUADS);
    for (i=0; i <= n; i++)
    {
        if (i % 4 < 2)
            glNormal3d(0.0, 0.0, 1.0);
        else
            glNormal3d(0.0, 0.0, -1.0);
        if (i < n)
        {
            glVertex3d(firstx, firsty+height, z);
            glVertex3d(firstx, firsty, z);
            glVertex3d(firstx+delta, firsty, z);
            glVertex3d(firstx+delta, firsty+height, z);
        }
        firstx+= delta;
    }
    glEnd();
}
//-------------------------------------------------------------------
void SeparateQuadsIndex()
{
    int     i;
    double  firstx =  -widthp/2.0;
    double  firsty =  -height/2.0;
    Vector3 vertex[(n+1)*2];
    Vector3 normal[(n+1)*2];
    int     indices[n*4];
    int     index = 0;

    for (i=0; i <= n; i++)
    {
        int  k = i*2;
        if (i % 4 < 2)
        {
            SetVector(&normal[k  ], 0.0, 0.0, 1.0);
            SetVector(&normal[k+1], 0.0, 0.0, 1.0);
        }
        else
        {
            SetVector(&normal[k  ], 0.0, 0.0, -1.0);
            SetVector(&normal[k+1], 0.0, 0.0, -1.0);
        }
        SetVector(&vertex[k  ], firstx, firsty+height, z);
        SetVector(&vertex[k+1], firstx, firsty, z);
        firstx+= delta;
        if (i < n)
        {
            indices[index++] = k;
            indices[index++] = k+1;
            indices[index++] = k+3;
            indices[index++] = k+2;
        }
    }

    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glVertexPointer(3, GL_DOUBLE, 0, vertex);
    glNormalPointer(GL_DOUBLE, 0, normal);
    glDrawElements(GL_QUADS, n*4, GL_UNSIGNED_INT, indices);
}
//-------------------------------------------------------------------
static void sphere()
{
    GLUquadricObj*  q;

    q = gluNewQuadric();
    glColor3ub(255,0,0);
    gluSphere(q, 40.0f, 25, 25);
    gluDeleteQuadric(q);
}
//-------------------------------------------------------------------
static void SetCell(int i, int j)
{
   glViewport ((int)(i*wsizex/nCell), (int)(j*wsizey/nCell), (int)(wsizex/nCell), (int)(wsizey/nCell));
}
//-------------------------------------------------------------------
static void Rotate()
{
    glRotatef(alpha, 1.0f, 1.0f, 1.0f);
    glRotatef(alpha, 0.0f, 1.0f, 1.0f);
}
//-------------------------------------------------------------------
static void drawAll()
{
    double  Zdistance = -80.0;
    PFNGLCULLPARAMETERDVEXTPROC CullParameter;
    PFNGLCULLPARAMETERFVEXTPROC CullParameterf;

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();
    glTranslatef (0.0f, 0.0f, (GLfloat)Zdistance);
    Rotate();

    {
        SetCell(0,0);
        glDisable(GL_CULL_VERTEX_EXT);
        sphere();
    }
    {
        double  CameraPos[4] = {0.0, 0.0, 0.0, 1.0};
        CullParameter  = (PFNGLCULLPARAMETERDVEXTPROC)wglGetProcAddress("glCullParameterdvEXT");
        CullParameterf = (PFNGLCULLPARAMETERFVEXTPROC)wglGetProcAddress("glCullParameterfvEXT");
        glEnable(GL_CULL_VERTEX_EXT);

        if (!CullParameter) goto exitpoint;

        {
            double  CameraPos[4]  = {0.0, 0.0, 0.0, 1.0};
            float   CameraPosf[4] = {0.0f, 0.0f, 0.0f, 1.0f};
            CullParameter(GL_CULL_VERTEX_EYE_POSITION_EXT, CameraPos);
            CullParameterf(GL_CULL_VERTEX_EYE_POSITION_EXT, CameraPosf);
            glFlush();
            SetCell(1,0);
            glPushMatrix();
            glLoadIdentity();
            glTranslatef (-80.0f, 0.0f, (GLfloat)Zdistance);
            Rotate();
            sphere();
            glPopMatrix();
        }
        {
            double	    CameraPos[4] = {0.0, 0.0, 1.0, 0.0};
            SetCell(2,0);
            CullParameter(GL_CULL_VERTEX_EYE_POSITION_EXT, CameraPos);
            sphere();
        }
        {
            double	    CameraPos[4] = {1.0, 0.0, 0.0, 0.0};
            SetCell(0,1);
            CullParameter(GL_CULL_VERTEX_OBJECT_POSITION_EXT, CameraPos);
            sphere();
        }
        {
            double	    CameraPos[4] = {0.0, 0.0, 100.0, 1.0};
            SetCell(1,1);
            CullParameter(GL_CULL_VERTEX_OBJECT_POSITION_EXT, CameraPos);
            sphere();
        }
        {
            double	    CameraPos[4] = {0.0, 0.0, 100.0, 0.0};
            SetCell(2,1);
            CullParameter(GL_CULL_VERTEX_OBJECT_POSITION_EXT, CameraPos);
            sphere();
        }
        {
            double	    CameraPos[4] = {0.0, 0.0, 1.0, 0.0};
            SetCell(3,0);
            CullParameter(GL_CULL_VERTEX_EYE_POSITION_EXT, CameraPos);
            sphere();
        }
        {
            double	    CameraPos[4] = {0.0, 0.0, 1.0, 0.0};
            SetCell(3,1);
            CullParameter(GL_CULL_VERTEX_OBJECT_POSITION_EXT, CameraPos);
            sphere();
        }
// -------------- Primitive without indices ------------------
        CullParameter(GL_CULL_VERTEX_EYE_POSITION_EXT, CameraPos);

        SetCell(0,2);
        TriangleStrip();

        SetCell(1,2);
        QuadStrip();

        SetCell(2,2);
        SeparateTriangles();

        SetCell(3,2);
        SeparateQuads();

        SetCell(4,2);
        TriangleFan();

        SetCell(5,2);
        Polygons();
// -------------- Primitive with indices ------------------
        SetCell(0,3);
        TriangleStripIndex();

        SetCell(1,3);
        QuadStripIndex();

        SetCell(2,3);
        SeparateTrianglesIndex();

        SetCell(3,3);
        SeparateQuadsIndex();

        SetCell(4,3);
        TriangleFanIndex();

        { // Test some functions
            GLboolean   b;
            GLdouble    d;
            GLdouble    dv[4];
            glGetBooleanv(GL_CULL_VERTEX_EXT, &b);
            glGetDoublev(GL_CULL_VERTEX_EXT, &d);
            glGetDoublev(GL_CULL_VERTEX_EYE_POSITION_EXT, dv);
            glGetDoublev(GL_CULL_VERTEX_OBJECT_POSITION_EXT, dv);
        }
    }
exitpoint:
    glPopMatrix();
//    alpha += 5.0f;
}

/*  Initialize depth buffer, projection matrix, light source,
 *  and lighting model.  Do not specify a material property here.
 */
static void myinit(void)
{
    glShadeModel(GL_FLAT);
    glEnable(GL_CULL_FACE);
    glFrontFace(GL_CCW);
    glCullFace(GL_BACK);
    {
        GLfloat   position[4] = {0.0f, 0.0f, 1.0f, 0.0f};
        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);
        glMaterialf(GL_FRONT, GL_SHININESS, 64.0f);
        glLightModeli (GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
        glLightfv(GL_LIGHT0, GL_POSITION, position);
    }
}

static void display(void)
{
    glClearColor (0.5f, 0.5f, 0.8f, 1.0f);
    glClear (GL_COLOR_BUFFER_BIT);
    drawAll();
    glFlush();
}

static void myReshape(GLsizei w, GLsizei h)
{
    wsizex = w;
    wsizey = h;
    glViewport (0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective ((double)80, 1.8 /*(double)w / (float) h*/, (double)0.01, (double)131072.0);
}

#define WIDTH  400
#define HEIGHT 300

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_cullver =
{
    "cullver",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\linelist.c ===
#include "pch.c"
#pragma hdrstop

#define	drawOneLine(x1,y1,x2,y2) glBegin(GL_LINES); \
	glVertex2f ((x1),(y1)); glVertex2f ((x2),(y2)); glEnd();

GLuint offset;

static void myinit (void)
{
/*  background to be cleared to black	*/
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glShadeModel (GL_FLAT);

    offset = glGenLists (3);
    glNewList (offset, GL_COMPILE);
	glDisable (GL_LINE_STIPPLE);
    glEndList ();
    glNewList (offset+1, GL_COMPILE);
	glEnable (GL_LINE_STIPPLE);
	glLineStipple (1, 0x0F0F);
    glEndList ();
    glNewList (offset+2, GL_COMPILE);
	glEnable (GL_LINE_STIPPLE);
	glLineStipple (1, 0x1111);
    glEndList ();
}

static void display(void)
{
    glClear (GL_COLOR_BUFFER_BIT);

/*  draw all lines in white	*/
    glColor3f (1.0, 1.0, 1.0);

    glCallList (offset);
    drawOneLine (50.0, 125.0, 350.0, 125.0);
    glCallList (offset+1);
    drawOneLine (50.0, 100.0, 350.0, 100.0);
    glCallList (offset+2);
    drawOneLine (50.0, 75.0, 350.0, 75.0);
    glCallList (offset+1);
    drawOneLine (50.0, 50.0, 350.0, 50.0);
    glCallList (offset);
    drawOneLine (50.0, 25.0, 350.0, 25.0);
    glFlush ();
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0.0, 400, 0.0, 150, -1, 1);
    glMatrixMode(GL_MODELVIEW);
}

#define WIDTH 400
#define HEIGHT 150

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_linelist =
{
    "linelist",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\glsutil.h ===
#ifndef __GLSUTIL_H__
#define __GLSUTIL_H__

typedef struct _GlsMemoryStream
{
    GLSenum iStreamType;
    size_t cb;
    GLubyte *pb;
} GlsMemoryStream;

GlsMemoryStream *GmsLoad(char *pszStream);
void             GmsFree(GlsMemoryStream *gms);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\etex.c ===
#include "pch.c"
#pragma hdrstop

#define WWIDTH (2*TWIDTH+GAP)
#define WHEIGHT (4*THEIGHT+3*GAP)
#define TWIDTH 128
#define THEIGHT 128
#define GAP 16

static int wwidth = WWIDTH;
static int wheight = WHEIGHT;
static int twidth = TWIDTH;
static int theight = THEIGHT;
static int gap = GAP;

static char *tex1_file = "1.rgb";
static char *tex2_file = "2.rgb";
static AUX_RGBImageRec *tex1, *tex2;

static BYTE tex1d1[TWIDTH*3], tex1d2[TWIDTH*3];

#define NTEXID 3
static GLuint texids[NTEXID+1];
static GLboolean texres[NTEXID];
static GLfloat texpri[NTEXID];

static void TexPoly(int x, int y)
{
    glBegin(GL_POLYGON);
    glTexCoord2i(0, 0);
    glVertex2i(x, y);
    glTexCoord2i(1, 0);
    glVertex2i(x+twidth-1, y);
    glTexCoord2i(1, 1);
    glVertex2i(x+twidth-1, y+theight-1);
    glTexCoord2i(0, 1);
    glVertex2i(x, y+theight-1);
    glEnd();
}

static void Test(void)
{
    int i;
    GLint res;
    GLfloat pri;
    GLboolean retval;
    int x1, x2, y;

    x2 = 0;
    x1 = x2+twidth+gap;
    y = 0;

    glGenTextures(NTEXID, texids);
    for (i = 0; i < NTEXID; i++)
    {
        // printf("Texture id %d is %d\n", i, texids[i]);
    }

    // Should fail for last
    for (i = 0; i < NTEXID+1; i++)
    {
        // printf("IsTexture %d is %d\n", i, glIsTexture(texids[i]));
    }

    glDeleteTextures(1, &texids[NTEXID-1]);
    // Should fail for last two
    for (i = 0; i < NTEXID+1; i++)
    {
        // printf("IsTexture %d is %d\n", i, glIsTexture(texids[i]));
    }

    // Should fail because these are all unbound right now
    retval = glAreTexturesResident(NTEXID, texids, texres);
    // printf("AreTexturesResident %d\n", retval);
    
    glBindTexture(GL_TEXTURE_2D, texids[0]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, tex1->sizeX, tex1->sizeY, 0, GL_RGB,
                 GL_UNSIGNED_BYTE, tex1->data);
    glEnable(GL_TEXTURE_2D);

    glGetTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, &pri);
    // printf("2D Priority is %f\n", pri);
    
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, 0.5f);
    glGetTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, &pri);
    // printf("2D Priority is %f\n", pri);

    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_RESIDENT, &res);
    // printf("2D Residency is %d\n", res);
    
    retval = glAreTexturesResident(1, texids, texres);
    // printf("AreTexturesResident %d\n", retval);
    for (i = 0; i < 1; i++)
    {
        // printf("Residency %d is %d\n", i, texres[i]);
    }
    
    glClear(GL_COLOR_BUFFER_BIT);

    TexPoly(x2, y);

    glDisable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_1D, texids[1]);
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexImage1D(GL_TEXTURE_1D, 0, 3, TWIDTH, 0, GL_RGB,
                 GL_UNSIGNED_BYTE, tex1d1);
    glEnable(GL_TEXTURE_1D);

    glGetTexParameterfv(GL_TEXTURE_1D, GL_TEXTURE_PRIORITY, &pri);
    // printf("1D Priority is %f\n", pri);
    
    glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_PRIORITY, 0.5f);
    glGetTexParameterfv(GL_TEXTURE_1D, GL_TEXTURE_PRIORITY, &pri);
    // printf("1D Priority is %f\n", pri);

    glGetTexParameteriv(GL_TEXTURE_1D, GL_TEXTURE_RESIDENT, &res);
    // printf("1D Residency is %d\n", res);
    
    TexPoly(x1, y);
    
    retval = glAreTexturesResident(2, texids, texres);
    // printf("AreTexturesResident %d\n", retval);
    for (i = 0; i < 2; i++)
    {
        // printf("Residency %d is %d\n", i, texres[i]);
    }

    glBindTexture(GL_TEXTURE_2D, texids[2]);
    
    texpri[0] = 0.25f;
    texpri[1] = 0.4f;
    texpri[2] = 0.7f;
    glPrioritizeTextures(NTEXID, texids, texpri);

    glGetTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, &pri);
    // printf("2D Priority is %f\n", pri);
    glGetTexParameterfv(GL_TEXTURE_1D, GL_TEXTURE_PRIORITY, &pri);
    // printf("1D Priority is %f\n", pri);

    retval = glAreTexturesResident(NTEXID, texids, texres);
    // printf("AreTexturesResident %d\n", retval);
    for (i = 0; i < NTEXID; i++)
    {
        // printf("Residency %d is %d\n", i, texres[i]);
    }

    glBindTexture(GL_TEXTURE_2D, texids[0]);
    y += theight+gap;

    glPixelStorei(GL_UNPACK_ROW_LENGTH, tex2->sizeX);
    glDisable(GL_TEXTURE_1D);
    glEnable(GL_TEXTURE_2D);
    glTexSubImage2D(GL_TEXTURE_2D, 0, tex1->sizeX/4, tex1->sizeY/4,
                     tex1->sizeX/2, tex1->sizeY/2, GL_RGB, GL_UNSIGNED_BYTE,
                     tex2->data);
    TexPoly(x2, y);
    
    glDisable(GL_TEXTURE_2D);
    glEnable(GL_TEXTURE_1D);
    glTexSubImage1D(GL_TEXTURE_1D, 0, TWIDTH/4, TWIDTH/2,
                     GL_RGB, GL_UNSIGNED_BYTE, tex1d2);
    TexPoly(x1, y);

    y += theight+gap;
    
    glDisable(GL_TEXTURE_1D);
    glEnable(GL_TEXTURE_2D);
    glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, x2, 0,
                      tex1->sizeX, tex1->sizeY, 0);
    TexPoly(x2, y);
    
    glDisable(GL_TEXTURE_2D);
    glEnable(GL_TEXTURE_1D);
    glCopyTexImage1D(GL_TEXTURE_1D, 0, GL_RGB, x1, 0,
                      TWIDTH, 0);
    TexPoly(x1, y);

    y += theight+gap;
    
    glDisable(GL_TEXTURE_1D);
    glEnable(GL_TEXTURE_2D);
    glCopyTexSubImage2D(GL_TEXTURE_2D, 0, tex1->sizeX/4, tex1->sizeY/4,
                         x2+twidth/4, theight+theight/4+gap,
                         tex1->sizeX/2, tex1->sizeY/2);
    TexPoly(x2, y);
    
    glDisable(GL_TEXTURE_2D);
    glEnable(GL_TEXTURE_1D);
    glCopyTexSubImage1D(GL_TEXTURE_1D, 0, TWIDTH/4,
                         x1+TWIDTH/4, theight+gap,
                         TWIDTH/2);
    TexPoly(x1, y);

    glFlush();
    
    glDeleteTextures(NTEXID-1, texids);
}

static void Reshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, w, 0, h, -1, 1);
    glMatrixMode(GL_MODELVIEW);

    wwidth = w;
    wheight = h;
}

static void Init(void)
{
    int i;

    tex1 = auxRGBImageLoad(tex1_file);
    if (tex1 == NULL)
    {
        printf("Unable to load '%s'\n", tex1_file);
        exit(1);
    }
    // printf("tex1 %d,%d\n", tex1->sizeX, tex1->sizeY);
    tex2 = auxRGBImageLoad(tex2_file);
    if (tex2 == NULL)
    {
        printf("Unable to load '%s'\n", tex2_file);
        exit(1);
    }
    // printf("tex2 %d,%d\n", tex2->sizeX, tex2->sizeY);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    for (i = 0; i < TWIDTH; i++)
    {
        tex1d1[i*3+2] = (i*256/TWIDTH);
        tex1d2[i*3] = (i*256/TWIDTH);
    }
    
    // glDisable(GL_DITHER);
}

static void OglBounds(int *w, int *h)
{
    *w = wwidth;
    *h = wheight;
}

static void OglDraw(int w, int h)
{
    Init();
    Reshape(w, h);
    Test();
}

OglModule oglmod_etex =
{
    "etex",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\drawf.c ===
#include "pch.c"
#pragma hdrstop

static GLubyte rasters[24] = {
    0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00,
    0xff, 0x00, 0xff, 0x00, 0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00,
    0xff, 0xc0, 0xff, 0xc0};

static void myinit(void)
{
    glPixelStorei (GL_UNPACK_ALIGNMENT, 1);
    glClearColor (0.0, 0.0, 0.0, 0.0);
}

static void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);
    glRasterPos2i (20.5, 20.5);
    glBitmap (10, 12, 0.0, 0.0, 12.0, 0.0, rasters);
    glBitmap (10, 12, 0.0, 0.0, 12.0, 0.0, rasters);
    glBitmap (10, 12, 0.0, 0.0, 12.0, 0.0, rasters);
    glFlush();
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho (0, 48, 0, 40, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
}

#define WIDTH 48
#define HEIGHT 40

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_drawf =
{
    "drawf",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\mfgls.c ===
#include "pch.c"
#pragma hdrstop

#include "glsutil.h"

extern OglModule oglmod_accanti;
extern OglModule oglmod_alpha3d;
extern OglModule oglmod_anti;
extern OglModule oglmod_antipnt;
extern OglModule oglmod_drawf;
extern OglModule oglmod_etex;
extern OglModule oglmod_linelist;
extern OglModule oglmod_material;
extern OglModule oglmod_ofont;
extern OglModule oglmod_polys;
extern OglModule oglmod_sharel;
extern OglModule oglmod_smooth;
extern OglModule oglmod_stencil;
extern OglModule oglmod_surfgrid;
extern OglModule oglmod_teapots;
extern OglModule oglmod_texpal;
extern OglModule oglmod_texsurf;
extern OglModule oglmod_varray;
extern OglModule oglmod_vptitle;

OglModule *ogl_modules[] =
{
    &oglmod_accanti,
    &oglmod_alpha3d,
    &oglmod_anti,
    &oglmod_antipnt,
    &oglmod_drawf,
    &oglmod_etex,
    &oglmod_linelist,
    &oglmod_material,
    &oglmod_ofont,
    &oglmod_polys,
    &oglmod_sharel,
    &oglmod_smooth,
    &oglmod_stencil,
    &oglmod_surfgrid,
    &oglmod_teapots,
    &oglmod_texpal,
    &oglmod_texsurf,
    &oglmod_varray,
    &oglmod_vptitle
};
#define OGLMOD_COUNT (sizeof(ogl_modules)/sizeof(ogl_modules[0]))
OglModule *ogl_module = NULL;

OglModule *FindOglModule(char *name)
{
    int i;
    int l;

    l = strlen(name);
    for (i = 0; i < OGLMOD_COUNT; i++)
    {
        if (!strncmp(name, ogl_modules[i]->name, l))
        {
            return ogl_modules[i];
        }
    }
    return ogl_modules[0];
}

void SetHdcPixelFormat(HDC hdc,
                       int cAlphaBits,
                       int cAccumBits,
                       int cDepthBits,
                       int cStencilBits)
{
    int fmt;
    PIXELFORMATDESCRIPTOR pfd;

    memset(&pfd, 0, sizeof(pfd));
    pfd.nSize = sizeof(pfd);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL |
        PFD_DOUBLEBUFFER;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 24;
    pfd.cAlphaBits = cAlphaBits;
    pfd.cAccumBits = cAccumBits;
    pfd.cDepthBits = cDepthBits;
    pfd.cStencilBits = cStencilBits;
    pfd.iLayerType = PFD_MAIN_PLANE;
    
    fmt = ChoosePixelFormat(hdc, &pfd);
    if (fmt == 0)
    {
        printf("SetHdcPixelFormat: ChoosePixelFormat failed, %d\n",
               GetLastError());
        exit(1);
    }

    if (DescribePixelFormat(hdc, fmt, sizeof(pfd), &pfd) == 0)
    {
        printf("SetHdcPixelFormat: DescribePixelFormat failed, %d\n",
               GetLastError());
        exit(1);
    }
    
    if (!SetPixelFormat(hdc, fmt, &pfd))
    {
        printf("SetHdcPixelFormat: SetPixelFormat failed, %d\n",
               GetLastError());
        exit(1);
    }
}

void ConvertToHighMetric(HDC hdc, POINT *ppt)
{
    int xnm, xdn;
    int ynm, ydn;

#if 1
    xnm = GetDeviceCaps(hdc, HORZSIZE)*100;
    xdn = GetDeviceCaps(hdc, HORZRES);
    ynm = GetDeviceCaps(hdc, VERTSIZE)*100;
    ydn = GetDeviceCaps(hdc, VERTRES);
#else
    xnm = 2540;
    xdn = GetDeviceCaps(hdc, LOGPIXELSX);
    ynm = 2540;
    ydn = GetDeviceCaps(hdc, LOGPIXELSY);
#endif
    ppt->x = MulDiv(ppt->x, xnm, xdn);
    ppt->y = MulDiv(ppt->y, ynm, ydn);
    printf("HIMETRIC point %d,%d\n", ppt->x, ppt->y);
}

void ConvertToDevice(HDC hdc, POINT *ppt)
{
    int xdn, xnm;
    int ydn, ynm;

#if 1
    xdn = GetDeviceCaps(hdc, HORZSIZE)*100;
    xnm = GetDeviceCaps(hdc, HORZRES);
    ydn = GetDeviceCaps(hdc, VERTSIZE)*100;
    ynm = GetDeviceCaps(hdc, VERTRES);
#else
    xdn = 2540;
    xnm = GetDeviceCaps(hdc, LOGPIXELSX);
    ydn = 2540;
    ynm = GetDeviceCaps(hdc, LOGPIXELSY);
#endif
    ppt->x = MulDiv(ppt->x, xnm, xdn);
    ppt->y = MulDiv(ppt->y, ynm, ydn);
    printf("DEVICE bounds %d,%d\n", ppt->x, ppt->y);
}

#define SRC_TYPE_GL          1
#define SRC_TYPE_GDI         2
#define SRC_TYPE_METAFILE    4
#define SRC_TYPE_MASK        7

#define DST_TYPE_METAFILE    1
#define DST_TYPE_DC          2
#define DST_TYPE_MASK        3

#define DST_HAS_RC      0x1000

typedef struct _Data
{
    union
    {
        HENHMETAFILE hemf;
        HDC hdc;
    } u;
} Data;

#define SRC_SIMPLE      0
#define SRC_OGLMOD      1
#define SRC_GDI         2
#define SRC_GLS         3
#define SRC_CLIPBOARD   4

typedef struct _SrcDescription
{
    char *pszName;
    DWORD fData;
    
    void (*Setup)(void);
    void (*SetupHdc)(HDC hdc);
    void (*Produce)(Data *pdata);
    void (*Cleanup)(void);
} SrcDescription;
SrcDescription *psdSrc;

#define DST_ENUM        0
#define DST_CLIPBOARD   1
#define DST_PRINT       2
#define DST_SCREEN      3

typedef struct _DstDescription
{
    char *pszName;
    DWORD fData;
    
    void (*Setup)(Data *pdata);
    void (*Consume)(Data *pdata);
    void (*Cleanup)(Data *pdata);
} DstDescription;
DstDescription *pddDst;

BOOL bDouble = TRUE;
BOOL bOffsetDraw = FALSE;

POINT ptBounds = {300, 300};
GLenum iAuxMode = AUX_RGB | AUX_DEPTH16;
char pszGlsFile[256];

void PrintEmf(HENHMETAFILE hemf)
{
    ENHMETAHEADER emh;
    ULONG cbPixelFormat;
    PIXELFORMATDESCRIPTOR pfd;

    if (!GetEnhMetaFileHeader(hemf, sizeof(emh), &emh))
    {
        printf("Unable to get header, %d\n", GetLastError());
    }
    else
    {
        printf("Metafile bounds: %d,%d - %d,%d\n",
               emh.rclFrame.left, emh.rclFrame.top,
               emh.rclFrame.right, emh.rclFrame.bottom);
    }
    
    cbPixelFormat = GetEnhMetaFilePixelFormat(hemf, sizeof(pfd), &pfd);
    if (cbPixelFormat == GDI_ERROR)
    {
        printf("Unable to get metafile pixel format, %d\n", GetLastError());
    }
    else if (cbPixelFormat > 0)
    {
        printf("Pixel format in metafile, %d bytes (%d), version %d\n",
               cbPixelFormat, pfd.nSize, pfd.nVersion);
        printf("  dwFlags      = 0x%08lX\n", pfd.dwFlags);
        printf("  iPixelType   = %d\n", pfd.iPixelType);
        printf("  cColorBits   = %d\n", pfd.cColorBits);
        printf("  cAlphaBits   = %d\n", pfd.cAlphaBits);
        printf("  cAccumBits   = %d\n", pfd.cAccumBits);
        printf("  cDepthBits   = %d\n", pfd.cDepthBits);
        printf("  cStencilBits = %d\n", pfd.cStencilBits);
        printf("  %d.%d:%d.%d:%d.%d\n",
               pfd.cRedBits, pfd.cRedShift,
               pfd.cGreenBits, pfd.cGreenShift,
               pfd.cBlueBits, pfd.cBlueShift);
    }
}

void CreateCurrentRc(HDC hdc)
{
    HGLRC hrc;
    
    hrc = wglCreateContext(hdc);
    if (hrc == NULL)
    {
        printf("Unable to create context, %d\n", GetLastError());
        exit(1);
    }

    if (!wglMakeCurrent(hdc, hrc))
    {
        printf("Unable to make current, %d\n", GetLastError());
        exit(1);
    }
}

void CleanupCurrentRc(void)
{
    HGLRC hrc;

    hrc = wglGetCurrentContext();
    wglMakeCurrent(NULL, NULL);
    wglDeleteContext(hrc);
}

void MetafileFromCall(SrcDescription *psd, Data *pdata)
{
    HDC hdc;
    
    hdc = CreateEnhMetaFile(NULL, NULL, NULL, NULL);
    if (hdc == NULL)
    {
        printf("CreateEnhMetaFile failed, %d\n", GetLastError());
        exit(1);
    }

    psd->SetupHdc(hdc);
    
    if ((psd->fData & SRC_TYPE_MASK) == SRC_TYPE_GL)
    {
        CreateCurrentRc(hdc);
    }

    psd->Produce(pdata);

    if ((psd->fData & SRC_TYPE_MASK) == SRC_TYPE_GL)
    {
        CleanupCurrentRc();
    }
    
    pdata->u.hemf = CloseEnhMetaFile(hdc);
    if (pdata->u.hemf == NULL)
    {
        printf("CloseEnhMetaFile failed, %d\n", GetLastError());
        exit(1);
    }
            
    PrintEmf(pdata->u.hemf);
}

void PlayMetafile(SrcDescription *psd, Data *pdata)
{
    RECT rBounds;
    Data dataSrc;

    psd->Produce(&dataSrc);
    
    // Metafile rect is inclusive-inclusive
    rBounds.left = 0;
    rBounds.top = 0;
    rBounds.right = ptBounds.x;
    rBounds.bottom = ptBounds.y;
    if (!PlayEnhMetaFile(pdata->u.hdc, dataSrc.u.hemf, &rBounds))
    {
        printf("PlayEnhMetaFile failed, %d\n", GetLastError());
    }
}

void ProduceForHdc(SrcDescription *psd, DstDescription *pdd, Data *pdataDst)
{
    BOOL fRc;

    fRc = FALSE;
    if (wglGetCurrentContext() == NULL &&
        ((psd->fData & SRC_TYPE_MASK) == SRC_TYPE_GL ||
         (psd->fData & SRC_TYPE_MASK) == SRC_TYPE_METAFILE &&
         (pdd->fData & DST_HAS_RC) == 0))
    {
        CreateCurrentRc(pdataDst->u.hdc);
        fRc = TRUE;
    }
    
    switch(psd->fData & SRC_TYPE_MASK)
    {
    case SRC_TYPE_GL:
    case SRC_TYPE_GDI:
        psd->Produce(pdataDst);
        break;
    case SRC_TYPE_METAFILE:
        PlayMetafile(psd, pdataDst);
        break;
    }
    
    if (fRc)
    {
        CleanupCurrentRc();
    }
}

void Empty(void)
{
}

void EmptyHdc(HDC hdc)
{
}

void EmptyData(Data *pdata)
{
}

#define SIMPLE_VERTEX2(x, y) v2sv(x, y)

void v2sv(int x, int y)
{
    GLshort v[2];

    v[0] = (GLshort)x;
    v[1] = (GLshort)y;
    glVertex2sv(v);
}

void SrcProduceSimple(Data *pdata)
{
    glViewport(0, 0, ptBounds.x, ptBounds.y);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, ptBounds.x, 0, ptBounds.y, -1, 1);
    glMatrixMode(GL_MODELVIEW);

    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_LINES);
    glColor3d(1, 0, 0);
    SIMPLE_VERTEX2(0, 0);
    SIMPLE_VERTEX2(ptBounds.x-1, ptBounds.y-1);
    glColor3d(0, 1, 0);
    SIMPLE_VERTEX2(ptBounds.x/4, ptBounds.y/2);
    SIMPLE_VERTEX2(0, 0);
    glColor3d(0, 0, 1);
    SIMPLE_VERTEX2(ptBounds.x/2, ptBounds.y/4);
    SIMPLE_VERTEX2(0, 0);
    glColor3d(1, 1, 0);
    SIMPLE_VERTEX2(ptBounds.x/2, ptBounds.y*3/4);
    SIMPLE_VERTEX2(ptBounds.x-1, ptBounds.y-1);
    glColor3d(1, 0, 1);
    SIMPLE_VERTEX2(ptBounds.x*3/4, ptBounds.y/2);
    SIMPLE_VERTEX2(ptBounds.x-1, ptBounds.y-1);
    glEnd();
}

void SrcSetupOglmod(void)
{
    if (ogl_module->DisplayMode != NULL)
    {
        iAuxMode = ogl_module->DisplayMode();
    }
    else
    {
        iAuxMode = AUX_RGB | AUX_DEPTH16;
    }
    ogl_module->Bounds(&ptBounds.x, &ptBounds.y);
}

void SrcSetupHdcOglmod(HDC hdc)
{
    if (ogl_module->Init != NULL)
    {
        ogl_module->Init(hdc);
    }
}

void SrcProduceOglmod(Data *pdata)
{
    ogl_module->Draw(ptBounds.x, ptBounds.y);
}

void SrcProduceGdi(Data *pdata)
{
    SelectObject(pdata->u.hdc, GetStockObject(WHITE_PEN));
    MoveToEx(pdata->u.hdc, 0, 0, NULL);
    LineTo(pdata->u.hdc, ptBounds.x, ptBounds.y);
}

void SrcProduceGls(Data *pdata)
{
    GlsMemoryStream *gms;
    GLuint ctx;
    extern void APIENTRY glsCallArrayInContext(GLuint, GLenum, size_t,
                                               const GLubyte *);
    
    printf("Playing GLS file '%s'\n", pszGlsFile);
    ctx = glsGenContext();
    if (ctx == 0)
    {
        printf("Unable to create GLS context\n");
        exit(1);
    }
    
    gms = GmsLoad(pszGlsFile);
    if (gms == NULL)
    {
        exit(1);
    }
    
    glsCallArrayInContext(ctx, gms->iStreamType, gms->cb, gms->pb);
    
    GmsFree(gms);

    glsDeleteContext(ctx);
}

void SrcProduceClipboard(Data *pdata)
{
    if (!OpenClipboard(NULL))
    {
        printf("OpenClipboard failed, %d\n", GetLastError());
        exit(1);
    }
            
    pdata->u.hemf = GetClipboardData(CF_ENHMETAFILE);
    if (pdata->u.hemf == NULL)
    {
        printf("GetClipboardData failed, %d\n", GetLastError());
        exit(1);
    }

    PrintEmf(pdata->u.hemf);
            
    CloseClipboard();
}

SrcDescription sdSrc[] =
{
    "Simple OpenGL", SRC_TYPE_GL,
        Empty, EmptyHdc, SrcProduceSimple, Empty,
    "Oglmod", SRC_TYPE_GL,
        SrcSetupOglmod, SrcSetupHdcOglmod, SrcProduceOglmod, Empty,
    "GDI", SRC_TYPE_GDI,
        Empty, EmptyHdc, SrcProduceGdi, Empty,
    "GLS stream", SRC_TYPE_GL,
        Empty, EmptyHdc, SrcProduceGls, Empty,
    "Clipboard", SRC_TYPE_METAFILE,
        Empty, EmptyHdc, SrcProduceClipboard, Empty
};

int CALLBACK EnumFn(HDC hdc, HANDLETABLE *pht, ENHMETARECORD CONST *pemr,
                    int nObj, LPARAM pv)
{
    printf("Record type %d, size %d\n", pemr->iType, pemr->nSize);
    return TRUE;
}

void DstConsumeEnum(Data *pdata)
{
    RECT rBounds;
    
    // Metafile rect is inclusive-inclusive
    rBounds.left = 0;
    rBounds.top = 0;
    rBounds.right = ptBounds.x;
    rBounds.bottom = ptBounds.y;
    if (!EnumEnhMetaFile(NULL, pdata->u.hemf, EnumFn, NULL, &rBounds))
    {
        printf("EnumEnhMetaFile failed, %d\n", GetLastError());
    }
}

void DstSetupPrint(Data *pdata)
{
    PRINTDLG pdlg;
    DOCINFO doc;
            
    memset(&pdlg, 0, sizeof(pdlg));
    pdlg.lStructSize = sizeof(pdlg);
    pdlg.Flags = PD_RETURNDC;

    if (!PrintDlg(&pdlg))
    {
        printf("PrintDlg failed, %d\n", GetLastError());
        exit(1);
    }

    pdata->u.hdc = pdlg.hDC;
    ConvertToHighMetric(GetDC(NULL), &ptBounds);
    ConvertToDevice(pdata->u.hdc, &ptBounds);
            
    doc.cbSize = sizeof(doc);
    doc.lpszDocName = "MfGls Document";
    doc.lpszOutput = NULL;
    doc.lpszDatatype = NULL;
    doc.fwType = 0;
    if (StartDoc(pdata->u.hdc, &doc) == SP_ERROR)
    {
        printf("Start doc failed, %d\n", GetLastError());
        exit(1);
    }
    if (StartPage(pdata->u.hdc) == 0)
    {
        printf("Start page failed, %d\n", GetLastError());
        exit(1);
    }
}

void DstCleanupPrint(Data *pdata)
{
    if (EndPage(pdata->u.hdc) == 0)
    {
        printf("End page failed, %d\n", GetLastError());
    }
    if (EndDoc(pdata->u.hdc) == SP_ERROR)
    {
        printf("End doc failed, %d\n", GetLastError());
    }
    DeleteDC(pdata->u.hdc);
}

void DstConsumeClipboard(Data *pdata)
{
    if (!OpenClipboard(NULL))
    {
        printf("OpenClipboard failed, %d\n", GetLastError());
        exit(1);
    }

    if (!EmptyClipboard())
    {
        printf("EmptyClipboard failed, %d\n", GetLastError());
    }
            
    if (!SetClipboardData(CF_ENHMETAFILE, pdata->u.hemf))
    {
        printf("SetClipboardData failed, %d\n", GetLastError());
    }
    CloseClipboard();
}

void Redraw(void)
{
    Data data;

    data.u.hdc = auxGetHDC();
    ProduceForHdc(psdSrc, pddDst, &data);

    // ATTENTION - Kind of a hack because the check should actually be
    // SRC_TYPE_GL || metafile with GL records
    if ((psdSrc->fData & SRC_TYPE_MASK) != SRC_TYPE_GDI)
    {
        glFlush();
        if (bDouble)
        {
            auxSwapBuffers();
        }
    }
}

void Reshape(GLsizei w, GLsizei h)
{
    ptBounds.x = w;
    ptBounds.y = h;
}

void DstSetupScreen(Data *pdata)
{
    auxInitPosition(50, 50, ptBounds.x, ptBounds.y);
    if (bDouble)
    {
        auxInitDisplayMode(iAuxMode | AUX_DOUBLE);
    }
    else
    {
        auxInitDisplayMode(iAuxMode | AUX_SINGLE);
    }
    auxInitWindow("Enhanced Metafile Player");
    auxReshapeFunc(Reshape);
    pdata->u.hdc = auxGetHDC();
}

void DstConsumeScreen(Data *pdata)
{
    auxMainLoop(Redraw);
}

DstDescription ddDst[] =
{
    "Enumerate metafile", DST_TYPE_METAFILE,
        EmptyData, DstConsumeEnum, EmptyData,
    "Paste", DST_TYPE_METAFILE,
        EmptyData, DstConsumeClipboard, EmptyData,
    "Print", DST_TYPE_DC,
        DstSetupPrint, EmptyData, DstCleanupPrint,
    "Screen", DST_TYPE_DC | DST_HAS_RC,
        DstSetupScreen, DstConsumeScreen, EmptyData
};
DstDescription *pddDst;

void Usage(void)
{
    int i;
    
    printf("Usage:\n");
    printf("  mfgls [-h[elp]]   = Show this message\n");
    printf("or\n");
    printf("  mfgls [options]\n");
    printf("    -simple (def)   = Simple source image\n");
    printf("    -oglmod<name>   = Source image from OpenGL module <name>\n");
    printf("    -gls<file>      = Source image in GLS <file>\n");
    printf("    -clip           = Source metafile from clipboard\n");
    printf("    -gdi            = Source image from GDI calls\n");
    printf("    -paste (def)    = Paste source to clipboard\n");
    printf("    -enum           = Enumerate source\n");
    printf("    -print          = Print source\n");
    printf("    -show           = Show source on screen\n");
    printf("    -double (def)   = Double buffered\n");
    printf("    -single         = Single buffered\n");
    printf("\n");
    printf("Current OpenGL modules are:\n");
    for (i = 0; i < OGLMOD_COUNT; i++)
    {
        printf("    %s\n", ogl_modules[i]->name);
    }
    exit(1);
}

GLint __cdecl main(int argc, char **argv)
{
    int iSrc, iDst;
    Data dataSrc, dataDst;

    iSrc = SRC_SIMPLE;
    iDst = DST_CLIPBOARD;
    
    while (--argc > 0)
    {
        argv++;

        if (!strcmp(*argv, "-simple"))
        {
            iSrc = SRC_SIMPLE;
        }
        else if (!strncmp(*argv, "-om", 3))
        {
            iSrc = SRC_OGLMOD;
            ogl_module = FindOglModule(*argv+3);
            sdSrc[iSrc].pszName = ogl_module->name;
        }
        else if (!strncmp(*argv, "-oglmod", 7))
        {
            iSrc = SRC_OGLMOD;
            ogl_module = FindOglModule(*argv+7);
            sdSrc[iSrc].pszName = ogl_module->name;
        }
        else if (!strcmp(*argv, "-gdi"))
        {
            iSrc = SRC_GDI;
        }
        else if (!strncmp(*argv, "-gls", 4))
        {
            iSrc = SRC_GLS;
            strcpy(pszGlsFile, *argv+4);
        }
        else if (!strcmp(*argv, "-clip"))
        {
            iSrc = SRC_CLIPBOARD;
        }
        else if (!strcmp(*argv, "-paste"))
        {
            iDst = DST_CLIPBOARD;
        }
        else if (!strcmp(*argv, "-enum"))
        {
            iDst = DST_ENUM;
        }
        else if (!strcmp(*argv, "-print"))
        {
            iDst = DST_PRINT;
        }
        else if (!strcmp(*argv, "-show"))
        {
            iDst = DST_SCREEN;
        }
        else if (!strcmp(*argv, "-double"))
        {
            bDouble = TRUE;
        }
        else if (!strcmp(*argv, "-single"))
        {
            bDouble = FALSE;
        }
        else if (!strncmp(*argv, "-wd", 3))
        {
            sscanf(*argv+3, "%d", &ptBounds.x);
        }
        else if (!strncmp(*argv, "-ht", 3))
        {
            sscanf(*argv+3, "%d", &ptBounds.y);
        }
        else if (!strcmp(*argv, "-h") ||
                 !strcmp(*argv, "-help"))
        {
            Usage();
        }
        else
        {
            Usage();
        }
    }

    psdSrc = &sdSrc[iSrc];
    pddDst = &ddDst[iDst];
    
    printf("Source '%s', destination '%s'\n",
           psdSrc->pszName, pddDst->pszName);

    psdSrc->Setup();
    pddDst->Setup(&dataDst);

    switch((pddDst->fData) & DST_TYPE_MASK)
    {
    case DST_TYPE_METAFILE:
        switch((psdSrc->fData) & SRC_TYPE_MASK)
        {
        case SRC_TYPE_GL:
        case SRC_TYPE_GDI:
            MetafileFromCall(psdSrc, &dataSrc);
            break;
        case SRC_TYPE_METAFILE:
            psdSrc->Produce(&dataSrc);
            break;
        }

        pddDst->Consume(&dataSrc);
        break;
        
    case DST_TYPE_DC:
#if 0
        {
            RECT rBox;
            
            printf("Type is %d, tech is %d\n",
                   GetObjectType(dataDst.u.hdc),
                   GetDeviceCaps(dataDst.u.hdc, TECHNOLOGY));
            GetClipBox(dataDst.u.hdc, &rBox);
            printf("Clip box is %d,%d - %d,%d\n",
                   rBox.left, rBox.top, rBox.right, rBox.bottom);
        }
#endif
        
        psdSrc->SetupHdc(dataDst.u.hdc);

        ProduceForHdc(psdSrc, pddDst, &dataDst);

        pddDst->Consume(&dataDst);
        break;
    }
    
    psdSrc->Cleanup();
    pddDst->Cleanup(&dataDst);

    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\glsutil.c ===
#include "pch.c"
#pragma hdrstop

#include "glsutil.h"

GlsMemoryStream *GmsLoad(char *pszStream)
{
    GlsMemoryStream *gms;
    FILE *fp;

    gms = (GlsMemoryStream *)malloc(sizeof(GlsMemoryStream));
    if (gms == NULL)
    {
        fprintf(stderr, "GlsLoad: Out of memory\n");
        return NULL;
    }

    gms->iStreamType = glsGetStreamType(pszStream);
    if (gms->iStreamType == 0)
    {
        fprintf(stderr, "GlsLoad: Invalid stream %s\n", pszStream);
        free(gms);
        return NULL;
    }
    
    gms->cb = glsGetStreamSize(pszStream);
    if (gms->cb == 0)
    {
        fprintf(stderr, "GlsLoad: Could not determine size of stream %s\n",
                pszStream);
        free(gms);
        return NULL;
    }
    
    gms->pb = (GLubyte *)malloc(gms->cb);
    if (gms->pb == NULL)
    {
        fprintf(stderr, "GlsLoad: malloc(%u) failed\n", gms->cb);
        free(gms);
        return NULL;
    }

    fp = fopen(pszStream, "rb");
    if (fp == NULL)
    {
        fprintf(stderr, "GlsLoad: Unable to open %s\n", pszStream);
        free(gms->pb);
        free(gms);
        return NULL;
    }
    
    fread(gms->pb, 1, gms->cb, fp);

    fclose(fp);

    return gms;
}

void GmsFree(GlsMemoryStream *gms)
{
    free(gms->pb);
    free(gms);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\material.c ===
#include "pch.c"
#pragma hdrstop

/*  Initialize z-buffer, projection matrix, light source, 
 *  and lighting model.  Do not specify a material property here.
 */
static void myinit(void)
{
    GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat position[] = { 0.0, 3.0, 2.0, 0.0 };
    GLfloat lmodel_ambient[] = { 0.4, 0.4, 0.4, 1.0 };
    GLfloat local_view[] = { 0.0 };

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glClearColor(0.0, 0.1, 0.1, 0.0);
}

/*  Draw twelve spheres in 3 rows with 4 columns.  
 *  The spheres in the first row have materials with no ambient reflection.
 *  The second row has materials with significant ambient reflection.
 *  The third row has materials with colored ambient reflection.
 *
 *  The first column has materials with blue, diffuse reflection only.
 *  The second column has blue diffuse reflection, as well as specular
 *  reflection with a low shininess exponent.
 *  The third column has blue diffuse reflection, as well as specular
 *  reflection with a high shininess exponent (a more concentrated highlight).
 *  The fourth column has materials which also include an emissive component.
 *
 *  glTranslatef() is used to move spheres to their appropriate locations.
 */

static void display(void)
{
    GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 };
    GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 };
    GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat no_shininess[] = { 0.0 };
    GLfloat low_shininess[] = { 5.0 };
    GLfloat high_shininess[] = { 100.0 };
    GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0};

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

/*  draw sphere in first row, first column
 *  diffuse reflection only; no ambient or specular  
 */
    glPushMatrix();
    glTranslatef (-3.75, 3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in first row, second column
 *  diffuse and specular reflection; low shininess; no ambient
 */
    glPushMatrix();
    glTranslatef (-1.25, 3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in first row, third column
 *  diffuse and specular reflection; high shininess; no ambient
 */
    glPushMatrix();
    glTranslatef (1.25, 3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in first row, fourth column
 *  diffuse reflection; emission; no ambient or specular reflection
 */
    glPushMatrix();
    glTranslatef (3.75, 3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in second row, first column
 *  ambient and diffuse reflection; no specular  
 */
    glPushMatrix();
    glTranslatef (-3.75, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in second row, second column
 *  ambient, diffuse and specular reflection; low shininess
 */
    glPushMatrix();
    glTranslatef (-1.25, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in second row, third column
 *  ambient, diffuse and specular reflection; high shininess
 */
    glPushMatrix();
    glTranslatef (1.25, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in second row, fourth column
 *  ambient and diffuse reflection; emission; no specular
 */
    glPushMatrix();
    glTranslatef (3.75, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in third row, first column
 *  colored ambient and diffuse reflection; no specular  
 */
    glPushMatrix();
    glTranslatef (-3.75, -3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in third row, second column
 *  colored ambient, diffuse and specular reflection; low shininess
 */
    glPushMatrix();
    glTranslatef (-1.25, -3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in third row, third column
 *  colored ambient, diffuse and specular reflection; high shininess
 */
    glPushMatrix();
    glTranslatef (1.25, -3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in third row, fourth column
 *  colored ambient and diffuse reflection; emission; no specular
 */
    glPushMatrix();
    glTranslatef (3.75, -3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
    auxSolidSphere(1.0);
    glPopMatrix();

    glFlush();
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= (h * 2))
	glOrtho (-6.0, 6.0, -3.0*((GLfloat)h*2)/(GLfloat)w, 
	    3.0*((GLfloat)h*2)/(GLfloat)w, -10.0, 10.0);
    else
	glOrtho (-6.0*(GLfloat)w/((GLfloat)h*2), 
	    6.0*(GLfloat)w/((GLfloat)h*2), -3.0, 3.0, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

#define WIDTH 600
#define HEIGHT 450

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_material =
{
    "material",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\mfgls.h ===
#ifndef __MFGLS_H__
#define __MFGLS_H__

void SetHdcPixelFormat(HDC hdc, int cAlphaBits, int cAccumBits,
                       int cDepthBits, int cStencilBits);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\pch.c ===
#include <stdlib.h>
#include <windows.h>
#include <commdlg.h>

#include <GL/glaux.h>

#include "../../../../inc/glmf.h"
#include "oglmod.h"
#include "mfgls.h"

#pragma warning(disable:4244)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\ofont.c ===
#include "pch.c"
#pragma hdrstop

#define WIDTH 256
#define HEIGHT 128

#define STRING "Test"
#define STRLEN (sizeof(STRING)-1)
#define CHAR_BASE 64
#define CHAR_NUM 64

#define ANG_STEP 45

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    HDC hdc;
    LOGFONT lf;
    HFONT hfont, hfontOld;
    GLuint lists;
    
    glLoadIdentity();
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-WIDTH, WIDTH, -HEIGHT, HEIGHT, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    
    hdc = wglGetCurrentDC();
    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfHeight = -24;
    lf.lfWeight = FW_NORMAL;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_SCREEN_OUTLINE_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = FF_DONTCARE | DEFAULT_PITCH;
    lstrcpy (lf.lfFaceName, "Arial") ;

    hfont = CreateFontIndirect(&lf);
    if (hfont == NULL)
    {
        printf("CreateFontIndirect failed, %d\n", GetLastError());
        return;
        
    }
    hfontOld = (HFONT)SelectObject(hdc, hfont);

    lists = glGenLists(CHAR_NUM);
    
    if (!wglUseFontOutlines(hdc, CHAR_BASE, CHAR_NUM, lists, 0.0f, 0.0f, 
                            WGL_FONT_POLYGONS, NULL))
    {
        printf("wglUseFontOutlines failed, %d\n", GetLastError());
    }
    else
    {
        int i;
        GLfloat grey;
        
        glClear(GL_COLOR_BUFFER_BIT);

        glScalef(72.0f, 72.0f, 72.0f);
        glListBase(lists-CHAR_BASE);

        grey = 0.5f;
        for (i = 0; i < 360; i += ANG_STEP)
        {
            glPushMatrix();

            glColor3f(grey, grey, grey);
            glRotatef((GLfloat)i, 0.0f, 0.0f, 1.0f);
            glCallLists(STRLEN, GL_UNSIGNED_BYTE, STRING);

            glPopMatrix();

            grey += 0.5f/(360/ANG_STEP-1);
        }
    }

    SelectObject(hdc, hfontOld);
    DeleteObject(hfont);
}

OglModule oglmod_ofont =
{
    "ofont",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\sharel.c ===
#include "pch.c"
#pragma hdrstop

#define WIDTH 512
#define HEIGHT 512

#define NLISTS 6
#define NTHREADS 1
#define NTLISTS (NLISTS/NTHREADS)
#define NRC (NTHREADS+1)
#define DRAW_RC (NRC-1)
#define THREAD_RC 0
#define THREAD_LIST_DELAY 250
#define THREAD_STEP_DELAY 100
#define THREAD_PAUSE_DELAY 1000

static char *wndclass = "GlUtest";
static char *wndtitle = "OpenGL Unit Test";

static HINSTANCE hinstance;
static HWND main_wnd;
static HGLRC wnd_hrc[NRC];
static HPALETTE wnd_hpal;
static GLint lists[NLISTS];
static double xr = 45, yr = 45, zr = 0;
static UINT timer = 0;
static BOOL terminating = FALSE;
static HANDLE thread_sem = NULL;

void SetOnce(void)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45, 1, .01, 10);
    gluLookAt(0, 0, -3, 0, 0, 0, 0, 1, 0);
    glMatrixMode(GL_MODELVIEW);

    glEnable(GL_CULL_FACE);
}

void CreateLists0(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* XZ zero plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 0, 0);
    glVertex3d(0, 0, 0);
    glColor3d(1, 0, 0);
    glVertex3d(1, 0, 0);
    glColor3d(1, 0, 1);
    glVertex3d(1, 0, 1);
    glColor3d(0, 0, 1);
    glVertex3d(0, 0, 1);
    glEnd();

    glEndList();
}

void CreateLists1(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* XY zero plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 0, 0);
    glVertex3d(0, 0, 0);
    glColor3d(0, 1, 0);
    glVertex3d(0, 1, 0);
    glColor3d(1, 1, 0);
    glVertex3d(1, 1, 0);
    glColor3d(1, 0, 0);
    glVertex3d(1, 0, 0);
    glEnd();

    glEndList();
}

void CreateLists2(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* YZ zero plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 0, 0);
    glVertex3d(0, 0, 0);
    glColor3d(0, 0, 1);
    glVertex3d(0, 0, 1);
    glColor3d(0, 1, 1);
    glVertex3d(0, 1, 1);
    glColor3d(0, 1, 0);
    glVertex3d(0, 1, 0);
    glEnd();

    glEndList();
}

void CreateLists3(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* XZ one plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 1, 0);
    glVertex3d(0, 1, 0);
    glColor3d(0, 1, 1);
    glVertex3d(0, 1, 1);
    glColor3d(1, 1, 1);
    glVertex3d(1, 1, 1);
    glColor3d(1, 1, 0);
    glVertex3d(1, 1, 0);
    glEnd();

    glEndList();
}

void CreateLists4(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* XY one plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 0, 1);
    glVertex3d(0, 0, 1);
    glColor3d(1, 0, 1);
    glVertex3d(1, 0, 1);
    glColor3d(1, 1, 1);
    glVertex3d(1, 1, 1);
    glColor3d(0, 1, 1);
    glVertex3d(0, 1, 1);
    glEnd();

    glEndList();
}

void CreateLists5(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* YZ one plane */
    glBegin(GL_POLYGON);
    glColor3d(1, 0, 0);
    glVertex3d(1, 0, 0);
    glColor3d(1, 1, 0);
    glVertex3d(1, 1, 0);
    glColor3d(1, 1, 1);
    glVertex3d(1, 1, 1);
    glColor3d(1, 0, 1);
    glVertex3d(1, 0, 1);
    glEnd();

    glEndList();
}

void (*define_list[NLISTS])(GLuint id) =
{
    CreateLists0,
    CreateLists1,
    CreateLists2,
    CreateLists3,
    CreateLists4,
    CreateLists5
};

static void Draw(void)
{
    glClear(GL_COLOR_BUFFER_BIT);

    glLoadIdentity();

    glRotated(xr, 1, 0, 0);
    glRotated(yr, 0, 1, 0);
    glRotated(zr, 0, 0, 1);
    glTranslated(-.5, -.5, -.5);

    glCallLists(NLISTS, GL_INT, lists);
        
    glFinish();
}

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglInit(HDC hdc)
{
    SetHdcPixelFormat(hdc, 0, 0, 16, 0);
}

static void OglDraw(int w, int h)
{
    int list_base, id, i, lid;
    
    SetOnce();

    id = 0;
    lid = 0;
    list_base = glGenLists(NTLISTS);
    if (list_base == 0)
    {
        printf("ThreadFn: Thread %d unable to glGenLists, 0x%X\n",
               id, glGetError());
        exit(1);
    }

    for (i = 0; i < NTLISTS; i++)
    {
        define_list[lid+i](list_base+i);
        lists[lid+i] = list_base+i;
    }

    glViewport(0, 0, w, h);
    Draw();
}

OglModule oglmod_sharel =
{
    "sharel",
    NULL,
    OglBounds,
    OglInit,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\polys.c ===
#include "pch.c"
#pragma hdrstop

static void display(void)
{
    GLubyte fly[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x80, 0x01, 0xC0, 0x06, 0xC0, 0x03, 0x60, 0x04, 0x60, 0x06, 0x20,
0x04, 0x30, 0x0C, 0x20, 0x04, 0x18, 0x18, 0x20, 0x04, 0x0C, 0x30, 0x20,
0x04, 0x06, 0x60, 0x20, 0x44, 0x03, 0xC0, 0x22, 0x44, 0x01, 0x80, 0x22,
0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22, 0x66, 0x01, 0x80, 0x66,
0x33, 0x01, 0x80, 0xCC, 0x19, 0x81, 0x81, 0x98, 0x0C, 0xC1, 0x83, 0x30,
0x07, 0xe1, 0x87, 0xe0, 0x03, 0x3f, 0xfc, 0xc0, 0x03, 0x31, 0x8c, 0xc0,
0x03, 0x33, 0xcc, 0xc0, 0x06, 0x64, 0x26, 0x60, 0x0c, 0xcc, 0x33, 0x30,
0x18, 0xcc, 0x33, 0x18, 0x10, 0xc4, 0x23, 0x08, 0x10, 0x63, 0xC6, 0x08,
0x10, 0x30, 0x0c, 0x08, 0x10, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x08};

    GLubyte halftone[] = {
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55};

    glClear (GL_COLOR_BUFFER_BIT);

/*  draw all polygons in white	*/
    glColor3f (1.0, 1.0, 1.0);

/*  draw one solid, unstippled rectangle,	*/	
/*  then two stippled rectangles		*/
    glRectf (25.0, 25.0, 125.0, 125.0);
    glEnable (GL_POLYGON_STIPPLE);
    glPolygonStipple (fly);
    glRectf (125.0, 25.0, 225.0, 125.0);
    glPolygonStipple (halftone);
    glRectf (225.0, 25.0, 325.0, 125.0);
    glDisable (GL_POLYGON_STIPPLE);

    glFlush ();
}

static void myinit (void) 
{
/*  clear background to black	*/
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glShadeModel (GL_FLAT);    
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0.0, 350, 0.0, 150, -1, 1);
    glMatrixMode(GL_MODELVIEW);
}

#define WIDTH 350
#define HEIGHT 150

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_polys =
{
    "polys",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\oglmod.h ===
typedef struct _OglModule
{
    char *name;
    
    GLenum (*DisplayMode)(void);
    void   (*Bounds)(int *w, int *h);
    void   (*Init)(HDC hdc);
    void   (*Draw)(int w, int h);
} OglModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\smooth.c ===
#include "pch.c"
#pragma hdrstop

/*  GL_SMOOTH is actually the default shading model.  */
static void myinit (void)
{
    glShadeModel (GL_SMOOTH);
}

static void triangle(void)
{
    glBegin (GL_TRIANGLES);
    glColor3f (1.0, 0.0, 0.0);
    glVertex2f (5.0, 5.0);
    glColor3f (0.0, 1.0, 0.0);
    glVertex2f (25.0, 5.0);
    glColor3f (0.0, 0.0, 1.0);
    glVertex2f (5.0, 25.0);
    glEnd ();
}

static void display(void)
{
    glClear (GL_COLOR_BUFFER_BIT);
    triangle ();
    glFlush ();
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	gluOrtho2D (0.0, 30.0, 0.0, 30.0 * (GLfloat) h/(GLfloat) w);
    else 
	gluOrtho2D (0.0, 30.0 * (GLfloat) w/(GLfloat) h, 0.0, 30.0);
    glMatrixMode(GL_MODELVIEW);
}

#define WIDTH 500
#define HEIGHT 500

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_smooth =
{
    "smooth",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\surfgrid.c ===
/*
 * surfgrid.c - simple test of polygon offset
 *
 *  $Revision: 1.3 $
 *
 * usage:
 *	surfgrid [-f]
 *
 * options:
 *	-f	run on full screen
 *
 * keys:
 *	p	toggle polygon offset
 *	m	toggle multisampling
 *      S       increase polygon offset factor
 *      s       decrease polygon offset factor
 *      B       increase polygon offset bias
 *      b       decrease polygon offset bias
 *	g	toggle grid drawing
 *      t       toggle surface drawing
 *	f	toggle smooth/flat shading
 *	n	toggle whether to use GL evaluators or GLU nurbs
 *	u	decr number of segments in U direction
 *	U	incr number of segments in U direction
 *	v	decr number of segments in V direction
 *	V	incr number of segments in V direction
 *	escape	quit
 */
#include "pch.c"
#pragma hdrstop

#include <math.h>

#define W 600
#define H 600

static GLfloat controlpts[] =
{
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 3.0f, 0.0f, 1.0f, 2.0f,
    3.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f, 8.0f, 0.0f, 0.0f, 4.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 3.0f, 0.0f,-1.0f, 2.0f,
    3.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f, 4.0f, 0.0f, 0.0f, 4.0f,
    2.0f,-2.0f, 0.0f, 2.0f, 1.0f,-1.0f, 0.5f, 1.0f, 1.5f,-1.5f, 0.5f, 1.0f,
    1.5f,-1.5f, 0.5f, 1.0f, 2.0f,-2.0f, 0.5f, 1.0f, 4.0f,-4.0f, 0.0f, 2.0f,
    4.0f,-4.0f, 0.0f, 2.0f, 2.0f,-2.0f,-0.5f, 1.0f, 1.5f,-1.5f,-0.5f, 1.0f,
    1.5f,-1.5f,-0.5f, 1.0f, 1.0f,-1.0f,-0.5f, 1.0f, 2.0f,-2.0f, 0.0f, 2.0f,
    0.0f,-2.0f, 0.0f, 2.0f, 0.0f,-1.0f, 0.5f, 1.0f, 0.0f,-1.5f, 0.5f, 1.0f,
    0.0f,-1.5f, 0.5f, 1.0f, 0.0f,-2.0f, 0.5f, 1.0f, 0.0f,-4.0f, 0.0f, 2.0f,
    0.0f,-4.0f, 0.0f, 2.0f, 0.0f,-2.0f,-0.5f, 1.0f, 0.0f,-1.5f,-0.5f, 1.0f,
    0.0f,-1.5f,-0.5f, 1.0f, 0.0f,-1.0f,-0.5f, 1.0f, 0.0f,-2.0f, 0.0f, 2.0f,
    0.0f,-2.0f, 0.0f, 2.0f, 0.0f,-1.0f, 0.5f, 1.0f, 0.0f,-1.5f, 0.5f, 1.0f,
    0.0f,-1.5f, 0.5f, 1.0f, 0.0f,-2.0f, 0.5f, 1.0f, 0.0f,-4.0f, 0.0f, 2.0f,
    0.0f,-4.0f, 0.0f, 2.0f, 0.0f,-2.0f,-0.5f, 1.0f, 0.0f,-1.5f,-0.5f, 1.0f,
    0.0f,-1.5f,-0.5f, 1.0f, 0.0f,-1.0f,-0.5f, 1.0f, 0.0f,-2.0f, 0.0f, 2.0f,
   -2.0f,-2.0f, 0.0f, 2.0f,-1.0f,-1.0f, 0.5f, 1.0f,-1.5f,-1.5f, 0.5f, 1.0f,
   -1.5f,-1.5f, 0.5f, 1.0f,-2.0f,-2.0f, 0.5f, 1.0f,-4.0f,-4.0f, 0.0f, 2.0f,
   -4.0f,-4.0f, 0.0f, 2.0f,-2.0f,-2.0f,-0.5f, 1.0f,-1.5f,-1.5f,-0.5f, 1.0f,
   -1.5f,-1.5f,-0.5f, 1.0f,-1.0f,-1.0f,-0.5f, 1.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-3.0f, 0.0f, 1.0f, 2.0f,
   -3.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,-8.0f, 0.0f, 0.0f, 4.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-3.0f, 0.0f,-1.0f, 2.0f,
   -3.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,-4.0f, 0.0f, 0.0f, 4.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-3.0f, 0.0f, 1.0f, 2.0f,
   -3.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,-8.0f, 0.0f, 0.0f, 4.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-3.0f, 0.0f,-1.0f, 2.0f,
   -3.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,-4.0f, 0.0f, 0.0f, 4.0f,
   -2.0f, 2.0f, 0.0f, 2.0f,-1.0f, 1.0f, 0.5f, 1.0f,-1.5f, 1.5f, 0.5f, 1.0f,
   -1.5f, 1.5f, 0.5f, 1.0f,-2.0f, 2.0f, 0.5f, 1.0f,-4.0f, 4.0f, 0.0f, 2.0f,
   -4.0f, 4.0f, 0.0f, 2.0f,-2.0f, 2.0f,-0.5f, 1.0f,-1.5f, 1.5f,-0.5f, 1.0f,
   -1.5f, 1.5f,-0.5f, 1.0f,-1.0f, 1.0f,-0.5f, 1.0f,-2.0f, 2.0f, 0.0f, 2.0f,
    0.0f, 2.0f, 0.0f, 2.0f, 0.0f, 1.0f, 0.5f, 1.0f, 0.0f, 1.5f, 0.5f, 1.0f,
    0.0f, 1.5f, 0.5f, 1.0f, 0.0f, 2.0f, 0.5f, 1.0f, 0.0f, 4.0f, 0.0f, 2.0f,
    0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f,-0.5f, 1.0f, 0.0f, 1.5f,-0.5f, 1.0f,
    0.0f, 1.5f,-0.5f, 1.0f, 0.0f, 1.0f,-0.5f, 1.0f, 0.0f, 2.0f, 0.0f, 2.0f,
    0.0f, 2.0f, 0.0f, 2.0f, 0.0f, 1.0f, 0.5f, 1.0f, 0.0f, 1.5f, 0.5f, 1.0f,
    0.0f, 1.5f, 0.5f, 1.0f, 0.0f, 2.0f, 0.5f, 1.0f, 0.0f, 4.0f, 0.0f, 2.0f,
    0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f,-0.5f, 1.0f, 0.0f, 1.5f,-0.5f, 1.0f,
    0.0f, 1.5f,-0.5f, 1.0f, 0.0f, 1.0f,-0.5f, 1.0f, 0.0f, 2.0f, 0.0f, 2.0f,
    2.0f, 2.0f, 0.0f, 2.0f, 1.0f, 1.0f, 0.5f, 1.0f, 1.5f, 1.5f, 0.5f, 1.0f,
    1.5f, 1.5f, 0.5f, 1.0f, 2.0f, 2.0f, 0.5f, 1.0f, 4.0f, 4.0f, 0.0f, 2.0f,
    4.0f, 4.0f, 0.0f, 2.0f, 2.0f, 2.0f,-0.5f, 1.0f, 1.5f, 1.5f,-0.5f, 1.0f,
    1.5f, 1.5f,-0.5f, 1.0f, 1.0f, 1.0f,-0.5f, 1.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 3.0f, 0.0f, 1.0f, 2.0f,
    3.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f, 8.0f, 0.0f, 0.0f, 4.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 3.0f, 0.0f,-1.0f, 2.0f,
    3.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f, 4.0f, 0.0f, 0.0f, 4.0f,
};

static GLfloat nurbctlpts[] = {
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f,-2.0f, 0.0f, 2.0f, 1.0f,-1.0f, 0.5f, 1.0f,
    2.0f,-2.0f, 0.5f, 1.0f, 4.0f,-4.0f, 0.0f, 2.0f, 2.0f,-2.0f,-0.5f, 1.0f,
    1.0f,-1.0f,-0.5f, 1.0f, 2.0f,-2.0f, 0.0f, 2.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -1.0f,-1.0f, 0.5f, 1.0f,-2.0f,-2.0f, 0.5f, 1.0f,-4.0f,-4.0f, 0.0f, 2.0f,
   -2.0f,-2.0f,-0.5f, 1.0f,-1.0f,-1.0f,-0.5f, 1.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 2.0f, 0.0f, 2.0f,-1.0f, 1.0f, 0.5f, 1.0f,
   -2.0f, 2.0f, 0.5f, 1.0f,-4.0f, 4.0f, 0.0f, 2.0f,-2.0f, 2.0f,-0.5f, 1.0f,
   -1.0f, 1.0f,-0.5f, 1.0f,-2.0f, 2.0f, 0.0f, 2.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    1.0f, 1.0f, 0.5f, 1.0f, 2.0f, 2.0f, 0.5f, 1.0f, 4.0f, 4.0f, 0.0f, 2.0f,
    2.0f, 2.0f,-0.5f, 1.0f, 1.0f, 1.0f,-0.5f, 1.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f,
};

/*
 * Misc vector op routines.
 */

float x_axis[] = { 1.0f, 0.0f, 0.0f };
float y_axis[] = { 0.0f, 1.0f, 0.0f };
float z_axis[] = { 0.0f, 0.0f, 1.0f };
float nx_axis[] = { -1.0f, 0.0f, 0.0f };
float ny_axis[] = { 0.0f, -1.0f, 0.0f };
float nz_axis[] = { 0.0f, 0.0f, -1.0f };

void norm(float v[3])
{
    float r;

    r = (float)sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );

    v[0] /= r;
    v[1] /= r;
    v[2] /= r;
}

float dot(float a[3], float b[3])
{
    return (a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);
}

void cross(float v1[3], float v2[3], float result[3])
{
    result[0] = v1[1]*v2[2] - v1[2]*v2[1];
    result[1] = v1[2]*v2[0] - v1[0]*v2[2];
    result[2] = v1[0]*v2[1] - v1[1]*v2[0];
}

float length(float v[3])
{
    float r = (float)sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return r;
}

static long winwidth = W, winheight = H;
GLUnurbsObj *nobj;
GLuint surflist, gridlist;

int useglunurbs = 0;
int smooth = 1;
int tracking = 0;
int showgrid = 1;
int showsurf = 1;
int fullscreen = 0;
int multisampling = 0;
float modelmatrix[16];
float scale = 0.5f;
float bias = 0.002f;
int usegments = 4;
int vsegments = 4;

int spindx, spindy;
int startx, starty;
int curx, cury;

void redraw(void);
void createlists(void);

float torusnurbpts[];
float torusbezierpts[];

void reshape_proc(GLsizei w, GLsizei h)
{
    int size;
    
    winwidth = w;
    winheight = h;
    size = (winwidth < winheight ? winwidth : winheight);
    glViewport((winwidth-size)/2, (winheight-size)/2, size, size);
}

void gridmaterials(void)
{
    static float front_mat_diffuse[] = { 1.0f, 1.0f, 0.4f, 1.0f };
    static float front_mat_ambient[] = { 0.1f, 0.1f, 0.1f, 1.0f };
    static float back_mat_diffuse[] = { 1.0f, 0.0f, 0.0f, 1.0f };
    static float back_mat_ambient[] = { 0.1f, 0.1f, 0.1f, 1.0f };

    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_FRONT, GL_AMBIENT, front_mat_ambient);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
    glMaterialfv(GL_BACK, GL_AMBIENT, back_mat_ambient);
}

void surfacematerials(void)
{
    static float front_mat_diffuse[] = { 0.2f, 0.7f, 0.4f, 1.0f };
    static float front_mat_ambient[] = { 0.1f, 0.1f, 0.1f, 1.0f };
    static float back_mat_diffuse[] = { 1.0f, 1.0f, 0.2f, 1.0f };
    static float back_mat_ambient[] = { 0.1f, 0.1f, 0.1f, 1.0f };

    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_FRONT, GL_AMBIENT, front_mat_ambient);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
    glMaterialfv(GL_BACK, GL_AMBIENT, back_mat_ambient);
}

void init(void)
{
    static float ambient[] = { 0.0f, 0.0f, 0.0f, 1.0f };
    static float diffuse[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    static float position[] = { 90.0f, 90.0f, -150.0f, 0.0f };
    static float lmodel_ambient[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    static float lmodel_twoside[] = { (float)GL_TRUE };

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective( 40.0, 1.0, 2.0, 200.0 );
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glGetFloatv(GL_MODELVIEW_MATRIX, modelmatrix);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_AUTO_NORMAL);
#ifdef GL_POLYGON_OFFSET_EXT
    glEnable(GL_POLYGON_OFFSET_EXT);
#endif
    glFrontFace(GL_CCW);

    glEnable( GL_MAP2_VERTEX_4 );
    glClearColor(0.25f, 0.25f, 0.5f, 0.0f);

#ifdef GL_POLYGON_OFFSET_EXT
    glPolygonOffsetEXT( scale, bias );
#endif

    nobj = gluNewNurbsRenderer();
    gluNurbsProperty(nobj, GLU_SAMPLING_METHOD, (float)GLU_DOMAIN_DISTANCE );

    surflist = glGenLists(1);
    gridlist = glGenLists(1);
    createlists();
}

void drawmesh(void)
{
    int i, j;
    float *p;

    int up2p = 4;
    int uorder = 3, vorder = 3;
    int nu = 4, nv = 4;
    int vp2p = up2p * uorder * nu;

    for (j=0; j < nv; j++) {
	for (i=0; i < nu; i++) {
	    p = torusbezierpts + (j * vp2p * vorder) + (i * up2p * uorder);
#ifdef GL_POLYGON_OFFSET_EXT
	    glPolygonOffsetEXT( scale, bias );
#endif
	    glMap2f( GL_MAP2_VERTEX_4, 0.0f, 1.0f, up2p, 3, 0.0f, 1.0f, vp2p, 3,
		     (void*)p );
	    if (showsurf) {
		surfacematerials();
		glEvalMesh2( GL_FILL, 0, usegments, 0, vsegments );
	    }
	    if (showgrid) {
                gridmaterials();
	        glEvalMesh2( GL_LINE, 0, usegments, 0, vsegments );
            }
	}
    }
}

void redraw(void)
{
    static int i=0;
    int dx, dy;
    float v[3], rot[3];
    float len, ang;
    static GLuint vcount;

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    glColor3f( 1.0f, 0.0f, 0.0f);

    if (tracking) {
	dx = curx - startx;
	dy = cury - starty;
    } else {
	dx = spindx;
	dy = spindy;
    }
    if (dx || dy) {
	dy = -dy;
	v[0] = (float)dx;
	v[1] = (float)dy;
	v[2] = 0.0f;

	len = length(v);
	ang = -len / 600 * 360;
	norm( v );
	cross( v, z_axis, rot );

	/*
	** This is certainly not recommended for programs that care
	** about performance or numerical stability: we concatenate
	** the rotation onto the current modelview matrix and read the
	** matrix back, thus saving ourselves from writing our own
	** matrix manipulation routines.
	*/
	glLoadIdentity();
	glRotatef(ang, rot[0], rot[1], rot[2]);
	glMultMatrixf(modelmatrix);
	glGetFloatv(GL_MODELVIEW_MATRIX, modelmatrix);
    }
    glLoadIdentity();
    glTranslatef( 0.0f, 0.0f, -10.0f );
    glMultMatrixf(modelmatrix);

    if (useglunurbs) {
	if (showsurf) glCallList(surflist);
	if (showgrid) glCallList(gridlist);
    } else {
	glMapGrid2f( usegments, 0.0f, 1.0f, vsegments, 0.0f, 1.0f );
	drawmesh();
    }
}

static void OglBounds(int *w, int *h)
{
    *w = W;
    *h = H;
}

static void OglDraw(int w, int h)
{
    init();
    reshape_proc(w, h);
    redraw();
}

/****************************************************************************/

float circleknots[] = { 0.0f, 0.0f, 0.0f, 0.25f, 0.50f, 0.50f, 0.75f, 1.0f,
1.0f, 1.0f };

void createlists(void)
{
    gluNurbsProperty(nobj, GLU_U_STEP, (usegments-1)*4.0f );
    gluNurbsProperty(nobj, GLU_V_STEP, (vsegments-1)*4.0f );

    gluNurbsProperty(nobj, GLU_DISPLAY_MODE, (float)GLU_FILL);
    glNewList(surflist, GL_COMPILE);
    	surfacematerials();
    	gluBeginSurface(nobj);
    	gluNurbsSurface(nobj, 10, circleknots, 10, circleknots,
		    	4, 28, torusnurbpts, 3, 3, GL_MAP2_VERTEX_4);
    	gluEndSurface(nobj);
    glEndList();

    gluNurbsProperty(nobj, GLU_DISPLAY_MODE, (float)GLU_OUTLINE_POLYGON);
    glNewList(gridlist, GL_COMPILE);
    	gridmaterials();
    	gluBeginSurface(nobj);
    	gluNurbsSurface(nobj, 10, circleknots, 10, circleknots,
		    	4, 28, torusnurbpts, 3, 3, GL_MAP2_VERTEX_4);
    	gluEndSurface(nobj);
    glEndList();
}

/****************************************************************************/

/*
 * Control points of the torus in Bezier form.  Can be rendered
 * using OpenGL evaluators.
 */
static GLfloat torusbezierpts[] = {
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 3.0f, 0.0f, 1.0f, 2.0f,
    3.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f, 8.0f, 0.0f, 0.0f, 4.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 3.0f, 0.0f,-1.0f, 2.0f,
    3.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f, 4.0f, 0.0f, 0.0f, 4.0f,
    2.0f,-2.0f, 0.0f, 2.0f, 1.0f,-1.0f, 0.5f, 1.0f, 1.5f,-1.5f, 0.5f, 1.0f,
    1.5f,-1.5f, 0.5f, 1.0f, 2.0f,-2.0f, 0.5f, 1.0f, 4.0f,-4.0f, 0.0f, 2.0f,
    4.0f,-4.0f, 0.0f, 2.0f, 2.0f,-2.0f,-0.5f, 1.0f, 1.5f,-1.5f,-0.5f, 1.0f,
    1.5f,-1.5f,-0.5f, 1.0f, 1.0f,-1.0f,-0.5f, 1.0f, 2.0f,-2.0f, 0.0f, 2.0f,
    0.0f,-2.0f, 0.0f, 2.0f, 0.0f,-1.0f, 0.5f, 1.0f, 0.0f,-1.5f, 0.5f, 1.0f,
    0.0f,-1.5f, 0.5f, 1.0f, 0.0f,-2.0f, 0.5f, 1.0f, 0.0f,-4.0f, 0.0f, 2.0f,
    0.0f,-4.0f, 0.0f, 2.0f, 0.0f,-2.0f,-0.5f, 1.0f, 0.0f,-1.5f,-0.5f, 1.0f,
    0.0f,-1.5f,-0.5f, 1.0f, 0.0f,-1.0f,-0.5f, 1.0f, 0.0f,-2.0f, 0.0f, 2.0f,
    0.0f,-2.0f, 0.0f, 2.0f, 0.0f,-1.0f, 0.5f, 1.0f, 0.0f,-1.5f, 0.5f, 1.0f,
    0.0f,-1.5f, 0.5f, 1.0f, 0.0f,-2.0f, 0.5f, 1.0f, 0.0f,-4.0f, 0.0f, 2.0f,
    0.0f,-4.0f, 0.0f, 2.0f, 0.0f,-2.0f,-0.5f, 1.0f, 0.0f,-1.5f,-0.5f, 1.0f,
    0.0f,-1.5f,-0.5f, 1.0f, 0.0f,-1.0f,-0.5f, 1.0f, 0.0f,-2.0f, 0.0f, 2.0f,
   -2.0f,-2.0f, 0.0f, 2.0f,-1.0f,-1.0f, 0.5f, 1.0f,-1.5f,-1.5f, 0.5f, 1.0f,
   -1.5f,-1.5f, 0.5f, 1.0f,-2.0f,-2.0f, 0.5f, 1.0f,-4.0f,-4.0f, 0.0f, 2.0f,
   -4.0f,-4.0f, 0.0f, 2.0f,-2.0f,-2.0f,-0.5f, 1.0f,-1.5f,-1.5f,-0.5f, 1.0f,
   -1.5f,-1.5f,-0.5f, 1.0f,-1.0f,-1.0f,-0.5f, 1.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-3.0f, 0.0f, 1.0f, 2.0f,
   -3.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,-8.0f, 0.0f, 0.0f, 4.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-3.0f, 0.0f,-1.0f, 2.0f,
   -3.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,-4.0f, 0.0f, 0.0f, 4.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-3.0f, 0.0f, 1.0f, 2.0f,
   -3.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,-8.0f, 0.0f, 0.0f, 4.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-3.0f, 0.0f,-1.0f, 2.0f,
   -3.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,-4.0f, 0.0f, 0.0f, 4.0f,
   -2.0f, 2.0f, 0.0f, 2.0f,-1.0f, 1.0f, 0.5f, 1.0f,-1.5f, 1.5f, 0.5f, 1.0f,
   -1.5f, 1.5f, 0.5f, 1.0f,-2.0f, 2.0f, 0.5f, 1.0f,-4.0f, 4.0f, 0.0f, 2.0f,
   -4.0f, 4.0f, 0.0f, 2.0f,-2.0f, 2.0f,-0.5f, 1.0f,-1.5f, 1.5f,-0.5f, 1.0f,
   -1.5f, 1.5f,-0.5f, 1.0f,-1.0f, 1.0f,-0.5f, 1.0f,-2.0f, 2.0f, 0.0f, 2.0f,
    0.0f, 2.0f, 0.0f, 2.0f, 0.0f, 1.0f, 0.5f, 1.0f, 0.0f, 1.5f, 0.5f, 1.0f,
    0.0f, 1.5f, 0.5f, 1.0f, 0.0f, 2.0f, 0.5f, 1.0f, 0.0f, 4.0f, 0.0f, 2.0f,
    0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f,-0.5f, 1.0f, 0.0f, 1.5f,-0.5f, 1.0f,
    0.0f, 1.5f,-0.5f, 1.0f, 0.0f, 1.0f,-0.5f, 1.0f, 0.0f, 2.0f, 0.0f, 2.0f,
    0.0f, 2.0f, 0.0f, 2.0f, 0.0f, 1.0f, 0.5f, 1.0f, 0.0f, 1.5f, 0.5f, 1.0f,
    0.0f, 1.5f, 0.5f, 1.0f, 0.0f, 2.0f, 0.5f, 1.0f, 0.0f, 4.0f, 0.0f, 2.0f,
    0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f,-0.5f, 1.0f, 0.0f, 1.5f,-0.5f, 1.0f,
    0.0f, 1.5f,-0.5f, 1.0f, 0.0f, 1.0f,-0.5f, 1.0f, 0.0f, 2.0f, 0.0f, 2.0f,
    2.0f, 2.0f, 0.0f, 2.0f, 1.0f, 1.0f, 0.5f, 1.0f, 1.5f, 1.5f, 0.5f, 1.0f,
    1.5f, 1.5f, 0.5f, 1.0f, 2.0f, 2.0f, 0.5f, 1.0f, 4.0f, 4.0f, 0.0f, 2.0f,
    4.0f, 4.0f, 0.0f, 2.0f, 2.0f, 2.0f,-0.5f, 1.0f, 1.5f, 1.5f,-0.5f, 1.0f,
    1.5f, 1.5f,-0.5f, 1.0f, 1.0f, 1.0f,-0.5f, 1.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 3.0f, 0.0f, 1.0f, 2.0f,
    3.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f, 8.0f, 0.0f, 0.0f, 4.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 3.0f, 0.0f,-1.0f, 2.0f,
    3.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f, 4.0f, 0.0f, 0.0f, 4.0f,
};

/*
 * Control points of a torus in NURBS form.  Can be rendered using
 * the GLU NURBS routines.
 */
static GLfloat torusnurbpts[] = {
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f,-2.0f, 0.0f, 2.0f, 1.0f,-1.0f, 0.5f, 1.0f,
    2.0f,-2.0f, 0.5f, 1.0f, 4.0f,-4.0f, 0.0f, 2.0f, 2.0f,-2.0f,-0.5f, 1.0f,
    1.0f,-1.0f,-0.5f, 1.0f, 2.0f,-2.0f, 0.0f, 2.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -1.0f,-1.0f, 0.5f, 1.0f,-2.0f,-2.0f, 0.5f, 1.0f,-4.0f,-4.0f, 0.0f, 2.0f,
   -2.0f,-2.0f,-0.5f, 1.0f,-1.0f,-1.0f,-0.5f, 1.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 2.0f, 0.0f, 2.0f,-1.0f, 1.0f, 0.5f, 1.0f,
   -2.0f, 2.0f, 0.5f, 1.0f,-4.0f, 4.0f, 0.0f, 2.0f,-2.0f, 2.0f,-0.5f, 1.0f,
   -1.0f, 1.0f,-0.5f, 1.0f,-2.0f, 2.0f, 0.0f, 2.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    1.0f, 1.0f, 0.5f, 1.0f, 2.0f, 2.0f, 0.5f, 1.0f, 4.0f, 4.0f, 0.0f, 2.0f,
    2.0f, 2.0f,-0.5f, 1.0f, 1.0f, 1.0f,-0.5f, 1.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f,
};

OglModule oglmod_surfgrid =
{
    "surfgrid",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\teapots.c ===
#include "pch.c"
#pragma hdrstop

/*  Initialize depth buffer, projection matrix, light source, 
 *  and lighting model.  Do not specify a material property here.
 */
static void myinit(void)
{
    GLfloat ambient[] = { 0.0f, 0.0f, 0.0f, 1.0f };
    GLfloat diffuse[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    GLfloat specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    GLfloat position[] = { 0.0f, 3.0f, 3.0f, 0.0f };
    
    GLfloat lmodel_ambient[] = { 0.2f, 0.2f, 0.2f, 1.0f };
    GLfloat local_view[] = { 0.0f };

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

    glFrontFace (GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
}

/*  Move object into position.  Use 3rd through 12th parameters
 *  to specify the material property.  Draw a teapot.
 */
static void renderTeapot (GLfloat x, GLfloat y, 
    GLfloat ambr, GLfloat ambg, GLfloat ambb, 
    GLfloat difr, GLfloat difg, GLfloat difb, 
    GLfloat specr, GLfloat specg, GLfloat specb, GLfloat shine)
{
    float mat[4];

    mat[3] = 1.0f;
    glPushMatrix();
    glTranslatef (x, y, 0.0f);
    mat[0] = ambr; mat[1] = ambg; mat[2] = ambb;	
    glMaterialfv (GL_FRONT, GL_AMBIENT, mat);
    mat[0] = difr; mat[1] = difg; mat[2] = difb;	
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat);
    mat[0] = specr; mat[1] = specg; mat[2] = specb;
    glMaterialfv (GL_FRONT, GL_SPECULAR, mat);
    glMaterialf (GL_FRONT, GL_SHININESS, shine*128.0f);
    auxSolidTeapot(1.0);
    glPopMatrix();
}

/*  First column:  emerald, jade, obsidian, pearl, ruby, turquoise
 *  2nd column:  brass, bronze, chrome, copper, gold, silver
 *  3rd column:  black, cyan, green, red, white, yellow plastic
 *  4th column:  black, cyan, green, red, white, yellow rubber
 */
static void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    printf("1\n");
    renderTeapot (2.0, 17.0, 0.0215, 0.1745, 0.0215, 
	0.07568, 0.61424, 0.07568, 0.633, 0.727811, 0.633, 0.6);
#if 1
    printf("2\n");
    renderTeapot (2.0, 14.0, 0.135, 0.2225, 0.1575,
	0.54, 0.89, 0.63, 0.316228, 0.316228, 0.316228, 0.1);
    printf("3\n");
    renderTeapot (2.0, 11.0, 0.05375, 0.05, 0.06625,
	0.18275, 0.17, 0.22525, 0.332741, 0.328634, 0.346435, 0.3);
    printf("4\n");
    renderTeapot (2.0, 8.0, 0.25, 0.20725, 0.20725,
	1, 0.829, 0.829, 0.296648, 0.296648, 0.296648, 0.088);
    printf("5\n");
    renderTeapot (2.0, 5.0, 0.1745, 0.01175, 0.01175,
	0.61424, 0.04136, 0.04136, 0.727811, 0.626959, 0.626959, 0.6);
    printf("6\n");
    renderTeapot (2.0, 2.0, 0.1, 0.18725, 0.1745,
	0.396, 0.74151, 0.69102, 0.297254, 0.30829, 0.306678, 0.1);
    printf("7\n");
    renderTeapot (6.0, 17.0, 0.329412, 0.223529, 0.027451,
	0.780392, 0.568627, 0.113725, 0.992157, 0.941176, 0.807843,
	0.21794872);
    printf("8\n");
    renderTeapot (6.0, 14.0, 0.2125, 0.1275, 0.054,
	0.714, 0.4284, 0.18144, 0.393548, 0.271906, 0.166721, 0.2);
    printf("9\n");
    renderTeapot (6.0, 11.0, 0.25, 0.25, 0.25, 
	0.4, 0.4, 0.4, 0.774597, 0.774597, 0.774597, 0.6);
    printf("10\n");
    renderTeapot (6.0, 8.0, 0.19125, 0.0735, 0.0225,
	0.7038, 0.27048, 0.0828, 0.256777, 0.137622, 0.086014, 0.1);
    printf("11\n");
    renderTeapot (6.0, 5.0, 0.24725, 0.1995, 0.0745,
	0.75164, 0.60648, 0.22648, 0.628281, 0.555802, 0.366065, 0.4);
    printf("12\n");
    renderTeapot (6.0, 2.0, 0.19225, 0.19225, 0.19225,
	0.50754, 0.50754, 0.50754, 0.508273, 0.508273, 0.508273, 0.4);
    printf("13\n");
    renderTeapot (10.0, 17.0, 0.0, 0.0, 0.0, 0.01, 0.01, 0.01,
	0.50, 0.50, 0.50, .25);
    printf("14\n");
    renderTeapot (10.0, 14.0, 0.0, 0.1, 0.06, 0.0, 0.50980392, 0.50980392,
	0.50196078, 0.50196078, 0.50196078, .25);
    printf("15\n");
    renderTeapot (10.0, 11.0, 0.0, 0.0, 0.0, 
	0.1, 0.35, 0.1, 0.45, 0.55, 0.45, .25);
    printf("16\n");
    renderTeapot (10.0, 8.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0,
	0.7, 0.6, 0.6, .25);
    printf("17\n");
    renderTeapot (10.0, 5.0, 0.0, 0.0, 0.0, 0.55, 0.55, 0.55,
	0.70, 0.70, 0.70, .25);
    printf("18\n");
    renderTeapot (10.0, 2.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0,
	0.60, 0.60, 0.50, .25);
    printf("19\n");
    renderTeapot (14.0, 17.0, 0.02, 0.02, 0.02, 0.01, 0.01, 0.01,
	0.4, 0.4, 0.4, .078125);
    printf("20\n");
    renderTeapot (14.0, 14.0, 0.0, 0.05, 0.05, 0.4, 0.5, 0.5,
	0.04, 0.7, 0.7, .078125);
    printf("21\n");
    renderTeapot (14.0, 11.0, 0.0, 0.05, 0.0, 0.4, 0.5, 0.4,
	0.04, 0.7, 0.04, .078125);
    printf("22\n");
    renderTeapot (14.0, 8.0, 0.05, 0.0, 0.0, 0.5, 0.4, 0.4,
	0.7, 0.04, 0.04, .078125);
    printf("23\n");
    renderTeapot (14.0, 5.0, 0.05, 0.05, 0.05, 0.5, 0.5, 0.5,
	0.7, 0.7, 0.7, .078125);
    printf("24\n");
    renderTeapot (14.0, 2.0, 0.05, 0.05, 0.0, 0.5, 0.5, 0.4, 
	0.7, 0.7, 0.04, .078125);
#endif
    printf("25\n");
    glFlush();
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho (0.0, 16.0, 0.0, 16.0*(GLfloat)h/(GLfloat)w, 
		-10.0, 10.0);
    else
	glOrtho (0.0, 16.0*(GLfloat)w/(GLfloat)h, 0.0, 16.0, 
		-10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

#define WIDTH 517
#define HEIGHT 607

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_teapots =
{
    "teapots",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\stencil.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  stencil.c
 *  This program draws two rotated tori in a window.  
 *  A diamond in the center of the window masks out part 
 *  of the scene.  Within this mask, a different model 
 *  (a sphere) is drawn in a different color.
 */
#include "pch.c"
#pragma hdrstop

#define YELLOWMAT   1
#define BLUEMAT 2

static void myinit (void) 
{
    GLfloat yellow_diffuse[] = { 0.7, 0.7, 0.0, 1.0 };
    GLfloat yellow_specular[] = { 1.0, 1.0, 1.0, 1.0 };

    GLfloat blue_diffuse[] = { 0.1, 0.1, 0.7, 1.0 };
    GLfloat blue_specular[] = { 0.1, 1.0, 1.0, 1.0 };

    GLfloat position_one[] = { 1.0, 1.0, 1.0, 0.0 };

    glNewList(YELLOWMAT, GL_COMPILE);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, yellow_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, yellow_specular);
    glMaterialf(GL_FRONT, GL_SHININESS, 64.0);
    glEndList();

    glNewList(BLUEMAT, GL_COMPILE);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, blue_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, blue_specular);
    glMaterialf(GL_FRONT, GL_SHININESS, 45.0);
    glEndList();

    glLightfv(GL_LIGHT0, GL_POSITION, position_one);

    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHTING);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);

    glClearStencil(0x0);
    glEnable(GL_STENCIL_TEST);

}

/*  Draw a sphere in a diamond-shaped section in the
 *  middle of a window with 2 tori.
 */
static void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

/* draw blue sphere where the stencil is 1 */
    glStencilFunc (GL_EQUAL, 0x1, 0x1);
    glCallList (BLUEMAT);
    auxSolidSphere (0.5);

/* draw the tori where the stencil is not 1 */
    glStencilFunc (GL_NOTEQUAL, 0x1, 0x1);
    glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);
    glPushMatrix();
	glRotatef (45.0, 0.0, 0.0, 1.0);
	glRotatef (45.0, 0.0, 1.0, 0.0);
	glCallList (YELLOWMAT);
	auxSolidTorus (0.275, 0.85);
	glPushMatrix();
	    glRotatef (90.0, 1.0, 0.0, 0.0);
	    auxSolidTorus (0.275, 0.85);
	glPopMatrix();
    glPopMatrix();
    glFlush();

}

/*  Whenever the window is reshaped, redefine the 
 *  coordinate system and redraw the stencil area.
 */
static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);

    glClear(GL_STENCIL_BUFFER_BIT);
/* create a diamond shaped stencil area */
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-3.0, 3.0, -3.0, 3.0, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glStencilFunc (GL_ALWAYS, 0x1, 0x1);
    glStencilOp (GL_REPLACE, GL_REPLACE, GL_REPLACE);
    glBegin(GL_QUADS);
	glVertex3f (-1.0, 0.0, 0.0);
	glVertex3f (0.0, 1.0, 0.0);
	glVertex3f (1.0, 0.0, 0.0);
	glVertex3f (0.0, -1.0, 0.0);
    glEnd();

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, (GLfloat) w/(GLfloat) h, 3.0, 7.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -5.0);
}

static GLenum OglDisplayMode(void)
{
    return AUX_RGB | AUX_DEPTH16 | AUX_STENCIL;
}

static void OglBounds(int *w, int *h)
{
    *w = 400;
    *h = 400;
}

static void OglInit(HDC hdc)
{
    SetHdcPixelFormat(hdc, 0, 0, 16, 4);
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_stencil =
{
    "stencil",
    OglDisplayMode,
    OglBounds,
    OglInit,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\vptitle.c ===
#include "pch.c"
#pragma hdrstop

#include "bfont.h"

static void DrawString(char *str, GLfloat x, GLfloat y)
{
	short	nseg, nstroke;
	short	*cptr;
	int	i, j;

	glPushMatrix();
	glTranslatef (x, y, 0.0F);
	glScalef (10.0F, 10.0F, 1.0F);


	while (*str) {
		cptr = &(chrtbl[*str][0]);
		nseg = *(cptr++);
		for (i = 0; i < nseg; i++) {
			nstroke = *(cptr++);
			glBegin(GL_LINE_STRIP);
			for (j = 0; j < nstroke; j++) {
				glVertex2sv(cptr);
				cptr += 2;
			}
			glEnd();
		}
		glTranslatef (6.0F, 0.0F, 0.0F);
		str++;
	}
	glPopMatrix();
}

static void ViewperfTitle(void)
{
    glClearColor(0.0F, 0.0F, 0.0F, 1.0F);
    glDrawBuffer(GL_FRONT_AND_BACK);
    glClear(GL_COLOR_BUFFER_BIT);
    glDrawBuffer(GL_FRONT);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0.0F, 1280.0F, 0.0F, 1024.0F, 1.0F, -1.0F);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glShadeModel(GL_SMOOTH);

    glBegin(GL_QUADS);
    glColor3f(1.0F, 0.9F, 0.3F);
    glVertex2f(0.0F, 0.0F);
    glColor3f(1.0F, 0.9F, 0.3F);
    glVertex2f(1280.0F, 0.0F);
    glColor3f(0.6F, 0.1F, 0.9F);
    glVertex2f(1280.0F, 1024.0F);
    glColor3f(0.6F, 0.1F, 0.9F);
    glVertex2f(0.0F, 1024.0F);
    glEnd();

    glLineWidth(4.0F);
    glColor3f(0.0F, 0.0F, 0.0F);
    DrawString("     OpenGL     ", 172.0F, 602.0F);
    glLineWidth(3.0F);
    glColor3f(1.0F, 1.0F, 0.0F);
    DrawString("     OpenGL     ", 170.0F, 600.0F);

    glLineWidth(4.0F);
    glColor3f(0.0F, 0.0F, 0.0F);
    DrawString("    Viewperf    ", 172.0F, 477.0F);
    glLineWidth(3.0F);
    glColor3f(0.0F, 1.0F, 0.0F);
    DrawString("    Viewperf    ", 170.0F, 475.0F);

    glLineWidth(4.0F);
    glColor3f(0.0F, 0.0F, 0.0F);
    DrawString("Loading Data Set", 172.0F, 352.0F);
    glLineWidth(3.0F);
    glColor3f(0.0F, 0.7F, 1.0F);
    DrawString("Loading Data Set", 170.0F, 350.0F);
}

static void OglBounds(int *w, int *h)
{
    *w = 700;
    *h = 700;
}

static void OglDraw(int w, int h)
{
    glViewport(0, 0, w, h);
    ViewperfTitle();
}

OglModule oglmod_vptitle =
{
    "vptitle",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\texsurf.c ===
#include "pch.c"
#pragma hdrstop
#include <math.h>

static GLfloat ctrlpoints[4][4][3] = {
    {{ -1.5, -1.5, 4.0}, { -0.5, -1.5, 2.0}, 
	{0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}}, 
    {{ -1.5, -0.5, 1.0}, { -0.5, -0.5, 3.0}, 
	{0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}}, 
    {{ -1.5, 0.5, 4.0}, { -0.5, 0.5, 0.0}, 
	{0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}}, 
    {{ -1.5, 1.5, -2.0}, { -0.5, 1.5, -2.0}, 
	{0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}}
};

static GLfloat texpts[2][2][2] = {{{0.0, 0.0}, {0.0, 1.0}}, 
			{{1.0, 0.0}, {1.0, 1.0}}};

static void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor3f(1.0, 1.0, 1.0);
    glEvalMesh2(GL_FILL, 0, 20, 0, 20);
    glFlush();
}

#define	imageWidth 64
#define	imageHeight 64
GLubyte image[3*imageWidth*imageHeight];

static void makeImage(void)
{
    int i, j;
    float ti, tj;
    
    for (i = 0; i < imageWidth; i++) {
	ti = 2.0*3.14159265*i/imageWidth;
	for (j = 0; j < imageHeight; j++) {
	    tj = 2.0*3.14159265*j/imageHeight;

	    image[3*(imageHeight*i+j)] = (GLubyte) 127*(1.0+sin(ti));
	    image[3*(imageHeight*i+j)+1] = (GLubyte) 127*(1.0+cos(2*tj));
	    image[3*(imageHeight*i+j)+2] = (GLubyte) 127*(1.0+cos(ti+tj));
	}
    }
}

static void myinit(void)
{
    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
	    0, 1, 12, 4, &ctrlpoints[0][0][0]);
    glMap2f(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2, 
	    0, 1, 4, 2, &texpts[0][0][0]);
    glEnable(GL_MAP2_TEXTURE_COORD_2);
    glEnable(GL_MAP2_VERTEX_3);
    glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
    makeImage();
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, imageWidth, imageHeight, 0,
		 GL_RGB, GL_UNSIGNED_BYTE, image);
    glEnable(GL_TEXTURE_2D);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_NORMALIZE);
    glShadeModel (GL_FLAT);
}

static void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho(-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w, 
	    4.0*(GLfloat)h/(GLfloat)w, -4.0, 4.0);
    else
	glOrtho(-4.0*(GLfloat)w/(GLfloat)h, 
	    4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -4.0, 4.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glRotatef(85.0, 1.0, 1.0, 1.0);
}

#define WIDTH 300
#define HEIGHT 300

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    myinit();
    myReshape(w, h);
    display();
}

OglModule oglmod_texsurf =
{
    "texsurf",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\varray.c ===
#include "pch.c"
#pragma hdrstop

#define WIDTH 256
#define HEIGHT 256

#define VERTICES 13

PFNGLDRAWRANGEELEMENTSWINPROC pfnDrawRangeElementsWIN;

static GLboolean edge_flags[VERTICES] =
{
    GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE,
    GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE,
    GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE,
    GL_TRUE
};
static GLfloat tex_coords[VERTICES][2] =
{
    0.0f, 0.0f,
    0.0f, 1.0f,
    1.0f, 1.0f,
    1.0f, 0.0f,
    0.0f, 0.0f,
    0.0f, 1.0f,
    1.0f, 1.0f,
    1.0f, 0.0f,
    0.0f, 0.0f,
    0.0f, 1.0f,
    1.0f, 1.0f,
    1.0f, 0.0f,
    1.0f, 0.0f
};
static GLfloat color_vals[VERTICES][3] =
{
    1.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 1.0f
};
static GLint vertex_vals[VERTICES][2] =
{
    0, 0,
    0, HEIGHT,
    WIDTH/2, HEIGHT,
    WIDTH/2, 0,
    WIDTH/4, HEIGHT/2,
    3*WIDTH/8, 0,
    WIDTH/8, 0,
    0, HEIGHT/4,
    0, 3*HEIGHT/4,
    WIDTH/8, HEIGHT,
    3*WIDTH/8, HEIGHT,
    WIDTH/2, HEIGHT/4,
    WIDTH/2, 3*HEIGHT/4
};
#define INDICES 12
static GLint indices[INDICES] =
{
    4, 5, 6,
    4, 7, 8,
    4, 9, 10,
    4, 11, 12
};

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void OglDraw(int w, int h)
{
    glLoadIdentity();
    glViewport(0, 0, w, h);
    glClear (GL_COLOR_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, WIDTH, 0, HEIGHT, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    
    glEdgeFlagPointer(0, edge_flags);
    glTexCoordPointer(2, GL_FLOAT, 0, tex_coords);
    glColorPointer(3, GL_FLOAT, 0, color_vals);
    glVertexPointer(2, GL_INT, 0, vertex_vals);
    glEnableClientState(GL_EDGE_FLAG_ARRAY);
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);
    glEnableClientState(GL_VERTEX_ARRAY);
    
    glEnableClientState(GL_NORMAL_ARRAY);
    glDisableClientState(GL_NORMAL_ARRAY);

    glArrayElement(1);

    glDrawArrays(GL_POLYGON, 0, 4);

    glTranslated(WIDTH/2, 0, 0);

    glDisableClientState(GL_COLOR_ARRAY);
    glDrawElements(GL_TRIANGLES, INDICES, GL_UNSIGNED_INT, indices);

    // Test DrawRangeElements WIN extension

    pfnDrawRangeElementsWIN = (PFNGLDRAWRANGEELEMENTSWINPROC)
        wglGetProcAddress("glDrawRangeElementsWIN");
    if( !pfnDrawRangeElementsWIN )
        return;

    {
        int iMaxVertices, iMaxIndices;

        glGetIntegerv( GL_MAX_ELEMENTS_VERTICES_WIN, &iMaxVertices );
        glGetIntegerv( GL_MAX_ELEMENTS_INDICES_WIN, &iMaxIndices );

        if( ((INDICES-4+1) > iMaxVertices) || (INDICES > iMaxIndices) )
            // Extension can't handle index range or number of indices
            return;

        glTranslated(WIDTH/8, HEIGHT/4, 0);
        glScaled( 0.5, 0.5, 0.5 );
        glEnableClientState(GL_COLOR_ARRAY);

        pfnDrawRangeElementsWIN(GL_TRIANGLES, 4, INDICES, INDICES, GL_UNSIGNED_INT, indices);
    }
}

OglModule oglmod_varray =
{
    "varray",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\mfgls\texpal.c ===
#include "pch.c"
#pragma hdrstop

#define WIDTH 256
#define HEIGHT 256

static PFNGLCOLORTABLEEXTPROC pfnColorTableEXT;
static PFNGLCOLORSUBTABLEEXTPROC pfnColorSubTableEXT;
static PFNGLGETCOLORTABLEEXTPROC pfnGetColorTableEXT;
static PFNGLGETCOLORTABLEPARAMETERIVEXTPROC pfnGetColorTableParameterivEXT;
static PFNGLGETCOLORTABLEPARAMETERFVEXTPROC pfnGetColorTableParameterfvEXT;

static BYTE wave_data[WIDTH];
static RGBQUAD wave_pal[256];

static void OglBounds(int *w, int *h)
{
    *w = WIDTH;
    *h = HEIGHT;
}

static void WaveTex(void)
{
    int i;
    BYTE *data;
    int width;

    width = WIDTH;
    data = wave_data;
    for (i = 0; i < width; i++)
    {
        *data++ = (BYTE)(i*255/(width-1));
    }
    for (i = 0; i < 256; i++)
    {
        wave_pal[i].rgbRed = i;
        wave_pal[i].rgbGreen = i;
        wave_pal[i].rgbBlue = i;
        wave_pal[i].rgbReserved = 255;
    }
}

static void OglDraw(int w, int h)
{
    int iv[6];
    float fv[6];
    int i;
    
    pfnColorTableEXT = (PFNGLCOLORTABLEEXTPROC)
        wglGetProcAddress("glColorTableEXT");
    if (pfnColorTableEXT == NULL)
    {
        printf("Unable to get glColorTableEXT\n");
        exit(1);
    }
    pfnColorSubTableEXT = (PFNGLCOLORSUBTABLEEXTPROC)
        wglGetProcAddress("glColorSubTableEXT");
    if (pfnColorSubTableEXT == NULL)
    {
        printf("Unable to get glColorSubTableEXT\n");
        exit(1);
    }
    pfnGetColorTableEXT = (PFNGLGETCOLORTABLEEXTPROC)
        wglGetProcAddress("glGetColorTableEXT");
    if (pfnGetColorTableEXT == NULL)
    {
        printf("Unable to get glGetColorTableEXT\n");
        exit(1);
    }
    pfnGetColorTableParameterivEXT = (PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)
        wglGetProcAddress("glGetColorTableParameterivEXT");
    if (pfnGetColorTableParameterivEXT == NULL)
    {
        printf("Unable to get glGetColorTableParameterivEXT\n");
        exit(1);
    }
    pfnGetColorTableParameterfvEXT = (PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)
        wglGetProcAddress("glGetColorTableParameterfvEXT");
    if (pfnGetColorTableParameterfvEXT == NULL)
    {
        printf("Unable to get glGetColorTableParameterfvEXT\n");
        exit(1);
    }
    
    WaveTex();
    
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, WIDTH, 0, HEIGHT, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    
    glTexImage2D(GL_TEXTURE_2D, 0, GL_COLOR_INDEX8_EXT, WIDTH, 1, 0,
                 GL_COLOR_INDEX, GL_UNSIGNED_BYTE, wave_data);
    
    pfnColorTableEXT(GL_TEXTURE_2D, GL_RGB, 256, GL_BGRA_EXT,
                     GL_UNSIGNED_BYTE, wave_pal);
    
    pfnGetColorTableParameterivEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_FORMAT_EXT,
                                &iv[0]);
    pfnGetColorTableParameterivEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_WIDTH_EXT,
                                &iv[1]);
    pfnGetColorTableParameterivEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_RED_SIZE_EXT,
                                &iv[2]);
    pfnGetColorTableParameterivEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_GREEN_SIZE_EXT,
                                &iv[3]);
    pfnGetColorTableParameterivEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_BLUE_SIZE_EXT,
                                &iv[4]);
    pfnGetColorTableParameterivEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_ALPHA_SIZE_EXT,
                                &iv[5]);
    printf("Format %d, width %d, %d:%d:%d:%d\n", iv[0], iv[1],
           iv[2], iv[3], iv[4], iv[5]);
    
    pfnGetColorTableParameterfvEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_FORMAT_EXT,
                                &fv[0]);
    pfnGetColorTableParameterfvEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_WIDTH_EXT,
                                &fv[1]);
    pfnGetColorTableParameterfvEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_RED_SIZE_EXT,
                                &fv[2]);
    pfnGetColorTableParameterfvEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_GREEN_SIZE_EXT,
                                &fv[3]);
    pfnGetColorTableParameterfvEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_BLUE_SIZE_EXT,
                                &fv[4]);
    pfnGetColorTableParameterfvEXT(GL_TEXTURE_2D, GL_COLOR_TABLE_ALPHA_SIZE_EXT,
                                &fv[5]);
    printf("Format %.1lf, width %.1lf, %.1lf:%.1lf:%.1lf:%.1lf\n",
           fv[0], fv[1],
           fv[2], fv[3], fv[4], fv[5]);
    
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    
    glEnable(GL_TEXTURE_2D);
    
    glBegin(GL_POLYGON);
    glTexCoord2f(0.0f, 0.0f);
    glVertex2i(0, 0);
    glTexCoord2f(0.0f, 1.0f);
    glVertex2i(0, HEIGHT);
    glTexCoord2f(1.0f, 1.0f);
    glVertex2i(WIDTH/2, HEIGHT);
    glTexCoord2f(1.0f, 0.0f);
    glVertex2i(WIDTH/2, 0);
    glEnd();

    for (i = 64; i < 192; i++)
    {
        wave_pal[i].rgbRed = 0;
    }
    pfnColorSubTableEXT(GL_TEXTURE_2D, 64, 128, GL_BGRA_EXT,
                        GL_UNSIGNED_BYTE, wave_pal+64);
    
    glBegin(GL_POLYGON);
    glTexCoord2f(0.0f, 0.0f);
    glVertex2i(WIDTH/2, 0);
    glTexCoord2f(0.0f, 1.0f);
    glVertex2i(WIDTH/2, HEIGHT);
    glTexCoord2f(1.0f, 1.0f);
    glVertex2i(WIDTH, HEIGHT);
    glTexCoord2f(1.0f, 0.0f);
    glVertex2i(WIDTH, 0);
    glEnd();

    memset(wave_pal, 0, sizeof(wave_pal));
    pfnGetColorTableEXT(GL_TEXTURE_2D, GL_BGRA_EXT, GL_UNSIGNED_BYTE,
                        wave_pal);
    for (i = 60; i < 68; i++)
    {
        printf("%d: %02X:%02X:%02X:%02X\n",
               i, wave_pal[i].rgbRed, wave_pal[i].rgbGreen,
               wave_pal[i].rgbBlue, wave_pal[i].rgbReserved);
    }
    for (i = 188; i < 196; i++)
    {
        printf("%d: %02X:%02X:%02X:%02X\n",
               i, wave_pal[i].rgbRed, wave_pal[i].rgbGreen,
               wave_pal[i].rgbBlue, wave_pal[i].rgbReserved);
    }
}

OglModule oglmod_texpal =
{
    "texpal",
    NULL,
    OglBounds,
    NULL,
    OglDraw
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\pix\pch.c ===
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>
#include <gl\glut.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\pix\pix.c ===
#include "pch.c"
#pragma hdrstop

int winwidth = 640;
int winheight = 480;

int niter = 20;

int data_width = 100;
int data_height = 100;
int rgb_x, bgr_x, bgra_x;
int copy_src_x, copy_dst_x;

BOOL copy_back = FALSE;
BOOL double_buffer = FALSE;
BOOL depth24 = FALSE;
BOOL get_char = FALSE;

BOOL test_draw = TRUE, test_read = TRUE, test_copy = TRUE;
BOOL test_gdi = TRUE, test_gl = TRUE;
BOOL test_depth = TRUE;

HDC data3_hdc, data4_hdc;
HBITMAP data3_hbm, data4_hbm;

void *data3, *data3_read, *data4, *data4_read, *depth;

void PrepareData(void)
{
    HDC hdc;
    HBITMAP hbm;
    BITMAPINFO *pbmi;
    BITMAPINFOHEADER *pbmih;
    void *pv;
    HPEN hpen;
    int i, aw;

    pbmi = (BITMAPINFO *)calloc(1, sizeof(BITMAPINFO)+2*sizeof(DWORD));
    if (pbmi == NULL)
    {
        printf("malloc failed\n");
        exit(1);
    }
    pbmih = &pbmi->bmiHeader;
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth = data_width;
    pbmih->biHeight = data_height;
    pbmih->biPlanes = 1;
    pbmih->biBitCount = 24;
    pbmih->biCompression = BI_RGB;
    
    hdc = CreateCompatibleDC(NULL);
    if (hdc == NULL)
    {
        printf("CreateCompatibleDC failed, %d\n",
               GetLastError());
        exit(1);
    }
    hbm = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS,
                           &pv, NULL, 0);
    if (hbm == NULL)
    {
        printf("CreateDibSection failed, %d\n",
               GetLastError());
        exit(1);
    }

    data3 = pv;

    aw = (data_width*3+3) & ~3;
    data3_read = malloc(aw*data_height);
    if (data3_read == NULL)
    {
        printf("Unable to allocate data3_read\n");
        exit(1);
    }
    
    if (SelectObject(hdc, hbm) == NULL)
    {
        printf("SelectObject failed, %d\n",
               GetLastError());
        exit(1);
    }

    for (i = 0; i < data_height; i++)
    {
        hpen = CreatePen(PS_SOLID, 0,
                         RGB(i*256/data_height, 128,
                             (data_height-i-1)*256/data_height));
        if (hpen == NULL)
        {
            printf("Unable to create pen, %d\n",
                   GetLastError());
            exit(1);
        }
            
        SelectObject(hdc, hpen);
        MoveToEx(hdc, 0, i, NULL);
        LineTo(hdc, data_width, i);

        SelectObject(hdc, GetStockObject(BLACK_PEN));
        DeleteObject(hpen);
    }

    data3_hdc = hdc;
    data3_hbm = hbm;
    
    pbmi = (BITMAPINFO *)calloc(1, sizeof(BITMAPINFO)+2*sizeof(DWORD));
    if (pbmi == NULL)
    {
        printf("malloc failed\n");
        exit(1);
    }
    pbmih = &pbmi->bmiHeader;
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth = data_width;
    pbmih->biHeight = data_height;
    pbmih->biPlanes = 1;
    pbmih->biBitCount = 32;
    pbmih->biCompression = BI_BITFIELDS;
    *((DWORD *)pbmi->bmiColors+0) = 0xff0000;
    *((DWORD *)pbmi->bmiColors+1) = 0xff00;
    *((DWORD *)pbmi->bmiColors+2) = 0xff;
    
    hdc = CreateCompatibleDC(NULL);
    if (hdc == NULL)
    {
        printf("CreateCompatibleDC failed, %d\n",
               GetLastError());
        exit(1);
    }
    hbm = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS,
                           &pv, NULL, 0);
    if (hbm == NULL)
    {
        printf("CreateDibSection failed, %d\n",
               GetLastError());
        exit(1);
    }

    data4 = pv;

    aw = (data_width*4+3) & ~3;
    data4_read = malloc(aw*data_height);
    if (data4_read == NULL)
    {
        printf("Unable to allocate data4_read\n");
        exit(1);
    }
    
    if (SelectObject(hdc, hbm) == NULL)
    {
        printf("SelectObject failed, %d\n",
               GetLastError());
        exit(1);
    }

    for (i = 0; i < data_height; i++)
    {
        hpen = CreatePen(PS_SOLID, 0,
                         RGB(i*256/data_height, 128,
                             (data_height-i-1)*256/data_height));
        if (hpen == NULL)
        {
            printf("Unable to create pen, %d\n",
                   GetLastError());
            exit(1);
        }
            
        SelectObject(hdc, hpen);
        MoveToEx(hdc, 0, i, NULL);
        LineTo(hdc, data_width, i);

        SelectObject(hdc, GetStockObject(BLACK_PEN));
        DeleteObject(hpen);
    }

    data4_hdc = hdc;
    data4_hbm = hbm;
    
    depth = calloc(1, data_width*data_height*sizeof(DWORD));
    if (depth == NULL)
    {
        printf("Unable to allocate depth\n");
        exit(1);
    }
}

void GlDrawRgb(int x, int y)
{
    glRasterPos2i(rgb_x+x, y);
    glDrawPixels(data_width, data_height, GL_RGB, GL_UNSIGNED_BYTE,
                 data3);
}

void GlDrawBgr(int x, int y)
{
    glRasterPos2i(bgr_x+x, y);
    glDrawPixels(data_width, data_height, GL_BGR_EXT, GL_UNSIGNED_BYTE,
                 data3);
}

void GlDrawBgra(int x, int y)
{
    glRasterPos2i(bgra_x+x, y);
    glDrawPixels(data_width, data_height, GL_BGRA_EXT, GL_UNSIGNED_BYTE,
                 data4);
}

void GlDrawDepth(int x, int y)
{
    glRasterPos2i(x, y);
    glDrawPixels(data_width, data_height, GL_DEPTH_COMPONENT,
                 GL_UNSIGNED_SHORT, depth);
    glDrawPixels(data_width, data_height, GL_DEPTH_COMPONENT,
                 GL_UNSIGNED_INT, depth);
}

void GdiDrawBgr(int x, int y)
{
    BitBlt(auxGetHDC(), bgr_x+x, y, data_width, data_height,
           data3_hdc, 0, 0, SRCCOPY);
}

void GdiDrawBgra(int x, int y)
{
    BitBlt(auxGetHDC(), bgra_x+x, y, data_width, data_height,
           data4_hdc, 0, 0, SRCCOPY);
}

#define COPYBACK

void GlReadRgb(int x, int y)
{
    glReadPixels(rgb_x+x, y, data_width, data_height, GL_RGB, GL_UNSIGNED_BYTE,
                 data3_read);
    if (copy_back)
    {
        glRasterPos2i(rgb_x+x, y+data_height+niter+5);
        glDrawPixels(data_width, data_height, GL_RGB, GL_UNSIGNED_BYTE,
                     data3_read);
    }
}

void GlReadBgr(int x, int y)
{
    glReadPixels(bgr_x+x, y, data_width, data_height, GL_BGR_EXT,
                 GL_UNSIGNED_BYTE, data3_read);
    if (copy_back)
    {
        glRasterPos2i(bgr_x+x, y+data_height+niter+5);
        glDrawPixels(data_width, data_height, GL_BGR_EXT, GL_UNSIGNED_BYTE,
                     data3_read);
    }
}

void GlReadBgra(int x, int y)
{
    glReadPixels(bgra_x+x, y, data_width, data_height, GL_BGRA_EXT,
                 GL_UNSIGNED_BYTE, data4_read);
    if (copy_back)
    {
        glRasterPos2i(bgra_x+x, y+data_height+niter+5);
        glDrawPixels(data_width, data_height, GL_BGRA_EXT, GL_UNSIGNED_BYTE,
                     data4_read);
    }
}

void GlReadDepth(int x, int y)
{
    glReadPixels(x, y, data_width, data_height, GL_DEPTH_COMPONENT,
                 GL_UNSIGNED_SHORT, depth);
    glReadPixels(x, y, data_width, data_height, GL_DEPTH_COMPONENT,
                 GL_UNSIGNED_INT, depth);
}

void GdiReadBgr(int x, int y)
{
    BitBlt(data3_hdc, 0, 0, data_width, data_height,
           auxGetHDC(), bgr_x+x, y, SRCCOPY);
}

void GdiReadBgra(int x, int y)
{
    BitBlt(data4_hdc, 0, 0, data_width, data_height,
           auxGetHDC(), bgra_x+x, y, SRCCOPY);
}

void GlCopy(int x, int y)
{
    glRasterPos2i(copy_dst_x+x, y);
    glCopyPixels(copy_src_x+x, y, data_width, data_height, GL_COLOR);
}

void GlCopyDepth(int x, int y)
{
    glRasterPos2i(copy_dst_x+x, y);
    glCopyPixels(copy_src_x+x, y, data_width, data_height, GL_DEPTH);
}

void GdiCopy(int x, int y)
{
    BitBlt(auxGetHDC(), copy_dst_x+x, y, data_width, data_height,
           auxGetHDC(), copy_src_x+x, y, SRCCOPY);
}
    
typedef void (*DrawFn)(int x, int y);

void Test(char *name, DrawFn draw_fn)
{
    int iter;
    DWORD ms;

    ms = GetTickCount();
    for (iter = 0; iter < niter; iter++)
    {
        draw_fn(iter, iter);
    }
    GdiFlush();
    glFlush();
    ms = GetTickCount()-ms;

    if (double_buffer)
    {
        auxSwapBuffers();
    }
    
    printf("%s: %d iterations in %d ms\n", name, niter, ms);
    
    if (get_char)
    {
        getchar();
    }
}

void Redraw(void)
{
    glDisable(GL_DITHER);

    if (test_draw)
    {
        if (test_gdi)
        {
            Test("GdiDrawBgr", GdiDrawBgr);
            Test("GdiDrawBgra", GdiDrawBgra);
        }
        if (test_gl)
        {
            Test("GlDrawRgb", GlDrawRgb);
            Test("GlDrawBgr", GlDrawBgr);
            Test("GlDrawBgra", GlDrawBgra);
        }
    }

    if (test_read)
    {
        if (test_gdi)
        {
            Test("GdiReadBgr", GdiReadBgr);
            Test("GdiReadBgra", GdiReadBgra);
        }
        if (test_gl)
        {
            Test("GlReadRgb", GlReadRgb);
            Test("GlReadBgr", GlReadBgr);
            Test("GlReadBgra", GlReadBgra);
        }
    }

    if (test_copy)
    {
        if (test_gdi)
        {
            Test("GdiCopy", GdiCopy);
        }
        if (test_gl)
        {
            Test("GlCopy", GlCopy);
        }
    }

    if (test_depth && test_gl)
    {
        glDrawBuffer(GL_NONE);
        glDepthFunc(GL_ALWAYS);
        glEnable(GL_DEPTH_TEST);

        if (test_draw)
        {
            Test("GlDrawDepth", GlDrawDepth);
        }
        if (test_read)
        {
            Test("GlReadDepth", GlReadDepth);
        }
        if (test_copy)
        {
            Test("GlCopyDepth", GlCopyDepth);
        }
    }
}

void __cdecl main(int argc, char **argv)
{
    while (--argc > 0)
    {
        argv++;

        if (!strncmp(*argv, "-iter", 5))
        {
            sscanf(*argv+5, "%d", &niter);
        }
        else if (!strncmp(*argv, "-wd", 3))
        {
            sscanf(*argv+3, "%d", &data_width);
        }
        else if (!strncmp(*argv, "-ht", 3))
        {
            sscanf(*argv+3, "%d", &data_height);
        }
        else if (!strncmp(*argv, "-wwd", 4))
        {
            sscanf(*argv+4, "%d", &winwidth);
        }
        else if (!strncmp(*argv, "-wht", 4))
        {
            sscanf(*argv+4, "%d", &winheight);
        }
        else if (!strcmp(*argv, "-db"))
        {
            double_buffer = TRUE;
        }
        else if (!strcmp(*argv, "-d24"))
        {
            depth24 = TRUE;
        }
        else if (!strcmp(*argv, "-cb"))
        {
            copy_back = TRUE;
        }
        else if (!strcmp(*argv, "-gc"))
        {
            get_char = TRUE;
        }
        else if (!strncmp(*argv, "-draw", 5))
        {
            test_draw = *(*argv+5) == '+';
        }
        else if (!strncmp(*argv, "-read", 5))
        {
            test_read = *(*argv+5) == '+';
        }
        else if (!strncmp(*argv, "-copy", 5))
        {
            test_copy = *(*argv+5) == '+';
        }
        else if (!strncmp(*argv, "-gdi", 4))
        {
            test_gdi = *(*argv+4) == '+';
        }
        else if (!strncmp(*argv, "-gl", 3))
        {
            test_gl = *(*argv+3) == '+';
        }
        else if (!strncmp(*argv, "-depth", 6))
        {
            test_depth = *(*argv+6) == '+';
        }
    }
    
    rgb_x = 0;
    bgr_x = rgb_x+data_width+niter+5;
    bgra_x = bgr_x+data_width+niter+5;
    copy_src_x = bgr_x;
    copy_dst_x = bgra_x+data_width+niter+5;
    
    PrepareData();
    
    auxInitPosition(20, 20, winwidth, winheight);
    auxInitDisplayMode(AUX_RGB |
                       (double_buffer ? AUX_DOUBLE : AUX_SINGLE) |
                       (depth24 ? AUX_DEPTH24 : AUX_DEPTH16));
    auxInitWindow("Pixel Performance");
    
    auxMainLoop(Redraw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\sharel\pch.c ===
#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\timecube\fastdib.h ===
/******************************Module*Header*******************************\
* Module Name: fastdib.h
*
* CreateCompatibleDIB definitions.
*
* Created: 02-Feb-1996 19:30:45
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _FASTDIB_H_
#define _FASTDIB_H_

HBITMAP APIENTRY CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight, PVOID *ppvBits);
BOOL APIENTRY UpdateDIBColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal);
BOOL APIENTRY GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride);
BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector);

#endif //_FASTDIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\d2hex.c ===
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int __cdecl main(int argc, char **argv)
{
    unsigned long *pul;
    double f;

    if (argc <= 1)
        printf("usage: f2hex [float number] ==> output is hex\n");
    else
    {
        f = strtod(argv[1], 0);
        pul = (unsigned long *) &f;

        printf("%f = 0x%08lx %08lx", f, pul[1], pul[0]);
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\sharel\sharel.c ===
#include "pch.c"
#pragma hdrstop

#define WINWIDTH 512
#define WINHEIGHT 512

#define MAXLISTS 6
#define MAXTHREADS 3
#define EXTRA_RC 2
#define MAXRC (MAXTHREADS+EXTRA_RC)
#define THREAD_RC 1
#define DRAW_RC 0
// #define COPY_RC (NRC-2)

#define THREAD_LIST_DELAY 250
#define THREAD_STEP_DELAY 100
#define THREAD_PAUSE_DELAY 1000

char *wndclass = "GlUtest";
char *wndtitle = "OpenGL Unit Test";

HINSTANCE hinstance;
HWND main_wnd;
HGLRC wnd_hrc[MAXRC];
HPALETTE wnd_hpal;
GLint lists[MAXLISTS];
double xr = 0, yr = 0, zr = 0;
UINT timer = 0;
BOOL terminating = FALSE;
HANDLE thread_sem = NULL;
HBITMAP hbm;
HDC hdcBitmap;

int nLists = MAXLISTS, nThreads = MAXTHREADS;
int nThreadLists = MAXLISTS/MAXTHREADS;
int nContexts = MAXRC;
int iBitmapWidth = WINWIDTH, iBitmapHeight = WINHEIGHT;
#if 1
BOOL fBitmap = FALSE;
#else
BOOL fBitmap = TRUE;
#endif
BOOL fDefineMain;
BOOL fShowLists = FALSE;
BOOL fOffsetDrawing = FALSE;
BOOL fRotate = TRUE;
BOOL fCenterMark = FALSE;
BOOL fWinOnly = FALSE;
BOOL fOtherWin = FALSE;

void SetHdcPixelFormat(HDC hdc)
{
    int fmt;
    PIXELFORMATDESCRIPTOR pfd;

    pfd.nSize = sizeof(pfd);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_SUPPORT_OPENGL;
    if (fBitmap)
    {
        pfd.dwFlags |= PFD_DRAW_TO_BITMAP;
    }
    else
    {
        pfd.dwFlags |= PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER;
    }
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 24;
    pfd.cAlphaBits = 0;
    pfd.cAccumBits = 0;
    pfd.cDepthBits = 16;
    pfd.cStencilBits = 0;
    pfd.cAuxBuffers = 0;
    pfd.iLayerType = PFD_MAIN_PLANE;
    
    fmt = ChoosePixelFormat(hdc, &pfd);
    if (fmt == 0)
    {
        printf("SetHdcPixelFormat: ChoosePixelFormat failed, %d\n",
               GetLastError());
        exit(1);
    }

    if (!SetPixelFormat(hdc, fmt, &pfd))
    {
        printf("SetHdcPixelFormat: SetPixelFormat failed, %d\n",
               GetLastError());
        exit(1);
    }

    DescribePixelFormat(hdc, fmt, sizeof(pfd), &pfd);
    printf("Chose pixel format %d, dwFlags = 0x%08lX\n",
           fmt, pfd.dwFlags);
}

HGLRC CreateRc(HDC hdc)
{
    HGLRC hrc;
    
    hrc = wglCreateContext(hdc);
    if (hrc == NULL)
    {
        printf("CreateRc: wglCreateContext failed, %d\n", GetLastError());
        exit(1);
    }
    
    return hrc;
}

/*
  Routines to create an appropriate RGB palette if needed for the given
  device context.

  Taken from the 3D Flying Objects screen saver
  */
static unsigned char three_bit_intensities[8] =
{
    0, 0111 >> 1, 0222 >> 1, 0333 >> 1, 0444 >> 1, 0555 >> 1, 0666 >> 1, 0377
};

static unsigned char two_bit_intensities[4] =
{
    0, 0x55, 0xaa, 0xff
};

static unsigned char one_bit_intensities[2] =
{
    0, 255
};

static unsigned char
ComponentFromIndex(int i, int nbits, int shift)
{
    unsigned char val;

    val = i >> shift;
    
    switch (nbits)
    {
    case 1:
        return one_bit_intensities[val & 1];

    case 2:
        return two_bit_intensities[val & 3];

    case 3:
        return three_bit_intensities[val & 7];

    default:
        return 0;
    }
}

static BOOL system_palette_changed = FALSE;
static UINT old_system_palette_use;

HPALETTE CreateRgbPalette(HDC hdc, HDC hdcWin)
{
    PIXELFORMATDESCRIPTOR pfd;
    LOGPALETTE *pal;
    int fmt, i, n;
    HPALETTE hpal;

    fmt = GetPixelFormat(hdc);
    if (DescribePixelFormat(hdc, fmt,
                            sizeof(PIXELFORMATDESCRIPTOR), &pfd) == 0)
    {
        printf("CreateRgbPalette: DescribePixelFormat failed, %d\n",
               GetLastError());
        return NULL;
    }

    hpal = NULL;
    
    if (pfd.dwFlags & PFD_NEED_PALETTE)
    {
        n = 1 << pfd.cColorBits;
        pal = (PLOGPALETTE)malloc(sizeof(LOGPALETTE) +
                                  (n-1) * sizeof(PALETTEENTRY));
        if (pal == NULL)
        {
            printf("CreateRgbPalette: Unable to allocate LOGPALETTE\n");
            return NULL;
        }
        
        pal->palVersion = 0x300;
        pal->palNumEntries = n;
        for (i = 0; i < n; i++)
        {
            pal->palPalEntry[i].peRed =
                ComponentFromIndex(i, pfd.cRedBits, pfd.cRedShift);
            pal->palPalEntry[i].peGreen =
                ComponentFromIndex(i, pfd.cGreenBits, pfd.cGreenShift);
            pal->palPalEntry[i].peBlue =
                ComponentFromIndex(i, pfd.cBlueBits, pfd.cBlueShift);
            pal->palPalEntry[i].peFlags = ((n == 256) && (i == 0 || i == 255))
                ? 0 : PC_NOCOLLAPSE;
        }

        hpal = CreatePalette(pal);
        free(pal);

        if (hpal == NULL)
        {
            printf("CreateRgbPalette: CreatePalette failed, %d\n",
                   GetLastError());
            return hpal;
        }

        if (n == 256)
        {
            system_palette_changed = TRUE;
            old_system_palette_use = SetSystemPaletteUse(hdcWin,
                                                         SYSPAL_NOSTATIC);
        }
    }

    return hpal;
}

void FreeRgbPalette(HPALETTE hpal, HDC hdcWin)
{
    if (system_palette_changed)
    {
        SetSystemPaletteUse(hdcWin, old_system_palette_use);
        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);
    }

    SelectPalette(hdcWin, GetStockObject(DEFAULT_PALETTE), FALSE);
    RealizePalette(hdcWin);
    
    DeleteObject(hpal);
}

void SetOnce(void)
{
    int iv4[4];

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45, 1, .01, 10);
    gluLookAt(0, 0, -3, 0, 0, 0, 0, 1, 0);
    glMatrixMode(GL_MODELVIEW);

    glEnable(GL_CULL_FACE);

    glGetIntegerv(GL_VIEWPORT, iv4);
    printf("Viewport %d,%d - %d,%d\n", iv4[0], iv4[1], iv4[2], iv4[3]);
}

void CreateLists0(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* XZ zero plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 0, 0);
    glVertex3d(0, 0, 0);
    glColor3d(1, 0, 0);
    glVertex3d(1, 0, 0);
    glColor3d(1, 0, 1);
    glVertex3d(1, 0, 1);
    glColor3d(0, 0, 1);
    glVertex3d(0, 0, 1);
    glEnd();

    glEndList();
}

void CreateLists1(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* XY zero plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 0, 0);
    glVertex3d(0, 0, 0);
    glColor3d(0, 1, 0);
    glVertex3d(0, 1, 0);
    glColor3d(1, 1, 0);
    glVertex3d(1, 1, 0);
    glColor3d(1, 0, 0);
    glVertex3d(1, 0, 0);
    glEnd();

    glEndList();
}

void CreateLists2(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* YZ zero plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 0, 0);
    glVertex3d(0, 0, 0);
    glColor3d(0, 0, 1);
    glVertex3d(0, 0, 1);
    glColor3d(0, 1, 1);
    glVertex3d(0, 1, 1);
    glColor3d(0, 1, 0);
    glVertex3d(0, 1, 0);
    glEnd();

    glEndList();
}

void CreateLists3(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* XZ one plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 1, 0);
    glVertex3d(0, 1, 0);
    glColor3d(0, 1, 1);
    glVertex3d(0, 1, 1);
    glColor3d(1, 1, 1);
    glVertex3d(1, 1, 1);
    glColor3d(1, 1, 0);
    glVertex3d(1, 1, 0);
    glEnd();

    glEndList();
}

void CreateLists4(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* XY one plane */
    glBegin(GL_POLYGON);
    glColor3d(0, 0, 1);
    glVertex3d(0, 0, 1);
    glColor3d(1, 0, 1);
    glVertex3d(1, 0, 1);
    glColor3d(1, 1, 1);
    glVertex3d(1, 1, 1);
    glColor3d(0, 1, 1);
    glVertex3d(0, 1, 1);
    glEnd();

    glEndList();
}

void CreateLists5(GLuint id)
{
    glNewList(id, GL_COMPILE);
    
    /* YZ one plane */
    glBegin(GL_POLYGON);
    glColor3d(1, 0, 0);
    glVertex3d(1, 0, 0);
    glColor3d(1, 1, 0);
    glVertex3d(1, 1, 0);
    glColor3d(1, 1, 1);
    glVertex3d(1, 1, 1);
    glColor3d(1, 0, 1);
    glVertex3d(1, 0, 1);
    glEnd();

    glEndList();
}

void (*define_list[MAXLISTS])(GLuint id) =
{
    CreateLists0,
    CreateLists1,
    CreateLists2,
    CreateLists3,
    CreateLists4,
    CreateLists5
};

static int offset = 0;

void Draw(HDC hdc, HDC hdcWin)
{
#ifdef COPY_RC
    if (!wglMakeCurrent(hdc, wnd_hrc[COPY_RC]))
    {
        printf("Draw: Unable to make copy RC current, %d\n", GetLastError());
        exit(1);
    }

    glDisable(GL_DEPTH_TEST);
    glDisable(GL_CULL_FACE);
    
    glDisable(GL_DITHER);

    // Should copy the dither change but not the depth test or cull
    if (!wglCopyContext(wnd_hrc[COPY_RC], wnd_hrc[DRAW_RC],
                        GL_COLOR_BUFFER_BIT))
    {
        printf("Draw: Unable to copy RC, %d\n", GetLastError());
        exit(1);
    }
#endif
    
    if (!wglMakeCurrent(hdc, wnd_hrc[DRAW_RC]))
    {
        printf("Draw: Unable to make draw RC current, %d\n", GetLastError());
        exit(1);
    }

    if (fOffsetDrawing)
    {
        glViewport(0, offset, WINWIDTH, WINHEIGHT);
        offset -= 5;
    }

    glClearColor(1.0f, 0.0f, 0.0f, 0.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glLoadIdentity();

    glRotated(xr, 1, 0, 0);
    glRotated(yr, 0, 1, 0);
    glRotated(zr, 0, 0, 1);
    glTranslated(-.5, -.5, -.5);

    if (fShowLists)
    {
        int i;
        
        for (i = 0; i < nLists; i++)
        {
            printf("draw list %d, %d\n", lists[i], glIsList(lists[i]));
        }
    }
    
    glCallLists(nLists, GL_INT, lists);

    if (fCenterMark)
    {
        glLoadIdentity();
        glBegin(GL_LINES);
        glColor3f(1.0f, 1.0f, 1.0f);
        glVertex2f(-2.0f, -2.0f);
        glVertex2f(2.0f, 2.0f);
        glVertex2f(2.0f, -2.0f);
        glVertex2f(-2.0f, 2.0f);
        glEnd();
    }
    
    glFinish();

    if (fBitmap)
    {
        BitBlt(hdcWin, 0, 0, WINWIDTH, WINHEIGHT, hdcBitmap,
               (iBitmapWidth-WINWIDTH)/2, (iBitmapHeight-WINHEIGHT)/2,
               SRCCOPY);
    }
    else
    {
        if (!SwapBuffers(hdc))
        {
            printf("Draw: Unable to swap buffers, %d\n", GetLastError());
            exit(1);
        }
    }
        
    if (!wglMakeCurrent(hdc, NULL))
    {
        printf("Draw: Unable to make RC not-current, %d\n", GetLastError());
        exit(1);
    }
}

void DrawTo(HDC hdc)
{
    if (fBitmap)
    {
        Draw(hdcBitmap, hdc);
    }
    else
    {
        Draw(hdc, hdc);
    }
}

void CALLBACK TimerCb(HWND hwnd, UINT msg, UINT id, DWORD time)
{
    HDC hdc;
    static int busy = FALSE;

    if (busy)
    {
	return;
    }
    busy = TRUE;

    if (fRotate)
    {
        xr += 3;
        yr += 2;
    }

    hdc = GetDC(hwnd);
    DrawTo(hdc);
    ReleaseDC(hwnd, hdc);

    busy = FALSE;
}

DWORD ThreadFn(LPVOID vid)
{
    GLuint list_base = 0;
    int i = 0, id, lid;
    HDC hdc;
    DWORD ret;

    id = (int)vid;
    lid = id*nThreadLists;

    ret = WaitForSingleObject(thread_sem, 10000);
    if (ret != WAIT_OBJECT_0)
    {
        printf("ThreadFn: Thread %d unable to wait, %d\n", id, GetLastError());
        exit(1);
    }

    if (fBitmap)
    {
        hdc = hdcBitmap;
    }
    else
    {
        hdc = GetDC(main_wnd);
        if (hdc == NULL)
        {
            printf("ThreadFn: Thread %d, no DC for window %p\n", id, main_wnd);
            exit(1);
        }
    }
    
    printf("Thread %d running on hwnd %p, hdc %p, rc %p\n",
           id, main_wnd, hdc, wnd_hrc[THREAD_RC+id]);
    
    while (!terminating)
    {
        if (!wglMakeCurrent(hdc, wnd_hrc[THREAD_RC+id]))
        {
            printf("ThreadFn: Thread %d unable to initially make RC "
                   "%d (%p) current, %d\n",
                   id, THREAD_RC+id, wnd_hrc[THREAD_RC+id], GetLastError());
            exit(1);
        }

        if (!fDefineMain)
        {
            list_base = glGenLists(nThreadLists);
            if (list_base == 0)
            {
                printf("ThreadFn: Thread %d unable to glGenLists, 0x%X\n",
                       id, glGetError());
                exit(1);
            }

            for (i = 0; i < nThreadLists; i++)
            {
                define_list[lid+i](list_base+i);
                lists[lid+i] = list_base+i;

                if (!wglMakeCurrent(hdc, NULL))
                {
                    printf("ThreadFn: Unable to make RC "
                           "not-current after set, %d\n",
                           GetLastError());
                    exit(1);
                }
                Sleep(THREAD_LIST_DELAY);
                if (!wglMakeCurrent(hdc, wnd_hrc[THREAD_RC+id]))
                {
                    printf("ThreadFn: Thread %d unable to make RC "
                           "%d (%p) current after set, %d\n",
                           id, THREAD_RC+id, wnd_hrc[THREAD_RC+id],
                           GetLastError());
                    exit(1);
                }
            }

            if (!wglMakeCurrent(hdc, NULL))
            {
                printf("ThreadFn: Unable to make RC "
                       "not-current before pause, %d\n", GetLastError());
                exit(1);
            }
            Sleep(THREAD_PAUSE_DELAY);
            if (!wglMakeCurrent(hdc, wnd_hrc[THREAD_RC+id]))
            {
                printf("ThreadFn: Thread %d unable to make RC "
                       "%d (%p) current before pause, %d\n",
                       id, THREAD_RC+id, wnd_hrc[THREAD_RC+id],
                       GetLastError());
                exit(1);
            }

            for (i = 0; i < nThreadLists; i++)
            {
                lists[lid+i] = 0;
            }
            glDeleteLists(list_base, nThreadLists);
        }
        
        if (!wglMakeCurrent(hdc, NULL))
        {
            printf("ThreadFn: Unable to make RC "
                   "not-current at end of step, %d\n", GetLastError());
            exit(1);
        }
        Sleep(THREAD_STEP_DELAY);
    }

    if (!fBitmap)
    {
        ReleaseDC(main_wnd, hdc);
    }

    ReleaseSemaphore(thread_sem, 1, NULL);
    
    return 0;
}

void Initialize(HWND hwnd)
{
    HDC hdc, hdcWin;
    int i;
    HANDLE thread;
    DWORD tid;

    thread_sem = CreateSemaphore(NULL, 0, nThreads, NULL);
    if (thread_sem == NULL)
    {
        printf("Initialize: Unable to create semaphore, %d\n", GetLastError());
        exit(1);
    }
    
    hdcWin = GetDC(hwnd);

    if (fBitmap)
    {
        BYTE abBitmapInfo[sizeof(BITMAPINFO)];
        BITMAPINFO *pbmi = (BITMAPINFO *)abBitmapInfo;
        BITMAPINFOHEADER *pbmih;
        
        hdcBitmap = CreateCompatibleDC(hdcWin);
        pbmih = &pbmi->bmiHeader;
        pbmih->biSize = sizeof(BITMAPINFOHEADER);
        pbmih->biWidth = iBitmapWidth;
        pbmih->biHeight = iBitmapHeight;
        pbmih->biPlanes = 1;
        pbmih->biBitCount = 24;
        pbmih->biCompression = BI_RGB;
        pbmih->biSizeImage= 0;
        pbmih->biXPelsPerMeter = 0;
        pbmih->biYPelsPerMeter = 0;
        pbmih->biClrUsed = 0;
        pbmih->biClrImportant = 0;
        hbm = CreateDIBSection(hdcBitmap, pbmi, DIB_RGB_COLORS,
                               NULL, NULL, 0);
        SelectObject(hdcBitmap, hbm);
        hdc = hdcBitmap;
    }
    else
    {
        hdc = hdcWin;
    }
    
    SetHdcPixelFormat(hdc);

    for (i = 0; i < nContexts; i++)
    {
        wnd_hrc[i] = CreateRc(hdc);
        if (wnd_hrc[i] == NULL)
        {
            printf("Initialize: Unable to create HRC %d, %d\n",
                   i, GetLastError());
            exit(1);
        }

        if (nThreads > 1 && i > 0)
        {
            if (!wglShareLists(wnd_hrc[0], wnd_hrc[i]))
            {
                printf("Initialize: Unable to share list %d, %d\n",
                       i, GetLastError());
                exit(1);
            }
        }
    }

    if (!wglMakeCurrent(hdc, wnd_hrc[DRAW_RC]))
    {
        printf("Initialize: Unable to make draw RC current after share, %d\n",
               GetLastError());
        exit(1);
    }
    SetOnce();

    if (fDefineMain)
    {
        GLuint lb;
    
        lb = glGenLists(nLists);
        if (lb == 0)
        {
            printf("Initialize: Unable to glGenLists, 0x%X\n", glGetError());
            exit(1);
        }

        for (i = 0; i < nLists; i++)
        {
            define_list[i](lb+i);
            lists[i] = lb+i;
        }
    }

    if (!wglMakeCurrent(hdc, NULL))
    {
        printf("Initialize: Unable to make RC "
               "not-current after SetOnce, %d\n", GetLastError());
        exit(1);
    }

    for (i = 0; i < nThreads; i++)
    {
        thread = CreateThread(NULL, 0, ThreadFn, (LPVOID)i, 0, &tid);
        if (thread == NULL)
        {
            printf("Initialize: Unable to create thread %d\n", i);
            exit(1);
        }

        CloseHandle(thread);
    }
    
    wnd_hpal = CreateRgbPalette(hdc, hdcWin);

    if (wnd_hpal != NULL)
    {
        SelectPalette(hdcWin, wnd_hpal, FALSE);
        RealizePalette(hdcWin);
    }

    ReleaseDC(hwnd, hdcWin);

    if (!fOtherWin)
    {
        timer = SetTimer(hwnd, 1, 100, TimerCb);
        if (timer == 0)
        {
            printf("Initialize: Unable to create timer, %d\n", GetLastError());
            exit(1);
        }
    }
}

void Uninitialize(HWND hwnd)
{
    HDC hdc;
    int i;
    DWORD ret;
    
    terminating = TRUE;
    
    if (timer != 0)
    {
        KillTimer(hwnd, timer);
    }

    for (i = 0; i < nThreads; i++)
    {
        ret = WaitForSingleObject(thread_sem, 100000);
        if (ret != WAIT_OBJECT_0)
        {
            printf("Wait for thread %d failed, %d\n", i, GetLastError());
        }
    }
    
    hdc = GetDC(hwnd);
    if (!wglMakeCurrent(hdc, NULL))
    {
        printf("Uninitialize: Unable to make RC not-current, %d\n",
               GetLastError());
        exit(1);
    }

    if (wnd_hpal != NULL)
    {
        FreeRgbPalette(wnd_hpal, hdc);
    }
    
    ReleaseDC(hwnd, hdc);

    for (i = 0; i < nContexts; i++)
    {
        if (!wglDeleteContext(wnd_hrc[i]))
        {
            printf("Uninitialize: Unable to delete context %d, %d\n",
                   i, GetLastError());
        }
    }

    CloseHandle(thread_sem);
}

LRESULT CALLBACK Events(HWND hwnd, UINT msg, WPARAM wpm, LPARAM lpm)
{
    HDC hdc;
    PAINTSTRUCT ps;

    switch(msg)
    {
    case WM_CREATE:
        if (!fWinOnly)
        {
            Initialize(hwnd);
        }
        return 0;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        if (!fWinOnly)
        {
            DrawTo(hdc);
        }
        EndPaint(hwnd, &ps);
        return 0;

    case WM_KEYDOWN:
        DestroyWindow(hwnd);
        break;
        
    case WM_DESTROY:
        if (!fWinOnly)
        {
            Uninitialize(hwnd);
        }
        PostQuitMessage(0);
        return 0;
    }
    
    return DefWindowProc(hwnd, msg, wpm, lpm);
}

void MakeWindow(void)
{
    WNDCLASS wc;
    RECT wrc;
    DWORD wstyle;
    
    hinstance = (HINSTANCE)GetModuleHandle(NULL);
    wc.lpfnWndProc = Events;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hinstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = wndclass;
    wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
        
    if (!RegisterClass(&wc))
    {
        printf("MakeWindow: Unable to register class, %d\n", GetLastError());
        exit(1);
    }

    wrc.left = 0;
    wrc.right = WINWIDTH;
    wrc.top = 0;
    wrc.bottom = WINHEIGHT;
    wstyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
    AdjustWindowRect(&wrc, wstyle, FALSE);
    main_wnd = CreateWindow(wndclass, wndtitle, wstyle,
                            5, 5,
                            wrc.right-wrc.left, wrc.bottom-wrc.top,
                            NULL, NULL, hinstance, NULL);
    if (main_wnd == NULL)
    {
        printf("MakeWindow: Unable to create window, %d\n", GetLastError());
        exit(1);
    }

    ShowWindow(main_wnd, SW_SHOW);
    UpdateWindow(main_wnd);
}

void EventLoop(void)
{
    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0) && msg.message != WM_QUIT)
    {
        if (fOtherWin)
        {
            printf("Msg %d for %d\n", msg, msg.hwnd);
        }
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

int __cdecl main(int argc, char **argv)
{
    int i;

    while (--argc > 0)
    {
        argv++;

        if (!strcmp(*argv, "-bm"))
        {
            fBitmap = TRUE;
        }
        else if (!strcmp(*argv, "-cm"))
        {
            fCenterMark = TRUE;
        }
        else if (!strcmp(*argv, "-winonly"))
        {
            fWinOnly = TRUE;
        }
        else if (!strcmp(*argv, "-bmw"))
        {
            argc--;
            sscanf(*++argv, "%d", &iBitmapWidth);
        }
        else if (!strcmp(*argv, "-bmh"))
        {
            argc--;
            sscanf(*++argv, "%d", &iBitmapHeight);
        }
        else if (!strcmp(*argv, "-nth"))
        {
            argc--;
            sscanf(*++argv, "%d", &nThreads);
        }
        else if (!strcmp(*argv, "-win"))
        {
            argc--;
            sscanf(*++argv, "%d", &main_wnd);
            fOtherWin = TRUE;
        }
    }

    nContexts = nThreads+EXTRA_RC;
    if (nThreads == 1)
    {
        fDefineMain = TRUE;
    }

    if (!fOtherWin)
    {
        MakeWindow();
    }
    else
    {
        DWORD tid;
        HDC hdc;

        tid = GetWindowThreadProcessId(main_wnd, NULL);
        printf("Attaching tid %d to %d\n", GetCurrentThreadId(), tid);
        if (!AttachThreadInput(GetCurrentThreadId(), tid, TRUE))
        {
            printf("Unable to attach thread input, %d\n",
                   GetLastError());
            exit(1);
        }
        Initialize(main_wnd);
        hdc = GetDC(main_wnd);
        DrawTo(hdc);
        ReleaseDC(main_wnd, hdc);
    }

    if (!fWinOnly)
    {
        for (i = 0; i < nThreads; i++)
        {
            ReleaseSemaphore(thread_sem, 1, NULL);
        }
        
        EventLoop();
    }
    else
    {
        printf("Window is %d, thread %d\n", main_wnd, GetCurrentThreadId());
        Sleep(INFINITE);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\trirast\trirast.c ===
#define SIMPLE_ORTHO
//#define UNIT_CUBE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ptypes32.h>
#include <pwin32.h>

long WndProc ( HWND hwnd, UINT message, DWORD wParam, LONG lParam );
void DrawGlStuff( );
void InitGL( HWND hWnd );

#include <GL\gl.h>

#define TERMINATE   DbgPrint("%s (%d)\n", __FILE__, __LINE__), ExitProcess(0)

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)


// Globals
HDC hDc;
HGLRC hRc;

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    static char szAppName[] = "TriRast";
    HWND hwnd;
    MSG msg;
    RECT Rect;
    WNDCLASS wndclass;

    if ( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
        wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;

        RegisterClass(&wndclass);
    }

    /*
     *  Make the windows a reasonable size and pick a
     *  position for it.
     */

    Rect.left   = 50;
    Rect.top    = 200;
    Rect.right  = 150;
    Rect.bottom = 300;

    AdjustWindowRect( &Rect, WS_OVERLAPPEDWINDOW, FALSE );

DbgPrint("CreateWindow in app\n");
    hwnd = CreateWindow  (  szAppName,              // window class name
                            "The TriRast Program",    // window caption
                            WS_OVERLAPPEDWINDOW,    // window style
                            Rect.left,              // initial x position
                            Rect.top,               // initial y position
                            WINDSIZEX(Rect),        // initial x size
                            WINDSIZEY(Rect),        // initial y size
                            NULL,                   // parent window handle
                            NULL,                   // window menu handle
                            hInstance,              // program instance handle
                            NULL                    // creation parameter

                        );
DbgPrint("Back CreateWindow in app\n");
    hDc = GetDC(hwnd);
DbgPrint("hDc in app is 0x%x\n", hDc);

    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    while ( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    return( msg.wParam );
}


long
WndProc (   HWND hWnd,
            UINT message,
            DWORD wParam,
            LONG lParam
        )
{
    PAINTSTRUCT ps;
    HDC paintdc;

    switch ( message )
    {
        case WM_PAINT:
DbgPrint("WM_PAINT\n");
            if (hRc == NULL)
                InitGL(hWnd);

            paintdc = BeginPaint( hWnd, &ps );
DbgPrint("paintdc is 0x%x\n", paintdc);

            DrawGlStuff();

            EndPaint( hWnd, &ps );
            return(0);

        case WM_DESTROY:
            wglDeleteContext( hRc );
            PostQuitMessage( 0 );
            return( 0 );


    }
    return( DefWindowProc( hWnd, message, wParam, lParam ) );

}

GLfloat Black[] = { 0.5, 0.0, 0.0, 1.1};
GLfloat Red[] = { 1.0, 0.0, 0.0, 1.1};
GLfloat Green[] = { 0.0, 1.0, 0.0, 1.1};
GLfloat Blue[] = { 0.0, 0.0, 1.0, 1.1};

void
InitGL( HWND hWnd )
{
    RECT Rect;


    DbgPrint("InitGL");
    /* Get the size of the client area */

    GetClientRect( hWnd, &Rect );

    DbgPrint("GetClientRect: hdc 0x%x (%d, %d) (%d, %d)\n",
        hDc,
        Rect.left,
        Rect.top,
        Rect.right,
        Rect.bottom );

    /* Create a Rendering Context */

    hRc = wglCreateContext( hDc );

    /* Make it Current */

    wglMakeCurrent( hDc, hRc );

    /* Set up the projection matrix */

    //Ortho2D(0, WINDSIZEX(Rect), 0, WINDSIZEY(Rect));

#ifdef SIMPLE_ORTHO
    glOrtho(0, WINDSIZEX(Rect), 0, WINDSIZEY(Rect), -1, 1);
#endif

// the following should be the default
#ifdef X_UNIT_CUBE		
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
#endif

    glViewport(0, 0, WINDSIZEX(Rect), WINDSIZEY(Rect));

    /* Set the clear color */

    glClearColor( Black[0], Black[1], Black[2], Black[3] );

    glDisable(GL_DITHER); 		/* Turn off dithering */
    glShadeModel(GL_SMOOTH);		/* SMOOTH shaded */

}


void
DrawGlStuff( )
{
    int i;


    DbgPrint("trirast: drawGLstuff\n");
    /* Clear the color buffer */

    glClear( GL_COLOR_BUFFER_BIT );


    /* Draw a single point */
    glBegin(GL_TRIANGLES);

#ifdef SIMPLE_ORTHO
	glColor4fv( Blue );
        glVertex2f( (GLfloat)10, (GLfloat)10 );
	glColor4fv( Green );
        glVertex2f( (GLfloat)50, (GLfloat)20 );
	glColor4fv( Red );
        glVertex2f( (GLfloat)40, (GLfloat)60 );
#endif

#ifdef UNIT_CUBE
        /*  Set the color */
        glIndexi(RED_INDEX);
        glVertex2f( (GLfloat).1, (GLfloat).1 );
        glVertex2f( (GLfloat).2, (GLfloat).2 );
        glVertex2f( (GLfloat).3, (GLfloat).5 );
#endif

    glEnd();

    glFlush();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\timecube\fastdib.c ===
/******************************Module*Header*******************************\
* Module Name: fastdib.c
*
* CreateCompatibleDIB implementation.
*
* Created: 23-Jan-1996 21:08:18
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#include "fastdib.h"

static BOOL bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static BOOL bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static UINT MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                                      LPPALETTEENTRY lppe);
static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal,
                                        BYTE *pajVector);

#if DBG
ULONG DbgPrint(PCH DebugMessage, ...);

#define DBGPRINT(str)                       DbgPrint(str)
#define DBGPRINT1(str, arg1)                DbgPrint(str, arg1)
#define DBGPRINT2(str, arg1, arg2)          DbgPrint(str, arg1, arg2)
#define DBGPRINT3(str, arg1, arg2, arg3)    DbgPrint(str, arg1, arg2, arg3)
#else
#define DBGPRINT(str)
#define DBGPRINT1(str, arg1)
#define DBGPRINT2(str, arg1, arg2)
#define DBGPRINT3(str, arg1, arg2, arg3)
#endif

/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DIB <= 8bpp, then the DIB color table is initialized based on the
* specified palette.  If the palette handle is NULL, then the system
* palette is used.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Note: On palettized displays, if the system palette changes the
*       UpdateDIBColorTable function should be called to maintain
*       the identity palette mapping between the DIB and the display.
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY
CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight,
                    PVOID *ppvBits)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        DBGPRINT("CreateCompatibleDIB: not OBJ_DC\n");
        return hbmRet;
    }

    memset(aj, 0, sizeof(aj));
    if ( bFillBitmapInfo(hdc, hpal, pbmi) )
    {
        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = ulWidth;
        pbmi->bmiHeader.biHeight = ulHeight;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);

        if ( !hbmRet )
        {
            DBGPRINT("CreateCompatibleDIB: CreateDIBSection failed\n");
        }
    }
    else
    {
        DBGPRINT("CreateCompatibleDIB: bFillBitmapInfo failed\n");
    }

    return hbmRet;
}

/******************************Public*Routine******************************\
* UpdateDIBColorTable
*
* Synchronize the DIB color table to the specified palette hpal.
* If hpal is NULL, then use the system palette.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
UpdateDIBColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;
    BYTE aj[(sizeof(RGBQUAD) + sizeof(PALETTEENTRY)) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    LPRGBQUAD prgb = (LPRGBQUAD) (lppe + 256);
    ULONG i, cColors;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        DBGPRINT("UpdateDIBColorTable: not OBJ_DC\n");
        return bRet;
    }
    if ( GetObjectType(hdcMem) != OBJ_MEMDC )
    {
        DBGPRINT("UpdateDIBColorTable: not OBJ_MEMDC\n");
        return bRet;
    }

    //
    // Get the bitmap handle out of the memdc.
    //

    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP);

    //
    // Validate bitmap (must be DIB section).
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds)) &&
         ds.dsBm.bmBits )
    {
        //
        // Get palette entries from specified palette or system palette.
        //

        cColors = 1 << ds.dsBmih.biBitCount;

        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe)
           )
        {
            UINT i;

            //
            // Convert to RGBQUAD.
            //

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            //
            // Set the DIB color table.
            //

            bRet = (BOOL) SetDIBColorTable(hdcMem, 0, cColors, prgb);

            if (!bRet)
            {
                DBGPRINT("UpdateDIBColorTable: SetDIBColorTable failed\n");
            }
        }
        else
        {
            DBGPRINT("UpdateDIBColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }
    else
    {
        DBGPRINT("UpdateDIBColorTable: GetObject failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        //!!!dbug -- GDI Bug 19374: bmWidthBytes returns pitch assuming
        //!!!        that DIB scanlines are WORD aligned (as they
        //!!!        are in Win95).  But NT DIBs are DWORD aligned.
        //!!!        When bug if corrected, we can remove this block of
        //!!!        code.
        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                DBGPRINT1("GetCompatibleDIBInfo: GetVersionEx failed with %d\n", GetLastError());
                return bRet;
            }
        }

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((int) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        DBGPRINT("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetDIBTranslationVector
*
* Copies the translation vector that maps colors in the specified palette,
* hpal, to the DIB selected into the specified DC, hdcMem.
*
* Effects:
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;

    //
    // Validate parameters.
    //

    if ( GetObjectType(hdcMem) != OBJ_MEMDC ||
         GetObjectType(hpal) != OBJ_PAL ||
         !pbVector )
    {
        DBGPRINT("GetDIBTranslationVector: bad parameter\n");
        return bRet;
    }

    //
    // The function bComputeLogicalToSurfaceMap cannot handle palettes
    // greater than 256 entries.
    //

    if ( GetPaletteEntries(hpal, 0, 1, NULL) > 256 )
    {
        DBGPRINT("GetDIBTranslationVector: palette too big\n");
        return bRet;
    }

    //
    // The DIB must have a color table.
    //

    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP);
    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && (ds.dsBmih.biBitCount <= 8) )
    {
        bRet = bComputeLogicalToSurfaceMap(hdcMem, hpal, pbVector);
    }
    else
    {
        DBGPRINT("GetDIBTranslationVector: not a DIB section\n");
        return bRet;
    }

    return bRet;
}

//////////////////// Below here are internal-only routines ////////////////////

/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if ( pbmi->bmiHeader.biBitCount <= 8 )
        {
            bRet = bFillColorTable(hdc, hpal, pbmi);
        }
        else
        {
            if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
            {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
            }

            bRet = TRUE;
        }

        DeleteObject(hbm);
    }
    else
    {
        DBGPRINT("bFillBitmapInfo: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG i, cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;
    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            DBGPRINT("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bComputeLogicalToSurfaceMap
*
* Copy logical palette to surface palette translation vector to the buffer
* pointed to by pajVector.  The logical palette is specified by hpal.  The
* surface is specified by hdc.
*
* Note: The hdc may identify either a direct (display) dc or a DIB memory dc.
* If hdc is a display dc, then the surface palette is the system palette.
* If hdc is a memory dc, then the surface palette is the DIB color table.
*
* History:
*  27-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal, BYTE *pajVector)
{
    BOOL bRet = FALSE;
    HPALETTE hpalSurf;
    ULONG cEntries, cSysEntries;
    DWORD dwDcType = GetObjectType(hdc);
    LPPALETTEENTRY lppeTmp, lppeEnd;

    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)];
    LOGPALETTE *ppal = (LOGPALETTE *) aj;
    LPPALETTEENTRY lppeSurf = &ppal->palPalEntry[0];
    LPPALETTEENTRY lppe = lppeSurf + 256;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

    //
    // Determine number of colors in each palette.
    //

    cEntries = GetPaletteEntries(hpal, 0, 1, NULL);
    if ( dwDcType == OBJ_DC )
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, 1, NULL);
    else
        cSysEntries = 256;

    //
    // Get the logical palette entries.
    //

    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe);

    //
    // Get the surface palette entries.
    //

    if ( dwDcType == OBJ_DC )
    {
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf);

        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        for (; lppeTmp < lppeEnd; lppeTmp++)
            lppeTmp->peFlags = 0;
    }
    else
    {
        RGBQUAD *prgbTmp;

        //
        // First get RGBQUADs from DIB color table...
        //

        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb);

        //
        // ...then convert RGBQUADs into PALETTEENTRIES.
        //

        prgbTmp = prgb;
        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        while ( lppeTmp < lppeEnd )
        {
            lppeTmp->peRed   = prgbTmp->rgbRed;
            lppeTmp->peGreen = prgbTmp->rgbGreen;
            lppeTmp->peBlue  = prgbTmp->rgbBlue;
            lppeTmp->peFlags = 0;

            lppeTmp++;
            prgbTmp++;

        }
    }

    //
    // Construct a translation vector by using GetNearestPaletteIndex to
    // map each entry in the logical palette to the surface palette.
    //

    if ( cEntries && cSysEntries )
    {
        //
        // Create a temporary logical palette that matches the surface
        // palette retrieved above.
        //

        ppal->palVersion = 0x300;
        ppal->palNumEntries = (USHORT) cSysEntries;

        if ( hpalSurf = CreatePalette(ppal) )
        {
            //
            // Translate each logical palette entry into a surface palette
            // index.
            //

            lppeTmp = lppe;
            lppeEnd = lppe + cEntries;

            for ( ; lppeTmp < lppeEnd; lppeTmp++, pajVector++)
            {
                *pajVector = (BYTE) GetNearestPaletteIndex(
                                        hpalSurf,
                                        RGB(lppeTmp->peRed,
                                            lppeTmp->peGreen,
                                            lppeTmp->peBlue)
                                        );
            }

            bRet = TRUE;

            DeleteObject(hpalSurf);
        }
        else
        {
            DBGPRINT("bComputeLogicalToSurfaceMap: CreatePalette failed\n");
        }
    }
    else
    {
        DBGPRINT("bComputeLogicalToSurfaceMap: failed to get pal info\n");
    }

    return bRet;
}

#if DBG
/******************************Public*Routine******************************\
* DbgPrint
*
* Formatted string output to the debugger.
*
* History:
*  26-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG
DbgPrint(PCH DebugMessage, ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, DebugMessage);

    vsprintf(buffer, DebugMessage, ap);

    OutputDebugStringA(buffer);

    va_end(ap);

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\f2hex.c ===
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int __cdecl main(int argc, char **argv)
{
    unsigned long *pul;
    float f;

    if (argc <= 1)
        printf("usage: f2hex [float number] ==> output is hex\n");
    else
    {
        f = (float) strtod(argv[1], 0);
        pul = (unsigned long *) &f;

        printf("%f = 0x%08lx", f, *pul);
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\simple\rgb\timecube\timecube.c ===
/******************************Module*Header*******************************\
* Module Name: timecube.c
*
* Simple app to render a rotating color cube.
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <time.h>
#include <sys\types.h>
#include <sys\timeb.h>
#include <gl\gl.h>
#include "fastdib.h"

#define GAMMA_CORRECTION 10

LONG     WndProc(HWND, UINT, WPARAM, LPARAM);
VOID     vDraw(HWND, HDC);
HGLRC    hrcInitGL(HWND, HDC);
VOID     vResizeDoubleBuffer(HWND, HDC);
VOID     vCleanupGL(HDC, HGLRC);
BOOL     bSetupPixelFormat(HDC);
HPALETTE CreateRGBPalette(HDC);
HDC      MyCreateCompatibleDC(HDC);
VOID     vSetSize(HWND);

ULONG DbgPrint(PCH DebugMessage, ... );

#define WINDSIZEX(Rect)   (Rect.right - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

#define ZERO            ((GLfloat)0.0)
#define ONE             ((GLfloat)1.0)
#define POINT_TWO       ((GLfloat)0.2)
#define POINT_SEVEN     ((GLfloat)0.7)
#define THREE           ((GLfloat)3.0)
#define FIVE            ((GLfloat)5.0)
#define TEN             ((GLfloat)10.0)
#define FORTY_FIVE      ((GLfloat)45.0)
#define FIFTY           ((GLfloat)50.0)

//
// Default Logical Palette indexes
//

#define BLACK_INDEX     0
#define WHITE_INDEX     19
#define RED_INDEX       13
#define GREEN_INDEX     14
#define BLUE_INDEX      16
#define YELLOW_INDEX    15
#define MAGENTA_INDEX   17
#define CYAN_INDEX      18

#define ClearColor  ZERO, ZERO, ZERO, ONE
#define Cyan        ZERO, ONE, ONE, ONE
#define Yellow      ONE, ONE, ZERO, ONE
#define Magenta     ONE, ZERO, ONE, ONE
#define Red         ONE, ZERO, ZERO, ONE
#define Green       ZERO, ONE, ZERO, ONE
#define Blue        ZERO, ZERO, ONE, ONE
#define White       ONE, ONE, ONE, ONE
#define Black       ZERO, ZERO, ZERO, ONE

//
// Global variables defining current position and orientation.
//

GLfloat AngleX         = (GLfloat)145.0;
GLfloat AngleY         = FIFTY;
GLfloat AngleZ         = ZERO;
GLfloat DeltaAngle[3]  = { TEN, FIVE, -FIVE };
GLfloat OffsetX        = ZERO;
GLfloat OffsetY        = ZERO;
GLfloat OffsetZ        = -THREE;
GLuint  DListCube;
UINT    guiTimerTick = 1;
ULONG   gulZoom = 1;

HDC     ghdcMem;
HBITMAP ghbmBackBuffer = (HBITMAP) 0, ghbmOld;

HGLRC ghrc = (HGLRC) 0;
HPALETTE ghpalOld, ghPalette = (HPALETTE) 0;

BOOL bResetStats = TRUE;
struct _timeb thisTime, baseTime;
int frameCount;

void printmemdc(HDC hdc)
{
    HBITMAP hbm;
    HPALETTE hpal;
    int i, iMax;
    BYTE aj[(sizeof(PALETTEENTRY) + sizeof(RGBQUAD)) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

    hbm = GetCurrentObject(hdc, OBJ_BITMAP);
    hpal = GetCurrentObject(hdc, OBJ_PAL);

    DbgPrint("Palette\n");
    iMax = GetPaletteEntries(hpal, 0, 256, lppe);
    for (i = 0; i < iMax; i++)
        DbgPrint("%ld\t(0x%02x, 0x%02x, 0x%02x)\n",
                 i, lppe[i].peRed, lppe[i].peGreen, lppe[i].peBlue);

    DbgPrint("Color table\n");
    iMax = GetDIBColorTable(hdc, 0, 256, prgb);
    for (i = 0; i < iMax; i++)
        DbgPrint("%ld\t(0x%02x, 0x%02x, 0x%02x)\n",
                 i, prgb[i].rgbRed, prgb[i].rgbGreen, prgb[i].rgbBlue);
}

/******************************Public*Routine******************************\
* WinMain
*
* Program entry point.
*
\**************************************************************************/

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine, int nCmdShow)
{
    static char szAppName[] = "TimeCube";
    HWND hwnd;
    MSG msg;
    RECT rc;
    WNDCLASS wndclass;
    char title[32];

    //
    // Create window class.
    //

    if (!hPrevInstance)
    {
        wndclass.style          = CS_OWNDC;
        wndclass.lpfnWndProc    = (WNDPROC)WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = hInstance;
        wndclass.hCursor        = NULL;
        wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szAppName;
        wndclass.hIcon          = LoadIcon(hInstance, "CubeIcon");

        RegisterClass(&wndclass);
    }

    //
    // Make the windows a reasonable size and pick a position for it.
    //

    rc.left    = 100;
    rc.top     = 100;
    rc.right   = 300;
    rc.bottom  = 300;
    guiTimerTick = 1;

    AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, FALSE);

    hwnd = CreateWindow(szAppName,              // window class name
                        szAppName,              // window caption
                        WS_OVERLAPPEDWINDOW
                        | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                        CW_USEDEFAULT,          // initial x position
                        rc.top,                 // initial y position
                        WINDSIZEX(rc),          // initial x size
                        WINDSIZEY(rc),          // initial y size
                        NULL,                   // parent window handle
                        NULL,                   // window menu handle
                        hInstance,              // program instance handle
                        NULL                    // creation parameter
                       );

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    //
    // Setup timer.  We will draw cube every timer tick.
    //

    SetTimer(hwnd, 1, guiTimerTick, NULL);

    //
    // Message loop.
    //

    while ( GetMessage(&msg, NULL, 0, 0) )
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return( msg.wParam );
}

/******************************Public*Routine******************************\
* WndProc
*
* Window procedure.  Process window messages.
*
\**************************************************************************/

LONG WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static HDC hdc = (HDC) NULL;
    PAINTSTRUCT ps;

    switch (message)
    {
        case WM_CREATE:
            //
            // Our app is going to hold the DC for the duration of the
            // window to avoid having to call wglMakeCurrent each time.
            //
            // An alternative would be to create window as CS_OWNDC.
            //

            hdc = GetDC(hwnd);

            if (ghrc == (HGLRC) 0)
                ghrc = hrcInitGL(hwnd, hdc);

            return(0);

        case WM_PAINT:
            BeginPaint(hwnd, &ps);
            EndPaint(hwnd, &ps);

            if (ghrc == (HGLRC) 0)
                ghrc = hrcInitGL(hwnd, hdc);

            vDraw(hwnd, hdc);

            return(0);

        case WM_SIZE:
            vResizeDoubleBuffer(hwnd, hdc);
            vSetSize(hwnd);

            return(0);

        case WM_PALETTECHANGED:
            if (hwnd != (HWND) wParam)
            {
                UnrealizeObject(ghPalette);
                SelectPalette(hdc, ghPalette, TRUE);
                if (RealizePalette(hdc) != GDI_ERROR)
                    return 1;
            }
            return 0;

        case WM_QUERYNEWPALETTE:

            UnrealizeObject(ghPalette);
            SelectPalette(hdc, ghPalette, FALSE);
            if (RealizePalette(hdc) != GDI_ERROR)
                return 1;

        case WM_KEYDOWN:
            switch (wParam)
            {
            case VK_ESCAPE:
                PostMessage(hwnd, WM_DESTROY, 0, 0);
                break;
            default:
                break;
            }
            return 0;

        case WM_CHAR:
            switch(wParam)
            {
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    gulZoom = wParam - '0';
                    vResizeDoubleBuffer(hwnd, hdc);
                    vSetSize(hwnd);
                    break;

                case 'd':
                case 'D':
                    OffsetX += POINT_TWO;
                    break;

                case 'a':
                case 'A':
                    OffsetX -= POINT_TWO;
                    break;

                case 's':
                case 'S':
                    OffsetY += POINT_TWO;
                    break;

                case 'w':
                case 'W':
                    OffsetY -= POINT_TWO;
                    break;

                case 'q':
                case 'Q':
                    OffsetZ += POINT_TWO;
                    break;

                case 'e':
                case 'E':
                    OffsetZ -= POINT_TWO;
                    break;

                case ',':
                case '<':
                    guiTimerTick = guiTimerTick << 1;
                    guiTimerTick = min(0x40000000, guiTimerTick);

                    KillTimer(hwnd, 1);
                    SetTimer(hwnd, 1, guiTimerTick, NULL);
                    break;

                case '.':
                case '>':
                    guiTimerTick = guiTimerTick >> 1;
                    guiTimerTick = max(1, guiTimerTick);

                    KillTimer(hwnd, 1);
                    SetTimer(hwnd, 1, guiTimerTick, NULL);
                    break;

                default:
                    break;
            }

            return 0;

        case WM_TIMER:
            //
            // Each timer tick, we change the angle and draw a new frame.
            //

            AngleX += DeltaAngle[0];
            if (AngleX > 360.0f)
                AngleX -= 360.0f;
            AngleY += DeltaAngle[1];
            if (AngleY > 360.0f)
                AngleY -= 360.0f;
            AngleZ += DeltaAngle[2];
            if (AngleZ > 360.0f)
                AngleZ -= 360.0f;

            vDraw(hwnd, hdc);

            return 0;

        case WM_DESTROY:

            vCleanupGL(hdc, ghrc);
            ReleaseDC(hwnd, hdc);

            KillTimer(hwnd, 1);
            PostQuitMessage( 0 );
            return( 0 );

    }
    return( DefWindowProc( hwnd, message, wParam, lParam ) );
}

/******************************Public*Routine******************************\
* vResizeDoubleBuffer
*
\**************************************************************************/

void vResizeDoubleBuffer(HWND hwnd, HDC hdc)
{
    RECT rc;
    HBITMAP hbmNew;
    PVOID pvBits;

    if (ghdcMem)
    {
        GetClientRect(hwnd, &rc);

        hbmNew = CreateCompatibleDIB(hdc, NULL, WINDSIZEX(rc)/gulZoom, WINDSIZEY(rc)/gulZoom, &pvBits);
        if (hbmNew)
        {
            if (ghbmBackBuffer != (HBITMAP) 0)
            {
                SelectObject(ghdcMem, ghbmOld);
                DeleteObject(ghbmBackBuffer);
            }

            ghbmBackBuffer = hbmNew;
            ghbmOld = SelectObject(ghdcMem, ghbmBackBuffer);
        }
        else
            DbgPrint("vResizeDoubleBuffer: CreateCompatibleBitmap failed\n");
    }
    else
        DbgPrint("vResizeDoubleBuffer: no memdc\n");

    bResetStats = TRUE;
}

/******************************Public*Routine******************************\
* ComponentFromIndex
*
* Translates an 8-bit index into the corresponding 332 RGB value.
* Used only on 8bpp displays.
*
\**************************************************************************/

// Conversion tables for n bits to eight bits

#if GAMMA_CORRECTION == 10
// These tables are corrected for a gamma of 1.0
static unsigned char abThreeToEight[8] =
{
    0, 0111 >> 1, 0222 >> 1, 0333 >> 1, 0444 >> 1, 0555 >> 1, 0666 >> 1, 0377
};
static unsigned char abTwoToEight[4] =
{
    0, 0x55, 0xaa, 0xff
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#else
// These tables are corrected for a gamma of 1.4
static unsigned char abThreeToEight[8] =
{
    0, 63, 104, 139, 171, 200, 229, 255
};
static unsigned char abTwoToEight[4] =
{
    0, 116, 191, 255
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#endif

unsigned char
ComponentFromIndex(i, nbits, shift)
{
    unsigned char val;

    val = i >> shift;
    switch (nbits) {

    case 1:
        val &= 0x1;
        return abOneToEight[val];

    case 2:
        val &= 0x3;
        return abTwoToEight[val];

    case 3:
        val &= 0x7;
        return abThreeToEight[val];

    default:
        return 0;
    }
}

/******************************Public*Routine******************************\
*
* UpdateStaticMapping
*
* Computes the best match between the current system static colors
* and a 3-3-2 palette
*
* History:
*  Tue Aug 01 18:18:12 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define STATIC_COLORS   20
#define EXACT_MATCH     1
#define COLOR_USED      1
#define MAX_COL_DIST    (3*256*256L)

// Table which indicates which colors in a 3-3-2 palette should be
// replaced with the system default colors
#if GAMMA_CORRECTION == 10
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 4, 32, 36, 128, 132, 160, 173, 181, 245,
    247, 164, 156, 7, 56, 63, 192, 199, 248, 255
};
#else
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 3, 24, 27, 64, 67, 88, 173, 181, 236,
    247, 164, 91, 7, 56, 63, 192, 199, 248, 255
};
#endif

static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },

    { 192, 220, 192,  0 },
    { 166, 202, 240,  0 },
    { 255, 251, 240,  0 },
    { 160, 160, 164,  0 },

    { 0x80,0x80,0x80, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

static void
UpdateStaticMapping(PALETTEENTRY *pe332Palette)
{
    HPALETTE hpalStock;
    int iStatic, i332;
    int iMinDist, iDist;
    int iDelta;
    int iMinEntry;
    PALETTEENTRY *peStatic, *pe332;

    hpalStock = GetStockObject(DEFAULT_PALETTE);

    // Get the current static colors
    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry);

    // Zero the flags in the static colors because they are used later
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Zero the flags in the incoming palette because they are used later
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = 0;
        pe332++;
    }

    // Try to match each static color exactly
    // This saves time by avoiding the least-squares match for each
    // exact match
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            if (peStatic->peRed == pe332->peRed &&
                peStatic->peGreen == pe332->peGreen &&
                peStatic->peBlue == pe332->peBlue)
            {
                peStatic->peFlags = EXACT_MATCH;
                pe332->peFlags = COLOR_USED;
                aiDefaultOverride[iStatic] = i332;

                break;
            }

            pe332++;
        }

        peStatic++;
    }

    // Match each static color as closely as possible to an entry
    // in the 332 palette by minimized the square of the distance
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        // Skip colors already matched exactly
        if (peStatic->peFlags == EXACT_MATCH)
        {
            peStatic++;
            continue;
        }

        iMinDist = MAX_COL_DIST+1;

        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            // Skip colors already used
            if (pe332->peFlags == COLOR_USED)
            {
                pe332++;
                continue;
            }

            // Compute Euclidean distance squared
            iDelta = pe332->peRed-peStatic->peRed;
            iDist = iDelta*iDelta;
            iDelta = pe332->peGreen-peStatic->peGreen;
            iDist += iDelta*iDelta;
            iDelta = pe332->peBlue-peStatic->peBlue;
            iDist += iDelta*iDelta;

            if (iDist < iMinDist)
            {
                iMinDist = iDist;
                iMinEntry = i332;
            }

            pe332++;
        }

        // Remember the best match
        aiDefaultOverride[iStatic] = iMinEntry;
        pe332Palette[iMinEntry].peFlags = COLOR_USED;

        peStatic++;
    }

    // Zero the flags in the static colors because they may have been
    // set.  We want them to be zero so the colors can be remapped
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Reset the 332 flags because we may have modified them
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = PC_NOCOLLAPSE;
        pe332++;
    }

#if 0
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        DbgPrint("Static color %2d maps to %d\n",
                 iStatic, aiDefaultOverride[iStatic]);
    }
#endif
}

/******************************Public*Routine******************************\
* FlushPalette
*
* Because of Win 3.1 compatibility, GDI palette mapping always starts
* at zero and stops at the first exact match.  So if there are duplicates,
* the higher colors aren't mapped to--which is often a problem if we
* are trying to make to any of the upper 10 static colors.  To work around
* this, we flush the palette to all black.
*
* This only needs to be done for the 8BPP (256 color) case.
*
\**************************************************************************/

static void
FlushPalette(HDC hdc, int nColors)
{
    LOGPALETTE *pPal;
    HPALETTE hpal, hpalOld;
    int i;

    if (nColors == 256)
    {
        pPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
                                         sizeof(LOGPALETTE) + nColors * sizeof(PALETTEENTRY));

        if (pPal)
        {
            pPal->palVersion = 0x300;
            pPal->palNumEntries = nColors;

        // Mark everything PC_NOCOLLAPSE and PC_RESERVED to force every thing
        // into the palette.  Colors are already black because we zero initialized
        // during memory allocation.

            for (i = 0; i < nColors; i++)
            {
                pPal->palPalEntry[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
            }

            hpal = CreatePalette(pPal);
            LocalFree(pPal);

            hpalOld = SelectPalette(hdc, hpal, FALSE);
            RealizePalette(hdc);

            SelectPalette(hdc, hpalOld, FALSE);
            DeleteObject(hpal);
        }
    }
}

/******************************Public*Routine******************************\
* CreateRGBPalette
*
* If required by the pixelformat, create the logical palette and select
* into DC.
*
\**************************************************************************/

HPALETTE CreateRGBPalette(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    LOGPALETTE *pPal;
    int n, i;
    HPALETTE hpalRet = ghPalette;

    if (!hpalRet)
    {
        ppfd = &pfd;
        n = GetPixelFormat(hdc);
        DescribePixelFormat(hdc, n, sizeof(PIXELFORMATDESCRIPTOR), ppfd);

        if (ppfd->dwFlags & PFD_NEED_PALETTE) {
            n = 1 << ppfd->cColorBits;
            pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
                    n * sizeof(PALETTEENTRY));
            pPal->palVersion = 0x300;
            pPal->palNumEntries = n;
            for (i=0; i<n; i++)
            {
                pPal->palPalEntry[i].peRed =
                        ComponentFromIndex(i, ppfd->cRedBits, ppfd->cRedShift);
                pPal->palPalEntry[i].peGreen =
                        ComponentFromIndex(i, ppfd->cGreenBits, ppfd->cGreenShift);
                pPal->palPalEntry[i].peBlue =
                        ComponentFromIndex(i, ppfd->cBlueBits, ppfd->cBlueShift);
                pPal->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
            }

            if (n == 256)
            {
                pPal->palPalEntry[0].peFlags = 0;
                pPal->palPalEntry[255].peFlags = 0;

                // The defaultOverride array is computed assuming a 332
                // palette where red has zero shift, etc.

                if ( (3 == ppfd->cRedBits)   && (0 == ppfd->cRedShift)   &&
                     (3 == ppfd->cGreenBits) && (3 == ppfd->cGreenShift) &&
                     (2 == ppfd->cBlueBits)  && (6 == ppfd->cBlueShift) )
                {
                    UpdateStaticMapping(pPal->palPalEntry);

                    for ( i = 0 ; i < STATIC_COLORS ; i++)
                    {
                        pPal->palPalEntry[aiDefaultOverride[i]] = apeDefaultPalEntry[i];
                    }
                }
            }

            hpalRet = CreatePalette(pPal);
            LocalFree(pPal);

        }
    }

    return hpalRet;
}

/******************************Public*Routine******************************\
* bSetupPixelFormat
*
* Choose and set pixelformat.
\**************************************************************************/

BOOL bSetupPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    PIXELFORMATDESCRIPTOR pfdGot, *ppfdGot;
    int pixelformat;

    ppfd = &pfd;
    ppfdGot = &pfdGot;

    memset(ppfd, 0, sizeof(PIXELFORMATDESCRIPTOR));
    ppfd->nSize = sizeof(PIXELFORMATDESCRIPTOR);
    ppfd->nVersion = 1;

    if (GetObjectType(hdc) == OBJ_MEMDC)
    {
        ppfd->dwFlags = PFD_DRAW_TO_BITMAP | PFD_SUPPORT_OPENGL;
    }
    else
    {
        ppfd->dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    }

    ppfd->iPixelType = PFD_TYPE_RGBA;
    ppfd->cColorBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);;
    ppfd->cDepthBits = 0;
    ppfd->cAccumBits = 0;
    ppfd->cStencilBits = 0;

    ppfd->iLayerType = PFD_MAIN_PLANE;
    ppfd->dwLayerMask = PFD_MAIN_PLANE;

    if ( (pixelformat = ChoosePixelFormat(hdc, ppfd)) == 0 )
    {
        MessageBox(NULL, "ChoosePixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    DescribePixelFormat(hdc, pixelformat, sizeof(*ppfdGot), ppfdGot);
    if ( ((ppfd->dwFlags & PFD_DRAW_TO_BITMAP) && !(ppfdGot->dwFlags & PFD_DRAW_TO_BITMAP)) ||
         ((ppfd->dwFlags & PFD_DRAW_TO_WINDOW) && !(ppfdGot->dwFlags & PFD_DRAW_TO_WINDOW)) )
        MessageBoxA(NULL, "bad flag", "warning",MB_OK);
    if (ppfdGot->cColorBits != ppfd->cColorBits)
        MessageBoxA(NULL, "bad color depth", "warning", MB_OK);

    if (SetPixelFormat(hdc, pixelformat, ppfd) == FALSE)
    {
        MessageBox(NULL, "SetPixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    if (ppfdGot->dwFlags & PFD_NEED_PALETTE)
    {
        ghPalette = CreateRGBPalette(hdc);

        //!!!dbug
        //SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC);
        //UnrealizeObject(ghPalette);

        FlushPalette(hdc, 1 << ppfdGot->cColorBits);
        ghpalOld = SelectPalette(hdc, ghPalette, FALSE);
        RealizePalette(hdc);
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* hrcInitGL
*
* Initialize OpenGL.
*
\**************************************************************************/

HGLRC hrcInitGL(HWND hwnd, HDC hdc)
{
    HGLRC hrc;

    //
    // Create a Rendering Context and make it current.
    // If rendering to a bitmap, create the memdc and bitmap.
    //

    bSetupPixelFormat(hdc);

    ghdcMem = CreateCompatibleDC(hdc);
    //ghdcMem = MyCreateCompatibleDC(hdc);

    if (!ghdcMem)
        DbgPrint("CreateCompatibleDC failed\n");

    vResizeDoubleBuffer(hwnd, hdc);
    //UpdateDIBColorTable(ghdcMem, hdc, NULL);

    bSetupPixelFormat(ghdcMem);

    hrc = wglCreateContext(ghdcMem);
    wglMakeCurrent(ghdcMem, hrc);

    //
    // Setup OpenGL state.
    //

    glPushAttrib(GL_TEXTURE_BIT | GL_LIGHTING_BIT | GL_TRANSFORM_BIT);
    glClearColor( ClearColor );
    glEnable(GL_CULL_FACE);
    glDrawBuffer(GL_FRONT);
    glDisable(GL_DEPTH_TEST);

    //
    // Generate color cube as a display list.
    //

    DListCube = glGenLists(1);

    glNewList(DListCube, GL_COMPILE);

        glBegin(GL_QUADS);

        glColor4f( White );
        glVertex3f( POINT_SEVEN, POINT_SEVEN, POINT_SEVEN);
        glColor4f( Magenta );
        glVertex3f( POINT_SEVEN, -POINT_SEVEN, POINT_SEVEN);
        glColor4f( Red );
        glVertex3f( POINT_SEVEN, -POINT_SEVEN, -POINT_SEVEN);
        glColor4f( Yellow );
        glVertex3f( POINT_SEVEN, POINT_SEVEN, -POINT_SEVEN);

        glColor4f( Yellow );
        glVertex3f( POINT_SEVEN, POINT_SEVEN, -POINT_SEVEN);
        glColor4f( Red );
        glVertex3f( POINT_SEVEN, -POINT_SEVEN, -POINT_SEVEN);
        glColor4f( Black );
        glVertex3f( -POINT_SEVEN, -POINT_SEVEN, -POINT_SEVEN);
        glColor4f( Green );
        glVertex3f( -POINT_SEVEN, POINT_SEVEN, -POINT_SEVEN);

        glColor4f( Green );
        glVertex3f( -POINT_SEVEN, POINT_SEVEN, -POINT_SEVEN);
        glColor4f( Black );
        glVertex3f( -POINT_SEVEN, -POINT_SEVEN, -POINT_SEVEN);
        glColor4f( Blue );
        glVertex3f( -POINT_SEVEN, -POINT_SEVEN, POINT_SEVEN);
        glColor4f( Cyan );
        glVertex3f( -POINT_SEVEN, POINT_SEVEN, POINT_SEVEN);

        glColor4f( Cyan );
        glVertex3f( -POINT_SEVEN, POINT_SEVEN, POINT_SEVEN);
        glColor4f( Blue );
        glVertex3f( -POINT_SEVEN, -POINT_SEVEN, POINT_SEVEN);
        glColor4f( Magenta );
        glVertex3f( POINT_SEVEN, -POINT_SEVEN, POINT_SEVEN);
        glColor4f( White );
        glVertex3f( POINT_SEVEN, POINT_SEVEN, POINT_SEVEN);

        glColor4f( White );
        glVertex3f( POINT_SEVEN, POINT_SEVEN, POINT_SEVEN);
        glColor4f( Yellow );
        glVertex3f( POINT_SEVEN, POINT_SEVEN, -POINT_SEVEN);
        glColor4f( Green );
        glVertex3f( -POINT_SEVEN, POINT_SEVEN, -POINT_SEVEN);
        glColor4f( Cyan );
        glVertex3f( -POINT_SEVEN, POINT_SEVEN, POINT_SEVEN);

        glColor4f( Magenta );
        glVertex3f( POINT_SEVEN, -POINT_SEVEN, POINT_SEVEN);
        glColor4f( Blue );
        glVertex3f( -POINT_SEVEN, -POINT_SEVEN, POINT_SEVEN);
        glColor4f( Black );
        glVertex3f( -POINT_SEVEN, -POINT_SEVEN, -POINT_SEVEN);
        glColor4f( Red );
        glVertex3f( POINT_SEVEN, -POINT_SEVEN, -POINT_SEVEN);

        glEnd();

    glEndList();

    //
    // Setup transforms.
    //

    vSetSize(hwnd);

    return hrc;
}

/******************************Public*Routine******************************\
* vSetSize
*
* Setup the OpenGL transforms.
*
\**************************************************************************/

VOID vSetSize(HWND hwnd)
{
    RECT rc;

    GetClientRect(hwnd, &rc);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.5, 20.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glTranslatef(OffsetX, OffsetY, OffsetZ);

    glViewport(0, 0, WINDSIZEX(rc)/gulZoom, WINDSIZEY(rc)/gulZoom);
}

/******************************Public*Routine******************************\
* vCleanupGL
*
* Release all the various OpenGL resources.
*
\**************************************************************************/

void vCleanupGL(HDC hdc, HGLRC hrc)
{
    if (ghPalette)
        DeleteObject(SelectObject(ghdcMem, ghpalOld));

    wglDeleteContext( hrc );

    DeleteObject(SelectObject(ghdcMem, ghbmOld));
    DeleteDC(ghdcMem);

    //!!!dbug
    //SetSystemPaletteUse(hdc, SYSPAL_STATIC);
}

/******************************Public*Routine******************************\
* vDraw
*
* Draw the current frame.
*
\**************************************************************************/

void vDraw(HWND hwnd, HDC hdc)
{
    RECT rc;

    //
    // Clear the buffer.
    //

    glClear(GL_COLOR_BUFFER_BIT);

    //
    // Save current transform.
    //

    glPushMatrix();

        //
        // Rotate transform to current orientation.
        //

        glRotatef(AngleX, ONE, ZERO, ZERO);
        glRotatef(AngleY, ZERO, ONE, ZERO);
        glRotatef(AngleZ, ZERO, ZERO, ONE);

        //
        // Draw the cube display list.
        //

        glCallList(DListCube);

    //
    // Restore the transform.
    //

    glPopMatrix();

    //
    // Flush OpenGL queque.
    //

    glFlush();

    //
    // Update the window from our bitmap.
    //

    GetClientRect(hwnd, &rc);
    if (gulZoom == 1)
    {
        BitBlt(hdc, 0, 0, rc.right-rc.left, rc.bottom-rc.top,
               ghdcMem, 0, 0, SRCCOPY);
    }
    else
    {
        StretchBlt(hdc, 0, 0, rc.right, rc.bottom,
                   ghdcMem, 0, 0, rc.right/gulZoom, rc.bottom/gulZoom,
                   SRCCOPY);
    }

    //
    // Flush GDI queque.
    //

    GdiFlush();

//!!!dbug
if (FALSE)
{
    static BOOL bOnce = TRUE;
    if (bOnce)
    {
        printmemdc(ghdcMem);
        bOnce = FALSE;
    }
}

    //
    // Accumulate statistics.  Every 16 frames, print out the frames/sec.
    // Statistics can be reset by forcing bResetStats TRUE.
    //

    if (bResetStats)
    {
        _ftime( &baseTime );
        frameCount = 0;
        bResetStats = FALSE;
    }
    else
    {
        frameCount++;
    }

    if ( !(frameCount & 0x0000000f) )
    {
        TCHAR ach[256];
        double elapsed;

        _ftime( &thisTime );
        elapsed = thisTime.time + thisTime.millitm/1000.0 -
                  (baseTime.time + baseTime.millitm/1000.0);
        if( elapsed != 0.0 )
        {
            int frameRate;
            frameRate = (int) (100.0 * (frameCount / elapsed));
            wsprintf(ach, TEXT("%ld.%02ld fps"), frameRate/100, frameRate%100 );
            SetWindowText(hwnd, ach);
        }
    }
}

/******************************Public*Routine******************************\
* MyCreateCompatibleDC
*
*
* Effects:
*
* Warnings:
*
* History:
*  25-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HDC MyCreateCompatibleDC(HDC hdc)
{
    HDC hdcRet;
    HPALETTE hpal, hpalMem;
    int nEntries;

    hdcRet = CreateCompatibleDC(hdc);

    if (!hdcRet)
    {
        DbgPrint("MyCreateCompatibleDC: CreateCompatibleDC failed\n");
    }

    //hpal = GetCurrentObject(hdc, OBJ_PAL);

    //nEntries = GetPaletteEntries(hpal, 0, 0, NULL);
    nEntries = GetSystemPaletteEntries(hdc, 0, 0, NULL);
    if (nEntries)
    {
        LOGPALETTE *ppal;

        ppal = LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) + (nEntries * sizeof(PALETTEENTRY)));
        if (ppal)
        {
            ppal->palVersion = 0x300;
            ppal->palNumEntries = nEntries;

            //GetPaletteEntries(hpal, 0, nEntries, ppal->palPalEntry);
            GetSystemPaletteEntries(hdc, 0, nEntries, ppal->palPalEntry);
            hpalMem = CreatePalette(ppal);

            if (!SelectPalette(hdcRet, hpalMem, FALSE) ||
                !RealizePalette(hdcRet))
            {
                DbgPrint("MyCreateCompatibleDC: palette error\n");
            }
        }
        else
        {
            DbgPrint("MyCreateCompatibleDC: memalloc error\n");
        }
    }
    else
    {
        DbgPrint("MyCreateCompatibleDC: bad pal size\n");
    }

    return hdcRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\capimips.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>

#include <nturtl.h>
#include <windows.h>
#include <winddi.h>

#include <ksmips.h>
#include "glteb.h"
#include <GL/gl.h>
#include <gldrv.h>

/***************************************************
 *                                                 *
 *  Client API generator for MIPS (capimips)       *
 *                                                 *
 ***************************************************/

/*
 *  from /nt/private/windows/gdi/opengl/inc/glteb.h:
 *
 *      #define GLTEB_CLTDISPATCHTABLE
 *          ((PGLDISPATCHTABLE)(NtCurrentTeb()->glDispatchTable))
 *
 *  from /nt/public/sdk/inc/ntmips.h:#define NtCurrentTeb() ((PTEB)(PCR->Teb))
 *
 *      #define NtCurrentTeb() ((PTEB)(USER_PCR->Teb))
 *
 *  Define Address of Processor Control Registers.
 *
 *      #define USPCR 0x7ffff000            // user address of PCR
 *
 *  Define Pointer to Processor Control Registers.
 *
 *      #define USER_PCR ((KPCR * const)USPCR)
 *
 */

/*
 *  The compiler generated the the following code:
 *
 *  glNewList:
 *    00000000: 27BDFFE8 addiu       sp,sp,FFE8
 *    00000004: AFBF0014 sw          ra,0014(sp)
 *    00000008: 3C0E8000 lui         t6,8000
 *    0000000C: 8DCFF4A8 lw          t7,F4A8(t6)
 *    00000010: 8DF80714 lw          t8,0714(t7)
 *    00000014: 0300F809 jalr        ra,t8
 *    00000018: 00000000 nop
 *    0000001C: 8FBF0014 lw          ra,0014(sp)
 *    00000020: 03E00008 jr          ra
 *    00000024: 27BD0018 addiu       sp,sp,0018
 *    00000028: 00000000 nop
 *    0000002C: 00000000 nop
 *
 *  glMap2d:
 *    00000000: 27BDFFB8 addiu       sp,sp,FFB8
 *    00000004: AFBF0044 sw          ra,0044(sp)
 *    00000008: 44866000 mtc1        a2,$12
 *    0000000C: 44876800 mtc1        a3,$13
 *    00000010: 00000000 nop
 *    00000014: D7A40058 ldc1        $4,0058(sp)
 *    00000018: 3C098000 lui         t1,8000
 *    0000001C: 8FAE0060 lw          t6,0060(sp)
 *    00000020: 8FAF0064 lw          t7,0064(sp)
 *    00000024: D7A60068 ldc1        $6,0068(sp)
 *    00000028: D7A80070 ldc1        $8,0070(sp)
 *    0000002C: 8FB80078 lw          t8,0078(sp)
 *    00000030: 8FB9007C lw          t9,007C(sp)
 *    00000034: 8FA80080 lw          t0,0080(sp)
 *    00000038: F7A40010 sdc1        $4,0010(sp)
 *    0000003C: AFAE0018 sw          t6,0018(sp)
 *    00000040: AFAF001C sw          t7,001C(sp)
 *    00000044: F7A60020 sdc1        $6,0020(sp)
 *    00000048: F7A80028 sdc1        $8,0028(sp)
 *    0000004C: AFB80030 sw          t8,0030(sp)
 *    00000050: AFB90034 sw          t9,0034(sp)
 *    00000054: AFA80038 sw          t0,0038(sp)
 *    00000058: 8D2AF4A8 lw          t2,F4A8(t1)
 *    0000005C: 44066000 mfc1        a2,$12
 *    00000060: 44076800 mfc1        a3,$13
 *    00000064: 8D4B0A8C lw          t3,0A8C(t2)
 *    00000068: 0160F809 jalr        ra,t3
 *    0000006C: 00000000 nop
 *    00000070: 8FBF0044 lw          ra,0044(sp)
 *    00000074: 03E00008 jr          ra
 *    00000078: 27BD0048 addiu       sp,sp,0048
 *    0000007C: 00000000 nop
 *
 *  Summary:
 *
 *      C Version:                  Assembly version:
 *
 *      A0F0 .debug$S                 5C .debug$S
 *      425C .debug$T
 *      17E8 .pdata
 *      3ED0 .text                  17F0 .text
 */

#define PAGE_AFTER_LAST         0x80000000
#define OFFSET_FROM_PAGE        (PAGE_AFTER_LAST - (size_t)USER_PCR)
#define ADD_DEBUG_FORMATION
#define JUSTDOIT(x)                 Do( #x, offsetof(GLDISPATCHTABLE, x))

void Do( char *Func, size_t Fo );
void PrintEntryMacro( void );

void
main ( int argc, char **argv )
{
    printf("\n");
    printf("//////////////////////////////////////////////////////////\n");
    printf("//     This file was generated by %s\n", *argv);
    printf("//             DO NOT MODIFY\n");
    printf("//////////////////////////////////////////////////////////\n");
    printf("\n");
    printf("#include \"ksmips.h\"\n\n");

    PrintEntryMacro();

    JUSTDOIT( glNewList                 );
    JUSTDOIT( glEndList                 );
    JUSTDOIT( glCallList                );
    JUSTDOIT( glCallLists               );
    JUSTDOIT( glDeleteLists             );
    JUSTDOIT( glGenLists                );
    JUSTDOIT( glListBase                );
    JUSTDOIT( glBegin                   );
    JUSTDOIT( glBitmap                  );
    JUSTDOIT( glColor3b                 );
    JUSTDOIT( glColor3bv                );
    JUSTDOIT( glColor3d                 );
    JUSTDOIT( glColor3dv                );
    JUSTDOIT( glColor3f                 );
    JUSTDOIT( glColor3fv                );
    JUSTDOIT( glColor3i                 );
    JUSTDOIT( glColor3iv                );
    JUSTDOIT( glColor3s                 );
    JUSTDOIT( glColor3sv                );
    JUSTDOIT( glColor3ub                );
    JUSTDOIT( glColor3ubv               );
    JUSTDOIT( glColor3ui                );
    JUSTDOIT( glColor3uiv               );
    JUSTDOIT( glColor3us                );
    JUSTDOIT( glColor3usv               );
    JUSTDOIT( glColor4b                 );
    JUSTDOIT( glColor4bv                );
    JUSTDOIT( glColor4d                 );
    JUSTDOIT( glColor4dv                );
    JUSTDOIT( glColor4f                 );
    JUSTDOIT( glColor4fv                );
    JUSTDOIT( glColor4i                 );
    JUSTDOIT( glColor4iv                );
    JUSTDOIT( glColor4s                 );
    JUSTDOIT( glColor4sv                );
    JUSTDOIT( glColor4ub                );
    JUSTDOIT( glColor4ubv               );
    JUSTDOIT( glColor4ui                );
    JUSTDOIT( glColor4uiv               );
    JUSTDOIT( glColor4us                );
    JUSTDOIT( glColor4usv               );
    JUSTDOIT( glEdgeFlag                );
    JUSTDOIT( glEdgeFlagv               );
    JUSTDOIT( glEnd                     );
    JUSTDOIT( glIndexd                  );
    JUSTDOIT( glIndexdv                 );
    JUSTDOIT( glIndexf                  );
    JUSTDOIT( glIndexfv                 );
    JUSTDOIT( glIndexi                  );
    JUSTDOIT( glIndexiv                 );
    JUSTDOIT( glIndexs                  );
    JUSTDOIT( glIndexsv                 );
    JUSTDOIT( glNormal3b                );
    JUSTDOIT( glNormal3bv               );
    JUSTDOIT( glNormal3d                );
    JUSTDOIT( glNormal3dv               );
    JUSTDOIT( glNormal3f                );
    JUSTDOIT( glNormal3fv               );
    JUSTDOIT( glNormal3i                );
    JUSTDOIT( glNormal3iv               );
    JUSTDOIT( glNormal3s                );
    JUSTDOIT( glNormal3sv               );
    JUSTDOIT( glRasterPos2d             );
    JUSTDOIT( glRasterPos2dv            );
    JUSTDOIT( glRasterPos2f             );
    JUSTDOIT( glRasterPos2fv            );
    JUSTDOIT( glRasterPos2i             );
    JUSTDOIT( glRasterPos2iv            );
    JUSTDOIT( glRasterPos2s             );
    JUSTDOIT( glRasterPos2sv            );
    JUSTDOIT( glRasterPos3d             );
    JUSTDOIT( glRasterPos3dv            );
    JUSTDOIT( glRasterPos3f             );
    JUSTDOIT( glRasterPos3fv            );
    JUSTDOIT( glRasterPos3i             );
    JUSTDOIT( glRasterPos3iv            );
    JUSTDOIT( glRasterPos3s             );
    JUSTDOIT( glRasterPos3sv            );
    JUSTDOIT( glRasterPos4d             );
    JUSTDOIT( glRasterPos4dv            );
    JUSTDOIT( glRasterPos4f             );
    JUSTDOIT( glRasterPos4fv            );
    JUSTDOIT( glRasterPos4i             );
    JUSTDOIT( glRasterPos4iv            );
    JUSTDOIT( glRasterPos4s             );
    JUSTDOIT( glRasterPos4sv            );
    JUSTDOIT( glRectd                   );
    JUSTDOIT( glRectdv                  );
    JUSTDOIT( glRectf                   );
    JUSTDOIT( glRectfv                  );
    JUSTDOIT( glRecti                   );
    JUSTDOIT( glRectiv                  );
    JUSTDOIT( glRects                   );
    JUSTDOIT( glRectsv                  );
    JUSTDOIT( glTexCoord1d              );
    JUSTDOIT( glTexCoord1dv             );
    JUSTDOIT( glTexCoord1f              );
    JUSTDOIT( glTexCoord1fv             );
    JUSTDOIT( glTexCoord1i              );
    JUSTDOIT( glTexCoord1iv             );
    JUSTDOIT( glTexCoord1s              );
    JUSTDOIT( glTexCoord1sv             );
    JUSTDOIT( glTexCoord2d              );
    JUSTDOIT( glTexCoord2dv             );
    JUSTDOIT( glTexCoord2f              );
    JUSTDOIT( glTexCoord2fv             );
    JUSTDOIT( glTexCoord2i              );
    JUSTDOIT( glTexCoord2iv             );
    JUSTDOIT( glTexCoord2s              );
    JUSTDOIT( glTexCoord2sv             );
    JUSTDOIT( glTexCoord3d              );
    JUSTDOIT( glTexCoord3dv             );
    JUSTDOIT( glTexCoord3f              );
    JUSTDOIT( glTexCoord3fv             );
    JUSTDOIT( glTexCoord3i              );
    JUSTDOIT( glTexCoord3iv             );
    JUSTDOIT( glTexCoord3s              );
    JUSTDOIT( glTexCoord3sv             );
    JUSTDOIT( glTexCoord4d              );
    JUSTDOIT( glTexCoord4dv             );
    JUSTDOIT( glTexCoord4f              );
    JUSTDOIT( glTexCoord4fv             );
    JUSTDOIT( glTexCoord4i              );
    JUSTDOIT( glTexCoord4iv             );
    JUSTDOIT( glTexCoord4s              );
    JUSTDOIT( glTexCoord4sv             );
    JUSTDOIT( glVertex2d                );
    JUSTDOIT( glVertex2dv               );
    JUSTDOIT( glVertex2f                );
    JUSTDOIT( glVertex2fv               );
    JUSTDOIT( glVertex2i                );
    JUSTDOIT( glVertex2iv               );
    JUSTDOIT( glVertex2s                );
    JUSTDOIT( glVertex2sv               );
    JUSTDOIT( glVertex3d                );
    JUSTDOIT( glVertex3dv               );
    JUSTDOIT( glVertex3f                );
    JUSTDOIT( glVertex3fv               );
    JUSTDOIT( glVertex3i                );
    JUSTDOIT( glVertex3iv               );
    JUSTDOIT( glVertex3s                );
    JUSTDOIT( glVertex3sv               );
    JUSTDOIT( glVertex4d                );
    JUSTDOIT( glVertex4dv               );
    JUSTDOIT( glVertex4f                );
    JUSTDOIT( glVertex4fv               );
    JUSTDOIT( glVertex4i                );
    JUSTDOIT( glVertex4iv               );
    JUSTDOIT( glVertex4s                );
    JUSTDOIT( glVertex4sv               );
    JUSTDOIT( glClipPlane               );
    JUSTDOIT( glColorMaterial           );
    JUSTDOIT( glCullFace                );
    JUSTDOIT( glFogf                    );
    JUSTDOIT( glFogfv                   );
    JUSTDOIT( glFogi                    );
    JUSTDOIT( glFogiv                   );
    JUSTDOIT( glFrontFace               );
    JUSTDOIT( glHint                    );
    JUSTDOIT( glLightf                  );
    JUSTDOIT( glLightfv                 );
    JUSTDOIT( glLighti                  );
    JUSTDOIT( glLightiv                 );
    JUSTDOIT( glLightModelf             );
    JUSTDOIT( glLightModelfv            );
    JUSTDOIT( glLightModeli             );
    JUSTDOIT( glLightModeliv            );
    JUSTDOIT( glLineStipple             );
    JUSTDOIT( glLineWidth               );
    JUSTDOIT( glMaterialf               );
    JUSTDOIT( glMaterialfv              );
    JUSTDOIT( glMateriali               );
    JUSTDOIT( glMaterialiv              );
    JUSTDOIT( glPointSize               );
    JUSTDOIT( glPolygonMode             );
    JUSTDOIT( glPolygonStipple          );
    JUSTDOIT( glScissor                 );
    JUSTDOIT( glShadeModel              );
    JUSTDOIT( glTexParameterf           );
    JUSTDOIT( glTexParameterfv          );
    JUSTDOIT( glTexParameteri           );
    JUSTDOIT( glTexParameteriv          );
    JUSTDOIT( glTexImage1D              );
    JUSTDOIT( glTexImage2D              );
    JUSTDOIT( glTexEnvf                 );
    JUSTDOIT( glTexEnvfv                );
    JUSTDOIT( glTexEnvi                 );
    JUSTDOIT( glTexEnviv                );
    JUSTDOIT( glTexGend                 );
    JUSTDOIT( glTexGendv                );
    JUSTDOIT( glTexGenf                 );
    JUSTDOIT( glTexGenfv                );
    JUSTDOIT( glTexGeni                 );
    JUSTDOIT( glTexGeniv                );
    JUSTDOIT( glFeedbackBuffer          );
    JUSTDOIT( glSelectBuffer            );
    JUSTDOIT( glRenderMode              );
    JUSTDOIT( glInitNames               );
    JUSTDOIT( glLoadName                );
    JUSTDOIT( glPassThrough             );
    JUSTDOIT( glPopName                 );
    JUSTDOIT( glPushName                );
    JUSTDOIT( glDrawBuffer              );
    JUSTDOIT( glClear                   );
    JUSTDOIT( glClearAccum              );
    JUSTDOIT( glClearIndex              );
    JUSTDOIT( glClearColor              );
    JUSTDOIT( glClearStencil            );
    JUSTDOIT( glClearDepth              );
    JUSTDOIT( glStencilMask             );
    JUSTDOIT( glColorMask               );
    JUSTDOIT( glDepthMask               );
    JUSTDOIT( glIndexMask               );
    JUSTDOIT( glAccum                   );
    JUSTDOIT( glDisable                 );
    JUSTDOIT( glEnable                  );
    JUSTDOIT( glFinish                  );
    JUSTDOIT( glFlush                   );
    JUSTDOIT( glPopAttrib               );
    JUSTDOIT( glPushAttrib              );
    JUSTDOIT( glMap1d                   );
    JUSTDOIT( glMap1f                   );
    JUSTDOIT( glMap2d                   );
    JUSTDOIT( glMap2f                   );
    JUSTDOIT( glMapGrid1d               );
    JUSTDOIT( glMapGrid1f               );
    JUSTDOIT( glMapGrid2d               );
    JUSTDOIT( glMapGrid2f               );
    JUSTDOIT( glEvalCoord1d             );
    JUSTDOIT( glEvalCoord1dv            );
    JUSTDOIT( glEvalCoord1f             );
    JUSTDOIT( glEvalCoord1fv            );
    JUSTDOIT( glEvalCoord2d             );
    JUSTDOIT( glEvalCoord2dv            );
    JUSTDOIT( glEvalCoord2f             );
    JUSTDOIT( glEvalCoord2fv            );
    JUSTDOIT( glEvalMesh1               );
    JUSTDOIT( glEvalPoint1              );
    JUSTDOIT( glEvalMesh2               );
    JUSTDOIT( glEvalPoint2              );
    JUSTDOIT( glAlphaFunc               );
    JUSTDOIT( glBlendFunc               );
    JUSTDOIT( glLogicOp                 );
    JUSTDOIT( glStencilFunc             );
    JUSTDOIT( glStencilOp               );
    JUSTDOIT( glDepthFunc               );
    JUSTDOIT( glPixelZoom               );
    JUSTDOIT( glPixelTransferf          );
    JUSTDOIT( glPixelTransferi          );
    JUSTDOIT( glPixelStoref             );
    JUSTDOIT( glPixelStorei             );
    JUSTDOIT( glPixelMapfv              );
    JUSTDOIT( glPixelMapuiv             );
    JUSTDOIT( glPixelMapusv             );
    JUSTDOIT( glReadBuffer              );
    JUSTDOIT( glCopyPixels              );
    JUSTDOIT( glReadPixels              );
    JUSTDOIT( glDrawPixels              );
    JUSTDOIT( glGetBooleanv             );
    JUSTDOIT( glGetClipPlane            );
    JUSTDOIT( glGetDoublev              );
    JUSTDOIT( glGetError                );
    JUSTDOIT( glGetFloatv               );
    JUSTDOIT( glGetIntegerv             );
    JUSTDOIT( glGetLightfv              );
    JUSTDOIT( glGetLightiv              );
    JUSTDOIT( glGetMapdv                );
    JUSTDOIT( glGetMapfv                );
    JUSTDOIT( glGetMapiv                );
    JUSTDOIT( glGetMaterialfv           );
    JUSTDOIT( glGetMaterialiv           );
    JUSTDOIT( glGetPixelMapfv           );
    JUSTDOIT( glGetPixelMapuiv          );
    JUSTDOIT( glGetPixelMapusv          );
    JUSTDOIT( glGetPolygonStipple       );
    JUSTDOIT( glGetString               );
    JUSTDOIT( glGetTexEnvfv             );
    JUSTDOIT( glGetTexEnviv             );
    JUSTDOIT( glGetTexGendv             );
    JUSTDOIT( glGetTexGenfv             );
    JUSTDOIT( glGetTexGeniv             );
    JUSTDOIT( glGetTexImage             );
    JUSTDOIT( glGetTexParameterfv       );
    JUSTDOIT( glGetTexParameteriv       );
    JUSTDOIT( glGetTexLevelParameterfv  );
    JUSTDOIT( glGetTexLevelParameteriv  );
    JUSTDOIT( glIsEnabled               );
    JUSTDOIT( glIsList                  );
    JUSTDOIT( glDepthRange              );
    JUSTDOIT( glFrustum                 );
    JUSTDOIT( glLoadIdentity            );
    JUSTDOIT( glLoadMatrixf             );
    JUSTDOIT( glLoadMatrixd             );
    JUSTDOIT( glMatrixMode              );
    JUSTDOIT( glMultMatrixf             );
    JUSTDOIT( glMultMatrixd             );
    JUSTDOIT( glOrtho                   );
    JUSTDOIT( glPopMatrix               );
    JUSTDOIT( glPushMatrix              );
    JUSTDOIT( glRotated                 );
    JUSTDOIT( glRotatef                 );
    JUSTDOIT( glScaled                  );
    JUSTDOIT( glScalef                  );
    JUSTDOIT( glTranslated              );
    JUSTDOIT( glTranslatef              );
    JUSTDOIT( glViewport                );
}

void
oDo( char *Func, size_t Fo )
{
    /*
     *  This code will generate the following code:
     *
     *  glNewList:
     *    00000000: 3C0E8000 lui         t6,8000
     *    00000004: 8DCFF4A8 lw          t7,F4A8(t6)
     *    00000008: 8DF80714 lw          t8,0714(t7)
     *    0000000C: 03000008 jr          t8
     *    00000010: 00000000 nop
     */

    printf("    .text\n");
    printf("    .align 2\n");

#ifdef ADD_DEBUG_FORMATION
    printf("    .ent %s\n", Func);
#endif

    printf("    .globl %s\n", Func);


    printf("    li      $14, 0x%lX\n", PAGE_AFTER_LAST );
    printf("    lw      $15, 0x%lX($14)\n",
                                offsetof(KPCR, Teb) - OFFSET_FROM_PAGE );
    printf("    lw      $24, 0x%lX($15)\n", offsetof(TEB, glDispatchTable)+Fo);
    printf("    j       $24\n");

#ifdef ADD_DEBUG_FORMATION
    printf("    .end\n");
#endif

    printf("\n");
}

void
Do( char *Func, size_t Fo )
{
    /*
     *  This code will generate the following code:
     *
     *  glNewList:
     *    00000000: 3C0E8000 lui         t6,8000
     *    00000004: 8DCFF4A8 lw          t7,F4A8(t6)
     *    00000008: 8DF80714 lw          t8,0714(t7)
     *    0000000C: 03000008 jr          t8
     *    00000010: 00000000 nop
     */

    printf("    GL_TABLE_ENTRY(%s)\n", Func);
    printf("    lw      t7, UsPcr + PcTeb\n");
    printf("    lw      t8,TeglDispatchTable + 0x%lX(t7)\n", Fo); 
    printf("    j       t8\n");

#ifdef ADD_DEBUG_FORMATION
    printf("    .end\n");
#endif

    printf("\n");
}

void
PrintEntryMacro(void)
{
    printf("#define GL_TABLE_ENTRY(Name)            \\\n");
    printf("        .text;                          \\\n");
    printf("        .align  2;                      \\\n");
    printf("        .globl  Name;                   \\\n");
    printf("        .ent    Name, 0;                \\\n");
    printf("Name:;                                  \\\n");
    printf("        .frame  sp, 0, ra;              \\\n");
    printf("        .prologue 0;\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\hex2d.c ===
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int __cdecl main(int argc, char **argv)
{
    unsigned long ul[2];
    double *pf;

    if (argc <= 1)
        printf("usage: hex2f [32-bit hex number] ==> output is float val\n");
    else
    {
        ul[1] = strtoul(argv[1], 0, 16);
        ul[0] = strtoul(argv[2], 0, 16);
        pf = (double *) ul;

        printf("0x%08lx%08lx = %.50f", ul[1], ul[0], *pf);
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\hex2f.c ===
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int __cdecl main(int argc, char **argv)
{
    unsigned long ul;
    float *pf;

    if (argc <= 1)
        printf("usage: hex2f [32-bit hex number] ==> output is float val\n");
    else
    {
        ul = strtoul(argv[1], 0, 16);
        pf = (float *) &ul;

    if (*pf == 0.0)
        return 0;

    if (*pf == -0.0)
        return 2;

        printf("0x%08lx = %f", ul, *pf);
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\win8map.c ===
/*
 * win8map.c - program to create an 8 bit RGB color map for OpenGL use
 *
 * OpenGL RGB rendering needs to know red, green, & blue component bit
 * sizes and positions.  On 8 bit palette devices you need to create a 
 * logical palette that has the correct RGB values for all 256 possible 
 * entries.  This program will create an 8 bit RGB color cube with a 
 * default gamma of 1.4.
 *
 * Unfortunately, if you select this palette into an 8 bit display DC, you
 * will not realize all of the logical palette.  This is because the standard
 * 20 colors in the system palette cannot be changed.  This program changes
 * some of the entries in the logical palette to match enties in the system
 * palette.  The program does a least squares calculation to find the
 * enties to replace.
 *
 *
 *
 * Note:  Three bits for red & green, two for blue, red is lsb, blue msb
 */

#include <stdio.h>
#include <math.h>

#define DEFAULT_GAMMA 1.4F

#define MAX_PAL_ERROR (3*256*256L)

struct colorentry {
    unsigned char red;
    unsigned char green;
    unsigned char blue;
};

struct rampentry {
    struct colorentry color;
    long defaultindex;
    unsigned char flags;
};


struct defaultentry {
    struct colorentry color;
    long rampindex;
    unsigned char flags;
};

/* values for flags */
#define EXACTMATCH      0x01
#define CHANGED         0x02        /* one of the default entries is close */

/*
 * These arrays hold bit arrays with a gamma of 1.0 
 * used to convert n bit values to 8 bit values
 */
 
unsigned char threeto8[8] = {
    0, 0111>>1, 0222>>1, 0333>>1, 0444>>1, 0555>>1, 0666>>1, 0377
};

unsigned char twoto8[4] = {
    0, 0x55, 0xaa, 0xff
};

unsigned char oneto8[2] = {
    0, 255
};

struct defaultentry defaultpal[20] = {
    { 0,   0,   0 },
    { 0x80,0,   0 },
    { 0,   0x80,0 },
    { 0x80,0x80,0 },
    { 0,   0,   0x80 },
    { 0x80,0,   0x80 },
    { 0,   0x80,0x80 },
    { 0xC0,0xC0,0xC0 },

    { 192, 220, 192 },
    { 166, 202, 240 },
    { 255, 251, 240 },
    { 160, 160, 164 },

    { 0x80,0x80,0x80 },
    { 0xFF,0,   0 },
    { 0,   0xFF,0 },
    { 0xFF,0xFF,0 },
    { 0,   0,   0xFF },
    { 0xFF,0,   0xFF },
    { 0,   0xFF,0xFF },
    { 0xFF,0xFF,0xFF }
};

struct rampentry rampmap[256];
 
void
gammacorrect(double gamma)
{
    int i;
    unsigned char v, nv;
    double dv;

    for (i=0; i<8; i++) {
        v = threeto8[i];
        dv = (255.0 * pow(v/255.0, 1.0/gamma)) + 0.5;
    nv = (unsigned char)dv;
    printf("Gamma correct %d to %d (gamma %.2f)\n", v, nv, gamma);
        threeto8[i] = nv;
    }
    for (i=0; i<4; i++) {
        v = twoto8[i];
        dv = (255.0 * pow(v/255.0, 1.0/gamma)) + 0.5;
    nv = (unsigned char)dv;
    printf("Gamma correct %d to %d (gamma %.2f)\n", v, nv, gamma);
        twoto8[i] = nv;
    }
    printf("\n");
}

main(int argc, char *argv[])
{
    long i, j, error, min_error;
    long error_index, delta;
    double gamma;
    struct colorentry *pc;
 
    if (argc == 2)
        gamma = atof(argv[1]);
    else
        gamma = DEFAULT_GAMMA;

    gammacorrect(gamma);
      
    /* First create a 256 entry RGB color cube */
    
    for (i = 0; i < 256; i++) {
        /* BGR: 2:3:3 */
        rampmap[i].color.red = threeto8[(i&7)];
        rampmap[i].color.green = threeto8[((i>>3)&7)];
        rampmap[i].color.blue = twoto8[(i>>6)&3];
    }

    /* Go through the default palette and find exact matches */
    for (i=0; i<20; i++) {
        for(j=0; j<256; j++) {
            if ( (defaultpal[i].color.red == rampmap[j].color.red) &&
                 (defaultpal[i].color.green == rampmap[j].color.green) &&
                 (defaultpal[i].color.blue == rampmap[j].color.blue)) {

                rampmap[j].flags = EXACTMATCH;
                rampmap[j].defaultindex = i;
                defaultpal[i].rampindex = j;
                defaultpal[i].flags = EXACTMATCH;
                break;
            } 
        }
    }

    /* Now find close matches */            
    for (i=0; i<20; i++) {
        if (defaultpal[i].flags == EXACTMATCH)
            continue;                       /* skip entries w/ exact matches */
        min_error = MAX_PAL_ERROR;
        
        /* Loop through RGB ramp and calculate least square error */
        /* if an entry has already been used, skip it */
        for(j=0; j<256; j++) {
            if (rampmap[j].flags != 0)      /* Already used */
                continue;
                
            delta = defaultpal[i].color.red - rampmap[j].color.red;
            error = (delta * delta);
            delta = defaultpal[i].color.green - rampmap[j].color.green;
            error += (delta * delta);
            delta = defaultpal[i].color.blue - rampmap[j].color.blue;
            error += (delta * delta);
            if (error < min_error) {        /* New minimum? */
                error_index = j;
                min_error = error;
            }
        }
        defaultpal[i].rampindex = error_index;
        rampmap[error_index].flags = CHANGED;
        rampmap[error_index].defaultindex = i;
    }
    
    /* First print out the color cube */ 
    
    printf("Standard 8 bit RGB color cube with gamma %.2f:\n", gamma);
    for (i=0; i<256; i++) {
        pc = &rampmap[i].color; 
        printf("%3ld: (%3d, %3d, %3d)\n", i, pc->red, pc->green, pc->blue);
    
    }
    printf("\n");
    
    /* Now print out the default entries that have an exact match */

    for (i=0; i<20; i++) {
        if (defaultpal[i].flags == EXACTMATCH) {
            pc = &defaultpal[i].color; 
            printf("Default entry %2ld exactly matched RGB ramp entry %3ld",
                  i, defaultpal[i].rampindex);
            printf(" (%3d, %3d, %3d)\n", pc->red, pc->green, pc->blue);
        }
    }
    printf("\n");
    
    /* Now print out the closet entries for rest of the default entries */
    
    for (i=0; i<20; i++) {
        if (defaultpal[i].flags != EXACTMATCH) {
            pc = &defaultpal[i].color; 
            printf("Default entry %2ld (%3d, %3d, %3d) is close to ",
                i, pc->red, pc->green, pc->blue);
            pc = &rampmap[defaultpal[i].rampindex].color;
            printf("RGB ramp entry %3ld (%3d, %3d, %3d)\n",
                defaultpal[i].rampindex, pc->red, pc->green, pc->blue);
        }
    }
    printf("\n");
    
    /* Print out code to initialize a logical palette that will not overflow */

    printf("Here is code you can use to create a logical palette\n");

    printf("static struct {\n");
    printf("    WORD        palVersion;\n");
    printf("    WORD        palNumEntries;\n");
    printf("    PALETTEENTRY palPalEntries[256];\n");
    printf("} rgb8palette = {\n");
    printf("    0x300,\n");
    printf("    256,\n");

    for (i=0; i<256; i++) { 
        if (rampmap[i].flags == 0)
            pc = &rampmap[i].color;
        else
            pc = &defaultpal[rampmap[i].defaultindex].color;
        
        printf("    %3d, %3d, %3d,   0,    /* %ld",
                pc->red, pc->green, pc->blue, i); 
        if (rampmap[i].flags == EXACTMATCH)
            printf(" - Exact match with default %d", rampmap[i].defaultindex);
        if (rampmap[i].flags == CHANGED)
            printf(" - Changed to match default %d", rampmap[i].defaultindex);
        printf(" */\n");
    }

    printf("};\n");
    printf("\n    * * *\n\n");
    printf("    hpal = CreatePalette((LOGPALETTE *)&rgb8palette);\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\floattst.c ===
#include <stdio.h>
#include <math.h>

/*
 * During the development of OpenGL on NT, we have had problems
 * with the compiler and floating point.  Here are a few simple
 * sanity checks to make sure the compiler didn't regress.
 */

#define POW_TEST                                \
    /* pow(0,0) should be 1 not 0 */            \
    f =  (float)pow(0.0, 0.0);                  \
    printf("pow(0.0, 0.0) is %f ", f);          \
    if (f == 1.0F) {                            \
        printf("Correct\n");                    \
    } else {                                    \
        printf("ERROR\n");                      \
        errorcount++;                           \
    }

#define FLOOR_TEST                              \
    /* floor() would always return 0! */        \
    d = floor(8.123);                           \
    printf("floor(8.123) is %lf ", d);          \
    if (d == 8.0) {                             \
        printf("Correct\n");                    \
    } else {                                    \
        printf("ERROR\n");                      \
        errorcount++;                           \
    }                                           \
    d = floor(63.5);                            \
    printf("floor(63.5) is %lf ", d);           \
    if (d == 63.0) {                            \
        printf("Correct\n");                    \
    } else {                                    \
        printf("ERROR\n");                      \
        errorcount++;                           \
    }

int nointrin(void);
int CastTest(void);

main()
{
    float f;
    double d;
    int errorcount = 0;

    f =  (float)pow(0.0, 3.0);
    if (f != 0.0F) {
        printf("pow(0.0, 3.0) not 0.0!  ERROR\n");
        errorcount++;
    } else {
        printf("pow(0.0, 3.0) is 0.0  Correct\n");
    }

    POW_TEST;

    FLOOR_TEST;

    errorcount += CastTest();

    errorcount += nointrin();

    if (errorcount)
        printf("%d errors in test\n", errorcount);
    else
        printf("\nAll tests passed\n");

    return errorcount;
}

int
CastTest()
{
    double dMaxUint;
    unsigned int uiResult;

    dMaxUint = 4294967295.0;

    uiResult = (unsigned int)dMaxUint;

    printf("uiResult(0x%08lX) = (unsigned int)dMaxUint(%lf) ",
        uiResult, dMaxUint);
    if (uiResult == 0xffffffff) {
        printf("Correct\n");
        return 0;
    } else {
        printf("ERROR\n");
        return 1;
    }
}

#pragma function (pow)
#pragma function (floor)
int
nointrin()
{
    float f;
    double d;
    int errorcount = 0;

    printf("\n\nNot using intrinsic functions for:\n");
    printf("pow()\n");
    printf("floor()\n");
    printf("\n");

    POW_TEST;

    FLOOR_TEST;

    return errorcount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\mcdtab\addon.h ===
// Common strings

#define NO_HELP                         ((DWORD) -1)
#define IDH_COMM_GROUPBOX               28548

// Welcome Help after Setup: Jessev

#define GET_WELCOME			0002

// Enhanced Property Sheet ID's: Shawnb


#define IDH_COMPDRV_TABLE_ULTRA		1002
#define IDH_COMPDRV_TABLE_HIPACK	1003
#define IDH_COMPDRV_TABLE_STD		1004
#define IDH_COMPDRV_TABLE_UNCOMP	1005
#define IDH_COMPDRV_TABLE_FREESP	1006
#define IDH_COMPDRV_TABLE_REDUCED	1007
#define IDH_COMPDRV_PIE                 1008
#define IDH_COMPDRV_TABLE               1009
#define IDH_COMPDRV_RECOMPNOW           1010
#define IDH_COMPDRV_UPGRADENOW		1011
#define IDH_COMPDRV_ADV                 1012
#define IDH_COMPDRV_ADV_HIDEHOST        1013
#define IDH_UNCOMPDRV_COMPDRIVE         1014
#define IDH_UNCOMPDRV_COMPPIE           1015
#define IDH_UNCOMPDRV_CREATENEW         1016
#define IDH_UNCOMPDRV_CREATEPIE         1017
#define IDH_HOSTDRV_PIE                 1018
#define IDH_HOSTDRV_TABLE           	1019
#define IDH_RUN_DRVSPACE                1020
#define IDH_COMPDRV_GAUGE		1021
#define IDH_COMPDRV_TABLE_TOTAL		1022


//ID's for the Theme Picker applet

#define IDH_THEME_LIST			2001		
#define IDH_THEME_SAVEAS		2002
#define IDH_THEME_DELETE		2003
#define IDH_THEME_PREVSCRN		2004
#define IDH_THEME_PREVETC		2005
#define IDH_THEME_PREVIEW		2006
#define IDH_THEME_SCRNSAVER		2007
#define IDH_THEMES_SOUNDS		2008
#define IDH_THEME_POINTERS		2009
#define IDH_THEME_WALLPAPER		2010
#define IDH_THEME_ICONS			2011
#define IDH_THEME_COLORS		2012
#define IDH_THEME_FONTS			2013
#define IDH_THEME_BORDER		2014
#define IDH_THEME_POINTERS_LIST		2015
#define IDH_THEME_POINTERS_PREV		2016
#define IDH_THEME_POINTERS_FILE		2018
#define IDH_THEME_SOUNDS_LIST		2019
#define IDH_THEME_SOUNDS_ICON_PREV	2020
#define IDH_THEME_SOUNDS_PLAYS		2021
#define IDH_THEME_SOUNDS_FILE		2022
#define IDH_THEME_PICS_LIST		2023
#define IDH_THEME_PICS_PREV		2024
#define IDH_THEME_PICS_FILE		2025
// #define IDH_THEME_SAVE_NAME		2026
#define IDH_THEME_ICON_SIZESPACE	2027

// Lens settings ID's

#define IDH_LENS_FLIP			3000		// Temporary
#define IDH_LENS_GLASS_SPHERE		3001
#define IDH_LENS_INSIDE_OUT		3002
#define IDH_LENS_BLACK_HOLE		3003
#define IDH_LENS_DENT			3004
#define IDH_LENS_SPIRAL			3005
#define IDH_LENS_SIZE			3006
#define IDH_LENS_SPEED			3007
#define IDH_LENS_INDEX			3008
#define IDH_LENS_ALTITUDE		3009
#define IDH_LENS_MASS			3010
#define IDH_LENS_HEIGHT			3011
#define IDH_LENS_TWIST			3012
#define IDH_LENS_WALLPAPER		3013

//Blocks settings ID's

#define IDH_BLOCKS_SIZE			3050
#define IDH_BLOCKS_SPEED		3051

//Socha Settings ID's

#define IDH_SCRNSAVER_GEN_MONITOR	3100
#define IDH_SCRNSAVER_GEN_MOUSESEN	3101
#define IDH_SCRNSAVER_GEN_PASSREQUIRED	3102
#define IDH_SCRNSAVER_GEN_ABOUT		3103
#define IDH_SCRNSAVER_PREVIEW		3104
#define IDH_SCRNSAVER_GEN_NOSOUND	3105

// Plus Display Properties ID's

#define IDH_DISPLAY_PLUSPACK_LIST	4300
#define IDH_DISPLAY_PLUSPACK_CHANGEICON	4301
#define IDH_DISPLAY_PLUSPACK_ALLCOLORS	4302
#define IDH_DISPLAY_PLUSPACK_FULLWINDOW	4303
#define IDH_DISPLAY_PLUSPACK_FONTSMOOTH	4304
#define IDH_DISPLAY_PLUSPACK_STRETCH	4305
#define IDH_DISPLAY_PLUSPACK_LARGEICONS	4306
#define IDH_DISPLAY_PLUSPACK_DEFAULT_ICON 4307

// RNA dial-in ID's

#define IDH_RNA_IN_NOACC                4259
#define IDH_RNA_IN_ENABLEACC            4260
#define IDH_RNA_IN_PASSWORD             4263
#define IDH_RNA_IN_COMMENT              4264
#define IDH_RNA_IN_STATUS               4265
#define IDH_RNA_IN_DISCONNECT           4266
#define IDH_RNA_MODEM_SERVER		4275

// Internet Shortcut Target URL

#define IDH_INTERNET_SHORTCUT_TARGET	6001

// Disk Troubleshooter ID's

#define IDH_DSKTRB_FREESPACE		5001
#define IDH_COMPSET_TRB_MAIN            5002    // Must match DOS\DOS86\DBLSPACE\UTILITY\FROSTHLP.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\printpfd.c ===
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <windows.h>

/*
 *  Structures
 */

typedef struct {

    char *Name;
    DWORD Value;

} DWFLAGS;

/*
 *  Prototypes
 */

VOID PrintPixelFormat( HDC Dc, int PixelFormatId );
void PrintRangeOfPixelFormat( HDC Dc, int Start, int End );
char * dwFlags2String( DWORD dwFlags, char *Buf );
static char *iLayerType2String( BYTE iLayerType, char *Buf );
void PrintUsage( void );
void PrintHelp( void );

/*
 *  defines
 */

#define EXIT_OK     EXIT_SUCCESS
#define EXIT_ERROR  EXIT_FAILURE
#define EXIT_USAGE  15
#define EXIT_HELP   14

/*
 *  globals
 */

char *ProgramName;              /* Pointer to the name of the program      */
int CountOnly       = 0;        /* Count only flag                         */

/*
 *  main
 */

int
main( int argc, char **argv )
{
    HDC Dc;
    int AvailableIds;
    int ExitCode = EXIT_OK;

    ProgramName = *argv;

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
            case 'c':
            case 'C':
                CountOnly = !CountOnly;
                break;

            case 'h':
            case 'H':
            case '?':
                PrintHelp();
                exit(EXIT_HELP);
                break;

            default:
                PrintUsage();
                exit(EXIT_USAGE);
                break;
        }
    }

    /*
     *  Get a DC for the display
     */

    Dc = GetDC(NULL);

    /*
     *  Get the total number of pixel formats
     */

    AvailableIds = DescribePixelFormat( Dc, 0, 0, NULL );

    /*
     *  If only a count was requested, we are done
     */

    if (CountOnly)
    {
        printf("%d\n", AvailableIds);
        exit(AvailableIds);
    }

    /*
     *  If there are more arguments, print only the Ids requested
     */

    if ( argc )
    {
        for ( ; argc ; argc--, argv++ )
        {
            int StartId, EndId, Scanned;

            Scanned = sscanf(*argv, "%i-%i", &StartId, &EndId );

            if ( 1 == Scanned )
            {
                PrintPixelFormat( Dc, StartId );
            }
            else if ( 2 == Scanned )
            {
                PrintRangeOfPixelFormat( Dc, StartId, EndId );
            }
            else
            {
                fprintf(stderr, "%s: Error: expected a number, found: '%s'\n",
                    ProgramName, *argv );
            }
        }
    }
    else
    {
        /*
         *  Print them all
         */

        PrintRangeOfPixelFormat( Dc, 1, AvailableIds );
    }

    /*
     *  Don't need the DC anymore
     */

    ReleaseDC( NULL, Dc );

    return(ExitCode);
}

VOID
PrintPixelFormat( HDC Dc, int PixelFormatId )
{
    char Buf[256];
    PIXELFORMATDESCRIPTOR Pfd;

    if ( DescribePixelFormat( Dc, PixelFormatId, sizeof(Pfd), &Pfd ) )
    {
        printf("PixelFormat:    %d\n", PixelFormatId         );
        printf("nSize           %d\n", Pfd.nSize             );
        printf("nVersion        %d\n", Pfd.nVersion          );
        printf("dwFlags         0x%08lX (%s)\n", Pfd.dwFlags,
            dwFlags2String( Pfd.dwFlags, Buf ));

        printf("iPixelType      %d, (%s)\n", Pfd.iPixelType,
            (PFD_TYPE_RGBA == Pfd.iPixelType) ?
                "TYPE_RGBA" : "TYPE_COLORINDEX");

        printf("cColorBits      %d\n", Pfd.cColorBits        );
        printf("cRedBits        %d\n", Pfd.cRedBits          );
        printf("cRedShift       %d\n", Pfd.cRedShift         );
        printf("cGreenBits      %d\n", Pfd.cGreenBits        );
        printf("cGreenShift     %d\n", Pfd.cGreenShift       );
        printf("cBlueBits       %d\n", Pfd.cBlueBits         );
        printf("cBlueShift      %d\n", Pfd.cBlueShift        );
        printf("cAlphaBits      %d\n", Pfd.cAlphaBits        );
        printf("cAlphaShift     %d\n", Pfd.cAlphaShift       );
        printf("cAccumBits      %d\n", Pfd.cAccumBits        );
        printf("cAccumRedBits   %d\n", Pfd.cAccumRedBits     );
        printf("cAccumGreenBits %d\n", Pfd.cAccumGreenBits   );
        printf("cAccumBlueBits  %d\n", Pfd.cAccumBlueBits    );
        printf("cAccumAlphaBits %d\n", Pfd.cAccumAlphaBits   );
        printf("cDepthBits      %d\n", Pfd.cDepthBits        );
        printf("cStencilBits    %d\n", Pfd.cStencilBits      );
        printf("cAuxBuffers     %d\n", Pfd.cAuxBuffers       );
        printf("iLayerType      %d, (%s)\n", Pfd.iLayerType,
            iLayerType2String( Pfd.iLayerType, Buf ) );

        printf("bReserved       %d\n", Pfd.bReserved         );
        printf("dwLayerMask     %d\n", Pfd.dwLayerMask       );
        printf("dwVisibleMask   %d\n", Pfd.dwVisibleMask     );
        printf("dwDamageMask    %d\n", Pfd.dwDamageMask      );

        printf("\n");
    }
    else
    {
        printf("Could not get pixel format id: %d\n", PixelFormatId );
    }
}

void
PrintRangeOfPixelFormat( HDC Dc, int Start, int End )
{
    if ( End >= Start )
    {
        for ( ; Start <= End; Start++ )
        {
            PrintPixelFormat( Dc, Start );
        }
    }
    else
    {
        for ( ; Start >= End; Start-- )
        {
            PrintPixelFormat( Dc, Start );
        }
    }
}

char *
dwFlags2String( DWORD dwFlags, char *Buf )
{
    int i;

    static DWFLAGS dwFlagsData[] = {

        { "PFD_DOUBLEBUFFER"        , PFD_DOUBLEBUFFER   },
        { "PFD_STEREO"              , PFD_STEREO         },
        { "PFD_DRAW_TO_WINDOW"      , PFD_DRAW_TO_WINDOW },
        { "PFD_DRAW_TO_BITMAP"      , PFD_DRAW_TO_BITMAP },
        { "PFD_SUPPORT_GDI"         , PFD_SUPPORT_GDI    },
        { "PFD_SUPPORT_OPENGL"      , PFD_SUPPORT_OPENGL },
        { "PFD_GENERIC_FORMAT"      , PFD_GENERIC_FORMAT },
        { "PFD_NEED_PALETTE"        , PFD_NEED_PALETTE   },
        { "PFD_NEED_SYSTEM_PALETTE" , PFD_NEED_SYSTEM_PALETTE   },
        { "PFD_GENERIC_ACCELERATED" , PFD_GENERIC_ACCELERATED },
        { NULL                      , 0                  }

    };

    *Buf = '\0';

    for ( i = 0; NULL != dwFlagsData[i].Name ; i++ )
    {
        if ( dwFlags & dwFlagsData[i].Value )
        {
            strcat( Buf, dwFlagsData[i].Name );
            strcat( Buf, " ");
        }
    }
    return( Buf );
}
/********************************************************************/

static char *
iLayerType2String( BYTE iLayerType, char *Buf )
{
    switch ( iLayerType )
    {
        case PFD_MAIN_PLANE:
            strcpy( Buf, "PFD_MAIN_PLANE");
            break;

        case PFD_OVERLAY_PLANE:
            strcpy( Buf, "PFD_OVERLAY_PLANE");
            break;

        case PFD_UNDERLAY_PLANE:
            strcpy( Buf, "PFD_UNDERLAY_PLANE");
            break;

        default:
            strcpy( Buf, "UNKNOWN");
            break;
    }
    return( Buf );
}

void
PrintUsage( void )
{
    printf("usage: %s -ch? [PfdId[-RangePfd]...]\n", ProgramName );
}

void
PrintHelp( void )
{
    PrintUsage();

    printf("\n");
    printf("  -?|h  Print this information.\n");
    printf("  -c    Count the number of available pixel formats. (exit code is count)\n");
    printf("\n");
    printf("PfdId is the pixel format id requested\n");
    printf("A range of pixel formats is specified with StarId-EndId\n");
    printf("\n");
    printf("The following prints Ids 5 to 7: %s 5-7\n", ProgramName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\mcdtab\clssfact.cpp ===
//---------------------------------------------------------------------------
//
//	File: CLSSFACT.CPP
//
//	Implements a class factory object that creates CPropSheetExt objects.
//
//---------------------------------------------------------------------------

#include "clssfact.h"


extern ULONG g_cObj;	// See PLUSTAB.CPP
extern ULONG g_cLock;	// See PLUSTAB.CPP


//---------------------------------------------------------------------------
//	ObjectDestroyed()
//
//	Function for the CPropSheetExt object to call when it is destroyed.
//	Because we're in a DLL, we only track the number of objects here,
//	letting DllCanUnloadNow take care of the rest.
//---------------------------------------------------------------------------
void FAR PASCAL ObjectDestroyed( void )
{
	g_cObj--;
	return;
}


//---------------------------------------------------------------------------
//	Class Member functions
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//	Constructor
//---------------------------------------------------------------------------
CClassFactory::CClassFactory()
{
	m_cRef = 0L;
	return;
}

//---------------------------------------------------------------------------
//	Destructor
//---------------------------------------------------------------------------
CClassFactory::~CClassFactory( void )
{
	return;
}

//---------------------------------------------------------------------------
//	QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    //Any interface on this object is the object pointer.
    if( IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_IClassFactory ) )
	{
        *ppv = (LPVOID)this;
		++m_cRef;
		return NOERROR;
	}
	return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//	AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
	return ++m_cRef;
}

//---------------------------------------------------------------------------
//	Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release()
{
ULONG cRefT;

	cRefT = --m_cRef;

	if( 0L == m_cRef )
		delete this;

	return cRefT;
}

//---------------------------------------------------------------------------
//	CreateInstance()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR *ppvObj )
{
CPropSheetExt*	pObj;
HRESULT		hr = E_OUTOFMEMORY;

	*ppvObj = NULL;

    // We don't support aggregation at all.
	if( pUnkOuter )
	{
		return CLASS_E_NOAGGREGATION;
	}

	//Verify that a controlling unknown asks for IShellPropSheetExt
	if( IsEqualIID( riid, IID_IShellPropSheetExt ) )
	{
		//Create the object, passing function to notify on destruction
		pObj = new CPropSheetExt( pUnkOuter, ObjectDestroyed );

		if( NULL == pObj )
		{
			return hr;
		}
		hr = pObj->QueryInterface( riid, ppvObj );

		//Kill the object if initial creation or FInit failed.
		if( FAILED(hr) )
		{
			delete pObj;
		}
		else
		{
			g_cObj++;
		}
		return hr;
	}
	return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//	LockServer()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer( BOOL fLock )
{
	if( fLock )
	{
		g_cLock++;
	}
	else
	{
		g_cLock--;
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\mcdtab\clssfact.h ===
//--------------------------------------------------------------------------------
//
//	File:	CLSSFACT.H
//
//	Defines the CClassFactory object.
//
//--------------------------------------------------------------------------------

#ifndef _CLSSFACT_H_
#define _CLSSFACT_H_

#include "propsext.h"

void FAR PASCAL ObjectDestroyed();

//This class factory object creates CPropSheetExt objects.
class CClassFactory : public IClassFactory
{
protected:
	ULONG	m_cRef;

public:
	CClassFactory();
	~CClassFactory();

	//IUnknown members
	STDMETHODIMP		 QueryInterface( REFIID, LPVOID* );
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//IClassFactory members
	STDMETHODIMP		CreateInstance( LPUNKNOWN, REFIID, LPVOID* );
	STDMETHODIMP		LockServer( BOOL );
};

#endif //_CLSSFACT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\mcdtab\mcdtab.h ===
//--------------------------------------------------------------------------------
//
//	File:	PLUSTAB.H
//
//	Definitions, classes, and prototypes for a DLL that
//	provides CPropSheetExt objects to any other object user.
//
//--------------------------------------------------------------------------------

#ifndef _PLUSTAB_H_
#define _PLUSTAb_H_

//Get the object definitions
#include <WINDOWS.H>
#include <WINDOWSX.H>


#endif //_PLUSTAB_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\mcdtab\mcdtab.cpp ===
//--------------------------------------------------------------------------------
//
//      File:   MCDTAB.CPP
//
//	Implements the interfaces to the DLL.
//
//--------------------------------------------------------------------------------

//Do this once in the entire build
#define INITGUIDS


#include "mcdtab.h"
#include "clssfact.h"
#include <initguid.h>

// Count number of objects and number of locks.
ULONG g_cObj = 0;
ULONG g_cLock = 0;
HINSTANCE	g_hInst = NULL;

// OLE-Registry magic number
static const GUID CLSID_PlusPackCplExt =
{0x49f1d180, 0x8ead, 0x11cf, {0x83, 0xac, 0x00, 0xaa, 0x00, 0xc2, 0x1d, 0xb6}};

//---------------------------------------------------------------------------
// DllMain()
//---------------------------------------------------------------------------
int APIENTRY DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID )
{
    if( dwReason == DLL_PROCESS_ATTACH )	// Initializing
    {
        g_hInst = hInstance;
        
        DisableThreadLibraryCalls(hInstance);
    }

	return 1;
} 
//---------------------------------------------------------------------------
//	DllGetClassObject()
//
//	If someone calls with our CLSID, create an IClassFactory and pass it to
//	them, so they can create and use one of our CPropSheetExt objects.
//
//---------------------------------------------------------------------------
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID* ppvOut )
{
	*ppvOut = NULL; // Assume Failure
	if( IsEqualCLSID( rclsid, CLSID_PlusPackCplExt ) )
	{
		//Check that we can provide the interface
		if( IsEqualIID( riid, IID_IUnknown) || IsEqualIID( riid, IID_IClassFactory ) )
		{
			//Return our IClassFactory for CPropSheetExt objects
			*ppvOut = (LPVOID* )new CClassFactory();
			if( NULL != *ppvOut )
			{
			    //AddRef the object through any interface we return
				((CClassFactory*)*ppvOut)->AddRef();
				return NOERROR;
			}
			return E_OUTOFMEMORY;
		}
		return E_NOINTERFACE;
	}
	else
	{
		return CLASS_E_CLASSNOTAVAILABLE;
	}
}

//---------------------------------------------------------------------------
//	DllCanUnloadNow()
//
//	If we are not locked, and no objects are active, then we can exit.
//
//---------------------------------------------------------------------------
STDAPI DllCanUnloadNow()
{
SCODE   sc;
    //Our answer is whether there are any object or locks
    sc = (0L == g_cObj && 0 == g_cLock) ? S_OK : S_FALSE;
    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\mcdtab\propsext.h ===
//---------------------------------------------------------------------------
//
//	File: PROPSEXT.CPP
//
//	Defines the CPropSheetExt object.
//
//---------------------------------------------------------------------------

#ifndef _PROPSEXT_H_
#define _PROPSEXT_H_

#include <windows.h>

#include <prsht.h>
#include <shlobj.h>

//Type for an object-destroyed callback
typedef void (FAR PASCAL *LPFNDESTROYED)(void);


class CPropSheetExt : public IShellPropSheetExt
{
private:
	ULONG           m_cRef;
	LPUNKNOWN       m_pUnkOuter;    //Controlling unknown
	LPFNDESTROYED	m_pfnDestroy;	//Function closure call

public:
	CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy );
	~CPropSheetExt(void);

	// IUnknown members
	STDMETHODIMP		 QueryInterface(REFIID, LPVOID*);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // *** IShellPropSheetExt methods ***
    STDMETHODIMP		AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
    STDMETHODIMP		ReplacePage( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );
};

#endif //_PROPSEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\mcdtab\propsext.cpp ===
//---------------------------------------------------------------------------
//
//	File: PROPSEXT.CPP
//
//	Implementation of the CPropSheetExt object.
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include "propsext.h"
#include "rc.h"
#include "string.h"
#include "addon.h"
#include <shlobj.h>

//
// Defines for getting registry settings
//

#define STR_MCDKEY      (PCSTR)"Software\\Microsoft\\Windows\\CurrentVersion\\MCD"
#define STR_ENABLE      (LPSTR)"Enable"
#define STR_SWAPSYNC    (LPSTR)"SwapSync"
#define STR_8BPP        (LPSTR)"Palettized Formats"
#define STR_IOPRIORITY  (LPSTR)"IO Priority"
#define STR_STENCIL     (LPSTR)"Use Generic Stencil"
#define STR_DEBUG       (LPSTR)"Debug"

#define STR_DCIKEY      (PCSTR)"System\\CurrentControlSet\\Control\\GraphicsDrivers\\DCI"
#define STR_TIMEOUT     (LPSTR)"TimeOut"

//
// Structure describing current MCD settings.
//

typedef struct tagMcdRegistry
{
    HKEY    hkMcd;          // Handle to MCD key in registry.
    BOOL    bEnable;
    BOOL    bSwapSync;
    BOOL    bPalFormats;
    BOOL    bIoPriority;
    BOOL    bUseGenSten;

#ifdef SUPPORT_MCDBG_FLAGS
    long    lDebug;
#endif

    HKEY    hkDci;          // Handle to DCI key in registry.
    long    lTimeout;
} MCDREGISTRY;

MCDREGISTRY McdRegistry;

//
// Functions to get registry settings, setup dialog based on settings, and
// save registry settings.
//

extern "C" {

void McdInitRegistry(MCDREGISTRY *pMcdReg);
BOOL McdOpenRegistry(MCDREGISTRY *pMcdReg);
void McdUpdateDialogSettings(MCDREGISTRY *pMcdReg, HWND hDlg);
void McdCloseRegistry(MCDREGISTRY *pMcdReg);
void McdUpdateRegistry(MCDREGISTRY *pMcdReg);
void McdSetRegValue(HKEY hkey, LPSTR lpstrValueName, long lData);
long McdGetRegValue(HKEY hkey, LPSTR lpstrValueName, long lDefaultData);

BOOL McdDetection(void);

};

//
// Function prototype
//

BOOL CALLBACK McdDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam,
                         LPARAM lParam);

//
// Handle to the DLL
//

extern HINSTANCE g_hInst;

//
// Track state of OLE CoInitialize()
//

BOOL  gfCoInitDone = FALSE;


#if DBG
ULONG
DbgPrint(
    PCH DebugMessage,
    ...
    )
{
    va_list ap;
    char buffer[256];

    va_start(ap, DebugMessage);

    vsprintf(buffer, DebugMessage, ap);

    OutputDebugStringA(buffer);

    va_end(ap);

    return(0);
}

VOID NTAPI
DbgBreakPoint(VOID)
{
    DebugBreak();
}
#endif

///////////////////////////// BEGIN CUT-AND-PASTE /////////////////////////////
//                                                                           //
// This section of code is cut-and-paste from the Plus! Pack prop sheet      //
// code.  The coding style is entirely the responsibility of someone         //
// over in building 27.  :-)                                                 //
//                                                                           //
//                                -- Gilman                                  //
//                                                                           //

//---------------------------------------------------------------------------
//	Class Member functions
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//	Constructor
//---------------------------------------------------------------------------
CPropSheetExt::CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy )
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pfnDestroy = pfnDestroy;

    return;
}

//---------------------------------------------------------------------------
//	Destructor
//---------------------------------------------------------------------------
CPropSheetExt::~CPropSheetExt( void )
{
    return;
}

//---------------------------------------------------------------------------
//	QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    if( IsEqualIID( riid, IID_IShellPropSheetExt ) )
    {
        *ppv = (LPVOID)this;
        ++m_cRef;

        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//---------------------------------------------------------------------------
//	AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::AddRef( void )
{
    return ++m_cRef;
}

//---------------------------------------------------------------------------
//	Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::Release( void )
{
    ULONG cRefT;

    cRefT = --m_cRef;

    if( m_cRef == 0 )
    {
        // Tell the housing that an object is going away so that it
        // can shut down if appropriate.

        if( NULL != m_pfnDestroy )
                (*m_pfnDestroy)();
        delete this;
    }

    return cRefT;
}

//---------------------------------------------------------------------------
//	AddPages()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    // Fail the call if not an MCD-enabled display
    // driver.

    if (!McdDetection())
        return ( E_FAIL );

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    // psp.dwFlags     = PSP_USETITLE | PSP_HASHELP;
    psp.dwFlags     = PSP_USETITLE;
    psp.hIcon       = NULL;
    psp.hInstance   = g_hInst;
    psp.pszTemplate = MAKEINTRESOURCE( MCD_DLG );
    psp.pfnDlgProc  = (DLGPROC)McdDlgProc;
    psp.pszTitle    = "3D";
    psp.lParam      = 0;

    if( ( hpage = CreatePropertySheetPage( &psp ) ) == NULL )
    {
        return ( E_OUTOFMEMORY );
    }

    if( !lpfnAddPage( hpage, lParam ) )
    {
        DestroyPropertySheetPage( hpage );

        return ( E_FAIL );
    }

    return NOERROR;
}

//---------------------------------------------------------------------------
//	ReplacePage()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::ReplacePage( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    return NOERROR;
}

//                                                                           //
// Guess its time to go back to my code.                                     //
//                                                                           //
//                                -- Gilman                                  //
//                                                                           //
////////////////////////////// END CUT-AND-PASTE //////////////////////////////


/******************************Public*Routine******************************\
* McdDlgProc
*
* The dialog procedure for the "OpenGL MCD" property sheet page.
*
* History:
*  05-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL CALLBACK
McdDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) GetWindowLong(hDlg, DWL_USER);
    static char szHelpFile[32];

    switch( uMessage )
    {
    case WM_INITDIALOG:

        //!!! This is left over from the Plus!Pack propsheet.  Is it needed?
        SetWindowLong( hDlg, DWL_USER, lParam );
        psp = (LPPROPSHEETPAGE)lParam;

        //
        // Get the name of the help file.
        //

        LoadString( g_hInst, IDS_HELPFILE, szHelpFile, 32 );

        //
        // Get the values for the settings from the registry and
        // set the checkboxes.
        //

        McdInitRegistry(&McdRegistry);
        McdOpenRegistry(&McdRegistry);
        McdUpdateDialogSettings(&McdRegistry, hDlg);

        break;

    case WM_DESTROY:
        if ( gfCoInitDone )
            CoUninitialize();
        McdCloseRegistry(&McdRegistry);

        break;

    case WM_COMMAND:
        switch( LOWORD(wParam) )
        {
        case IDC_MCD_ENABLE:
            McdRegistry.bEnable = IsDlgButtonChecked(hDlg, IDC_MCD_ENABLE);
            break;

        case IDC_MCD_SYNCSWAP:
            McdRegistry.bSwapSync = IsDlgButtonChecked(hDlg, IDC_MCD_SYNCSWAP);
            break;

        case IDC_MCD_PALFMTS:
            McdRegistry.bPalFormats = IsDlgButtonChecked(hDlg, IDC_MCD_PALFMTS);
            break;

        case IDC_MCD_IOPRIORITY:
            McdRegistry.bIoPriority = IsDlgButtonChecked(hDlg, IDC_MCD_IOPRIORITY);
            break;

        case IDC_MCD_STENCIL:
            McdRegistry.bUseGenSten = IsDlgButtonChecked(hDlg, IDC_MCD_STENCIL);
            break;

        case IDC_DCI_TIMEOUT:
            if (IsDlgButtonChecked(hDlg, IDC_DCI_TIMEOUT))
                McdRegistry.lTimeout = 7;
            else
                McdRegistry.lTimeout = 0;
            break;

#ifdef SUPPORT_MCDBG_FLAGS
        case IDC_MCDBG_ALLOCBUF:
            if (!IsDlgButtonChecked(hDlg, IDC_MCDBG_ALLOCBUF))
                McdRegistry.lDebug |= MCDDEBUG_DISABLE_ALLOCBUF;
            else
                McdRegistry.lDebug &= ~MCDDEBUG_DISABLE_ALLOCBUF;
            break;

        case IDC_MCDBG_GETBUF:
            if (!IsDlgButtonChecked(hDlg, IDC_MCDBG_GETBUF))
                McdRegistry.lDebug |= MCDDEBUG_DISABLE_GETBUF;
            else
                McdRegistry.lDebug &= ~MCDDEBUG_DISABLE_GETBUF;
            break;

        case IDC_MCDBG_DRAW:
            if (!IsDlgButtonChecked(hDlg, IDC_MCDBG_DRAW))
                McdRegistry.lDebug |= MCDDEBUG_DISABLE_PROCBATCH;
            else
                McdRegistry.lDebug &= ~MCDDEBUG_DISABLE_PROCBATCH;
            break;

        case IDC_MCDBG_CLEAR:
            if (!IsDlgButtonChecked(hDlg, IDC_MCDBG_CLEAR))
                McdRegistry.lDebug |= MCDDEBUG_DISABLE_CLEAR;
            else
                McdRegistry.lDebug &= ~MCDDEBUG_DISABLE_CLEAR;
            break;
#endif

        default:
            return FALSE;
        }

        //
        // If the user changed a setting, tell the property manager we
        // have outstanding changes. This will enable the "Apply Now" button...
        //

        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0L);

        break;

    case WM_NOTIFY:
        switch( ((NMHDR *)lParam)->code )
        {
        case PSN_APPLY:         // OK or Apply clicked

            McdUpdateRegistry(&McdRegistry);
            break;

        case PSN_QUERYCANCEL:   // Cancel clicked
            break;

        default:
            break;
        }

        break;

    #if 0
    case WM_HELP:
        {
            LPHELPINFO lphi = (LPHELPINFO)lParam;

            if( lphi->iContextType == HELPINFO_WINDOW )
            {
                    WinHelp( (HWND)lphi->hItemHandle, (LPSTR)szHelpFile, HELP_WM_HELP,(DWORD)((POPUP_HELP_ARRAY FAR *)phaMainWin) );
            }
        }
        break;
    #endif

    //!!! This is also left over from Plus!Pack propsheet.  Is it needed?
    case WM_CONTEXTMENU:
        // first check for dlg window
        if( (HWND)wParam == hDlg )
        {
            // let the def dlg proc decide whether to respond or ignore;
            // necessary for title bar sys menu on right click
            return FALSE;
        }
        #if 0
        else
        {
            // else go for the controls
            WinHelp( (HWND)wParam, (LPSTR)szHelpFile, HELP_CONTEXTMENU,(DWORD)((POPUP_HELP_ARRAY FAR *)phaMainWin) );
        }
        #endif
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* McdInitResistry
*
* Initializes the MCDREGISTRY structure.
*
* History:
*  05-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void McdInitRegistry(MCDREGISTRY *pMcdReg)
{
    //
    // The registry keys must be set to zero.  The data is valid
    // only if the corresponding keys are valid.
    //

    memset(pMcdReg, 0, sizeof(*pMcdReg));
}

/******************************Public*Routine******************************\
* McdOpenRegistry
*
* Opens the MCD registry and initializes the settings to the values found
* in the registry.
*
* Note:
*   The function will leave the registry keys open, so the caller should
*   make sure to call McdCloseRegistry when done.
*
* History:
*  05-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL McdOpenRegistry(MCDREGISTRY *pMcdReg)
{
    //
    // Open the MCD key and get the data.
    //

    if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                       STR_MCDKEY,
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE,
                       &pMcdReg->hkMcd) == ERROR_SUCCESS )
    {
        pMcdReg->bEnable =
            McdGetRegValue(pMcdReg->hkMcd, STR_ENABLE, 0) != 0;

        pMcdReg->bSwapSync =
            McdGetRegValue(pMcdReg->hkMcd, STR_SWAPSYNC, 0) != 0;

        pMcdReg->bPalFormats =
            McdGetRegValue(pMcdReg->hkMcd, STR_8BPP, 0) != 0;

        pMcdReg->bIoPriority =
            McdGetRegValue(pMcdReg->hkMcd, STR_IOPRIORITY, 0) != 0;

        pMcdReg->bUseGenSten =
            McdGetRegValue(pMcdReg->hkMcd, STR_STENCIL, 0) != 0;

#ifdef SUPPORT_MCDBG_FLAGS
        pMcdReg->lDebug = McdGetRegValue(pMcdReg->hkMcd, STR_DEBUG, 0);
#endif
    }
    else
    {
        pMcdReg->hkMcd = (HKEY) NULL;
    }

    //
    // Open the DCI key and get the data.
    //

    if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                       STR_DCIKEY,
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE,
                       &pMcdReg->hkDci) == ERROR_SUCCESS )
    {
        pMcdReg->lTimeout = McdGetRegValue(pMcdReg->hkDci, STR_TIMEOUT, 0);
    }
    else
    {
        pMcdReg->hkDci = (HKEY) NULL;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* McdUpdateDialogSettings
*
* Sets the controls in the dialog to match the MCD registry settings.
*
* History:
*  05-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void McdUpdateDialogSettings(MCDREGISTRY *pMcdReg, HWND hDlg)
{
    //
    // If the mcd key is valid, the data is valid.  Use the
    // data to set the MCD controls in the dialog.
    //

    if (pMcdReg->hkMcd)
    {
        CheckDlgButton(hDlg, IDC_MCD_ENABLE,     pMcdReg->bEnable);
        CheckDlgButton(hDlg, IDC_MCD_SYNCSWAP,   pMcdReg->bSwapSync);
        CheckDlgButton(hDlg, IDC_MCD_PALFMTS,    pMcdReg->bPalFormats);
        CheckDlgButton(hDlg, IDC_MCD_IOPRIORITY, pMcdReg->bIoPriority);
        CheckDlgButton(hDlg, IDC_MCD_STENCIL,    pMcdReg->bUseGenSten);

#ifdef SUPPORT_MCDBG_FLAGS
        CheckDlgButton(hDlg, IDC_MCDBG_ALLOCBUF, !(pMcdReg->lDebug & MCDDEBUG_DISABLE_ALLOCBUF ));
        CheckDlgButton(hDlg, IDC_MCDBG_GETBUF,   !(pMcdReg->lDebug & MCDDEBUG_DISABLE_GETBUF   ));
        CheckDlgButton(hDlg, IDC_MCDBG_DRAW,     !(pMcdReg->lDebug & MCDDEBUG_DISABLE_PROCBATCH));
        CheckDlgButton(hDlg, IDC_MCDBG_CLEAR,    !(pMcdReg->lDebug & MCDDEBUG_DISABLE_CLEAR    ));
#endif
    }

    //
    // If the dci key is valid, the data is valid.  Use the
    // data to set the DCI controls in the dialog.
    //

    if (pMcdReg->hkDci)
    {
        CheckDlgButton(hDlg, IDC_DCI_TIMEOUT,    pMcdReg->lTimeout != 0);
    }
}

/******************************Public*Routine******************************\
* McdCloseRegistry
*
* Close any resources used in the MCDREGISTRY (i.e., close the open registry
* keys).
*
* History:
*  05-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void McdCloseRegistry(MCDREGISTRY *pMcdReg)
{
    //
    // Close open registry keys.
    //

    if (pMcdReg->hkMcd)
    {
        RegCloseKey(pMcdReg->hkMcd);
        pMcdReg->hkMcd = (HKEY) NULL;
    }

    if (pMcdReg->hkDci)
    {
        RegCloseKey(pMcdReg->hkDci);
        pMcdReg->hkDci = (HKEY) NULL;
    }
}

/******************************Public*Routine******************************\
* McdUpdateRegistry
*
* Save the current values in MCDREGISTRY to the system
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void McdUpdateRegistry(MCDREGISTRY *pMcdReg)
{
    //
    // If the mcd key is open, save the MCD data to the registry.
    //

    if (pMcdReg->hkMcd)
    {
        McdSetRegValue(pMcdReg->hkMcd, STR_ENABLE,
                       (long) pMcdReg->bEnable);

        McdSetRegValue(pMcdReg->hkMcd, STR_SWAPSYNC,
                       (long) pMcdReg->bSwapSync);

        McdSetRegValue(pMcdReg->hkMcd, STR_8BPP,
                       (long) pMcdReg->bPalFormats);

        McdSetRegValue(pMcdReg->hkMcd, STR_IOPRIORITY,
                       (long) pMcdReg->bIoPriority);

        McdSetRegValue(pMcdReg->hkMcd, STR_STENCIL,
                       (long) pMcdReg->bUseGenSten);

#ifdef SUPPORT_MCDBG_FLAGS
        McdSetRegValue(pMcdReg->hkMcd, STR_DEBUG,
                       pMcdReg->lDebug);
#endif
    }

    //
    // If the dci key is open, save the DCI data to the registry.
    //

    if (pMcdReg->hkDci)
    {
        McdSetRegValue(pMcdReg->hkDci, STR_TIMEOUT,
                       pMcdReg->lTimeout);
    }
}

/******************************Public*Routine******************************\
* McdGetRegValue
*
* Get the data value for the specified value name out of the specified
* registry key.
*
* History:
*  05-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

long McdGetRegValue(HKEY hkey, LPSTR lpstrValueName, long lDefaultData)
{
    DWORD dwDataType;
    DWORD cjSize;
    long  lData;

    //
    // For specified value, attempt to fetch the data.
    //

    cjSize = sizeof(long);
    if ( (RegQueryValueExA(hkey,
                           lpstrValueName,
                           (LPDWORD) NULL,
                           &dwDataType,
                           (LPBYTE) &lData,
                           &cjSize) != ERROR_SUCCESS)
         || (dwDataType != REG_DWORD) )
    {
        lData = lDefaultData;
    }

    return lData;
}

/******************************Public*Routine******************************\
* McdSetRegValue
*
* Set the specified value name of the registry key with the specified data.
*
* History:
*  05-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void McdSetRegValue(HKEY hkey, LPSTR lpstrValueName, long lData)
{
    //
    // Set the specified value.
    //

    RegSetValueExA(hkey, lpstrValueName, 0, REG_DWORD, (BYTE *) &lData,
                   sizeof(lData));
}

/******************************Public*Routine******************************\
* McdDetection
*
* Detect MCD support in the driver by calling the MCDGetDriverInfo function.
*
* History:
*  05-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

typedef struct _MCDRIVERINFO {
    ULONG verMajor;
    ULONG verMinor;
    ULONG verDriver;
    CHAR  idStr[200];
    ULONG drvMemFlags;
    ULONG drvBatchMemSizeMax;
} MCDDRIVERINFO;

typedef BOOL (APIENTRY *MCDGETDRIVERINFOFUNC)(HDC hdc, MCDDRIVERINFO *pMCDDriverInfo);

BOOL McdDetection(void)
{
    static BOOL bFirstTime = TRUE;
    static BOOL bRet = FALSE;

//ATTENTION -- Need a good way to detect MCD support independent of the
//ATTENTION    setting of the MCD Enable flag.  MCDGetDriverInfo fails
//ATTENTION    if MCD is disabled (whether or not the driver has MCD
//ATTENTION    support).
return TRUE;

    if (bFirstTime)
    {
        HMODULE hmodMcd;

        //
        // Only do this once.
        //

        bFirstTime = FALSE;

        //
        // Load the MCD32.DLL library.
        //

        hmodMcd = LoadLibraryA("mcd32.dll");

        if (hmodMcd)
        {
            MCDGETDRIVERINFOFUNC pMCDGetDriverInfo;

            //
            // Get the MCDGetDriverInfo entry point and call it.
            //

            pMCDGetDriverInfo = (MCDGETDRIVERINFOFUNC)
                GetProcAddress(hmodMcd, "MCDGetDriverInfo");

            if (pMCDGetDriverInfo)
            {
                HDC hdc;

                //
                // An hdc is required for the function call.
                //

                hdc = CreateDCA("display", NULL, NULL, NULL);

                if (hdc)
                {
                    MCDDRIVERINFO McdInfo;

                    //
                    //  Gee, the display driver really does support MCD.
                    //

                    bRet = (*pMCDGetDriverInfo)(hdc, &McdInfo);

                    DeleteDC(hdc);
                }
            }

            FreeLibrary(hmodMcd);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\tools\mcdtab\rc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by mcdtab.RC
//

#define SUPPORT_MCDBG_FLAGS

#define IDS_HELPFILE                    1

#define IDC_GRPBOX_1                    10
#define IDC_GRPBOX_2                    11

#define IDC_MCD_ENABLE                  20
#define IDC_MCD_SYNCSWAP                21
#define IDC_MCD_PALFMTS                 22
#define IDC_MCD_IOPRIORITY              23
#define IDC_MCD_DEBUG                   24
#define IDC_MCD_STENCIL                 25
#define IDC_DCI_TIMEOUT                 26

#ifdef SUPPORT_MCDBG_FLAGS
#define IDC_MCDBG_ALLOCBUF              30
#define IDC_MCDBG_GETBUF                31
#define IDC_MCDBG_DRAW                  32
#define IDC_MCDBG_CLEAR                 33
#define MCDDEBUG_DISABLE_ALLOCBUF   0x00000001
#define MCDDEBUG_DISABLE_GETBUF     0x00000002
#define MCDDEBUG_DISABLE_PROCBATCH  0x00000004
#define MCDDEBUG_DISABLE_CLEAR      0x00000008
#endif

#define MCD_DLG                         40
#define IDI_OPENGL                      41

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\3d.h ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
void	error(char *);
void	diff3(GLdouble [3], GLdouble [3], GLdouble [3]);
void	add3(GLdouble [3], GLdouble [3], GLdouble [3]);
void	scalarmult(GLdouble, GLdouble [3], GLdouble [3]);
GLdouble	dot3(GLdouble [3], GLdouble [3]);
GLdouble	length3(GLdouble [3]);
GLdouble	dist3(GLdouble [3], GLdouble [3]);
void	copy3(GLdouble [3], GLdouble [3]);
void	crossprod(GLdouble [3], GLdouble [3], GLdouble [3]);
void	normalize(GLdouble [3]);
void	print3(GLdouble [3]);
void	printmat3(GLdouble [3][3]);
void	identifymat3(GLdouble [3][3]);
void	copymat3(GLdouble *, GLdouble *);
void	xformvec3(GLdouble [3], GLdouble [3][3], GLdouble [3]);

void m_resetmatrixstack();
void m_xformpt(GLdouble [3], GLdouble [3], GLdouble [3], GLdouble [3]);
void m_xformptonly(GLdouble [3], GLdouble [3]);
void m_pushmatrix();
void m_popmatrix();
void m_shear(GLdouble, GLdouble, GLdouble);
void m_translate(GLdouble, GLdouble, GLdouble);
void m_scale(GLdouble, GLdouble, GLdouble);
void m_rotate(GLdouble, char);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\font.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <gl/glaux.h>
#include "tk.h"

#define static


static GLuint bitmapBase;
void APIENTRY auxDrawStrAW(LPCSTR str, BOOL bUnicode);

void auxCreateFont(void)
{
    bitmapBase = glGenLists(256);
    if (tkCreateBitmapFont(bitmapBase) == GL_FALSE) {
        auxQuit();
    }
}

void APIENTRY auxDrawStrA(LPCSTR str)
{
    auxDrawStrAW(str, FALSE);
}

void APIENTRY auxDrawStrW(LPCWSTR str)
{
    auxDrawStrAW((LPCSTR)str, TRUE);
}

void APIENTRY auxDrawStrAW(LPCSTR str, BOOL bUnicode)
{

    glPushAttrib(GL_LIST_BIT);
    glListBase(bitmapBase);
    if (bUnicode)
        glCallLists(wcslen((LPWSTR) str), GL_UNSIGNED_SHORT, str);
    else
	glCallLists(strlen(str), GL_UNSIGNED_BYTE, str);
    glPopAttrib();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\glaux.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <GL/gl.h>
#include <gl/glaux.h>
#include "tk.h"

#define static

#if defined(__cplusplus) || defined(c_plusplus)
#define class c_class
#endif


static struct {
    int keyField;
    void (*KeyFunc)(void);
} keyTable[200];

static struct {
    int mouseField;
    void (*MouseFunc)(AUX_EVENTREC *);
} mouseDownTable[20], mouseUpTable[20], mouseLocTable[20];

static int keyTableCount = 0;
static int mouseDownTableCount = 0;
static int mouseUpTableCount = 0;
static int mouseLocTableCount = 0;
static GLenum displayModeType = 0;
GLenum APIENTRY auxInitWindowAW(LPCSTR title, BOOL bUnicode);

static void DefaultHandleReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho((GLdouble)0.0, (GLdouble)w, (GLdouble)0.0, (GLdouble)h, (GLdouble)-1.0, (GLdouble)1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

static void DefaultHandleExpose(GLsizei w, GLsizei h)
{
}

static GLenum MouseLoc(int x, int y, GLenum button)
{
    AUX_EVENTREC info;
    GLenum flag;
    int i;

    flag = GL_FALSE;
    for (i = 0; i < mouseLocTableCount; i++) {
        if ((int)(button & AUX_LEFTBUTTON) == mouseLocTable[i].mouseField) {
	    info.event = AUX_MOUSELOC;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_LEFTBUTTON;
	    (*mouseLocTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_RIGHTBUTTON) == mouseLocTable[i].mouseField) {
	    info.event = AUX_MOUSELOC;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_RIGHTBUTTON;
	    (*mouseLocTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_MIDDLEBUTTON) == mouseLocTable[i].mouseField) {
	    info.event = AUX_MOUSELOC;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_MIDDLEBUTTON;
	    (*mouseLocTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
    }
    return flag;
}

static GLenum MouseUp(int x, int y, GLenum button)
{
    AUX_EVENTREC info;
    GLenum flag;
    int i;

    flag = GL_FALSE;
    for (i = 0; i < mouseUpTableCount; i++) {
        if ((int)(button & AUX_LEFTBUTTON) == mouseUpTable[i].mouseField) {
	    info.event = AUX_MOUSEUP;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_LEFTBUTTON;
	    (*mouseUpTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_RIGHTBUTTON) == mouseUpTable[i].mouseField) {
	    info.event = AUX_MOUSEUP;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_RIGHTBUTTON;
	    (*mouseUpTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_MIDDLEBUTTON) == mouseUpTable[i].mouseField) {
	    info.event = AUX_MOUSEUP;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_MIDDLEBUTTON;
	    (*mouseUpTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
    }
    return flag;
}

static GLenum MouseDown(int x, int y, GLenum button)
{
    AUX_EVENTREC info;
    GLenum flag;
    int i;

    flag = GL_FALSE;
    for (i = 0; i < mouseDownTableCount; i++) {
        if ((int)(button & AUX_LEFTBUTTON) == mouseDownTable[i].mouseField) {
	    info.event = AUX_MOUSEDOWN;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_LEFTBUTTON;
	    (*mouseDownTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_RIGHTBUTTON) == mouseDownTable[i].mouseField) {
	    info.event = AUX_MOUSEDOWN;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_RIGHTBUTTON;
	    (*mouseDownTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_MIDDLEBUTTON) == mouseDownTable[i].mouseField) {
	    info.event = AUX_MOUSEDOWN;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_MIDDLEBUTTON;
	    (*mouseDownTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
    }
    return flag;
}

static GLenum KeyDown(int key, GLenum status)
{
    GLenum flag;
    int i;

    flag = GL_FALSE;
    if (keyTableCount) {
	for (i = 0; i < keyTableCount; i++) {
	    if (key == keyTable[i].keyField) {
		(*keyTable[i].KeyFunc)();
		flag |= GL_TRUE;
	    }
	}
    }
    return flag;
}

void auxExposeFunc(AUXEXPOSEPROC Func)
{
    tkExposeFunc(Func);
}

void auxReshapeFunc(AUXRESHAPEPROC Func)
{
    tkExposeFunc((void (*)(int, int))Func);
    tkReshapeFunc((void (*)(int, int))Func);
}

void auxIdleFunc(AUXIDLEPROC Func)
{
    tkIdleFunc(Func);
}

void auxKeyFunc(int key, AUXKEYPROC Func)
{
    keyTable[keyTableCount].keyField = key;
    keyTable[keyTableCount++].KeyFunc = Func;
}

void auxMouseFunc(int mouse, int mode, AUXMOUSEPROC Func)
{
    if (mode == AUX_MOUSEDOWN) {
	mouseDownTable[mouseDownTableCount].mouseField = mouse;
	mouseDownTable[mouseDownTableCount++].MouseFunc = Func;
    } else if (mode == AUX_MOUSEUP) {
	mouseUpTable[mouseUpTableCount].mouseField = mouse;
	mouseUpTable[mouseUpTableCount++].MouseFunc = Func;
    } else if (mode == AUX_MOUSELOC) {
	mouseLocTable[mouseLocTableCount].mouseField = mouse;
	mouseLocTable[mouseLocTableCount++].MouseFunc = Func;
    } 
}

void auxMainLoop(AUXMAINPROC Func)
{
    tkDisplayFunc(Func);
    tkExec();
}

void auxInitPosition(int x, int y, int width, int height)
{
    tkInitPosition(x, y, width, height);
}

void auxInitDisplayMode(GLenum type)
{
    displayModeType = type;
    tkInitDisplayMode(type);
}

void auxInitDisplayModePolicy(GLenum type)
{
    tkInitDisplayModePolicy(type);
}

GLenum auxInitDisplayModeID(GLint id)
{
    return tkInitDisplayModeID(id);
}

GLenum APIENTRY auxInitWindowA(LPCSTR title)
{
    return auxInitWindowAW(title,FALSE);
}

GLenum APIENTRY auxInitWindowW(LPCWSTR title)
{
    return auxInitWindowAW((LPCSTR)title,TRUE);
}

GLenum APIENTRY auxInitWindowAW(LPCSTR title, BOOL bUnicode)
{
    int useDoubleAsSingle = 0;

    if (tkInitWindowAW((char *)title, bUnicode) == GL_FALSE) {
	if (AUX_WIND_IS_SINGLE(displayModeType)) {
	    tkInitDisplayMode(displayModeType | AUX_DOUBLE);
	    if (tkInitWindowAW((char *)title, bUnicode) == GL_FALSE) {
		return GL_FALSE;    /*  curses, foiled again	*/
            }
            MESSAGEBOX(GetFocus(), "Can't initialize a single buffer visual. "
                                   "Will use a double buffer visual instead, "
                                   "only drawing into the front buffer.",
                                   "Warning", MB_OK);
	    displayModeType = displayModeType | AUX_DOUBLE;
	    useDoubleAsSingle = 1;
	}
    }
    tkReshapeFunc((void (*)(int, int))DefaultHandleReshape);
    tkExposeFunc((void (*)(int, int))DefaultHandleExpose);
    tkMouseUpFunc(MouseUp);
    tkMouseDownFunc(MouseDown);
    tkMouseMoveFunc(MouseLoc);
    tkKeyDownFunc(KeyDown);
    auxKeyFunc(AUX_ESCAPE, auxQuit);
    glClearColor((GLclampf)0.0, (GLclampf)0.0, (GLclampf)0.0, (GLclampf)1.0);
    glClearIndex((GLfloat)0.0);
    glLoadIdentity();
    if (useDoubleAsSingle)
	glDrawBuffer(GL_FRONT);
    return GL_TRUE;
}

void auxCloseWindow(void)
{
    tkCloseWindow();
    keyTableCount = 0;
    mouseDownTableCount = 0;
    mouseUpTableCount = 0;
    mouseLocTableCount = 0;
}

void auxQuit(void)
{
    tkQuit();
}

void auxSwapBuffers(void)
{
    tkSwapBuffers();
}

HWND auxGetHWND(void)
{
    return tkGetHWND();
}

HDC auxGetHDC(void)
{
    return tkGetHDC();
}

HGLRC auxGetHGLRC(void)
{
    return tkGetHRC();
}

GLenum auxGetDisplayModePolicy(void)
{
    return tkGetDisplayModePolicy();
}

GLint auxGetDisplayModeID(void)
{
    return tkGetDisplayModeID();
}

GLenum auxGetDisplayMode(void)
{
    return tkGetDisplayMode();
}

void auxSetOneColor(int index, float r, float g, float b)
{
    tkSetOneColor(index, r, g, b);
}

void auxSetFogRamp(int density, int startIndex)
{
    tkSetFogRamp(density, startIndex);
}

void auxSetGreyRamp(void)
{
    tkSetGreyRamp();
}

void auxSetRGBMap(int size, float *rgb)
{
    tkSetRGBMap(size, rgb);
}

int auxGetColorMapSize(void)
{
    return tkGetColorMapSize();
}

void auxGetMouseLoc(int *x, int *y)
{
    tkGetMouseLoc(x, y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\shapes.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <gl/glaux.h>
#include "3d.h"

#define static

#define SPHEREWIRE      0
#define CUBEWIRE        1
#define BOXWIRE         2
#define TORUSWIRE       3
#define CYLINDERWIRE    4
#define ICOSAWIRE       5
#define OCTAWIRE        6
#define TETRAWIRE       7
#define DODECAWIRE      8
#define CONEWIRE        9
#define SPHERESOLID     10
#define CUBESOLID       11
#define BOXSOLID        12
#define TORUSSOLID      13
#define CYLINDERSOLID   14
#define ICOSASOLID      15
#define OCTASOLID       16
#define TETRASOLID      17
#define DODECASOLID     18
#define CONESOLID       19

#define PI ((GLdouble)3.1415926535897)

/*      structure for each geometric object     */
typedef struct model {
    GLuint list;        /*  display list to render object   */
    struct model *ptr;  /*  pointer to next object      */
    int numParam;       /*  # of parameters             */
    GLdouble *params;   /*  array with parameters       */
} MODEL, *MODELPTR;

/*      array of linked lists--used to keep track of display lists
 *      for each different type of geometric object.
 */
static MODELPTR lists[25] = {
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL
};

GLuint findList (int index, GLdouble *paramArray, int size);
int compareParams (GLdouble *oneArray, GLdouble *twoArray, int size);
GLuint makeModelPtr (int index, GLdouble *sizeArray, int count);

static void drawbox(GLdouble, GLdouble, GLdouble,
        GLdouble, GLdouble, GLdouble, GLenum);
static void doughnut(GLdouble, GLdouble, GLint, GLint, GLenum);
static void icosahedron(GLdouble *, GLdouble, GLenum);
static void octahedron(GLdouble *, GLdouble, GLenum);
static void tetrahedron(GLdouble *, GLdouble, GLenum);
static void subdivide(int, GLdouble *, GLdouble *, GLdouble *,
        GLdouble *, GLdouble, GLenum, int);
static void drawtriangle(int, int, int,
        GLdouble *, GLdouble, GLenum, int);
static void recorditem(GLdouble *, GLdouble *, GLdouble *,
        GLdouble *, GLdouble, GLenum, int);
static void initdodec(void);
static void dodecahedron(GLdouble *, GLdouble, GLenum);
static void pentagon(int, int, int, int, int, GLenum);


/*  Render wire frame or solid sphere.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireSphere (GLdouble radius)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (SPHEREWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (SPHEREWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_LINE);
            gluSphere (quadObj, radius, 16, 16);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidSphere (GLdouble radius)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (SPHERESOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (SPHERESOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_FILL);
            gluQuadricNormals (quadObj, GLU_SMOOTH);
            gluSphere (quadObj, radius, 16, 16);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid cube.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireCube (GLdouble size)
{
    GLdouble *sizeArray;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = size;
    displayList = findList (CUBEWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (CUBEWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            drawbox(-size/(GLdouble)2., size/(GLdouble)2., -size/(GLdouble)2., size/(GLdouble)2.,
                -size/(GLdouble)2., size/(GLdouble)2., GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidCube (GLdouble size)
{
    GLdouble *sizeArray;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = size;
    displayList = findList (CUBESOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (CUBESOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            drawbox(-size/(GLdouble)2., size/(GLdouble)2., -size/(GLdouble)2., size/(GLdouble)2.,
                -size/(GLdouble)2., size/(GLdouble)2., GL_QUADS);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid cube.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireBox (GLdouble width, GLdouble height, GLdouble depth)
{
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 3);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = width;
    *tmp++ = height;
    *tmp++ = depth;
    displayList = findList (BOXWIRE, sizeArray, 3);

    if (displayList == 0) {
        glNewList(makeModelPtr (BOXWIRE, sizeArray, 3),
            GL_COMPILE_AND_EXECUTE);
            drawbox(-width/(GLdouble)2., width/(GLdouble)2., -height/(GLdouble)2., height/(GLdouble)2.,
                -depth/(GLdouble)2., depth/(GLdouble)2., GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidBox (GLdouble width, GLdouble height, GLdouble depth)
{
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 3);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = width;
    *tmp++ = height;
    *tmp++ = depth;
    displayList = findList (BOXSOLID, sizeArray, 3);

    if (displayList == 0) {
        glNewList(makeModelPtr (BOXSOLID, sizeArray, 3),
            GL_COMPILE_AND_EXECUTE);
            drawbox(-width/(GLdouble)2., width/(GLdouble)2., -height/(GLdouble)2., height/(GLdouble)2.,
                -depth/(GLdouble)2., depth/(GLdouble)2., GL_QUADS);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid tori.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireTorus (GLdouble innerRadius, GLdouble outerRadius)
{
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = innerRadius;
    *tmp++ = outerRadius;
    displayList = findList (TORUSWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (TORUSWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            doughnut(innerRadius, outerRadius, 5, 10, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidTorus (GLdouble innerRadius, GLdouble outerRadius)
{
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = innerRadius;
    *tmp++ = outerRadius;
    displayList = findList (TORUSSOLID, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (TORUSSOLID, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            doughnut(innerRadius, outerRadius, 8, 15, GL_QUADS);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid cylinders.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireCylinder (GLdouble radius, GLdouble height)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = radius;
    *tmp++ = height;
    displayList = findList (CYLINDERWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (CYLINDERWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            glPushMatrix ();
            glRotatef ((GLfloat)90.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
            glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.0);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_LINE);
            gluCylinder (quadObj, radius, radius, height, 12, 2);
            glPopMatrix ();
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidCylinder (GLdouble radius, GLdouble height)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = radius;
    *tmp++ = height;
    displayList = findList (CYLINDERWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (CYLINDERWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            glPushMatrix ();
            glRotatef ((GLfloat)90.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
            glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.0);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_FILL);
            gluQuadricNormals (quadObj, GLU_SMOOTH);
            gluCylinder (quadObj, radius, radius, height, 12, 2);
            glPopMatrix ();
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid icosahedra.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireIcosahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (ICOSAWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (ICOSAWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            icosahedron (center, radius, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidIcosahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (ICOSASOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (ICOSASOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            icosahedron (center, radius, GL_TRIANGLES);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid octahedra.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireOctahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (OCTAWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (OCTAWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            octahedron (center, radius, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidOctahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (OCTASOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (OCTASOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            octahedron (center, radius, GL_TRIANGLES);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid tetrahedra.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireTetrahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (TETRAWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (TETRAWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            tetrahedron (center, radius, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidTetrahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (TETRASOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (TETRASOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            tetrahedron (center, radius, GL_TRIANGLES);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid dodecahedra.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireDodecahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (DODECAWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (DODECAWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            dodecahedron (center, radius/(GLdouble)1.73, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidDodecahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (DODECASOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (DODECASOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            dodecahedron (center, radius/(GLdouble)1.73, GL_POLYGON);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid cones.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireCone (GLdouble base, GLdouble height)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = base;
    *tmp++ = height;
    displayList = findList (CONEWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (CONEWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_LINE);
            gluCylinder (quadObj, base, (GLdouble)0.0, height, 15, 10);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidCone (GLdouble base, GLdouble height)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = base;
    *tmp++ = height;
    displayList = findList (CONEWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (CONEWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_FILL);
            gluQuadricNormals (quadObj, GLU_SMOOTH);
            gluCylinder (quadObj, base, (GLdouble)0.0, height, 15, 10);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/* Routines to build 3 dimensional solids, including:
 *
 * drawbox, doughnut, icosahedron,
 * octahedron, tetrahedron, dodecahedron.
 */

/* drawbox:
 *
 * draws a rectangular box with the given x, y, and z ranges.
 * The box is axis-aligned.
 */
void drawbox(GLdouble x0, GLdouble x1, GLdouble y0, GLdouble y1,
        GLdouble z0, GLdouble z1, GLenum type)
{
    static GLdouble n[6][3] = {
        {-1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {1.0, 0.0, 0.0},
        {0.0, -1.0, 0.0}, {0.0, 0.0, 1.0}, {0.0, 0.0, -1.0}
    };
    static GLint faces[6][4] = {
        { 0, 1, 2, 3 }, { 3, 2, 6, 7 }, { 7, 6, 5, 4 },
        { 4, 5, 1, 0 }, { 5, 6, 2, 1 }, { 7, 4, 0, 3 }
    };
    GLdouble v[8][3], tmp;
    GLint i;

    if (x0 > x1) {
        tmp = x0; x0 = x1; x1 = tmp;
    }
    if (y0 > y1) {
        tmp = y0; y0 = y1; y1 = tmp;
    }
    if (z0 > z1) {
        tmp = z0; z0 = z1; z1 = tmp;
    }
    v[0][0] = v[1][0] = v[2][0] = v[3][0] = x0;
    v[4][0] = v[5][0] = v[6][0] = v[7][0] = x1;
    v[0][1] = v[1][1] = v[4][1] = v[5][1] = y0;
    v[2][1] = v[3][1] = v[6][1] = v[7][1] = y1;
    v[0][2] = v[3][2] = v[4][2] = v[7][2] = z0;
    v[1][2] = v[2][2] = v[5][2] = v[6][2] = z1;

    for (i = 0; i < 6; i++) {
        glBegin(type);
        glNormal3dv(&n[i][0]);
        glVertex3dv(&v[faces[i][0]][0]);
        glNormal3dv(&n[i][0]);
        glVertex3dv(&v[faces[i][1]][0]);
        glNormal3dv(&n[i][0]);
        glVertex3dv(&v[faces[i][2]][0]);
        glNormal3dv(&n[i][0]);
        glVertex3dv(&v[faces[i][3]][0]);
        glEnd();
    }
}

/* doughnut:
 *
 * draws a doughnut, centered at (0, 0, 0) whose axis is aligned with
 * the z-axis.  The doughnut's major radius is R, and minor radius is r.
 */

void doughnut(GLdouble r, GLdouble R, GLint nsides, GLint rings, GLenum type)
{
    int i, j;
    GLdouble    theta, phi, theta1, phi1;
    GLdouble    p0[03], p1[3], p2[3], p3[3];
    GLdouble    n0[3], n1[3], n2[3], n3[3];

    for (i = 0; i < rings; i++) {
        theta = (GLdouble)i*(GLdouble)2.0*PI/rings;
        theta1 = (GLdouble)(i+1)*(GLdouble)2.0*PI/rings;
        for (j = 0; j < nsides; j++) {
            phi = (GLdouble)j*(GLdouble)2.0*PI/nsides;
            phi1 = (GLdouble)(j+1)*(GLdouble)2.0*PI/nsides;

            p0[0] = cos(theta)*(R + r*cos(phi));
            p0[1] = -sin(theta)*(R + r*cos(phi));
            p0[2] = r*sin(phi);

            p1[0] = cos(theta1)*(R + r*cos(phi));
            p1[1] = -sin(theta1)*(R + r*cos(phi));
            p1[2] = r*sin(phi);

            p2[0] = cos(theta1)*(R + r*cos(phi1));
            p2[1] = -sin(theta1)*(R + r*cos(phi1));
            p2[2] = r*sin(phi1);

            p3[0] = cos(theta)*(R + r*cos(phi1));
            p3[1] = -sin(theta)*(R + r*cos(phi1));
            p3[2] = r*sin(phi1);

            n0[0] = cos(theta)*(cos(phi));
            n0[1] = -sin(theta)*(cos(phi));
            n0[2] = sin(phi);

            n1[0] = cos(theta1)*(cos(phi));
            n1[1] = -sin(theta1)*(cos(phi));
            n1[2] = sin(phi);

            n2[0] = cos(theta1)*(cos(phi1));
            n2[1] = -sin(theta1)*(cos(phi1));
            n2[2] = sin(phi1);

            n3[0] = cos(theta)*(cos(phi1));
            n3[1] = -sin(theta)*(cos(phi1));
            n3[2] = sin(phi1);

            m_xformpt(p0, p0, n0, n0);
            m_xformpt(p1, p1, n1, n1);
            m_xformpt(p2, p2, n2, n2);
            m_xformpt(p3, p3, n3, n3);

            glBegin(type);
                glNormal3dv(n3);
                glVertex3dv(p3);
                glNormal3dv(n2);
                glVertex3dv(p2);
                glNormal3dv(n1);
                glVertex3dv(p1);
                glNormal3dv(n0);
                glVertex3dv(p0);
            glEnd();
        }
    }
}

/* octahedron data: The octahedron produced is centered
 * at the origin and has radius 1.0
 */
static GLdouble odata[6][3] = {
  {1.0, 0.0, 0.0},
  {-1.0, 0.0, 0.0},
  {0.0, 1.0, 0.0},
  {0.0, -1.0, 0.0},
  {0.0, 0.0, 1.0},
  {0.0, 0.0, -1.0}
};

static int ondex[8][3] = {
    {0, 4, 2}, {1, 2, 4}, {0, 3, 4}, {1, 4, 3},
    {0, 2, 5}, {1, 5, 2}, {0, 5, 3}, {1, 3, 5}
};

/* tetrahedron data: */

#define T       1.73205080756887729

static GLdouble tdata[4][3] = {
    {T, T, T}, {T, -T, -T}, {-T, T, -T}, {-T, -T, T}
};

static int tndex[4][3] = {
    {0, 1, 3}, {2, 1, 0}, {3, 2, 0}, {1, 2, 3}
};

/* icosahedron data: These numbers are rigged to
 * make an icosahedron of radius 1.0
 */

#define X .525731112119133606
#define Z .850650808352039932

static GLdouble idata[12][3] = {
  {-X, 0, Z},
  {X, 0, Z},
  {-X, 0, -Z},
  {X, 0, -Z},
  {0, Z, X},
  {0, Z, -X},
  {0, -Z, X},
  {0, -Z, -X},
  {Z, X, 0},
  {-Z, X, 0},
  {Z, -X, 0},
  {-Z, -X, 0}
};

static int index[20][3] = {
    {0, 4, 1},    {0, 9, 4},
    {9, 5, 4},    {4, 5, 8},
    {4, 8, 1},    {8, 10, 1},
    {8, 3, 10},    {5, 3, 8},
    {5, 2, 3},    {2, 7, 3},
    {7, 10, 3},    {7, 6, 10},
    {7, 11, 6},    {11, 0, 6},
    {0, 1, 6},    {6, 1, 10},
    {9, 0, 11},    {9, 11, 2},
    {9, 2, 5},    {7, 2, 11},
};

/* icosahedron:
 *
 * Draws an icosahedron with center at p0 having the
 * given radius.
 */

static void icosahedron(GLdouble p0[3], GLdouble radius, GLenum shadeType)
{
    int i;

    for (i = 0; i < 20; i++)
        drawtriangle(i, 0, 1, p0, radius, shadeType, 0);
}

/* octahedron:
 *
 * Draws an octahedron with center at p0 having the
 * given radius.
 */
static void octahedron(GLdouble p0[3], GLdouble radius, GLenum shadeType)
{
    int i;

    for (i = 0; i < 8; i++)
        drawtriangle(i, 1, 1, p0, radius, shadeType, 0);
}

/* tetrahedron:
 *
 * Draws an tetrahedron with center at p0 having the
 * given radius.
 */

static void tetrahedron(GLdouble p0[3], GLdouble radius, GLenum shadeType)
{
    int i;

    for (i = 0; i < 4; i++)
        drawtriangle(i, 2, 1, p0, radius, shadeType, 0);
}

static void subdivide(int depth, GLdouble *v0, GLdouble *v1, GLdouble *v2,
        GLdouble p0[3], GLdouble radius, GLenum shadeType, int avnormal)
{
    GLdouble w0[3], w1[3], w2[3];
    GLdouble l;
    int i, j, k, n;

    for (i = 0; i < depth; i++)
        for (j = 0; i + j < depth; j++) {
            k = depth - i - j;
            for (n = 0; n < 3; n++) {
                w0[n] = (i*v0[n] + j*v1[n] + k*v2[n])/depth;
                w1[n] = ((i+1)*v0[n] + j*v1[n] + (k-1)*v2[n])/depth;
                w2[n] = (i*v0[n] + (j+1)*v1[n] + (k-1)*v2[n])/depth;
            }
            l = sqrt(w0[0]*w0[0] + w0[1]*w0[1] + w0[2]*w0[2]);
            w0[0] /= l; w0[1] /= l; w0[2] /= l;
            l = sqrt(w1[0]*w1[0] + w1[1]*w1[1] + w1[2]*w1[2]);
            w1[0] /= l; w1[1] /= l; w1[2] /= l;
            l = sqrt(w2[0]*w2[0] + w2[1]*w2[1] + w2[2]*w2[2]);
            w2[0] /= l; w2[1] /= l; w2[2] /= l;
            recorditem(w1, w0, w2, p0, radius, shadeType, avnormal);
        }
    for (i = 0; i < depth-1; i++)
        for (j = 0; i + j < depth-1; j++) {
            k = depth - i - j;
            for (n = 0; n < 3; n++) {
                w0[n] = ((i+1)*v0[n] + (j+1)*v1[n] + (k-2)*v2[n])/depth;
                w1[n] = ((i+1)*v0[n] + j*v1[n] + (k-1)*v2[n])/depth;
                w2[n] = (i*v0[n] + (j+1)*v1[n] + (k-1)*v2[n])/depth;
            }
            l = sqrt(w0[0]*w0[0] + w0[1]*w0[1] + w0[2]*w0[2]);
            w0[0] /= l; w0[1] /= l; w0[2] /= l;
            l = sqrt(w1[0]*w1[0] + w1[1]*w1[1] + w1[2]*w1[2]);
            w1[0] /= l; w1[1] /= l; w1[2] /= l;
            l = sqrt(w2[0]*w2[0] + w2[1]*w2[1] + w2[2]*w2[2]);
            w2[0] /= l; w2[1] /= l; w2[2] /= l;
            recorditem(w0, w1, w2, p0, radius, shadeType, avnormal);
        }
}

static void drawtriangle(int i, int geomType, int depth,
        GLdouble p0[3], GLdouble radius, GLenum shadeType, int avnormal)
{
    GLdouble *x0, *x1, *x2;

    switch (geomType) {
        case 0: /* icosahedron */
            x0 = &idata[index[i][0]][0];
            x1 = &idata[index[i][1]][0];
            x2 = &idata[index[i][2]][0];
            break;
        case 1: /* octahedron */
            x0 = &odata[ondex[i][0]][0];
            x1 = &odata[ondex[i][1]][0];
            x2 = &odata[ondex[i][2]][0];
            break;
        case 2: /* tetrahedron */
            x0 = &tdata[tndex[i][0]][0];
            x1 = &tdata[tndex[i][1]][0];
            x2 = &tdata[tndex[i][2]][0];
            break;
    }
    subdivide(depth, x0, x1, x2, p0, radius, shadeType, avnormal);
}

static void recorditem(GLdouble *n1, GLdouble *n2, GLdouble *n3,
        GLdouble center[3], GLdouble radius, GLenum shadeType, int avnormal)
{
    GLdouble p1[3], p2[3], p3[3], q0[3], q1[3], n11[3], n22[3], n33[3];
    int i;

    for (i = 0; i < 3; i++) {
        p1[i] = n1[i]*radius + center[i];
        p2[i] = n2[i]*radius + center[i];
        p3[i] = n3[i]*radius + center[i];
    }
    if (avnormal == 0) {
        diff3(p1, p2, q0);
        diff3(p2, p3, q1);
        crossprod(q0, q1, q1);
        normalize(q1);
        m_xformpt(p1, p1, q1, n11);
        m_xformptonly(p2, p2);
        m_xformptonly(p3, p3);

        glBegin (shadeType);
        glNormal3dv(n11);
        glVertex3dv(p1);
        glVertex3dv(p2);
        glVertex3dv(p3);
        glEnd();
        return;
    }
    m_xformpt(p1, p1, n1, n11);
    m_xformpt(p2, p2, n2, n22);
    m_xformpt(p3, p3, n3, n33);

    glBegin (shadeType);
    glNormal3dv(n11);
    glVertex3dv(p1);
    glNormal3dv(n22);
    glVertex3dv(p2);
    glNormal3dv(n33);
    glVertex3dv(p3);
    glEnd();
}

static GLdouble dodec[20][3];

static void initdodec()
{
    GLdouble alpha, beta;

    alpha = sqrt((double)2.0/((double)3.0 + sqrt((double)5.0)));
    beta = (double)1.0 + sqrt((double)6.0/((double)3.0 + sqrt((double)5.0)) - (double)2.0 + (double)2.0*sqrt((double)2.0/((double)3.0 +
                                                            sqrt((double)5.0))));
    dodec[0][0] = -alpha; dodec[0][1] = 0; dodec[0][2] = beta;
    dodec[1][0] = alpha; dodec[1][1] = 0; dodec[1][2] = beta;
    dodec[2][0] = -1; dodec[2][1] = -1; dodec[2][2] = -1;
    dodec[3][0] = -1; dodec[3][1] = -1; dodec[3][2] = 1;
    dodec[4][0] = -1; dodec[4][1] = 1; dodec[4][2] = -1;
    dodec[5][0] = -1; dodec[5][1] = 1; dodec[5][2] = 1;
    dodec[6][0] = 1; dodec[6][1] = -1; dodec[6][2] = -1;
    dodec[7][0] = 1; dodec[7][1] = -1; dodec[7][2] = 1;
    dodec[8][0] = 1; dodec[8][1] = 1; dodec[8][2] = -1;
    dodec[9][0] = 1; dodec[9][1] = 1; dodec[9][2] = 1;
    dodec[10][0] = beta; dodec[10][1] = alpha; dodec[10][2] = 0;
    dodec[11][0] = beta; dodec[11][1] = -alpha; dodec[11][2] = 0;
    dodec[12][0] = -beta; dodec[12][1] = alpha; dodec[12][2] = 0;
    dodec[13][0] = -beta; dodec[13][1] = -alpha; dodec[13][2] = 0;
    dodec[14][0] = -alpha; dodec[14][1] = 0; dodec[14][2] = -beta;
    dodec[15][0] = alpha; dodec[15][1] = 0; dodec[15][2] = -beta;
    dodec[16][0] = 0; dodec[16][1] = beta; dodec[16][2] = alpha;
    dodec[17][0] = 0; dodec[17][1] = beta; dodec[17][2] = -alpha;
    dodec[18][0] = 0; dodec[18][1] = -beta; dodec[18][2] = alpha;
    dodec[19][0] = 0; dodec[19][1] = -beta; dodec[19][2] = -alpha;
}

/* dodecahedron:
 *
 * Draws an dodecahedron with center at 0.0. The radius
 * is sqrt(3).
 */
static void dodecahedron(GLdouble center[3], GLdouble sc, GLenum type)
{
    static int inited = 0;

    if ( inited == 0) {
        inited = 1;
        initdodec();
    }
    m_pushmatrix();
    m_translate(center[0], center[1], center[2]);
    m_scale(sc, sc, sc);
    pentagon(0, 1, 9, 16, 5, type);
    pentagon(1, 0, 3, 18, 7, type);
    pentagon(1, 7, 11, 10, 9, type);
    pentagon(11, 7, 18, 19, 6, type);
    pentagon(8, 17, 16, 9, 10, type);
    pentagon(2, 14, 15, 6, 19, type);
    pentagon(2, 13, 12, 4, 14, type);
    pentagon(2, 19, 18, 3, 13, type);
    pentagon(3, 0, 5, 12, 13, type);
    pentagon(6, 15, 8, 10, 11, type);
    pentagon(4, 17, 8, 15, 14, type);
    pentagon(4, 12, 5, 16, 17, type);
    m_popmatrix();
}

static void pentagon(int a, int b, int c, int d, int e, GLenum shadeType)
{
    GLdouble n0[3], d1[3], d2[3], d3[3], d4[3], d5[3], nout[3];

    diff3(&dodec[a][0], &dodec[b][0], d1);
    diff3(&dodec[b][0], &dodec[c][0], d2);
    crossprod(d1, d2, n0);
    normalize(n0);
    m_xformpt(&dodec[a][0], d1, n0, nout);
    m_xformptonly(&dodec[b][0], d2);
    m_xformptonly(&dodec[c][0], d3);
    m_xformptonly(&dodec[d][0], d4);
    m_xformptonly(&dodec[e][0], d5);

    glBegin (shadeType);
    glNormal3dv(nout);
    glVertex3dv(d1);
    glVertex3dv(d2);
    glVertex3dv(d3);
    glVertex3dv(d4);
    glVertex3dv(d5);
    glEnd();
}

/*      linked lists--display lists for each different
 *      type of geometric objects.  The linked list is
 *      searched, until an object of the requested
 *      size is found.  If no geometric object of that size
 *      has been previously made, a new one is created.
 */
GLuint findList (int index, GLdouble *paramArray, int size)
{
    MODELPTR endList;
    int found = 0;

    endList = lists[index];
    while (endList != NULL) {
        if (compareParams (endList->params, paramArray, size))
            return (endList->list);
        endList = endList->ptr;
    }
/*  if not found, return 0 and calling routine should
 *  make a new list
 */
    return (0);
}

int compareParams (GLdouble *oneArray, GLdouble *twoArray, int size)
{
    int i;
    int matches = 1;

    for (i = 0; (i < size) && matches; i++) {
        if (*oneArray++ != *twoArray++)
            matches = 0;
    }
    return (matches);
}

GLuint makeModelPtr (int index, GLdouble *sizeArray, int count)
{
    MODELPTR newModel;

    newModel = (MODELPTR) malloc (sizeof (MODEL));
    if (!newModel)
        return 0;
    newModel->list = glGenLists (1);
    newModel->numParam = count;
    newModel->params = sizeArray;
    newModel->ptr = lists[index];
    lists[index] = newModel;

    return (newModel->list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\teapot.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <GL/gl.h>
#include <gl/glaux.h>
#include "teapot.h"

#define static

long GRD;

#define TEAPOTSOLID 0
#define TEAPOTWIRE 1

static GLuint teapots[2] = {0, 0};

static float tex[2][2][2] = {{{0, 0},{1, 0}},{{0, 1},{1, 1}}};

static void solidTeapot(long grid, GLdouble scale)
{
    float p[4][4][3], q[4][4][3], r[4][4][3], s[4][4][3];
    long i, j, k, l;

    if (grid < 2) grid = 7;
    GRD = grid;
    teapots[TEAPOTSOLID] = glGenLists (1);
    glNewList(teapots[TEAPOTSOLID], GL_COMPILE);
    glPushMatrix ();
    glRotatef ((GLfloat)270.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
    glScalef ((GLdouble)0.5*scale, (GLdouble)0.5*scale, (GLdouble)0.5*scale);
    glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.5);
    for (i = 0; i < 10; i++) {
	for (j = 0; j < 4; j++)
	    for (k = 0; k < 4; k++) 
		for (l = 0; l < 3; l++) {
		    p[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
		    q[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
		    if (l == 1) q[j][k][l] *= (float)-1.0;
		    if (i < 6) {
			r[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
			if (l == 0) r[j][k][l] *= (float)-1.0;
			s[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
			if (l == 0) s[j][k][l] *= (float)-1.0;
			if (l == 1) s[j][k][l] *= (float)-1.0;
		    }
		}
	glMap2f(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2, 0, 1, 4, 2, &tex[0][0][0]);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &p[0][0][0]);
	glEnable(GL_MAP2_VERTEX_3); glEnable(GL_MAP2_TEXTURE_COORD_2);
	glMapGrid2f(GRD, (GLfloat)0.0, (GLfloat)1.0, GRD, (GLfloat)0.0, (GLfloat)1.0);
	glEvalMesh2(GL_FILL, 0, GRD, 0, GRD);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &q[0][0][0]);
	glEvalMesh2(GL_FILL, 0, GRD, 0, GRD);
	if (i < 6) {
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &r[0][0][0]);
	    glEvalMesh2(GL_FILL, 0, GRD, 0, GRD);
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &s[0][0][0]);
	    glEvalMesh2(GL_FILL, 0, GRD, 0, GRD);
	}
    }
    glDisable(GL_MAP2_VERTEX_3); glDisable(GL_MAP2_TEXTURE_COORD_2);
    glPopMatrix ();
    glEndList();
}

static void wireTeapot(long grid, GLdouble scale)
{
    float p[4][4][3], q[4][4][3], r[4][4][3], s[4][4][3];
    long i, j, k, l;
    
    if (grid < 2) grid = 7;
    GRD = grid;
    teapots[TEAPOTWIRE] = glGenLists (1);
    glNewList(teapots[TEAPOTWIRE], GL_COMPILE);
    glPushMatrix ();
    glRotatef ((GLfloat)270.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
    glScalef ((GLdouble)0.5*scale, (GLdouble)0.5*scale, (GLdouble)0.5*scale);
    glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.5);
    for (i = 0; i < 10; i++) {
	for (j = 0; j < 4; j++)
	    for (k = 0; k < 4; k++) 
		for (l = 0; l < 3; l++) {
		    p[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
		    q[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
		    if (l == 1) q[j][k][l] *= (float)-1.0;
		    if (i < 6) {
			r[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
			if (l == 0) r[j][k][l] *= (float)-1.0;
			s[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
			if (l == 0) s[j][k][l] *= (float)-1.0;
			if (l == 1) s[j][k][l] *= (float)-1.0;
		    }
		}
	glMap2f(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2, 0, 1, 4, 2, &tex[0][0][0]);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &p[0][0][0]);
	glEnable(GL_MAP2_VERTEX_3); glEnable(GL_MAP2_TEXTURE_COORD_2);
	glMapGrid2f(GRD, (GLfloat)0.0, (GLfloat)1.0, GRD, (GLfloat)0.0, (GLfloat)1.0);
	glEvalMesh2(GL_LINE, 0, GRD, 0, GRD);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &q[0][0][0]);
	glEvalMesh2(GL_LINE, 0, GRD, 0, GRD);
	if (i < 6) {
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &r[0][0][0]);
	    glEvalMesh2(GL_LINE, 0, GRD, 0, GRD);
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &s[0][0][0]);
	    glEvalMesh2(GL_LINE, 0, GRD, 0, GRD);
	}
    }
    glDisable(GL_MAP2_VERTEX_3); glDisable(GL_MAP2_TEXTURE_COORD_2);
    glPopMatrix ();
    glEndList();
}

void auxSolidTeapot(GLdouble scale)
{
    if (glIsList(teapots[TEAPOTSOLID]) == 0)
	solidTeapot (14, scale);
    glCallList(teapots[TEAPOTSOLID]);
}

void auxWireTeapot(GLdouble scale)
{
    if (glIsList(teapots[TEAPOTWIRE]) == 0)
	wireTeapot (10, scale);
    glCallList(teapots[TEAPOTWIRE]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\teapot.h ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/* Rim, body, lid, and bottom data must be reflected in x and y; 
 * handle and spout data across the y axis only.
 */

long patchdata[][16] = {
    {102,103,104,105,4,5,6,7,8,9,10,11,12,13,14,15},		   /* rim */
    {12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27},		   /* body */
    {24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40},		   /* body */
    {96,96,96,96,97,98,99,100,101,101,101,101,0,1,2,3,},	   /* lid */
    {0,1,2,3,106,107,108,109,110,111,112,113,114,115,116,117},	   /* lid */
    {118,118,118,118,124,122,119,121,123,126,125,120,40,39,38,37}, /* bottom */
    {41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56},		   /* handle */
    {53,54,55,56,57,58,59,60,61,62,63,64,28,65,66,67},		   /* handle */
    {68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83},		   /* spout */
    {80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95}		   /* spout */
};

#pragma warning (disable:4244)
#pragma warning (disable:4305)

float cpdata[][3] = {
{0.2,0,2.7},{0.2,-0.112,2.7},{0.112,-0.2,2.7},{0,-0.2,2.7},{1.3375,0,2.53125},
{1.3375,-0.749,2.53125},{0.749,-1.3375,2.53125},{0,-1.3375,2.53125},
{1.4375,0,2.53125},{1.4375,-0.805,2.53125},{0.805,-1.4375,2.53125},
{0,-1.4375,2.53125},{1.5,0,2.4},{1.5,-0.84,2.4},{0.84,-1.5,2.4},{0,-1.5,2.4},
{1.75,0,1.875},{1.75,-0.98,1.875},{0.98,-1.75,1.875},{0,-1.75,1.875},{2,0,1.35},
{2,-1.12,1.35},{1.12,-2,1.35},{0,-2,1.35},{2,0,0.9},{2,-1.12,0.9},{1.12,-2,0.9},
{0,-2,0.9},{-2,0,0.9},{2,0,0.45},{2,-1.12,0.45},{1.12,-2,0.45},{0,-2,0.45},
{1.5,0,0.225},{1.5,-0.84,0.225},{0.84,-1.5,0.225},{0,-1.5,0.225},{1.5,0,0.15},
{1.5,-0.84,0.15},{0.84,-1.5,0.15},{0,-1.5,0.15},{-1.6,0,2.025},{-1.6,-0.3,2.025},
{-1.5,-0.3,2.25},{-1.5,0,2.25},{-2.3,0,2.025},{-2.3,-0.3,2.025},{-2.5,-0.3,2.25},
{-2.5,0,2.25},{-2.7,0,2.025},{-2.7,-0.3,2.025},{-3,-0.3,2.25},{-3,0,2.25},
{-2.7,0,1.8},{-2.7,-0.3,1.8},{-3,-0.3,1.8},{-3,0,1.8},{-2.7,0,1.575},
{-2.7,-0.3,1.575},{-3,-0.3,1.35},{-3,0,1.35},{-2.5,0,1.125},{-2.5,-0.3,1.125},
{-2.65,-0.3,0.9375},{-2.65,0,0.9375},{-2,-0.3,0.9},{-1.9,-0.3,0.6},{-1.9,0,0.6},
{1.7,0,1.425},{1.7,-0.66,1.425},{1.7,-0.66,0.6},{1.7,0,0.6},{2.6,0,1.425},
{2.6,-0.66,1.425},{3.1,-0.66,0.825},{3.1,0,0.825},{2.3,0,2.1},{2.3,-0.25,2.1},
{2.4,-0.25,2.025},{2.4,0,2.025},{2.7,0,2.4},{2.7,-0.25,2.4},{3.3,-0.25,2.4},
{3.3,0,2.4},{2.8,0,2.475},{2.8,-0.25,2.475},{3.525,-0.25,2.49375},
{3.525,0,2.49375},{2.9,0,2.475},{2.9,-0.15,2.475},{3.45,-0.15,2.5125},
{3.45,0,2.5125},{2.8,0,2.4},{2.8,-0.15,2.4},{3.2,-0.15,2.4},{3.2,0,2.4},
{0,0,3.15},{0.8,0,3.15},{0.8,-0.45,3.15},{0.45,-0.8,3.15},{0,-0.8,3.15},
{0,0,2.85},{1.4,0,2.4},{1.4,-0.784,2.4},{0.784,-1.4,2.4},{0,-1.4,2.4},
{0.4,0,2.55},{0.4,-0.224,2.55},{0.224,-0.4,2.55},{0,-0.4,2.55},{1.3,0,2.55},
{1.3,-0.728,2.55},{0.728,-1.3,2.55},{0,-1.3,2.55},{1.3,0,2.4},{1.3,-0.728,2.4},
{0.728,-1.3,2.4},{0,-1.3,2.4},{0,0,0},{1.425,-0.798,0},{1.5,0,0.075},{1.425,0,0},
{0.798,-1.425,0},{0,-1.5,0.075},{0,-1.425,0},{1.5,-0.84,0.075},{0.84,-1.5,0.075}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\image.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <gl/glaux.h>
#include "tk.h"

#define static


AUX_RGBImageRec * APIENTRY auxRGBImageLoadA(LPCSTR filename)
{
    return (AUX_RGBImageRec *)tkRGBImageLoadAW((char *)filename, FALSE);
}

AUX_RGBImageRec * APIENTRY auxRGBImageLoadW(LPCWSTR filename)
{
    return (AUX_RGBImageRec *)tkRGBImageLoadAW((char *)filename, TRUE);
}

AUX_RGBImageRec * APIENTRY auxDIBImageLoadA(LPCSTR filename)
{
    return (AUX_RGBImageRec *)tkDIBImageLoadAW((char *)filename, FALSE);
}

AUX_RGBImageRec * APIENTRY auxDIBImageLoadW(LPCWSTR filename)
{
    return (AUX_RGBImageRec *)tkDIBImageLoadAW((char *)filename, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\tk.h ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#ifndef __tk_h__
#define __tk_h__

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** Window Types
*/

#define TK_RGB		0
#define TK_INDEX	1
#define TK_SINGLE	0
#define TK_DOUBLE	2
#define TK_DIRECT	0
#define TK_INDIRECT	4
#define TK_ACCUM	8
#define TK_ALPHA	16
#define TK_DEPTH24      32      /* 24-bit depth buffer */
#define TK_STENCIL      64
#define TK_DEPTH16      256     /* 16-bit depth buffer */
#define TK_FIXED_332_PAL    512
#define TK_DEPTH        TK_DEPTH16 /* default is 16-bit depth buffer */

/*
** Display Mode Selection Criteria
*/

enum {
    TK_USE_ID = 1,
    TK_EXACT_MATCH,
    TK_MINIMUM_CRITERIA
};

/* 
** Window Masks
*/

#define TK_IS_RGB(x)		(((x) & TK_INDEX) == 0)
#define TK_IS_INDEX(x)		(((x) & TK_INDEX) != 0)
#define TK_IS_SINGLE(x)		(((x) & TK_DOUBLE) == 0)
#define TK_IS_DOUBLE(x)		(((x) & TK_DOUBLE) != 0)
#define TK_HAS_ACCUM(x)		(((x) & TK_ACCUM) != 0)
#define TK_HAS_ALPHA(x)		(((x) & TK_ALPHA) != 0)
#define TK_HAS_DEPTH(x)         (((x) & (TK_DEPTH24 | TK_DEPTH16)) != 0)
#define TK_HAS_STENCIL(x)	(((x) & TK_STENCIL) != 0)
#define TK_IS_DIRECT(x)		(((x) & TK_INDIRECT) == 0)
#define TK_IS_INDIRECT(x)       (((x) & TK_INDIRECT) != 0)
#define TK_USE_FIXED_332_PAL(x) (((x) & TK_FIXED_332_PAL) != 0)
#define TK_IS_DEPTH16(x)        (((x) & TK_DEPTH16) != 0)

/*
** Event Status
*/

#define	TK_LEFTBUTTON		1
#define	TK_RIGHTBUTTON		2
#define	TK_MIDDLEBUTTON		4
#define	TK_SHIFT		1
#define	TK_CONTROL		2

/* 
** Key Codes
*/

#define TK_RETURN		0x0D
#define TK_ESCAPE		0x1B
#define TK_SPACE		0x20
#define TK_LEFT			0x25
#define TK_UP			0x26
#define TK_RIGHT		0x27
#define TK_DOWN			0x28
#define TK_A			'A'
#define TK_B			'B'
#define TK_C			'C'
#define TK_D			'D'
#define TK_E			'E'
#define TK_F			'F'
#define TK_G			'G'
#define TK_H			'H'
#define TK_I			'I'
#define TK_J			'J'
#define TK_K			'K'
#define TK_L			'L'
#define TK_M			'M'
#define TK_N			'N'
#define TK_O			'O'
#define TK_P			'P'
#define TK_Q			'Q'
#define TK_R			'R'
#define TK_S			'S'
#define TK_T			'T'
#define TK_U			'U'
#define TK_V			'V'
#define TK_W			'W'
#define TK_X			'X'
#define TK_Y			'Y'
#define TK_Z			'Z'
#define TK_a			'a'
#define TK_b			'b'
#define TK_c			'c'
#define TK_d			'd'
#define TK_e			'e'
#define TK_f			'f'
#define TK_g			'g'
#define TK_h			'h'
#define TK_i			'i'
#define TK_j			'j'
#define TK_k			'k'
#define TK_l			'l'
#define TK_m			'm'
#define TK_n			'n'
#define TK_o			'o'
#define TK_p			'p'
#define TK_q			'q'
#define TK_r			'r'
#define TK_s			's'
#define TK_t			't'
#define TK_u			'u'
#define TK_v			'v'
#define TK_w			'w'
#define TK_x			'x'
#define TK_y			'y'
#define TK_z			'z'
#define TK_0			'0'
#define TK_1			'1'
#define TK_2			'2'
#define TK_3			'3'
#define TK_4			'4'
#define TK_5			'5'
#define TK_6			'6'
#define TK_7			'7'
#define TK_8			'8'
#define TK_9			'9'

/*
** Color Macros - Default Windows Logical palette
*/

enum {
    TK_BLACK = 0,
    TK_RED = 13,
    TK_GREEN,
    TK_YELLOW,
    TK_BLUE,
    TK_MAGENTA,
    TK_CYAN,
    TK_WHITE
};

extern float auxRGBMap[20][3];
#define tkRGBMap auxRGBMap

#define TK_SETCOLOR(x, y) (TK_IS_RGB((x)) ? \
		           glColor3fv(auxRGBMap[(y)]) : glIndexf((y)))

/*
** RGB Image Structure
*/

typedef struct _TK_RGBImageRec {
    GLint sizeX, sizeY;
    unsigned char *data;
} TK_RGBImageRec;

/*
** Prototypes
*/

extern void tkInitDisplayMode(GLenum);
extern void tkInitPosition(int, int, int, int);
extern void tkInitDisplayModePolicy(GLenum);
extern GLenum tkInitDisplayModeID(GLint);
extern GLenum tkInitWindow(char *);
extern GLenum tkInitWindowAW(char *, BOOL);
extern void tkCloseWindow(void);
extern void tkQuit(void);

extern void tkExec(void);
extern void tkExposeFunc(void (*)(int, int));
extern void tkReshapeFunc(void (*)(int, int));
extern void tkDisplayFunc(void (*)(void));
extern void tkKeyDownFunc(GLenum (*)(int, GLenum));
extern void tkMouseDownFunc(GLenum (*)(int, int, GLenum));
extern void tkMouseUpFunc(GLenum (*)(int, int, GLenum));
extern void tkMouseMoveFunc(GLenum (*)(int, int, GLenum));
extern void tkIdleFunc(void (*)(void));

extern void tkSwapBuffers(void);

extern GLint tkGetColorMapSize(void);
extern void tkGetMouseLoc(int *, int *);
extern GLint tkGetDisplayModeID(void);
extern GLenum tkGetDisplayModePolicy(void);
extern GLenum tkGetDisplayMode(void);

extern void tkSetOneColor(int, float, float, float);
extern void tkSetFogRamp(int, int);
extern void tkSetGreyRamp(void);
extern void tkSetRGBMap(int, float *);

extern TK_RGBImageRec *tkRGBImageLoad(char *);
extern TK_RGBImageRec *tkRGBImageLoadAW(char *, BOOL);

extern TK_RGBImageRec *tkDIBImageLoad(char *);
extern TK_RGBImageRec *tkDIBImageLoadAW(char *, BOOL);

extern GLenum tkCreateStrokeFont(GLuint);
extern GLenum tkCreateOutlineFont(GLuint);
extern GLenum tkCreateFilledFont(GLuint);
extern GLenum tkCreateBitmapFont(GLuint);
extern void tkDrawStr(GLuint, char *);

/* Windows specific routines */
extern HWND  tkGetHWND(void);
extern HDC   tkGetHDC(void);
extern HGLRC tkGetHRC(void);

/* Error popup control */
extern void tkErrorPopups(GLboolean);
extern GLboolean tkPopupEnable;
#define MESSAGEBOX(a, b, c, d)  if (tkPopupEnable) MessageBoxA((a), (b), (c), (d))

#ifdef __cplusplus
}
#endif

#endif // __tk_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\tk.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "tk.h"
#include "windows.h"

#if(WINVER < 0x0400)
// Ordinarily not defined for versions before 4.00.
#define COLOR_3DDKSHADOW        21
#define COLOR_3DLIGHT           22
#define COLOR_INFOTEXT          23
#define COLOR_INFOBK            24
#endif

#define static

#if defined(__cplusplus) || defined(c_plusplus)
#define class c_class
#endif

#if DBG
#define TKASSERT(x)                                     \
if ( !(x) ) {                                           \
    PrintMessage("%s(%d) Assertion failed %s\n",        \
        __FILE__, __LINE__, #x);                        \
}
#else
#define TKASSERT(x)
#endif  /* DBG */

/******************************************************************************/

static struct _WINDOWINFO {
    int x, y;
    int width, height;
    GLenum type;
    GLenum dmPolicy;
    int ipfd;
    BOOL bDefPos;
} windInfo = {
    0, 0, 100, 100, TK_INDEX | TK_SINGLE, TK_MINIMUM_CRITERIA, 0, TRUE
};


HWND     tkhwnd     = NULL;
HDC      tkhdc      = NULL;
static HGLRC    tkhrc      = NULL;
HPALETTE tkhpalette = NULL;
static OSVERSIONINFO tkOSVerInfo;
GLboolean tkPopupEnable = TRUE;

// Fixed palette support.

#define BLACK   PALETTERGB(0,0,0)
#define WHITE   PALETTERGB(255,255,255)
#define MAX_STATIC_COLORS   (COLOR_INFOBK - COLOR_SCROLLBAR + 1)
static int tkNumStaticColors = MAX_STATIC_COLORS;

// TRUE if app wants to take over palette
static BOOL tkUseStaticColors = FALSE;

// TRUE if static system color settings have been replaced with B&W settings.
BOOL tkSystemColorsInUse = FALSE;

// TRUE if original static colors saved
static BOOL tkStaticColorsSaved = FALSE;

// saved system static colors (initialize with default colors)
static COLORREF gacrSave[MAX_STATIC_COLORS];

// new B&W system static colors
static COLORREF gacrBlackAndWhite[] = {
    WHITE,  // COLOR_SCROLLBAR
    BLACK,  // COLOR_BACKGROUND
    BLACK,  // COLOR_ACTIVECAPTION
    WHITE,  // COLOR_INACTIVECAPTION
    WHITE,  // COLOR_MENU
    WHITE,  // COLOR_WINDOW
    BLACK,  // COLOR_WINDOWFRAME
    BLACK,  // COLOR_MENUTEXT
    BLACK,  // COLOR_WINDOWTEXT
    WHITE,  // COLOR_CAPTIONTEXT
    WHITE,  // COLOR_ACTIVEBORDER
    WHITE,  // COLOR_INACTIVEBORDER
    WHITE,  // COLOR_APPWORKSPACE
    BLACK,  // COLOR_HIGHLIGHT
    WHITE,  // COLOR_HIGHLIGHTTEXT
    WHITE,  // COLOR_BTNFACE
    BLACK,  // COLOR_BTNSHADOW
    BLACK,  // COLOR_GRAYTEXT
    BLACK,  // COLOR_BTNTEXT
    BLACK,  // COLOR_INACTIVECAPTIONTEXT
    BLACK,  // COLOR_BTNHIGHLIGHT
    BLACK,  // COLOR_3DDKSHADOW
    WHITE,  // COLOR_3DLIGHT
    BLACK,  // COLOR_INFOTEXT
    WHITE   // COLOR_INFOBK
    };
static INT gaiStaticIndex[] = {
    COLOR_SCROLLBAR          ,
    COLOR_BACKGROUND         ,
    COLOR_ACTIVECAPTION      ,
    COLOR_INACTIVECAPTION    ,
    COLOR_MENU               ,
    COLOR_WINDOW             ,
    COLOR_WINDOWFRAME        ,
    COLOR_MENUTEXT           ,
    COLOR_WINDOWTEXT         ,
    COLOR_CAPTIONTEXT        ,
    COLOR_ACTIVEBORDER       ,
    COLOR_INACTIVEBORDER     ,
    COLOR_APPWORKSPACE       ,
    COLOR_HIGHLIGHT          ,
    COLOR_HIGHLIGHTTEXT      ,
    COLOR_BTNFACE            ,
    COLOR_BTNSHADOW          ,
    COLOR_GRAYTEXT           ,
    COLOR_BTNTEXT            ,
    COLOR_INACTIVECAPTIONTEXT,
    COLOR_BTNHIGHLIGHT       ,
    COLOR_3DDKSHADOW         ,
    COLOR_3DLIGHT            ,
    COLOR_INFOTEXT           ,
    COLOR_INFOBK
    };

static BOOL GrabStaticEntries(HDC);
static BOOL ReleaseStaticEntries(HDC);

#define RESTORE_FROM_REGISTRY   1
#if RESTORE_FROM_REGISTRY
// Registry names for the system colors.
CHAR *gaszSysClrNames[] = {
    "Scrollbar",      // COLOR_SCROLLBAR              0
    "Background",     // COLOR_BACKGROUND             1   (also COLOR_DESKTOP)
    "ActiveTitle",    // COLOR_ACTIVECAPTION          2
    "InactiveTitle",  // COLOR_INACTIVECAPTION        3
    "Menu",           // COLOR_MENU                   4
    "Window",         // COLOR_WINDOW                 5
    "WindowFrame",    // COLOR_WINDOWFRAME            6
    "MenuText",       // COLOR_MENUTEXT               7
    "WindowText",     // COLOR_WINDOWTEXT             8
    "TitleText",      // COLOR_CAPTIONTEXT            9
    "ActiveBorder",   // COLOR_ACTIVEBORDER          10
    "InactiveBorder", // COLOR_INACTIVEBORDER        11
    "AppWorkspace",   // COLOR_APPWORKSPACE          12
    "Hilight",        // COLOR_HIGHLIGHT             13
    "HilightText",    // COLOR_HIGHLIGHTTEXT         14
    "ButtonFace",     // COLOR_BTNFACE               15   (also COLOR_3DFACE)
    "ButtonShadow",   // COLOR_BTNSHADOW             16   (also COLOR_3DSHADOW)
    "GrayText",       // COLOR_GRAYTEXT              17
    "ButtonText",     // COLOR_BTNTEXT               18
    "InactiveTitleText", // COLOR_INACTIVECAPTIONTEXT   19
    "ButtonHilight",  // COLOR_BTNHIGHLIGHT          20   (also COLOR_3DHILIGHT)
    "ButtonDkShadow", // COLOR_3DDKSHADOW            21
    "ButtonLight",    // COLOR_3DLIGHT               22
    "InfoText",       // COLOR_INFOTEXT              23
    "InfoWindow"      // COLOR_INFOBK                24
};

static BOOL GetRegistrySysColors(COLORREF *, int);
#endif

static void (*ExposeFunc)(int, int)              = NULL;
static void (*ReshapeFunc)(int, int)             = NULL;
static void (*DisplayFunc)(void)                 = NULL;
static GLenum (*KeyDownFunc)(int, GLenum)        = NULL;
static GLenum (*MouseDownFunc)(int, int, GLenum) = NULL;
static GLenum (*MouseUpFunc)(int, int, GLenum)   = NULL;
static GLenum (*MouseMoveFunc)(int, int, GLenum) = NULL;
static void (*IdleFunc)(void)                    = NULL;

static char     *lpszClassName = "tkLibWClass";
static WCHAR    *lpszClassNameW = L"tkLibWClass";

static LRESULT tkWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
static unsigned char ComponentFromIndex(int i, int nbits, int shift );
static void PrintMessage( const char *Format, ... );
static PALETTEENTRY *FillRgbPaletteEntries( PIXELFORMATDESCRIPTOR *Pfd, PALETTEENTRY *Entries, UINT Count );
static HPALETTE CreateCIPalette( HDC Dc );
static HPALETTE CreateRGBPalette( HDC hdc );
static void DestroyThisWindow( HWND Window );
static void CleanUp( void );
static void DelayPaletteRealization( void );
static long RealizePaletteNow( HDC Dc, HPALETTE Palette, BOOL bForceBackground );
static void ForceRedraw( HWND Window );
static BOOL FindPixelFormat(HDC hdc, GLenum type);
static int FindBestPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd);
static int FindExactPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd);
static BOOL IsPixelFormatValid(HDC hdc, int ipfd, PIXELFORMATDESCRIPTOR *ppfd);
static int PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd );
static void *AllocateMemory( size_t Size );
static void *AllocateZeroedMemory( size_t Size );
static void FreeMemory( void *Chunk );

/*
 *  Prototypes for the debugging functions go here
 */

#define DBGFUNC 0
#if DBGFUNC

static void DbgPrintf( const char *Format, ... );
static void pwi( void );
static void pwr(RECT *pr);
static void ShowPixelFormat(HDC hdc);

#endif

static float colorMaps[] = {
    0.000000F, 1.000000F, 0.000000F, 1.000000F, 0.000000F, 1.000000F,
    0.000000F, 1.000000F, 0.333333F, 0.776471F, 0.443137F, 0.556863F,
    0.443137F, 0.556863F, 0.219608F, 0.666667F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.039216F, 0.078431F, 0.117647F, 0.156863F,
    0.200000F, 0.239216F, 0.278431F, 0.317647F, 0.356863F, 0.400000F,
    0.439216F, 0.478431F, 0.517647F, 0.556863F, 0.600000F, 0.639216F,
    0.678431F, 0.717647F, 0.756863F, 0.800000F, 0.839216F, 0.878431F,
    0.917647F, 0.956863F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 0.000000F, 0.000000F,
    1.000000F, 1.000000F, 0.000000F, 0.000000F, 1.000000F, 1.000000F,
    0.333333F, 0.443137F, 0.776471F, 0.556863F, 0.443137F, 0.219608F,
    0.556863F, 0.666667F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.039216F, 0.078431F, 0.117647F, 0.156863F, 0.200000F, 0.239216F,
    0.278431F, 0.317647F, 0.356863F, 0.400000F, 0.439216F, 0.478431F,
    0.517647F, 0.556863F, 0.600000F, 0.639216F, 0.678431F, 0.717647F,
    0.756863F, 0.800000F, 0.839216F, 0.878431F, 0.917647F, 0.956863F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 0.333333F, 0.443137F,
    0.443137F, 0.219608F, 0.776471F, 0.556863F, 0.556863F, 0.666667F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.039216F, 0.078431F,
    0.117647F, 0.156863F, 0.200000F, 0.239216F, 0.278431F, 0.317647F,
    0.356863F, 0.400000F, 0.439216F, 0.478431F, 0.517647F, 0.556863F,
    0.600000F, 0.639216F, 0.678431F, 0.717647F, 0.756863F, 0.800000F,
    0.839216F, 0.878431F, 0.917647F, 0.956863F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
};

/* Default Palette */
float auxRGBMap[20][3] = {
    { 0.0F, 0.0F, 0.0F },                               /* 0: black */
    { 0x80/255.0F, 0.0F, 0.0F },                        /* 1: Half red */
    { 0.0F, 0x80/255.0F, 0.0F },                        /* 2: Half green */
    { 0x80/255.0F, 0x80/255.0F, 0.0F },                 /* 3: Half yellow */
    { 0.0F, 0.0F, 0x80/255.0F },                        /* 4: Half blue */
    { 0x80/255.0F, 0.0F, 0x80/255.0F },                 /* 5: Half magenta */
    { 0.0F, 0x80/255.0F, 0x80/255.0F },                 /* 6: Half cyan */
    { 0xC0/255.0F, 0xC0/255.0F, 0xC0/255.0F },          /* 7: Light gray */
    { 0xC0/255.0F, 0xDC/255.0F, 0xC0/255.0F },          /* 8: Green gray */
    { 0xA6/255.0F, 0xCA/255.0F, 0xF0/255.0F },          /* 9: Half gray */
    { 1.0F, 0xFB/255.0F, 0xF0/255.0F },                 /* 10: Pale */
    { 0xA0/255.0F, 0xA0/255.0F, 0xA4/255.0F },          /* 11: Med gray */
    { 0x80/255.0F, 0x80/255.0F, 0x80/255.0F },          /* 12: Dark gray */
    { 1.0F, 0.0F, 0.0F },                               /* 13: red */
    { 0.0F, 1.0F, 0.0F },                               /* 14: green */
    { 1.0F, 1.0F, 0.0F },                               /* 15: yellow */
    { 0.0F, 0.0F, 1.0F },                               /* 16: blue */
    { 1.0F, 0.0F, 1.0F },                               /* 17: magenta */
    { 0.0F, 1.0F, 1.0F },                               /* 18: cyan */
    { 1.0F, 1.0F, 1.0F },                               /* 19: white */
};

/***************************************************************
 *                                                             *
 *  Exported Functions go here                                 *
 *                                                             *
 ***************************************************************/

void tkErrorPopups(GLboolean bEnable)
{
    tkPopupEnable = bEnable;
}

void tkCloseWindow(void)
{
    DestroyThisWindow(tkhwnd);
}


void tkExec(void)
{
    MSG Message;

    /*
     *  WM_SIZE gets delivered before we get here!
     */

    if (ReshapeFunc)
    {
        RECT ClientRect;

        GetClientRect(tkhwnd, &ClientRect);
        (*ReshapeFunc)(ClientRect.right, ClientRect.bottom);
    }

    while (GL_TRUE)
    {
        /*
         *  Process all pending messages
         */

        if (IdleFunc) {
            while (PeekMessage(&Message, NULL, 0, 0, PM_NOREMOVE) == TRUE) {
                if (GetMessage(&Message, NULL, 0, 0) ) {
                    TranslateMessage(&Message);
                    DispatchMessage(&Message);
                } else {
                    /*
                     *  Nothing else to do here, just return
                     */

                    return;
                }
            }

            /*
             *  If an idle function was defined, call it
             */

            if (IdleFunc) {
                (*IdleFunc)();
            }
        } else {
            if (GetMessage(&Message, NULL, 0, 0)) {
                TranslateMessage(&Message);
                DispatchMessage(&Message);
            } else {
                return;
            }
        }
    }
}

void tkExposeFunc(void (*Func)(int, int))
{
    ExposeFunc = Func;
}

void tkReshapeFunc(void (*Func)(int, int))
{
    ReshapeFunc = Func;
}

void tkDisplayFunc(void (*Func)(void))
{
    DisplayFunc = Func;
}

void tkKeyDownFunc(GLenum (*Func)(int, GLenum))
{
    KeyDownFunc = Func;
}

void tkMouseDownFunc(GLenum (*Func)(int, int, GLenum))
{
    MouseDownFunc = Func;
}

void tkMouseUpFunc(GLenum (*Func)(int, int, GLenum))
{
    MouseUpFunc = Func;
}

void tkMouseMoveFunc(GLenum (*Func)(int, int, GLenum))
{
    MouseMoveFunc = Func;
}

void tkIdleFunc(void (*Func)(void))
{
    IdleFunc = Func;
}

void tkInitPosition(int x, int y, int width, int height)
{
    if (x == CW_USEDEFAULT)
    {
        x = 0;
        y = 0;
        windInfo.bDefPos = TRUE;
    }
    else
        windInfo.bDefPos = FALSE;

    windInfo.x = x + GetSystemMetrics(SM_CXFRAME);
    windInfo.y = y + GetSystemMetrics(SM_CYCAPTION)
                 - GetSystemMetrics(SM_CYBORDER)
                 + GetSystemMetrics(SM_CYFRAME);
    windInfo.width = width;
    windInfo.height = height;
}

void tkInitDisplayMode(GLenum type)
{
    windInfo.type = type;
}

void tkInitDisplayModePolicy(GLenum type)
{
    windInfo.dmPolicy = type;
}

GLenum tkInitDisplayModeID(GLint ipfd)
{
    windInfo.ipfd = ipfd;
    return GL_TRUE;
}

// Initialize a window, create a rendering context for that window
GLenum tkInitWindow(char *title)
{
    TKASSERT( NULL==tkhwnd      );
    TKASSERT( NULL==tkhdc       );
    TKASSERT( NULL==tkhrc       );
    TKASSERT( NULL==tkhpalette  );

    return tkInitWindowAW(title, FALSE);
}

GLenum tkInitWindowAW(char *title, BOOL bUnicode)
{
    WNDCLASS wndclass;
    RECT     WinRect;
    HANDLE   hInstance;
    ATOM     aRegister;
    GLenum   Result = GL_FALSE;
    BOOL     bGetVersionExRet;

    hInstance = GetModuleHandle(NULL);

    tkOSVerInfo.dwOSVersionInfoSize = sizeof(tkOSVerInfo);
    bGetVersionExRet = GetVersionEx(&tkOSVerInfo);
    TKASSERT(bGetVersionExRet);
    if ( tkOSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
         tkOSVerInfo.dwMajorVersion == 3 &&
         (tkOSVerInfo.dwMinorVersion == 5 || tkOSVerInfo.dwMinorVersion == 51) )
        tkNumStaticColors = COLOR_BTNHIGHLIGHT - COLOR_SCROLLBAR + 1;
    else
        tkNumStaticColors = COLOR_INFOBK - COLOR_SCROLLBAR + 1;

    // Must not define CS_PARENTDC style.
    wndclass.style         = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc   = (WNDPROC)tkWndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = hInstance;
    wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = GetStockObject(BLACK_BRUSH);
    wndclass.lpszMenuName  = NULL;

    if (bUnicode)
        wndclass.lpszClassName = (LPCSTR)lpszClassNameW;
    else
        wndclass.lpszClassName = (LPCSTR)lpszClassName;

    if (bUnicode)
    {
        aRegister = RegisterClassW((CONST WNDCLASSW *)&wndclass);
    }
    else
    {
        aRegister = RegisterClass(&wndclass);
    }


    /*
     *  If the window failed to register, then there's no
     *  need to continue further.
     */

    if(0 == aRegister)
    {
        PrintMessage("Failed to register window class\n");
        return(Result);
    }


    /*
     *  Make window large enough to hold a client area as large as windInfo
     */

    WinRect.left   = windInfo.x;
    WinRect.right  = windInfo.x + windInfo.width;
    WinRect.top    = windInfo.y;
    WinRect.bottom = windInfo.y + windInfo.height;

    AdjustWindowRect(&WinRect, WS_OVERLAPPEDWINDOW, FALSE);

    /*
     *  Must use WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles.
     */

    if (bUnicode)
    {
        tkhwnd = CreateWindowW(
                    (LPCWSTR)lpszClassNameW,
                    (LPCWSTR)title,
                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.left,
                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.top,
                    WinRect.right - WinRect.left,
                    WinRect.bottom - WinRect.top,
                    NULL,
                    NULL,
                    hInstance,
                    NULL);
    }
    else
    {
        tkhwnd = CreateWindow(
                    lpszClassName,
                    title,
                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.left,
                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.top,
                    WinRect.right - WinRect.left,
                    WinRect.bottom - WinRect.top,
                    NULL,
                    NULL,
                    hInstance,
                    NULL);
    }

    if ( NULL != tkhwnd )
    {
        // If default window positioning used, find out window position and fix
        // up the windInfo position info.

        if (windInfo.bDefPos)
        {
            GetWindowRect(tkhwnd, &WinRect);
            windInfo.x = WinRect.left + GetSystemMetrics(SM_CXFRAME);
            windInfo.y = WinRect.top  + GetSystemMetrics(SM_CYCAPTION)
                         - GetSystemMetrics(SM_CYBORDER)
                         + GetSystemMetrics(SM_CYFRAME);
        }

        tkhdc = GetDC(tkhwnd);

        if ( NULL != tkhdc )
        {
            ShowWindow(tkhwnd, SW_SHOWDEFAULT);

            if ( FindPixelFormat(tkhdc, windInfo.type) )
            {
                /*
                 *  Create a Rendering Context
                 */

                tkhrc = wglCreateContext(tkhdc);

                if ( NULL != tkhrc )
                {
                    /*
                     *  Make it Current
                     */

                    if ( wglMakeCurrent(tkhdc, tkhrc) )
                    {
                        Result = GL_TRUE;
                    }
                    else
                    {
                        PrintMessage("wglMakeCurrent Failed\n");
                    }
                }
                else
                {
                    PrintMessage("wglCreateContext Failed\n");
                }
            }
        }
        else
        {
            PrintMessage("Could not get an HDC for window 0x%08lX\n", tkhwnd );
        }
    }
    else
    {
        PrintMessage("create window failed\n");
    }

    if ( GL_FALSE == Result )
    {
        DestroyThisWindow(tkhwnd);  // Something Failed, Destroy this window
    }
    return( Result );
}

/******************************************************************************/

/*
 * You cannot just call DestroyWindow() here.  The programs do not expect
 * tkQuit() to return;  DestroyWindow() just sends a WM_DESTROY message
 */

void tkQuit(void)
{
    DestroyThisWindow(tkhwnd);
    ExitProcess(0);
}

/******************************************************************************/

void tkSetOneColor(int index, float r, float g, float b)
{
    PALETTEENTRY PalEntry;
    HPALETTE Palette;

    if ( NULL != (Palette = CreateCIPalette( tkhdc )) )
    {
        if ( tkUseStaticColors && ( index == 0 || index == 255 ) )
            return;

        PalEntry.peRed   = (BYTE)(r*(float)255.0 + (float)0.5);
        PalEntry.peGreen = (BYTE)(g*(float)255.0 + (float)0.5);
        PalEntry.peBlue  = (BYTE)(b*(float)255.0 + (float)0.5);
        PalEntry.peFlags = ( tkUseStaticColors ) ? PC_NOCOLLAPSE : 0;

        // This is a workaround for a GDI palette "feature".  If any of
        // the static colors are repeated in the palette, those colors
        // will map to the first occurance.  So, for our case where there
        // are only two static colors (black and white), if a white
        // color appears anywhere in the palette other than in the last
        // entry, the static white will remap to the first white.  This
        // destroys the nice one-to-one mapping we are trying to achieve.
        //
        // There are two ways to workaround this.  The first is to
        // simply not allow a pure white anywhere but in the last entry.
        // Such requests are replaced with an attenuated white of
        // (0xFE, 0xFE, 0xFE).
        //
        // The other way is to mark these extra whites with PC_RESERVED
        // which will cause GDI to skip these entries when mapping colors.
        // This way the app gets the actual colors requested, but can
        // have side effects on other apps.
        //
        // Both solutions are included below.  The PC_RESERVED solution is
        // the one currently enabled.  It may have side effects, but taking
        // over the static colors as we are is a really big side effect that
        // should swamp out the effects of using PC_RESERVED.

        if ( tkUseStaticColors )
        {
            if ( PalEntry.peRed   == 0xFF &&
                 PalEntry.peGreen == 0xFF &&
                 PalEntry.peBlue  == 0xFF )
            {
            #define USE_PC_RESERVED_WORKAROUND  1
            #if USE_PC_RESERVED_WORKAROUND
                PalEntry.peFlags |= PC_RESERVED;
            #else
                PalEntry.peRed   =
                PalEntry.peGreen =
                PalEntry.peBlue  = 0xFE;
            #endif
            }
        }

        SetPaletteEntries( Palette, index, 1, &PalEntry);

        DelayPaletteRealization();
    }
}

void tkSetFogRamp(int density, int startIndex)
{
    HPALETTE CurrentPal;
    PALETTEENTRY *pPalEntry;
    UINT n, i, j, k, intensity, fogValues, colorValues;

    if ( NULL != (CurrentPal = CreateCIPalette(tkhdc)) )
    {
        n = GetPaletteEntries( CurrentPal, 0, 0, NULL );

        pPalEntry = AllocateMemory( n * sizeof(PALETTEENTRY) );

        if ( NULL != pPalEntry)
        {
            fogValues = 1 << density;
            colorValues = 1 << startIndex;
            for (i = 0; i < colorValues; i++) {
                for (j = 0; j < fogValues; j++) {
                    k = i * fogValues + j;

                    intensity = i * fogValues + j * colorValues;
                    //mf: not sure what they're trying to do here
                    //intensity = (intensity << 8) | intensity; ???

                // This is a workaround for a GDI palette "feature".  If any of
                // the static colors are repeated in the palette, those colors
                // will map to the first occurance.  So, for our case where there
                // are only two static colors (black and white), if a white
                // color appears anywhere in the palette other than in the last
                // entry, the static white will remap to the first white.  This
                // destroys the nice one-to-one mapping we are trying to achieve.
                //
                // There are two ways to workaround this.  The first is to
                // simply not allow a pure white anywhere but in the last entry.
                // Such requests are replaced with an attenuated white of
                // (0xFE, 0xFE, 0xFE).
                //
                // The other way is to mark these extra whites with PC_RESERVED
                // which will cause GDI to skip these entries when mapping colors.
                // This way the app gets the actual colors requested, but can
                // have side effects on other apps.
                //
                // Both solutions are included below.  The PC_RESERVED solution is
                // the one currently enabled.  It may have side effects, but taking
                // over the static colors as we are is a really big side effect that
                // should swamp out the effects of using PC_RESERVED.

                #if USE_PC_RESERVED_WORKAROUND
                    if (intensity > 0xFF)
                        intensity = 0xFF;
                #else
                    if (intensity >= 0xFF)
                        intensity = ( tkUseStaticColors && k != 255) ? 0xFE : 0xFF;
                #endif

                    pPalEntry[k].peRed =
                    pPalEntry[k].peGreen =
                    pPalEntry[k].peBlue = (BYTE) intensity;
                    pPalEntry[k].peFlags = ( tkUseStaticColors && k != 0 && k != 255 )
                                           ? PC_NOCOLLAPSE : 0;

                #if USE_PC_RESERVED_WORKAROUND
                    if (tkUseStaticColors && intensity == 0xFF
                        && k != 0 && k!= 255)
                        pPalEntry[k].peFlags |= PC_RESERVED;
                #endif
                }
            }

            SetPaletteEntries(CurrentPal, 0, n, pPalEntry);
            FreeMemory( pPalEntry );

            DelayPaletteRealization();
        }
    }
}

void tkSetGreyRamp(void)
{
    HPALETTE CurrentPal;
    PALETTEENTRY *Entries;
    UINT Count, i;
    float intensity;

    if ( NULL != (CurrentPal = CreateCIPalette( tkhdc )) )
    {
        Count   = GetPaletteEntries( CurrentPal, 0, 0, NULL );
        Entries = AllocateMemory( Count * sizeof(PALETTEENTRY) );

        if ( NULL != Entries )
        {
            for (i = 0; i < Count; i++)
            {
                intensity = (float)(((double)i / (double)(Count-1)) * (double)255.0 + (double)0.5);
                Entries[i].peRed =
                Entries[i].peGreen =
                Entries[i].peBlue = (BYTE) intensity;
                Entries[i].peFlags = ( tkUseStaticColors && i != 0 && i != 255 )
                                     ? PC_NOCOLLAPSE : 0;
            }
            SetPaletteEntries( CurrentPal, 0, Count, Entries );
            FreeMemory( Entries );

            DelayPaletteRealization();
        }
    }
}

void tkSetRGBMap( int Size, float *Values )
{
    HPALETTE CurrentPal;
    PIXELFORMATDESCRIPTOR Pfd, *pPfd;
    PALETTEENTRY *Entries;
    UINT Count;

    if ( NULL != (CurrentPal = CreateCIPalette( tkhdc )) )
    {
        pPfd = &Pfd;

        if ( PixelFormatDescriptorFromDc( tkhdc, pPfd ) )
        {
            Count    = 1 << pPfd->cColorBits;
            Entries  = AllocateMemory( Count * sizeof(PALETTEENTRY) );

            if ( NULL != Entries )
            {
                FillRgbPaletteEntries( pPfd, Entries, Count );
                SetPaletteEntries( CurrentPal, 0, Count, Entries );
                FreeMemory(Entries);

                RealizePaletteNow( tkhdc, tkhpalette, FALSE );
            }
        }
    }
}

/******************************************************************************/

void tkSwapBuffers(void)
{
    SwapBuffers(tkhdc);
}

/******************************************************************************/

GLint tkGetColorMapSize(void)
{
    CreateCIPalette( tkhdc );

    if ( NULL == tkhpalette )
        return( 0 );

    return( GetPaletteEntries( tkhpalette, 0, 0, NULL ) );
}

void tkGetMouseLoc(int *x, int *y)
{
    POINT Point;

    *x = 0;
    *y = 0;

    GetCursorPos(&Point);

    /*
     *  GetCursorPos returns screen coordinates,
     *  we want window coordinates
     */

    *x = Point.x - windInfo.x;
    *y = Point.y - windInfo.y;
}

HWND tkGetHWND(void)
{
    return tkhwnd;
}

HDC tkGetHDC(void)
{
    return tkhdc;
}

HGLRC tkGetHRC(void)
{
    return tkhrc;
}

GLenum tkGetDisplayModePolicy(void)
{
    return windInfo.dmPolicy;
}

GLint tkGetDisplayModeID(void)
{
    return windInfo.ipfd;
}

GLenum tkGetDisplayMode(void)
{
    return windInfo.type;
}


/***********************************************************************
 *                                                                     *
 *  The Following functions are for our own use only. (ie static)      *
 *                                                                     *
 ***********************************************************************/

static LRESULT
tkWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int key;
    PAINTSTRUCT paint;
    HDC hdc;
    PIXELFORMATDESCRIPTOR pfd;

    switch (message) {

    case WM_USER:
        if ( RealizePaletteNow( tkhdc, tkhpalette, FALSE ) > 0 )
        {
            ForceRedraw( hWnd );
        }
        return(0);

    case WM_SIZE:
        windInfo.width  = LOWORD(lParam);
        windInfo.height = HIWORD(lParam);

        if (ReshapeFunc)
        {
            (*ReshapeFunc)(windInfo.width, windInfo.height);

            ForceRedraw( hWnd );
        }
        return (0);

    case WM_MOVE:
        windInfo.x = LOWORD(lParam);
        windInfo.y = HIWORD(lParam);
        return (0);

    case WM_PAINT:
        /*
         *  Validate the region even if there are no DisplayFunc.
         *  Otherwise, USER will not stop sending WM_PAINT messages.
         */

        hdc = BeginPaint(tkhwnd, &paint);

        if (DisplayFunc)
        {
            (*DisplayFunc)();
        }

        EndPaint(tkhwnd, &paint);
        return (0);

    case WM_QUERYNEWPALETTE:

    // We don't actually realize the palette here (we do it at WM_ACTIVATE
    // time), but we need the system to think that we have so that a
    // WM_PALETTECHANGED message is generated.

        return (1);

    case WM_PALETTECHANGED:

    // Respond to this message only if the window that changed the palette
    // is not this app's window.

    // We are not the foreground window, so realize palette in the
    // background.  We cannot call RealizePaletteNow to do this because
    // we should not do any of the tkUseStaticColors processing while
    // in background.

        if ( hWnd != (HWND) wParam )
        {
            if ( !tkSystemColorsInUse &&
                 NULL != tkhpalette &&
                 NULL != SelectPalette( tkhdc, tkhpalette, TRUE ) )
                RealizePalette( tkhdc );
        }

        return (0);

    case WM_SYSCOLORCHANGE:

    // If the system colors have changed and we have a palette
    // for an RGB surface then we need to recompute the static
    // color mapping because they might have been changed in
    // the process of changing the system colors.

        if (tkhdc != NULL && tkhpalette != NULL &&
            PixelFormatDescriptorFromDc(tkhdc, &pfd) &&
            (pfd.dwFlags & PFD_NEED_PALETTE) &&
            pfd.iPixelType == PFD_TYPE_RGBA)
        {
            HPALETTE hpalTmp;

            hpalTmp = tkhpalette;
            tkhpalette = NULL;
            if (CreateRGBPalette(tkhdc) != NULL)
            {
                DeleteObject(hpalTmp);
                ForceRedraw(hWnd);
            }
            else
            {
                tkhpalette = hpalTmp;
            }
        }
        break;
            
    case WM_ACTIVATE:

    // If the window is going inactive, the palette must be realized to
    // the background.  Cannot depend on WM_PALETTECHANGED to be sent since
    // the window that comes to the foreground may or may not be palette
    // managed.

        if ( LOWORD(wParam) == WA_INACTIVE )
        {
            if ( NULL != tkhpalette )
            {
            // Realize as a background palette.  Need to call
            // RealizePaletteNow rather than RealizePalette directly to
            // because it may be necessary to release usage of the static
            // system colors.

                if ( RealizePaletteNow( tkhdc, tkhpalette, TRUE ) > 0 )
                    ForceRedraw( hWnd );
            }
        }

    // Window is going active.  If we are not iconized, realize palette
    // to the foreground.  If management of the system static colors is
    // needed, RealizePaletteNow will take care of it.

        else if ( HIWORD(wParam) == 0 )
        {
            if ( NULL != tkhpalette )
            {
                if ( RealizePaletteNow( tkhdc, tkhpalette, FALSE ) > 0 )
                    ForceRedraw( hWnd );

                return (1);
            }
        }

    // Allow DefWindowProc() to finish the default processing (which includes
    // changing the keyboard focus).

        break;

    case WM_MOUSEMOVE:

        if (MouseMoveFunc)
        {
            GLenum mask;

            mask = 0;
            if (wParam & MK_LBUTTON) {
                mask |= TK_LEFTBUTTON;
            }
            if (wParam & MK_MBUTTON) {
                mask |= TK_MIDDLEBUTTON;
            }
            if (wParam & MK_RBUTTON) {
                mask |= TK_RIGHTBUTTON;
            }

            if ((*MouseMoveFunc)( LOWORD(lParam), HIWORD(lParam), mask ))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_LBUTTONDOWN:

        SetCapture(hWnd);

        if (MouseDownFunc)
        {
            if ( (*MouseDownFunc)(LOWORD(lParam), HIWORD(lParam),
                 TK_LEFTBUTTON) )
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_LBUTTONUP:

        ReleaseCapture();

        if (MouseUpFunc)
        {
            if ((*MouseUpFunc)(LOWORD(lParam), HIWORD(lParam), TK_LEFTBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_MBUTTONDOWN:

        SetCapture(hWnd);

        if (MouseDownFunc)
        {
            if ((*MouseDownFunc)(LOWORD(lParam), HIWORD(lParam),
                    TK_MIDDLEBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_MBUTTONUP:

        ReleaseCapture();

        if (MouseUpFunc)
        {
            if ((*MouseUpFunc)(LOWORD(lParam), HIWORD(lParam),
                TK_MIDDLEBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_RBUTTONDOWN:

        SetCapture(hWnd);

        if (MouseDownFunc)
        {
            if ((*MouseDownFunc)(LOWORD(lParam), HIWORD(lParam),
                TK_RIGHTBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_RBUTTONUP:

        ReleaseCapture();

        if (MouseUpFunc)
        {
            if ((*MouseUpFunc)(LOWORD(lParam), HIWORD(lParam),
                TK_RIGHTBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_SPACE:          key = TK_SPACE;         break;
        case VK_RETURN:         key = TK_RETURN;        break;
        case VK_ESCAPE:         key = TK_ESCAPE;        break;
        case VK_LEFT:           key = TK_LEFT;          break;
        case VK_UP:             key = TK_UP;            break;
        case VK_RIGHT:          key = TK_RIGHT;         break;
        case VK_DOWN:           key = TK_DOWN;          break;
        default:                key = GL_FALSE;         break;
        }

        if (key && KeyDownFunc)
        {
            GLenum mask;

            mask = 0;
            if (GetKeyState(VK_CONTROL)) {
                mask |= TK_CONTROL;
            }

            if (GetKeyState(VK_SHIFT)) {

                mask |= TK_SHIFT;
            }

            if ( (*KeyDownFunc)(key, mask) )
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_CHAR:
        if (('0' <= wParam && wParam <= '9') ||
            ('a' <= wParam && wParam <= 'z') ||
            ('A' <= wParam && wParam <= 'Z')) {

            key = (int)wParam;
        } else {
            key = GL_FALSE;
        }

        if (key && KeyDownFunc) {
            GLenum mask;

            mask = 0;

            if (GetKeyState(VK_CONTROL)) {
                mask |= TK_CONTROL;
            }

            if (GetKeyState(VK_SHIFT)) {
                mask |= TK_SHIFT;
            }

            if ( (*KeyDownFunc)(key, mask) )
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_CLOSE:
        DestroyWindow(tkhwnd);
        return(0);

    case WM_DESTROY:
        CleanUp();
        PostQuitMessage(TRUE);
        return 0;
    }
    return(DefWindowProc( hWnd, message, wParam, lParam));
}

#if RESTORE_FROM_REGISTRY
/******************************Public*Routine******************************\
* GetRegistrySysColors
*
* Reads the Control Panel's color settings from the registry and stores
* those values in pcr.  If we fail to get any value, then the corresponding
* entry in pcr is not modified.
*
* History:
*  12-Apr-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL GetRegistrySysColors(COLORREF *pcr, int nColors)
{
    BOOL bRet = FALSE;
    long lRet;
    HKEY hkSysColors = (HKEY) NULL;
    int i;
    DWORD dwDataType;
    char achColor[64];
    DWORD cjColor;

    TKASSERT(nColors <= tkNumStaticColors);

// Open the key for the system color settings.

    lRet = RegOpenKeyExA(HKEY_CURRENT_USER,
                         "Control Panel\\Colors",
                         0,
                         KEY_QUERY_VALUE,
                         &hkSysColors);

    if ( lRet != ERROR_SUCCESS )
    {
        goto GetRegistrySysColors_exit;
    }

// Read each system color value.  The names are stored in the global
// array of char *, gaszSysClrNames.

    for (i = 0; i < nColors; i++)
    {
        cjColor = sizeof(achColor);
        lRet = RegQueryValueExA(hkSysColors,
                                (LPSTR) gaszSysClrNames[i],
                                (LPDWORD) NULL,
                                &dwDataType,
                                (LPBYTE) achColor,
                                &cjColor);

        TKASSERT(lRet != ERROR_MORE_DATA);

        if ( lRet == ERROR_SUCCESS && dwDataType == REG_SZ )
        {
            DWORD r, g, b;

            sscanf(achColor, "%ld %ld %ld", &r, &g, &b);
            pcr[i] = RGB(r, g, b);
        }
    }

    bRet = TRUE;

GetRegistrySysColors_exit:
    if (hkSysColors)
        RegCloseKey(hkSysColors);

    return bRet;
}
#endif

/******************************Public*Routine******************************\
* GrabStaticEntries
*
* Support routine for RealizePaletteNow to manage the static system color
* usage.
*
* This function will save the current static system color usage state.
* It will fail if:
*
*   1.  TK is not in "sys color in use state but system palette is in
*       SYSPAL_NOSTATIC mode.  This means that another app still possesses
*       the static system colors.  This this happens, GrabStaticEntries
*       will post a message to cause TK to try again (by calling
*       DelayPaletteRealization).
*
* Side effect:
*   If system colors are changed, then WM_SYSCOLORCHANGE message is
*   broadcast to all top level windows.
*
*   DelayPaletteRealization may be called in case 2 above, resulting in
*   a WM_USER message being posted to our message queue.
*
* Returns:
*   TRUE if successful, FALSE otherwise (see above).
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL GrabStaticEntries(HDC hdc)
{
    int i;
    BOOL bRet = FALSE;

// Do nothing if sys colors already in use.

    if ( !tkSystemColorsInUse )
    {
    // Take possession only if no other app has the static colors.
    // How can we tell?  If the return from SetSystemPaletteUse is
    // SYSPAL_STATIC, then no other app has the statics.  If it is
    // SYSPAL_NOSTATIC, someone else has them and we must fail.
    //
    // SetSystemPaletteUse is properly synchronized internally
    // so that it is atomic.
    //
    // Because we are relying on SetSystemPaletteUse to synchronize TK,
    // it is important to observe the following order for grabbing and
    // releasing:
    //
    //      Grab        call SetSystemPaletteUse and check for SYSPAL_STATIC
    //                  save sys color settings
    //                  set new sys color settings
    //
    //      Release     restore sys color settings
    //                  call SetSystemPaletteUse

        if ( SetSystemPaletteUse( hdc, SYSPAL_NOSTATIC ) == SYSPAL_STATIC )
        {
        // Save current sys color settings.

            for (i = COLOR_SCROLLBAR; i <= COLOR_BTNHIGHLIGHT; i++)
                gacrSave[i - COLOR_SCROLLBAR] = GetSysColor(i);

        // Set b&w sys color settings.  Put TK in "sys colors in use" state.

            SetSysColors(tkNumStaticColors, gaiStaticIndex, gacrBlackAndWhite);
            tkSystemColorsInUse = TRUE;

        // Inform all other top-level windows of the system color change.

            PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);

            bRet = TRUE;
        }

    // Sleep a little and then post message to try palette realization again
    // later.

        else
        {
            Sleep(0L);
            DelayPaletteRealization();
        }
    }
    else
        bRet = TRUE;

    return bRet;
}

/******************************Public*Routine******************************\
* ReleaseStaticEntries
*
* Support routine for RealizePaletteNow to manage the static system color
* usage.
*
* This function will reset the current static system color usage state.
* It will fail if:
*
*   1.  TK is not in a "sys colors in use" state.  If we are in this case,
*       then the static system colors do not need to be released.
*
* Side effect:
*   If system colors are changed, then WM_SYSCOLORCHANGE message is
*   broadcast to all top level windows.
*
* Returns:
*   TRUE if successful, FALSE otherwise (see above).
*
* History:
*  21-Jul-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL ReleaseStaticEntries(HDC hdc)
{
    BOOL bRet = FALSE;

// Do nothing if sys colors not in use.

    if ( tkSystemColorsInUse )
    {
#if RESTORE_FROM_REGISTRY
    // Replace saved system colors with registry values.  We do it now
    // rather than earlier because someone may have changed registry while
    // TK app was running in the foreground (very unlikely, but it could
    // happen).
    //
    // Also, we still try to save current setting in GrabStaticEntries so
    // that if for some reason we fail to grab one or more of the colors
    // from the registry, we can still fall back on what we grabbed via
    // GetSysColors (even though there is a chance its the wrong color).

        GetRegistrySysColors(gacrSave, tkNumStaticColors);
#endif

    // Restore the saved system color settings.

        SetSysColors(tkNumStaticColors, gaiStaticIndex, gacrSave);

    // Return the system palette to SYSPAL_STATIC.

        SetSystemPaletteUse( hdc, SYSPAL_STATIC );

    // Inform all other top-level windows of the system color change.

        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);

    // Reset the "sys colors in use" state and return success.

        tkSystemColorsInUse = FALSE;
        bRet = TRUE;
    }

    return bRet;
}

// Default palette entry flags
#define PALETTE_FLAGS PC_NOCOLLAPSE

// Gamma correction factor * 10
#define GAMMA_CORRECTION 14

// Maximum color distance with 8-bit components
#define MAX_COL_DIST (3*256*256L)

// Number of static colors
#define STATIC_COLORS 20

// Flags used when matching colors
#define EXACT_MATCH 1
#define COLOR_USED 1

// Conversion tables for n bits to eight bits

#if GAMMA_CORRECTION == 10
// These tables are corrected for a gamma of 1.0
static unsigned char abThreeToEight[8] =
{
    0, 0111 >> 1, 0222 >> 1, 0333 >> 1, 0444 >> 1, 0555 >> 1, 0666 >> 1, 0377
};
static unsigned char abTwoToEight[4] =
{
    0, 0x55, 0xaa, 0xff
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#else
// These tables are corrected for a gamma of 1.4
static unsigned char abThreeToEight[8] =
{
    0, 63, 104, 139, 171, 200, 229, 255
};
static unsigned char abTwoToEight[4] =
{
    0, 116, 191, 255
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#endif

// Table which indicates which colors in a 3-3-2 palette should be
// replaced with the system default colors
#if GAMMA_CORRECTION == 10
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 4, 32, 36, 128, 132, 160, 173, 181, 245,
    247, 164, 156, 7, 56, 63, 192, 199, 248, 255
};
#else
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 3, 24, 27, 64, 67, 88, 173, 181, 236,
    247, 164, 91, 7, 56, 63, 192, 199, 248, 255
};
#endif

static unsigned char
ComponentFromIndex(int i, int nbits, int shift)
{
    unsigned char val;

    TKASSERT(nbits >= 1 && nbits <= 3);
    
    val = i >> shift;
    switch (nbits)
    {
    case 1:
        return abOneToEight[val & 1];

    case 2:
        return abTwoToEight[val & 3];

    case 3:
        return abThreeToEight[val & 7];
    }
    return 0;
}

// System default colors
static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },

    { 192, 220, 192,  0 },
    { 166, 202, 240,  0 },
    { 255, 251, 240,  0 },
    { 160, 160, 164,  0 },

    { 0x80,0x80,0x80, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/******************************Public*Routine******************************\
*
* UpdateStaticMapping
*
* Computes the best match between the current system static colors
* and a 3-3-2 palette
*
* History:
*  Tue Aug 01 18:18:12 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static void
UpdateStaticMapping(PALETTEENTRY *pe332Palette)
{
    HPALETTE hpalStock;
    int iStatic, i332;
    int iMinDist, iDist;
    int iDelta;
    int iMinEntry;
    PALETTEENTRY *peStatic, *pe332;

    hpalStock = GetStockObject(DEFAULT_PALETTE);

    // The system should always have one of these
    TKASSERT(hpalStock != NULL);
    // Make sure there's the correct number of entries
    TKASSERT(GetPaletteEntries(hpalStock, 0, 0, NULL) == STATIC_COLORS);

    // Get the current static colors
    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry);

    // Zero the flags in the static colors because they are used later
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Zero the flags in the incoming palette because they are used later
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = 0;
        pe332++;
    }

    // Try to match each static color exactly
    // This saves time by avoiding the least-squares match for each
    // exact match
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            if (peStatic->peRed == pe332->peRed &&
                peStatic->peGreen == pe332->peGreen &&
                peStatic->peBlue == pe332->peBlue)
            {
                TKASSERT(pe332->peFlags != COLOR_USED);
                
                peStatic->peFlags = EXACT_MATCH;
                pe332->peFlags = COLOR_USED;
                aiDefaultOverride[iStatic] = i332;
                
                break;
            }

            pe332++;
        }

        peStatic++;
    }
    
    // Match each static color as closely as possible to an entry
    // in the 332 palette by minimized the square of the distance
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        // Skip colors already matched exactly
        if (peStatic->peFlags == EXACT_MATCH)
        {
            peStatic++;
            continue;
        }
        
        iMinDist = MAX_COL_DIST+1;
#if DBG
        iMinEntry = -1;
#endif

        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            // Skip colors already used
            if (pe332->peFlags == COLOR_USED)
            {
                pe332++;
                continue;
            }
            
            // Compute Euclidean distance squared
            iDelta = pe332->peRed-peStatic->peRed;
            iDist = iDelta*iDelta;
            iDelta = pe332->peGreen-peStatic->peGreen;
            iDist += iDelta*iDelta;
            iDelta = pe332->peBlue-peStatic->peBlue;
            iDist += iDelta*iDelta;

            if (iDist < iMinDist)
            {
                iMinDist = iDist;
                iMinEntry = i332;
            }

            pe332++;
        }

        TKASSERT(iMinEntry != -1);

        // Remember the best match
        aiDefaultOverride[iStatic] = iMinEntry;
        pe332Palette[iMinEntry].peFlags = COLOR_USED;
        
        peStatic++;
    }

    // Zero the flags in the static colors because they may have been
    // set.  We want them to be zero so the colors can be remapped
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Reset the 332 flags because we may have set them
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = PALETTE_FLAGS;
        pe332++;
    }

#if 0
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        PrintMessage("Static color %2d maps to %d\n",
                     iStatic, aiDefaultOverride[iStatic]);
    }
#endif
}

/******************************Public*Routine******************************\
* FillRgbPaletteEntries
*
* Fills a PALETTEENTRY array with values required for a logical rgb palette.
* If tkSetStaticColorUsage has been called with TRUE, the static system
* colors will be overridden.  Otherwise, the PALETTEENTRY array will be
* fixed up to contain the default static system colors.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY *
FillRgbPaletteEntries(  PIXELFORMATDESCRIPTOR *Pfd,
                        PALETTEENTRY *Entries,
                        UINT Count
                     )
{
    PALETTEENTRY *Entry;
    UINT i;

    if ( NULL != Entries )
    {
        for ( i = 0, Entry = Entries ; i < Count ; i++, Entry++ )
        {
            Entry->peRed   = ComponentFromIndex(i, Pfd->cRedBits,
                                    Pfd->cRedShift);
            Entry->peGreen = ComponentFromIndex(i, Pfd->cGreenBits,
                                    Pfd->cGreenShift);
            Entry->peBlue  = ComponentFromIndex(i, Pfd->cBlueBits,
                                    Pfd->cBlueShift);
            Entry->peFlags = PALETTE_FLAGS;
        }

        if ( 256 == Count)
        {
        // If app set static system color usage for fixed palette support,
        // setup to take over the static colors.  Otherwise, fixup the
        // static system colors.

            if ( tkUseStaticColors )
            {
            // Black and white already exist as the only remaining static
            // colors.  Let those remap.  All others should be put into
            // the palette (i.e., set PC_NOCOLLAPSE).

                Entries[0].peFlags = 0;
                Entries[255].peFlags = 0;
            }
            else
            {
            // The defaultOverride array is computed assuming a 332
            // palette where red has zero shift, etc.

                if ( (3 == Pfd->cRedBits)   && (0 == Pfd->cRedShift)   &&
                     (3 == Pfd->cGreenBits) && (3 == Pfd->cGreenShift) &&
                     (2 == Pfd->cBlueBits)  && (6 == Pfd->cBlueShift) )
                {
                    UpdateStaticMapping(Entries);
                    
                    for ( i = 0 ; i < STATIC_COLORS ; i++)
                    {
                        Entries[aiDefaultOverride[i]] = apeDefaultPalEntry[i];
                    }
                }
            }
        }
    }
    return( Entries );
}

/******************************Public*Routine******************************\
* FlushPalette
*
* Because of Win 3.1 compatibility, GDI palette mapping always starts
* at zero and stops at the first exact match.  So if there are duplicates,
* the higher colors aren't mapped to--which is often a problem if we
* are trying to make to any of the upper 10 static colors.  To work around
* this, we flush the palette to all black.
*
* This only needs to be done for the 8BPP (256 color) case.
*
\**************************************************************************/

static void
FlushPalette(HDC hdc, int nColors)
{
    LOGPALETTE *pPal;
    HPALETTE hpal, hpalOld;
    int i;

    if (nColors == 256)
    {
        pPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
                                         sizeof(LOGPALETTE) + nColors * sizeof(PALETTEENTRY));

        if (pPal)
        {
	    pPal->palVersion = 0x300;
	    pPal->palNumEntries = (WORD)nColors;

        // Mark everything PC_NOCOLLAPSE and PC_RESERVED to force every thing
        // into the palette.  Colors are already black because we zero initialized
        // during memory allocation.

            for (i = 0; i < nColors; i++)
            {
                pPal->palPalEntry[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
            }

            hpal = CreatePalette(pPal);
            LocalFree(pPal);

            hpalOld = SelectPalette(hdc, hpal, FALSE);
            RealizePalette(hdc);

            SelectPalette(hdc, hpalOld, FALSE);
            DeleteObject(hpal);
        }
    }
}

static HPALETTE
CreateRGBPalette( HDC Dc )
{
    PIXELFORMATDESCRIPTOR Pfd, *pPfd;
    LOGPALETTE *LogPalette;
    UINT Count;

    if ( NULL == tkhpalette )
    {
        pPfd = &Pfd;

        if ( PixelFormatDescriptorFromDc( Dc, pPfd ) )
        {
            /*
             *  Make sure we need a palette
             */

            if ( (pPfd->iPixelType == PFD_TYPE_RGBA) &&
                 (pPfd->dwFlags & PFD_NEED_PALETTE) )
            {
                /*
                 *  Note how palette is to be realized.  Take over the
                 *  system colors if either the pixel format requires it
                 *  or the app wants it.
                 */
                tkUseStaticColors = ( pPfd->dwFlags & PFD_NEED_SYSTEM_PALETTE )
                                    || TK_USE_FIXED_332_PAL(windInfo.type);

                Count       = 1 << pPfd->cColorBits;
                LogPalette  = AllocateMemory( sizeof(LOGPALETTE) +
                                Count * sizeof(PALETTEENTRY));

                if ( NULL != LogPalette )
                {
                    LogPalette->palVersion    = 0x300;
                    LogPalette->palNumEntries = (WORD)Count;

                    FillRgbPaletteEntries( pPfd,
                                           &LogPalette->palPalEntry[0],
                                           Count );

                    tkhpalette = CreatePalette(LogPalette);
                    FreeMemory(LogPalette);

                    FlushPalette(Dc, Count);
                    
                    RealizePaletteNow( Dc, tkhpalette, FALSE );
                }
            }
        }
    }
    return( tkhpalette );
}

static HPALETTE
CreateCIPalette( HDC Dc )
{
    PIXELFORMATDESCRIPTOR Pfd;
    LOGPALETTE *LogicalPalette;
    HPALETTE StockPalette;
    UINT PaletteSize, StockPaletteSize, EntriesToCopy;

    if ( (Dc != NULL) && (NULL == tkhpalette) )
    {
        if ( PixelFormatDescriptorFromDc( Dc, &Pfd ) )
        {
            if ( Pfd.iPixelType == PFD_TYPE_COLORINDEX )
            {
                /*
                 *  Note how palette is to be realized (Is this the correct place to do this?)
                 */
                tkUseStaticColors = ( Pfd.dwFlags & PFD_NEED_SYSTEM_PALETTE )
                                    || TK_USE_FIXED_332_PAL(windInfo.type);

                /*
                 *  Limit the size of the palette to 256 colors.
                 *  Why? Because this is what was decided.
                 */

                PaletteSize = (Pfd.cColorBits >= 8) ? 256 : (1 << Pfd.cColorBits);

                LogicalPalette = AllocateZeroedMemory( sizeof(LOGPALETTE) +
                                        (PaletteSize * sizeof(PALETTEENTRY)) );

                if ( NULL != LogicalPalette )
                {
                    LogicalPalette->palVersion    = 0x300;
                    LogicalPalette->palNumEntries = (WORD)PaletteSize;

                    StockPalette     = GetStockObject(DEFAULT_PALETTE);
                    StockPaletteSize = GetPaletteEntries( StockPalette, 0, 0, NULL );

                    /*
                     *  start by copying default palette into new one
                     */

                    EntriesToCopy = StockPaletteSize < PaletteSize ?
                                        StockPaletteSize : PaletteSize;

                    GetPaletteEntries( StockPalette, 0, EntriesToCopy,
                                        LogicalPalette->palPalEntry );

                    /*
                     *  If we are taking possession of the system colors,
                     *  must guarantee that 0 and 255 are black and white
                     *  (respectively).
                     */

                    if ( tkUseStaticColors && PaletteSize == 256 )
                    {
                        int i;

                        LogicalPalette->palPalEntry[0].peRed =
                        LogicalPalette->palPalEntry[0].peGreen =
                        LogicalPalette->palPalEntry[0].peBlue = 0x00;

                        LogicalPalette->palPalEntry[255].peRed =
                        LogicalPalette->palPalEntry[255].peGreen =
                        LogicalPalette->palPalEntry[255].peBlue = 0xFF;

                        LogicalPalette->palPalEntry[0].peFlags =
                        LogicalPalette->palPalEntry[255].peFlags = 0;

                        /*
                         *  All other entries should be remappable,
                         *  so mark them as PC_NOCOLLAPSE.
                         */
                        for ( i = 1; i < 255; i++ )
                            LogicalPalette->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
                    }

                    tkhpalette = CreatePalette(LogicalPalette);

                    FreeMemory(LogicalPalette);

                    RealizePaletteNow( Dc, tkhpalette, FALSE );
                }
            }
        }
    }
    return( tkhpalette );
}

static BOOL
FindPixelFormat(HDC hdc, GLenum type)
{
    PIXELFORMATDESCRIPTOR pfd;
    int PfdIndex;
    BOOL Result = FALSE;

    if ( TK_MINIMUM_CRITERIA == windInfo.dmPolicy )
        PfdIndex = FindBestPixelFormat(hdc, type, &pfd);
    else if ( TK_EXACT_MATCH == windInfo.dmPolicy )
        PfdIndex = FindExactPixelFormat(hdc, type, &pfd);
    else if ( IsPixelFormatValid(hdc, windInfo.ipfd, &pfd) )
        PfdIndex = windInfo.ipfd;
    else
        PfdIndex = 0;

    if ( PfdIndex )
    {
        if ( SetPixelFormat(hdc, PfdIndex, &pfd) )
        {
            /*
             *  If this pixel format requires a palette do it now.
             *  In colorindex mode, create a logical palette only
             *  if the application needs to modify it.
             */

            CreateRGBPalette( hdc );
            Result = TRUE;
        }
        else
        {
            PrintMessage("SetPixelFormat failed\n");
        }
    }
    else
    {
        PrintMessage("Selecting a pixel format failed\n");
    }
    return(Result);
}

static int
FindBestPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd)
{
    PIXELFORMATDESCRIPTOR pfd;

    pfd.nSize       = sizeof(pfd);
    pfd.nVersion    = 1;
    pfd.dwFlags     = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;

    if (TK_IS_DOUBLE(type))
        pfd.dwFlags |= PFD_DOUBLEBUFFER;

    if (TK_IS_INDEX(type)) {
        pfd.iPixelType = PFD_TYPE_COLORINDEX;
        pfd.cColorBits = 8;
    } else {
        pfd.iPixelType = PFD_TYPE_RGBA;
        pfd.cColorBits = 24;
    }

    if (TK_HAS_ALPHA(type))
        pfd.cAlphaBits = 8;
    else
        pfd.cAlphaBits = 0;

    if (TK_HAS_ACCUM(type))
        pfd.cAccumBits = pfd.cColorBits + pfd.cAlphaBits;
    else
        pfd.cAccumBits = 0;

    if (TK_HAS_DEPTH(type)) {
        if (TK_IS_DEPTH16(type))
            pfd.cDepthBits = 16;
        else
            pfd.cDepthBits = 24;
    } else {
        pfd.cDepthBits = 0;
    }

    if (TK_HAS_STENCIL(type))
        pfd.cStencilBits = 4;
    else
        pfd.cStencilBits = 0;

    pfd.cAuxBuffers = 0;
    pfd.iLayerType  = PFD_MAIN_PLANE;
    *ppfd = pfd;

    return ( ChoosePixelFormat(hdc, &pfd) );
}

static int
FindExactPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd)
{
    int i, MaxPFDs, Score, BestScore, BestPFD;
    PIXELFORMATDESCRIPTOR pfd;

    i = 1;
    BestPFD = BestScore = 0;
    do
    {
        MaxPFDs = DescribePixelFormat(hdc, i, sizeof(pfd), &pfd);
        if ( MaxPFDs <= 0 )
            return ( 0 );

        Score = 0;
        if ( !( ( pfd.dwFlags & PFD_DRAW_TO_WINDOW ) &&
                ( pfd.dwFlags & PFD_SUPPORT_OPENGL ) ) )
            continue;
        if ( pfd.iLayerType != PFD_MAIN_PLANE )
            continue;
        if ( ( pfd.iPixelType == PFD_TYPE_RGBA ) && ( TK_IS_INDEX(type) ) )
            continue;
        if ( ( pfd.iPixelType == PFD_TYPE_COLORINDEX ) && ( TK_IS_RGB(type) ) )
            continue;
        if ( ( pfd.dwFlags & PFD_DOUBLEBUFFER ) && ( TK_IS_SINGLE(type) ) )
            continue;
        if ( !( pfd.dwFlags & PFD_DOUBLEBUFFER ) && ( TK_IS_DOUBLE(type) ) )
            continue;

/* If accum requested then accum rgb size must be > 0 */
/* If alpha requested then alpha size must be > 0 */
/* if accum & alpha requested then accum alpha size must be > 0 */
        if ( TK_IS_RGB(type) )
        {
            if ( TK_HAS_ACCUM(type) )
            {
                if (  pfd.cAccumBits <= 0 )
                    continue;
            }
            else
            {
                if ( pfd.cAccumBits > 0 )
                    continue;
            }

            if ( TK_HAS_ALPHA(type) )
            {
                if ( pfd.cAlphaBits <= 0 )
                    continue;
                if ( TK_HAS_ACCUM(type) && pfd.cAccumAlphaBits <= 0 )
                    continue;
            }
            else
            {
                if ( pfd.cAlphaBits > 0 )
                    continue;
            }
        }

        if ( TK_HAS_DEPTH(type) )
        {
            if ( pfd.cDepthBits <= 0 )
                continue;
        }
        else
        {
            if ( pfd.cDepthBits > 0 )
                continue;
        }

        if ( TK_HAS_STENCIL(type) )
        {
            if ( pfd.cStencilBits <= 0 )
                continue;
        }
        else
        {
            if ( pfd.cStencilBits > 0 )
                continue;
        }

        Score = pfd.cColorBits;

        if (Score > BestScore)
        {
            BestScore = Score;
            BestPFD = i;
            *ppfd = pfd;
        }
    } while (++i <= MaxPFDs);

    return ( BestPFD );
}

static BOOL IsPixelFormatValid(HDC hdc, int ipfd, PIXELFORMATDESCRIPTOR *ppfd)
{
    if ( ipfd > 0 )
    {
        if ( ipfd <= DescribePixelFormat(hdc, ipfd, sizeof(*ppfd), ppfd) )
        {
            if ( ( ppfd->dwFlags & PFD_DRAW_TO_WINDOW ) &&
                 ( ppfd->dwFlags & PFD_SUPPORT_OPENGL ) )
            {
                return ( TRUE );
            }
        }
    }
    return ( FALSE );
}


static void
PrintMessage( const char *Format, ... )
{
    va_list ArgList;
    char Buffer[256];

    va_start(ArgList, Format);
    vsprintf(Buffer, Format, ArgList);
    va_end(ArgList);

    MESSAGEBOX(GetFocus(), Buffer, "Error", MB_OK);
}

static void
DelayPaletteRealization( void )
{
    MSG Message;

    TKASSERT(NULL!=tkhwnd);

    /*
     *  Add a WM_USER message to the queue, if there isn't one there already.
     */

    if (!PeekMessage(&Message, tkhwnd, WM_USER, WM_USER, PM_NOREMOVE) )
    {
        PostMessage( tkhwnd, WM_USER, 0, 0);
    }
}

/******************************Public*Routine******************************\
* RealizePaletteNow
*
* Select the given palette in background or foreground mode (as specified
* by the bForceBackground flag), and realize the palette.
*
* If static system color usage is set, the system colors are replaced.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

long
RealizePaletteNow( HDC Dc, HPALETTE Palette, BOOL bForceBackground )
{
    long Result = -1;
    BOOL bHaveSysPal = TRUE;

    TKASSERT( NULL!=Dc      );
    TKASSERT( NULL!=Palette );

// If static system color usage is set, prepare to take over the
// system palette.

    if ( tkUseStaticColors )
    {
    // If foreground, take over the static colors.  If background, release
    // the static colors.

        if ( !bForceBackground )
        {
        // If GrabStaticEntries succeeds, then it is OK to take over the
        // static colors.  If not, then GrabStaticEntries will have
        // posted a WM_USER message for us to try again later.

            bHaveSysPal = GrabStaticEntries( Dc );
        }
        else
        {
        // If we are currently using the system colors (tkSystemColorsInUse)
        // and RealizePaletteNow was called with bForceBackground set, we
        // are being deactivated and must release the static system colors.

            ReleaseStaticEntries( Dc );
        }

    // Rerealize the palette.
    //
    // If set to TRUE, bForceBackground will force the palette to be realized
    // as a background palette, regardless of focus.  This will happen anyway
    // if the TK window does not have the keyboard focus.

        if ( (bForceBackground || bHaveSysPal) &&
             UnrealizeObject( Palette ) &&
             NULL != SelectPalette( Dc, Palette, bForceBackground ) )
        {
            Result = RealizePalette( Dc );
        }
    }
    else
    {
        if ( NULL != SelectPalette( Dc, Palette, FALSE ) )
        {
            Result = RealizePalette( Dc );
        }
    }

    return( Result );
}

static void
ForceRedraw( HWND Window )
{
    MSG Message;

    if (!PeekMessage(&Message, Window, WM_PAINT, WM_PAINT, PM_NOREMOVE) )
    {
        InvalidateRect( Window, NULL, FALSE );
    }
}

static int
PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd )
{
    int PfdIndex;

    if ( 0 < (PfdIndex = GetPixelFormat( Dc )) )
    {
        if ( 0 < DescribePixelFormat( Dc, PfdIndex, sizeof(*Pfd), Pfd ) )
        {
            return(PfdIndex);
        }
        else
        {
            PrintMessage("Could not get a description of pixel format %d\n",
                PfdIndex );
        }
    }
    else
    {
        PrintMessage("Could not get pixel format for Dc 0x%08lX\n", Dc );
    }
    return( 0 );
}

static void
DestroyThisWindow( HWND Window )
{
    if ( NULL != Window )
    {
        DestroyWindow( Window );
    }
}

/*
 *  This Should be called in response to a WM_DESTROY message
 */

static void
CleanUp( void )
{
    HPALETTE hStock;

// Cleanup the palette.

    if ( NULL != tkhpalette )
    {
    // If static system color usage is set, restore the system colors.

        if ( tkUseStaticColors )
        {
            RealizePaletteNow( tkhdc, GetStockObject(DEFAULT_PALETTE), TRUE );
        }
        else
        {
            if ( hStock = GetStockObject( DEFAULT_PALETTE ) )
                SelectPalette( tkhdc, hStock, FALSE );
        }

        DeleteObject( tkhpalette );
    }

// Cleanup the RC.

    if ( NULL != tkhrc )
    {
        wglMakeCurrent( tkhdc, NULL );  // Release first...
        wglDeleteContext( tkhrc );      // then delete.
    }

// Cleanup the DC.

    if ( NULL != tkhdc )
    {
        ReleaseDC( tkhwnd, tkhdc );
    }

// Be really nice and reset global values.

    tkhwnd        = NULL;
    tkhdc         = NULL;
    tkhrc         = NULL;
    tkhpalette    = NULL;

    ExposeFunc    = NULL;
    ReshapeFunc   = NULL;
    IdleFunc      = NULL;
    DisplayFunc   = NULL;
    KeyDownFunc   = NULL;
    MouseDownFunc = NULL;
    MouseUpFunc   = NULL;
    MouseMoveFunc = NULL;
}

static void *
AllocateMemory( size_t Size )
{
    return( LocalAlloc( LMEM_FIXED, Size ) );
}

static void *
AllocateZeroedMemory( size_t Size )
{
    return( LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size ) );
}


static void
FreeMemory( void *Chunk )
{
    TKASSERT( NULL!=Chunk );

    LocalFree( Chunk );
}


/*******************************************************************
 *                                                                 *
 *  Debugging functions go here                                    *
 *                                                                 *
 *******************************************************************/

#if DBGFUNC

static void
DbgPrintf( const char *Format, ... )
{
    va_list ArgList;
    char Buffer[256];

    va_start(ArgList, Format);
    vsprintf(Buffer, Format, ArgList);
    va_end(ArgList);

    printf("%s", Buffer );
    fflush(stdout);
}

static void
pwi( void )
{
    DbgPrintf("windInfo: x %d, y %d, w %d, h %d\n", windInfo.x, windInfo.y, windInfo.width, windInfo.height);
}

static void
pwr(RECT *pr)
{
    DbgPrintf("Rect: left %d, top %d, right %d, bottom %d\n", pr->left, pr->top, pr->right, pr->bottom);
}

static void
ShowPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    int format;

    ppfd   = &pfd;
    format = PixelFormatDescriptorFromDc( hdc, ppfd );

    DbgPrintf("Pixel format %d\n", format);
    DbgPrintf("  dwFlags - 0x%x", ppfd->dwFlags);
        if (ppfd->dwFlags & PFD_DOUBLEBUFFER) DbgPrintf("PFD_DOUBLEBUFFER ");
        if (ppfd->dwFlags & PFD_STEREO) DbgPrintf("PFD_STEREO ");
        if (ppfd->dwFlags & PFD_DRAW_TO_WINDOW) DbgPrintf("PFD_DRAW_TO_WINDOW ");
        if (ppfd->dwFlags & PFD_DRAW_TO_BITMAP) DbgPrintf("PFD_DRAW_TO_BITMAP ");
        if (ppfd->dwFlags & PFD_SUPPORT_GDI) DbgPrintf("PFD_SUPPORT_GDI ");
        if (ppfd->dwFlags & PFD_SUPPORT_OPENGL) DbgPrintf("PFD_SUPPORT_OPENGL ");
        if (ppfd->dwFlags & PFD_GENERIC_FORMAT) DbgPrintf("PFD_GENERIC_FORMAT ");
        if (ppfd->dwFlags & PFD_NEED_PALETTE) DbgPrintf("PFD_NEED_PALETTE ");
        if (ppfd->dwFlags & PFD_NEED_SYSTEM_PALETTE) DbgPrintf("PFD_NEED_SYSTEM_PALETTE ");
        DbgPrintf("\n");
    DbgPrintf("  iPixelType - %d", ppfd->iPixelType);
        if (ppfd->iPixelType == PFD_TYPE_RGBA) DbgPrintf("PGD_TYPE_RGBA\n");
        if (ppfd->iPixelType == PFD_TYPE_COLORINDEX) DbgPrintf("PGD_TYPE_COLORINDEX\n");
    DbgPrintf("  cColorBits - %d\n", ppfd->cColorBits);
    DbgPrintf("  cRedBits - %d\n", ppfd->cRedBits);
    DbgPrintf("  cRedShift - %d\n", ppfd->cRedShift);
    DbgPrintf("  cGreenBits - %d\n", ppfd->cGreenBits);
    DbgPrintf("  cGreenShift - %d\n", ppfd->cGreenShift);
    DbgPrintf("  cBlueBits - %d\n", ppfd->cBlueBits);
    DbgPrintf("  cBlueShift - %d\n", ppfd->cBlueShift);
    DbgPrintf("  cAlphaBits - %d\n", ppfd->cAlphaBits);
    DbgPrintf("  cAlphaShift - 0x%x\n", ppfd->cAlphaShift);
    DbgPrintf("  cAccumBits - %d\n", ppfd->cAccumBits);
    DbgPrintf("  cAccumRedBits - %d\n", ppfd->cAccumRedBits);
    DbgPrintf("  cAccumGreenBits - %d\n", ppfd->cAccumGreenBits);
    DbgPrintf("  cAccumBlueBits - %d\n", ppfd->cAccumBlueBits);
    DbgPrintf("  cAccumAlphaBits - %d\n", ppfd->cAccumAlphaBits);
    DbgPrintf("  cDepthBits - %d\n", ppfd->cDepthBits);
    DbgPrintf("  cStencilBits - %d\n", ppfd->cStencilBits);
    DbgPrintf("  cAuxBuffers - %d\n", ppfd->cAuxBuffers);
    DbgPrintf("  iLayerType - %d\n", ppfd->iLayerType);
    DbgPrintf("  bReserved - %d\n", ppfd->bReserved);
    DbgPrintf("  dwLayerMask - 0x%x\n", ppfd->dwLayerMask);
    DbgPrintf("  dwVisibleMask - 0x%x\n", ppfd->dwVisibleMask);
    DbgPrintf("  dwDamageMask - 0x%x\n", ppfd->dwDamageMask);

}

#endif  /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\tkdib.c ===
/******************************Module*Header*******************************\
* Module Name: dib.c
*
* (Brief description)
*
* Created: 21-Feb-1994 23:12:58
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
*   (#defines)
*   (#includes)
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> 
#include "tk.h"

#define static

#define BFT_BITMAP  0x4d42  // 'BM' -- indicates structure is BITMAPFILEHEADER

// struct BITMAPFILEHEADER {
//      WORD  bfType
//      DWORD bfSize
//      WORD  bfReserved1
//      WORD  bfReserved2
//      DWORD bfOffBits
// }
#define OFFSET_bfType       0
#define OFFSET_bfSize       2
#define OFFSET_bfReserved1  6
#define OFFSET_bfReserved2  8
#define OFFSET_bfOffBits    10
#define SIZEOF_BITMAPFILEHEADER 14

// Read a WORD-aligned DWORD.  Needed because BITMAPFILEHEADER has
// WORD-alignment.
#define READDWORD(pv)   ( (DWORD)((PWORD)(pv))[0]               \
                          | ((DWORD)((PWORD)(pv))[1] << 16) )   \

// Computes the number of BYTES needed to contain n number of bits.
#define BITS2BYTES(n)   ( ((n) + 7) >> 3 )

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DibNumColors(VOID FAR * pv)                                *
 *                                                                          *
 *  PURPOSE    : Determines the number of colors in the DIB by looking at   *
 *               the BitCount filed in the info block.                      *
 *                                                                          *
 *  RETURNS    : The number of colors in the DIB.                           *
 *                                                                          *
 * Stolen from SDK ShowDIB example.                                         *
 ****************************************************************************/

WORD DibNumColors(VOID FAR * pv)
{
    WORD                bits;
    BITMAPINFOHEADER UNALIGNED *lpbi;
    BITMAPCOREHEADER UNALIGNED *lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     *
     *  Because of the way we use this call, BITMAPINFOHEADER may be out
     *  of alignment if it follows a BITMAPFILEHEADER.  So use the macro
     *  to safely access DWORD fields.
     */
    if (READDWORD(&lpbi->biSize) != sizeof(BITMAPCOREHEADER)){
        if (READDWORD(&lpbi->biClrUsed) != 0)
        {
            return (WORD) READDWORD(&lpbi->biClrUsed);
        }
        bits = lpbi->biBitCount;
    }
    else
        bits = lpbc->bcBitCount;

    switch (bits){
        case 1:
            return 2;
        case 4:
            return 16;
        case 8:
            return 256;
        default:
            /* A 24 bitcount DIB has no color table */
            return 0;
    }
}

/******************************Public*Routine******************************\
* tkDIBImageLoad
*
* ANSI version stub.  Only here for orthogonality with tkRGBImageLoad.
*
* History:
*  22-Feb-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

TK_RGBImageRec *tkDIBImageLoadAW(char *fileName, BOOL bUnicode);

TK_RGBImageRec *tkDIBImageLoad(char *fileName)
{
    return tkDIBImageLoadAW(fileName, FALSE);
}

/******************************Public*Routine******************************\
* tkDIBImageLoadAW
*
* Loads a DIB file (specified as either an ANSI or Unicode filename,
* depending on the bUnicode flag) and converts it into a TK image format.
*
* The technique used is based on CreateDIBSection and SetDIBits.
* CreateDIBSection is used to create a DIB with a format easily converted
* into the TK image format (packed 24BPP RGB).  The only conversion 
* required is swapping R and B in each RGB triplet (see history below)
* The resulting bitmap is selected into a memory DC.
*
* The DIB file is mapped into memory and SetDIBits called to initialize
* the memory DC bitmap.  It is during this step that GDI converts the
* arbitrary DIB file format to RGB format.
*
* Finally, the RGB data in the DIB section is read out and repacked
* as 24BPP 'BGR'.
*
* Returns:
*   Pointer to TK_RGBImageRec.  If an error occurs, a diagnostic error
*   message is put into the error stream and tkQuit() is called,
*   terminating the app.
*
* History:
*  - 22-Feb-1994 -by- Gilman Wong [gilmanw]
*    Wrote it.
*
*  - 01-May-1995 : [marcfo]
*    Don't quit if can't open DIB file - return NULL.
*
*  - 27-Jul-1995 : [marcfo]
*    Changed CreateDIBSection to create an RGB mapping, so this would work
*    on win95.  Swapping of R and B required, to generate BGR (R=low byte)
*    for GL.  If the GL 'BGR' (R=high byte) extension becomes part of api
*    in OpenGL 2.0, then we can avoid swap and do a memcpy to grab the bits.
*
\**************************************************************************/

TK_RGBImageRec *tkDIBImageLoadAW(char *fileName, BOOL bUnicode)
{
    TK_RGBImageRec *final = (TK_RGBImageRec *) NULL; // Ptr to TK image struct
                                                     // to return.  Non-NULL
                                                     // only for success.

    WORD             wNumColors;    // Number of colors in color table
    BITMAPFILEHEADER *pbmf;         // Ptr to file header
    BITMAPINFOHEADER UNALIGNED *pbmihFile;
    BITMAPCOREHEADER UNALIGNED *pbmchFile; // Ptr to file's core header (if it exists)
    PVOID            pvBitsFile;    // Ptr to bitmap bits in file
    PBYTE            pjBitsRGB;     // Ptr to 24BPP RGB image in DIB section
    PBYTE            pjTKBits = (PBYTE) NULL;   // Ptr to final TK image bits
    PBYTE            pjSrc;         // Ptr to image file used for conversion
    PBYTE            pjDst;         // Ptr to TK image used for conversion

    // These need to be cleaned up when we exit:
    HANDLE     hFile = INVALID_HANDLE_VALUE;        // File handle
    HANDLE     hMap = (HANDLE) NULL;                // Mapping object handle
    PVOID      pvFile = (PVOID) NULL;               // Ptr to mapped file
    HDC        hdcMem = (HDC) NULL;                 // 24BPP mem DC
    HBITMAP    hbmRGB = (HBITMAP) NULL;             // 24BPP RGB bitmap
    BITMAPINFO *pbmiSource = (BITMAPINFO *) NULL;   // Ptr to source BITMAPINFO
    BITMAPINFO *pbmiRGB = (BITMAPINFO *) NULL;      // Ptr to file's BITMAPINFO

    int i, j;
    int padBytes;

// Map the DIB file into memory.

    hFile = bUnicode ? 
            CreateFileW((LPWSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, 0, 0) :
            CreateFileA((LPSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, 0, 0);

    if (hFile == INVALID_HANDLE_VALUE)
        goto tkDIBLoadImage_cleanup;

    hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!hMap)
        goto tkDIBLoadImage_cleanup;

    pvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (!pvFile)
        goto tkDIBLoadImage_cleanup;

// Check the file header.  If the BFT_BITMAP magic number is there,
// then the file format is a BITMAPFILEHEADER followed immediately
// by either a BITMAPINFOHEADER or a BITMAPCOREHEADER.  The bitmap
// bits, in this case, are located at the offset bfOffBits from the
// BITMAPFILEHEADER.
//
// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER
// followed immediately with the color table and the bitmap bits.

    pbmf = (BITMAPFILEHEADER *) pvFile;

    if ( pbmf->bfType == BFT_BITMAP )
    {
        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER);

    // BITMAPFILEHEADER is WORD aligned, so use safe macro to read DWORD
    // bfOffBits field.

        pvBitsFile = (PVOID *) ((PBYTE) pbmf
                                + READDWORD((PBYTE) pbmf + OFFSET_bfOffBits));
    }
    else
    {
        pbmihFile = (BITMAPINFOHEADER *) pvFile;

    // Determination of where the bitmaps bits are needs to wait until we
    // know for sure whether we have a BITMAPINFOHEADER or a BITMAPCOREHEADER.
    }

// Determine the number of colors in the DIB palette.  This is non-zero
// only for 8BPP or less.

    wNumColors = DibNumColors(pbmihFile);

// Create a BITMAPINFO (with color table) for the DIB file.  Because the
// file may not have one (BITMAPCORE case) and potential alignment problems,
// we will create a new one in memory we allocate.
//
// We distinguish between BITMAPINFO and BITMAPCORE cases based upon
// BITMAPINFOHEADER.biSize.

    pbmiSource = (BITMAPINFO *)
        LocalAlloc(LMEM_FIXED, sizeof(BITMAPINFO)
                               + wNumColors * sizeof(RGBQUAD));
    if (!pbmiSource)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    // Note: need to use safe READDWORD macro because pbmihFile may
    // have only WORD alignment if it follows a BITMAPFILEHEADER.

    switch (READDWORD(&pbmihFile->biSize))
    {
    case sizeof(BITMAPINFOHEADER):

    // Convert WORD-aligned BITMAPINFOHEADER to aligned BITMAPINFO.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = READDWORD(&pbmihFile->biWidth);
        pbmiSource->bmiHeader.biHeight        = READDWORD(&pbmihFile->biHeight);
        pbmiSource->bmiHeader.biPlanes        = pbmihFile->biPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmihFile->biBitCount;
        pbmiSource->bmiHeader.biCompression   = 
                                        READDWORD(&pbmihFile->biCompression);
        pbmiSource->bmiHeader.biSizeImage     = 
                                        READDWORD(&pbmihFile->biSizeImage);
        pbmiSource->bmiHeader.biXPelsPerMeter = 
                                        READDWORD(&pbmihFile->biXPelsPerMeter);
        pbmiSource->bmiHeader.biYPelsPerMeter = 
                                        READDWORD(&pbmihFile->biYPelsPerMeter);
        pbmiSource->bmiHeader.biClrUsed       = 
                                        READDWORD(&pbmihFile->biClrUsed);
        pbmiSource->bmiHeader.biClrImportant  = 
                                        READDWORD(&pbmihFile->biClrImportant);

    // Copy color table.  It immediately follows the BITMAPINFOHEADER.

        memcpy((PVOID) &pbmiSource->bmiColors[0], (PVOID) (pbmihFile + 1),
               wNumColors * sizeof(RGBQUAD));

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBitsFile)
            pvBitsFile = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBQUAD));
        break;

    case sizeof(BITMAPCOREHEADER):
        pbmchFile = (BITMAPCOREHEADER *) pbmihFile;

    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = (DWORD) pbmchFile->bcWidth;
        pbmiSource->bmiHeader.biHeight        = (DWORD) pbmchFile->bcHeight;
        pbmiSource->bmiHeader.biPlanes        = pbmchFile->bcPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmchFile->bcBitCount;
        pbmiSource->bmiHeader.biCompression   = BI_RGB;
        pbmiSource->bmiHeader.biSizeImage     = 0;
        pbmiSource->bmiHeader.biXPelsPerMeter = 0;
        pbmiSource->bmiHeader.biYPelsPerMeter = 0;
        pbmiSource->bmiHeader.biClrUsed       = wNumColors;
        pbmiSource->bmiHeader.biClrImportant  = wNumColors;

    // Convert RGBTRIPLE color table into RGBQUAD color table.

        {
            RGBQUAD *rgb4 = pbmiSource->bmiColors;
            RGBTRIPLE *rgb3 = (RGBTRIPLE *) (pbmchFile + 1);

            for (i = 0; i < wNumColors; i++)
            {
                rgb4->rgbRed   = rgb3->rgbtRed  ;
                rgb4->rgbGreen = rgb3->rgbtGreen;
                rgb4->rgbBlue  = rgb3->rgbtBlue ;
                rgb4->rgbReserved = 0;

                rgb4++;
                rgb3++;
            }
        }

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBitsFile)
            pvBitsFile = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBTRIPLE));
        break;

    default:
        MESSAGEBOX(GetFocus(), "Unknown DIB file format.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Fill in default values (for fields that can have defaults).

    if (pbmiSource->bmiHeader.biSizeImage == 0)
        pbmiSource->bmiHeader.biSizeImage = 
            BITS2BYTES( (DWORD) pbmiSource->bmiHeader.biWidth * 
                                pbmiSource->bmiHeader.biBitCount ) * 
                                pbmiSource->bmiHeader.biHeight;
    if (pbmiSource->bmiHeader.biClrUsed == 0)
        pbmiSource->bmiHeader.biClrUsed = wNumColors;

// Create memory DC.

    hdcMem = CreateCompatibleDC(NULL);
    if (!hdcMem) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Create a 24BPP RGB DIB section and select it into the memory DC.

    pbmiRGB = (BITMAPINFO *)
              LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(BITMAPINFO) );
    if (!pbmiRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    pbmiRGB->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmiRGB->bmiHeader.biWidth         = pbmiSource->bmiHeader.biWidth;
    pbmiRGB->bmiHeader.biHeight        = pbmiSource->bmiHeader.biHeight;
    pbmiRGB->bmiHeader.biPlanes        = 1;
    pbmiRGB->bmiHeader.biBitCount      = 24;
    pbmiRGB->bmiHeader.biCompression   = BI_RGB;
    pbmiRGB->bmiHeader.biSizeImage     = pbmiRGB->bmiHeader.biWidth
                                         * abs(pbmiRGB->bmiHeader.biHeight) * 3;

    hbmRGB = CreateDIBSection(hdcMem, pbmiRGB, DIB_RGB_COLORS, 
                              (PVOID *) &pjBitsRGB, NULL, 0);

    if (!hbmRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); 
        goto tkDIBLoadImage_cleanup;
    }

    if (!SelectObject(hdcMem, hbmRGB))
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Slam the DIB file image into the memory DC.  GDI will do the work of
// translating whatever format the DIB file has into RGB format.

    if (!SetDIBits(hdcMem, hbmRGB, 0, pbmiSource->bmiHeader.biHeight, 
                   pvBitsFile, pbmiSource, DIB_RGB_COLORS))
    {
        MESSAGEBOX(GetFocus(), "Image file conversion error.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }
    GdiFlush();     // make sure that SetDIBits executes

// Convert to TK image format (packed RGB format).
// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app
// can deallocate with free()).

    pjTKBits = (PBYTE) malloc(pbmiRGB->bmiHeader.biSizeImage);
    if (!pjTKBits)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    pjSrc = pjBitsRGB;
    pjDst = pjTKBits;
    // src lines end on LONG boundary - so need to skip over any padding bytes
    padBytes = pbmiSource->bmiHeader.biWidth % sizeof(LONG);
    for (i = 0; i < pbmiSource->bmiHeader.biHeight; i++)
    {
        for (j = 0; j < pbmiSource->bmiHeader.biWidth; j++)
        {
            // swap R and B
            *pjDst++ = pjSrc[2];
            *pjDst++ = pjSrc[1];
            *pjDst++ = pjSrc[0];
            pjSrc += 3;
        }
        pjSrc += padBytes;
    }

// Allocate and initialize the TK_RGBImageRec.
// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app
// can deallocate with free()).

    final = (TK_RGBImageRec *)malloc(sizeof(TK_RGBImageRec));
    if (final == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }
    // If we get to here, we have suceeded!
    final->sizeX = pbmiSource->bmiHeader.biWidth;
    final->sizeY = pbmiSource->bmiHeader.biHeight;
    final->data = pjTKBits;

// Cleanup objects.

tkDIBLoadImage_cleanup:
    {
        if (hdcMem)
            DeleteDC(hdcMem);

        if (hbmRGB)
            DeleteObject(hbmRGB);

        if (pbmiRGB)
            LocalFree(pbmiRGB);

        if (pbmiSource)
            LocalFree(pbmiSource);

        if (pvFile)
            UnmapViewOfFile(pvFile);

        if (hMap)
            CloseHandle(hMap);

        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
    }

// Check for error.

    if (!final)
    {
        if (pjTKBits)
            free(pjTKBits);

        if ( (hFile == INVALID_HANDLE_VALUE) || !hMap || !pvFile )
        {
            CHAR ach[256];

            bUnicode ? wsprintf(ach, "Failed to open DIB file %ws.\n", fileName) :
                       wsprintf(ach, "Failed to open DIB file %s.\n", fileName);

            MESSAGEBOX(GetFocus(), ach, "Error", MB_OK);
        }
    }

    return final;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\tkfont.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include "tk.h"

#define static

enum {
    FONT_BEGIN = 1,
    FONT_NEXT,
    FONT_END,
    FONT_ADVANCE
};
#define MAX_STROKES        256
#define END_OF_LIST        256
#define BITMAP_END_OF_LIST 0

#define STROKE_SCALE ((GLfloat) 1.71)
#define OUTLINE_SCALE ((GLfloat) 0.023)
#define FILLED_SCALE ((GLfloat) 0.023)


GLint strokeFont[][1+MAX_STROKES*3] = {
    {
	1,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 2, 2,
	FONT_END, 4, 4,
	FONT_BEGIN, 2, 8,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	2,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 3, 5,
	FONT_END, 4, 6,
	FONT_BEGIN, 3, 5,
	FONT_NEXT, 3, 3,
	FONT_END, 4, 2,
	FONT_BEGIN, 3, 3,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	3,
	FONT_BEGIN, 0, 0,
	FONT_NEXT, 1, 1,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 5, 5,
	FONT_NEXT, 4, 4,
	FONT_END, 1, 4,
	FONT_BEGIN, 4, 4,
	FONT_NEXT, 5, 3,
	FONT_NEXT, 4, 2,
	FONT_END, 1, 2,
	FONT_ADVANCE, 7, 0
    },
    {
	4,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 2, 6,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	5,
	FONT_BEGIN, 0, 5,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	6,
	FONT_BEGIN, 1, 4,
	FONT_END, 3, 4,
	FONT_BEGIN, 3, 6,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 1, 3,
	FONT_NEXT, 2, 2,
	FONT_END, 3, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	7,
	FONT_BEGIN, 1, 2,
	FONT_END, 1, 6,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 6,
	FONT_BEGIN, 3, 6,
	FONT_END, 3, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	8,
	FONT_BEGIN, 0, 2,
	FONT_END, 2, 4,
	FONT_BEGIN, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	10,
	FONT_ADVANCE, 0, -9
    },
    {
	11,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 1, 1,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 2, 7,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	12,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 3,
	FONT_BEGIN, 4, 6,
	FONT_END, 0, 6,
	FONT_BEGIN, 2, 8,
	FONT_END, 2, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	14,
	FONT_BEGIN, 1, 3,
	FONT_NEXT, 2, 4,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 3,
	FONT_END, 2, 4,
	FONT_BEGIN, 2, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 4,
	FONT_END, 1, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	15,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 2, 8,
	FONT_END, 1, 8,
	FONT_BEGIN, 4, 4,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	16,
	FONT_BEGIN, 4, 7,
	FONT_NEXT, 1, 7,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 1, 3,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	17,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 3, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 3, 7,
	FONT_END, 0, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	18,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 7,
	FONT_NEXT, 3, 7,
	FONT_NEXT, 4, 6,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	19,
	FONT_BEGIN, 0, 7,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 4,
	FONT_NEXT, 3, 4,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	20,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 2, 2,
	FONT_END, 4, 8,
	FONT_BEGIN, 3, 6,
	FONT_END, 1, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	21,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 4, 5,
	FONT_END, 1, 5,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 4, 8,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	22,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 7,
	FONT_NEXT, 3, 7,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 3,
	FONT_NEXT, 1, 3,
	FONT_END, 0, 4,
	FONT_BEGIN, 1, 4,
	FONT_END, 3, 6,
	FONT_BEGIN, 1, 6,
	FONT_END, 3, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	23,
	FONT_BEGIN, 2, 0,
	FONT_NEXT, 0, 2,
	FONT_NEXT, 4, 6,
	FONT_END, 2, 8,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 6,
	FONT_BEGIN, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	24,
	FONT_BEGIN, 0, 0,
	FONT_END, 4, 0,
	FONT_ADVANCE, 6, 0
    },
    {
	25,
	FONT_BEGIN, 2, 3,
	FONT_NEXT, 4, 5,
	FONT_END, 2, 7,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	26,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 1, 9,
	FONT_NEXT, 2, 9,
	FONT_NEXT, 2, 8,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 9,
	FONT_ADVANCE, 6, 0
    },
    {
	27,
	FONT_BEGIN, 0, 1,
	FONT_END, 4, 7,
	FONT_BEGIN, 4, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 1
    },
    {
	28,
	FONT_BEGIN, 1, 2,
	FONT_END, 3, 2,
	FONT_BEGIN, 3, 4,
	FONT_NEXT, 1, 6,
	FONT_END, 3, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	29,
	FONT_BEGIN, 1, 2,
	FONT_END, 3, 2,
	FONT_BEGIN, 1, 4,
	FONT_NEXT, 3, 6,
	FONT_END, 1, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	30,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 3,
	FONT_BEGIN, 4, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 0, 7,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	31,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 2, 4,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	32,
	FONT_ADVANCE, 6, 0
    },
    {
	33,
	FONT_BEGIN, 2, 1,
	FONT_END, 2, 2,
	FONT_BEGIN, 2, 4,
	FONT_END, 2, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	34,
	FONT_BEGIN, 1, 7,
	FONT_END, 1, 9,
	FONT_BEGIN, 3, 9,
	FONT_END, 3, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	35,
	FONT_BEGIN, 1, 2,
	FONT_END, 1, 7,
	FONT_BEGIN, 3, 7,
	FONT_END, 3, 2,
	FONT_BEGIN, 4, 3,
	FONT_END, 0, 3,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	36,
	FONT_BEGIN, 2, 1,
	FONT_END, 2, 9,
	FONT_BEGIN, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 3, 1,
	FONT_NEXT, 1, 1,
	FONT_END, 0, 2,
	FONT_ADVANCE, 6, -1
    },
    {
	37,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 4, 7,
	FONT_END, 4, 8,
	FONT_BEGIN, 1, 8,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 7,
	FONT_END, 1, 8,
	FONT_BEGIN, 4, 3,
	FONT_NEXT, 5, 3,
	FONT_NEXT, 5, 2,
	FONT_NEXT, 4, 2,
	FONT_END, 5, 2,
	FONT_ADVANCE, 8, 1
    },
    {
	38,
	FONT_BEGIN, 4, 4,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 2, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	39,
	FONT_BEGIN, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 1, 9,
	FONT_NEXT, 2, 9,
	FONT_NEXT, 2, 8,
	FONT_END, 1, 8,
	FONT_ADVANCE, 6, 1
    },
    {
	40,
	FONT_BEGIN, 4, 2,
	FONT_NEXT, 2, 4,
	FONT_NEXT, 2, 6,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	41,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 2, 4,
	FONT_NEXT, 2, 6,
	FONT_END, 0, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	42,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 8,
	FONT_BEGIN, 0, 7,
	FONT_END, 4, 3,
	FONT_BEGIN, 4, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	43,
	FONT_BEGIN, 2, 3,
	FONT_END, 2, 7,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	44,
	FONT_BEGIN, 0, 1,
	FONT_NEXT, 1, 2,
	FONT_END, 1, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	45,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	46,
	FONT_BEGIN, 1, 2,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	47,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	48,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	49,
	FONT_BEGIN, 1, 2,
	FONT_END, 3, 2,
	FONT_BEGIN, 2, 2,
	FONT_NEXT, 2, 8,
	FONT_END, 1, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	50,
	FONT_BEGIN, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	51,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 5,
	FONT_END, 2, 5,
	FONT_BEGIN, 3, 5,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_END, 0, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	52,
	FONT_BEGIN, 3, 2,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 4,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	53,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 0, 8,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	54,
	FONT_BEGIN, 0, 5,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 2, 8,
	FONT_END, 3, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	55,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 4, 8,
	FONT_NEXT, 2, 4,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	56,
	FONT_BEGIN, 1, 5,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 6,
	FONT_END, 3, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	57,
	FONT_BEGIN, 1, 2,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	58,
	FONT_BEGIN, 0, 3,
	FONT_END, 1, 3,
	FONT_BEGIN, 1, 6,
	FONT_END, 0, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	59,
	FONT_BEGIN, 0, 1,
	FONT_NEXT, 1, 2,
	FONT_END, 1, 3,
	FONT_BEGIN, 1, 6,
	FONT_END, 0, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	60,
	FONT_BEGIN, 3, 3,
	FONT_NEXT, 1, 5,
	FONT_END, 3, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	61,
	FONT_BEGIN, 0, 4,
	FONT_END, 4, 4,
	FONT_BEGIN, 4, 6,
	FONT_END, 0, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	62,
	FONT_BEGIN, 1, 7,
	FONT_NEXT, 3, 5,
	FONT_END, 1, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	63,
	FONT_BEGIN, 1, 2,
	FONT_END, 2, 2,
	FONT_BEGIN, 2, 4,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_END, 0, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	64,
	FONT_BEGIN, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 2, 4,
	FONT_NEXT, 2, 6,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	65,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_END, 4, 2,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	66,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 3, 5,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 0, 8,
	FONT_END, 0, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	67,
	FONT_BEGIN, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	68,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_END, 0, 8,
	FONT_BEGIN, 1, 8,
	FONT_END, 1, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	69,
	FONT_BEGIN, 4, 2,
	FONT_NEXT, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_END, 4, 8,
	FONT_BEGIN, 3, 5,
	FONT_END, 0, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	70,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_END, 4, 8,
	FONT_BEGIN, 3, 5,
	FONT_END, 0, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	71,
	FONT_BEGIN, 3, 4,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	72,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_BEGIN, 4, 8,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	73,
	FONT_BEGIN, 1, 2,
	FONT_END, 3, 2,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 8,
	FONT_BEGIN, 1, 8,
	FONT_END, 3, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	74,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	75,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 8,
	FONT_NEXT, 1, 5,
	FONT_END, 4, 2,
	FONT_ADVANCE, 8, 0
    },
    {
	76,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	77,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 4, 8,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	78,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 4, 2,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	79,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	80,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 3, 5,
	FONT_END, 0, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	81,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_BEGIN, 2, 5,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	82,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 3, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 1, 5,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	83,
	FONT_BEGIN, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	84,
	FONT_BEGIN, 0, 8,
	FONT_END, 4, 8,
	FONT_BEGIN, 2, 8,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	85,
	FONT_BEGIN, 0, 3,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 8,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	86,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	87,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 8,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 2, 4,
	FONT_END, 0, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	88,
	FONT_BEGIN, 0, 2,
	FONT_END, 4, 8,
	FONT_BEGIN, 0, 8,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	89,
	FONT_BEGIN, 2, 2,
	FONT_NEXT, 2, 5,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 8,
	FONT_END, 2, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	90,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 4, 8,
	FONT_NEXT, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	91,
	FONT_BEGIN, 3, 1,
	FONT_NEXT, 1, 1,
	FONT_NEXT, 1, 9,
	FONT_END, 3, 9,
	FONT_ADVANCE, 6, 0
    },
    {
	92,
	FONT_BEGIN, 0, 7,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	93,
	FONT_BEGIN, 1, 9,
	FONT_NEXT, 3, 9,
	FONT_NEXT, 3, 1,
	FONT_END, 1, 1,
	FONT_ADVANCE, 6, 0
    },
    {
	94,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 8,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 2, 8,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	95,
	FONT_BEGIN, 2, 3,
	FONT_NEXT, 0, 5,
	FONT_END, 2, 7,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	96,
	FONT_BEGIN, 3, 8,
	FONT_NEXT, 2, 8,
	FONT_NEXT, 2, 9,
	FONT_NEXT, 3, 9,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	97,
	FONT_BEGIN, 1, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 4,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	98,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 0, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 3, 6,
	FONT_END, 0, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	99,
	FONT_BEGIN, 4, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	100,
	FONT_BEGIN, 4, 8,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	101,
	FONT_BEGIN, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 3, 4,
	FONT_END, 0, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	102,
	FONT_BEGIN, 1, 2,
	FONT_NEXT, 1, 7,
	FONT_NEXT, 2, 8,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 7,
	FONT_BEGIN, 2, 5,
	FONT_END, 0, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	103,
	FONT_BEGIN, 1, 0,
	FONT_NEXT, 3, 0,
	FONT_NEXT, 4, 1,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	104,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	105,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 5,
	FONT_BEGIN, 2, 6,
	FONT_END, 2, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	106,
	FONT_BEGIN, 0, 1,
	FONT_NEXT, 1, 0,
	FONT_NEXT, 3, 0,
	FONT_NEXT, 4, 1,
	FONT_END, 4, 5,
	FONT_BEGIN, 4, 6,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	107,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 6,
	FONT_NEXT, 2, 4,
	FONT_END, 0, 4,
	FONT_BEGIN, 2, 4,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	108,
	FONT_BEGIN, 1, 2,
	FONT_END, 1, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	109,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 2,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	110,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	111,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	112,
	FONT_BEGIN, 0, 0,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_END, 0, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	113,
	FONT_BEGIN, 4, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 0,
	FONT_ADVANCE, 6, 0
    },
    {
	114,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 6,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 3, 6,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	115,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 4,
	FONT_NEXT, 1, 4,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	116,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 6,
	FONT_BEGIN, 2, 8,
	FONT_NEXT, 2, 3,
	FONT_NEXT, 3, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	117,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	118,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 4, 4,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	119,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 2, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	120,
	FONT_BEGIN, 0, 2,
	FONT_END, 4, 6,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	121,
	FONT_BEGIN, 0, 0,
	FONT_NEXT, 4, 4,
	FONT_END, 4, 6,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 0, 4,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	122,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	123,
	FONT_BEGIN, 4, 9,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 3, 4,
	FONT_NEXT, 3, 2,
	FONT_END, 4, 1,
	FONT_ADVANCE, 6, 0
    },
    {
	124,
	FONT_BEGIN, 2, 9,
	FONT_END, 2, 0,
	FONT_ADVANCE, 6, 0
    },
    {
	125,
	FONT_BEGIN, 2, 2,
	FONT_NEXT, 2, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 2, 7,
	FONT_END, 2, 8,
	FONT_BEGIN, 2, 7,
	FONT_NEXT, 4, 5,
	FONT_END, 2, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	126,
	FONT_BEGIN, 0, 9,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 1, 4,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 1,
	FONT_ADVANCE, 6, 0
    },
    {
	END_OF_LIST
    }
};

GLint outlineFont[][1+MAX_STROKES*3] = {
    {
	32,
	FONT_ADVANCE, 250, 0
    },
    {
	33,
	FONT_BEGIN, 234, 559,
	FONT_NEXT, 236, 605,
	FONT_NEXT, 229, 642,
	FONT_NEXT, 211, 667,
	FONT_NEXT, 182, 676,
	FONT_NEXT, 156, 668,
	FONT_NEXT, 140, 648,
	FONT_NEXT, 130, 592,
	FONT_NEXT, 131, 568,
	FONT_NEXT, 134, 534,
	FONT_NEXT, 146, 447,
	FONT_NEXT, 158, 355,
	FONT_NEXT, 163, 315,
	FONT_NEXT, 167, 284,
	FONT_NEXT, 176, 176,
	FONT_END, 189, 176,
	FONT_BEGIN, 219, 3,
	FONT_NEXT, 232, 18,
	FONT_NEXT, 238, 42,
	FONT_NEXT, 233, 62,
	FONT_NEXT, 222, 79,
	FONT_NEXT, 204, 91,
	FONT_NEXT, 183, 96,
	FONT_NEXT, 162, 91,
	FONT_NEXT, 145, 80,
	FONT_NEXT, 134, 63,
	FONT_NEXT, 130, 42,
	FONT_NEXT, 135, 18,
	FONT_NEXT, 148, 2,
	FONT_END, 183, -9,
	FONT_ADVANCE, 333, 0
    },
    {
	34,
	FONT_BEGIN, 308, 482,
	FONT_NEXT, 318, 543,
	FONT_NEXT, 327, 599,
	FONT_NEXT, 331, 635,
	FONT_NEXT, 317, 665,
	FONT_NEXT, 289, 676,
	FONT_NEXT, 260, 665,
	FONT_NEXT, 246, 635,
	FONT_NEXT, 249, 599,
	FONT_NEXT, 258, 543,
	FONT_NEXT, 268, 482,
	FONT_NEXT, 278, 431,
	FONT_END, 299, 431,
	FONT_BEGIN, 139, 482,
	FONT_NEXT, 149, 543,
	FONT_NEXT, 158, 599,
	FONT_NEXT, 162, 635,
	FONT_NEXT, 148, 665,
	FONT_NEXT, 120, 676,
	FONT_NEXT, 91, 665,
	FONT_NEXT, 77, 635,
	FONT_NEXT, 80, 599,
	FONT_NEXT, 89, 543,
	FONT_NEXT, 99, 482,
	FONT_NEXT, 109, 431,
	FONT_END, 130, 431,
	FONT_ADVANCE, 408, 0
    },
    {
	35,
	FONT_BEGIN, 371, 271,
	FONT_NEXT, 391, 405,
	FONT_NEXT, 496, 405,
	FONT_NEXT, 496, 460,
	FONT_NEXT, 399, 460,
	FONT_NEXT, 429, 662,
	FONT_NEXT, 371, 662,
	FONT_NEXT, 341, 460,
	FONT_NEXT, 208, 460,
	FONT_NEXT, 239, 662,
	FONT_NEXT, 181, 662,
	FONT_NEXT, 150, 460,
	FONT_NEXT, 32, 460,
	FONT_NEXT, 32, 405,
	FONT_NEXT, 142, 405,
	FONT_NEXT, 121, 271,
	FONT_NEXT, 5, 271,
	FONT_NEXT, 5, 216,
	FONT_NEXT, 112, 216,
	FONT_NEXT, 79, 0,
	FONT_NEXT, 137, 0,
	FONT_NEXT, 170, 216,
	FONT_NEXT, 304, 216,
	FONT_NEXT, 273, 0,
	FONT_NEXT, 331, 0,
	FONT_NEXT, 362, 216,
	FONT_NEXT, 471, 216,
	FONT_END, 471, 271,
	FONT_BEGIN, 313, 271,
	FONT_NEXT, 179, 271,
	FONT_NEXT, 200, 405,
	FONT_END, 333, 405,
	FONT_ADVANCE, 500, 0
    },
    {
	36,
	FONT_BEGIN, 425, 611,
	FONT_NEXT, 387, 634,
	FONT_NEXT, 345, 649,
	FONT_NEXT, 264, 664,
	FONT_NEXT, 264, 727,
	FONT_NEXT, 230, 727,
	FONT_NEXT, 230, 664,
	FONT_NEXT, 185, 658,
	FONT_NEXT, 148, 646,
	FONT_NEXT, 93, 611,
	FONT_NEXT, 61, 563,
	FONT_NEXT, 52, 511,
	FONT_NEXT, 55, 476,
	FONT_NEXT, 67, 445,
	FONT_NEXT, 106, 392,
	FONT_NEXT, 163, 349,
	FONT_NEXT, 230, 310,
	FONT_NEXT, 230, 28,
	FONT_NEXT, 166, 37,
	FONT_NEXT, 117, 66,
	FONT_NEXT, 81, 114,
	FONT_NEXT, 59, 181,
	FONT_NEXT, 44, 181,
	FONT_NEXT, 44, 51,
	FONT_NEXT, 70, 35,
	FONT_NEXT, 110, 19,
	FONT_NEXT, 162, 5,
	FONT_NEXT, 230, 0,
	FONT_NEXT, 230, -87,
	FONT_NEXT, 264, -87,
	FONT_NEXT, 264, 0,
	FONT_NEXT, 338, 16,
	FONT_NEXT, 399, 49,
	FONT_NEXT, 441, 100,
	FONT_NEXT, 453, 134,
	FONT_NEXT, 457, 174,
	FONT_NEXT, 453, 211,
	FONT_NEXT, 444, 243,
	FONT_NEXT, 408, 295,
	FONT_NEXT, 348, 341,
	FONT_NEXT, 264, 391,
	FONT_NEXT, 264, 637,
	FONT_NEXT, 305, 628,
	FONT_NEXT, 348, 607,
	FONT_NEXT, 385, 566,
	FONT_NEXT, 399, 537,
	FONT_NEXT, 410, 500,
	FONT_END, 425, 500,
	FONT_BEGIN, 187, 435,
	FONT_NEXT, 155, 464,
	FONT_NEXT, 133, 495,
	FONT_NEXT, 126, 532,
	FONT_NEXT, 128, 555,
	FONT_NEXT, 141, 586,
	FONT_NEXT, 171, 616,
	FONT_NEXT, 196, 628,
	FONT_NEXT, 229, 637,
	FONT_END, 229, 407,
	FONT_BEGIN, 308, 264,
	FONT_NEXT, 344, 234,
	FONT_NEXT, 369, 197,
	FONT_NEXT, 378, 151,
	FONT_NEXT, 374, 116,
	FONT_NEXT, 364, 89,
	FONT_NEXT, 333, 53,
	FONT_NEXT, 295, 35,
	FONT_NEXT, 264, 28,
	FONT_END, 264, 293,
	FONT_ADVANCE, 500, 0
    },
    {
	37,
	FONT_BEGIN, 622, 365,
	FONT_NEXT, 583, 349,
	FONT_NEXT, 514, 293,
	FONT_NEXT, 466, 218,
	FONT_NEXT, 453, 177,
	FONT_NEXT, 449, 137,
	FONT_NEXT, 455, 86,
	FONT_NEXT, 475, 42,
	FONT_NEXT, 513, 11,
	FONT_NEXT, 572, 0,
	FONT_NEXT, 615, 6,
	FONT_NEXT, 654, 25,
	FONT_NEXT, 688, 53,
	FONT_NEXT, 717, 88,
	FONT_NEXT, 757, 173,
	FONT_NEXT, 772, 261,
	FONT_NEXT, 768, 295,
	FONT_NEXT, 760, 321,
	FONT_NEXT, 731, 354,
	FONT_NEXT, 695, 368,
	FONT_END, 663, 371,
	FONT_BEGIN, 703, 332,
	FONT_NEXT, 726, 314,
	FONT_NEXT, 740, 287,
	FONT_NEXT, 746, 254,
	FONT_NEXT, 733, 183,
	FONT_NEXT, 700, 110,
	FONT_NEXT, 650, 53,
	FONT_NEXT, 620, 36,
	FONT_NEXT, 589, 30,
	FONT_NEXT, 552, 39,
	FONT_NEXT, 533, 60,
	FONT_NEXT, 525, 106,
	FONT_NEXT, 527, 128,
	FONT_NEXT, 534, 160,
	FONT_NEXT, 564, 238,
	FONT_NEXT, 611, 308,
	FONT_NEXT, 641, 330,
	FONT_END, 676, 339,
	FONT_BEGIN, 595, 676,
	FONT_NEXT, 536, 630,
	FONT_NEXT, 493, 614,
	FONT_NEXT, 438, 608,
	FONT_NEXT, 404, 610,
	FONT_NEXT, 381, 616,
	FONT_NEXT, 352, 635,
	FONT_NEXT, 325, 653,
	FONT_NEXT, 305, 659,
	FONT_NEXT, 276, 662,
	FONT_NEXT, 232, 655,
	FONT_NEXT, 192, 639,
	FONT_NEXT, 156, 613,
	FONT_NEXT, 124, 581,
	FONT_NEXT, 78, 504,
	FONT_NEXT, 65, 463,
	FONT_NEXT, 61, 425,
	FONT_NEXT, 64, 390,
	FONT_NEXT, 72, 361,
	FONT_NEXT, 102, 319,
	FONT_NEXT, 140, 296,
	FONT_NEXT, 178, 289,
	FONT_NEXT, 223, 295,
	FONT_NEXT, 264, 314,
	FONT_NEXT, 299, 343,
	FONT_NEXT, 329, 379,
	FONT_NEXT, 369, 463,
	FONT_NEXT, 384, 548,
	FONT_NEXT, 377, 593,
	FONT_NEXT, 401, 585,
	FONT_NEXT, 443, 583,
	FONT_NEXT, 478, 585,
	FONT_NEXT, 507, 592,
	FONT_NEXT, 548, 611,
	FONT_NEXT, 550, 609,
	FONT_NEXT, 201, -13,
	FONT_NEXT, 249, -13,
	FONT_END, 634, 676,
	FONT_BEGIN, 172, 326,
	FONT_NEXT, 153, 339,
	FONT_NEXT, 141, 362,
	FONT_NEXT, 137, 397,
	FONT_NEXT, 150, 468,
	FONT_NEXT, 184, 545,
	FONT_NEXT, 230, 606,
	FONT_NEXT, 255, 625,
	FONT_NEXT, 281, 632,
	FONT_NEXT, 299, 622,
	FONT_NEXT, 315, 611,
	FONT_NEXT, 350, 600,
	FONT_NEXT, 359, 553,
	FONT_NEXT, 345, 469,
	FONT_NEXT, 309, 396,
	FONT_NEXT, 257, 343,
	FONT_NEXT, 228, 328,
	FONT_END, 199, 323,
	FONT_ADVANCE, 833, 0
    },
    {
	38,
	FONT_BEGIN, 287, 596,
	FONT_NEXT, 304, 623,
	FONT_NEXT, 329, 639,
	FONT_NEXT, 359, 644,
	FONT_NEXT, 389, 637,
	FONT_NEXT, 414, 620,
	FONT_NEXT, 431, 594,
	FONT_NEXT, 438, 560,
	FONT_NEXT, 423, 504,
	FONT_NEXT, 389, 462,
	FONT_NEXT, 350, 432,
	FONT_NEXT, 321, 416,
	FONT_NEXT, 293, 483,
	FONT_END, 281, 557,
	FONT_BEGIN, 495, 426,
	FONT_NEXT, 495, 405,
	FONT_NEXT, 540, 395,
	FONT_NEXT, 554, 381,
	FONT_NEXT, 559, 359,
	FONT_NEXT, 548, 310,
	FONT_NEXT, 524, 259,
	FONT_NEXT, 494, 213,
	FONT_NEXT, 468, 178,
	FONT_NEXT, 396, 277,
	FONT_NEXT, 336, 384,
	FONT_NEXT, 387, 409,
	FONT_NEXT, 437, 444,
	FONT_NEXT, 475, 492,
	FONT_NEXT, 486, 521,
	FONT_NEXT, 491, 556,
	FONT_NEXT, 480, 606,
	FONT_NEXT, 450, 644,
	FONT_NEXT, 407, 667,
	FONT_NEXT, 355, 676,
	FONT_NEXT, 319, 672,
	FONT_NEXT, 288, 661,
	FONT_NEXT, 240, 624,
	FONT_NEXT, 211, 573,
	FONT_NEXT, 202, 519,
	FONT_NEXT, 211, 452,
	FONT_NEXT, 237, 377,
	FONT_NEXT, 199, 355,
	FONT_NEXT, 146, 320,
	FONT_NEXT, 95, 274,
	FONT_NEXT, 57, 215,
	FONT_NEXT, 42, 144,
	FONT_NEXT, 46, 99,
	FONT_NEXT, 59, 64,
	FONT_NEXT, 78, 36,
	FONT_NEXT, 101, 16,
	FONT_NEXT, 155, -7,
	FONT_NEXT, 207, -13,
	FONT_NEXT, 286, -4,
	FONT_NEXT, 347, 19,
	FONT_NEXT, 394, 49,
	FONT_NEXT, 429, 78,
	FONT_NEXT, 456, 51,
	FONT_NEXT, 494, 21,
	FONT_NEXT, 542, -3,
	FONT_NEXT, 599, -13,
	FONT_NEXT, 635, -9,
	FONT_NEXT, 667, 4,
	FONT_NEXT, 713, 42,
	FONT_NEXT, 740, 80,
	FONT_NEXT, 747, 93,
	FONT_NEXT, 750, 100,
	FONT_NEXT, 735, 111,
	FONT_NEXT, 697, 73,
	FONT_NEXT, 672, 62,
	FONT_NEXT, 639, 58,
	FONT_NEXT, 585, 70,
	FONT_NEXT, 540, 98,
	FONT_NEXT, 507, 129,
	FONT_NEXT, 491, 150,
	FONT_NEXT, 528, 200,
	FONT_NEXT, 550, 232,
	FONT_NEXT, 568, 261,
	FONT_NEXT, 591, 300,
	FONT_NEXT, 617, 346,
	FONT_NEXT, 638, 375,
	FONT_NEXT, 661, 392,
	FONT_NEXT, 711, 405,
	FONT_END, 711, 426,
	FONT_BEGIN, 146, 238,
	FONT_NEXT, 176, 283,
	FONT_NEXT, 214, 317,
	FONT_NEXT, 252, 343,
	FONT_NEXT, 322, 219,
	FONT_NEXT, 404, 104,
	FONT_NEXT, 356, 69,
	FONT_NEXT, 316, 49,
	FONT_NEXT, 285, 41,
	FONT_NEXT, 263, 39,
	FONT_NEXT, 212, 50,
	FONT_NEXT, 171, 80,
	FONT_NEXT, 144, 125,
	FONT_END, 134, 180,
	FONT_ADVANCE, 778, 0
    },
    {
	39,
	FONT_BEGIN, 136, 450,
	FONT_NEXT, 173, 483,
	FONT_NEXT, 204, 528,
	FONT_NEXT, 218, 580,
	FONT_NEXT, 208, 630,
	FONT_NEXT, 186, 659,
	FONT_NEXT, 159, 672,
	FONT_NEXT, 137, 676,
	FONT_NEXT, 98, 663,
	FONT_NEXT, 84, 645,
	FONT_NEXT, 79, 618,
	FONT_NEXT, 85, 593,
	FONT_NEXT, 100, 578,
	FONT_NEXT, 141, 568,
	FONT_NEXT, 156, 570,
	FONT_NEXT, 165, 572,
	FONT_NEXT, 174, 568,
	FONT_NEXT, 179, 558,
	FONT_NEXT, 175, 539,
	FONT_NEXT, 162, 513,
	FONT_NEXT, 137, 483,
	FONT_NEXT, 97, 452,
	FONT_END, 106, 433,
	FONT_ADVANCE, 333, 0
    },
    {
	40,
	FONT_BEGIN, 239, 638,
	FONT_NEXT, 191, 596,
	FONT_NEXT, 148, 549,
	FONT_NEXT, 113, 499,
	FONT_NEXT, 85, 444,
	FONT_NEXT, 64, 386,
	FONT_NEXT, 52, 325,
	FONT_NEXT, 48, 262,
	FONT_NEXT, 53, 169,
	FONT_NEXT, 70, 96,
	FONT_NEXT, 96, 35,
	FONT_NEXT, 130, -20,
	FONT_NEXT, 203, -108,
	FONT_NEXT, 247, -148,
	FONT_NEXT, 292, -177,
	FONT_NEXT, 304, -161,
	FONT_NEXT, 247, -116,
	FONT_NEXT, 205, -63,
	FONT_NEXT, 175, -4,
	FONT_NEXT, 155, 56,
	FONT_NEXT, 136, 174,
	FONT_NEXT, 134, 225,
	FONT_NEXT, 134, 269,
	FONT_NEXT, 138, 356,
	FONT_NEXT, 150, 428,
	FONT_NEXT, 168, 488,
	FONT_NEXT, 191, 537,
	FONT_NEXT, 246, 609,
	FONT_NEXT, 304, 660,
	FONT_END, 295, 676,
	FONT_ADVANCE, 333, 0
    },
    {
	41,
	FONT_BEGIN, 93, -140,
	FONT_NEXT, 141, -98,
	FONT_NEXT, 184, -51,
	FONT_NEXT, 219, 0,
	FONT_NEXT, 247, 54,
	FONT_NEXT, 268, 112,
	FONT_NEXT, 280, 173,
	FONT_NEXT, 285, 237,
	FONT_NEXT, 279, 329,
	FONT_NEXT, 262, 402,
	FONT_NEXT, 236, 463,
	FONT_NEXT, 203, 519,
	FONT_NEXT, 129, 606,
	FONT_NEXT, 85, 646,
	FONT_NEXT, 41, 676,
	FONT_NEXT, 29, 660,
	FONT_NEXT, 85, 614,
	FONT_NEXT, 127, 561,
	FONT_NEXT, 157, 502,
	FONT_NEXT, 177, 442,
	FONT_NEXT, 196, 324,
	FONT_NEXT, 198, 273,
	FONT_NEXT, 199, 230,
	FONT_NEXT, 194, 142,
	FONT_NEXT, 182, 70,
	FONT_NEXT, 164, 10,
	FONT_NEXT, 141, -39,
	FONT_NEXT, 86, -111,
	FONT_NEXT, 29, -161,
	FONT_END, 38, -177,
	FONT_ADVANCE, 333, 0
    },
    {
	42,
	FONT_BEGIN, 76, 362,
	FONT_NEXT, 103, 351,
	FONT_NEXT, 129, 358,
	FONT_NEXT, 143, 371,
	FONT_NEXT, 164, 394,
	FONT_NEXT, 192, 422,
	FONT_NEXT, 210, 435,
	FONT_NEXT, 240, 456,
	FONT_NEXT, 241, 449,
	FONT_NEXT, 240, 405,
	FONT_NEXT, 230, 365,
	FONT_NEXT, 219, 331,
	FONT_NEXT, 214, 304,
	FONT_NEXT, 225, 275,
	FONT_NEXT, 249, 265,
	FONT_NEXT, 277, 278,
	FONT_NEXT, 288, 307,
	FONT_NEXT, 274, 352,
	FONT_NEXT, 264, 389,
	FONT_NEXT, 260, 449,
	FONT_NEXT, 260, 456,
	FONT_NEXT, 267, 453,
	FONT_NEXT, 307, 425,
	FONT_NEXT, 338, 391,
	FONT_NEXT, 366, 362,
	FONT_NEXT, 396, 350,
	FONT_NEXT, 421, 359,
	FONT_NEXT, 432, 386,
	FONT_NEXT, 428, 404,
	FONT_NEXT, 419, 416,
	FONT_NEXT, 384, 428,
	FONT_NEXT, 334, 439,
	FONT_NEXT, 276, 465,
	FONT_NEXT, 268, 470,
	FONT_NEXT, 304, 489,
	FONT_NEXT, 336, 502,
	FONT_NEXT, 388, 513,
	FONT_NEXT, 420, 525,
	FONT_NEXT, 428, 537,
	FONT_NEXT, 431, 557,
	FONT_NEXT, 427, 574,
	FONT_NEXT, 417, 585,
	FONT_NEXT, 395, 593,
	FONT_NEXT, 368, 581,
	FONT_NEXT, 341, 554,
	FONT_NEXT, 309, 520,
	FONT_NEXT, 267, 488,
	FONT_NEXT, 260, 484,
	FONT_NEXT, 260, 510,
	FONT_NEXT, 273, 582,
	FONT_NEXT, 282, 613,
	FONT_NEXT, 287, 637,
	FONT_NEXT, 279, 661,
	FONT_NEXT, 269, 671,
	FONT_NEXT, 253, 676,
	FONT_NEXT, 231, 671,
	FONT_NEXT, 220, 659,
	FONT_NEXT, 216, 637,
	FONT_NEXT, 228, 581,
	FONT_NEXT, 237, 548,
	FONT_NEXT, 241, 499,
	FONT_NEXT, 241, 486,
	FONT_NEXT, 185, 523,
	FONT_NEXT, 152, 557,
	FONT_NEXT, 129, 581,
	FONT_NEXT, 102, 591,
	FONT_NEXT, 85, 586,
	FONT_NEXT, 75, 576,
	FONT_NEXT, 69, 557,
	FONT_NEXT, 72, 538,
	FONT_NEXT, 83, 526,
	FONT_NEXT, 120, 511,
	FONT_NEXT, 170, 500,
	FONT_NEXT, 223, 478,
	FONT_NEXT, 234, 471,
	FONT_NEXT, 172, 441,
	FONT_NEXT, 120, 428,
	FONT_NEXT, 82, 415,
	FONT_NEXT, 72, 402,
	FONT_END, 69, 383,
	FONT_ADVANCE, 500, 0
    },
    {
	43,
	FONT_BEGIN, 30, 286,
	FONT_NEXT, 30, 220,
	FONT_NEXT, 249, 220,
	FONT_NEXT, 249, 0,
	FONT_NEXT, 315, 0,
	FONT_NEXT, 315, 220,
	FONT_NEXT, 534, 220,
	FONT_NEXT, 534, 286,
	FONT_NEXT, 315, 286,
	FONT_NEXT, 315, 506,
	FONT_NEXT, 249, 506,
	FONT_END, 249, 286,
	FONT_ADVANCE, 564, 0
    },
    {
	44,
	FONT_BEGIN, 113, -124,
	FONT_NEXT, 150, -91,
	FONT_NEXT, 181, -46,
	FONT_NEXT, 195, 6,
	FONT_NEXT, 185, 56,
	FONT_NEXT, 163, 85,
	FONT_NEXT, 136, 98,
	FONT_NEXT, 114, 102,
	FONT_NEXT, 75, 89,
	FONT_NEXT, 61, 71,
	FONT_NEXT, 56, 44,
	FONT_NEXT, 62, 19,
	FONT_NEXT, 77, 4,
	FONT_NEXT, 118, -6,
	FONT_NEXT, 133, -4,
	FONT_NEXT, 142, -2,
	FONT_NEXT, 151, -6,
	FONT_NEXT, 156, -16,
	FONT_NEXT, 152, -35,
	FONT_NEXT, 139, -61,
	FONT_NEXT, 114, -91,
	FONT_NEXT, 74, -122,
	FONT_END, 83, -141,
	FONT_ADVANCE, 250, 0
    },
    {
	45,
	FONT_BEGIN, 39, 194,
	FONT_NEXT, 285, 194,
	FONT_NEXT, 285, 257,
	FONT_END, 39, 257,
	FONT_ADVANCE, 333, 0
    },
    {
	46,
	FONT_BEGIN, 160, 2,
	FONT_NEXT, 175, 18,
	FONT_NEXT, 181, 43,
	FONT_NEXT, 176, 64,
	FONT_NEXT, 164, 83,
	FONT_NEXT, 146, 95,
	FONT_NEXT, 125, 100,
	FONT_NEXT, 103, 95,
	FONT_NEXT, 86, 83,
	FONT_NEXT, 74, 65,
	FONT_NEXT, 70, 43,
	FONT_NEXT, 75, 18,
	FONT_NEXT, 89, 1,
	FONT_END, 125, -11,
	FONT_ADVANCE, 250, 0
    },
    {
	47,
	FONT_BEGIN, 220, 676,
	FONT_NEXT, -9, -14,
	FONT_NEXT, 59, -14,
	FONT_END, 287, 676,
	FONT_ADVANCE, 278, 0
    },
    {
	48,
	FONT_BEGIN, 292, 639,
	FONT_NEXT, 324, 609,
	FONT_NEXT, 347, 566,
	FONT_NEXT, 363, 516,
	FONT_NEXT, 377, 409,
	FONT_NEXT, 379, 364,
	FONT_NEXT, 380, 331,
	FONT_NEXT, 379, 294,
	FONT_NEXT, 377, 247,
	FONT_NEXT, 363, 141,
	FONT_NEXT, 347, 92,
	FONT_NEXT, 324, 50,
	FONT_NEXT, 292, 22,
	FONT_NEXT, 250, 12,
	FONT_NEXT, 207, 22,
	FONT_NEXT, 175, 50,
	FONT_NEXT, 152, 91,
	FONT_NEXT, 137, 141,
	FONT_NEXT, 122, 246,
	FONT_NEXT, 120, 294,
	FONT_NEXT, 120, 331,
	FONT_NEXT, 120, 364,
	FONT_NEXT, 122, 409,
	FONT_NEXT, 137, 516,
	FONT_NEXT, 152, 566,
	FONT_NEXT, 175, 609,
	FONT_NEXT, 207, 639,
	FONT_END, 250, 650,
	FONT_BEGIN, 187, 666,
	FONT_NEXT, 137, 638,
	FONT_NEXT, 97, 597,
	FONT_NEXT, 68, 547,
	FONT_NEXT, 33, 434,
	FONT_NEXT, 26, 379,
	FONT_NEXT, 24, 331,
	FONT_NEXT, 33, 226,
	FONT_NEXT, 68, 113,
	FONT_NEXT, 97, 63,
	FONT_NEXT, 137, 22,
	FONT_NEXT, 187, -5,
	FONT_NEXT, 250, -14,
	FONT_NEXT, 312, -5,
	FONT_NEXT, 362, 22,
	FONT_NEXT, 402, 63,
	FONT_NEXT, 432, 113,
	FONT_NEXT, 466, 226,
	FONT_NEXT, 476, 331,
	FONT_NEXT, 473, 379,
	FONT_NEXT, 466, 434,
	FONT_NEXT, 432, 547,
	FONT_NEXT, 402, 597,
	FONT_NEXT, 362, 638,
	FONT_NEXT, 312, 666,
	FONT_END, 250, 676,
	FONT_ADVANCE, 500, 0
    },
    {
	49,
	FONT_BEGIN, 394, 0,
	FONT_NEXT, 394, 15,
	FONT_NEXT, 347, 17,
	FONT_NEXT, 318, 26,
	FONT_NEXT, 303, 44,
	FONT_NEXT, 299, 74,
	FONT_NEXT, 299, 674,
	FONT_NEXT, 291, 676,
	FONT_NEXT, 111, 585,
	FONT_NEXT, 111, 571,
	FONT_NEXT, 143, 583,
	FONT_NEXT, 161, 590,
	FONT_NEXT, 179, 593,
	FONT_NEXT, 198, 588,
	FONT_NEXT, 208, 577,
	FONT_NEXT, 213, 546,
	FONT_NEXT, 213, 93,
	FONT_NEXT, 206, 49,
	FONT_NEXT, 187, 27,
	FONT_NEXT, 157, 17,
	FONT_NEXT, 118, 15,
	FONT_END, 118, 0,
	FONT_ADVANCE, 500, 0
    },
    {
	50,
	FONT_BEGIN, 462, 142,
	FONT_NEXT, 435, 105,
	FONT_NEXT, 413, 85,
	FONT_NEXT, 367, 76,
	FONT_NEXT, 128, 76,
	FONT_NEXT, 296, 252,
	FONT_NEXT, 334, 295,
	FONT_NEXT, 376, 351,
	FONT_NEXT, 410, 419,
	FONT_NEXT, 424, 496,
	FONT_NEXT, 419, 535,
	FONT_NEXT, 408, 571,
	FONT_NEXT, 367, 628,
	FONT_NEXT, 309, 663,
	FONT_NEXT, 243, 676,
	FONT_NEXT, 176, 666,
	FONT_NEXT, 115, 633,
	FONT_NEXT, 88, 606,
	FONT_NEXT, 64, 571,
	FONT_NEXT, 45, 528,
	FONT_NEXT, 31, 477,
	FONT_NEXT, 52, 472,
	FONT_NEXT, 70, 515,
	FONT_NEXT, 97, 557,
	FONT_NEXT, 137, 589,
	FONT_NEXT, 195, 602,
	FONT_NEXT, 235, 597,
	FONT_NEXT, 267, 586,
	FONT_NEXT, 310, 549,
	FONT_NEXT, 332, 502,
	FONT_NEXT, 338, 459,
	FONT_NEXT, 329, 400,
	FONT_NEXT, 305, 336,
	FONT_NEXT, 265, 270,
	FONT_NEXT, 208, 201,
	FONT_NEXT, 30, 12,
	FONT_NEXT, 30, 0,
	FONT_NEXT, 420, 0,
	FONT_END, 475, 137,
	FONT_ADVANCE, 500, 0
    },
    {
	51,
	FONT_BEGIN, 197, 330,
	FONT_NEXT, 230, 326,
	FONT_NEXT, 283, 308,
	FONT_NEXT, 321, 276,
	FONT_NEXT, 345, 239,
	FONT_NEXT, 356, 202,
	FONT_NEXT, 359, 176,
	FONT_NEXT, 351, 120,
	FONT_NEXT, 326, 70,
	FONT_NEXT, 285, 35,
	FONT_NEXT, 225, 22,
	FONT_NEXT, 184, 30,
	FONT_NEXT, 148, 50,
	FONT_NEXT, 115, 69,
	FONT_NEXT, 82, 78,
	FONT_NEXT, 56, 71,
	FONT_NEXT, 46, 60,
	FONT_NEXT, 43, 43,
	FONT_NEXT, 56, 12,
	FONT_NEXT, 89, -5,
	FONT_NEXT, 126, -13,
	FONT_NEXT, 154, -14,
	FONT_NEXT, 210, -10,
	FONT_NEXT, 263, 1,
	FONT_NEXT, 310, 21,
	FONT_NEXT, 351, 47,
	FONT_NEXT, 384, 80,
	FONT_NEXT, 409, 120,
	FONT_NEXT, 425, 165,
	FONT_NEXT, 431, 216,
	FONT_NEXT, 427, 261,
	FONT_NEXT, 417, 298,
	FONT_NEXT, 383, 351,
	FONT_NEXT, 341, 383,
	FONT_NEXT, 304, 401,
	FONT_NEXT, 346, 433,
	FONT_NEXT, 375, 466,
	FONT_NEXT, 391, 502,
	FONT_NEXT, 397, 541,
	FONT_NEXT, 390, 579,
	FONT_NEXT, 367, 623,
	FONT_NEXT, 319, 660,
	FONT_NEXT, 284, 671,
	FONT_NEXT, 241, 676,
	FONT_NEXT, 187, 669,
	FONT_NEXT, 132, 644,
	FONT_NEXT, 83, 594,
	FONT_NEXT, 62, 558,
	FONT_NEXT, 45, 514,
	FONT_NEXT, 60, 510,
	FONT_NEXT, 76, 538,
	FONT_NEXT, 105, 573,
	FONT_NEXT, 148, 603,
	FONT_NEXT, 208, 616,
	FONT_NEXT, 256, 606,
	FONT_NEXT, 290, 583,
	FONT_NEXT, 311, 549,
	FONT_NEXT, 318, 512,
	FONT_NEXT, 304, 450,
	FONT_NEXT, 269, 403,
	FONT_NEXT, 216, 368,
	FONT_NEXT, 152, 343,
	FONT_END, 153, 330,
	FONT_ADVANCE, 500, 0
    },
    {
	52,
	FONT_BEGIN, 370, 231,
	FONT_NEXT, 370, 676,
	FONT_NEXT, 326, 676,
	FONT_NEXT, 12, 231,
	FONT_NEXT, 12, 167,
	FONT_NEXT, 293, 167,
	FONT_NEXT, 293, 0,
	FONT_NEXT, 370, 0,
	FONT_NEXT, 370, 167,
	FONT_NEXT, 472, 167,
	FONT_END, 472, 231,
	FONT_BEGIN, 52, 231,
	FONT_NEXT, 290, 571,
	FONT_NEXT, 292, 571,
	FONT_END, 292, 231,
	FONT_ADVANCE, 500, 0
    },
    {
	53,
	FONT_BEGIN, 377, 583,
	FONT_NEXT, 391, 584,
	FONT_NEXT, 400, 592,
	FONT_NEXT, 438, 681,
	FONT_NEXT, 429, 688,
	FONT_NEXT, 411, 669,
	FONT_NEXT, 383, 662,
	FONT_NEXT, 174, 662,
	FONT_NEXT, 65, 425,
	FONT_NEXT, 64, 415,
	FONT_NEXT, 71, 412,
	FONT_NEXT, 161, 399,
	FONT_NEXT, 254, 365,
	FONT_NEXT, 294, 337,
	FONT_NEXT, 326, 300,
	FONT_NEXT, 348, 255,
	FONT_NEXT, 356, 201,
	FONT_NEXT, 352, 158,
	FONT_NEXT, 343, 121,
	FONT_NEXT, 310, 66,
	FONT_NEXT, 266, 33,
	FONT_NEXT, 217, 23,
	FONT_NEXT, 72, 85,
	FONT_NEXT, 48, 80,
	FONT_NEXT, 37, 69,
	FONT_NEXT, 32, 46,
	FONT_NEXT, 40, 21,
	FONT_NEXT, 65, 2,
	FONT_NEXT, 104, -10,
	FONT_NEXT, 158, -14,
	FONT_NEXT, 214, -10,
	FONT_NEXT, 266, 4,
	FONT_NEXT, 312, 26,
	FONT_NEXT, 351, 55,
	FONT_NEXT, 382, 90,
	FONT_NEXT, 406, 131,
	FONT_NEXT, 420, 176,
	FONT_NEXT, 426, 225,
	FONT_NEXT, 423, 281,
	FONT_NEXT, 415, 323,
	FONT_NEXT, 398, 359,
	FONT_NEXT, 372, 395,
	FONT_NEXT, 321, 439,
	FONT_NEXT, 263, 468,
	FONT_NEXT, 139, 498,
	FONT_END, 181, 583,
	FONT_ADVANCE, 500, 0
    },
    {
	54,
	FONT_BEGIN, 358, 673,
	FONT_NEXT, 279, 647,
	FONT_NEXT, 209, 609,
	FONT_NEXT, 149, 560,
	FONT_NEXT, 100, 502,
	FONT_NEXT, 64, 436,
	FONT_NEXT, 41, 365,
	FONT_NEXT, 34, 291,
	FONT_NEXT, 38, 217,
	FONT_NEXT, 51, 154,
	FONT_NEXT, 72, 102,
	FONT_NEXT, 99, 59,
	FONT_NEXT, 132, 27,
	FONT_NEXT, 169, 4,
	FONT_NEXT, 210, -10,
	FONT_NEXT, 254, -14,
	FONT_NEXT, 314, -8,
	FONT_NEXT, 362, 11,
	FONT_NEXT, 399, 40,
	FONT_NEXT, 427, 74,
	FONT_NEXT, 459, 150,
	FONT_NEXT, 468, 218,
	FONT_NEXT, 464, 265,
	FONT_NEXT, 454, 307,
	FONT_NEXT, 437, 343,
	FONT_NEXT, 415, 373,
	FONT_NEXT, 357, 414,
	FONT_NEXT, 284, 428,
	FONT_NEXT, 247, 425,
	FONT_NEXT, 217, 417,
	FONT_NEXT, 187, 403,
	FONT_NEXT, 152, 383,
	FONT_NEXT, 181, 475,
	FONT_NEXT, 207, 519,
	FONT_NEXT, 240, 560,
	FONT_NEXT, 281, 597,
	FONT_NEXT, 329, 628,
	FONT_NEXT, 384, 652,
	FONT_NEXT, 448, 668,
	FONT_END, 446, 684,
	FONT_BEGIN, 278, 377,
	FONT_NEXT, 307, 364,
	FONT_NEXT, 331, 344,
	FONT_NEXT, 349, 319,
	FONT_NEXT, 371, 254,
	FONT_NEXT, 378, 179,
	FONT_NEXT, 369, 105,
	FONT_NEXT, 347, 54,
	FONT_NEXT, 312, 23,
	FONT_NEXT, 269, 14,
	FONT_NEXT, 215, 28,
	FONT_NEXT, 191, 46,
	FONT_NEXT, 169, 72,
	FONT_NEXT, 152, 105,
	FONT_NEXT, 138, 147,
	FONT_NEXT, 130, 197,
	FONT_NEXT, 127, 256,
	FONT_NEXT, 128, 294,
	FONT_NEXT, 133, 321,
	FONT_NEXT, 147, 350,
	FONT_NEXT, 191, 375,
	FONT_END, 242, 382,
	FONT_ADVANCE, 500, 0
    },
    {
	55,
	FONT_BEGIN, 79, 662,
	FONT_NEXT, 63, 618,
	FONT_NEXT, 20, 515,
	FONT_NEXT, 37, 507,
	FONT_NEXT, 59, 541,
	FONT_NEXT, 83, 567,
	FONT_NEXT, 112, 582,
	FONT_NEXT, 153, 588,
	FONT_NEXT, 370, 588,
	FONT_NEXT, 172, -8,
	FONT_NEXT, 237, -8,
	FONT_NEXT, 449, 646,
	FONT_END, 449, 662,
	FONT_ADVANCE, 500, 0
    },
    {
	56,
	FONT_BEGIN, 285, 258,
	FONT_NEXT, 333, 216,
	FONT_NEXT, 360, 174,
	FONT_NEXT, 369, 126,
	FONT_NEXT, 360, 78,
	FONT_NEXT, 337, 43,
	FONT_NEXT, 302, 21,
	FONT_NEXT, 259, 14,
	FONT_NEXT, 204, 25,
	FONT_NEXT, 165, 56,
	FONT_NEXT, 140, 101,
	FONT_NEXT, 132, 156,
	FONT_NEXT, 140, 215,
	FONT_NEXT, 160, 258,
	FONT_NEXT, 186, 289,
	FONT_END, 212, 312,
	FONT_BEGIN, 68, 88,
	FONT_NEXT, 104, 36,
	FONT_NEXT, 164, 0,
	FONT_NEXT, 202, -11,
	FONT_NEXT, 246, -14,
	FONT_NEXT, 302, -10,
	FONT_NEXT, 347, 4,
	FONT_NEXT, 381, 24,
	FONT_NEXT, 407, 48,
	FONT_NEXT, 437, 102,
	FONT_NEXT, 445, 150,
	FONT_NEXT, 439, 199,
	FONT_NEXT, 417, 249,
	FONT_NEXT, 370, 305,
	FONT_NEXT, 335, 336,
	FONT_NEXT, 290, 371,
	FONT_NEXT, 333, 395,
	FONT_NEXT, 377, 428,
	FONT_NEXT, 410, 473,
	FONT_NEXT, 424, 534,
	FONT_NEXT, 412, 588,
	FONT_NEXT, 378, 633,
	FONT_NEXT, 324, 664,
	FONT_NEXT, 249, 676,
	FONT_NEXT, 183, 665,
	FONT_NEXT, 123, 636,
	FONT_NEXT, 79, 587,
	FONT_NEXT, 66, 556,
	FONT_NEXT, 62, 521,
	FONT_NEXT, 69, 467,
	FONT_NEXT, 92, 423,
	FONT_NEXT, 131, 381,
	FONT_NEXT, 186, 332,
	FONT_NEXT, 128, 286,
	FONT_NEXT, 87, 246,
	FONT_NEXT, 63, 202,
	FONT_END, 56, 146,
	FONT_BEGIN, 142, 583,
	FONT_NEXT, 161, 615,
	FONT_NEXT, 194, 638,
	FONT_NEXT, 243, 648,
	FONT_NEXT, 292, 638,
	FONT_NEXT, 327, 614,
	FONT_NEXT, 348, 579,
	FONT_NEXT, 355, 539,
	FONT_NEXT, 345, 481,
	FONT_NEXT, 322, 440,
	FONT_NEXT, 291, 410,
	FONT_NEXT, 261, 389,
	FONT_NEXT, 226, 412,
	FONT_NEXT, 185, 447,
	FONT_NEXT, 150, 492,
	FONT_END, 136, 547,
	FONT_ADVANCE, 500, 0
    },
    {
	57,
	FONT_BEGIN, 149, -9,
	FONT_NEXT, 228, 20,
	FONT_NEXT, 297, 61,
	FONT_NEXT, 354, 113,
	FONT_NEXT, 399, 174,
	FONT_NEXT, 432, 243,
	FONT_NEXT, 452, 317,
	FONT_NEXT, 459, 396,
	FONT_NEXT, 454, 455,
	FONT_NEXT, 442, 510,
	FONT_NEXT, 422, 557,
	FONT_NEXT, 395, 598,
	FONT_NEXT, 363, 631,
	FONT_NEXT, 326, 655,
	FONT_NEXT, 284, 670,
	FONT_NEXT, 240, 676,
	FONT_NEXT, 193, 671,
	FONT_NEXT, 152, 657,
	FONT_NEXT, 116, 634,
	FONT_NEXT, 86, 605,
	FONT_NEXT, 62, 569,
	FONT_NEXT, 44, 528,
	FONT_NEXT, 30, 435,
	FONT_NEXT, 39, 369,
	FONT_NEXT, 69, 305,
	FONT_NEXT, 94, 278,
	FONT_NEXT, 125, 256,
	FONT_NEXT, 163, 242,
	FONT_NEXT, 210, 237,
	FONT_NEXT, 285, 250,
	FONT_NEXT, 357, 292,
	FONT_NEXT, 359, 290,
	FONT_NEXT, 354, 271,
	FONT_NEXT, 343, 239,
	FONT_NEXT, 324, 197,
	FONT_NEXT, 296, 149,
	FONT_NEXT, 256, 101,
	FONT_NEXT, 204, 56,
	FONT_NEXT, 138, 21,
	FONT_NEXT, 56, -2,
	FONT_END, 59, -22,
	FONT_BEGIN, 358, 332,
	FONT_NEXT, 346, 315,
	FONT_NEXT, 302, 291,
	FONT_NEXT, 250, 280,
	FONT_NEXT, 214, 285,
	FONT_NEXT, 185, 299,
	FONT_NEXT, 146, 348,
	FONT_NEXT, 127, 410,
	FONT_NEXT, 122, 473,
	FONT_NEXT, 126, 534,
	FONT_NEXT, 144, 591,
	FONT_NEXT, 176, 632,
	FONT_NEXT, 200, 643,
	FONT_NEXT, 229, 648,
	FONT_NEXT, 272, 639,
	FONT_NEXT, 305, 616,
	FONT_NEXT, 329, 583,
	FONT_NEXT, 345, 543,
	FONT_NEXT, 359, 458,
	FONT_NEXT, 361, 421,
	FONT_NEXT, 362, 394,
	FONT_END, 362, 355,
	FONT_ADVANCE, 500, 0
    },
    {
	58,
	FONT_BEGIN, 171, 361,
	FONT_NEXT, 186, 377,
	FONT_NEXT, 192, 402,
	FONT_NEXT, 187, 423,
	FONT_NEXT, 175, 442,
	FONT_NEXT, 157, 454,
	FONT_NEXT, 136, 459,
	FONT_NEXT, 114, 454,
	FONT_NEXT, 97, 442,
	FONT_NEXT, 85, 424,
	FONT_NEXT, 81, 402,
	FONT_NEXT, 86, 377,
	FONT_NEXT, 100, 360,
	FONT_END, 136, 348,
	FONT_BEGIN, 171, 2,
	FONT_NEXT, 186, 18,
	FONT_NEXT, 192, 43,
	FONT_NEXT, 187, 64,
	FONT_NEXT, 175, 83,
	FONT_NEXT, 157, 95,
	FONT_NEXT, 136, 100,
	FONT_NEXT, 114, 95,
	FONT_NEXT, 97, 83,
	FONT_NEXT, 85, 65,
	FONT_NEXT, 81, 43,
	FONT_NEXT, 86, 18,
	FONT_NEXT, 100, 1,
	FONT_END, 136, -11,
	FONT_ADVANCE, 278, 0
    },
    {
	59,
	FONT_BEGIN, 138, -123,
	FONT_NEXT, 175, -90,
	FONT_NEXT, 206, -45,
	FONT_NEXT, 219, 6,
	FONT_NEXT, 209, 56,
	FONT_NEXT, 186, 85,
	FONT_NEXT, 160, 98,
	FONT_NEXT, 139, 102,
	FONT_NEXT, 125, 100,
	FONT_NEXT, 105, 93,
	FONT_NEXT, 87, 76,
	FONT_NEXT, 80, 44,
	FONT_NEXT, 85, 20,
	FONT_NEXT, 99, 5,
	FONT_NEXT, 142, -6,
	FONT_NEXT, 157, -4,
	FONT_NEXT, 166, -2,
	FONT_NEXT, 175, -6,
	FONT_NEXT, 180, -16,
	FONT_NEXT, 176, -35,
	FONT_NEXT, 163, -61,
	FONT_NEXT, 138, -91,
	FONT_NEXT, 98, -122,
	FONT_END, 107, -141,
	FONT_BEGIN, 171, 361,
	FONT_NEXT, 186, 377,
	FONT_NEXT, 192, 402,
	FONT_NEXT, 187, 423,
	FONT_NEXT, 175, 442,
	FONT_NEXT, 157, 454,
	FONT_NEXT, 136, 459,
	FONT_NEXT, 114, 454,
	FONT_NEXT, 97, 442,
	FONT_NEXT, 85, 424,
	FONT_NEXT, 81, 402,
	FONT_NEXT, 86, 377,
	FONT_NEXT, 100, 360,
	FONT_END, 136, 348,
	FONT_ADVANCE, 278, 0
    },
    {
	60,
	FONT_BEGIN, 111, 253,
	FONT_NEXT, 536, 446,
	FONT_NEXT, 536, 514,
	FONT_NEXT, 28, 284,
	FONT_NEXT, 28, 222,
	FONT_NEXT, 536, -8,
	FONT_END, 536, 60,
	FONT_ADVANCE, 564, 0
    },
    {
	61,
	FONT_BEGIN, 30, 386,
	FONT_NEXT, 30, 320,
	FONT_NEXT, 534, 320,
	FONT_END, 534, 386,
	FONT_BEGIN, 30, 186,
	FONT_NEXT, 30, 120,
	FONT_NEXT, 534, 120,
	FONT_END, 534, 186,
	FONT_ADVANCE, 564, 0
    },
    {
	62,
	FONT_BEGIN, 28, -8,
	FONT_NEXT, 536, 222,
	FONT_NEXT, 536, 284,
	FONT_NEXT, 28, 514,
	FONT_NEXT, 28, 446,
	FONT_NEXT, 453, 253,
	FONT_END, 28, 60,
	FONT_ADVANCE, 564, 0
    },
    {
	63,
	FONT_BEGIN, 257, 220,
	FONT_NEXT, 276, 267,
	FONT_NEXT, 302, 309,
	FONT_NEXT, 339, 354,
	FONT_NEXT, 363, 385,
	FONT_NEXT, 387, 426,
	FONT_NEXT, 406, 469,
	FONT_NEXT, 414, 510,
	FONT_NEXT, 412, 544,
	FONT_NEXT, 406, 571,
	FONT_NEXT, 378, 618,
	FONT_NEXT, 352, 639,
	FONT_NEXT, 316, 657,
	FONT_NEXT, 274, 671,
	FONT_NEXT, 231, 676,
	FONT_NEXT, 176, 667,
	FONT_NEXT, 123, 641,
	FONT_NEXT, 83, 597,
	FONT_NEXT, 72, 567,
	FONT_NEXT, 68, 532,
	FONT_NEXT, 78, 487,
	FONT_NEXT, 93, 474,
	FONT_NEXT, 118, 469,
	FONT_NEXT, 135, 473,
	FONT_NEXT, 148, 483,
	FONT_NEXT, 157, 510,
	FONT_NEXT, 119, 585,
	FONT_NEXT, 127, 608,
	FONT_NEXT, 149, 627,
	FONT_NEXT, 179, 641,
	FONT_NEXT, 212, 646,
	FONT_NEXT, 261, 634,
	FONT_NEXT, 295, 605,
	FONT_NEXT, 315, 564,
	FONT_NEXT, 322, 519,
	FONT_NEXT, 310, 444,
	FONT_NEXT, 285, 370,
	FONT_NEXT, 257, 306,
	FONT_NEXT, 249, 286,
	FONT_NEXT, 239, 251,
	FONT_NEXT, 227, 164,
	FONT_END, 244, 164,
	FONT_BEGIN, 273, 4,
	FONT_NEXT, 286, 19,
	FONT_NEXT, 292, 43,
	FONT_NEXT, 287, 63,
	FONT_NEXT, 276, 80,
	FONT_NEXT, 258, 92,
	FONT_NEXT, 237, 97,
	FONT_NEXT, 216, 92,
	FONT_NEXT, 199, 81,
	FONT_NEXT, 188, 64,
	FONT_NEXT, 184, 43,
	FONT_NEXT, 189, 19,
	FONT_NEXT, 202, 3,
	FONT_END, 237, -8,
	FONT_ADVANCE, 444, 0
    },
    {
	64,
	FONT_BEGIN, 554, 306,
	FONT_NEXT, 524, 240,
	FONT_NEXT, 489, 200,
	FONT_NEXT, 455, 187,
	FONT_NEXT, 430, 191,
	FONT_NEXT, 410, 206,
	FONT_NEXT, 396, 232,
	FONT_NEXT, 392, 271,
	FONT_NEXT, 395, 314,
	FONT_NEXT, 406, 352,
	FONT_NEXT, 442, 412,
	FONT_NEXT, 487, 450,
	FONT_NEXT, 529, 464,
	FONT_NEXT, 548, 459,
	FONT_NEXT, 561, 447,
	FONT_NEXT, 569, 426,
	FONT_END, 572, 399,
	FONT_BEGIN, 601, 39,
	FONT_NEXT, 550, 28,
	FONT_NEXT, 490, 25,
	FONT_NEXT, 427, 31,
	FONT_NEXT, 371, 48,
	FONT_NEXT, 321, 75,
	FONT_NEXT, 279, 111,
	FONT_NEXT, 245, 153,
	FONT_NEXT, 220, 200,
	FONT_NEXT, 205, 251,
	FONT_NEXT, 200, 305,
	FONT_NEXT, 205, 383,
	FONT_NEXT, 222, 451,
	FONT_NEXT, 248, 510,
	FONT_NEXT, 283, 558,
	FONT_NEXT, 324, 595,
	FONT_NEXT, 372, 623,
	FONT_NEXT, 424, 639,
	FONT_NEXT, 481, 645,
	FONT_NEXT, 545, 638,
	FONT_NEXT, 603, 619,
	FONT_NEXT, 652, 591,
	FONT_NEXT, 693, 555,
	FONT_NEXT, 726, 513,
	FONT_NEXT, 749, 469,
	FONT_NEXT, 764, 424,
	FONT_NEXT, 769, 380,
	FONT_NEXT, 760, 311,
	FONT_NEXT, 734, 245,
	FONT_NEXT, 693, 195,
	FONT_NEXT, 667, 181,
	FONT_NEXT, 639, 176,
	FONT_NEXT, 613, 183,
	FONT_NEXT, 603, 202,
	FONT_NEXT, 603, 240,
	FONT_NEXT, 668, 494,
	FONT_NEXT, 599, 494,
	FONT_NEXT, 589, 456,
	FONT_NEXT, 565, 491,
	FONT_NEXT, 546, 503,
	FONT_NEXT, 518, 508,
	FONT_NEXT, 470, 500,
	FONT_NEXT, 430, 480,
	FONT_NEXT, 396, 450,
	FONT_NEXT, 368, 414,
	FONT_NEXT, 332, 335,
	FONT_NEXT, 323, 298,
	FONT_NEXT, 321, 268,
	FONT_NEXT, 323, 230,
	FONT_NEXT, 332, 200,
	FONT_NEXT, 358, 163,
	FONT_NEXT, 390, 147,
	FONT_NEXT, 417, 144,
	FONT_NEXT, 457, 154,
	FONT_NEXT, 492, 174,
	FONT_NEXT, 517, 196,
	FONT_NEXT, 532, 214,
	FONT_NEXT, 534, 214,
	FONT_NEXT, 538, 197,
	FONT_NEXT, 553, 173,
	FONT_NEXT, 581, 152,
	FONT_NEXT, 623, 143,
	FONT_NEXT, 665, 149,
	FONT_NEXT, 702, 165,
	FONT_NEXT, 734, 191,
	FONT_NEXT, 760, 223,
	FONT_NEXT, 796, 300,
	FONT_NEXT, 809, 381,
	FONT_NEXT, 802, 442,
	FONT_NEXT, 783, 498,
	FONT_NEXT, 753, 548,
	FONT_NEXT, 714, 591,
	FONT_NEXT, 665, 627,
	FONT_NEXT, 609, 653,
	FONT_NEXT, 547, 670,
	FONT_NEXT, 481, 676,
	FONT_NEXT, 408, 669,
	FONT_NEXT, 340, 649,
	FONT_NEXT, 278, 618,
	FONT_NEXT, 224, 576,
	FONT_NEXT, 179, 524,
	FONT_NEXT, 145, 462,
	FONT_NEXT, 123, 392,
	FONT_NEXT, 116, 315,
	FONT_NEXT, 121, 262,
	FONT_NEXT, 137, 207,
	FONT_NEXT, 165, 152,
	FONT_NEXT, 205, 100,
	FONT_NEXT, 257, 54,
	FONT_NEXT, 322, 18,
	FONT_NEXT, 399, -6,
	FONT_NEXT, 491, -14,
	FONT_NEXT, 547, -10,
	FONT_NEXT, 601, 3,
	FONT_NEXT, 700, 43,
	FONT_END, 688, 73,
	FONT_ADVANCE, 921, 0
    },
    {
	65,
	FONT_BEGIN, 677, 23,
	FONT_NEXT, 656, 36,
	FONT_NEXT, 637, 62,
	FONT_NEXT, 616, 106,
	FONT_NEXT, 367, 674,
	FONT_NEXT, 347, 674,
	FONT_NEXT, 139, 183,
	FONT_NEXT, 104, 104,
	FONT_NEXT, 84, 67,
	FONT_NEXT, 66, 41,
	FONT_NEXT, 39, 23,
	FONT_NEXT, 15, 19,
	FONT_NEXT, 15, 0,
	FONT_NEXT, 213, 0,
	FONT_NEXT, 213, 19,
	FONT_NEXT, 171, 24,
	FONT_NEXT, 152, 36,
	FONT_NEXT, 145, 61,
	FONT_NEXT, 153, 99,
	FONT_NEXT, 199, 216,
	FONT_NEXT, 461, 216,
	FONT_NEXT, 502, 120,
	FONT_NEXT, 521, 57,
	FONT_NEXT, 515, 35,
	FONT_NEXT, 499, 24,
	FONT_NEXT, 451, 19,
	FONT_NEXT, 451, 0,
	FONT_NEXT, 706, 0,
	FONT_END, 706, 19,
	FONT_BEGIN, 331, 532,
	FONT_NEXT, 447, 257,
	FONT_END, 216, 257,
	FONT_ADVANCE, 722, 0
    },
    {
	66,
	FONT_BEGIN, 66, 637,
	FONT_NEXT, 95, 624,
	FONT_NEXT, 109, 597,
	FONT_NEXT, 113, 553,
	FONT_NEXT, 113, 109,
	FONT_NEXT, 109, 65,
	FONT_NEXT, 96, 38,
	FONT_NEXT, 67, 23,
	FONT_NEXT, 17, 19,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 351, 0,
	FONT_NEXT, 425, 6,
	FONT_NEXT, 482, 22,
	FONT_NEXT, 525, 45,
	FONT_NEXT, 555, 73,
	FONT_NEXT, 574, 103,
	FONT_NEXT, 586, 132,
	FONT_NEXT, 593, 176,
	FONT_NEXT, 589, 212,
	FONT_NEXT, 579, 244,
	FONT_NEXT, 542, 294,
	FONT_NEXT, 488, 327,
	FONT_NEXT, 426, 347,
	FONT_NEXT, 426, 349,
	FONT_NEXT, 465, 360,
	FONT_NEXT, 509, 383,
	FONT_NEXT, 544, 425,
	FONT_NEXT, 555, 455,
	FONT_NEXT, 559, 493,
	FONT_NEXT, 551, 544,
	FONT_NEXT, 530, 584,
	FONT_NEXT, 499, 614,
	FONT_NEXT, 460, 635,
	FONT_NEXT, 374, 657,
	FONT_NEXT, 297, 662,
	FONT_NEXT, 17, 662,
	FONT_END, 17, 643,
	FONT_BEGIN, 276, 325,
	FONT_NEXT, 319, 322,
	FONT_NEXT, 377, 311,
	FONT_NEXT, 414, 295,
	FONT_NEXT, 447, 270,
	FONT_NEXT, 469, 232,
	FONT_NEXT, 478, 180,
	FONT_NEXT, 472, 135,
	FONT_NEXT, 458, 101,
	FONT_NEXT, 436, 75,
	FONT_NEXT, 409, 58,
	FONT_NEXT, 348, 40,
	FONT_NEXT, 291, 37,
	FONT_NEXT, 254, 38,
	FONT_NEXT, 231, 43,
	FONT_NEXT, 218, 55,
	FONT_NEXT, 215, 78,
	FONT_END, 215, 326,
	FONT_BEGIN, 218, 615,
	FONT_NEXT, 237, 624,
	FONT_NEXT, 255, 624,
	FONT_NEXT, 282, 625,
	FONT_NEXT, 339, 620,
	FONT_NEXT, 396, 600,
	FONT_NEXT, 420, 582,
	FONT_NEXT, 439, 558,
	FONT_NEXT, 452, 527,
	FONT_NEXT, 457, 487,
	FONT_NEXT, 451, 447,
	FONT_NEXT, 437, 417,
	FONT_NEXT, 394, 381,
	FONT_NEXT, 344, 368,
	FONT_NEXT, 310, 366,
	FONT_NEXT, 215, 365,
	FONT_END, 215, 595,
	FONT_ADVANCE, 667, 0
    },
    {
	67,
	FONT_BEGIN, 611, 676,
	FONT_NEXT, 590, 676,
	FONT_NEXT, 580, 656,
	FONT_NEXT, 565, 647,
	FONT_NEXT, 544, 643,
	FONT_NEXT, 519, 648,
	FONT_NEXT, 481, 659,
	FONT_NEXT, 429, 670,
	FONT_NEXT, 368, 676,
	FONT_NEXT, 304, 670,
	FONT_NEXT, 242, 653,
	FONT_NEXT, 184, 625,
	FONT_NEXT, 133, 587,
	FONT_NEXT, 90, 538,
	FONT_NEXT, 56, 479,
	FONT_NEXT, 35, 410,
	FONT_NEXT, 28, 331,
	FONT_NEXT, 35, 244,
	FONT_NEXT, 57, 172,
	FONT_NEXT, 91, 112,
	FONT_NEXT, 134, 65,
	FONT_NEXT, 185, 29,
	FONT_NEXT, 241, 4,
	FONT_NEXT, 301, -10,
	FONT_NEXT, 362, -14,
	FONT_NEXT, 426, -9,
	FONT_NEXT, 481, 5,
	FONT_NEXT, 528, 25,
	FONT_NEXT, 566, 48,
	FONT_NEXT, 595, 71,
	FONT_NEXT, 616, 92,
	FONT_NEXT, 628, 106,
	FONT_NEXT, 633, 113,
	FONT_NEXT, 615, 131,
	FONT_NEXT, 583, 102,
	FONT_NEXT, 536, 69,
	FONT_NEXT, 471, 41,
	FONT_NEXT, 389, 30,
	FONT_NEXT, 342, 34,
	FONT_NEXT, 297, 46,
	FONT_NEXT, 256, 68,
	FONT_NEXT, 219, 100,
	FONT_NEXT, 188, 141,
	FONT_NEXT, 164, 192,
	FONT_NEXT, 149, 255,
	FONT_NEXT, 144, 329,
	FONT_NEXT, 151, 422,
	FONT_NEXT, 170, 491,
	FONT_NEXT, 197, 540,
	FONT_NEXT, 227, 575,
	FONT_NEXT, 261, 601,
	FONT_NEXT, 299, 620,
	FONT_NEXT, 377, 636,
	FONT_NEXT, 420, 632,
	FONT_NEXT, 459, 621,
	FONT_NEXT, 523, 582,
	FONT_NEXT, 569, 524,
	FONT_NEXT, 597, 451,
	FONT_END, 620, 451,
	FONT_ADVANCE, 667, 0
    },
    {
	68,
	FONT_BEGIN, 300, 0,
	FONT_NEXT, 404, 8,
	FONT_NEXT, 489, 32,
	FONT_NEXT, 556, 69,
	FONT_NEXT, 607, 114,
	FONT_NEXT, 643, 166,
	FONT_NEXT, 667, 221,
	FONT_NEXT, 681, 276,
	FONT_NEXT, 685, 329,
	FONT_NEXT, 677, 407,
	FONT_NEXT, 656, 475,
	FONT_NEXT, 622, 532,
	FONT_NEXT, 575, 579,
	FONT_NEXT, 517, 615,
	FONT_NEXT, 449, 641,
	FONT_NEXT, 372, 656,
	FONT_NEXT, 286, 662,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 16, 643,
	FONT_NEXT, 62, 636,
	FONT_NEXT, 88, 623,
	FONT_NEXT, 101, 597,
	FONT_NEXT, 104, 553,
	FONT_NEXT, 104, 109,
	FONT_NEXT, 100, 65,
	FONT_NEXT, 88, 39,
	FONT_NEXT, 61, 24,
	FONT_NEXT, 16, 19,
	FONT_END, 16, 0,
	FONT_BEGIN, 211, 613,
	FONT_NEXT, 225, 621,
	FONT_NEXT, 253, 625,
	FONT_NEXT, 335, 620,
	FONT_NEXT, 397, 606,
	FONT_NEXT, 444, 584,
	FONT_NEXT, 483, 555,
	FONT_NEXT, 526, 505,
	FONT_NEXT, 555, 449,
	FONT_NEXT, 571, 390,
	FONT_NEXT, 576, 328,
	FONT_NEXT, 573, 276,
	FONT_NEXT, 565, 231,
	FONT_NEXT, 536, 159,
	FONT_NEXT, 494, 108,
	FONT_NEXT, 445, 73,
	FONT_NEXT, 392, 52,
	FONT_NEXT, 341, 41,
	FONT_NEXT, 297, 37,
	FONT_NEXT, 266, 37,
	FONT_NEXT, 236, 38,
	FONT_NEXT, 218, 44,
	FONT_NEXT, 208, 57,
	FONT_NEXT, 206, 78,
	FONT_END, 206, 586,
	FONT_ADVANCE, 722, 0
    },
    {
	69,
	FONT_BEGIN, 569, 169,
	FONT_NEXT, 533, 105,
	FONT_NEXT, 489, 65,
	FONT_NEXT, 430, 44,
	FONT_NEXT, 350, 38,
	FONT_NEXT, 300, 38,
	FONT_NEXT, 263, 38,
	FONT_NEXT, 237, 40,
	FONT_NEXT, 219, 43,
	FONT_NEXT, 203, 56,
	FONT_NEXT, 201, 80,
	FONT_NEXT, 201, 328,
	FONT_NEXT, 355, 326,
	FONT_NEXT, 405, 321,
	FONT_NEXT, 436, 308,
	FONT_NEXT, 454, 279,
	FONT_NEXT, 465, 231,
	FONT_NEXT, 488, 231,
	FONT_NEXT, 488, 463,
	FONT_NEXT, 465, 463,
	FONT_NEXT, 455, 418,
	FONT_NEXT, 439, 388,
	FONT_NEXT, 408, 372,
	FONT_NEXT, 355, 368,
	FONT_NEXT, 201, 368,
	FONT_NEXT, 201, 590,
	FONT_NEXT, 203, 609,
	FONT_NEXT, 209, 619,
	FONT_NEXT, 234, 624,
	FONT_NEXT, 369, 624,
	FONT_NEXT, 437, 620,
	FONT_NEXT, 481, 604,
	FONT_NEXT, 506, 572,
	FONT_NEXT, 521, 519,
	FONT_NEXT, 546, 519,
	FONT_NEXT, 543, 662,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 12, 643,
	FONT_NEXT, 52, 637,
	FONT_NEXT, 79, 625,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 99, 553,
	FONT_NEXT, 99, 109,
	FONT_NEXT, 94, 63,
	FONT_NEXT, 79, 36,
	FONT_NEXT, 52, 23,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 552, 0,
	FONT_END, 597, 169,
	FONT_ADVANCE, 611, 0
    },
    {
	70,
	FONT_BEGIN, 479, 463,
	FONT_NEXT, 456, 463,
	FONT_NEXT, 446, 416,
	FONT_NEXT, 428, 387,
	FONT_NEXT, 396, 372,
	FONT_NEXT, 346, 368,
	FONT_NEXT, 201, 368,
	FONT_NEXT, 201, 590,
	FONT_NEXT, 202, 607,
	FONT_NEXT, 207, 618,
	FONT_NEXT, 233, 624,
	FONT_NEXT, 369, 624,
	FONT_NEXT, 437, 620,
	FONT_NEXT, 481, 604,
	FONT_NEXT, 506, 572,
	FONT_NEXT, 521, 519,
	FONT_NEXT, 546, 519,
	FONT_NEXT, 543, 662,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 12, 643,
	FONT_NEXT, 52, 637,
	FONT_NEXT, 79, 625,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 99, 553,
	FONT_NEXT, 99, 120,
	FONT_NEXT, 95, 70,
	FONT_NEXT, 83, 40,
	FONT_NEXT, 57, 24,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 292, 0,
	FONT_NEXT, 292, 19,
	FONT_NEXT, 247, 23,
	FONT_NEXT, 219, 37,
	FONT_NEXT, 205, 63,
	FONT_NEXT, 201, 109,
	FONT_NEXT, 201, 328,
	FONT_NEXT, 346, 326,
	FONT_NEXT, 393, 322,
	FONT_NEXT, 425, 309,
	FONT_NEXT, 444, 281,
	FONT_NEXT, 456, 231,
	FONT_END, 479, 231,
	FONT_ADVANCE, 556, 0
    },
    {
	71,
	FONT_BEGIN, 454, 354,
	FONT_NEXT, 454, 336,
	FONT_NEXT, 496, 331,
	FONT_NEXT, 523, 320,
	FONT_NEXT, 537, 295,
	FONT_NEXT, 542, 247,
	FONT_NEXT, 542, 85,
	FONT_NEXT, 530, 60,
	FONT_NEXT, 499, 42,
	FONT_NEXT, 455, 30,
	FONT_NEXT, 405, 26,
	FONT_NEXT, 349, 31,
	FONT_NEXT, 299, 46,
	FONT_NEXT, 254, 71,
	FONT_NEXT, 217, 105,
	FONT_NEXT, 187, 147,
	FONT_NEXT, 164, 197,
	FONT_NEXT, 150, 255,
	FONT_NEXT, 146, 320,
	FONT_NEXT, 152, 406,
	FONT_NEXT, 170, 476,
	FONT_NEXT, 197, 531,
	FONT_NEXT, 231, 572,
	FONT_NEXT, 269, 602,
	FONT_NEXT, 310, 622,
	FONT_NEXT, 388, 636,
	FONT_NEXT, 436, 631,
	FONT_NEXT, 477, 619,
	FONT_NEXT, 539, 577,
	FONT_NEXT, 581, 522,
	FONT_NEXT, 607, 465,
	FONT_NEXT, 630, 465,
	FONT_NEXT, 622, 676,
	FONT_NEXT, 600, 676,
	FONT_NEXT, 591, 659,
	FONT_NEXT, 577, 649,
	FONT_NEXT, 553, 643,
	FONT_NEXT, 525, 648,
	FONT_NEXT, 489, 659,
	FONT_NEXT, 440, 670,
	FONT_NEXT, 374, 676,
	FONT_NEXT, 298, 668,
	FONT_NEXT, 231, 647,
	FONT_NEXT, 172, 614,
	FONT_NEXT, 123, 571,
	FONT_NEXT, 84, 520,
	FONT_NEXT, 55, 464,
	FONT_NEXT, 38, 403,
	FONT_NEXT, 32, 341,
	FONT_NEXT, 37, 255,
	FONT_NEXT, 53, 189,
	FONT_NEXT, 79, 137,
	FONT_NEXT, 115, 93,
	FONT_NEXT, 174, 43,
	FONT_NEXT, 245, 10,
	FONT_NEXT, 320, -9,
	FONT_NEXT, 396, -14,
	FONT_NEXT, 480, -5,
	FONT_NEXT, 558, 16,
	FONT_NEXT, 616, 40,
	FONT_NEXT, 633, 50,
	FONT_NEXT, 639, 58,
	FONT_NEXT, 639, 259,
	FONT_NEXT, 643, 300,
	FONT_NEXT, 657, 322,
	FONT_NEXT, 679, 332,
	FONT_NEXT, 709, 336,
	FONT_END, 709, 354,
	FONT_ADVANCE, 722, 0
    },
    {
	72,
	FONT_BEGIN, 297, 0,
	FONT_NEXT, 297, 19,
	FONT_NEXT, 250, 25,
	FONT_NEXT, 223, 41,
	FONT_NEXT, 211, 67,
	FONT_NEXT, 209, 109,
	FONT_NEXT, 209, 315,
	FONT_NEXT, 512, 315,
	FONT_NEXT, 512, 120,
	FONT_NEXT, 510, 73,
	FONT_NEXT, 499, 42,
	FONT_NEXT, 473, 25,
	FONT_NEXT, 424, 19,
	FONT_NEXT, 424, 0,
	FONT_NEXT, 702, 0,
	FONT_NEXT, 702, 19,
	FONT_NEXT, 655, 25,
	FONT_NEXT, 628, 41,
	FONT_NEXT, 616, 67,
	FONT_NEXT, 614, 109,
	FONT_NEXT, 614, 553,
	FONT_NEXT, 617, 596,
	FONT_NEXT, 629, 622,
	FONT_NEXT, 656, 636,
	FONT_NEXT, 702, 643,
	FONT_NEXT, 702, 662,
	FONT_NEXT, 424, 662,
	FONT_NEXT, 424, 643,
	FONT_NEXT, 468, 636,
	FONT_NEXT, 495, 623,
	FONT_NEXT, 508, 597,
	FONT_NEXT, 512, 553,
	FONT_NEXT, 512, 359,
	FONT_NEXT, 209, 359,
	FONT_NEXT, 209, 553,
	FONT_NEXT, 212, 596,
	FONT_NEXT, 224, 622,
	FONT_NEXT, 251, 636,
	FONT_NEXT, 297, 643,
	FONT_NEXT, 297, 662,
	FONT_NEXT, 19, 662,
	FONT_NEXT, 19, 643,
	FONT_NEXT, 63, 636,
	FONT_NEXT, 90, 623,
	FONT_NEXT, 103, 597,
	FONT_NEXT, 107, 553,
	FONT_NEXT, 107, 120,
	FONT_NEXT, 105, 73,
	FONT_NEXT, 94, 42,
	FONT_NEXT, 68, 25,
	FONT_NEXT, 19, 19,
	FONT_END, 19, 0,
	FONT_ADVANCE, 722, 0
    },
    {
	73,
	FONT_BEGIN, 315, 0,
	FONT_NEXT, 315, 19,
	FONT_NEXT, 268, 22,
	FONT_NEXT, 238, 35,
	FONT_NEXT, 221, 62,
	FONT_NEXT, 217, 109,
	FONT_NEXT, 217, 553,
	FONT_NEXT, 222, 600,
	FONT_NEXT, 238, 626,
	FONT_NEXT, 268, 638,
	FONT_NEXT, 315, 643,
	FONT_NEXT, 315, 662,
	FONT_NEXT, 18, 662,
	FONT_NEXT, 18, 643,
	FONT_NEXT, 68, 637,
	FONT_NEXT, 97, 624,
	FONT_NEXT, 111, 597,
	FONT_NEXT, 115, 553,
	FONT_NEXT, 115, 109,
	FONT_NEXT, 111, 65,
	FONT_NEXT, 98, 38,
	FONT_NEXT, 69, 23,
	FONT_NEXT, 18, 19,
	FONT_END, 18, 0,
	FONT_ADVANCE, 333, 0
    },
    {
	74,
	FONT_BEGIN, 281, 597,
	FONT_NEXT, 294, 623,
	FONT_NEXT, 322, 637,
	FONT_NEXT, 370, 643,
	FONT_NEXT, 370, 662,
	FONT_NEXT, 83, 662,
	FONT_NEXT, 83, 643,
	FONT_NEXT, 131, 636,
	FONT_NEXT, 159, 622,
	FONT_NEXT, 172, 596,
	FONT_NEXT, 176, 553,
	FONT_NEXT, 176, 90,
	FONT_NEXT, 173, 57,
	FONT_NEXT, 165, 37,
	FONT_NEXT, 153, 27,
	FONT_NEXT, 137, 24,
	FONT_NEXT, 117, 37,
	FONT_NEXT, 107, 66,
	FONT_NEXT, 92, 94,
	FONT_NEXT, 77, 104,
	FONT_NEXT, 56, 108,
	FONT_NEXT, 36, 103,
	FONT_NEXT, 22, 90,
	FONT_NEXT, 10, 59,
	FONT_NEXT, 15, 36,
	FONT_NEXT, 32, 11,
	FONT_NEXT, 59, -6,
	FONT_NEXT, 110, -14,
	FONT_NEXT, 124, -14,
	FONT_NEXT, 147, -11,
	FONT_NEXT, 204, 11,
	FONT_NEXT, 231, 35,
	FONT_NEXT, 255, 70,
	FONT_NEXT, 271, 118,
	FONT_NEXT, 278, 183,
	FONT_END, 278, 553,
	FONT_ADVANCE, 389, 0
    },
    {
	75,
	FONT_BEGIN, 444, 641,
	FONT_NEXT, 465, 636,
	FONT_NEXT, 477, 627,
	FONT_NEXT, 481, 612,
	FONT_NEXT, 472, 584,
	FONT_NEXT, 459, 567,
	FONT_NEXT, 438, 543,
	FONT_NEXT, 406, 511,
	FONT_NEXT, 361, 470,
	FONT_NEXT, 301, 416,
	FONT_NEXT, 226, 348,
	FONT_NEXT, 226, 553,
	FONT_NEXT, 229, 597,
	FONT_NEXT, 242, 623,
	FONT_NEXT, 270, 637,
	FONT_NEXT, 318, 643,
	FONT_NEXT, 318, 662,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 34, 643,
	FONT_NEXT, 76, 637,
	FONT_NEXT, 104, 625,
	FONT_NEXT, 119, 599,
	FONT_NEXT, 124, 553,
	FONT_NEXT, 124, 120,
	FONT_NEXT, 120, 70,
	FONT_NEXT, 108, 40,
	FONT_NEXT, 80, 24,
	FONT_NEXT, 34, 19,
	FONT_NEXT, 34, 0,
	FONT_NEXT, 316, 0,
	FONT_NEXT, 316, 19,
	FONT_NEXT, 269, 24,
	FONT_NEXT, 241, 39,
	FONT_NEXT, 229, 65,
	FONT_NEXT, 226, 109,
	FONT_NEXT, 226, 296,
	FONT_NEXT, 252, 317,
	FONT_NEXT, 358, 212,
	FONT_NEXT, 392, 175,
	FONT_NEXT, 435, 126,
	FONT_NEXT, 472, 78,
	FONT_NEXT, 483, 58,
	FONT_NEXT, 488, 44,
	FONT_NEXT, 484, 31,
	FONT_NEXT, 472, 24,
	FONT_NEXT, 451, 20,
	FONT_NEXT, 418, 19,
	FONT_NEXT, 418, 0,
	FONT_NEXT, 723, 0,
	FONT_NEXT, 723, 19,
	FONT_NEXT, 683, 24,
	FONT_NEXT, 647, 45,
	FONT_NEXT, 609, 79,
	FONT_NEXT, 566, 127,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 523, 565,
	FONT_NEXT, 568, 606,
	FONT_NEXT, 603, 628,
	FONT_NEXT, 635, 638,
	FONT_NEXT, 675, 643,
	FONT_NEXT, 675, 662,
	FONT_NEXT, 413, 662,
	FONT_END, 413, 643,
	FONT_ADVANCE, 722, 0
    },
    {
	76,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 12, 643,
	FONT_NEXT, 52, 637,
	FONT_NEXT, 79, 625,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 99, 553,
	FONT_NEXT, 99, 109,
	FONT_NEXT, 94, 63,
	FONT_NEXT, 79, 36,
	FONT_NEXT, 52, 23,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 550, 0,
	FONT_NEXT, 598, 174,
	FONT_NEXT, 573, 174,
	FONT_NEXT, 551, 130,
	FONT_NEXT, 527, 97,
	FONT_NEXT, 501, 73,
	FONT_NEXT, 472, 57,
	FONT_NEXT, 399, 41,
	FONT_NEXT, 302, 39,
	FONT_NEXT, 251, 39,
	FONT_NEXT, 220, 44,
	FONT_NEXT, 205, 56,
	FONT_NEXT, 201, 80,
	FONT_NEXT, 201, 553,
	FONT_NEXT, 205, 599,
	FONT_NEXT, 222, 626,
	FONT_NEXT, 250, 638,
	FONT_NEXT, 294, 643,
	FONT_END, 294, 662,
	FONT_ADVANCE, 611, 0
    },
    {
	77,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 443, 157,
	FONT_NEXT, 212, 662,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 14, 643,
	FONT_NEXT, 60, 638,
	FONT_NEXT, 89, 625,
	FONT_NEXT, 104, 599,
	FONT_NEXT, 109, 553,
	FONT_NEXT, 109, 147,
	FONT_NEXT, 107, 110,
	FONT_NEXT, 104, 82,
	FONT_NEXT, 89, 44,
	FONT_NEXT, 59, 25,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 247, 0,
	FONT_NEXT, 247, 19,
	FONT_NEXT, 201, 25,
	FONT_NEXT, 172, 45,
	FONT_NEXT, 157, 83,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 153, 546,
	FONT_NEXT, 155, 546,
	FONT_NEXT, 404, 0,
	FONT_NEXT, 418, 0,
	FONT_NEXT, 672, 569,
	FONT_NEXT, 674, 569,
	FONT_NEXT, 674, 120,
	FONT_NEXT, 670, 70,
	FONT_NEXT, 657, 40,
	FONT_NEXT, 630, 24,
	FONT_NEXT, 583, 19,
	FONT_NEXT, 583, 0,
	FONT_NEXT, 863, 0,
	FONT_NEXT, 863, 19,
	FONT_NEXT, 822, 23,
	FONT_NEXT, 795, 36,
	FONT_NEXT, 780, 63,
	FONT_NEXT, 776, 109,
	FONT_NEXT, 776, 553,
	FONT_NEXT, 780, 599,
	FONT_NEXT, 795, 625,
	FONT_NEXT, 822, 637,
	FONT_NEXT, 863, 643,
	FONT_END, 863, 662,
	FONT_ADVANCE, 889, 0
    },
    {
	78,
	FONT_BEGIN, 472, 662,
	FONT_NEXT, 472, 643,
	FONT_NEXT, 515, 637,
	FONT_NEXT, 545, 620,
	FONT_NEXT, 562, 582,
	FONT_NEXT, 566, 553,
	FONT_NEXT, 568, 515,
	FONT_NEXT, 568, 181,
	FONT_NEXT, 566, 181,
	FONT_NEXT, 183, 662,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 12, 643,
	FONT_NEXT, 60, 634,
	FONT_NEXT, 82, 617,
	FONT_NEXT, 109, 588,
	FONT_NEXT, 109, 147,
	FONT_NEXT, 107, 110,
	FONT_NEXT, 104, 82,
	FONT_NEXT, 89, 44,
	FONT_NEXT, 59, 25,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 247, 0,
	FONT_NEXT, 247, 19,
	FONT_NEXT, 201, 25,
	FONT_NEXT, 172, 45,
	FONT_NEXT, 157, 83,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 153, 537,
	FONT_NEXT, 155, 537,
	FONT_NEXT, 595, -11,
	FONT_NEXT, 612, -11,
	FONT_NEXT, 612, 515,
	FONT_NEXT, 613, 553,
	FONT_NEXT, 617, 583,
	FONT_NEXT, 635, 620,
	FONT_NEXT, 665, 636,
	FONT_NEXT, 707, 643,
	FONT_END, 707, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	79,
	FONT_BEGIN, 427, -8,
	FONT_NEXT, 488, 9,
	FONT_NEXT, 544, 38,
	FONT_NEXT, 592, 78,
	FONT_NEXT, 632, 127,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 681, 254,
	FONT_NEXT, 688, 330,
	FONT_NEXT, 680, 410,
	FONT_NEXT, 659, 481,
	FONT_NEXT, 627, 540,
	FONT_NEXT, 586, 589,
	FONT_NEXT, 536, 627,
	FONT_NEXT, 481, 654,
	FONT_NEXT, 422, 670,
	FONT_NEXT, 361, 676,
	FONT_NEXT, 299, 670,
	FONT_NEXT, 240, 654,
	FONT_NEXT, 185, 627,
	FONT_NEXT, 136, 589,
	FONT_NEXT, 94, 540,
	FONT_NEXT, 62, 481,
	FONT_NEXT, 41, 410,
	FONT_NEXT, 34, 330,
	FONT_NEXT, 40, 254,
	FONT_NEXT, 59, 186,
	FONT_NEXT, 89, 127,
	FONT_NEXT, 129, 78,
	FONT_NEXT, 177, 38,
	FONT_NEXT, 233, 9,
	FONT_NEXT, 294, -8,
	FONT_END, 361, -14,
	FONT_BEGIN, 319, 26,
	FONT_NEXT, 280, 39,
	FONT_NEXT, 244, 61,
	FONT_NEXT, 212, 94,
	FONT_NEXT, 186, 136,
	FONT_NEXT, 165, 189,
	FONT_NEXT, 152, 254,
	FONT_NEXT, 148, 331,
	FONT_NEXT, 152, 409,
	FONT_NEXT, 166, 475,
	FONT_NEXT, 188, 528,
	FONT_NEXT, 216, 571,
	FONT_NEXT, 248, 602,
	FONT_NEXT, 284, 623,
	FONT_NEXT, 322, 636,
	FONT_NEXT, 361, 640,
	FONT_NEXT, 399, 636,
	FONT_NEXT, 437, 623,
	FONT_NEXT, 473, 602,
	FONT_NEXT, 505, 571,
	FONT_NEXT, 533, 528,
	FONT_NEXT, 555, 475,
	FONT_NEXT, 569, 409,
	FONT_NEXT, 574, 331,
	FONT_NEXT, 569, 254,
	FONT_NEXT, 556, 189,
	FONT_NEXT, 535, 136,
	FONT_NEXT, 509, 94,
	FONT_NEXT, 477, 61,
	FONT_NEXT, 441, 39,
	FONT_NEXT, 402, 26,
	FONT_END, 361, 22,
	FONT_ADVANCE, 722, 0
    },
    {
	80,
	FONT_BEGIN, 59, 635,
	FONT_NEXT, 85, 622,
	FONT_NEXT, 97, 596,
	FONT_NEXT, 100, 553,
	FONT_NEXT, 100, 120,
	FONT_NEXT, 98, 74,
	FONT_NEXT, 89, 44,
	FONT_NEXT, 64, 27,
	FONT_NEXT, 16, 19,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 296, 0,
	FONT_NEXT, 296, 19,
	FONT_NEXT, 248, 23,
	FONT_NEXT, 220, 37,
	FONT_NEXT, 205, 64,
	FONT_NEXT, 202, 109,
	FONT_NEXT, 202, 291,
	FONT_NEXT, 269, 288,
	FONT_NEXT, 340, 291,
	FONT_NEXT, 398, 302,
	FONT_NEXT, 444, 320,
	FONT_NEXT, 481, 347,
	FONT_NEXT, 497, 363,
	FONT_NEXT, 517, 391,
	FONT_NEXT, 534, 430,
	FONT_NEXT, 542, 482,
	FONT_NEXT, 536, 526,
	FONT_NEXT, 520, 563,
	FONT_NEXT, 495, 594,
	FONT_NEXT, 462, 619,
	FONT_NEXT, 379, 651,
	FONT_NEXT, 280, 662,
	FONT_NEXT, 16, 662,
	FONT_END, 16, 643,
	FONT_BEGIN, 204, 610,
	FONT_NEXT, 211, 620,
	FONT_NEXT, 243, 625,
	FONT_NEXT, 291, 622,
	FONT_NEXT, 354, 606,
	FONT_NEXT, 384, 588,
	FONT_NEXT, 409, 562,
	FONT_NEXT, 426, 527,
	FONT_NEXT, 433, 480,
	FONT_NEXT, 427, 429,
	FONT_NEXT, 411, 392,
	FONT_NEXT, 388, 365,
	FONT_NEXT, 361, 347,
	FONT_NEXT, 304, 330,
	FONT_NEXT, 262, 328,
	FONT_NEXT, 202, 331,
	FONT_END, 202, 591,
	FONT_ADVANCE, 556, 0
    },
    {
	81,
	FONT_BEGIN, 638, -153,
	FONT_NEXT, 586, -138,
	FONT_NEXT, 505, -90,
	FONT_NEXT, 426, -7,
	FONT_NEXT, 468, 2,
	FONT_NEXT, 512, 20,
	FONT_NEXT, 556, 47,
	FONT_NEXT, 597, 83,
	FONT_NEXT, 633, 130,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 681, 252,
	FONT_NEXT, 688, 330,
	FONT_NEXT, 680, 410,
	FONT_NEXT, 659, 481,
	FONT_NEXT, 627, 540,
	FONT_NEXT, 586, 589,
	FONT_NEXT, 536, 627,
	FONT_NEXT, 481, 654,
	FONT_NEXT, 422, 670,
	FONT_NEXT, 361, 676,
	FONT_NEXT, 299, 670,
	FONT_NEXT, 240, 654,
	FONT_NEXT, 185, 626,
	FONT_NEXT, 136, 588,
	FONT_NEXT, 94, 540,
	FONT_NEXT, 62, 480,
	FONT_NEXT, 41, 410,
	FONT_NEXT, 34, 330,
	FONT_NEXT, 40, 255,
	FONT_NEXT, 57, 191,
	FONT_NEXT, 82, 138,
	FONT_NEXT, 114, 94,
	FONT_NEXT, 151, 58,
	FONT_NEXT, 189, 31,
	FONT_NEXT, 265, -1,
	FONT_NEXT, 312, -56,
	FONT_NEXT, 379, -113,
	FONT_NEXT, 462, -151,
	FONT_NEXT, 555, -172,
	FONT_NEXT, 654, -178,
	FONT_NEXT, 701, -177,
	FONT_END, 701, -159,
	FONT_BEGIN, 399, 636,
	FONT_NEXT, 437, 623,
	FONT_NEXT, 473, 602,
	FONT_NEXT, 505, 570,
	FONT_NEXT, 533, 528,
	FONT_NEXT, 555, 475,
	FONT_NEXT, 569, 409,
	FONT_NEXT, 574, 330,
	FONT_NEXT, 569, 253,
	FONT_NEXT, 556, 189,
	FONT_NEXT, 535, 136,
	FONT_NEXT, 509, 93,
	FONT_NEXT, 477, 61,
	FONT_NEXT, 441, 39,
	FONT_NEXT, 402, 26,
	FONT_NEXT, 361, 22,
	FONT_NEXT, 319, 26,
	FONT_NEXT, 280, 39,
	FONT_NEXT, 244, 61,
	FONT_NEXT, 212, 93,
	FONT_NEXT, 186, 136,
	FONT_NEXT, 165, 189,
	FONT_NEXT, 152, 253,
	FONT_NEXT, 148, 330,
	FONT_NEXT, 152, 409,
	FONT_NEXT, 166, 475,
	FONT_NEXT, 188, 528,
	FONT_NEXT, 216, 570,
	FONT_NEXT, 248, 602,
	FONT_NEXT, 284, 623,
	FONT_NEXT, 322, 636,
	FONT_END, 361, 640,
	FONT_ADVANCE, 722, 0
    },
    {
	82,
	FONT_BEGIN, 608, 33,
	FONT_NEXT, 572, 66,
	FONT_NEXT, 366, 319,
	FONT_NEXT, 415, 330,
	FONT_NEXT, 475, 356,
	FONT_NEXT, 503, 377,
	FONT_NEXT, 525, 405,
	FONT_NEXT, 541, 441,
	FONT_NEXT, 547, 487,
	FONT_NEXT, 539, 538,
	FONT_NEXT, 519, 579,
	FONT_NEXT, 490, 610,
	FONT_NEXT, 453, 632,
	FONT_NEXT, 370, 656,
	FONT_NEXT, 293, 662,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 17, 643,
	FONT_NEXT, 59, 636,
	FONT_NEXT, 85, 623,
	FONT_NEXT, 98, 597,
	FONT_NEXT, 102, 553,
	FONT_NEXT, 102, 120,
	FONT_NEXT, 100, 73,
	FONT_NEXT, 89, 43,
	FONT_NEXT, 64, 26,
	FONT_NEXT, 17, 19,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 294, 0,
	FONT_NEXT, 294, 19,
	FONT_NEXT, 246, 25,
	FONT_NEXT, 219, 40,
	FONT_NEXT, 206, 67,
	FONT_NEXT, 204, 109,
	FONT_NEXT, 204, 306,
	FONT_NEXT, 260, 308,
	FONT_NEXT, 498, 0,
	FONT_NEXT, 659, 0,
	FONT_END, 659, 19,
	FONT_BEGIN, 206, 606,
	FONT_NEXT, 215, 617,
	FONT_NEXT, 233, 623,
	FONT_NEXT, 266, 625,
	FONT_NEXT, 310, 622,
	FONT_NEXT, 367, 606,
	FONT_NEXT, 394, 590,
	FONT_NEXT, 416, 566,
	FONT_NEXT, 432, 533,
	FONT_NEXT, 438, 489,
	FONT_NEXT, 431, 441,
	FONT_NEXT, 413, 406,
	FONT_NEXT, 386, 380,
	FONT_NEXT, 352, 362,
	FONT_NEXT, 276, 346,
	FONT_NEXT, 204, 343,
	FONT_END, 204, 589,
	FONT_ADVANCE, 667, 0
    },
    {
	83,
	FONT_BEGIN, 426, 676,
	FONT_NEXT, 418, 654,
	FONT_NEXT, 408, 645,
	FONT_NEXT, 391, 642,
	FONT_NEXT, 367, 647,
	FONT_NEXT, 334, 659,
	FONT_NEXT, 252, 676,
	FONT_NEXT, 185, 665,
	FONT_NEXT, 127, 633,
	FONT_NEXT, 86, 580,
	FONT_NEXT, 75, 546,
	FONT_NEXT, 71, 506,
	FONT_NEXT, 82, 441,
	FONT_NEXT, 114, 390,
	FONT_NEXT, 163, 349,
	FONT_NEXT, 227, 310,
	FONT_NEXT, 276, 280,
	FONT_NEXT, 314, 254,
	FONT_NEXT, 343, 231,
	FONT_NEXT, 363, 210,
	FONT_NEXT, 385, 172,
	FONT_NEXT, 390, 133,
	FONT_NEXT, 382, 92,
	FONT_NEXT, 360, 57,
	FONT_NEXT, 322, 31,
	FONT_NEXT, 270, 22,
	FONT_NEXT, 223, 27,
	FONT_NEXT, 183, 43,
	FONT_NEXT, 124, 92,
	FONT_NEXT, 86, 151,
	FONT_NEXT, 65, 199,
	FONT_NEXT, 42, 199,
	FONT_NEXT, 72, -13,
	FONT_NEXT, 94, -13,
	FONT_NEXT, 101, 9,
	FONT_NEXT, 125, 20,
	FONT_NEXT, 151, 14,
	FONT_NEXT, 185, 3,
	FONT_NEXT, 227, -9,
	FONT_NEXT, 280, -14,
	FONT_NEXT, 330, -10,
	FONT_NEXT, 373, 2,
	FONT_NEXT, 409, 20,
	FONT_NEXT, 439, 44,
	FONT_NEXT, 478, 102,
	FONT_NEXT, 491, 167,
	FONT_NEXT, 476, 235,
	FONT_NEXT, 438, 290,
	FONT_NEXT, 385, 336,
	FONT_NEXT, 324, 375,
	FONT_NEXT, 209, 448,
	FONT_NEXT, 171, 491,
	FONT_NEXT, 157, 542,
	FONT_NEXT, 165, 582,
	FONT_NEXT, 188, 611,
	FONT_NEXT, 221, 629,
	FONT_NEXT, 258, 635,
	FONT_NEXT, 295, 630,
	FONT_NEXT, 328, 619,
	FONT_NEXT, 384, 579,
	FONT_NEXT, 422, 524,
	FONT_NEXT, 444, 463,
	FONT_NEXT, 469, 463,
	FONT_END, 447, 676,
	FONT_ADVANCE, 556, 0
    },
    {
	84,
	FONT_BEGIN, 401, 24,
	FONT_NEXT, 372, 39,
	FONT_NEXT, 359, 66,
	FONT_NEXT, 356, 109,
	FONT_NEXT, 356, 620,
	FONT_NEXT, 410, 620,
	FONT_NEXT, 478, 615,
	FONT_NEXT, 522, 597,
	FONT_NEXT, 550, 558,
	FONT_NEXT, 569, 492,
	FONT_NEXT, 593, 492,
	FONT_NEXT, 587, 662,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 17, 492,
	FONT_NEXT, 41, 492,
	FONT_NEXT, 59, 557,
	FONT_NEXT, 87, 596,
	FONT_NEXT, 131, 615,
	FONT_NEXT, 200, 620,
	FONT_NEXT, 254, 620,
	FONT_NEXT, 254, 120,
	FONT_NEXT, 252, 73,
	FONT_NEXT, 241, 43,
	FONT_NEXT, 213, 26,
	FONT_NEXT, 160, 19,
	FONT_NEXT, 160, 0,
	FONT_NEXT, 452, 0,
	FONT_END, 452, 19,
	FONT_ADVANCE, 611, 0
    },
    {
	85,
	FONT_BEGIN, 473, 662,
	FONT_NEXT, 473, 643,
	FONT_NEXT, 517, 636,
	FONT_NEXT, 546, 617,
	FONT_NEXT, 562, 579,
	FONT_NEXT, 567, 515,
	FONT_NEXT, 567, 245,
	FONT_NEXT, 565, 192,
	FONT_NEXT, 560, 154,
	FONT_NEXT, 544, 109,
	FONT_NEXT, 517, 76,
	FONT_NEXT, 480, 51,
	FONT_NEXT, 434, 35,
	FONT_NEXT, 380, 30,
	FONT_NEXT, 322, 36,
	FONT_NEXT, 279, 52,
	FONT_NEXT, 248, 77,
	FONT_NEXT, 227, 107,
	FONT_NEXT, 208, 174,
	FONT_NEXT, 206, 233,
	FONT_NEXT, 206, 553,
	FONT_NEXT, 209, 596,
	FONT_NEXT, 221, 622,
	FONT_NEXT, 249, 636,
	FONT_NEXT, 297, 643,
	FONT_NEXT, 297, 662,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 14, 643,
	FONT_NEXT, 60, 637,
	FONT_NEXT, 87, 623,
	FONT_NEXT, 100, 597,
	FONT_NEXT, 104, 553,
	FONT_NEXT, 104, 241,
	FONT_NEXT, 104, 212,
	FONT_NEXT, 107, 175,
	FONT_NEXT, 117, 133,
	FONT_NEXT, 135, 91,
	FONT_NEXT, 164, 50,
	FONT_NEXT, 208, 17,
	FONT_NEXT, 270, -6,
	FONT_NEXT, 352, -14,
	FONT_NEXT, 437, -6,
	FONT_NEXT, 501, 16,
	FONT_NEXT, 547, 49,
	FONT_NEXT, 578, 90,
	FONT_NEXT, 597, 134,
	FONT_NEXT, 606, 178,
	FONT_NEXT, 611, 254,
	FONT_NEXT, 611, 515,
	FONT_NEXT, 614, 578,
	FONT_NEXT, 629, 615,
	FONT_NEXT, 657, 634,
	FONT_NEXT, 705, 643,
	FONT_END, 705, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	86,
	FONT_BEGIN, 492, 662,
	FONT_NEXT, 492, 643,
	FONT_NEXT, 542, 634,
	FONT_NEXT, 558, 621,
	FONT_NEXT, 565, 597,
	FONT_NEXT, 556, 556,
	FONT_NEXT, 549, 538,
	FONT_NEXT, 546, 528,
	FONT_NEXT, 399, 161,
	FONT_NEXT, 248, 499,
	FONT_NEXT, 218, 566,
	FONT_NEXT, 210, 590,
	FONT_NEXT, 207, 606,
	FONT_NEXT, 210, 624,
	FONT_NEXT, 223, 635,
	FONT_NEXT, 246, 640,
	FONT_NEXT, 282, 643,
	FONT_NEXT, 282, 662,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 16, 643,
	FONT_NEXT, 46, 638,
	FONT_NEXT, 71, 623,
	FONT_NEXT, 94, 592,
	FONT_NEXT, 122, 538,
	FONT_NEXT, 368, -11,
	FONT_NEXT, 383, -11,
	FONT_NEXT, 605, 550,
	FONT_NEXT, 625, 596,
	FONT_NEXT, 644, 623,
	FONT_NEXT, 666, 637,
	FONT_NEXT, 697, 643,
	FONT_END, 697, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	87,
	FONT_BEGIN, 734, 662,
	FONT_NEXT, 734, 643,
	FONT_NEXT, 781, 633,
	FONT_NEXT, 797, 620,
	FONT_NEXT, 803, 597,
	FONT_NEXT, 787, 525,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 530, 527,
	FONT_NEXT, 510, 574,
	FONT_NEXT, 503, 605,
	FONT_NEXT, 510, 626,
	FONT_NEXT, 529, 637,
	FONT_NEXT, 580, 643,
	FONT_NEXT, 580, 662,
	FONT_NEXT, 313, 662,
	FONT_NEXT, 313, 643,
	FONT_NEXT, 346, 640,
	FONT_NEXT, 371, 628,
	FONT_NEXT, 391, 601,
	FONT_NEXT, 414, 553,
	FONT_NEXT, 447, 471,
	FONT_NEXT, 340, 189,
	FONT_NEXT, 196, 565,
	FONT_NEXT, 185, 609,
	FONT_NEXT, 188, 625,
	FONT_NEXT, 200, 635,
	FONT_NEXT, 220, 640,
	FONT_NEXT, 250, 643,
	FONT_NEXT, 250, 662,
	FONT_NEXT, 5, 662,
	FONT_NEXT, 5, 643,
	FONT_NEXT, 40, 634,
	FONT_NEXT, 65, 613,
	FONT_NEXT, 86, 578,
	FONT_NEXT, 108, 526,
	FONT_NEXT, 125, 480,
	FONT_NEXT, 147, 421,
	FONT_NEXT, 199, 277,
	FONT_NEXT, 254, 123,
	FONT_NEXT, 279, 51,
	FONT_NEXT, 301, -11,
	FONT_NEXT, 316, -11,
	FONT_NEXT, 470, 412,
	FONT_NEXT, 630, -11,
	FONT_NEXT, 645, -11,
	FONT_NEXT, 745, 288,
	FONT_NEXT, 853, 582,
	FONT_NEXT, 864, 606,
	FONT_NEXT, 879, 624,
	FONT_NEXT, 900, 635,
	FONT_NEXT, 932, 643,
	FONT_END, 932, 662,
	FONT_ADVANCE, 944, 0
    },
    {
	88,
	FONT_BEGIN, 458, 662,
	FONT_NEXT, 458, 643,
	FONT_NEXT, 505, 637,
	FONT_NEXT, 521, 628,
	FONT_NEXT, 528, 610,
	FONT_NEXT, 516, 579,
	FONT_NEXT, 488, 542,
	FONT_NEXT, 375, 404,
	FONT_NEXT, 333, 463,
	FONT_NEXT, 291, 523,
	FONT_NEXT, 265, 565,
	FONT_NEXT, 251, 592,
	FONT_NEXT, 248, 611,
	FONT_NEXT, 252, 628,
	FONT_NEXT, 266, 637,
	FONT_NEXT, 290, 641,
	FONT_NEXT, 324, 643,
	FONT_NEXT, 324, 662,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 22, 643,
	FONT_NEXT, 60, 637,
	FONT_NEXT, 96, 618,
	FONT_NEXT, 116, 600,
	FONT_NEXT, 139, 573,
	FONT_NEXT, 168, 535,
	FONT_NEXT, 203, 486,
	FONT_NEXT, 312, 326,
	FONT_NEXT, 155, 133,
	FONT_NEXT, 128, 100,
	FONT_NEXT, 106, 74,
	FONT_NEXT, 73, 41,
	FONT_NEXT, 44, 24,
	FONT_NEXT, 10, 19,
	FONT_NEXT, 10, 0,
	FONT_NEXT, 243, 0,
	FONT_NEXT, 243, 19,
	FONT_NEXT, 190, 26,
	FONT_NEXT, 173, 37,
	FONT_NEXT, 167, 56,
	FONT_NEXT, 172, 73,
	FONT_NEXT, 185, 95,
	FONT_NEXT, 219, 140,
	FONT_NEXT, 338, 288,
	FONT_NEXT, 433, 148,
	FONT_NEXT, 464, 98,
	FONT_NEXT, 478, 72,
	FONT_NEXT, 484, 53,
	FONT_NEXT, 479, 35,
	FONT_NEXT, 464, 25,
	FONT_NEXT, 440, 21,
	FONT_NEXT, 407, 19,
	FONT_NEXT, 407, 0,
	FONT_NEXT, 704, 0,
	FONT_NEXT, 704, 19,
	FONT_NEXT, 670, 24,
	FONT_NEXT, 643, 37,
	FONT_NEXT, 619, 58,
	FONT_NEXT, 593, 93,
	FONT_NEXT, 401, 367,
	FONT_NEXT, 547, 549,
	FONT_NEXT, 592, 599,
	FONT_NEXT, 627, 627,
	FONT_NEXT, 660, 638,
	FONT_NEXT, 696, 643,
	FONT_END, 696, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	89,
	FONT_BEGIN, 484, 662,
	FONT_NEXT, 484, 643,
	FONT_NEXT, 530, 638,
	FONT_NEXT, 546, 628,
	FONT_NEXT, 553, 610,
	FONT_NEXT, 539, 573,
	FONT_NEXT, 396, 347,
	FONT_NEXT, 248, 569,
	FONT_NEXT, 231, 612,
	FONT_NEXT, 235, 628,
	FONT_NEXT, 249, 637,
	FONT_NEXT, 271, 641,
	FONT_NEXT, 302, 643,
	FONT_NEXT, 302, 662,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 22, 643,
	FONT_NEXT, 51, 637,
	FONT_NEXT, 81, 619,
	FONT_NEXT, 99, 600,
	FONT_NEXT, 121, 573,
	FONT_NEXT, 149, 535,
	FONT_NEXT, 184, 486,
	FONT_NEXT, 315, 294,
	FONT_NEXT, 315, 120,
	FONT_NEXT, 313, 72,
	FONT_NEXT, 301, 41,
	FONT_NEXT, 271, 24,
	FONT_NEXT, 246, 20,
	FONT_NEXT, 214, 19,
	FONT_NEXT, 214, 0,
	FONT_NEXT, 520, 0,
	FONT_NEXT, 520, 19,
	FONT_NEXT, 465, 23,
	FONT_NEXT, 434, 37,
	FONT_NEXT, 420, 64,
	FONT_NEXT, 417, 109,
	FONT_NEXT, 417, 303,
	FONT_NEXT, 565, 529,
	FONT_NEXT, 589, 564,
	FONT_NEXT, 610, 590,
	FONT_NEXT, 646, 624,
	FONT_NEXT, 675, 638,
	FONT_NEXT, 703, 643,
	FONT_END, 703, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	90,
	FONT_BEGIN, 556, 123,
	FONT_NEXT, 528, 79,
	FONT_NEXT, 481, 49,
	FONT_NEXT, 446, 40,
	FONT_NEXT, 402, 38,
	FONT_NEXT, 145, 38,
	FONT_NEXT, 577, 647,
	FONT_NEXT, 577, 662,
	FONT_NEXT, 51, 662,
	FONT_NEXT, 31, 491,
	FONT_NEXT, 57, 491,
	FONT_NEXT, 68, 540,
	FONT_NEXT, 92, 582,
	FONT_NEXT, 112, 599,
	FONT_NEXT, 140, 612,
	FONT_NEXT, 177, 621,
	FONT_NEXT, 225, 624,
	FONT_NEXT, 446, 624,
	FONT_NEXT, 9, 15,
	FONT_NEXT, 9, 0,
	FONT_NEXT, 573, 0,
	FONT_NEXT, 597, 176,
	FONT_END, 574, 176,
	FONT_ADVANCE, 611, 0
    },
    {
	91,
	FONT_BEGIN, 299, 662,
	FONT_NEXT, 88, 662,
	FONT_NEXT, 88, -156,
	FONT_NEXT, 299, -156,
	FONT_NEXT, 299, -131,
	FONT_NEXT, 213, -131,
	FONT_NEXT, 184, -125,
	FONT_NEXT, 170, -110,
	FONT_NEXT, 164, -79,
	FONT_NEXT, 164, 593,
	FONT_NEXT, 169, 620,
	FONT_NEXT, 182, 632,
	FONT_NEXT, 209, 637,
	FONT_END, 299, 637,
	FONT_ADVANCE, 333, 0
    },
    {
	92,
	FONT_BEGIN, 219, -14,
	FONT_NEXT, 287, -14,
	FONT_NEXT, 58, 676,
	FONT_END, -9, 676,
	FONT_ADVANCE, 278, 0
    },
    {
	93,
	FONT_BEGIN, 34, -156,
	FONT_NEXT, 245, -156,
	FONT_NEXT, 245, 662,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 34, 637,
	FONT_NEXT, 120, 637,
	FONT_NEXT, 148, 630,
	FONT_NEXT, 162, 615,
	FONT_NEXT, 169, 585,
	FONT_NEXT, 169, -87,
	FONT_NEXT, 163, -115,
	FONT_NEXT, 150, -127,
	FONT_NEXT, 124, -131,
	FONT_END, 34, -131,
	FONT_ADVANCE, 333, 0
    },
    {
	94,
	FONT_BEGIN, 235, 586,
	FONT_NEXT, 378, 297,
	FONT_NEXT, 446, 297,
	FONT_NEXT, 265, 662,
	FONT_NEXT, 205, 662,
	FONT_NEXT, 24, 297,
	FONT_END, 92, 297,
	FONT_ADVANCE, 469, 0
    },
    {
	95,
	FONT_BEGIN, 500, -75,
	FONT_NEXT, 0, -75,
	FONT_NEXT, 0, -125,
	FONT_END, 500, -125,
	FONT_ADVANCE, 500, 0
    },
    {
	96,
	FONT_BEGIN, 196, 658,
	FONT_NEXT, 159, 625,
	FONT_NEXT, 128, 580,
	FONT_NEXT, 115, 529,
	FONT_NEXT, 124, 478,
	FONT_NEXT, 146, 449,
	FONT_NEXT, 173, 436,
	FONT_NEXT, 196, 433,
	FONT_NEXT, 234, 445,
	FONT_NEXT, 248, 463,
	FONT_NEXT, 254, 491,
	FONT_NEXT, 247, 515,
	FONT_NEXT, 232, 531,
	FONT_NEXT, 192, 541,
	FONT_NEXT, 177, 539,
	FONT_NEXT, 168, 537,
	FONT_NEXT, 158, 540,
	FONT_NEXT, 154, 551,
	FONT_NEXT, 157, 569,
	FONT_NEXT, 170, 595,
	FONT_NEXT, 195, 625,
	FONT_NEXT, 236, 657,
	FONT_END, 227, 676,
	FONT_ADVANCE, 333, 0
    },
    {
	97,
	FONT_BEGIN, 281, 88,
	FONT_NEXT, 271, 77,
	FONT_NEXT, 253, 66,
	FONT_NEXT, 226, 55,
	FONT_NEXT, 191, 48,
	FONT_NEXT, 165, 53,
	FONT_NEXT, 144, 69,
	FONT_NEXT, 130, 93,
	FONT_NEXT, 125, 126,
	FONT_NEXT, 125, 128,
	FONT_NEXT, 129, 157,
	FONT_NEXT, 149, 192,
	FONT_NEXT, 169, 210,
	FONT_NEXT, 197, 229,
	FONT_NEXT, 236, 249,
	FONT_NEXT, 287, 268,
	FONT_END, 287, 123,
	FONT_BEGIN, 423, 53,
	FONT_NEXT, 397, 47,
	FONT_NEXT, 380, 51,
	FONT_NEXT, 371, 65,
	FONT_NEXT, 368, 105,
	FONT_NEXT, 368, 300,
	FONT_NEXT, 365, 350,
	FONT_NEXT, 349, 402,
	FONT_NEXT, 331, 425,
	FONT_NEXT, 305, 443,
	FONT_NEXT, 268, 455,
	FONT_NEXT, 219, 460,
	FONT_NEXT, 178, 456,
	FONT_NEXT, 144, 448,
	FONT_NEXT, 94, 419,
	FONT_NEXT, 65, 383,
	FONT_NEXT, 56, 349,
	FONT_NEXT, 65, 321,
	FONT_NEXT, 79, 309,
	FONT_NEXT, 99, 305,
	FONT_NEXT, 131, 318,
	FONT_NEXT, 144, 348,
	FONT_NEXT, 139, 387,
	FONT_NEXT, 145, 407,
	FONT_NEXT, 162, 423,
	FONT_NEXT, 210, 436,
	FONT_NEXT, 234, 433,
	FONT_NEXT, 259, 421,
	FONT_NEXT, 279, 396,
	FONT_NEXT, 287, 353,
	FONT_NEXT, 287, 292,
	FONT_NEXT, 179, 248,
	FONT_NEXT, 100, 206,
	FONT_NEXT, 73, 183,
	FONT_NEXT, 53, 158,
	FONT_NEXT, 41, 128,
	FONT_NEXT, 37, 94,
	FONT_NEXT, 45, 49,
	FONT_NEXT, 69, 16,
	FONT_NEXT, 103, -4,
	FONT_NEXT, 143, -10,
	FONT_NEXT, 183, -4,
	FONT_NEXT, 222, 14,
	FONT_NEXT, 288, 63,
	FONT_NEXT, 297, 21,
	FONT_NEXT, 315, -1,
	FONT_NEXT, 353, -10,
	FONT_NEXT, 387, -4,
	FONT_NEXT, 412, 11,
	FONT_NEXT, 442, 40,
	FONT_END, 442, 66,
	FONT_ADVANCE, 444, 0
    },
    {
	98,
	FONT_BEGIN, 165, 357,
	FONT_NEXT, 192, 380,
	FONT_NEXT, 224, 393,
	FONT_NEXT, 253, 397,
	FONT_NEXT, 284, 392,
	FONT_NEXT, 311, 379,
	FONT_NEXT, 350, 333,
	FONT_NEXT, 372, 270,
	FONT_NEXT, 380, 201,
	FONT_NEXT, 375, 145,
	FONT_NEXT, 357, 86,
	FONT_NEXT, 340, 61,
	FONT_NEXT, 317, 40,
	FONT_NEXT, 287, 26,
	FONT_NEXT, 249, 22,
	FONT_NEXT, 223, 24,
	FONT_NEXT, 191, 32,
	FONT_NEXT, 164, 47,
	FONT_NEXT, 153, 70,
	FONT_END, 153, 322,
	FONT_BEGIN, 73, 40,
	FONT_NEXT, 86, 28,
	FONT_NEXT, 127, 8,
	FONT_NEXT, 178, -6,
	FONT_NEXT, 224, -10,
	FONT_NEXT, 287, -4,
	FONT_NEXT, 340, 16,
	FONT_NEXT, 382, 44,
	FONT_NEXT, 415, 80,
	FONT_NEXT, 439, 119,
	FONT_NEXT, 455, 161,
	FONT_NEXT, 468, 238,
	FONT_NEXT, 457, 317,
	FONT_NEXT, 424, 389,
	FONT_NEXT, 399, 417,
	FONT_NEXT, 368, 440,
	FONT_NEXT, 332, 454,
	FONT_NEXT, 290, 460,
	FONT_NEXT, 237, 450,
	FONT_NEXT, 196, 428,
	FONT_NEXT, 167, 401,
	FONT_NEXT, 155, 379,
	FONT_NEXT, 153, 379,
	FONT_NEXT, 153, 681,
	FONT_NEXT, 148, 683,
	FONT_NEXT, 3, 639,
	FONT_NEXT, 3, 623,
	FONT_NEXT, 25, 624,
	FONT_NEXT, 50, 620,
	FONT_NEXT, 63, 609,
	FONT_NEXT, 69, 573,
	FONT_END, 69, 54,
	FONT_ADVANCE, 500, 0
    },
    {
	99,
	FONT_BEGIN, 340, 89,
	FONT_NEXT, 302, 69,
	FONT_NEXT, 255, 62,
	FONT_NEXT, 195, 75,
	FONT_NEXT, 147, 114,
	FONT_NEXT, 114, 174,
	FONT_NEXT, 102, 253,
	FONT_NEXT, 106, 302,
	FONT_NEXT, 116, 342,
	FONT_NEXT, 133, 373,
	FONT_NEXT, 152, 397,
	FONT_NEXT, 195, 423,
	FONT_NEXT, 231, 431,
	FONT_NEXT, 262, 427,
	FONT_NEXT, 280, 418,
	FONT_NEXT, 297, 383,
	FONT_NEXT, 303, 361,
	FONT_NEXT, 320, 329,
	FONT_NEXT, 334, 318,
	FONT_NEXT, 352, 315,
	FONT_NEXT, 386, 329,
	FONT_NEXT, 398, 359,
	FONT_NEXT, 387, 392,
	FONT_NEXT, 355, 429,
	FONT_NEXT, 306, 450,
	FONT_NEXT, 249, 460,
	FONT_NEXT, 168, 444,
	FONT_NEXT, 130, 425,
	FONT_NEXT, 96, 398,
	FONT_NEXT, 67, 363,
	FONT_NEXT, 44, 320,
	FONT_NEXT, 30, 270,
	FONT_NEXT, 25, 213,
	FONT_NEXT, 29, 158,
	FONT_NEXT, 42, 111,
	FONT_NEXT, 63, 73,
	FONT_NEXT, 88, 42,
	FONT_NEXT, 149, 2,
	FONT_NEXT, 212, -10,
	FONT_NEXT, 269, -2,
	FONT_NEXT, 322, 25,
	FONT_NEXT, 369, 74,
	FONT_NEXT, 412, 147,
	FONT_END, 398, 156,
	FONT_ADVANCE, 444, 0
    },
    {
	100,
	FONT_BEGIN, 328, 77,
	FONT_NEXT, 308, 58,
	FONT_NEXT, 281, 46,
	FONT_NEXT, 251, 42,
	FONT_NEXT, 201, 53,
	FONT_NEXT, 157, 88,
	FONT_NEXT, 139, 116,
	FONT_NEXT, 125, 152,
	FONT_NEXT, 116, 195,
	FONT_NEXT, 113, 247,
	FONT_NEXT, 116, 293,
	FONT_NEXT, 124, 333,
	FONT_NEXT, 154, 390,
	FONT_NEXT, 194, 422,
	FONT_NEXT, 237, 432,
	FONT_NEXT, 271, 425,
	FONT_NEXT, 303, 407,
	FONT_NEXT, 327, 376,
	FONT_NEXT, 340, 332,
	FONT_END, 340, 102,
	FONT_BEGIN, 452, 58,
	FONT_NEXT, 432, 68,
	FONT_NEXT, 425, 87,
	FONT_NEXT, 424, 114,
	FONT_NEXT, 424, 681,
	FONT_NEXT, 419, 683,
	FONT_NEXT, 272, 639,
	FONT_NEXT, 272, 623,
	FONT_NEXT, 296, 624,
	FONT_NEXT, 321, 620,
	FONT_NEXT, 334, 609,
	FONT_NEXT, 340, 573,
	FONT_NEXT, 340, 417,
	FONT_NEXT, 290, 449,
	FONT_NEXT, 234, 460,
	FONT_NEXT, 192, 454,
	FONT_NEXT, 154, 439,
	FONT_NEXT, 119, 416,
	FONT_NEXT, 88, 386,
	FONT_NEXT, 43, 307,
	FONT_NEXT, 31, 262,
	FONT_NEXT, 27, 214,
	FONT_NEXT, 33, 145,
	FONT_NEXT, 49, 92,
	FONT_NEXT, 74, 53,
	FONT_NEXT, 103, 25,
	FONT_NEXT, 164, -4,
	FONT_NEXT, 209, -10,
	FONT_NEXT, 257, -4,
	FONT_NEXT, 294, 11,
	FONT_NEXT, 320, 32,
	FONT_NEXT, 338, 54,
	FONT_NEXT, 340, 54,
	FONT_NEXT, 340, -7,
	FONT_NEXT, 344, -10,
	FONT_NEXT, 491, 42,
	FONT_END, 491, 58,
	FONT_ADVANCE, 500, 0
    },
    {
	101,
	FONT_BEGIN, 386, 131,
	FONT_NEXT, 355, 97,
	FONT_NEXT, 311, 70,
	FONT_NEXT, 253, 59,
	FONT_NEXT, 202, 68,
	FONT_NEXT, 153, 101,
	FONT_NEXT, 132, 130,
	FONT_NEXT, 114, 168,
	FONT_NEXT, 101, 216,
	FONT_NEXT, 94, 277,
	FONT_NEXT, 405, 277,
	FONT_NEXT, 398, 322,
	FONT_NEXT, 386, 360,
	FONT_NEXT, 348, 417,
	FONT_NEXT, 294, 449,
	FONT_NEXT, 229, 460,
	FONT_NEXT, 163, 447,
	FONT_NEXT, 129, 430,
	FONT_NEXT, 97, 406,
	FONT_NEXT, 68, 373,
	FONT_NEXT, 45, 330,
	FONT_NEXT, 30, 277,
	FONT_NEXT, 25, 214,
	FONT_NEXT, 28, 163,
	FONT_NEXT, 38, 119,
	FONT_NEXT, 54, 80,
	FONT_NEXT, 76, 48,
	FONT_NEXT, 104, 23,
	FONT_NEXT, 135, 5,
	FONT_NEXT, 172, -7,
	FONT_NEXT, 212, -10,
	FONT_NEXT, 262, -5,
	FONT_NEXT, 304, 11,
	FONT_NEXT, 368, 61,
	FONT_NEXT, 406, 117,
	FONT_NEXT, 417, 140,
	FONT_NEXT, 424, 157,
	FONT_END, 408, 164,
	FONT_BEGIN, 113, 364,
	FONT_NEXT, 137, 399,
	FONT_NEXT, 168, 418,
	FONT_NEXT, 207, 424,
	FONT_NEXT, 254, 412,
	FONT_NEXT, 282, 384,
	FONT_NEXT, 303, 309,
	FONT_END, 97, 309,
	FONT_ADVANCE, 444, 0
    },
    {
	102,
	FONT_BEGIN, 186, 450,
	FONT_NEXT, 186, 566,
	FONT_NEXT, 195, 624,
	FONT_NEXT, 213, 646,
	FONT_NEXT, 246, 655,
	FONT_NEXT, 340, 580,
	FONT_NEXT, 369, 590,
	FONT_NEXT, 379, 603,
	FONT_NEXT, 383, 622,
	FONT_NEXT, 375, 645,
	FONT_NEXT, 354, 665,
	FONT_NEXT, 322, 678,
	FONT_NEXT, 283, 683,
	FONT_NEXT, 223, 675,
	FONT_NEXT, 178, 654,
	FONT_NEXT, 146, 624,
	FONT_NEXT, 125, 587,
	FONT_NEXT, 105, 510,
	FONT_NEXT, 103, 476,
	FONT_NEXT, 103, 450,
	FONT_NEXT, 21, 450,
	FONT_NEXT, 21, 418,
	FONT_NEXT, 103, 418,
	FONT_NEXT, 103, 104,
	FONT_NEXT, 99, 58,
	FONT_NEXT, 86, 31,
	FONT_NEXT, 60, 19,
	FONT_NEXT, 20, 15,
	FONT_NEXT, 20, 0,
	FONT_NEXT, 280, 0,
	FONT_NEXT, 280, 15,
	FONT_NEXT, 226, 21,
	FONT_NEXT, 199, 37,
	FONT_NEXT, 188, 64,
	FONT_NEXT, 187, 104,
	FONT_NEXT, 187, 418,
	FONT_NEXT, 309, 418,
	FONT_END, 309, 450,
	FONT_ADVANCE, 333, 0
    },
    {
	103,
	FONT_BEGIN, 110, -49,
	FONT_NEXT, 147, -2,
	FONT_NEXT, 210, -12,
	FONT_NEXT, 251, -14,
	FONT_NEXT, 310, -15,
	FONT_NEXT, 360, -18,
	FONT_NEXT, 399, -24,
	FONT_NEXT, 424, -38,
	FONT_NEXT, 433, -64,
	FONT_NEXT, 420, -102,
	FONT_NEXT, 384, -133,
	FONT_NEXT, 326, -154,
	FONT_NEXT, 248, -161,
	FONT_NEXT, 176, -155,
	FONT_NEXT, 130, -138,
	FONT_NEXT, 105, -115,
	FONT_END, 98, -90,
	FONT_BEGIN, 158, 384,
	FONT_NEXT, 176, 412,
	FONT_NEXT, 200, 427,
	FONT_NEXT, 227, 432,
	FONT_NEXT, 256, 426,
	FONT_NEXT, 279, 410,
	FONT_NEXT, 310, 361,
	FONT_NEXT, 325, 307,
	FONT_NEXT, 329, 270,
	FONT_NEXT, 327, 245,
	FONT_NEXT, 318, 213,
	FONT_NEXT, 296, 185,
	FONT_NEXT, 256, 174,
	FONT_NEXT, 229, 177,
	FONT_NEXT, 206, 189,
	FONT_NEXT, 174, 228,
	FONT_NEXT, 157, 282,
	FONT_END, 152, 342,
	FONT_BEGIN, 470, 427,
	FONT_NEXT, 393, 427,
	FONT_NEXT, 338, 437,
	FONT_NEXT, 287, 454,
	FONT_NEXT, 241, 460,
	FONT_NEXT, 182, 450,
	FONT_NEXT, 126, 421,
	FONT_NEXT, 85, 369,
	FONT_NEXT, 73, 334,
	FONT_NEXT, 69, 293,
	FONT_NEXT, 75, 251,
	FONT_NEXT, 93, 216,
	FONT_NEXT, 122, 186,
	FONT_NEXT, 162, 163,
	FONT_NEXT, 132, 136,
	FONT_NEXT, 110, 115,
	FONT_NEXT, 84, 85,
	FONT_NEXT, 74, 67,
	FONT_NEXT, 73, 54,
	FONT_NEXT, 77, 35,
	FONT_NEXT, 89, 21,
	FONT_NEXT, 126, 1,
	FONT_NEXT, 57, -57,
	FONT_NEXT, 36, -89,
	FONT_NEXT, 28, -121,
	FONT_NEXT, 41, -159,
	FONT_NEXT, 78, -190,
	FONT_NEXT, 134, -211,
	FONT_NEXT, 205, -218,
	FONT_NEXT, 282, -208,
	FONT_NEXT, 366, -176,
	FONT_NEXT, 403, -153,
	FONT_NEXT, 433, -124,
	FONT_NEXT, 453, -89,
	FONT_NEXT, 461, -49,
	FONT_NEXT, 457, -22,
	FONT_NEXT, 440, 13,
	FONT_NEXT, 404, 43,
	FONT_NEXT, 375, 53,
	FONT_NEXT, 340, 58,
	FONT_NEXT, 211, 64,
	FONT_NEXT, 160, 69,
	FONT_NEXT, 140, 77,
	FONT_NEXT, 133, 91,
	FONT_NEXT, 139, 109,
	FONT_NEXT, 155, 129,
	FONT_NEXT, 175, 146,
	FONT_NEXT, 193, 154,
	FONT_NEXT, 247, 149,
	FONT_NEXT, 295, 156,
	FONT_NEXT, 347, 182,
	FONT_NEXT, 389, 227,
	FONT_NEXT, 401, 258,
	FONT_NEXT, 406, 296,
	FONT_NEXT, 404, 328,
	FONT_NEXT, 400, 352,
	FONT_NEXT, 387, 388,
	FONT_END, 470, 388,
	FONT_ADVANCE, 500, 0
    },
    {
	104,
	FONT_BEGIN, 456, 22,
	FONT_NEXT, 438, 34,
	FONT_NEXT, 429, 58,
	FONT_NEXT, 427, 102,
	FONT_NEXT, 427, 301,
	FONT_NEXT, 424, 342,
	FONT_NEXT, 411, 395,
	FONT_NEXT, 396, 420,
	FONT_NEXT, 374, 440,
	FONT_NEXT, 343, 454,
	FONT_NEXT, 303, 460,
	FONT_NEXT, 260, 454,
	FONT_NEXT, 221, 437,
	FONT_NEXT, 187, 411,
	FONT_NEXT, 159, 378,
	FONT_NEXT, 157, 378,
	FONT_NEXT, 157, 680,
	FONT_NEXT, 152, 683,
	FONT_NEXT, 10, 639,
	FONT_NEXT, 10, 623,
	FONT_NEXT, 29, 624,
	FONT_NEXT, 54, 620,
	FONT_NEXT, 67, 609,
	FONT_NEXT, 73, 573,
	FONT_NEXT, 73, 102,
	FONT_NEXT, 70, 58,
	FONT_NEXT, 61, 33,
	FONT_NEXT, 41, 21,
	FONT_NEXT, 9, 15,
	FONT_NEXT, 9, 0,
	FONT_NEXT, 225, 0,
	FONT_NEXT, 225, 15,
	FONT_NEXT, 193, 19,
	FONT_NEXT, 172, 31,
	FONT_NEXT, 160, 56,
	FONT_NEXT, 157, 102,
	FONT_NEXT, 157, 343,
	FONT_NEXT, 187, 373,
	FONT_NEXT, 216, 392,
	FONT_NEXT, 266, 406,
	FONT_NEXT, 301, 398,
	FONT_NEXT, 325, 378,
	FONT_NEXT, 338, 344,
	FONT_NEXT, 343, 300,
	FONT_NEXT, 343, 102,
	FONT_NEXT, 339, 56,
	FONT_NEXT, 327, 31,
	FONT_NEXT, 306, 19,
	FONT_NEXT, 275, 15,
	FONT_NEXT, 275, 0,
	FONT_NEXT, 487, 0,
	FONT_END, 487, 15,
	FONT_ADVANCE, 500, 0
    },
    {
	105,
	FONT_BEGIN, 253, 0,
	FONT_NEXT, 253, 15,
	FONT_NEXT, 212, 21,
	FONT_NEXT, 190, 35,
	FONT_NEXT, 180, 61,
	FONT_NEXT, 179, 102,
	FONT_NEXT, 179, 457,
	FONT_NEXT, 175, 460,
	FONT_NEXT, 20, 405,
	FONT_NEXT, 20, 390,
	FONT_NEXT, 60, 394,
	FONT_NEXT, 83, 386,
	FONT_NEXT, 91, 368,
	FONT_NEXT, 95, 334,
	FONT_NEXT, 95, 102,
	FONT_NEXT, 91, 55,
	FONT_NEXT, 78, 30,
	FONT_NEXT, 54, 18,
	FONT_NEXT, 16, 15,
	FONT_END, 16, 0,
	FONT_BEGIN, 89, 599,
	FONT_NEXT, 105, 586,
	FONT_NEXT, 128, 581,
	FONT_NEXT, 148, 584,
	FONT_NEXT, 165, 595,
	FONT_NEXT, 176, 611,
	FONT_NEXT, 180, 632,
	FONT_NEXT, 165, 668,
	FONT_NEXT, 148, 678,
	FONT_NEXT, 128, 683,
	FONT_NEXT, 105, 677,
	FONT_NEXT, 89, 664,
	FONT_END, 78, 632,
	FONT_ADVANCE, 278, 0
    },
    {
	106,
	FONT_BEGIN, 108, -102,
	FONT_NEXT, 102, -146,
	FONT_NEXT, 87, -174,
	FONT_NEXT, 59, -184,
	FONT_NEXT, -30, -124,
	FONT_NEXT, -58, -135,
	FONT_NEXT, -70, -162,
	FONT_NEXT, -63, -187,
	FONT_NEXT, -42, -204,
	FONT_NEXT, -12, -215,
	FONT_NEXT, 23, -218,
	FONT_NEXT, 67, -214,
	FONT_NEXT, 103, -201,
	FONT_NEXT, 133, -180,
	FONT_NEXT, 156, -153,
	FONT_NEXT, 184, -84,
	FONT_NEXT, 193, 0,
	FONT_NEXT, 193, 457,
	FONT_NEXT, 188, 460,
	FONT_NEXT, 32, 406,
	FONT_NEXT, 32, 390,
	FONT_NEXT, 74, 394,
	FONT_NEXT, 97, 386,
	FONT_NEXT, 105, 368,
	FONT_NEXT, 109, 334,
	FONT_END, 109, -45,
	FONT_BEGIN, 103, 599,
	FONT_NEXT, 119, 586,
	FONT_NEXT, 142, 581,
	FONT_NEXT, 162, 584,
	FONT_NEXT, 179, 595,
	FONT_NEXT, 190, 611,
	FONT_NEXT, 194, 632,
	FONT_NEXT, 179, 668,
	FONT_NEXT, 162, 678,
	FONT_NEXT, 142, 683,
	FONT_NEXT, 119, 677,
	FONT_NEXT, 103, 664,
	FONT_END, 92, 632,
	FONT_ADVANCE, 278, 0
    },
    {
	107,
	FONT_BEGIN, 241, 0,
	FONT_NEXT, 241, 15,
	FONT_NEXT, 221, 16,
	FONT_NEXT, 181, 26,
	FONT_NEXT, 169, 42,
	FONT_NEXT, 166, 67,
	FONT_NEXT, 166, 248,
	FONT_NEXT, 168, 248,
	FONT_NEXT, 306, 64,
	FONT_NEXT, 321, 43,
	FONT_NEXT, 327, 31,
	FONT_NEXT, 319, 18,
	FONT_NEXT, 306, 15,
	FONT_NEXT, 287, 15,
	FONT_NEXT, 287, 0,
	FONT_NEXT, 505, 0,
	FONT_NEXT, 505, 15,
	FONT_NEXT, 482, 18,
	FONT_NEXT, 455, 28,
	FONT_NEXT, 424, 49,
	FONT_NEXT, 388, 88,
	FONT_NEXT, 235, 282,
	FONT_NEXT, 264, 309,
	FONT_NEXT, 309, 350,
	FONT_NEXT, 347, 381,
	FONT_NEXT, 377, 404,
	FONT_NEXT, 402, 419,
	FONT_NEXT, 442, 433,
	FONT_NEXT, 480, 435,
	FONT_NEXT, 480, 450,
	FONT_NEXT, 276, 450,
	FONT_NEXT, 276, 436,
	FONT_NEXT, 301, 434,
	FONT_NEXT, 316, 430,
	FONT_NEXT, 326, 417,
	FONT_NEXT, 320, 401,
	FONT_NEXT, 303, 383,
	FONT_NEXT, 168, 263,
	FONT_NEXT, 166, 265,
	FONT_NEXT, 166, 681,
	FONT_NEXT, 162, 683,
	FONT_NEXT, 7, 639,
	FONT_NEXT, 7, 623,
	FONT_NEXT, 37, 625,
	FONT_NEXT, 60, 621,
	FONT_NEXT, 74, 611,
	FONT_NEXT, 80, 592,
	FONT_NEXT, 82, 564,
	FONT_NEXT, 82, 82,
	FONT_NEXT, 79, 50,
	FONT_NEXT, 69, 32,
	FONT_NEXT, 46, 22,
	FONT_NEXT, 7, 15,
	FONT_END, 7, 0,
	FONT_ADVANCE, 500, 0
    },
    {
	108,
	FONT_BEGIN, 257, 0,
	FONT_NEXT, 257, 15,
	FONT_NEXT, 220, 18,
	FONT_NEXT, 197, 28,
	FONT_NEXT, 185, 49,
	FONT_NEXT, 182, 84,
	FONT_NEXT, 182, 681,
	FONT_NEXT, 178, 683,
	FONT_NEXT, 19, 639,
	FONT_NEXT, 19, 623,
	FONT_NEXT, 53, 625,
	FONT_NEXT, 76, 621,
	FONT_NEXT, 90, 611,
	FONT_NEXT, 96, 592,
	FONT_NEXT, 98, 564,
	FONT_NEXT, 98, 87,
	FONT_NEXT, 94, 53,
	FONT_NEXT, 81, 31,
	FONT_NEXT, 57, 20,
	FONT_NEXT, 21, 15,
	FONT_END, 21, 0,
	FONT_ADVANCE, 278, 0
    },
    {
	109,
	FONT_BEGIN, 80, 45,
	FONT_NEXT, 66, 25,
	FONT_NEXT, 43, 16,
	FONT_NEXT, 16, 15,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 238, 0,
	FONT_NEXT, 238, 15,
	FONT_NEXT, 190, 23,
	FONT_NEXT, 175, 38,
	FONT_NEXT, 170, 67,
	FONT_NEXT, 170, 349,
	FONT_NEXT, 178, 360,
	FONT_NEXT, 201, 380,
	FONT_NEXT, 237, 399,
	FONT_NEXT, 285, 408,
	FONT_NEXT, 317, 400,
	FONT_NEXT, 339, 380,
	FONT_NEXT, 350, 347,
	FONT_NEXT, 354, 303,
	FONT_NEXT, 354, 86,
	FONT_NEXT, 349, 47,
	FONT_NEXT, 336, 27,
	FONT_NEXT, 315, 18,
	FONT_NEXT, 286, 15,
	FONT_NEXT, 286, 0,
	FONT_NEXT, 510, 0,
	FONT_NEXT, 510, 15,
	FONT_NEXT, 481, 17,
	FONT_NEXT, 458, 26,
	FONT_NEXT, 443, 50,
	FONT_NEXT, 438, 95,
	FONT_NEXT, 438, 347,
	FONT_NEXT, 481, 390,
	FONT_NEXT, 511, 403,
	FONT_NEXT, 549, 408,
	FONT_NEXT, 590, 397,
	FONT_NEXT, 612, 372,
	FONT_NEXT, 622, 298,
	FONT_NEXT, 622, 87,
	FONT_NEXT, 618, 49,
	FONT_NEXT, 607, 29,
	FONT_NEXT, 587, 19,
	FONT_NEXT, 556, 15,
	FONT_NEXT, 556, 0,
	FONT_NEXT, 775, 0,
	FONT_NEXT, 775, 15,
	FONT_NEXT, 749, 17,
	FONT_NEXT, 723, 26,
	FONT_NEXT, 711, 40,
	FONT_NEXT, 706, 76,
	FONT_NEXT, 706, 282,
	FONT_NEXT, 702, 341,
	FONT_NEXT, 686, 398,
	FONT_NEXT, 650, 442,
	FONT_NEXT, 622, 455,
	FONT_NEXT, 588, 460,
	FONT_NEXT, 532, 450,
	FONT_NEXT, 485, 427,
	FONT_NEXT, 449, 399,
	FONT_NEXT, 427, 376,
	FONT_NEXT, 414, 406,
	FONT_NEXT, 393, 433,
	FONT_NEXT, 362, 452,
	FONT_NEXT, 320, 460,
	FONT_NEXT, 281, 454,
	FONT_NEXT, 244, 438,
	FONT_NEXT, 166, 383,
	FONT_NEXT, 166, 458,
	FONT_NEXT, 159, 460,
	FONT_NEXT, 19, 415,
	FONT_NEXT, 19, 398,
	FONT_NEXT, 51, 402,
	FONT_NEXT, 74, 393,
	FONT_NEXT, 82, 374,
	FONT_NEXT, 86, 338,
	FONT_END, 86, 85,
	FONT_ADVANCE, 778, 0
    },
    {
	110,
	FONT_BEGIN, 76, 53,
	FONT_NEXT, 66, 31,
	FONT_NEXT, 47, 19,
	FONT_NEXT, 18, 15,
	FONT_NEXT, 18, 0,
	FONT_NEXT, 230, 0,
	FONT_NEXT, 230, 15,
	FONT_NEXT, 197, 19,
	FONT_NEXT, 177, 29,
	FONT_NEXT, 167, 45,
	FONT_NEXT, 164, 67,
	FONT_NEXT, 164, 348,
	FONT_NEXT, 216, 390,
	FONT_NEXT, 263, 405,
	FONT_NEXT, 299, 398,
	FONT_NEXT, 323, 379,
	FONT_NEXT, 336, 348,
	FONT_NEXT, 340, 308,
	FONT_NEXT, 340, 99,
	FONT_NEXT, 335, 54,
	FONT_NEXT, 322, 29,
	FONT_NEXT, 302, 18,
	FONT_NEXT, 277, 15,
	FONT_NEXT, 277, 0,
	FONT_NEXT, 485, 0,
	FONT_NEXT, 485, 15,
	FONT_NEXT, 454, 20,
	FONT_NEXT, 436, 31,
	FONT_NEXT, 426, 51,
	FONT_NEXT, 424, 81,
	FONT_NEXT, 424, 310,
	FONT_NEXT, 420, 351,
	FONT_NEXT, 412, 385,
	FONT_NEXT, 382, 431,
	FONT_NEXT, 344, 453,
	FONT_NEXT, 307, 460,
	FONT_NEXT, 266, 453,
	FONT_NEXT, 230, 436,
	FONT_NEXT, 161, 379,
	FONT_NEXT, 161, 458,
	FONT_NEXT, 154, 460,
	FONT_NEXT, 16, 415,
	FONT_NEXT, 16, 398,
	FONT_NEXT, 45, 402,
	FONT_NEXT, 68, 393,
	FONT_NEXT, 76, 374,
	FONT_NEXT, 80, 338,
	FONT_END, 80, 90,
	FONT_ADVANCE, 500, 0
    },
    {
	111,
	FONT_BEGIN, 197, 455,
	FONT_NEXT, 154, 441,
	FONT_NEXT, 117, 419,
	FONT_NEXT, 86, 390,
	FONT_NEXT, 62, 355,
	FONT_NEXT, 43, 316,
	FONT_NEXT, 29, 228,
	FONT_NEXT, 33, 179,
	FONT_NEXT, 45, 133,
	FONT_NEXT, 64, 93,
	FONT_NEXT, 90, 58,
	FONT_NEXT, 122, 29,
	FONT_NEXT, 159, 8,
	FONT_NEXT, 201, -6,
	FONT_NEXT, 248, -10,
	FONT_NEXT, 301, -4,
	FONT_NEXT, 346, 13,
	FONT_NEXT, 385, 39,
	FONT_NEXT, 416, 71,
	FONT_NEXT, 456, 149,
	FONT_NEXT, 470, 228,
	FONT_NEXT, 465, 279,
	FONT_NEXT, 453, 325,
	FONT_NEXT, 433, 365,
	FONT_NEXT, 406, 398,
	FONT_NEXT, 373, 424,
	FONT_NEXT, 335, 444,
	FONT_NEXT, 292, 455,
	FONT_END, 245, 460,
	FONT_BEGIN, 221, 26,
	FONT_NEXT, 189, 47,
	FONT_NEXT, 164, 80,
	FONT_NEXT, 145, 119,
	FONT_NEXT, 124, 204,
	FONT_NEXT, 119, 276,
	FONT_NEXT, 128, 344,
	FONT_NEXT, 154, 393,
	FONT_NEXT, 191, 422,
	FONT_NEXT, 237, 432,
	FONT_NEXT, 269, 427,
	FONT_NEXT, 298, 413,
	FONT_NEXT, 322, 390,
	FONT_NEXT, 343, 362,
	FONT_NEXT, 370, 287,
	FONT_NEXT, 380, 199,
	FONT_NEXT, 377, 150,
	FONT_NEXT, 368, 110,
	FONT_NEXT, 356, 78,
	FONT_NEXT, 340, 54,
	FONT_NEXT, 301, 26,
	FONT_END, 262, 18,
	FONT_ADVANCE, 500, 0
    },
    {
	112,
	FONT_BEGIN, 73, -160,
	FONT_NEXT, 64, -180,
	FONT_NEXT, 43, -194,
	FONT_NEXT, 5, -200,
	FONT_NEXT, 5, -217,
	FONT_NEXT, 247, -217,
	FONT_NEXT, 247, -199,
	FONT_NEXT, 202, -197,
	FONT_NEXT, 176, -186,
	FONT_NEXT, 162, -163,
	FONT_NEXT, 159, -124,
	FONT_NEXT, 159, 33,
	FONT_NEXT, 206, -1,
	FONT_NEXT, 260, -10,
	FONT_NEXT, 308, -4,
	FONT_NEXT, 351, 13,
	FONT_NEXT, 387, 40,
	FONT_NEXT, 417, 74,
	FONT_NEXT, 456, 156,
	FONT_NEXT, 470, 245,
	FONT_NEXT, 466, 292,
	FONT_NEXT, 456, 334,
	FONT_NEXT, 420, 402,
	FONT_NEXT, 368, 445,
	FONT_NEXT, 305, 460,
	FONT_NEXT, 252, 451,
	FONT_NEXT, 212, 432,
	FONT_NEXT, 181, 406,
	FONT_NEXT, 161, 383,
	FONT_NEXT, 159, 385,
	FONT_NEXT, 159, 458,
	FONT_NEXT, 153, 460,
	FONT_NEXT, 9, 409,
	FONT_NEXT, 9, 393,
	FONT_NEXT, 37, 394,
	FONT_NEXT, 57, 390,
	FONT_NEXT, 69, 380,
	FONT_NEXT, 73, 362,
	FONT_NEXT, 75, 337,
	FONT_END, 75, -131,
	FONT_BEGIN, 171, 360,
	FONT_NEXT, 196, 381,
	FONT_NEXT, 227, 395,
	FONT_NEXT, 257, 400,
	FONT_NEXT, 297, 392,
	FONT_NEXT, 328, 374,
	FONT_NEXT, 350, 347,
	FONT_NEXT, 366, 316,
	FONT_NEXT, 381, 253,
	FONT_NEXT, 383, 229,
	FONT_NEXT, 384, 215,
	FONT_NEXT, 380, 156,
	FONT_NEXT, 369, 111,
	FONT_NEXT, 353, 77,
	FONT_NEXT, 334, 53,
	FONT_NEXT, 294, 27,
	FONT_NEXT, 261, 22,
	FONT_NEXT, 221, 29,
	FONT_NEXT, 189, 46,
	FONT_NEXT, 167, 67,
	FONT_NEXT, 159, 88,
	FONT_END, 159, 334,
	FONT_ADVANCE, 500, 0
    },
    {
	113,
	FONT_BEGIN, 308, 450,
	FONT_NEXT, 247, 460,
	FONT_NEXT, 201, 455,
	FONT_NEXT, 159, 440,
	FONT_NEXT, 121, 417,
	FONT_NEXT, 88, 387,
	FONT_NEXT, 61, 351,
	FONT_NEXT, 41, 308,
	FONT_NEXT, 28, 262,
	FONT_NEXT, 24, 212,
	FONT_NEXT, 27, 159,
	FONT_NEXT, 37, 113,
	FONT_NEXT, 52, 75,
	FONT_NEXT, 72, 44,
	FONT_NEXT, 124, 3,
	FONT_NEXT, 188, -10,
	FONT_NEXT, 234, -3,
	FONT_NEXT, 278, 14,
	FONT_NEXT, 314, 38,
	FONT_NEXT, 336, 62,
	FONT_NEXT, 341, 62,
	FONT_NEXT, 341, -124,
	FONT_NEXT, 337, -157,
	FONT_NEXT, 324, -180,
	FONT_NEXT, 297, -194,
	FONT_NEXT, 252, -200,
	FONT_NEXT, 252, -217,
	FONT_NEXT, 488, -217,
	FONT_NEXT, 488, -203,
	FONT_NEXT, 459, -196,
	FONT_NEXT, 439, -187,
	FONT_NEXT, 428, -170,
	FONT_NEXT, 425, -141,
	FONT_NEXT, 425, 456,
	FONT_NEXT, 421, 460,
	FONT_NEXT, 414, 457,
	FONT_END, 360, 425,
	FONT_BEGIN, 333, 88,
	FONT_NEXT, 318, 73,
	FONT_NEXT, 288, 60,
	FONT_NEXT, 238, 51,
	FONT_NEXT, 206, 55,
	FONT_NEXT, 180, 67,
	FONT_NEXT, 140, 110,
	FONT_NEXT, 117, 169,
	FONT_NEXT, 110, 238,
	FONT_NEXT, 119, 319,
	FONT_NEXT, 147, 380,
	FONT_NEXT, 189, 418,
	FONT_NEXT, 245, 432,
	FONT_NEXT, 276, 428,
	FONT_NEXT, 300, 420,
	FONT_NEXT, 328, 393,
	FONT_NEXT, 339, 360,
	FONT_NEXT, 341, 333,
	FONT_END, 341, 127,
	FONT_ADVANCE, 500, 0
    },
    {
	114,
	FONT_BEGIN, 72, 51,
	FONT_NEXT, 61, 32,
	FONT_NEXT, 39, 22,
	FONT_NEXT, 5, 15,
	FONT_NEXT, 5, 0,
	FONT_NEXT, 245, 0,
	FONT_NEXT, 245, 15,
	FONT_NEXT, 210, 17,
	FONT_NEXT, 183, 27,
	FONT_NEXT, 166, 49,
	FONT_NEXT, 160, 90,
	FONT_NEXT, 160, 315,
	FONT_NEXT, 167, 341,
	FONT_NEXT, 185, 368,
	FONT_NEXT, 207, 388,
	FONT_NEXT, 228, 397,
	FONT_NEXT, 258, 379,
	FONT_NEXT, 274, 367,
	FONT_NEXT, 297, 362,
	FONT_NEXT, 325, 374,
	FONT_NEXT, 335, 406,
	FONT_NEXT, 331, 428,
	FONT_NEXT, 320, 445,
	FONT_NEXT, 303, 456,
	FONT_NEXT, 281, 460,
	FONT_NEXT, 252, 455,
	FONT_NEXT, 224, 441,
	FONT_NEXT, 195, 413,
	FONT_NEXT, 162, 369,
	FONT_NEXT, 160, 369,
	FONT_NEXT, 160, 458,
	FONT_NEXT, 155, 460,
	FONT_NEXT, 7, 406,
	FONT_NEXT, 7, 390,
	FONT_NEXT, 41, 394,
	FONT_NEXT, 64, 386,
	FONT_NEXT, 72, 368,
	FONT_NEXT, 76, 334,
	FONT_END, 76, 84,
	FONT_ADVANCE, 333, 0
    },
    {
	115,
	FONT_BEGIN, 311, 451,
	FONT_NEXT, 300, 451,
	FONT_NEXT, 283, 440,
	FONT_NEXT, 247, 450,
	FONT_NEXT, 191, 460,
	FONT_NEXT, 128, 448,
	FONT_NEXT, 84, 420,
	FONT_NEXT, 59, 380,
	FONT_NEXT, 51, 338,
	FONT_NEXT, 60, 288,
	FONT_NEXT, 86, 250,
	FONT_NEXT, 123, 219,
	FONT_NEXT, 168, 192,
	FONT_NEXT, 226, 159,
	FONT_NEXT, 264, 127,
	FONT_NEXT, 278, 85,
	FONT_NEXT, 270, 49,
	FONT_NEXT, 250, 27,
	FONT_NEXT, 224, 15,
	FONT_NEXT, 197, 12,
	FONT_NEXT, 163, 15,
	FONT_NEXT, 137, 26,
	FONT_NEXT, 100, 62,
	FONT_NEXT, 79, 107,
	FONT_NEXT, 68, 152,
	FONT_NEXT, 52, 152,
	FONT_NEXT, 52, -4,
	FONT_NEXT, 65, -4,
	FONT_NEXT, 73, 5,
	FONT_NEXT, 87, 8,
	FONT_NEXT, 138, -1,
	FONT_NEXT, 203, -10,
	FONT_NEXT, 252, -3,
	FONT_NEXT, 299, 21,
	FONT_NEXT, 334, 62,
	FONT_NEXT, 348, 119,
	FONT_NEXT, 341, 158,
	FONT_NEXT, 324, 189,
	FONT_NEXT, 264, 237,
	FONT_NEXT, 156, 301,
	FONT_NEXT, 133, 318,
	FONT_NEXT, 120, 337,
	FONT_NEXT, 113, 372,
	FONT_NEXT, 117, 393,
	FONT_NEXT, 130, 414,
	FONT_NEXT, 153, 430,
	FONT_NEXT, 189, 437,
	FONT_NEXT, 221, 432,
	FONT_NEXT, 252, 413,
	FONT_NEXT, 279, 376,
	FONT_NEXT, 300, 314,
	FONT_END, 315, 314,
	FONT_ADVANCE, 389, 0
    },
    {
	116,
	FONT_BEGIN, 154, 450,
	FONT_NEXT, 154, 566,
	FONT_NEXT, 147, 579,
	FONT_NEXT, 122, 544,
	FONT_NEXT, 102, 516,
	FONT_NEXT, 57, 465,
	FONT_NEXT, 26, 441,
	FONT_NEXT, 13, 425,
	FONT_NEXT, 17, 418,
	FONT_NEXT, 70, 418,
	FONT_NEXT, 70, 117,
	FONT_NEXT, 77, 54,
	FONT_NEXT, 96, 16,
	FONT_NEXT, 126, -5,
	FONT_NEXT, 162, -10,
	FONT_NEXT, 196, -5,
	FONT_NEXT, 228, 11,
	FONT_NEXT, 257, 35,
	FONT_NEXT, 279, 66,
	FONT_NEXT, 266, 77,
	FONT_NEXT, 243, 54,
	FONT_NEXT, 205, 42,
	FONT_NEXT, 175, 51,
	FONT_NEXT, 160, 75,
	FONT_NEXT, 154, 132,
	FONT_NEXT, 154, 418,
	FONT_NEXT, 255, 418,
	FONT_END, 255, 450,
	FONT_ADVANCE, 278, 0
    },
    {
	117,
	FONT_BEGIN, 444, 53,
	FONT_NEXT, 425, 64,
	FONT_NEXT, 418, 82,
	FONT_NEXT, 417, 107,
	FONT_NEXT, 417, 450,
	FONT_NEXT, 259, 450,
	FONT_NEXT, 259, 433,
	FONT_NEXT, 300, 427,
	FONT_NEXT, 322, 415,
	FONT_NEXT, 331, 396,
	FONT_NEXT, 333, 370,
	FONT_NEXT, 333, 135,
	FONT_NEXT, 328, 100,
	FONT_NEXT, 317, 84,
	FONT_NEXT, 274, 57,
	FONT_NEXT, 230, 48,
	FONT_NEXT, 190, 57,
	FONT_NEXT, 167, 80,
	FONT_NEXT, 157, 106,
	FONT_NEXT, 155, 124,
	FONT_NEXT, 155, 450,
	FONT_NEXT, 9, 450,
	FONT_NEXT, 9, 436,
	FONT_NEXT, 51, 425,
	FONT_NEXT, 65, 407,
	FONT_NEXT, 71, 372,
	FONT_NEXT, 71, 120,
	FONT_NEXT, 74, 83,
	FONT_NEXT, 83, 54,
	FONT_NEXT, 115, 15,
	FONT_NEXT, 154, -5,
	FONT_NEXT, 190, -10,
	FONT_NEXT, 208, -9,
	FONT_NEXT, 234, -4,
	FONT_NEXT, 264, 9,
	FONT_NEXT, 295, 33,
	FONT_NEXT, 338, 76,
	FONT_NEXT, 338, -7,
	FONT_NEXT, 340, -9,
	FONT_NEXT, 479, 36,
	FONT_END, 479, 50,
	FONT_ADVANCE, 500, 0
    },
    {
	118,
	FONT_BEGIN, 338, 450,
	FONT_NEXT, 338, 435,
	FONT_NEXT, 370, 426,
	FONT_NEXT, 385, 402,
	FONT_NEXT, 381, 383,
	FONT_NEXT, 373, 355,
	FONT_NEXT, 345, 280,
	FONT_NEXT, 280, 114,
	FONT_NEXT, 178, 370,
	FONT_NEXT, 169, 405,
	FONT_NEXT, 172, 419,
	FONT_NEXT, 183, 428,
	FONT_NEXT, 215, 435,
	FONT_NEXT, 215, 450,
	FONT_NEXT, 19, 450,
	FONT_NEXT, 19, 435,
	FONT_NEXT, 48, 427,
	FONT_NEXT, 74, 398,
	FONT_NEXT, 90, 364,
	FONT_NEXT, 110, 319,
	FONT_NEXT, 156, 212,
	FONT_NEXT, 200, 106,
	FONT_NEXT, 217, 63,
	FONT_NEXT, 230, 33,
	FONT_NEXT, 239, 7,
	FONT_NEXT, 246, -7,
	FONT_NEXT, 257, -14,
	FONT_NEXT, 269, 0,
	FONT_NEXT, 284, 36,
	FONT_NEXT, 412, 357,
	FONT_NEXT, 427, 393,
	FONT_NEXT, 440, 417,
	FONT_NEXT, 455, 429,
	FONT_NEXT, 477, 435,
	FONT_END, 477, 450,
	FONT_ADVANCE, 500, 0
    },
    {
	119,
	FONT_BEGIN, 571, 435,
	FONT_NEXT, 602, 425,
	FONT_NEXT, 611, 416,
	FONT_NEXT, 615, 402,
	FONT_NEXT, 610, 374,
	FONT_NEXT, 598, 338,
	FONT_NEXT, 508, 116,
	FONT_NEXT, 428, 330,
	FONT_NEXT, 411, 371,
	FONT_NEXT, 407, 398,
	FONT_NEXT, 411, 415,
	FONT_NEXT, 423, 425,
	FONT_NEXT, 465, 435,
	FONT_NEXT, 465, 450,
	FONT_NEXT, 262, 450,
	FONT_NEXT, 262, 435,
	FONT_NEXT, 288, 429,
	FONT_NEXT, 308, 413,
	FONT_NEXT, 327, 376,
	FONT_NEXT, 338, 347,
	FONT_NEXT, 351, 310,
	FONT_NEXT, 260, 111,
	FONT_NEXT, 224, 205,
	FONT_NEXT, 190, 290,
	FONT_NEXT, 164, 358,
	FONT_NEXT, 157, 383,
	FONT_NEXT, 155, 401,
	FONT_NEXT, 158, 417,
	FONT_NEXT, 169, 427,
	FONT_NEXT, 201, 435,
	FONT_NEXT, 201, 450,
	FONT_NEXT, 21, 450,
	FONT_NEXT, 21, 435,
	FONT_NEXT, 49, 420,
	FONT_NEXT, 60, 401,
	FONT_NEXT, 74, 372,
	FONT_NEXT, 209, 30,
	FONT_NEXT, 217, 8,
	FONT_NEXT, 224, -5,
	FONT_NEXT, 235, -14,
	FONT_NEXT, 244, -5,
	FONT_NEXT, 260, 25,
	FONT_NEXT, 372, 265,
	FONT_NEXT, 463, 29,
	FONT_NEXT, 471, 7,
	FONT_NEXT, 477, -6,
	FONT_NEXT, 487, -14,
	FONT_NEXT, 498, -5,
	FONT_NEXT, 505, 10,
	FONT_NEXT, 515, 35,
	FONT_NEXT, 653, 381,
	FONT_NEXT, 671, 419,
	FONT_NEXT, 694, 435,
	FONT_NEXT, 694, 450,
	FONT_END, 571, 450,
	FONT_ADVANCE, 722, 0
    },
    {
	120,
	FONT_BEGIN, 311, 60,
	FONT_NEXT, 318, 41,
	FONT_NEXT, 309, 20,
	FONT_NEXT, 278, 15,
	FONT_NEXT, 278, 0,
	FONT_NEXT, 479, 0,
	FONT_NEXT, 479, 15,
	FONT_NEXT, 445, 23,
	FONT_NEXT, 423, 41,
	FONT_NEXT, 397, 75,
	FONT_NEXT, 269, 271,
	FONT_NEXT, 352, 391,
	FONT_NEXT, 379, 417,
	FONT_NEXT, 403, 429,
	FONT_NEXT, 433, 435,
	FONT_NEXT, 433, 450,
	FONT_NEXT, 275, 450,
	FONT_NEXT, 275, 435,
	FONT_NEXT, 301, 431,
	FONT_NEXT, 311, 424,
	FONT_NEXT, 315, 412,
	FONT_NEXT, 313, 402,
	FONT_NEXT, 304, 386,
	FONT_NEXT, 284, 356,
	FONT_NEXT, 248, 304,
	FONT_NEXT, 210, 362,
	FONT_NEXT, 194, 391,
	FONT_NEXT, 188, 412,
	FONT_NEXT, 192, 424,
	FONT_NEXT, 202, 431,
	FONT_NEXT, 231, 435,
	FONT_NEXT, 231, 450,
	FONT_NEXT, 24, 450,
	FONT_NEXT, 24, 435,
	FONT_NEXT, 64, 428,
	FONT_NEXT, 83, 410,
	FONT_NEXT, 110, 375,
	FONT_NEXT, 204, 231,
	FONT_NEXT, 90, 66,
	FONT_NEXT, 68, 39,
	FONT_NEXT, 51, 24,
	FONT_NEXT, 17, 15,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 162, 0,
	FONT_NEXT, 162, 15,
	FONT_NEXT, 136, 17,
	FONT_NEXT, 122, 33,
	FONT_NEXT, 142, 74,
	FONT_NEXT, 221, 197,
	FONT_END, 302, 73,
	FONT_ADVANCE, 500, 0
    },
    {
	121,
	FONT_BEGIN, 340, 450,
	FONT_NEXT, 340, 435,
	FONT_NEXT, 376, 428,
	FONT_NEXT, 388, 407,
	FONT_NEXT, 380, 379,
	FONT_NEXT, 365, 339,
	FONT_NEXT, 287, 117,
	FONT_NEXT, 172, 370,
	FONT_NEXT, 162, 406,
	FONT_NEXT, 167, 421,
	FONT_NEXT, 182, 430,
	FONT_NEXT, 220, 435,
	FONT_NEXT, 220, 450,
	FONT_NEXT, 14, 450,
	FONT_NEXT, 14, 436,
	FONT_NEXT, 39, 428,
	FONT_NEXT, 65, 404,
	FONT_NEXT, 179, 158,
	FONT_NEXT, 194, 125,
	FONT_NEXT, 215, 83,
	FONT_NEXT, 233, 43,
	FONT_NEXT, 241, 20,
	FONT_NEXT, 239, 8,
	FONT_NEXT, 233, -11,
	FONT_NEXT, 214, -63,
	FONT_NEXT, 185, -113,
	FONT_NEXT, 167, -129,
	FONT_NEXT, 149, -134,
	FONT_NEXT, 118, -125,
	FONT_NEXT, 78, -116,
	FONT_NEXT, 51, -123,
	FONT_NEXT, 36, -136,
	FONT_NEXT, 30, -160,
	FONT_NEXT, 34, -181,
	FONT_NEXT, 47, -199,
	FONT_NEXT, 70, -213,
	FONT_NEXT, 103, -218,
	FONT_NEXT, 154, -206,
	FONT_NEXT, 197, -169,
	FONT_NEXT, 235, -106,
	FONT_NEXT, 273, -18,
	FONT_NEXT, 427, 390,
	FONT_NEXT, 439, 414,
	FONT_NEXT, 451, 427,
	FONT_NEXT, 475, 435,
	FONT_END, 475, 450,
	FONT_ADVANCE, 500, 0
    },
    {
	122,
	FONT_BEGIN, 400, 139,
	FONT_NEXT, 388, 89,
	FONT_NEXT, 369, 55,
	FONT_NEXT, 334, 36,
	FONT_NEXT, 307, 31,
	FONT_NEXT, 272, 30,
	FONT_NEXT, 134, 30,
	FONT_NEXT, 403, 435,
	FONT_NEXT, 403, 450,
	FONT_NEXT, 56, 450,
	FONT_NEXT, 53, 332,
	FONT_NEXT, 71, 332,
	FONT_NEXT, 76, 368,
	FONT_NEXT, 88, 396,
	FONT_NEXT, 112, 413,
	FONT_NEXT, 155, 420,
	FONT_NEXT, 293, 420,
	FONT_NEXT, 27, 15,
	FONT_NEXT, 27, 0,
	FONT_NEXT, 404, 0,
	FONT_END, 418, 135,
	FONT_ADVANCE, 444, 0
    },
    {
	123,
	FONT_BEGIN, 187, -82,
	FONT_NEXT, 196, -114,
	FONT_NEXT, 210, -139,
	FONT_NEXT, 228, -156,
	FONT_NEXT, 280, -176,
	FONT_NEXT, 350, -181,
	FONT_NEXT, 350, -170,
	FONT_NEXT, 305, -154,
	FONT_NEXT, 277, -129,
	FONT_NEXT, 263, -94,
	FONT_NEXT, 259, -47,
	FONT_NEXT, 259, 121,
	FONT_NEXT, 255, 168,
	FONT_NEXT, 242, 204,
	FONT_NEXT, 215, 230,
	FONT_NEXT, 168, 248,
	FONT_NEXT, 168, 250,
	FONT_NEXT, 215, 267,
	FONT_NEXT, 242, 294,
	FONT_NEXT, 255, 330,
	FONT_NEXT, 259, 378,
	FONT_NEXT, 259, 546,
	FONT_NEXT, 263, 592,
	FONT_NEXT, 277, 627,
	FONT_NEXT, 305, 652,
	FONT_NEXT, 350, 669,
	FONT_NEXT, 350, 680,
	FONT_NEXT, 280, 675,
	FONT_NEXT, 228, 655,
	FONT_NEXT, 210, 637,
	FONT_NEXT, 196, 612,
	FONT_NEXT, 187, 581,
	FONT_NEXT, 185, 541,
	FONT_NEXT, 185, 363,
	FONT_NEXT, 181, 320,
	FONT_NEXT, 168, 289,
	FONT_NEXT, 142, 266,
	FONT_NEXT, 100, 250,
	FONT_NEXT, 142, 233,
	FONT_NEXT, 168, 209,
	FONT_NEXT, 181, 178,
	FONT_NEXT, 185, 136,
	FONT_END, 185, -41,
	FONT_ADVANCE, 480, 0
    },
    {
	124,
	FONT_BEGIN, 133, -14,
	FONT_NEXT, 133, 676,
	FONT_NEXT, 67, 676,
	FONT_END, 67, -14,
	FONT_ADVANCE, 200, 0
    },
    {
	125,
	FONT_BEGIN, 292, 580,
	FONT_NEXT, 283, 612,
	FONT_NEXT, 269, 637,
	FONT_NEXT, 251, 655,
	FONT_NEXT, 199, 675,
	FONT_NEXT, 130, 680,
	FONT_NEXT, 130, 669,
	FONT_NEXT, 174, 652,
	FONT_NEXT, 202, 627,
	FONT_NEXT, 216, 592,
	FONT_NEXT, 221, 546,
	FONT_NEXT, 221, 378,
	FONT_NEXT, 224, 330,
	FONT_NEXT, 237, 294,
	FONT_NEXT, 264, 268,
	FONT_NEXT, 312, 251,
	FONT_NEXT, 312, 249,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 237, 204,
	FONT_NEXT, 224, 168,
	FONT_NEXT, 221, 121,
	FONT_NEXT, 221, -47,
	FONT_NEXT, 216, -94,
	FONT_NEXT, 202, -129,
	FONT_NEXT, 174, -154,
	FONT_NEXT, 130, -170,
	FONT_NEXT, 130, -181,
	FONT_NEXT, 199, -177,
	FONT_NEXT, 251, -157,
	FONT_NEXT, 269, -139,
	FONT_NEXT, 283, -114,
	FONT_NEXT, 292, -83,
	FONT_NEXT, 295, -42,
	FONT_NEXT, 295, 136,
	FONT_NEXT, 298, 178,
	FONT_NEXT, 311, 209,
	FONT_NEXT, 337, 233,
	FONT_NEXT, 380, 250,
	FONT_NEXT, 337, 266,
	FONT_NEXT, 311, 289,
	FONT_NEXT, 298, 320,
	FONT_NEXT, 295, 363,
	FONT_END, 295, 540,
	FONT_ADVANCE, 480, 0
    },
    {
	126,
	FONT_BEGIN, 428, 273,
	FONT_NEXT, 405, 257,
	FONT_NEXT, 378, 251,
	FONT_NEXT, 330, 263,
	FONT_NEXT, 276, 287,
	FONT_NEXT, 219, 309,
	FONT_NEXT, 165, 319,
	FONT_NEXT, 120, 311,
	FONT_NEXT, 85, 291,
	FONT_NEXT, 40, 233,
	FONT_NEXT, 76, 183,
	FONT_NEXT, 107, 232,
	FONT_NEXT, 130, 248,
	FONT_NEXT, 160, 255,
	FONT_NEXT, 222, 244,
	FONT_NEXT, 275, 220,
	FONT_NEXT, 324, 196,
	FONT_NEXT, 377, 187,
	FONT_NEXT, 418, 194,
	FONT_NEXT, 451, 214,
	FONT_NEXT, 502, 273,
	FONT_END, 466, 323,
	FONT_ADVANCE, 541, 0
    },
    {
	END_OF_LIST
    }
};

GLint filledFont[][1+MAX_STROKES*3] = {
    {
	32,
	FONT_ADVANCE, 250, 0
    },
    {
	33,
	FONT_BEGIN, 236, 605,
	FONT_NEXT, 234, 559,
	FONT_NEXT, 229, 642,
	FONT_NEXT, 189, 176,
	FONT_NEXT, 211, 667,
	FONT_END, 182, 676,
	FONT_BEGIN, 182, 676,
	FONT_NEXT, 189, 176,
	FONT_END, 176, 176,
	FONT_BEGIN, 182, 676,
	FONT_NEXT, 176, 176,
	FONT_NEXT, 156, 668,
	FONT_NEXT, 167, 284,
	FONT_END, 163, 315,
	FONT_BEGIN, 156, 668,
	FONT_NEXT, 163, 315,
	FONT_END, 158, 355,
	FONT_BEGIN, 156, 668,
	FONT_NEXT, 158, 355,
	FONT_END, 146, 447,
	FONT_BEGIN, 156, 668,
	FONT_NEXT, 146, 447,
	FONT_NEXT, 140, 648,
	FONT_NEXT, 134, 534,
	FONT_NEXT, 130, 592,
	FONT_END, 131, 568,
	FONT_BEGIN, 238, 42,
	FONT_NEXT, 232, 18,
	FONT_NEXT, 233, 62,
	FONT_END, 222, 79,
	FONT_BEGIN, 222, 79,
	FONT_NEXT, 232, 18,
	FONT_END, 219, 3,
	FONT_BEGIN, 222, 79,
	FONT_NEXT, 219, 3,
	FONT_NEXT, 204, 91,
	FONT_NEXT, 183, -9,
	FONT_NEXT, 183, 96,
	FONT_END, 162, 91,
	FONT_BEGIN, 162, 91,
	FONT_NEXT, 183, -9,
	FONT_END, 148, 2,
	FONT_BEGIN, 162, 91,
	FONT_NEXT, 148, 2,
	FONT_NEXT, 145, 80,
	FONT_NEXT, 135, 18,
	FONT_NEXT, 134, 63,
	FONT_END, 130, 42,
	FONT_ADVANCE, 333, 0
    },
    {
	34,
	FONT_BEGIN, 162, 635,
	FONT_NEXT, 158, 599,
	FONT_NEXT, 148, 665,
	FONT_NEXT, 149, 543,
	FONT_END, 139, 482,
	FONT_BEGIN, 148, 665,
	FONT_NEXT, 139, 482,
	FONT_NEXT, 120, 676,
	FONT_NEXT, 130, 431,
	FONT_END, 109, 431,
	FONT_BEGIN, 120, 676,
	FONT_NEXT, 109, 431,
	FONT_NEXT, 91, 665,
	FONT_NEXT, 99, 482,
	FONT_END, 89, 543,
	FONT_BEGIN, 91, 665,
	FONT_NEXT, 89, 543,
	FONT_NEXT, 77, 635,
	FONT_END, 80, 599,
	FONT_BEGIN, 331, 635,
	FONT_NEXT, 327, 599,
	FONT_NEXT, 317, 665,
	FONT_NEXT, 318, 543,
	FONT_END, 308, 482,
	FONT_BEGIN, 317, 665,
	FONT_NEXT, 308, 482,
	FONT_NEXT, 289, 676,
	FONT_NEXT, 299, 431,
	FONT_END, 278, 431,
	FONT_BEGIN, 289, 676,
	FONT_NEXT, 278, 431,
	FONT_NEXT, 260, 665,
	FONT_NEXT, 268, 482,
	FONT_END, 258, 543,
	FONT_BEGIN, 260, 665,
	FONT_NEXT, 258, 543,
	FONT_NEXT, 246, 635,
	FONT_END, 249, 599,
	FONT_ADVANCE, 408, 0
    },
    {
	35,
	FONT_BEGIN, 32, 405,
	FONT_NEXT, 32, 460,
	FONT_NEXT, 142, 405,
	FONT_NEXT, 150, 460,
	FONT_END, 137, 0,
	FONT_BEGIN, 142, 405,
	FONT_NEXT, 137, 0,
	FONT_NEXT, 121, 271,
	FONT_NEXT, 79, 0,
	FONT_END, 112, 216,
	FONT_BEGIN, 121, 271,
	FONT_NEXT, 112, 216,
	FONT_NEXT, 5, 271,
	FONT_END, 5, 216,
	FONT_BEGIN, 239, 662,
	FONT_NEXT, 208, 460,
	FONT_NEXT, 181, 662,
	FONT_NEXT, 200, 405,
	FONT_END, 179, 271,
	FONT_BEGIN, 181, 662,
	FONT_NEXT, 179, 271,
	FONT_NEXT, 150, 460,
	FONT_NEXT, 170, 216,
	FONT_END, 137, 0,
	FONT_BEGIN, 170, 216,
	FONT_NEXT, 179, 271,
	FONT_NEXT, 304, 216,
	FONT_NEXT, 313, 271,
	FONT_NEXT, 273, 0,
	FONT_END, 331, 0,
	FONT_BEGIN, 331, 0,
	FONT_NEXT, 313, 271,
	FONT_END, 333, 405,
	FONT_BEGIN, 331, 0,
	FONT_NEXT, 333, 405,
	FONT_NEXT, 341, 460,
	FONT_END, 208, 460,
	FONT_BEGIN, 208, 460,
	FONT_NEXT, 333, 405,
	FONT_END, 200, 405,
	FONT_BEGIN, 208, 460,
	FONT_END, 200, 405,
	FONT_BEGIN, 429, 662,
	FONT_NEXT, 399, 460,
	FONT_NEXT, 371, 662,
	FONT_NEXT, 391, 405,
	FONT_END, 371, 271,
	FONT_BEGIN, 371, 662,
	FONT_NEXT, 371, 271,
	FONT_NEXT, 341, 460,
	FONT_NEXT, 362, 216,
	FONT_END, 331, 0,
	FONT_BEGIN, 496, 460,
	FONT_NEXT, 496, 405,
	FONT_NEXT, 399, 460,
	FONT_END, 391, 405,
	FONT_BEGIN, 471, 271,
	FONT_NEXT, 471, 216,
	FONT_NEXT, 371, 271,
	FONT_END, 362, 216,
	FONT_ADVANCE, 500, 0
    },
    {
	36,
	FONT_BEGIN, 264, 727,
	FONT_NEXT, 264, 664,
	FONT_NEXT, 230, 727,
	FONT_NEXT, 264, 637,
	FONT_END, 264, 391,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, 391,
	FONT_END, 264, 293,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, 293,
	FONT_END, 264, 28,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, 28,
	FONT_END, 264, 0,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, 0,
	FONT_END, 264, -87,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, -87,
	FONT_END, 230, -87,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 230, -87,
	FONT_NEXT, 230, 664,
	FONT_END, 230, 310,
	FONT_BEGIN, 230, 310,
	FONT_NEXT, 230, -87,
	FONT_NEXT, 230, 28,
	FONT_NEXT, 230, 0,
	FONT_NEXT, 166, 37,
	FONT_NEXT, 162, 5,
	FONT_NEXT, 117, 66,
	FONT_NEXT, 110, 19,
	FONT_NEXT, 81, 114,
	FONT_NEXT, 70, 35,
	FONT_NEXT, 59, 181,
	FONT_NEXT, 44, 51,
	FONT_END, 44, 181,
	FONT_BEGIN, 425, 611,
	FONT_NEXT, 425, 500,
	FONT_NEXT, 387, 634,
	FONT_NEXT, 410, 500,
	FONT_END, 399, 537,
	FONT_BEGIN, 387, 634,
	FONT_NEXT, 399, 537,
	FONT_END, 385, 566,
	FONT_BEGIN, 387, 634,
	FONT_NEXT, 385, 566,
	FONT_NEXT, 345, 649,
	FONT_NEXT, 348, 607,
	FONT_END, 305, 628,
	FONT_BEGIN, 345, 649,
	FONT_NEXT, 305, 628,
	FONT_NEXT, 264, 664,
	FONT_END, 264, 637,
	FONT_BEGIN, 457, 174,
	FONT_NEXT, 453, 134,
	FONT_NEXT, 453, 211,
	FONT_END, 444, 243,
	FONT_BEGIN, 444, 243,
	FONT_NEXT, 453, 134,
	FONT_END, 441, 100,
	FONT_BEGIN, 444, 243,
	FONT_NEXT, 441, 100,
	FONT_NEXT, 408, 295,
	FONT_NEXT, 399, 49,
	FONT_NEXT, 348, 341,
	FONT_NEXT, 378, 151,
	FONT_END, 369, 197,
	FONT_BEGIN, 348, 341,
	FONT_NEXT, 369, 197,
	FONT_END, 344, 234,
	FONT_BEGIN, 348, 341,
	FONT_NEXT, 344, 234,
	FONT_NEXT, 264, 391,
	FONT_NEXT, 308, 264,
	FONT_END, 264, 293,
	FONT_BEGIN, 264, 28,
	FONT_NEXT, 295, 35,
	FONT_NEXT, 264, 0,
	FONT_NEXT, 333, 53,
	FONT_NEXT, 338, 16,
	FONT_NEXT, 364, 89,
	FONT_END, 374, 116,
	FONT_BEGIN, 338, 16,
	FONT_NEXT, 374, 116,
	FONT_NEXT, 399, 49,
	FONT_END, 378, 151,
	FONT_BEGIN, 126, 532,
	FONT_NEXT, 133, 495,
	FONT_NEXT, 106, 392,
	FONT_NEXT, 155, 464,
	FONT_NEXT, 163, 349,
	FONT_NEXT, 187, 435,
	FONT_END, 229, 407,
	FONT_BEGIN, 163, 349,
	FONT_NEXT, 229, 407,
	FONT_NEXT, 230, 310,
	FONT_NEXT, 229, 637,
	FONT_NEXT, 230, 664,
	FONT_END, 185, 658,
	FONT_BEGIN, 185, 658,
	FONT_NEXT, 229, 637,
	FONT_END, 196, 628,
	FONT_BEGIN, 185, 658,
	FONT_NEXT, 196, 628,
	FONT_END, 171, 616,
	FONT_BEGIN, 185, 658,
	FONT_NEXT, 171, 616,
	FONT_NEXT, 148, 646,
	FONT_NEXT, 141, 586,
	FONT_NEXT, 93, 611,
	FONT_NEXT, 128, 555,
	FONT_END, 126, 532,
	FONT_BEGIN, 93, 611,
	FONT_NEXT, 126, 532,
	FONT_END, 106, 392,
	FONT_BEGIN, 93, 611,
	FONT_NEXT, 106, 392,
	FONT_END, 67, 445,
	FONT_BEGIN, 93, 611,
	FONT_NEXT, 67, 445,
	FONT_NEXT, 61, 563,
	FONT_NEXT, 55, 476,
	FONT_END, 52, 511,
	FONT_ADVANCE, 500, 0
    },
    {
	37,
	FONT_BEGIN, 102, 319,
	FONT_NEXT, 137, 397,
	FONT_NEXT, 140, 296,
	FONT_NEXT, 141, 362,
	FONT_END, 153, 339,
	FONT_BEGIN, 140, 296,
	FONT_NEXT, 153, 339,
	FONT_END, 172, 326,
	FONT_BEGIN, 140, 296,
	FONT_NEXT, 172, 326,
	FONT_NEXT, 178, 289,
	FONT_NEXT, 199, 323,
	FONT_NEXT, 223, 295,
	FONT_NEXT, 228, 328,
	FONT_END, 257, 343,
	FONT_BEGIN, 223, 295,
	FONT_NEXT, 257, 343,
	FONT_NEXT, 264, 314,
	FONT_END, 299, 343,
	FONT_BEGIN, 299, 343,
	FONT_NEXT, 257, 343,
	FONT_END, 309, 396,
	FONT_BEGIN, 299, 343,
	FONT_NEXT, 309, 396,
	FONT_NEXT, 329, 379,
	FONT_NEXT, 345, 469,
	FONT_NEXT, 369, 463,
	FONT_NEXT, 359, 553,
	FONT_NEXT, 352, 635,
	FONT_NEXT, 350, 600,
	FONT_NEXT, 325, 653,
	FONT_NEXT, 315, 611,
	FONT_NEXT, 305, 659,
	FONT_NEXT, 299, 622,
	FONT_NEXT, 276, 662,
	FONT_NEXT, 281, 632,
	FONT_END, 255, 625,
	FONT_BEGIN, 276, 662,
	FONT_NEXT, 255, 625,
	FONT_NEXT, 232, 655,
	FONT_NEXT, 230, 606,
	FONT_NEXT, 192, 639,
	FONT_NEXT, 184, 545,
	FONT_NEXT, 156, 613,
	FONT_NEXT, 150, 468,
	FONT_NEXT, 124, 581,
	FONT_NEXT, 137, 397,
	FONT_END, 102, 319,
	FONT_BEGIN, 124, 581,
	FONT_NEXT, 102, 319,
	FONT_NEXT, 78, 504,
	FONT_NEXT, 72, 361,
	FONT_NEXT, 65, 463,
	FONT_NEXT, 64, 390,
	FONT_END, 61, 425,
	FONT_BEGIN, 201, -13,
	FONT_NEXT, 550, 609,
	FONT_NEXT, 249, -13,
	FONT_END, 595, 676,
	FONT_BEGIN, 595, 676,
	FONT_NEXT, 550, 609,
	FONT_NEXT, 536, 630,
	FONT_NEXT, 548, 611,
	FONT_END, 507, 592,
	FONT_BEGIN, 536, 630,
	FONT_NEXT, 507, 592,
	FONT_NEXT, 493, 614,
	FONT_NEXT, 478, 585,
	FONT_NEXT, 438, 608,
	FONT_NEXT, 443, 583,
	FONT_END, 401, 585,
	FONT_BEGIN, 438, 608,
	FONT_NEXT, 401, 585,
	FONT_NEXT, 404, 610,
	FONT_END, 381, 616,
	FONT_BEGIN, 381, 616,
	FONT_NEXT, 401, 585,
	FONT_END, 377, 593,
	FONT_BEGIN, 381, 616,
	FONT_NEXT, 377, 593,
	FONT_NEXT, 352, 635,
	FONT_END, 369, 463,
	FONT_BEGIN, 369, 463,
	FONT_NEXT, 377, 593,
	FONT_END, 384, 548,
	FONT_BEGIN, 369, 463,
	FONT_END, 384, 548,
	FONT_BEGIN, 249, -13,
	FONT_NEXT, 595, 676,
	FONT_END, 634, 676,
	FONT_BEGIN, 772, 261,
	FONT_NEXT, 757, 173,
	FONT_NEXT, 768, 295,
	FONT_END, 760, 321,
	FONT_BEGIN, 760, 321,
	FONT_NEXT, 757, 173,
	FONT_END, 746, 254,
	FONT_BEGIN, 760, 321,
	FONT_NEXT, 746, 254,
	FONT_NEXT, 731, 354,
	FONT_NEXT, 740, 287,
	FONT_END, 726, 314,
	FONT_BEGIN, 731, 354,
	FONT_NEXT, 726, 314,
	FONT_NEXT, 695, 368,
	FONT_NEXT, 703, 332,
	FONT_END, 676, 339,
	FONT_BEGIN, 695, 368,
	FONT_NEXT, 676, 339,
	FONT_NEXT, 663, 371,
	FONT_NEXT, 641, 330,
	FONT_NEXT, 622, 365,
	FONT_NEXT, 611, 308,
	FONT_NEXT, 583, 349,
	FONT_NEXT, 564, 238,
	FONT_NEXT, 514, 293,
	FONT_NEXT, 534, 160,
	FONT_END, 527, 128,
	FONT_BEGIN, 514, 293,
	FONT_NEXT, 527, 128,
	FONT_END, 525, 106,
	FONT_BEGIN, 514, 293,
	FONT_NEXT, 525, 106,
	FONT_END, 513, 11,
	FONT_BEGIN, 514, 293,
	FONT_NEXT, 513, 11,
	FONT_NEXT, 466, 218,
	FONT_NEXT, 475, 42,
	FONT_END, 455, 86,
	FONT_BEGIN, 466, 218,
	FONT_NEXT, 455, 86,
	FONT_NEXT, 453, 177,
	FONT_END, 449, 137,
	FONT_BEGIN, 525, 106,
	FONT_NEXT, 533, 60,
	FONT_NEXT, 513, 11,
	FONT_NEXT, 552, 39,
	FONT_NEXT, 572, 0,
	FONT_NEXT, 589, 30,
	FONT_NEXT, 615, 6,
	FONT_NEXT, 620, 36,
	FONT_END, 650, 53,
	FONT_BEGIN, 615, 6,
	FONT_NEXT, 650, 53,
	FONT_NEXT, 654, 25,
	FONT_END, 688, 53,
	FONT_BEGIN, 688, 53,
	FONT_NEXT, 650, 53,
	FONT_END, 700, 110,
	FONT_BEGIN, 688, 53,
	FONT_NEXT, 700, 110,
	FONT_NEXT, 717, 88,
	FONT_NEXT, 733, 183,
	FONT_END, 746, 254,
	FONT_BEGIN, 717, 88,
	FONT_NEXT, 746, 254,
	FONT_END, 757, 173,
	FONT_ADVANCE, 833, 0
    },
    {
	38,
	FONT_BEGIN, 42, 144,
	FONT_NEXT, 57, 215,
	FONT_NEXT, 46, 99,
	FONT_END, 59, 64,
	FONT_BEGIN, 59, 64,
	FONT_NEXT, 57, 215,
	FONT_NEXT, 78, 36,
	FONT_NEXT, 95, 274,
	FONT_NEXT, 101, 16,
	FONT_END, 134, 180,
	FONT_BEGIN, 134, 180,
	FONT_NEXT, 95, 274,
	FONT_NEXT, 146, 238,
	FONT_NEXT, 146, 320,
	FONT_NEXT, 176, 283,
	FONT_NEXT, 199, 355,
	FONT_NEXT, 214, 317,
	FONT_NEXT, 237, 377,
	FONT_NEXT, 252, 343,
	FONT_END, 240, 624,
	FONT_BEGIN, 240, 624,
	FONT_NEXT, 237, 377,
	FONT_NEXT, 211, 573,
	FONT_NEXT, 211, 452,
	FONT_END, 202, 519,
	FONT_BEGIN, 321, 416,
	FONT_NEXT, 350, 432,
	FONT_NEXT, 336, 384,
	FONT_END, 387, 409,
	FONT_BEGIN, 387, 409,
	FONT_NEXT, 350, 432,
	FONT_END, 389, 462,
	FONT_BEGIN, 387, 409,
	FONT_NEXT, 389, 462,
	FONT_END, 423, 504,
	FONT_BEGIN, 387, 409,
	FONT_NEXT, 423, 504,
	FONT_NEXT, 437, 444,
	FONT_NEXT, 438, 560,
	FONT_NEXT, 450, 644,
	FONT_NEXT, 431, 594,
	FONT_NEXT, 407, 667,
	FONT_NEXT, 414, 620,
	FONT_END, 389, 637,
	FONT_BEGIN, 407, 667,
	FONT_NEXT, 389, 637,
	FONT_NEXT, 355, 676,
	FONT_NEXT, 359, 644,
	FONT_END, 329, 639,
	FONT_BEGIN, 355, 676,
	FONT_NEXT, 329, 639,
	FONT_NEXT, 319, 672,
	FONT_NEXT, 304, 623,
	FONT_NEXT, 288, 661,
	FONT_NEXT, 287, 596,
	FONT_NEXT, 240, 624,
	FONT_NEXT, 281, 557,
	FONT_NEXT, 252, 343,
	FONT_NEXT, 293, 483,
	FONT_END, 321, 416,
	FONT_BEGIN, 252, 343,
	FONT_NEXT, 321, 416,
	FONT_NEXT, 322, 219,
	FONT_NEXT, 336, 384,
	FONT_END, 396, 277,
	FONT_BEGIN, 322, 219,
	FONT_NEXT, 396, 277,
	FONT_NEXT, 404, 104,
	FONT_NEXT, 429, 78,
	FONT_END, 394, 49,
	FONT_BEGIN, 404, 104,
	FONT_NEXT, 394, 49,
	FONT_NEXT, 356, 69,
	FONT_NEXT, 347, 19,
	FONT_NEXT, 316, 49,
	FONT_NEXT, 286, -4,
	FONT_NEXT, 285, 41,
	FONT_NEXT, 207, -13,
	FONT_NEXT, 263, 39,
	FONT_END, 212, 50,
	FONT_BEGIN, 212, 50,
	FONT_NEXT, 207, -13,
	FONT_NEXT, 171, 80,
	FONT_NEXT, 155, -7,
	FONT_NEXT, 144, 125,
	FONT_NEXT, 101, 16,
	FONT_END, 134, 180,
	FONT_BEGIN, 491, 556,
	FONT_NEXT, 486, 521,
	FONT_NEXT, 480, 606,
	FONT_NEXT, 475, 492,
	FONT_NEXT, 450, 644,
	FONT_END, 437, 444,
	FONT_BEGIN, 495, 405,
	FONT_NEXT, 495, 426,
	FONT_NEXT, 540, 395,
	FONT_NEXT, 617, 346,
	FONT_NEXT, 554, 381,
	FONT_NEXT, 591, 300,
	FONT_NEXT, 559, 359,
	FONT_NEXT, 568, 261,
	FONT_END, 550, 232,
	FONT_BEGIN, 559, 359,
	FONT_NEXT, 550, 232,
	FONT_NEXT, 548, 310,
	FONT_NEXT, 528, 200,
	FONT_NEXT, 524, 259,
	FONT_NEXT, 491, 150,
	FONT_NEXT, 494, 213,
	FONT_END, 468, 178,
	FONT_BEGIN, 468, 178,
	FONT_NEXT, 491, 150,
	FONT_END, 456, 51,
	FONT_BEGIN, 468, 178,
	FONT_NEXT, 456, 51,
	FONT_NEXT, 396, 277,
	FONT_END, 429, 78,
	FONT_BEGIN, 711, 426,
	FONT_NEXT, 711, 405,
	FONT_NEXT, 495, 426,
	FONT_NEXT, 661, 392,
	FONT_END, 638, 375,
	FONT_BEGIN, 495, 426,
	FONT_NEXT, 638, 375,
	FONT_END, 617, 346,
	FONT_BEGIN, 750, 100,
	FONT_NEXT, 747, 93,
	FONT_NEXT, 735, 111,
	FONT_NEXT, 740, 80,
	FONT_END, 713, 42,
	FONT_BEGIN, 735, 111,
	FONT_NEXT, 713, 42,
	FONT_NEXT, 697, 73,
	FONT_NEXT, 667, 4,
	FONT_NEXT, 672, 62,
	FONT_END, 639, 58,
	FONT_BEGIN, 639, 58,
	FONT_NEXT, 667, 4,
	FONT_END, 635, -9,
	FONT_BEGIN, 639, 58,
	FONT_NEXT, 635, -9,
	FONT_NEXT, 585, 70,
	FONT_NEXT, 599, -13,
	FONT_END, 542, -3,
	FONT_BEGIN, 585, 70,
	FONT_NEXT, 542, -3,
	FONT_NEXT, 540, 98,
	FONT_NEXT, 494, 21,
	FONT_NEXT, 507, 129,
	FONT_END, 491, 150,
	FONT_BEGIN, 491, 150,
	FONT_NEXT, 494, 21,
	FONT_END, 456, 51,
	FONT_BEGIN, 491, 150,
	FONT_END, 456, 51,
	FONT_ADVANCE, 778, 0
    },
    {
	39,
	FONT_BEGIN, 106, 433,
	FONT_NEXT, 97, 452,
	FONT_NEXT, 136, 450,
	FONT_NEXT, 137, 483,
	FONT_END, 162, 513,
	FONT_BEGIN, 136, 450,
	FONT_NEXT, 162, 513,
	FONT_NEXT, 173, 483,
	FONT_NEXT, 175, 539,
	FONT_END, 179, 558,
	FONT_BEGIN, 173, 483,
	FONT_NEXT, 179, 558,
	FONT_NEXT, 204, 528,
	FONT_END, 186, 659,
	FONT_BEGIN, 186, 659,
	FONT_NEXT, 179, 558,
	FONT_NEXT, 159, 672,
	FONT_NEXT, 174, 568,
	FONT_END, 165, 572,
	FONT_BEGIN, 159, 672,
	FONT_NEXT, 165, 572,
	FONT_END, 156, 570,
	FONT_BEGIN, 159, 672,
	FONT_NEXT, 156, 570,
	FONT_NEXT, 137, 676,
	FONT_NEXT, 141, 568,
	FONT_END, 100, 578,
	FONT_BEGIN, 137, 676,
	FONT_NEXT, 100, 578,
	FONT_NEXT, 98, 663,
	FONT_NEXT, 85, 593,
	FONT_NEXT, 84, 645,
	FONT_END, 79, 618,
	FONT_BEGIN, 218, 580,
	FONT_NEXT, 204, 528,
	FONT_NEXT, 208, 630,
	FONT_END, 186, 659,
	FONT_ADVANCE, 333, 0
    },
    {
	40,
	FONT_BEGIN, 48, 262,
	FONT_NEXT, 52, 325,
	FONT_NEXT, 53, 169,
	FONT_NEXT, 64, 386,
	FONT_NEXT, 70, 96,
	FONT_NEXT, 85, 444,
	FONT_NEXT, 96, 35,
	FONT_NEXT, 113, 499,
	FONT_NEXT, 130, -20,
	FONT_NEXT, 134, 225,
	FONT_END, 136, 174,
	FONT_BEGIN, 130, -20,
	FONT_NEXT, 136, 174,
	FONT_END, 155, 56,
	FONT_BEGIN, 130, -20,
	FONT_NEXT, 155, 56,
	FONT_END, 175, -4,
	FONT_BEGIN, 130, -20,
	FONT_NEXT, 175, -4,
	FONT_NEXT, 203, -108,
	FONT_NEXT, 205, -63,
	FONT_NEXT, 247, -148,
	FONT_NEXT, 247, -116,
	FONT_NEXT, 292, -177,
	FONT_END, 304, -161,
	FONT_BEGIN, 304, 660,
	FONT_NEXT, 246, 609,
	FONT_NEXT, 295, 676,
	FONT_END, 239, 638,
	FONT_BEGIN, 239, 638,
	FONT_NEXT, 246, 609,
	FONT_END, 191, 537,
	FONT_BEGIN, 239, 638,
	FONT_NEXT, 191, 537,
	FONT_NEXT, 191, 596,
	FONT_END, 148, 549,
	FONT_BEGIN, 148, 549,
	FONT_NEXT, 191, 537,
	FONT_END, 168, 488,
	FONT_BEGIN, 148, 549,
	FONT_NEXT, 168, 488,
	FONT_END, 150, 428,
	FONT_BEGIN, 148, 549,
	FONT_NEXT, 150, 428,
	FONT_END, 138, 356,
	FONT_BEGIN, 148, 549,
	FONT_NEXT, 138, 356,
	FONT_NEXT, 113, 499,
	FONT_NEXT, 134, 269,
	FONT_END, 134, 225,
	FONT_ADVANCE, 333, 0
    },
    {
	41,
	FONT_BEGIN, 29, -161,
	FONT_NEXT, 86, -111,
	FONT_NEXT, 38, -177,
	FONT_END, 93, -140,
	FONT_BEGIN, 93, -140,
	FONT_NEXT, 86, -111,
	FONT_NEXT, 141, -98,
	FONT_NEXT, 141, -39,
	FONT_END, 164, 10,
	FONT_BEGIN, 141, -98,
	FONT_NEXT, 164, 10,
	FONT_END, 182, 70,
	FONT_BEGIN, 141, -98,
	FONT_NEXT, 182, 70,
	FONT_NEXT, 184, -51,
	FONT_NEXT, 194, 142,
	FONT_END, 199, 230,
	FONT_BEGIN, 184, -51,
	FONT_NEXT, 199, 230,
	FONT_NEXT, 219, 0,
	FONT_END, 203, 519,
	FONT_BEGIN, 203, 519,
	FONT_NEXT, 199, 230,
	FONT_END, 198, 273,
	FONT_BEGIN, 203, 519,
	FONT_NEXT, 198, 273,
	FONT_END, 196, 324,
	FONT_BEGIN, 203, 519,
	FONT_NEXT, 196, 324,
	FONT_END, 177, 442,
	FONT_BEGIN, 203, 519,
	FONT_NEXT, 177, 442,
	FONT_NEXT, 129, 606,
	FONT_NEXT, 157, 502,
	FONT_END, 127, 561,
	FONT_BEGIN, 129, 606,
	FONT_NEXT, 127, 561,
	FONT_NEXT, 85, 646,
	FONT_NEXT, 85, 614,
	FONT_NEXT, 41, 676,
	FONT_END, 29, 660,
	FONT_BEGIN, 285, 237,
	FONT_NEXT, 280, 173,
	FONT_NEXT, 279, 329,
	FONT_NEXT, 268, 112,
	FONT_NEXT, 262, 402,
	FONT_NEXT, 247, 54,
	FONT_NEXT, 236, 463,
	FONT_NEXT, 219, 0,
	FONT_END, 203, 519,
	FONT_ADVANCE, 333, 0
    },
    {
	42,
	FONT_BEGIN, 69, 557,
	FONT_NEXT, 75, 576,
	FONT_NEXT, 72, 538,
	FONT_END, 83, 526,
	FONT_BEGIN, 83, 526,
	FONT_NEXT, 75, 576,
	FONT_END, 85, 586,
	FONT_BEGIN, 83, 526,
	FONT_NEXT, 85, 586,
	FONT_END, 102, 591,
	FONT_BEGIN, 83, 526,
	FONT_NEXT, 102, 591,
	FONT_NEXT, 120, 511,
	FONT_NEXT, 129, 581,
	FONT_END, 152, 557,
	FONT_BEGIN, 120, 511,
	FONT_NEXT, 152, 557,
	FONT_NEXT, 170, 500,
	FONT_NEXT, 185, 523,
	FONT_NEXT, 223, 478,
	FONT_END, 234, 471,
	FONT_BEGIN, 234, 471,
	FONT_NEXT, 185, 523,
	FONT_END, 241, 486,
	FONT_BEGIN, 234, 471,
	FONT_NEXT, 241, 486,
	FONT_END, 240, 456,
	FONT_BEGIN, 234, 471,
	FONT_NEXT, 240, 456,
	FONT_END, 210, 435,
	FONT_BEGIN, 234, 471,
	FONT_NEXT, 210, 435,
	FONT_NEXT, 172, 441,
	FONT_NEXT, 192, 422,
	FONT_END, 164, 394,
	FONT_BEGIN, 172, 441,
	FONT_NEXT, 164, 394,
	FONT_NEXT, 120, 428,
	FONT_NEXT, 143, 371,
	FONT_END, 129, 358,
	FONT_BEGIN, 120, 428,
	FONT_NEXT, 129, 358,
	FONT_END, 103, 351,
	FONT_BEGIN, 120, 428,
	FONT_NEXT, 103, 351,
	FONT_NEXT, 82, 415,
	FONT_NEXT, 76, 362,
	FONT_NEXT, 72, 402,
	FONT_END, 69, 383,
	FONT_BEGIN, 214, 304,
	FONT_NEXT, 219, 331,
	FONT_NEXT, 225, 275,
	FONT_NEXT, 230, 365,
	FONT_END, 240, 405,
	FONT_BEGIN, 225, 275,
	FONT_NEXT, 240, 405,
	FONT_NEXT, 249, 265,
	FONT_NEXT, 241, 449,
	FONT_NEXT, 241, 499,
	FONT_END, 241, 486,
	FONT_BEGIN, 241, 486,
	FONT_NEXT, 241, 449,
	FONT_END, 240, 456,
	FONT_BEGIN, 241, 486,
	FONT_END, 240, 456,
	FONT_BEGIN, 216, 637,
	FONT_NEXT, 220, 659,
	FONT_NEXT, 228, 581,
	FONT_NEXT, 231, 671,
	FONT_NEXT, 237, 548,
	FONT_END, 241, 499,
	FONT_BEGIN, 241, 499,
	FONT_NEXT, 231, 671,
	FONT_END, 253, 676,
	FONT_BEGIN, 241, 499,
	FONT_NEXT, 253, 676,
	FONT_NEXT, 249, 265,
	FONT_END, 260, 449,
	FONT_BEGIN, 260, 449,
	FONT_NEXT, 253, 676,
	FONT_NEXT, 260, 456,
	FONT_END, 260, 484,
	FONT_BEGIN, 260, 484,
	FONT_NEXT, 253, 676,
	FONT_NEXT, 260, 510,
	FONT_NEXT, 269, 671,
	FONT_NEXT, 273, 582,
	FONT_NEXT, 279, 661,
	FONT_NEXT, 282, 613,
	FONT_END, 287, 637,
	FONT_BEGIN, 288, 307,
	FONT_NEXT, 277, 278,
	FONT_NEXT, 274, 352,
	FONT_NEXT, 249, 265,
	FONT_NEXT, 264, 389,
	FONT_END, 260, 449,
	FONT_BEGIN, 431, 557,
	FONT_NEXT, 428, 537,
	FONT_NEXT, 427, 574,
	FONT_NEXT, 420, 525,
	FONT_NEXT, 417, 585,
	FONT_NEXT, 388, 513,
	FONT_NEXT, 395, 593,
	FONT_END, 368, 581,
	FONT_BEGIN, 368, 581,
	FONT_NEXT, 388, 513,
	FONT_END, 336, 502,
	FONT_BEGIN, 368, 581,
	FONT_NEXT, 336, 502,
	FONT_NEXT, 341, 554,
	FONT_END, 309, 520,
	FONT_BEGIN, 309, 520,
	FONT_NEXT, 336, 502,
	FONT_END, 304, 489,
	FONT_BEGIN, 309, 520,
	FONT_NEXT, 304, 489,
	FONT_NEXT, 267, 488,
	FONT_NEXT, 268, 470,
	FONT_END, 267, 453,
	FONT_BEGIN, 267, 488,
	FONT_NEXT, 267, 453,
	FONT_NEXT, 260, 484,
	FONT_END, 260, 456,
	FONT_BEGIN, 432, 386,
	FONT_NEXT, 421, 359,
	FONT_NEXT, 428, 404,
	FONT_END, 419, 416,
	FONT_BEGIN, 419, 416,
	FONT_NEXT, 421, 359,
	FONT_END, 396, 350,
	FONT_BEGIN, 419, 416,
	FONT_NEXT, 396, 350,
	FONT_NEXT, 384, 428,
	FONT_NEXT, 366, 362,
	FONT_NEXT, 334, 439,
	FONT_NEXT, 338, 391,
	FONT_END, 307, 425,
	FONT_BEGIN, 334, 439,
	FONT_NEXT, 307, 425,
	FONT_NEXT, 276, 465,
	FONT_NEXT, 267, 453,
	FONT_END, 268, 470,
	FONT_ADVANCE, 500, 0
    },
    {
	43,
	FONT_BEGIN, 315, 506,
	FONT_NEXT, 315, 286,
	FONT_NEXT, 249, 506,
	FONT_NEXT, 315, 220,
	FONT_END, 315, 0,
	FONT_BEGIN, 249, 506,
	FONT_NEXT, 315, 0,
	FONT_END, 249, 0,
	FONT_BEGIN, 249, 506,
	FONT_NEXT, 249, 0,
	FONT_NEXT, 249, 286,
	FONT_NEXT, 249, 220,
	FONT_NEXT, 30, 286,
	FONT_END, 30, 220,
	FONT_BEGIN, 534, 286,
	FONT_NEXT, 534, 220,
	FONT_NEXT, 315, 286,
	FONT_END, 315, 220,
	FONT_ADVANCE, 564, 0
    },
    {
	44,
	FONT_BEGIN, 83, -141,
	FONT_NEXT, 74, -122,
	FONT_NEXT, 113, -124,
	FONT_NEXT, 114, -91,
	FONT_END, 139, -61,
	FONT_BEGIN, 113, -124,
	FONT_NEXT, 139, -61,
	FONT_NEXT, 150, -91,
	FONT_NEXT, 152, -35,
	FONT_END, 156, -16,
	FONT_BEGIN, 150, -91,
	FONT_NEXT, 156, -16,
	FONT_NEXT, 181, -46,
	FONT_END, 163, 85,
	FONT_BEGIN, 163, 85,
	FONT_NEXT, 156, -16,
	FONT_NEXT, 136, 98,
	FONT_NEXT, 151, -6,
	FONT_END, 142, -2,
	FONT_BEGIN, 136, 98,
	FONT_NEXT, 142, -2,
	FONT_END, 133, -4,
	FONT_BEGIN, 136, 98,
	FONT_NEXT, 133, -4,
	FONT_NEXT, 114, 102,
	FONT_NEXT, 118, -6,
	FONT_END, 77, 4,
	FONT_BEGIN, 114, 102,
	FONT_NEXT, 77, 4,
	FONT_NEXT, 75, 89,
	FONT_NEXT, 62, 19,
	FONT_NEXT, 61, 71,
	FONT_END, 56, 44,
	FONT_BEGIN, 195, 6,
	FONT_NEXT, 181, -46,
	FONT_NEXT, 185, 56,
	FONT_END, 163, 85,
	FONT_ADVANCE, 250, 0
    },
    {
	45,
	FONT_BEGIN, 285, 257,
	FONT_NEXT, 285, 194,
	FONT_NEXT, 39, 257,
	FONT_END, 39, 194,
	FONT_ADVANCE, 333, 0
    },
    {
	46,
	FONT_BEGIN, 181, 43,
	FONT_NEXT, 175, 18,
	FONT_NEXT, 176, 64,
	FONT_END, 164, 83,
	FONT_BEGIN, 164, 83,
	FONT_NEXT, 175, 18,
	FONT_END, 160, 2,
	FONT_BEGIN, 164, 83,
	FONT_NEXT, 160, 2,
	FONT_NEXT, 146, 95,
	FONT_NEXT, 125, -11,
	FONT_NEXT, 125, 100,
	FONT_END, 103, 95,
	FONT_BEGIN, 103, 95,
	FONT_NEXT, 125, -11,
	FONT_END, 89, 1,
	FONT_BEGIN, 103, 95,
	FONT_NEXT, 89, 1,
	FONT_NEXT, 86, 83,
	FONT_NEXT, 75, 18,
	FONT_NEXT, 74, 65,
	FONT_END, 70, 43,
	FONT_ADVANCE, 250, 0
    },
    {
	47,
	FONT_BEGIN, 287, 676,
	FONT_NEXT, 59, -14,
	FONT_NEXT, 220, 676,
	FONT_END, -9, -14,
	FONT_ADVANCE, 278, 0
    },
    {
	48,
	FONT_BEGIN, 476, 331,
	FONT_NEXT, 466, 226,
	FONT_NEXT, 473, 379,
	FONT_END, 466, 434,
	FONT_BEGIN, 466, 434,
	FONT_NEXT, 466, 226,
	FONT_NEXT, 432, 547,
	FONT_NEXT, 432, 113,
	FONT_NEXT, 402, 597,
	FONT_NEXT, 402, 63,
	FONT_NEXT, 362, 638,
	FONT_NEXT, 377, 409,
	FONT_END, 363, 516,
	FONT_BEGIN, 362, 638,
	FONT_NEXT, 363, 516,
	FONT_END, 347, 566,
	FONT_BEGIN, 362, 638,
	FONT_NEXT, 347, 566,
	FONT_NEXT, 312, 666,
	FONT_NEXT, 324, 609,
	FONT_END, 292, 639,
	FONT_BEGIN, 312, 666,
	FONT_NEXT, 292, 639,
	FONT_NEXT, 250, 676,
	FONT_NEXT, 250, 650,
	FONT_NEXT, 187, 666,
	FONT_NEXT, 207, 639,
	FONT_END, 175, 609,
	FONT_BEGIN, 187, 666,
	FONT_NEXT, 175, 609,
	FONT_NEXT, 137, 638,
	FONT_NEXT, 152, 566,
	FONT_END, 137, 516,
	FONT_BEGIN, 137, 638,
	FONT_NEXT, 137, 516,
	FONT_NEXT, 97, 597,
	FONT_NEXT, 122, 409,
	FONT_END, 120, 364,
	FONT_BEGIN, 97, 597,
	FONT_NEXT, 120, 364,
	FONT_END, 120, 331,
	FONT_BEGIN, 97, 597,
	FONT_NEXT, 120, 331,
	FONT_END, 120, 294,
	FONT_BEGIN, 97, 597,
	FONT_NEXT, 120, 294,
	FONT_END, 97, 63,
	FONT_BEGIN, 97, 597,
	FONT_NEXT, 97, 63,
	FONT_NEXT, 68, 547,
	FONT_NEXT, 68, 113,
	FONT_NEXT, 33, 434,
	FONT_NEXT, 33, 226,
	FONT_NEXT, 26, 379,
	FONT_END, 24, 331,
	FONT_BEGIN, 120, 294,
	FONT_NEXT, 122, 246,
	FONT_NEXT, 97, 63,
	FONT_END, 137, 22,
	FONT_BEGIN, 137, 22,
	FONT_NEXT, 122, 246,
	FONT_END, 137, 141,
	FONT_BEGIN, 137, 22,
	FONT_NEXT, 137, 141,
	FONT_END, 152, 91,
	FONT_BEGIN, 137, 22,
	FONT_NEXT, 152, 91,
	FONT_END, 175, 50,
	FONT_BEGIN, 137, 22,
	FONT_NEXT, 175, 50,
	FONT_NEXT, 187, -5,
	FONT_NEXT, 207, 22,
	FONT_NEXT, 250, -14,
	FONT_NEXT, 250, 12,
	FONT_END, 292, 22,
	FONT_BEGIN, 250, -14,
	FONT_NEXT, 292, 22,
	FONT_NEXT, 312, -5,
	FONT_NEXT, 324, 50,
	FONT_END, 347, 92,
	FONT_BEGIN, 312, -5,
	FONT_NEXT, 347, 92,
	FONT_NEXT, 362, 22,
	FONT_NEXT, 363, 141,
	FONT_END, 377, 247,
	FONT_BEGIN, 362, 22,
	FONT_NEXT, 377, 247,
	FONT_NEXT, 402, 63,
	FONT_NEXT, 379, 294,
	FONT_END, 380, 331,
	FONT_BEGIN, 402, 63,
	FONT_NEXT, 380, 331,
	FONT_END, 379, 364,
	FONT_BEGIN, 402, 63,
	FONT_NEXT, 379, 364,
	FONT_END, 377, 409,
	FONT_ADVANCE, 500, 0
    },
    {
	49,
	FONT_BEGIN, 299, 674,
	FONT_NEXT, 299, 74,
	FONT_NEXT, 291, 676,
	FONT_NEXT, 213, 93,
	FONT_END, 213, 546,
	FONT_BEGIN, 291, 676,
	FONT_NEXT, 213, 546,
	FONT_END, 208, 577,
	FONT_BEGIN, 291, 676,
	FONT_NEXT, 208, 577,
	FONT_END, 198, 588,
	FONT_BEGIN, 291, 676,
	FONT_NEXT, 198, 588,
	FONT_END, 179, 593,
	FONT_BEGIN, 291, 676,
	FONT_NEXT, 179, 593,
	FONT_NEXT, 111, 585,
	FONT_NEXT, 161, 590,
	FONT_END, 143, 583,
	FONT_BEGIN, 111, 585,
	FONT_NEXT, 143, 583,
	FONT_END, 111, 571,
	FONT_BEGIN, 394, 15,
	FONT_NEXT, 394, 0,
	FONT_NEXT, 347, 17,
	FONT_NEXT, 118, 0,
	FONT_NEXT, 318, 26,
	FONT_END, 303, 44,
	FONT_BEGIN, 303, 44,
	FONT_NEXT, 118, 0,
	FONT_END, 187, 27,
	FONT_BEGIN, 303, 44,
	FONT_NEXT, 187, 27,
	FONT_NEXT, 299, 74,
	FONT_NEXT, 206, 49,
	FONT_END, 213, 93,
	FONT_BEGIN, 118, 15,
	FONT_NEXT, 157, 17,
	FONT_NEXT, 118, 0,
	FONT_END, 187, 27,
	FONT_ADVANCE, 500, 0
    },
    {
	50,
	FONT_BEGIN, 475, 137,
	FONT_NEXT, 420, 0,
	FONT_NEXT, 462, 142,
	FONT_END, 435, 105,
	FONT_BEGIN, 435, 105,
	FONT_NEXT, 420, 0,
	FONT_NEXT, 413, 85,
	FONT_NEXT, 30, 0,
	FONT_NEXT, 367, 76,
	FONT_END, 128, 76,
	FONT_BEGIN, 128, 76,
	FONT_NEXT, 30, 0,
	FONT_END, 30, 12,
	FONT_BEGIN, 128, 76,
	FONT_NEXT, 30, 12,
	FONT_END, 208, 201,
	FONT_BEGIN, 128, 76,
	FONT_NEXT, 208, 201,
	FONT_END, 265, 270,
	FONT_BEGIN, 128, 76,
	FONT_NEXT, 265, 270,
	FONT_NEXT, 296, 252,
	FONT_NEXT, 305, 336,
	FONT_END, 329, 400,
	FONT_BEGIN, 296, 252,
	FONT_NEXT, 329, 400,
	FONT_NEXT, 334, 295,
	FONT_NEXT, 338, 459,
	FONT_NEXT, 367, 628,
	FONT_NEXT, 332, 502,
	FONT_NEXT, 309, 663,
	FONT_NEXT, 310, 549,
	FONT_END, 267, 586,
	FONT_BEGIN, 309, 663,
	FONT_NEXT, 267, 586,
	FONT_NEXT, 243, 676,
	FONT_NEXT, 235, 597,
	FONT_NEXT, 176, 666,
	FONT_NEXT, 195, 602,
	FONT_END, 137, 589,
	FONT_BEGIN, 176, 666,
	FONT_NEXT, 137, 589,
	FONT_NEXT, 115, 633,
	FONT_NEXT, 97, 557,
	FONT_NEXT, 88, 606,
	FONT_NEXT, 70, 515,
	FONT_NEXT, 64, 571,
	FONT_NEXT, 52, 472,
	FONT_NEXT, 45, 528,
	FONT_END, 31, 477,
	FONT_BEGIN, 424, 496,
	FONT_NEXT, 410, 419,
	FONT_NEXT, 419, 535,
	FONT_END, 408, 571,
	FONT_BEGIN, 408, 571,
	FONT_NEXT, 410, 419,
	FONT_END, 376, 351,
	FONT_BEGIN, 408, 571,
	FONT_NEXT, 376, 351,
	FONT_NEXT, 367, 628,
	FONT_END, 334, 295,
	FONT_ADVANCE, 500, 0
    },
    {
	51,
	FONT_BEGIN, 153, 330,
	FONT_NEXT, 152, 343,
	FONT_NEXT, 197, 330,
	FONT_NEXT, 216, 368,
	FONT_NEXT, 230, 326,
	FONT_NEXT, 269, 403,
	FONT_NEXT, 283, 308,
	FONT_END, 304, 401,
	FONT_BEGIN, 304, 401,
	FONT_NEXT, 269, 403,
	FONT_END, 304, 450,
	FONT_BEGIN, 304, 401,
	FONT_NEXT, 304, 450,
	FONT_END, 318, 512,
	FONT_BEGIN, 304, 401,
	FONT_NEXT, 318, 512,
	FONT_NEXT, 346, 433,
	FONT_END, 319, 660,
	FONT_BEGIN, 319, 660,
	FONT_NEXT, 318, 512,
	FONT_END, 311, 549,
	FONT_BEGIN, 319, 660,
	FONT_NEXT, 311, 549,
	FONT_NEXT, 284, 671,
	FONT_NEXT, 290, 583,
	FONT_END, 256, 606,
	FONT_BEGIN, 284, 671,
	FONT_NEXT, 256, 606,
	FONT_NEXT, 241, 676,
	FONT_NEXT, 208, 616,
	FONT_NEXT, 187, 669,
	FONT_NEXT, 148, 603,
	FONT_NEXT, 132, 644,
	FONT_NEXT, 105, 573,
	FONT_NEXT, 83, 594,
	FONT_NEXT, 76, 538,
	FONT_NEXT, 62, 558,
	FONT_NEXT, 60, 510,
	FONT_END, 45, 514,
	FONT_BEGIN, 43, 43,
	FONT_NEXT, 46, 60,
	FONT_NEXT, 56, 12,
	FONT_NEXT, 56, 71,
	FONT_END, 82, 78,
	FONT_BEGIN, 56, 12,
	FONT_NEXT, 82, 78,
	FONT_NEXT, 89, -5,
	FONT_NEXT, 115, 69,
	FONT_NEXT, 126, -13,
	FONT_NEXT, 148, 50,
	FONT_NEXT, 154, -14,
	FONT_NEXT, 184, 30,
	FONT_NEXT, 210, -10,
	FONT_NEXT, 225, 22,
	FONT_NEXT, 263, 1,
	FONT_NEXT, 285, 35,
	FONT_NEXT, 310, 21,
	FONT_NEXT, 326, 70,
	FONT_NEXT, 351, 47,
	FONT_NEXT, 351, 120,
	FONT_END, 359, 176,
	FONT_BEGIN, 351, 47,
	FONT_NEXT, 359, 176,
	FONT_NEXT, 383, 351,
	FONT_END, 341, 383,
	FONT_BEGIN, 341, 383,
	FONT_NEXT, 359, 176,
	FONT_END, 356, 202,
	FONT_BEGIN, 341, 383,
	FONT_NEXT, 356, 202,
	FONT_END, 345, 239,
	FONT_BEGIN, 341, 383,
	FONT_NEXT, 345, 239,
	FONT_END, 321, 276,
	FONT_BEGIN, 341, 383,
	FONT_NEXT, 321, 276,
	FONT_NEXT, 304, 401,
	FONT_END, 283, 308,
	FONT_BEGIN, 431, 216,
	FONT_NEXT, 425, 165,
	FONT_NEXT, 427, 261,
	FONT_END, 417, 298,
	FONT_BEGIN, 417, 298,
	FONT_NEXT, 425, 165,
	FONT_END, 409, 120,
	FONT_BEGIN, 417, 298,
	FONT_NEXT, 409, 120,
	FONT_NEXT, 383, 351,
	FONT_NEXT, 384, 80,
	FONT_END, 351, 47,
	FONT_BEGIN, 397, 541,
	FONT_NEXT, 391, 502,
	FONT_NEXT, 390, 579,
	FONT_NEXT, 375, 466,
	FONT_NEXT, 367, 623,
	FONT_NEXT, 346, 433,
	FONT_END, 319, 660,
	FONT_ADVANCE, 500, 0
    },
    {
	52,
	FONT_BEGIN, 292, 571,
	FONT_NEXT, 293, 167,
	FONT_NEXT, 292, 231,
	FONT_NEXT, 12, 167,
	FONT_NEXT, 52, 231,
	FONT_NEXT, 12, 231,
	FONT_NEXT, 290, 571,
	FONT_NEXT, 326, 676,
	FONT_NEXT, 292, 571,
	FONT_END, 293, 167,
	FONT_BEGIN, 293, 167,
	FONT_NEXT, 326, 676,
	FONT_NEXT, 293, 0,
	FONT_END, 370, 0,
	FONT_BEGIN, 370, 0,
	FONT_NEXT, 326, 676,
	FONT_NEXT, 370, 167,
	FONT_END, 370, 231,
	FONT_BEGIN, 370, 231,
	FONT_NEXT, 326, 676,
	FONT_END, 370, 676,
	FONT_BEGIN, 370, 231,
	FONT_END, 370, 676,
	FONT_BEGIN, 472, 231,
	FONT_NEXT, 472, 167,
	FONT_NEXT, 370, 231,
	FONT_END, 370, 167,
	FONT_ADVANCE, 500, 0
    },
    {
	53,
	FONT_BEGIN, 64, 415,
	FONT_NEXT, 65, 425,
	FONT_NEXT, 71, 412,
	FONT_NEXT, 139, 498,
	FONT_NEXT, 161, 399,
	FONT_END, 254, 365,
	FONT_BEGIN, 254, 365,
	FONT_NEXT, 139, 498,
	FONT_END, 263, 468,
	FONT_BEGIN, 254, 365,
	FONT_NEXT, 263, 468,
	FONT_NEXT, 294, 337,
	FONT_NEXT, 321, 439,
	FONT_NEXT, 326, 300,
	FONT_END, 348, 255,
	FONT_BEGIN, 348, 255,
	FONT_NEXT, 321, 439,
	FONT_NEXT, 356, 201,
	FONT_NEXT, 372, 395,
	FONT_END, 351, 55,
	FONT_BEGIN, 356, 201,
	FONT_NEXT, 351, 55,
	FONT_NEXT, 352, 158,
	FONT_END, 343, 121,
	FONT_BEGIN, 343, 121,
	FONT_NEXT, 351, 55,
	FONT_END, 312, 26,
	FONT_BEGIN, 343, 121,
	FONT_NEXT, 312, 26,
	FONT_NEXT, 310, 66,
	FONT_NEXT, 266, 4,
	FONT_NEXT, 266, 33,
	FONT_END, 217, 23,
	FONT_BEGIN, 217, 23,
	FONT_NEXT, 266, 4,
	FONT_END, 214, -10,
	FONT_BEGIN, 217, 23,
	FONT_NEXT, 214, -10,
	FONT_NEXT, 72, 85,
	FONT_NEXT, 158, -14,
	FONT_END, 104, -10,
	FONT_BEGIN, 72, 85,
	FONT_NEXT, 104, -10,
	FONT_END, 65, 2,
	FONT_BEGIN, 72, 85,
	FONT_NEXT, 65, 2,
	FONT_NEXT, 48, 80,
	FONT_NEXT, 40, 21,
	FONT_NEXT, 37, 69,
	FONT_END, 32, 46,
	FONT_BEGIN, 438, 681,
	FONT_NEXT, 400, 592,
	FONT_NEXT, 429, 688,
	FONT_END, 411, 669,
	FONT_BEGIN, 411, 669,
	FONT_NEXT, 400, 592,
	FONT_NEXT, 383, 662,
	FONT_NEXT, 391, 584,
	FONT_END, 377, 583,
	FONT_BEGIN, 383, 662,
	FONT_NEXT, 377, 583,
	FONT_NEXT, 174, 662,
	FONT_NEXT, 181, 583,
	FONT_END, 139, 498,
	FONT_BEGIN, 174, 662,
	FONT_NEXT, 139, 498,
	FONT_END, 65, 425,
	FONT_BEGIN, 426, 225,
	FONT_NEXT, 420, 176,
	FONT_NEXT, 423, 281,
	FONT_END, 415, 323,
	FONT_BEGIN, 415, 323,
	FONT_NEXT, 420, 176,
	FONT_END, 406, 131,
	FONT_BEGIN, 415, 323,
	FONT_NEXT, 406, 131,
	FONT_NEXT, 398, 359,
	FONT_NEXT, 382, 90,
	FONT_NEXT, 372, 395,
	FONT_END, 351, 55,
	FONT_ADVANCE, 500, 0
    },
    {
	54,
	FONT_BEGIN, 448, 668,
	FONT_NEXT, 384, 652,
	FONT_NEXT, 446, 684,
	FONT_END, 358, 673,
	FONT_BEGIN, 358, 673,
	FONT_NEXT, 384, 652,
	FONT_END, 329, 628,
	FONT_BEGIN, 358, 673,
	FONT_NEXT, 329, 628,
	FONT_NEXT, 279, 647,
	FONT_NEXT, 281, 597,
	FONT_END, 240, 560,
	FONT_BEGIN, 279, 647,
	FONT_NEXT, 240, 560,
	FONT_NEXT, 209, 609,
	FONT_NEXT, 207, 519,
	FONT_NEXT, 149, 560,
	FONT_NEXT, 181, 475,
	FONT_END, 152, 383,
	FONT_BEGIN, 149, 560,
	FONT_NEXT, 152, 383,
	FONT_END, 147, 350,
	FONT_BEGIN, 149, 560,
	FONT_NEXT, 147, 350,
	FONT_NEXT, 100, 502,
	FONT_NEXT, 133, 321,
	FONT_END, 128, 294,
	FONT_BEGIN, 100, 502,
	FONT_NEXT, 128, 294,
	FONT_END, 127, 256,
	FONT_BEGIN, 100, 502,
	FONT_NEXT, 127, 256,
	FONT_END, 99, 59,
	FONT_BEGIN, 100, 502,
	FONT_NEXT, 99, 59,
	FONT_NEXT, 64, 436,
	FONT_NEXT, 72, 102,
	FONT_END, 51, 154,
	FONT_BEGIN, 64, 436,
	FONT_NEXT, 51, 154,
	FONT_NEXT, 41, 365,
	FONT_NEXT, 38, 217,
	FONT_END, 34, 291,
	FONT_BEGIN, 468, 218,
	FONT_NEXT, 459, 150,
	FONT_NEXT, 464, 265,
	FONT_END, 454, 307,
	FONT_BEGIN, 454, 307,
	FONT_NEXT, 459, 150,
	FONT_END, 427, 74,
	FONT_BEGIN, 454, 307,
	FONT_NEXT, 427, 74,
	FONT_NEXT, 437, 343,
	FONT_END, 415, 373,
	FONT_BEGIN, 415, 373,
	FONT_NEXT, 427, 74,
	FONT_END, 399, 40,
	FONT_BEGIN, 415, 373,
	FONT_NEXT, 399, 40,
	FONT_NEXT, 357, 414,
	FONT_NEXT, 378, 179,
	FONT_END, 371, 254,
	FONT_BEGIN, 357, 414,
	FONT_NEXT, 371, 254,
	FONT_END, 349, 319,
	FONT_BEGIN, 357, 414,
	FONT_NEXT, 349, 319,
	FONT_NEXT, 284, 428,
	FONT_NEXT, 331, 344,
	FONT_END, 307, 364,
	FONT_BEGIN, 284, 428,
	FONT_NEXT, 307, 364,
	FONT_END, 278, 377,
	FONT_BEGIN, 284, 428,
	FONT_NEXT, 278, 377,
	FONT_NEXT, 247, 425,
	FONT_NEXT, 242, 382,
	FONT_NEXT, 217, 417,
	FONT_NEXT, 191, 375,
	FONT_NEXT, 187, 403,
	FONT_NEXT, 147, 350,
	FONT_END, 152, 383,
	FONT_BEGIN, 127, 256,
	FONT_NEXT, 130, 197,
	FONT_NEXT, 99, 59,
	FONT_END, 132, 27,
	FONT_BEGIN, 132, 27,
	FONT_NEXT, 130, 197,
	FONT_END, 138, 147,
	FONT_BEGIN, 132, 27,
	FONT_NEXT, 138, 147,
	FONT_END, 152, 105,
	FONT_BEGIN, 132, 27,
	FONT_NEXT, 152, 105,
	FONT_NEXT, 169, 4,
	FONT_NEXT, 169, 72,
	FONT_END, 191, 46,
	FONT_BEGIN, 169, 4,
	FONT_NEXT, 191, 46,
	FONT_NEXT, 210, -10,
	FONT_NEXT, 215, 28,
	FONT_NEXT, 254, -14,
	FONT_NEXT, 269, 14,
	FONT_END, 312, 23,
	FONT_BEGIN, 254, -14,
	FONT_NEXT, 312, 23,
	FONT_NEXT, 314, -8,
	FONT_NEXT, 347, 54,
	FONT_NEXT, 362, 11,
	FONT_NEXT, 369, 105,
	FONT_END, 378, 179,
	FONT_BEGIN, 362, 11,
	FONT_NEXT, 378, 179,
	FONT_END, 399, 40,
	FONT_ADVANCE, 500, 0
    },
    {
	55,
	FONT_BEGIN, 449, 662,
	FONT_NEXT, 449, 646,
	FONT_NEXT, 79, 662,
	FONT_END, 370, 588,
	FONT_BEGIN, 370, 588,
	FONT_NEXT, 449, 646,
	FONT_END, 237, -8,
	FONT_BEGIN, 370, 588,
	FONT_NEXT, 237, -8,
	FONT_END, 172, -8,
	FONT_BEGIN, 37, 507,
	FONT_NEXT, 20, 515,
	FONT_NEXT, 59, 541,
	FONT_NEXT, 63, 618,
	FONT_END, 79, 662,
	FONT_BEGIN, 59, 541,
	FONT_NEXT, 79, 662,
	FONT_NEXT, 83, 567,
	FONT_END, 112, 582,
	FONT_BEGIN, 112, 582,
	FONT_NEXT, 79, 662,
	FONT_NEXT, 153, 588,
	FONT_END, 370, 588,
	FONT_ADVANCE, 500, 0
    },
    {
	56,
	FONT_BEGIN, 136, 547,
	FONT_NEXT, 150, 492,
	FONT_NEXT, 131, 381,
	FONT_NEXT, 185, 447,
	FONT_NEXT, 186, 332,
	FONT_END, 212, 312,
	FONT_BEGIN, 212, 312,
	FONT_NEXT, 185, 447,
	FONT_END, 226, 412,
	FONT_BEGIN, 212, 312,
	FONT_NEXT, 226, 412,
	FONT_END, 261, 389,
	FONT_BEGIN, 212, 312,
	FONT_NEXT, 261, 389,
	FONT_NEXT, 285, 258,
	FONT_END, 290, 371,
	FONT_BEGIN, 290, 371,
	FONT_NEXT, 261, 389,
	FONT_END, 291, 410,
	FONT_BEGIN, 290, 371,
	FONT_NEXT, 291, 410,
	FONT_END, 322, 440,
	FONT_BEGIN, 290, 371,
	FONT_NEXT, 322, 440,
	FONT_NEXT, 333, 395,
	FONT_NEXT, 345, 481,
	FONT_END, 355, 539,
	FONT_BEGIN, 333, 395,
	FONT_NEXT, 355, 539,
	FONT_NEXT, 377, 428,
	FONT_NEXT, 348, 579,
	FONT_NEXT, 378, 633,
	FONT_END, 324, 664,
	FONT_BEGIN, 324, 664,
	FONT_NEXT, 348, 579,
	FONT_END, 327, 614,
	FONT_BEGIN, 324, 664,
	FONT_NEXT, 327, 614,
	FONT_END, 292, 638,
	FONT_BEGIN, 324, 664,
	FONT_NEXT, 292, 638,
	FONT_NEXT, 249, 676,
	FONT_NEXT, 243, 648,
	FONT_NEXT, 183, 665,
	FONT_NEXT, 194, 638,
	FONT_END, 161, 615,
	FONT_BEGIN, 183, 665,
	FONT_NEXT, 161, 615,
	FONT_NEXT, 123, 636,
	FONT_NEXT, 142, 583,
	FONT_END, 136, 547,
	FONT_BEGIN, 123, 636,
	FONT_NEXT, 136, 547,
	FONT_END, 131, 381,
	FONT_BEGIN, 123, 636,
	FONT_NEXT, 131, 381,
	FONT_END, 92, 423,
	FONT_BEGIN, 123, 636,
	FONT_NEXT, 92, 423,
	FONT_NEXT, 79, 587,
	FONT_NEXT, 69, 467,
	FONT_NEXT, 66, 556,
	FONT_END, 62, 521,
	FONT_BEGIN, 56, 146,
	FONT_NEXT, 63, 202,
	FONT_NEXT, 68, 88,
	FONT_NEXT, 87, 246,
	FONT_NEXT, 104, 36,
	FONT_NEXT, 128, 286,
	FONT_NEXT, 132, 156,
	FONT_END, 140, 215,
	FONT_BEGIN, 140, 215,
	FONT_NEXT, 128, 286,
	FONT_NEXT, 160, 258,
	FONT_END, 186, 289,
	FONT_BEGIN, 186, 289,
	FONT_NEXT, 128, 286,
	FONT_END, 186, 332,
	FONT_BEGIN, 186, 289,
	FONT_NEXT, 186, 332,
	FONT_END, 212, 312,
	FONT_BEGIN, 285, 258,
	FONT_NEXT, 290, 371,
	FONT_NEXT, 333, 216,
	FONT_NEXT, 335, 336,
	FONT_NEXT, 360, 174,
	FONT_END, 369, 126,
	FONT_BEGIN, 369, 126,
	FONT_NEXT, 335, 336,
	FONT_END, 370, 305,
	FONT_BEGIN, 369, 126,
	FONT_NEXT, 370, 305,
	FONT_END, 381, 24,
	FONT_BEGIN, 369, 126,
	FONT_NEXT, 381, 24,
	FONT_END, 347, 4,
	FONT_BEGIN, 369, 126,
	FONT_NEXT, 347, 4,
	FONT_NEXT, 360, 78,
	FONT_END, 337, 43,
	FONT_BEGIN, 337, 43,
	FONT_NEXT, 347, 4,
	FONT_END, 302, -10,
	FONT_BEGIN, 337, 43,
	FONT_NEXT, 302, -10,
	FONT_NEXT, 302, 21,
	FONT_END, 259, 14,
	FONT_BEGIN, 259, 14,
	FONT_NEXT, 302, -10,
	FONT_END, 246, -14,
	FONT_BEGIN, 259, 14,
	FONT_NEXT, 246, -14,
	FONT_NEXT, 204, 25,
	FONT_NEXT, 202, -11,
	FONT_NEXT, 165, 56,
	FONT_NEXT, 164, 0,
	FONT_NEXT, 140, 101,
	FONT_NEXT, 104, 36,
	FONT_END, 132, 156,
	FONT_BEGIN, 445, 150,
	FONT_NEXT, 437, 102,
	FONT_NEXT, 439, 199,
	FONT_END, 417, 249,
	FONT_BEGIN, 417, 249,
	FONT_NEXT, 437, 102,
	FONT_END, 407, 48,
	FONT_BEGIN, 417, 249,
	FONT_NEXT, 407, 48,
	FONT_NEXT, 370, 305,
	FONT_END, 381, 24,
	FONT_BEGIN, 424, 534,
	FONT_NEXT, 410, 473,
	FONT_NEXT, 412, 588,
	FONT_END, 378, 633,
	FONT_BEGIN, 378, 633,
	FONT_NEXT, 410, 473,
	FONT_END, 377, 428,
	FONT_BEGIN, 378, 633,
	FONT_END, 377, 428,
	FONT_ADVANCE, 500, 0
    },
    {
	57,
	FONT_BEGIN, 459, 396,
	FONT_NEXT, 452, 317,
	FONT_NEXT, 454, 455,
	FONT_END, 442, 510,
	FONT_BEGIN, 442, 510,
	FONT_NEXT, 452, 317,
	FONT_END, 432, 243,
	FONT_BEGIN, 442, 510,
	FONT_NEXT, 432, 243,
	FONT_NEXT, 422, 557,
	FONT_NEXT, 399, 174,
	FONT_NEXT, 395, 598,
	FONT_NEXT, 354, 113,
	FONT_END, 362, 355,
	FONT_BEGIN, 395, 598,
	FONT_NEXT, 362, 355,
	FONT_NEXT, 363, 631,
	FONT_NEXT, 362, 394,
	FONT_END, 361, 421,
	FONT_BEGIN, 363, 631,
	FONT_NEXT, 361, 421,
	FONT_END, 359, 458,
	FONT_BEGIN, 363, 631,
	FONT_NEXT, 359, 458,
	FONT_END, 345, 543,
	FONT_BEGIN, 363, 631,
	FONT_NEXT, 345, 543,
	FONT_NEXT, 326, 655,
	FONT_NEXT, 329, 583,
	FONT_END, 305, 616,
	FONT_BEGIN, 326, 655,
	FONT_NEXT, 305, 616,
	FONT_NEXT, 284, 670,
	FONT_NEXT, 272, 639,
	FONT_NEXT, 240, 676,
	FONT_NEXT, 229, 648,
	FONT_NEXT, 193, 671,
	FONT_NEXT, 200, 643,
	FONT_END, 176, 632,
	FONT_BEGIN, 193, 671,
	FONT_NEXT, 176, 632,
	FONT_NEXT, 152, 657,
	FONT_NEXT, 144, 591,
	FONT_NEXT, 116, 634,
	FONT_NEXT, 126, 534,
	FONT_END, 122, 473,
	FONT_BEGIN, 116, 634,
	FONT_NEXT, 122, 473,
	FONT_END, 94, 278,
	FONT_BEGIN, 116, 634,
	FONT_NEXT, 94, 278,
	FONT_NEXT, 86, 605,
	FONT_NEXT, 69, 305,
	FONT_NEXT, 62, 569,
	FONT_NEXT, 39, 369,
	FONT_NEXT, 44, 528,
	FONT_END, 30, 435,
	FONT_BEGIN, 56, -2,
	FONT_NEXT, 138, 21,
	FONT_NEXT, 59, -22,
	FONT_END, 149, -9,
	FONT_BEGIN, 149, -9,
	FONT_NEXT, 138, 21,
	FONT_END, 204, 56,
	FONT_BEGIN, 149, -9,
	FONT_NEXT, 204, 56,
	FONT_NEXT, 228, 20,
	FONT_NEXT, 256, 101,
	FONT_END, 296, 149,
	FONT_BEGIN, 228, 20,
	FONT_NEXT, 296, 149,
	FONT_NEXT, 297, 61,
	FONT_NEXT, 324, 197,
	FONT_END, 343, 239,
	FONT_BEGIN, 297, 61,
	FONT_NEXT, 343, 239,
	FONT_NEXT, 354, 113,
	FONT_NEXT, 354, 271,
	FONT_END, 359, 290,
	FONT_BEGIN, 354, 113,
	FONT_NEXT, 359, 290,
	FONT_NEXT, 362, 355,
	FONT_END, 358, 332,
	FONT_BEGIN, 358, 332,
	FONT_NEXT, 359, 290,
	FONT_END, 357, 292,
	FONT_BEGIN, 358, 332,
	FONT_NEXT, 357, 292,
	FONT_NEXT, 346, 315,
	FONT_NEXT, 285, 250,
	FONT_NEXT, 302, 291,
	FONT_END, 250, 280,
	FONT_BEGIN, 250, 280,
	FONT_NEXT, 285, 250,
	FONT_END, 210, 237,
	FONT_BEGIN, 250, 280,
	FONT_NEXT, 210, 237,
	FONT_NEXT, 214, 285,
	FONT_END, 185, 299,
	FONT_BEGIN, 185, 299,
	FONT_NEXT, 210, 237,
	FONT_END, 163, 242,
	FONT_BEGIN, 185, 299,
	FONT_NEXT, 163, 242,
	FONT_NEXT, 146, 348,
	FONT_NEXT, 125, 256,
	FONT_NEXT, 127, 410,
	FONT_END, 122, 473,
	FONT_BEGIN, 122, 473,
	FONT_NEXT, 125, 256,
	FONT_END, 94, 278,
	FONT_BEGIN, 122, 473,
	FONT_END, 94, 278,
	FONT_ADVANCE, 500, 0
    },
    {
	58,
	FONT_BEGIN, 192, 43,
	FONT_NEXT, 186, 18,
	FONT_NEXT, 187, 64,
	FONT_END, 175, 83,
	FONT_BEGIN, 175, 83,
	FONT_NEXT, 186, 18,
	FONT_END, 171, 2,
	FONT_BEGIN, 175, 83,
	FONT_NEXT, 171, 2,
	FONT_NEXT, 157, 95,
	FONT_NEXT, 136, -11,
	FONT_NEXT, 136, 100,
	FONT_END, 114, 95,
	FONT_BEGIN, 114, 95,
	FONT_NEXT, 136, -11,
	FONT_END, 100, 1,
	FONT_BEGIN, 114, 95,
	FONT_NEXT, 100, 1,
	FONT_NEXT, 97, 83,
	FONT_NEXT, 86, 18,
	FONT_NEXT, 85, 65,
	FONT_END, 81, 43,
	FONT_BEGIN, 192, 402,
	FONT_NEXT, 186, 377,
	FONT_NEXT, 187, 423,
	FONT_END, 175, 442,
	FONT_BEGIN, 175, 442,
	FONT_NEXT, 186, 377,
	FONT_END, 171, 361,
	FONT_BEGIN, 175, 442,
	FONT_NEXT, 171, 361,
	FONT_NEXT, 157, 454,
	FONT_NEXT, 136, 348,
	FONT_NEXT, 136, 459,
	FONT_END, 114, 454,
	FONT_BEGIN, 114, 454,
	FONT_NEXT, 136, 348,
	FONT_END, 100, 360,
	FONT_BEGIN, 114, 454,
	FONT_NEXT, 100, 360,
	FONT_NEXT, 97, 442,
	FONT_NEXT, 86, 377,
	FONT_NEXT, 85, 424,
	FONT_END, 81, 402,
	FONT_ADVANCE, 278, 0
    },
    {
	59,
	FONT_BEGIN, 107, -141,
	FONT_NEXT, 98, -122,
	FONT_NEXT, 138, -123,
	FONT_NEXT, 138, -91,
	FONT_END, 163, -61,
	FONT_BEGIN, 138, -123,
	FONT_NEXT, 163, -61,
	FONT_NEXT, 175, -90,
	FONT_NEXT, 176, -35,
	FONT_END, 180, -16,
	FONT_BEGIN, 175, -90,
	FONT_NEXT, 180, -16,
	FONT_NEXT, 206, -45,
	FONT_END, 186, 85,
	FONT_BEGIN, 186, 85,
	FONT_NEXT, 180, -16,
	FONT_NEXT, 160, 98,
	FONT_NEXT, 175, -6,
	FONT_END, 166, -2,
	FONT_BEGIN, 160, 98,
	FONT_NEXT, 166, -2,
	FONT_END, 157, -4,
	FONT_BEGIN, 160, 98,
	FONT_NEXT, 157, -4,
	FONT_NEXT, 139, 102,
	FONT_NEXT, 142, -6,
	FONT_END, 99, 5,
	FONT_BEGIN, 139, 102,
	FONT_NEXT, 99, 5,
	FONT_NEXT, 125, 100,
	FONT_END, 105, 93,
	FONT_BEGIN, 105, 93,
	FONT_NEXT, 99, 5,
	FONT_NEXT, 87, 76,
	FONT_NEXT, 85, 20,
	FONT_END, 80, 44,
	FONT_BEGIN, 219, 6,
	FONT_NEXT, 206, -45,
	FONT_NEXT, 209, 56,
	FONT_END, 186, 85,
	FONT_BEGIN, 192, 402,
	FONT_NEXT, 186, 377,
	FONT_NEXT, 187, 423,
	FONT_END, 175, 442,
	FONT_BEGIN, 175, 442,
	FONT_NEXT, 186, 377,
	FONT_END, 171, 361,
	FONT_BEGIN, 175, 442,
	FONT_NEXT, 171, 361,
	FONT_NEXT, 157, 454,
	FONT_NEXT, 136, 348,
	FONT_NEXT, 136, 459,
	FONT_END, 114, 454,
	FONT_BEGIN, 114, 454,
	FONT_NEXT, 136, 348,
	FONT_END, 100, 360,
	FONT_BEGIN, 114, 454,
	FONT_NEXT, 100, 360,
	FONT_NEXT, 97, 442,
	FONT_NEXT, 86, 377,
	FONT_NEXT, 85, 424,
	FONT_END, 81, 402,
	FONT_ADVANCE, 278, 0
    },
    {
	60,
	FONT_BEGIN, 536, 514,
	FONT_NEXT, 536, 446,
	FONT_NEXT, 28, 284,
	FONT_NEXT, 111, 253,
	FONT_NEXT, 28, 222,
	FONT_END, 536, -8,
	FONT_BEGIN, 536, -8,
	FONT_NEXT, 111, 253,
	FONT_END, 536, 60,
	FONT_BEGIN, 536, -8,
	FONT_END, 536, 60,
	FONT_ADVANCE, 564, 0
    },
    {
	61,
	FONT_BEGIN, 534, 186,
	FONT_NEXT, 534, 120,
	FONT_NEXT, 30, 186,
	FONT_END, 30, 120,
	FONT_BEGIN, 534, 386,
	FONT_NEXT, 534, 320,
	FONT_NEXT, 30, 386,
	FONT_END, 30, 320,
	FONT_ADVANCE, 564, 0
    },
    {
	62,
	FONT_BEGIN, 28, 446,
	FONT_NEXT, 28, 514,
	FONT_NEXT, 453, 253,
	FONT_NEXT, 536, 222,
	FONT_END, 28, -8,
	FONT_BEGIN, 453, 253,
	FONT_NEXT, 28, -8,
	FONT_END, 28, 60,
	FONT_BEGIN, 536, 222,
	FONT_NEXT, 28, 514,
	FONT_END, 536, 284,
	FONT_ADVANCE, 564, 0
    },
    {
	63,
	FONT_BEGIN, 68, 532,
	FONT_NEXT, 72, 567,
	FONT_NEXT, 78, 487,
	FONT_NEXT, 83, 597,
	FONT_NEXT, 93, 474,
	FONT_END, 118, 469,
	FONT_BEGIN, 118, 469,
	FONT_NEXT, 83, 597,
	FONT_END, 119, 585,
	FONT_BEGIN, 118, 469,
	FONT_NEXT, 119, 585,
	FONT_NEXT, 135, 473,
	FONT_END, 148, 483,
	FONT_BEGIN, 148, 483,
	FONT_NEXT, 119, 585,
	FONT_END, 157, 510,
	FONT_BEGIN, 148, 483,
	FONT_END, 157, 510,
	FONT_BEGIN, 414, 510,
	FONT_NEXT, 406, 469,
	FONT_NEXT, 412, 544,
	FONT_END, 406, 571,
	FONT_BEGIN, 406, 571,
	FONT_NEXT, 406, 469,
	FONT_NEXT, 378, 618,
	FONT_NEXT, 387, 426,
	FONT_END, 363, 385,
	FONT_BEGIN, 378, 618,
	FONT_NEXT, 363, 385,
	FONT_NEXT, 352, 639,
	FONT_NEXT, 339, 354,
	FONT_NEXT, 316, 657,
	FONT_NEXT, 322, 519,
	FONT_END, 315, 564,
	FONT_BEGIN, 316, 657,
	FONT_NEXT, 315, 564,
	FONT_NEXT, 274, 671,
	FONT_NEXT, 295, 605,
	FONT_END, 261, 634,
	FONT_BEGIN, 274, 671,
	FONT_NEXT, 261, 634,
	FONT_NEXT, 231, 676,
	FONT_NEXT, 212, 646,
	FONT_NEXT, 176, 667,
	FONT_NEXT, 179, 641,
	FONT_END, 149, 627,
	FONT_BEGIN, 176, 667,
	FONT_NEXT, 149, 627,
	FONT_NEXT, 123, 641,
	FONT_NEXT, 127, 608,
	FONT_END, 119, 585,
	FONT_BEGIN, 123, 641,
	FONT_NEXT, 119, 585,
	FONT_END, 83, 597,
	FONT_BEGIN, 227, 164,
	FONT_NEXT, 239, 251,
	FONT_NEXT, 244, 164,
	FONT_NEXT, 249, 286,
	FONT_NEXT, 257, 220,
	FONT_NEXT, 257, 306,
	FONT_NEXT, 276, 267,
	FONT_NEXT, 285, 370,
	FONT_NEXT, 302, 309,
	FONT_NEXT, 310, 444,
	FONT_END, 322, 519,
	FONT_BEGIN, 302, 309,
	FONT_NEXT, 322, 519,
	FONT_END, 339, 354,
	FONT_BEGIN, 292, 43,
	FONT_NEXT, 286, 19,
	FONT_NEXT, 287, 63,
	FONT_END, 276, 80,
	FONT_BEGIN, 276, 80,
	FONT_NEXT, 286, 19,
	FONT_END, 273, 4,
	FONT_BEGIN, 276, 80,
	FONT_NEXT, 273, 4,
	FONT_NEXT, 258, 92,
	FONT_NEXT, 237, -8,
	FONT_NEXT, 237, 97,
	FONT_END, 216, 92,
	FONT_BEGIN, 216, 92,
	FONT_NEXT, 237, -8,
	FONT_END, 202, 3,
	FONT_BEGIN, 216, 92,
	FONT_NEXT, 202, 3,
	FONT_NEXT, 199, 81,
	FONT_NEXT, 189, 19,
	FONT_NEXT, 188, 64,
	FONT_END, 184, 43,
	FONT_ADVANCE, 444, 0
    },
    {
	64,
	FONT_BEGIN, 321, 268,
	FONT_NEXT, 323, 298,
	FONT_NEXT, 323, 230,
	FONT_END, 332, 200,
	FONT_BEGIN, 332, 200,
	FONT_NEXT, 323, 298,
	FONT_END, 332, 335,
	FONT_BEGIN, 332, 200,
	FONT_NEXT, 332, 335,
	FONT_NEXT, 358, 163,
	FONT_NEXT, 368, 414,
	FONT_NEXT, 390, 147,
	FONT_NEXT, 392, 271,
	FONT_END, 396, 232,
	FONT_BEGIN, 390, 147,
	FONT_NEXT, 396, 232,
	FONT_END, 410, 206,
	FONT_BEGIN, 390, 147,
	FONT_NEXT, 410, 206,
	FONT_NEXT, 417, 144,
	FONT_NEXT, 430, 191,
	FONT_END, 455, 187,
	FONT_BEGIN, 417, 144,
	FONT_NEXT, 455, 187,
	FONT_NEXT, 457, 154,
	FONT_NEXT, 489, 200,
	FONT_NEXT, 492, 174,
	FONT_END, 517, 196,
	FONT_BEGIN, 517, 196,
	FONT_NEXT, 489, 200,
	FONT_END, 524, 240,
	FONT_BEGIN, 517, 196,
	FONT_NEXT, 524, 240,
	FONT_NEXT, 532, 214,
	FONT_END, 534, 214,
	FONT_BEGIN, 534, 214,
	FONT_NEXT, 524, 240,
	FONT_END, 553, 173,
	FONT_BEGIN, 534, 214,
	FONT_NEXT, 553, 173,
	FONT_END, 538, 197,
	FONT_BEGIN, 668, 494,
	FONT_NEXT, 603, 240,
	FONT_NEXT, 599, 494,
	FONT_NEXT, 603, 202,
	FONT_END, 581, 152,
	FONT_BEGIN, 599, 494,
	FONT_NEXT, 581, 152,
	FONT_NEXT, 589, 456,
	FONT_NEXT, 572, 399,
	FONT_NEXT, 565, 491,
	FONT_NEXT, 569, 426,
	FONT_END, 561, 447,
	FONT_BEGIN, 565, 491,
	FONT_NEXT, 561, 447,
	FONT_NEXT, 546, 503,
	FONT_NEXT, 548, 459,
	FONT_END, 529, 464,
	FONT_BEGIN, 546, 503,
	FONT_NEXT, 529, 464,
	FONT_NEXT, 518, 508,
	FONT_NEXT, 487, 450,
	FONT_NEXT, 470, 500,
	FONT_NEXT, 442, 412,
	FONT_NEXT, 430, 480,
	FONT_NEXT, 406, 352,
	FONT_NEXT, 396, 450,
	FONT_NEXT, 395, 314,
	FONT_NEXT, 368, 414,
	FONT_END, 392, 271,
	FONT_BEGIN, 116, 315,
	FONT_NEXT, 123, 392,
	FONT_NEXT, 121, 262,
	FONT_END, 137, 207,
	FONT_BEGIN, 137, 207,
	FONT_NEXT, 123, 392,
	FONT_END, 145, 462,
	FONT_BEGIN, 137, 207,
	FONT_NEXT, 145, 462,
	FONT_NEXT, 165, 152,
	FONT_NEXT, 179, 524,
	FONT_NEXT, 200, 305,
	FONT_END, 205, 383,
	FONT_BEGIN, 205, 383,
	FONT_NEXT, 179, 524,
	FONT_NEXT, 222, 451,
	FONT_NEXT, 224, 576,
	FONT_NEXT, 248, 510,
	FONT_NEXT, 278, 618,
	FONT_NEXT, 283, 558,
	FONT_END, 324, 595,
	FONT_BEGIN, 324, 595,
	FONT_NEXT, 278, 618,
	FONT_END, 340, 649,
	FONT_BEGIN, 324, 595,
	FONT_NEXT, 340, 649,
	FONT_NEXT, 372, 623,
	FONT_NEXT, 408, 669,
	FONT_NEXT, 424, 639,
	FONT_END, 481, 645,
	FONT_BEGIN, 481, 645,
	FONT_NEXT, 408, 669,
	FONT_END, 481, 676,
	FONT_BEGIN, 481, 645,
	FONT_NEXT, 481, 676,
	FONT_NEXT, 545, 638,
	FONT_NEXT, 547, 670,
	FONT_NEXT, 603, 619,
	FONT_NEXT, 609, 653,
	FONT_NEXT, 652, 591,
	FONT_NEXT, 665, 627,
	FONT_NEXT, 693, 555,
	FONT_NEXT, 714, 591,
	FONT_NEXT, 726, 513,
	FONT_END, 749, 469,
	FONT_BEGIN, 749, 469,
	FONT_NEXT, 714, 591,
	FONT_END, 753, 548,
	FONT_BEGIN, 749, 469,
	FONT_NEXT, 753, 548,
	FONT_NEXT, 764, 424,
	FONT_END, 769, 380,
	FONT_BEGIN, 769, 380,
	FONT_NEXT, 753, 548,
	FONT_END, 783, 498,
	FONT_BEGIN, 769, 380,
	FONT_NEXT, 783, 498,
	FONT_END, 760, 223,
	FONT_BEGIN, 769, 380,
	FONT_NEXT, 760, 223,
	FONT_NEXT, 760, 311,
	FONT_END, 734, 245,
	FONT_BEGIN, 734, 245,
	FONT_NEXT, 760, 223,
	FONT_END, 734, 191,
	FONT_BEGIN, 734, 245,
	FONT_NEXT, 734, 191,
	FONT_NEXT, 693, 195,
	FONT_NEXT, 702, 165,
	FONT_END, 665, 149,
	FONT_BEGIN, 693, 195,
	FONT_NEXT, 665, 149,
	FONT_NEXT, 667, 181,
	FONT_END, 639, 176,
	FONT_BEGIN, 639, 176,
	FONT_NEXT, 665, 149,
	FONT_END, 623, 143,
	FONT_BEGIN, 639, 176,
	FONT_NEXT, 623, 143,
	FONT_NEXT, 613, 183,
	FONT_NEXT, 581, 152,
	FONT_END, 603, 202,
	FONT_BEGIN, 700, 43,
	FONT_NEXT, 601, 3,
	FONT_NEXT, 688, 73,
	FONT_END, 601, 39,
	FONT_BEGIN, 601, 39,
	FONT_NEXT, 601, 3,
	FONT_NEXT, 550, 28,
	FONT_NEXT, 547, -10,
	FONT_NEXT, 490, 25,
	FONT_NEXT, 491, -14,
	FONT_END, 399, -6,
	FONT_BEGIN, 490, 25,
	FONT_NEXT, 399, -6,
	FONT_NEXT, 427, 31,
	FONT_END, 371, 48,
	FONT_BEGIN, 371, 48,
	FONT_NEXT, 399, -6,
	FONT_END, 322, 18,
	FONT_BEGIN, 371, 48,
	FONT_NEXT, 322, 18,
	FONT_NEXT, 321, 75,
	FONT_NEXT, 257, 54,
	FONT_NEXT, 279, 111,
	FONT_END, 245, 153,
	FONT_BEGIN, 245, 153,
	FONT_NEXT, 257, 54,
	FONT_END, 205, 100,
	FONT_BEGIN, 245, 153,
	FONT_NEXT, 205, 100,
	FONT_NEXT, 220, 200,
	FONT_END, 205, 251,
	FONT_BEGIN, 205, 251,
	FONT_NEXT, 205, 100,
	FONT_NEXT, 200, 305,
	FONT_END, 165, 152,
	FONT_BEGIN, 809, 381,
	FONT_NEXT, 796, 300,
	FONT_NEXT, 802, 442,
	FONT_END, 783, 498,
	FONT_BEGIN, 783, 498,
	FONT_NEXT, 796, 300,
	FONT_END, 760, 223,
	FONT_BEGIN, 783, 498,
	FONT_END, 760, 223,
	FONT_BEGIN, 524, 240,
	FONT_NEXT, 554, 306,
	FONT_NEXT, 553, 173,
	FONT_NEXT, 572, 399,
	FONT_END, 581, 152,
	FONT_ADVANCE, 921, 0
    },
    {
	65,
	FONT_BEGIN, 451, 19,
	FONT_NEXT, 499, 24,
	FONT_NEXT, 451, 0,
	FONT_END, 637, 62,
	FONT_BEGIN, 637, 62,
	FONT_NEXT, 499, 24,
	FONT_END, 515, 35,
	FONT_BEGIN, 637, 62,
	FONT_NEXT, 515, 35,
	FONT_NEXT, 616, 106,
	FONT_NEXT, 521, 57,
	FONT_NEXT, 367, 674,
	FONT_NEXT, 502, 120,
	FONT_END, 461, 216,
	FONT_BEGIN, 367, 674,
	FONT_NEXT, 461, 216,
	FONT_END, 447, 257,
	FONT_BEGIN, 367, 674,
	FONT_NEXT, 447, 257,
	FONT_END, 331, 532,
	FONT_BEGIN, 367, 674,
	FONT_NEXT, 331, 532,
	FONT_NEXT, 347, 674,
	FONT_END, 139, 183,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 331, 532,
	FONT_END, 216, 257,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 216, 257,
	FONT_END, 199, 216,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 199, 216,
	FONT_END, 153, 99,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 153, 99,
	FONT_END, 145, 61,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 145, 61,
	FONT_NEXT, 104, 104,
	FONT_END, 84, 67,
	FONT_BEGIN, 84, 67,
	FONT_NEXT, 145, 61,
	FONT_NEXT, 66, 41,
	FONT_NEXT, 15, 0,
	FONT_NEXT, 39, 23,
	FONT_END, 15, 19,
	FONT_BEGIN, 706, 19,
	FONT_NEXT, 706, 0,
	FONT_NEXT, 677, 23,
	FONT_NEXT, 451, 0,
	FONT_NEXT, 656, 36,
	FONT_END, 637, 62,
	FONT_BEGIN, 216, 257,
	FONT_NEXT, 447, 257,
	FONT_NEXT, 199, 216,
	FONT_END, 461, 216,
	FONT_BEGIN, 213, 19,
	FONT_NEXT, 213, 0,
	FONT_NEXT, 171, 24,
	FONT_NEXT, 15, 0,
	FONT_NEXT, 152, 36,
	FONT_END, 145, 61,
	FONT_ADVANCE, 722, 0
    },
    {
	66,
	FONT_BEGIN, 17, 19,
	FONT_NEXT, 67, 23,
	FONT_NEXT, 17, 0,
	FONT_END, 215, 78,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 67, 23,
	FONT_END, 96, 38,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 96, 38,
	FONT_END, 109, 65,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 109, 65,
	FONT_END, 113, 109,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 113, 109,
	FONT_END, 113, 553,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 113, 553,
	FONT_END, 109, 597,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 109, 597,
	FONT_NEXT, 215, 326,
	FONT_END, 215, 365,
	FONT_BEGIN, 215, 365,
	FONT_NEXT, 109, 597,
	FONT_NEXT, 215, 595,
	FONT_NEXT, 95, 624,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 66, 637,
	FONT_END, 17, 643,
	FONT_BEGIN, 215, 326,
	FONT_NEXT, 215, 365,
	FONT_NEXT, 276, 325,
	FONT_NEXT, 310, 366,
	FONT_NEXT, 319, 322,
	FONT_NEXT, 344, 368,
	FONT_NEXT, 377, 311,
	FONT_NEXT, 394, 381,
	FONT_NEXT, 414, 295,
	FONT_NEXT, 426, 347,
	FONT_NEXT, 447, 270,
	FONT_END, 469, 232,
	FONT_BEGIN, 469, 232,
	FONT_NEXT, 426, 347,
	FONT_END, 488, 327,
	FONT_BEGIN, 469, 232,
	FONT_NEXT, 488, 327,
	FONT_NEXT, 478, 180,
	FONT_NEXT, 482, 22,
	FONT_NEXT, 472, 135,
	FONT_NEXT, 425, 6,
	FONT_NEXT, 458, 101,
	FONT_END, 436, 75,
	FONT_BEGIN, 436, 75,
	FONT_NEXT, 425, 6,
	FONT_NEXT, 409, 58,
	FONT_NEXT, 351, 0,
	FONT_NEXT, 348, 40,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 291, 37,
	FONT_END, 254, 38,
	FONT_BEGIN, 254, 38,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 231, 43,
	FONT_END, 218, 55,
	FONT_BEGIN, 218, 55,
	FONT_NEXT, 17, 0,
	FONT_END, 215, 78,
	FONT_BEGIN, 218, 55,
	FONT_END, 215, 78,
	FONT_BEGIN, 215, 595,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 218, 615,
	FONT_END, 237, 624,
	FONT_BEGIN, 237, 624,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 255, 624,
	FONT_END, 282, 625,
	FONT_BEGIN, 282, 625,
	FONT_NEXT, 17, 662,
	FONT_END, 297, 662,
	FONT_BEGIN, 282, 625,
	FONT_NEXT, 297, 662,
	FONT_NEXT, 339, 620,
	FONT_NEXT, 374, 657,
	FONT_NEXT, 396, 600,
	FONT_END, 420, 582,
	FONT_BEGIN, 420, 582,
	FONT_NEXT, 374, 657,
	FONT_NEXT, 439, 558,
	FONT_NEXT, 460, 635,
	FONT_NEXT, 452, 527,
	FONT_END, 457, 487,
	FONT_BEGIN, 457, 487,
	FONT_NEXT, 460, 635,
	FONT_END, 465, 360,
	FONT_BEGIN, 457, 487,
	FONT_NEXT, 465, 360,
	FONT_NEXT, 451, 447,
	FONT_NEXT, 426, 349,
	FONT_NEXT, 437, 417,
	FONT_END, 394, 381,
	FONT_BEGIN, 394, 381,
	FONT_NEXT, 426, 349,
	FONT_END, 426, 347,
	FONT_BEGIN, 394, 381,
	FONT_END, 426, 347,
	FONT_BEGIN, 559, 493,
	FONT_NEXT, 555, 455,
	FONT_NEXT, 551, 544,
	FONT_NEXT, 544, 425,
	FONT_NEXT, 530, 584,
	FONT_NEXT, 509, 383,
	FONT_NEXT, 499, 614,
	FONT_NEXT, 465, 360,
	FONT_END, 460, 635,
	FONT_BEGIN, 593, 176,
	FONT_NEXT, 586, 132,
	FONT_NEXT, 589, 212,
	FONT_END, 579, 244,
	FONT_BEGIN, 579, 244,
	FONT_NEXT, 586, 132,
	FONT_END, 574, 103,
	FONT_BEGIN, 579, 244,
	FONT_NEXT, 574, 103,
	FONT_NEXT, 542, 294,
	FONT_NEXT, 555, 73,
	FONT_END, 525, 45,
	FONT_BEGIN, 542, 294,
	FONT_NEXT, 525, 45,
	FONT_NEXT, 488, 327,
	FONT_END, 482, 22,
	FONT_ADVANCE, 667, 0
    },
    {
	67,
	FONT_BEGIN, 620, 451,
	FONT_NEXT, 597, 451,
	FONT_NEXT, 611, 676,
	FONT_END, 590, 676,
	FONT_BEGIN, 590, 676,
	FONT_NEXT, 597, 451,
	FONT_END, 569, 524,
	FONT_BEGIN, 590, 676,
	FONT_NEXT, 569, 524,
	FONT_NEXT, 580, 656,
	FONT_END, 565, 647,
	FONT_BEGIN, 565, 647,
	FONT_NEXT, 569, 524,
	FONT_END, 523, 582,
	FONT_BEGIN, 565, 647,
	FONT_NEXT, 523, 582,
	FONT_NEXT, 544, 643,
	FONT_END, 519, 648,
	FONT_BEGIN, 519, 648,
	FONT_NEXT, 523, 582,
	FONT_END, 459, 621,
	FONT_BEGIN, 519, 648,
	FONT_NEXT, 459, 621,
	FONT_NEXT, 481, 659,
	FONT_END, 429, 670,
	FONT_BEGIN, 429, 670,
	FONT_NEXT, 459, 621,
	FONT_END, 420, 632,
	FONT_BEGIN, 429, 670,
	FONT_NEXT, 420, 632,
	FONT_NEXT, 368, 676,
	FONT_NEXT, 377, 636,
	FONT_END, 299, 620,
	FONT_BEGIN, 368, 676,
	FONT_NEXT, 299, 620,
	FONT_NEXT, 304, 670,
	FONT_END, 242, 653,
	FONT_BEGIN, 242, 653,
	FONT_NEXT, 299, 620,
	FONT_END, 261, 601,
	FONT_BEGIN, 242, 653,
	FONT_NEXT, 261, 601,
	FONT_END, 227, 575,
	FONT_BEGIN, 242, 653,
	FONT_NEXT, 227, 575,
	FONT_NEXT, 184, 625,
	FONT_NEXT, 197, 540,
	FONT_END, 170, 491,
	FONT_BEGIN, 184, 625,
	FONT_NEXT, 170, 491,
	FONT_NEXT, 133, 587,
	FONT_NEXT, 151, 422,
	FONT_END, 144, 329,
	FONT_BEGIN, 133, 587,
	FONT_NEXT, 144, 329,
	FONT_END, 134, 65,
	FONT_BEGIN, 133, 587,
	FONT_NEXT, 134, 65,
	FONT_END, 91, 112,
	FONT_BEGIN, 133, 587,
	FONT_NEXT, 91, 112,
	FONT_NEXT, 90, 538,
	FONT_NEXT, 57, 172,
	FONT_NEXT, 56, 479,
	FONT_NEXT, 35, 244,
	FONT_NEXT, 35, 410,
	FONT_END, 28, 331,
	FONT_BEGIN, 633, 113,
	FONT_NEXT, 628, 106,
	FONT_NEXT, 615, 131,
	FONT_NEXT, 616, 92,
	FONT_END, 595, 71,
	FONT_BEGIN, 615, 131,
	FONT_NEXT, 595, 71,
	FONT_NEXT, 583, 102,
	FONT_NEXT, 566, 48,
	FONT_NEXT, 536, 69,
	FONT_NEXT, 528, 25,
	FONT_NEXT, 471, 41,
	FONT_NEXT, 481, 5,
	FONT_END, 426, -9,
	FONT_BEGIN, 471, 41,
	FONT_NEXT, 426, -9,
	FONT_NEXT, 389, 30,
	FONT_NEXT, 362, -14,
	FONT_NEXT, 342, 34,
	FONT_NEXT, 301, -10,
	FONT_NEXT, 297, 46,
	FONT_NEXT, 241, 4,
	FONT_NEXT, 256, 68,
	FONT_END, 219, 100,
	FONT_BEGIN, 219, 100,
	FONT_NEXT, 241, 4,
	FONT_END, 185, 29,
	FONT_BEGIN, 219, 100,
	FONT_NEXT, 185, 29,
	FONT_NEXT, 188, 141,
	FONT_END, 164, 192,
	FONT_BEGIN, 164, 192,
	FONT_NEXT, 185, 29,
	FONT_END, 134, 65,
	FONT_BEGIN, 164, 192,
	FONT_NEXT, 134, 65,
	FONT_NEXT, 149, 255,
	FONT_END, 144, 329,
	FONT_ADVANCE, 667, 0
    },
    {
	68,
	FONT_BEGIN, 16, 643,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 62, 636,
	FONT_END, 88, 623,
	FONT_BEGIN, 88, 623,
	FONT_NEXT, 16, 662,
	FONT_END, 206, 586,
	FONT_BEGIN, 88, 623,
	FONT_NEXT, 206, 586,
	FONT_NEXT, 101, 597,
	FONT_NEXT, 206, 78,
	FONT_NEXT, 104, 553,
	FONT_END, 104, 109,
	FONT_BEGIN, 104, 109,
	FONT_NEXT, 206, 78,
	FONT_NEXT, 100, 65,
	FONT_END, 88, 39,
	FONT_BEGIN, 88, 39,
	FONT_NEXT, 206, 78,
	FONT_NEXT, 61, 24,
	FONT_NEXT, 16, 0,
	FONT_END, 16, 19,
	FONT_BEGIN, 685, 329,
	FONT_NEXT, 681, 276,
	FONT_NEXT, 677, 407,
	FONT_NEXT, 667, 221,
	FONT_NEXT, 656, 475,
	FONT_NEXT, 643, 166,
	FONT_NEXT, 622, 532,
	FONT_NEXT, 607, 114,
	FONT_NEXT, 575, 579,
	FONT_NEXT, 576, 328,
	FONT_END, 571, 390,
	FONT_BEGIN, 575, 579,
	FONT_NEXT, 571, 390,
	FONT_NEXT, 517, 615,
	FONT_NEXT, 555, 449,
	FONT_END, 526, 505,
	FONT_BEGIN, 517, 615,
	FONT_NEXT, 526, 505,
	FONT_END, 483, 555,
	FONT_BEGIN, 517, 615,
	FONT_NEXT, 483, 555,
	FONT_NEXT, 449, 641,
	FONT_NEXT, 444, 584,
	FONT_NEXT, 372, 656,
	FONT_NEXT, 397, 606,
	FONT_END, 335, 620,
	FONT_BEGIN, 372, 656,
	FONT_NEXT, 335, 620,
	FONT_NEXT, 286, 662,
	FONT_NEXT, 253, 625,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 225, 621,
	FONT_END, 211, 613,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 211, 613,
	FONT_END, 206, 586,
	FONT_BEGIN, 206, 78,
	FONT_NEXT, 208, 57,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 218, 44,
	FONT_END, 236, 38,
	FONT_BEGIN, 16, 0,
	FONT_NEXT, 236, 38,
	FONT_END, 266, 37,
	FONT_BEGIN, 16, 0,
	FONT_NEXT, 266, 37,
	FONT_END, 297, 37,
	FONT_BEGIN, 16, 0,
	FONT_NEXT, 297, 37,
	FONT_NEXT, 300, 0,
	FONT_NEXT, 341, 41,
	FONT_END, 392, 52,
	FONT_BEGIN, 300, 0,
	FONT_NEXT, 392, 52,
	FONT_NEXT, 404, 8,
	FONT_NEXT, 445, 73,
	FONT_NEXT, 489, 32,
	FONT_NEXT, 494, 108,
	FONT_END, 536, 159,
	FONT_BEGIN, 489, 32,
	FONT_NEXT, 536, 159,
	FONT_NEXT, 556, 69,
	FONT_NEXT, 565, 231,
	FONT_END, 573, 276,
	FONT_BEGIN, 556, 69,
	FONT_NEXT, 573, 276,
	FONT_NEXT, 607, 114,
	FONT_END, 576, 328,
	FONT_ADVANCE, 722, 0
    },
    {
	69,
	FONT_BEGIN, 12, 19,
	FONT_NEXT, 52, 23,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 79, 36,
	FONT_NEXT, 201, 80,
	FONT_NEXT, 94, 63,
	FONT_END, 99, 109,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 99, 109,
	FONT_END, 99, 553,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 99, 553,
	FONT_END, 94, 599,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 201, 328,
	FONT_NEXT, 201, 368,
	FONT_NEXT, 355, 326,
	FONT_NEXT, 355, 368,
	FONT_NEXT, 405, 321,
	FONT_NEXT, 408, 372,
	FONT_NEXT, 436, 308,
	FONT_NEXT, 439, 388,
	FONT_NEXT, 454, 279,
	FONT_NEXT, 455, 418,
	FONT_NEXT, 465, 231,
	FONT_NEXT, 465, 463,
	FONT_NEXT, 488, 231,
	FONT_END, 488, 463,
	FONT_BEGIN, 597, 169,
	FONT_NEXT, 552, 0,
	FONT_NEXT, 569, 169,
	FONT_END, 533, 105,
	FONT_BEGIN, 533, 105,
	FONT_NEXT, 552, 0,
	FONT_NEXT, 489, 65,
	FONT_END, 430, 44,
	FONT_BEGIN, 430, 44,
	FONT_NEXT, 552, 0,
	FONT_END, 12, 0,
	FONT_BEGIN, 430, 44,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 350, 38,
	FONT_END, 300, 38,
	FONT_BEGIN, 300, 38,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 263, 38,
	FONT_END, 237, 40,
	FONT_BEGIN, 237, 40,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 219, 43,
	FONT_END, 203, 56,
	FONT_BEGIN, 203, 56,
	FONT_NEXT, 12, 0,
	FONT_END, 201, 80,
	FONT_BEGIN, 203, 56,
	FONT_END, 201, 80,
	FONT_BEGIN, 12, 643,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 52, 637,
	FONT_END, 79, 625,
	FONT_BEGIN, 79, 625,
	FONT_NEXT, 12, 662,
	FONT_END, 201, 590,
	FONT_BEGIN, 79, 625,
	FONT_NEXT, 201, 590,
	FONT_NEXT, 94, 599,
	FONT_END, 201, 368,
	FONT_BEGIN, 546, 519,
	FONT_NEXT, 521, 519,
	FONT_NEXT, 543, 662,
	FONT_NEXT, 506, 572,
	FONT_END, 481, 604,
	FONT_BEGIN, 543, 662,
	FONT_NEXT, 481, 604,
	FONT_END, 437, 620,
	FONT_BEGIN, 543, 662,
	FONT_NEXT, 437, 620,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 369, 624,
	FONT_END, 234, 624,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 234, 624,
	FONT_END, 209, 619,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 209, 619,
	FONT_END, 203, 609,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 203, 609,
	FONT_END, 201, 590,
	FONT_ADVANCE, 611, 0
    },
    {
	70,
	FONT_BEGIN, 12, 643,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 52, 637,
	FONT_END, 79, 625,
	FONT_BEGIN, 79, 625,
	FONT_NEXT, 12, 662,
	FONT_END, 201, 590,
	FONT_BEGIN, 79, 625,
	FONT_NEXT, 201, 590,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 201, 368,
	FONT_END, 201, 328,
	FONT_BEGIN, 94, 599,
	FONT_NEXT, 201, 328,
	FONT_END, 201, 109,
	FONT_BEGIN, 94, 599,
	FONT_NEXT, 201, 109,
	FONT_NEXT, 99, 553,
	FONT_END, 99, 120,
	FONT_BEGIN, 99, 120,
	FONT_NEXT, 201, 109,
	FONT_NEXT, 95, 70,
	FONT_END, 83, 40,
	FONT_BEGIN, 83, 40,
	FONT_NEXT, 201, 109,
	FONT_NEXT, 57, 24,
	FONT_NEXT, 205, 63,
	FONT_END, 12, 0,
	FONT_BEGIN, 57, 24,
	FONT_NEXT, 12, 0,
	FONT_END, 12, 19,
	FONT_BEGIN, 546, 519,
	FONT_NEXT, 521, 519,
	FONT_NEXT, 543, 662,
	FONT_NEXT, 506, 572,
	FONT_END, 481, 604,
	FONT_BEGIN, 543, 662,
	FONT_NEXT, 481, 604,
	FONT_END, 437, 620,
	FONT_BEGIN, 543, 662,
	FONT_NEXT, 437, 620,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 369, 624,
	FONT_END, 233, 624,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 233, 624,
	FONT_END, 207, 618,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 207, 618,
	FONT_END, 202, 607,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 202, 607,
	FONT_END, 201, 590,
	FONT_BEGIN, 479, 463,
	FONT_NEXT, 479, 231,
	FONT_NEXT, 456, 463,
	FONT_NEXT, 456, 231,
	FONT_NEXT, 446, 416,
	FONT_NEXT, 444, 281,
	FONT_NEXT, 428, 387,
	FONT_NEXT, 425, 309,
	FONT_NEXT, 396, 372,
	FONT_NEXT, 393, 322,
	FONT_NEXT, 346, 368,
	FONT_NEXT, 346, 326,
	FONT_NEXT, 201, 368,
	FONT_END, 201, 328,
	FONT_BEGIN, 292, 19,
	FONT_NEXT, 292, 0,
	FONT_NEXT, 247, 23,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 219, 37,
	FONT_END, 205, 63,
	FONT_ADVANCE, 556, 0
    },
    {
	71,
	FONT_BEGIN, 630, 465,
	FONT_NEXT, 607, 465,
	FONT_NEXT, 622, 676,
	FONT_END, 600, 676,
	FONT_BEGIN, 600, 676,
	FONT_NEXT, 607, 465,
	FONT_END, 581, 522,
	FONT_BEGIN, 600, 676,
	FONT_NEXT, 581, 522,
	FONT_NEXT, 591, 659,
	FONT_END, 577, 649,
	FONT_BEGIN, 577, 649,
	FONT_NEXT, 581, 522,
	FONT_END, 539, 577,
	FONT_BEGIN, 577, 649,
	FONT_NEXT, 539, 577,
	FONT_NEXT, 553, 643,
	FONT_END, 525, 648,
	FONT_BEGIN, 525, 648,
	FONT_NEXT, 539, 577,
	FONT_END, 477, 619,
	FONT_BEGIN, 525, 648,
	FONT_NEXT, 477, 619,
	FONT_NEXT, 489, 659,
	FONT_END, 440, 670,
	FONT_BEGIN, 440, 670,
	FONT_NEXT, 477, 619,
	FONT_END, 436, 631,
	FONT_BEGIN, 440, 670,
	FONT_NEXT, 436, 631,
	FONT_NEXT, 374, 676,
	FONT_NEXT, 388, 636,
	FONT_END, 310, 622,
	FONT_BEGIN, 374, 676,
	FONT_NEXT, 310, 622,
	FONT_NEXT, 298, 668,
	FONT_NEXT, 269, 602,
	FONT_NEXT, 231, 647,
	FONT_NEXT, 231, 572,
	FONT_NEXT, 172, 614,
	FONT_NEXT, 197, 531,
	FONT_END, 170, 476,
	FONT_BEGIN, 172, 614,
	FONT_NEXT, 170, 476,
	FONT_NEXT, 123, 571,
	FONT_NEXT, 152, 406,
	FONT_END, 146, 320,
	FONT_BEGIN, 123, 571,
	FONT_NEXT, 146, 320,
	FONT_END, 115, 93,
	FONT_BEGIN, 123, 571,
	FONT_NEXT, 115, 93,
	FONT_NEXT, 84, 520,
	FONT_NEXT, 79, 137,
	FONT_NEXT, 55, 464,
	FONT_NEXT, 53, 189,
	FONT_NEXT, 38, 403,
	FONT_NEXT, 37, 255,
	FONT_END, 32, 341,
	FONT_BEGIN, 454, 336,
	FONT_NEXT, 454, 354,
	FONT_NEXT, 496, 331,
	FONT_END, 523, 320,
	FONT_BEGIN, 523, 320,
	FONT_NEXT, 454, 354,
	FONT_END, 643, 300,
	FONT_BEGIN, 523, 320,
	FONT_NEXT, 643, 300,
	FONT_END, 639, 259,
	FONT_BEGIN, 523, 320,
	FONT_NEXT, 639, 259,
	FONT_NEXT, 537, 295,
	FONT_NEXT, 639, 58,
	FONT_END, 633, 50,
	FONT_BEGIN, 537, 295,
	FONT_NEXT, 633, 50,
	FONT_END, 616, 40,
	FONT_BEGIN, 537, 295,
	FONT_NEXT, 616, 40,
	FONT_NEXT, 542, 247,
	FONT_NEXT, 558, 16,
	FONT_NEXT, 542, 85,
	FONT_END, 530, 60,
	FONT_BEGIN, 530, 60,
	FONT_NEXT, 558, 16,
	FONT_END, 480, -5,
	FONT_BEGIN, 530, 60,
	FONT_NEXT, 480, -5,
	FONT_NEXT, 499, 42,
	FONT_END, 455, 30,
	FONT_BEGIN, 455, 30,
	FONT_NEXT, 480, -5,
	FONT_END, 396, -14,
	FONT_BEGIN, 455, 30,
	FONT_NEXT, 396, -14,
	FONT_NEXT, 405, 26,
	FONT_END, 349, 31,
	FONT_BEGIN, 349, 31,
	FONT_NEXT, 396, -14,
	FONT_END, 320, -9,
	FONT_BEGIN, 349, 31,
	FONT_NEXT, 320, -9,
	FONT_NEXT, 299, 46,
	FONT_NEXT, 245, 10,
	FONT_NEXT, 254, 71,
	FONT_END, 217, 105,
	FONT_BEGIN, 217, 105,
	FONT_NEXT, 245, 10,
	FONT_END, 174, 43,
	FONT_BEGIN, 217, 105,
	FONT_NEXT, 174, 43,
	FONT_NEXT, 187, 147,
	FONT_END, 164, 197,
	FONT_BEGIN, 164, 197,
	FONT_NEXT, 174, 43,
	FONT_END, 115, 93,
	FONT_BEGIN, 164, 197,
	FONT_NEXT, 115, 93,
	FONT_NEXT, 150, 255,
	FONT_END, 146, 320,
	FONT_BEGIN, 709, 354,
	FONT_NEXT, 709, 336,
	FONT_NEXT, 454, 354,
	FONT_NEXT, 679, 332,
	FONT_END, 657, 322,
	FONT_BEGIN, 454, 354,
	FONT_NEXT, 657, 322,
	FONT_END, 643, 300,
	FONT_ADVANCE, 722, 0
    },
    {
	72,
	FONT_BEGIN, 19, 643,
	FONT_NEXT, 19, 662,
	FONT_NEXT, 63, 636,
	FONT_END, 90, 623,
	FONT_BEGIN, 90, 623,
	FONT_NEXT, 19, 662,
	FONT_END, 212, 596,
	FONT_BEGIN, 90, 623,
	FONT_NEXT, 212, 596,
	FONT_END, 209, 553,
	FONT_BEGIN, 90, 623,
	FONT_NEXT, 209, 553,
	FONT_NEXT, 103, 597,
	FONT_NEXT, 209, 359,
	FONT_END, 209, 315,
	FONT_BEGIN, 103, 597,
	FONT_NEXT, 209, 315,
	FONT_END, 209, 109,
	FONT_BEGIN, 103, 597,
	FONT_NEXT, 209, 109,
	FONT_NEXT, 107, 553,
	FONT_END, 107, 120,
	FONT_BEGIN, 107, 120,
	FONT_NEXT, 209, 109,
	FONT_NEXT, 105, 73,
	FONT_END, 94, 42,
	FONT_BEGIN, 94, 42,
	FONT_NEXT, 209, 109,
	FONT_NEXT, 68, 25,
	FONT_NEXT, 211, 67,
	FONT_END, 19, 0,
	FONT_BEGIN, 68, 25,
	FONT_NEXT, 19, 0,
	FONT_END, 19, 19,
	FONT_BEGIN, 297, 662,
	FONT_NEXT, 297, 643,
	FONT_NEXT, 19, 662,
	FONT_NEXT, 251, 636,
	FONT_END, 224, 622,
	FONT_BEGIN, 19, 662,
	FONT_NEXT, 224, 622,
	FONT_END, 212, 596,
	FONT_BEGIN, 424, 643,
	FONT_NEXT, 424, 662,
	FONT_NEXT, 468, 636,
	FONT_END, 495, 623,
	FONT_BEGIN, 495, 623,
	FONT_NEXT, 424, 662,
	FONT_END, 617, 596,
	FONT_BEGIN, 495, 623,
	FONT_NEXT, 617, 596,
	FONT_END, 614, 553,
	FONT_BEGIN, 495, 623,
	FONT_NEXT, 614, 553,
	FONT_NEXT, 508, 597,
	FONT_NEXT, 614, 109,
	FONT_NEXT, 512, 553,
	FONT_NEXT, 512, 120,
	FONT_NEXT, 512, 359,
	FONT_NEXT, 512, 315,
	FONT_NEXT, 209, 359,
	FONT_END, 209, 315,
	FONT_BEGIN, 702, 662,
	FONT_NEXT, 702, 643,
	FONT_NEXT, 424, 662,
	FONT_NEXT, 656, 636,
	FONT_END, 629, 622,
	FONT_BEGIN, 424, 662,
	FONT_NEXT, 629, 622,
	FONT_END, 617, 596,
	FONT_BEGIN, 424, 19,
	FONT_NEXT, 473, 25,
	FONT_NEXT, 424, 0,
	FONT_END, 616, 67,
	FONT_BEGIN, 616, 67,
	FONT_NEXT, 473, 25,
	FONT_NEXT, 614, 109,
	FONT_NEXT, 499, 42,
	FONT_END, 510, 73,
	FONT_BEGIN, 614, 109,
	FONT_NEXT, 510, 73,
	FONT_END, 512, 120,
	FONT_BEGIN, 702, 19,
	FONT_NEXT, 702, 0,
	FONT_NEXT, 655, 25,
	FONT_NEXT, 424, 0,
	FONT_NEXT, 628, 41,
	FONT_END, 616, 67,
	FONT_BEGIN, 297, 19,
	FONT_NEXT, 297, 0,
	FONT_NEXT, 250, 25,
	FONT_NEXT, 19, 0,
	FONT_NEXT, 223, 41,
	FONT_END, 211, 67,
	FONT_ADVANCE, 722, 0
    },
    {
	73,
	FONT_BEGIN, 18, 643,
	FONT_NEXT, 18, 662,
	FONT_NEXT, 68, 637,
	FONT_END, 97, 624,
	FONT_BEGIN, 97, 624,
	FONT_NEXT, 18, 662,
	FONT_END, 222, 600,
	FONT_BEGIN, 97, 624,
	FONT_NEXT, 222, 600,
	FONT_END, 217, 553,
	FONT_BEGIN, 97, 624,
	FONT_NEXT, 217, 553,
	FONT_NEXT, 111, 597,
	FONT_NEXT, 217, 109,
	FONT_NEXT, 115, 553,
	FONT_END, 115, 109,
	FONT_BEGIN, 115, 109,
	FONT_NEXT, 217, 109,
	FONT_NEXT, 111, 65,
	FONT_END, 98, 38,
	FONT_BEGIN, 98, 38,
	FONT_NEXT, 217, 109,
	FONT_END, 221, 62,
	FONT_BEGIN, 98, 38,
	FONT_NEXT, 221, 62,
	FONT_NEXT, 69, 23,
	FONT_NEXT, 18, 0,
	FONT_END, 18, 19,
	FONT_BEGIN, 315, 662,
	FONT_NEXT, 315, 643,
	FONT_NEXT, 18, 662,
	FONT_NEXT, 268, 638,
	FONT_END, 238, 626,
	FONT_BEGIN, 18, 662,
	FONT_NEXT, 238, 626,
	FONT_END, 222, 600,
	FONT_BEGIN, 315, 19,
	FONT_NEXT, 315, 0,
	FONT_NEXT, 268, 22,
	FONT_NEXT, 18, 0,
	FONT_NEXT, 238, 35,
	FONT_END, 221, 62,
	FONT_ADVANCE, 333, 0
    },
    {
	74,
	FONT_BEGIN, 83, 643,
	FONT_NEXT, 83, 662,
	FONT_NEXT, 131, 636,
	FONT_END, 159, 622,
	FONT_BEGIN, 159, 622,
	FONT_NEXT, 83, 662,
	FONT_END, 281, 597,
	FONT_BEGIN, 159, 622,
	FONT_NEXT, 281, 597,
	FONT_END, 278, 553,
	FONT_BEGIN, 159, 622,
	FONT_NEXT, 278, 553,
	FONT_NEXT, 172, 596,
	FONT_NEXT, 278, 183,
	FONT_END, 271, 118,
	FONT_BEGIN, 172, 596,
	FONT_NEXT, 271, 118,
	FONT_END, 255, 70,
	FONT_BEGIN, 172, 596,
	FONT_NEXT, 255, 70,
	FONT_END, 231, 35,
	FONT_BEGIN, 172, 596,
	FONT_NEXT, 231, 35,
	FONT_NEXT, 176, 553,
	FONT_NEXT, 204, 11,
	FONT_NEXT, 176, 90,
	FONT_END, 173, 57,
	FONT_BEGIN, 173, 57,
	FONT_NEXT, 204, 11,
	FONT_END, 147, -11,
	FONT_BEGIN, 173, 57,
	FONT_NEXT, 147, -11,
	FONT_NEXT, 165, 37,
	FONT_END, 153, 27,
	FONT_BEGIN, 153, 27,
	FONT_NEXT, 147, -11,
	FONT_NEXT, 137, 24,
	FONT_NEXT, 124, -14,
	FONT_NEXT, 117, 37,
	FONT_NEXT, 110, -14,
	FONT_NEXT, 107, 66,
	FONT_NEXT, 59, -6,
	FONT_NEXT, 92, 94,
	FONT_END, 77, 104,
	FONT_BEGIN, 77, 104,
	FONT_NEXT, 59, -6,
	FONT_NEXT, 56, 108,
	FONT_NEXT, 32, 11,
	FONT_NEXT, 36, 103,
	FONT_END, 22, 90,
	FONT_BEGIN, 22, 90,
	FONT_NEXT, 32, 11,
	FONT_END, 15, 36,
	FONT_BEGIN, 22, 90,
	FONT_NEXT, 15, 36,
	FONT_END, 10, 59,
	FONT_BEGIN, 370, 662,
	FONT_NEXT, 370, 643,
	FONT_NEXT, 83, 662,
	FONT_NEXT, 322, 637,
	FONT_END, 294, 623,
	FONT_BEGIN, 83, 662,
	FONT_NEXT, 294, 623,
	FONT_END, 281, 597,
	FONT_ADVANCE, 389, 0
    },
    {
	75,
	FONT_BEGIN, 34, 643,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 76, 637,
	FONT_END, 104, 625,
	FONT_BEGIN, 104, 625,
	FONT_NEXT, 34, 662,
	FONT_END, 229, 597,
	FONT_BEGIN, 104, 625,
	FONT_NEXT, 229, 597,
	FONT_END, 226, 553,
	FONT_BEGIN, 104, 625,
	FONT_NEXT, 226, 553,
	FONT_NEXT, 119, 599,
	FONT_NEXT, 226, 348,
	FONT_END, 226, 296,
	FONT_BEGIN, 119, 599,
	FONT_NEXT, 226, 296,
	FONT_END, 226, 109,
	FONT_BEGIN, 119, 599,
	FONT_NEXT, 226, 109,
	FONT_NEXT, 124, 553,
	FONT_END, 124, 120,
	FONT_BEGIN, 124, 120,
	FONT_NEXT, 226, 109,
	FONT_NEXT, 120, 70,
	FONT_END, 108, 40,
	FONT_BEGIN, 108, 40,
	FONT_NEXT, 226, 109,
	FONT_END, 229, 65,
	FONT_BEGIN, 108, 40,
	FONT_NEXT, 229, 65,
	FONT_NEXT, 80, 24,
	FONT_NEXT, 34, 0,
	FONT_END, 34, 19,
	FONT_BEGIN, 318, 662,
	FONT_NEXT, 318, 643,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 270, 637,
	FONT_END, 242, 623,
	FONT_BEGIN, 34, 662,
	FONT_NEXT, 242, 623,
	FONT_END, 229, 597,
	FONT_BEGIN, 413, 643,
	FONT_NEXT, 413, 662,
	FONT_NEXT, 444, 641,
	FONT_END, 465, 636,
	FONT_BEGIN, 465, 636,
	FONT_NEXT, 413, 662,
	FONT_END, 568, 606,
	FONT_BEGIN, 465, 636,
	FONT_NEXT, 568, 606,
	FONT_NEXT, 477, 627,
	FONT_NEXT, 523, 565,
	FONT_NEXT, 481, 612,
	FONT_END, 472, 584,
	FONT_BEGIN, 472, 584,
	FONT_NEXT, 523, 565,
	FONT_END, 333, 377,
	FONT_BEGIN, 472, 584,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 459, 567,
	FONT_END, 438, 543,
	FONT_BEGIN, 438, 543,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 406, 511,
	FONT_END, 361, 470,
	FONT_BEGIN, 361, 470,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 301, 416,
	FONT_NEXT, 252, 317,
	FONT_NEXT, 226, 348,
	FONT_END, 226, 296,
	FONT_BEGIN, 675, 662,
	FONT_NEXT, 675, 643,
	FONT_NEXT, 413, 662,
	FONT_NEXT, 635, 638,
	FONT_END, 603, 628,
	FONT_BEGIN, 413, 662,
	FONT_NEXT, 603, 628,
	FONT_END, 568, 606,
	FONT_BEGIN, 723, 19,
	FONT_NEXT, 723, 0,
	FONT_NEXT, 683, 24,
	FONT_NEXT, 418, 0,
	FONT_NEXT, 647, 45,
	FONT_END, 609, 79,
	FONT_BEGIN, 609, 79,
	FONT_NEXT, 418, 0,
	FONT_END, 472, 24,
	FONT_BEGIN, 609, 79,
	FONT_NEXT, 472, 24,
	FONT_END, 484, 31,
	FONT_BEGIN, 609, 79,
	FONT_NEXT, 484, 31,
	FONT_NEXT, 566, 127,
	FONT_NEXT, 488, 44,
	FONT_END, 483, 58,
	FONT_BEGIN, 566, 127,
	FONT_NEXT, 483, 58,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 472, 78,
	FONT_END, 435, 126,
	FONT_BEGIN, 333, 377,
	FONT_NEXT, 435, 126,
	FONT_END, 392, 175,
	FONT_BEGIN, 333, 377,
	FONT_NEXT, 392, 175,
	FONT_END, 358, 212,
	FONT_BEGIN, 333, 377,
	FONT_NEXT, 358, 212,
	FONT_END, 252, 317,
	FONT_BEGIN, 418, 19,
	FONT_NEXT, 451, 20,
	FONT_NEXT, 418, 0,
	FONT_END, 472, 24,
	FONT_BEGIN, 316, 19,
	FONT_NEXT, 316, 0,
	FONT_NEXT, 269, 24,
	FONT_NEXT, 34, 0,
	FONT_NEXT, 241, 39,
	FONT_END, 229, 65,
	FONT_ADVANCE, 722, 0
    },
    {
	76,
	FONT_BEGIN, 12, 19,
	FONT_NEXT, 52, 23,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 79, 36,
	FONT_NEXT, 201, 80,
	FONT_NEXT, 94, 63,
	FONT_END, 99, 109,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 99, 109,
	FONT_END, 99, 553,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 99, 553,
	FONT_END, 94, 599,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 201, 553,
	FONT_NEXT, 79, 625,
	FONT_NEXT, 205, 599,
	FONT_END, 12, 662,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 79, 625,
	FONT_END, 52, 637,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 52, 637,
	FONT_END, 12, 643,
	FONT_BEGIN, 598, 174,
	FONT_NEXT, 550, 0,
	FONT_NEXT, 573, 174,
	FONT_END, 551, 130,
	FONT_BEGIN, 551, 130,
	FONT_NEXT, 550, 0,
	FONT_NEXT, 527, 97,
	FONT_END, 501, 73,
	FONT_BEGIN, 501, 73,
	FONT_NEXT, 550, 0,
	FONT_NEXT, 472, 57,
	FONT_END, 399, 41,
	FONT_BEGIN, 399, 41,
	FONT_NEXT, 550, 0,
	FONT_END, 12, 0,
	FONT_BEGIN, 399, 41,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 302, 39,
	FONT_END, 251, 39,
	FONT_BEGIN, 251, 39,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 220, 44,
	FONT_END, 205, 56,
	FONT_BEGIN, 205, 56,
	FONT_NEXT, 12, 0,
	FONT_END, 201, 80,
	FONT_BEGIN, 205, 56,
	FONT_END, 201, 80,
	FONT_BEGIN, 294, 662,
	FONT_NEXT, 294, 643,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 250, 638,
	FONT_END, 222, 626,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 222, 626,
	FONT_END, 205, 599,
	FONT_ADVANCE, 611, 0
    },
    {
	77,
	FONT_BEGIN, 14, 643,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 60, 638,
	FONT_END, 89, 625,
	FONT_BEGIN, 89, 625,
	FONT_NEXT, 14, 662,
	FONT_END, 212, 662,
	FONT_BEGIN, 89, 625,
	FONT_NEXT, 212, 662,
	FONT_END, 155, 546,
	FONT_BEGIN, 89, 625,
	FONT_NEXT, 155, 546,
	FONT_END, 153, 546,
	FONT_BEGIN, 89, 625,
	FONT_NEXT, 153, 546,
	FONT_NEXT, 104, 599,
	FONT_END, 109, 553,
	FONT_BEGIN, 109, 553,
	FONT_NEXT, 153, 546,
	FONT_END, 153, 147,
	FONT_BEGIN, 109, 553,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 109, 147,
	FONT_END, 107, 110,
	FONT_BEGIN, 107, 110,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 104, 82,
	FONT_END, 89, 44,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 153, 147,
	FONT_END, 157, 83,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 157, 83,
	FONT_NEXT, 59, 25,
	FONT_NEXT, 172, 45,
	FONT_END, 12, 0,
	FONT_BEGIN, 59, 25,
	FONT_NEXT, 12, 0,
	FONT_END, 12, 19,
	FONT_BEGIN, 863, 662,
	FONT_NEXT, 863, 643,
	FONT_NEXT, 664, 662,
	FONT_NEXT, 822, 637,
	FONT_END, 795, 625,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 795, 625,
	FONT_END, 780, 599,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 780, 599,
	FONT_END, 776, 553,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 776, 553,
	FONT_END, 776, 109,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 776, 109,
	FONT_END, 674, 569,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 674, 569,
	FONT_END, 672, 569,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 672, 569,
	FONT_END, 418, 0,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 418, 0,
	FONT_NEXT, 443, 157,
	FONT_END, 212, 662,
	FONT_BEGIN, 212, 662,
	FONT_NEXT, 418, 0,
	FONT_END, 404, 0,
	FONT_BEGIN, 212, 662,
	FONT_NEXT, 404, 0,
	FONT_END, 155, 546,
	FONT_BEGIN, 583, 19,
	FONT_NEXT, 630, 24,
	FONT_NEXT, 583, 0,
	FONT_END, 780, 63,
	FONT_BEGIN, 780, 63,
	FONT_NEXT, 630, 24,
	FONT_NEXT, 776, 109,
	FONT_NEXT, 657, 40,
	FONT_END, 670, 70,
	FONT_BEGIN, 776, 109,
	FONT_NEXT, 670, 70,
	FONT_END, 674, 120,
	FONT_BEGIN, 776, 109,
	FONT_NEXT, 674, 120,
	FONT_END, 674, 569,
	FONT_BEGIN, 863, 19,
	FONT_NEXT, 863, 0,
	FONT_NEXT, 822, 23,
	FONT_NEXT, 583, 0,
	FONT_NEXT, 795, 36,
	FONT_END, 780, 63,
	FONT_BEGIN, 247, 19,
	FONT_NEXT, 247, 0,
	FONT_NEXT, 201, 25,
	FONT_NEXT, 12, 0,
	FONT_END, 172, 45,
	FONT_ADVANCE, 889, 0
    },
    {
	78,
	FONT_BEGIN, 12, 643,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 60, 634,
	FONT_NEXT, 183, 662,
	FONT_NEXT, 82, 617,
	FONT_END, 109, 588,
	FONT_BEGIN, 109, 588,
	FONT_NEXT, 183, 662,
	FONT_END, 155, 537,
	FONT_BEGIN, 109, 588,
	FONT_NEXT, 155, 537,
	FONT_END, 153, 537,
	FONT_BEGIN, 109, 588,
	FONT_NEXT, 153, 537,
	FONT_END, 153, 147,
	FONT_BEGIN, 109, 588,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 109, 147,
	FONT_END, 107, 110,
	FONT_BEGIN, 107, 110,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 104, 82,
	FONT_END, 89, 44,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 153, 147,
	FONT_END, 157, 83,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 157, 83,
	FONT_NEXT, 59, 25,
	FONT_NEXT, 172, 45,
	FONT_END, 12, 0,
	FONT_BEGIN, 59, 25,
	FONT_NEXT, 12, 0,
	FONT_END, 12, 19,
	FONT_BEGIN, 472, 643,
	FONT_NEXT, 472, 662,
	FONT_NEXT, 515, 637,
	FONT_END, 545, 620,
	FONT_BEGIN, 545, 620,
	FONT_NEXT, 472, 662,
	FONT_END, 617, 583,
	FONT_BEGIN, 545, 620,
	FONT_NEXT, 617, 583,
	FONT_END, 613, 553,
	FONT_BEGIN, 545, 620,
	FONT_NEXT, 613, 553,
	FONT_END, 612, 515,
	FONT_BEGIN, 545, 620,
	FONT_NEXT, 612, 515,
	FONT_NEXT, 562, 582,
	FONT_END, 566, 553,
	FONT_BEGIN, 566, 553,
	FONT_NEXT, 612, 515,
	FONT_END, 612, -11,
	FONT_BEGIN, 566, 553,
	FONT_NEXT, 612, -11,
	FONT_NEXT, 568, 515,
	FONT_NEXT, 595, -11,
	FONT_NEXT, 568, 181,
	FONT_END, 566, 181,
	FONT_BEGIN, 566, 181,
	FONT_NEXT, 595, -11,
	FONT_END, 155, 537,
	FONT_BEGIN, 566, 181,
	FONT_NEXT, 155, 537,
	FONT_END, 183, 662,
	FONT_BEGIN, 707, 662,
	FONT_NEXT, 707, 643,
	FONT_NEXT, 472, 662,
	FONT_NEXT, 665, 636,
	FONT_END, 635, 620,
	FONT_BEGIN, 472, 662,
	FONT_NEXT, 635, 620,
	FONT_END, 617, 583,
	FONT_BEGIN, 247, 19,
	FONT_NEXT, 247, 0,
	FONT_NEXT, 201, 25,
	FONT_NEXT, 12, 0,
	FONT_END, 172, 45,
	FONT_ADVANCE, 722, 0
    },
    {
	79,
	FONT_BEGIN, 148, 331,
	FONT_NEXT, 152, 254,
	FONT_NEXT, 129, 78,
	FONT_NEXT, 165, 189,
	FONT_NEXT, 177, 38,
	FONT_NEXT, 186, 136,
	FONT_END, 212, 94,
	FONT_BEGIN, 177, 38,
	FONT_NEXT, 212, 94,
	FONT_NEXT, 233, 9,
	FONT_NEXT, 244, 61,
	FONT_END, 280, 39,
	FONT_BEGIN, 233, 9,
	FONT_NEXT, 280, 39,
	FONT_NEXT, 294, -8,
	FONT_NEXT, 319, 26,
	FONT_NEXT, 361, -14,
	FONT_NEXT, 361, 22,
	FONT_END, 402, 26,
	FONT_BEGIN, 361, -14,
	FONT_NEXT, 402, 26,
	FONT_NEXT, 427, -8,
	FONT_NEXT, 441, 39,
	FONT_END, 477, 61,
	FONT_BEGIN, 427, -8,
	FONT_NEXT, 477, 61,
	FONT_NEXT, 488, 9,
	FONT_NEXT, 509, 94,
	FONT_END, 535, 136,
	FONT_BEGIN, 488, 9,
	FONT_NEXT, 535, 136,
	FONT_NEXT, 544, 38,
	FONT_NEXT, 556, 189,
	FONT_END, 569, 254,
	FONT_BEGIN, 544, 38,
	FONT_NEXT, 569, 254,
	FONT_NEXT, 592, 78,
	FONT_NEXT, 574, 331,
	FONT_NEXT, 586, 589,
	FONT_NEXT, 569, 409,
	FONT_NEXT, 536, 627,
	FONT_NEXT, 555, 475,
	FONT_END, 533, 528,
	FONT_BEGIN, 536, 627,
	FONT_NEXT, 533, 528,
	FONT_NEXT, 481, 654,
	FONT_NEXT, 505, 571,
	FONT_END, 473, 602,
	FONT_BEGIN, 481, 654,
	FONT_NEXT, 473, 602,
	FONT_NEXT, 422, 670,
	FONT_NEXT, 437, 623,
	FONT_END, 399, 636,
	FONT_BEGIN, 422, 670,
	FONT_NEXT, 399, 636,
	FONT_NEXT, 361, 676,
	FONT_NEXT, 361, 640,
	FONT_NEXT, 299, 670,
	FONT_NEXT, 322, 636,
	FONT_END, 284, 623,
	FONT_BEGIN, 299, 670,
	FONT_NEXT, 284, 623,
	FONT_NEXT, 240, 654,
	FONT_NEXT, 248, 602,
	FONT_END, 216, 571,
	FONT_BEGIN, 240, 654,
	FONT_NEXT, 216, 571,
	FONT_NEXT, 185, 627,
	FONT_NEXT, 188, 528,
	FONT_END, 166, 475,
	FONT_BEGIN, 185, 627,
	FONT_NEXT, 166, 475,
	FONT_NEXT, 136, 589,
	FONT_NEXT, 152, 409,
	FONT_END, 148, 331,
	FONT_BEGIN, 136, 589,
	FONT_NEXT, 148, 331,
	FONT_END, 129, 78,
	FONT_BEGIN, 136, 589,
	FONT_NEXT, 129, 78,
	FONT_NEXT, 94, 540,
	FONT_NEXT, 89, 127,
	FONT_NEXT, 62, 481,
	FONT_NEXT, 59, 186,
	FONT_NEXT, 41, 410,
	FONT_NEXT, 40, 254,
	FONT_END, 34, 330,
	FONT_BEGIN, 688, 330,
	FONT_NEXT, 681, 254,
	FONT_NEXT, 680, 410,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 659, 481,
	FONT_NEXT, 632, 127,
	FONT_NEXT, 627, 540,
	FONT_NEXT, 592, 78,
	FONT_END, 586, 589,
	FONT_ADVANCE, 722, 0
    },
    {
	80,
	FONT_BEGIN, 16, 643,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 59, 635,
	FONT_END, 85, 622,
	FONT_BEGIN, 85, 622,
	FONT_NEXT, 16, 662,
	FONT_END, 202, 591,
	FONT_BEGIN, 85, 622,
	FONT_NEXT, 202, 591,
	FONT_NEXT, 97, 596,
	FONT_NEXT, 202, 331,
	FONT_END, 202, 291,
	FONT_BEGIN, 97, 596,
	FONT_NEXT, 202, 291,
	FONT_END, 202, 109,
	FONT_BEGIN, 97, 596,
	FONT_NEXT, 202, 109,
	FONT_NEXT, 100, 553,
	FONT_END, 100, 120,
	FONT_BEGIN, 100, 120,
	FONT_NEXT, 202, 109,
	FONT_NEXT, 98, 74,
	FONT_END, 89, 44,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 202, 109,
	FONT_NEXT, 64, 27,
	FONT_NEXT, 205, 64,
	FONT_END, 16, 0,
	FONT_BEGIN, 64, 27,
	FONT_NEXT, 16, 0,
	FONT_END, 16, 19,
	FONT_BEGIN, 542, 482,
	FONT_NEXT, 534, 430,
	FONT_NEXT, 536, 526,
	FONT_END, 520, 563,
	FONT_BEGIN, 520, 563,
	FONT_NEXT, 534, 430,
	FONT_END, 517, 391,
	FONT_BEGIN, 520, 563,
	FONT_NEXT, 517, 391,
	FONT_NEXT, 495, 594,
	FONT_NEXT, 497, 363,
	FONT_END, 481, 347,
	FONT_BEGIN, 495, 594,
	FONT_NEXT, 481, 347,
	FONT_NEXT, 462, 619,
	FONT_NEXT, 444, 320,
	FONT_END, 433, 480,
	FONT_BEGIN, 462, 619,
	FONT_NEXT, 433, 480,
	FONT_END, 426, 527,
	FONT_BEGIN, 462, 619,
	FONT_NEXT, 426, 527,
	FONT_NEXT, 379, 651,
	FONT_NEXT, 409, 562,
	FONT_END, 384, 588,
	FONT_BEGIN, 379, 651,
	FONT_NEXT, 384, 588,
	FONT_END, 354, 606,
	FONT_BEGIN, 379, 651,
	FONT_NEXT, 354, 606,
	FONT_NEXT, 280, 662,
	FONT_NEXT, 291, 622,
	FONT_END, 243, 625,
	FONT_BEGIN, 280, 662,
	FONT_NEXT, 243, 625,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 211, 620,
	FONT_END, 204, 610,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 204, 610,
	FONT_END, 202, 591,
	FONT_BEGIN, 202, 331,
	FONT_NEXT, 262, 328,
	FONT_NEXT, 202, 291,
	FONT_END, 269, 288,
	FONT_BEGIN, 269, 288,
	FONT_NEXT, 262, 328,
	FONT_END, 304, 330,
	FONT_BEGIN, 269, 288,
	FONT_NEXT, 304, 330,
	FONT_NEXT, 340, 291,
	FONT_NEXT, 361, 347,
	FONT_END, 388, 365,
	FONT_BEGIN, 340, 291,
	FONT_NEXT, 388, 365,
	FONT_NEXT, 398, 302,
	FONT_NEXT, 411, 392,
	FONT_END, 427, 429,
	FONT_BEGIN, 398, 302,
	FONT_NEXT, 427, 429,
	FONT_NEXT, 444, 320,
	FONT_END, 433, 480,
	FONT_BEGIN, 296, 19,
	FONT_NEXT, 296, 0,
	FONT_NEXT, 248, 23,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 220, 37,
	FONT_END, 205, 64,
	FONT_ADVANCE, 556, 0
    },
    {
	81,
	FONT_BEGIN, 34, 330,
	FONT_NEXT, 41, 410,
	FONT_NEXT, 40, 255,
	FONT_END, 57, 191,
	FONT_BEGIN, 57, 191,
	FONT_NEXT, 41, 410,
	FONT_END, 62, 480,
	FONT_BEGIN, 57, 191,
	FONT_NEXT, 62, 480,
	FONT_NEXT, 82, 138,
	FONT_NEXT, 94, 540,
	FONT_NEXT, 114, 94,
	FONT_NEXT, 136, 588,
	FONT_END, 148, 330,
	FONT_BEGIN, 114, 94,
	FONT_NEXT, 148, 330,
	FONT_NEXT, 151, 58,
	FONT_NEXT, 152, 253,
	FONT_END, 165, 189,
	FONT_BEGIN, 151, 58,
	FONT_NEXT, 165, 189,
	FONT_END, 186, 136,
	FONT_BEGIN, 151, 58,
	FONT_NEXT, 186, 136,
	FONT_NEXT, 189, 31,
	FONT_NEXT, 212, 93,
	FONT_END, 244, 61,
	FONT_BEGIN, 189, 31,
	FONT_NEXT, 244, 61,
	FONT_NEXT, 265, -1,
	FONT_NEXT, 280, 39,
	FONT_NEXT, 312, -56,
	FONT_NEXT, 319, 26,
	FONT_END, 361, 22,
	FONT_BEGIN, 312, -56,
	FONT_NEXT, 361, 22,
	FONT_NEXT, 379, -113,
	FONT_NEXT, 402, 26,
	FONT_NEXT, 426, -7,
	FONT_NEXT, 441, 39,
	FONT_NEXT, 468, 2,
	FONT_NEXT, 477, 61,
	FONT_END, 509, 93,
	FONT_BEGIN, 468, 2,
	FONT_NEXT, 509, 93,
	FONT_NEXT, 512, 20,
	FONT_NEXT, 535, 136,
	FONT_NEXT, 556, 47,
	FONT_NEXT, 556, 189,
	FONT_END, 569, 253,
	FONT_BEGIN, 556, 47,
	FONT_NEXT, 569, 253,
	FONT_END, 574, 330,
	FONT_BEGIN, 556, 47,
	FONT_NEXT, 574, 330,
	FONT_NEXT, 597, 83,
	FONT_NEXT, 586, 589,
	FONT_END, 627, 540,
	FONT_BEGIN, 597, 83,
	FONT_NEXT, 627, 540,
	FONT_NEXT, 633, 130,
	FONT_NEXT, 659, 481,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 680, 410,
	FONT_NEXT, 681, 252,
	FONT_END, 688, 330,
	FONT_BEGIN, 574, 330,
	FONT_NEXT, 569, 409,
	FONT_NEXT, 586, 589,
	FONT_END, 536, 627,
	FONT_BEGIN, 536, 627,
	FONT_NEXT, 569, 409,
	FONT_END, 555, 475,
	FONT_BEGIN, 536, 627,
	FONT_NEXT, 555, 475,
	FONT_END, 533, 528,
	FONT_BEGIN, 536, 627,
	FONT_NEXT, 533, 528,
	FONT_NEXT, 481, 654,
	FONT_NEXT, 505, 570,
	FONT_END, 473, 602,
	FONT_BEGIN, 481, 654,
	FONT_NEXT, 473, 602,
	FONT_NEXT, 422, 670,
	FONT_NEXT, 437, 623,
	FONT_END, 399, 636,
	FONT_BEGIN, 422, 670,
	FONT_NEXT, 399, 636,
	FONT_NEXT, 361, 676,
	FONT_NEXT, 361, 640,
	FONT_NEXT, 299, 670,
	FONT_NEXT, 322, 636,
	FONT_END, 284, 623,
	FONT_BEGIN, 299, 670,
	FONT_NEXT, 284, 623,
	FONT_NEXT, 240, 654,
	FONT_NEXT, 248, 602,
	FONT_END, 216, 570,
	FONT_BEGIN, 240, 654,
	FONT_NEXT, 216, 570,
	FONT_NEXT, 185, 626,
	FONT_NEXT, 188, 528,
	FONT_END, 166, 475,
	FONT_BEGIN, 185, 626,
	FONT_NEXT, 166, 475,
	FONT_NEXT, 136, 588,
	FONT_NEXT, 152, 409,
	FONT_END, 148, 330,
	FONT_BEGIN, 701, -159,
	FONT_NEXT, 701, -177,
	FONT_NEXT, 638, -153,
	FONT_NEXT, 654, -178,
	FONT_END, 555, -172,
	FONT_BEGIN, 638, -153,
	FONT_NEXT, 555, -172,
	FONT_NEXT, 586, -138,
	FONT_END, 505, -90,
	FONT_BEGIN, 505, -90,
	FONT_NEXT, 555, -172,
	FONT_END, 462, -151,
	FONT_BEGIN, 505, -90,
	FONT_NEXT, 462, -151,
	FONT_NEXT, 426, -7,
	FONT_END, 379, -113,
	FONT_ADVANCE, 722, 0
    },
    {
	82,
	FONT_BEGIN, 17, 643,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 59, 636,
	FONT_END, 85, 623,
	FONT_BEGIN, 85, 623,
	FONT_NEXT, 17, 662,
	FONT_END, 204, 589,
	FONT_BEGIN, 85, 623,
	FONT_NEXT, 204, 589,
	FONT_NEXT, 98, 597,
	FONT_NEXT, 204, 343,
	FONT_END, 204, 306,
	FONT_BEGIN, 98, 597,
	FONT_NEXT, 204, 306,
	FONT_END, 204, 109,
	FONT_BEGIN, 98, 597,
	FONT_NEXT, 204, 109,
	FONT_NEXT, 102, 553,
	FONT_END, 102, 120,
	FONT_BEGIN, 102, 120,
	FONT_NEXT, 204, 109,
	FONT_NEXT, 100, 73,
	FONT_END, 89, 43,
	FONT_BEGIN, 89, 43,
	FONT_NEXT, 204, 109,
	FONT_NEXT, 64, 26,
	FONT_NEXT, 206, 67,
	FONT_END, 17, 0,
	FONT_BEGIN, 64, 26,
	FONT_NEXT, 17, 0,
	FONT_END, 17, 19,
	FONT_BEGIN, 204, 306,
	FONT_NEXT, 204, 343,
	FONT_NEXT, 260, 308,
	FONT_NEXT, 276, 346,
	FONT_END, 352, 362,
	FONT_BEGIN, 260, 308,
	FONT_NEXT, 352, 362,
	FONT_NEXT, 366, 319,
	FONT_NEXT, 386, 380,
	FONT_END, 413, 406,
	FONT_BEGIN, 366, 319,
	FONT_NEXT, 413, 406,
	FONT_NEXT, 415, 330,
	FONT_NEXT, 431, 441,
	FONT_END, 438, 489,
	FONT_BEGIN, 415, 330,
	FONT_NEXT, 438, 489,
	FONT_NEXT, 475, 356,
	FONT_END, 453, 632,
	FONT_BEGIN, 453, 632,
	FONT_NEXT, 438, 489,
	FONT_END, 432, 533,
	FONT_BEGIN, 453, 632,
	FONT_NEXT, 432, 533,
	FONT_END, 416, 566,
	FONT_BEGIN, 453, 632,
	FONT_NEXT, 416, 566,
	FONT_NEXT, 370, 656,
	FONT_NEXT, 394, 590,
	FONT_END, 367, 606,
	FONT_BEGIN, 370, 656,
	FONT_NEXT, 367, 606,
	FONT_NEXT, 293, 662,
	FONT_NEXT, 310, 622,
	FONT_END, 266, 625,
	FONT_BEGIN, 293, 662,
	FONT_NEXT, 266, 625,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 233, 623,
	FONT_END, 215, 617,
	FONT_BEGIN, 17, 662,
	FONT_NEXT, 215, 617,
	FONT_END, 206, 606,
	FONT_BEGIN, 17, 662,
	FONT_NEXT, 206, 606,
	FONT_END, 204, 589,
	FONT_BEGIN, 659, 19,
	FONT_NEXT, 659, 0,
	FONT_NEXT, 608, 33,
	FONT_NEXT, 498, 0,
	FONT_NEXT, 572, 66,
	FONT_END, 366, 319,
	FONT_BEGIN, 366, 319,
	FONT_NEXT, 498, 0,
	FONT_END, 260, 308,
	FONT_BEGIN, 366, 319,
	FONT_END, 260, 308,
	FONT_BEGIN, 547, 487,
	FONT_NEXT, 541, 441,
	FONT_NEXT, 539, 538,
	FONT_NEXT, 525, 405,
	FONT_NEXT, 519, 579,
	FONT_NEXT, 503, 377,
	FONT_NEXT, 490, 610,
	FONT_NEXT, 475, 356,
	FONT_END, 453, 632,
	FONT_BEGIN, 294, 19,
	FONT_NEXT, 294, 0,
	FONT_NEXT, 246, 25,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 219, 40,
	FONT_END, 206, 67,
	FONT_ADVANCE, 667, 0
    },
    {
	83,
	FONT_BEGIN, 71, 506,
	FONT_NEXT, 75, 546,
	FONT_NEXT, 82, 441,
	FONT_NEXT, 86, 580,
	FONT_NEXT, 114, 390,
	FONT_NEXT, 127, 633,
	FONT_END, 157, 542,
	FONT_BEGIN, 114, 390,
	FONT_NEXT, 157, 542,
	FONT_NEXT, 163, 349,
	FONT_NEXT, 171, 491,
	FONT_END, 209, 448,
	FONT_BEGIN, 163, 349,
	FONT_NEXT, 209, 448,
	FONT_NEXT, 227, 310,
	FONT_END, 276, 280,
	FONT_BEGIN, 276, 280,
	FONT_NEXT, 209, 448,
	FONT_NEXT, 314, 254,
	FONT_NEXT, 324, 375,
	FONT_NEXT, 343, 231,
	FONT_END, 363, 210,
	FONT_BEGIN, 363, 210,
	FONT_NEXT, 324, 375,
	FONT_NEXT, 385, 172,
	FONT_NEXT, 385, 336,
	FONT_NEXT, 390, 133,
	FONT_NEXT, 409, 20,
	FONT_END, 373, 2,
	FONT_BEGIN, 390, 133,
	FONT_NEXT, 373, 2,
	FONT_NEXT, 382, 92,
	FONT_END, 360, 57,
	FONT_BEGIN, 360, 57,
	FONT_NEXT, 373, 2,
	FONT_END, 330, -10,
	FONT_BEGIN, 360, 57,
	FONT_NEXT, 330, -10,
	FONT_NEXT, 322, 31,
	FONT_NEXT, 280, -14,
	FONT_NEXT, 270, 22,
	FONT_NEXT, 227, -9,
	FONT_NEXT, 223, 27,
	FONT_NEXT, 185, 3,
	FONT_NEXT, 183, 43,
	FONT_NEXT, 151, 14,
	FONT_NEXT, 124, 92,
	FONT_NEXT, 125, 20,
	FONT_END, 101, 9,
	FONT_BEGIN, 124, 92,
	FONT_NEXT, 101, 9,
	FONT_NEXT, 86, 151,
	FONT_NEXT, 94, -13,
	FONT_END, 72, -13,
	FONT_BEGIN, 86, 151,
	FONT_NEXT, 72, -13,
	FONT_NEXT, 65, 199,
	FONT_END, 42, 199,
	FONT_BEGIN, 469, 463,
	FONT_NEXT, 444, 463,
	FONT_NEXT, 447, 676,
	FONT_END, 426, 676,
	FONT_BEGIN, 426, 676,
	FONT_NEXT, 444, 463,
	FONT_END, 422, 524,
	FONT_BEGIN, 426, 676,
	FONT_NEXT, 422, 524,
	FONT_NEXT, 418, 654,
	FONT_NEXT, 384, 579,
	FONT_NEXT, 408, 645,
	FONT_END, 391, 642,
	FONT_BEGIN, 391, 642,
	FONT_NEXT, 384, 579,
	FONT_NEXT, 367, 647,
	FONT_NEXT, 328, 619,
	FONT_NEXT, 334, 659,
	FONT_END, 252, 676,
	FONT_BEGIN, 252, 676,
	FONT_NEXT, 328, 619,
	FONT_END, 295, 630,
	FONT_BEGIN, 252, 676,
	FONT_NEXT, 295, 630,
	FONT_END, 258, 635,
	FONT_BEGIN, 252, 676,
	FONT_NEXT, 258, 635,
	FONT_END, 221, 629,
	FONT_BEGIN, 252, 676,
	FONT_NEXT, 221, 629,
	FONT_NEXT, 185, 665,
	FONT_NEXT, 188, 611,
	FONT_END, 165, 582,
	FONT_BEGIN, 185, 665,
	FONT_NEXT, 165, 582,
	FONT_NEXT, 127, 633,
	FONT_END, 157, 542,
	FONT_BEGIN, 491, 167,
	FONT_NEXT, 478, 102,
	FONT_NEXT, 476, 235,
	FONT_NEXT, 439, 44,
	FONT_NEXT, 438, 290,
	FONT_NEXT, 409, 20,
	FONT_END, 385, 336,
	FONT_ADVANCE, 556, 0
    },
    {
	84,
	FONT_BEGIN, 17, 492,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 41, 492,
	FONT_END, 59, 557,
	FONT_BEGIN, 59, 557,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 87, 596,
	FONT_END, 131, 615,
	FONT_BEGIN, 131, 615,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 200, 620,
	FONT_END, 254, 620,
	FONT_BEGIN, 254, 620,
	FONT_NEXT, 23, 662,
	FONT_END, 356, 620,
	FONT_BEGIN, 254, 620,
	FONT_NEXT, 356, 620,
	FONT_END, 356, 109,
	FONT_BEGIN, 254, 620,
	FONT_NEXT, 356, 109,
	FONT_NEXT, 254, 120,
	FONT_END, 252, 73,
	FONT_BEGIN, 252, 73,
	FONT_NEXT, 356, 109,
	FONT_NEXT, 241, 43,
	FONT_END, 213, 26,
	FONT_BEGIN, 213, 26,
	FONT_NEXT, 356, 109,
	FONT_END, 359, 66,
	FONT_BEGIN, 213, 26,
	FONT_NEXT, 359, 66,
	FONT_END, 160, 0,
	FONT_BEGIN, 213, 26,
	FONT_NEXT, 160, 0,
	FONT_END, 160, 19,
	FONT_BEGIN, 593, 492,
	FONT_NEXT, 569, 492,
	FONT_NEXT, 587, 662,
	FONT_NEXT, 550, 558,
	FONT_END, 522, 597,
	FONT_BEGIN, 587, 662,
	FONT_NEXT, 522, 597,
	FONT_END, 478, 615,
	FONT_BEGIN, 587, 662,
	FONT_NEXT, 478, 615,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 410, 620,
	FONT_END, 356, 620,
	FONT_BEGIN, 452, 19,
	FONT_NEXT, 452, 0,
	FONT_NEXT, 401, 24,
	FONT_NEXT, 160, 0,
	FONT_NEXT, 372, 39,
	FONT_END, 359, 66,
	FONT_ADVANCE, 611, 0
    },
    {
	85,
	FONT_BEGIN, 14, 643,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 60, 637,
	FONT_END, 87, 623,
	FONT_BEGIN, 87, 623,
	FONT_NEXT, 14, 662,
	FONT_END, 209, 596,
	FONT_BEGIN, 87, 623,
	FONT_NEXT, 209, 596,
	FONT_END, 206, 553,
	FONT_BEGIN, 87, 623,
	FONT_NEXT, 206, 553,
	FONT_NEXT, 100, 597,
	FONT_NEXT, 206, 233,
	FONT_END, 164, 50,
	FONT_BEGIN, 100, 597,
	FONT_NEXT, 164, 50,
	FONT_NEXT, 104, 553,
	FONT_NEXT, 135, 91,
	FONT_END, 117, 133,
	FONT_BEGIN, 104, 553,
	FONT_NEXT, 117, 133,
	FONT_END, 107, 175,
	FONT_BEGIN, 104, 553,
	FONT_NEXT, 107, 175,
	FONT_END, 104, 212,
	FONT_BEGIN, 104, 553,
	FONT_NEXT, 104, 212,
	FONT_END, 104, 241,
	FONT_BEGIN, 297, 662,
	FONT_NEXT, 297, 643,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 249, 636,
	FONT_END, 221, 622,
	FONT_BEGIN, 14, 662,
	FONT_NEXT, 221, 622,
	FONT_END, 209, 596,
	FONT_BEGIN, 473, 643,
	FONT_NEXT, 473, 662,
	FONT_NEXT, 517, 636,
	FONT_NEXT, 629, 615,
	FONT_END, 614, 578,
	FONT_BEGIN, 517, 636,
	FONT_NEXT, 614, 578,
	FONT_NEXT, 546, 617,
	FONT_NEXT, 611, 515,
	FONT_NEXT, 562, 579,
	FONT_NEXT, 611, 254,
	FONT_END, 606, 178,
	FONT_BEGIN, 562, 579,
	FONT_NEXT, 606, 178,
	FONT_END, 597, 134,
	FONT_BEGIN, 562, 579,
	FONT_NEXT, 597, 134,
	FONT_NEXT, 567, 515,
	FONT_NEXT, 578, 90,
	FONT_NEXT, 567, 245,
	FONT_END, 565, 192,
	FONT_BEGIN, 565, 192,
	FONT_NEXT, 578, 90,
	FONT_END, 547, 49,
	FONT_BEGIN, 565, 192,
	FONT_NEXT, 547, 49,
	FONT_NEXT, 560, 154,
	FONT_END, 544, 109,
	FONT_BEGIN, 544, 109,
	FONT_NEXT, 547, 49,
	FONT_END, 501, 16,
	FONT_BEGIN, 544, 109,
	FONT_NEXT, 501, 16,
	FONT_NEXT, 517, 76,
	FONT_END, 480, 51,
	FONT_BEGIN, 480, 51,
	FONT_NEXT, 501, 16,
	FONT_END, 437, -6,
	FONT_BEGIN, 480, 51,
	FONT_NEXT, 437, -6,
	FONT_NEXT, 434, 35,
	FONT_NEXT, 352, -14,
	FONT_NEXT, 380, 30,
	FONT_END, 322, 36,
	FONT_BEGIN, 322, 36,
	FONT_NEXT, 352, -14,
	FONT_END, 270, -6,
	FONT_BEGIN, 322, 36,
	FONT_NEXT, 270, -6,
	FONT_NEXT, 279, 52,
	FONT_END, 248, 77,
	FONT_BEGIN, 248, 77,
	FONT_NEXT, 270, -6,
	FONT_END, 208, 17,
	FONT_BEGIN, 248, 77,
	FONT_NEXT, 208, 17,
	FONT_NEXT, 227, 107,
	FONT_END, 208, 174,
	FONT_BEGIN, 208, 174,
	FONT_NEXT, 208, 17,
	FONT_NEXT, 206, 233,
	FONT_END, 164, 50,
	FONT_BEGIN, 705, 662,
	FONT_NEXT, 705, 643,
	FONT_NEXT, 473, 662,
	FONT_NEXT, 657, 634,
	FONT_END, 629, 615,
	FONT_ADVANCE, 722, 0
    },
    {
	86,
	FONT_BEGIN, 282, 662,
	FONT_NEXT, 282, 643,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 246, 640,
	FONT_END, 223, 635,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 223, 635,
	FONT_END, 210, 624,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 210, 624,
	FONT_END, 207, 606,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 207, 606,
	FONT_END, 71, 623,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 71, 623,
	FONT_END, 46, 638,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 46, 638,
	FONT_END, 16, 643,
	FONT_BEGIN, 549, 538,
	FONT_NEXT, 556, 556,
	FONT_NEXT, 546, 528,
	FONT_NEXT, 383, -11,
	FONT_NEXT, 399, 161,
	FONT_END, 248, 499,
	FONT_BEGIN, 248, 499,
	FONT_NEXT, 383, -11,
	FONT_END, 368, -11,
	FONT_BEGIN, 248, 499,
	FONT_NEXT, 368, -11,
	FONT_END, 122, 538,
	FONT_BEGIN, 248, 499,
	FONT_NEXT, 122, 538,
	FONT_NEXT, 218, 566,
	FONT_END, 210, 590,
	FONT_BEGIN, 210, 590,
	FONT_NEXT, 122, 538,
	FONT_NEXT, 207, 606,
	FONT_NEXT, 94, 592,
	FONT_END, 71, 623,
	FONT_BEGIN, 492, 643,
	FONT_NEXT, 492, 662,
	FONT_NEXT, 542, 634,
	FONT_NEXT, 625, 596,
	FONT_NEXT, 558, 621,
	FONT_NEXT, 605, 550,
	FONT_NEXT, 565, 597,
	FONT_END, 556, 556,
	FONT_BEGIN, 556, 556,
	FONT_NEXT, 605, 550,
	FONT_END, 383, -11,
	FONT_BEGIN, 556, 556,
	FONT_END, 383, -11,
	FONT_BEGIN, 697, 662,
	FONT_NEXT, 697, 643,
	FONT_NEXT, 492, 662,
	FONT_NEXT, 666, 637,
	FONT_END, 644, 623,
	FONT_BEGIN, 492, 662,
	FONT_NEXT, 644, 623,
	FONT_END, 625, 596,
	FONT_ADVANCE, 722, 0
    },
    {
	87,
	FONT_BEGIN, 125, 480,
	FONT_NEXT, 108, 526,
	FONT_NEXT, 147, 421,
	FONT_END, 185, 609,
	FONT_BEGIN, 185, 609,
	FONT_NEXT, 108, 526,
	FONT_END, 86, 578,
	FONT_BEGIN, 185, 609,
	FONT_NEXT, 86, 578,
	FONT_END, 65, 613,
	FONT_BEGIN, 185, 609,
	FONT_NEXT, 65, 613,
	FONT_END, 40, 634,
	FONT_BEGIN, 185, 609,
	FONT_NEXT, 40, 634,
	FONT_NEXT, 5, 662,
	FONT_END, 5, 643,
	FONT_BEGIN, 313, 643,
	FONT_NEXT, 313, 662,
	FONT_NEXT, 346, 640,
	FONT_END, 371, 628,
	FONT_BEGIN, 371, 628,
	FONT_NEXT, 313, 662,
	FONT_END, 503, 605,
	FONT_BEGIN, 371, 628,
	FONT_NEXT, 503, 605,
	FONT_NEXT, 391, 601,
	FONT_END, 414, 553,
	FONT_BEGIN, 414, 553,
	FONT_NEXT, 503, 605,
	FONT_NEXT, 447, 471,
	FONT_NEXT, 470, 412,
	FONT_END, 316, -11,
	FONT_BEGIN, 447, 471,
	FONT_NEXT, 316, -11,
	FONT_NEXT, 340, 189,
	FONT_END, 196, 565,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 316, -11,
	FONT_END, 301, -11,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 301, -11,
	FONT_END, 279, 51,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 279, 51,
	FONT_END, 254, 123,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 254, 123,
	FONT_END, 199, 277,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 199, 277,
	FONT_END, 147, 421,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 147, 421,
	FONT_END, 185, 609,
	FONT_BEGIN, 580, 662,
	FONT_NEXT, 580, 643,
	FONT_NEXT, 313, 662,
	FONT_NEXT, 529, 637,
	FONT_END, 510, 626,
	FONT_BEGIN, 313, 662,
	FONT_NEXT, 510, 626,
	FONT_END, 503, 605,
	FONT_BEGIN, 734, 643,
	FONT_NEXT, 734, 662,
	FONT_NEXT, 781, 633,
	FONT_NEXT, 864, 606,
	FONT_END, 853, 582,
	FONT_BEGIN, 781, 633,
	FONT_NEXT, 853, 582,
	FONT_NEXT, 797, 620,
	FONT_END, 803, 597,
	FONT_BEGIN, 803, 597,
	FONT_NEXT, 853, 582,
	FONT_END, 745, 288,
	FONT_BEGIN, 803, 597,
	FONT_NEXT, 745, 288,
	FONT_NEXT, 787, 525,
	FONT_END, 662, 186,
	FONT_BEGIN, 662, 186,
	FONT_NEXT, 745, 288,
	FONT_END, 645, -11,
	FONT_BEGIN, 662, 186,
	FONT_NEXT, 645, -11,
	FONT_NEXT, 530, 527,
	FONT_NEXT, 630, -11,
	FONT_END, 470, 412,
	FONT_BEGIN, 530, 527,
	FONT_NEXT, 470, 412,
	FONT_NEXT, 510, 574,
	FONT_END, 503, 605,
	FONT_BEGIN, 932, 662,
	FONT_NEXT, 932, 643,
	FONT_NEXT, 734, 662,
	FONT_NEXT, 900, 635,
	FONT_END, 879, 624,
	FONT_BEGIN, 734, 662,
	FONT_NEXT, 879, 624,
	FONT_END, 864, 606,
	FONT_BEGIN, 250, 662,
	FONT_NEXT, 250, 643,
	FONT_NEXT, 5, 662,
	FONT_NEXT, 220, 640,
	FONT_END, 200, 635,
	FONT_BEGIN, 5, 662,
	FONT_NEXT, 200, 635,
	FONT_END, 188, 625,
	FONT_BEGIN, 5, 662,
	FONT_NEXT, 188, 625,
	FONT_END, 185, 609,
	FONT_ADVANCE, 944, 0
    },
    {
	88,
	FONT_BEGIN, 22, 643,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 60, 637,
	FONT_END, 96, 618,
	FONT_BEGIN, 96, 618,
	FONT_NEXT, 22, 662,
	FONT_END, 248, 611,
	FONT_BEGIN, 96, 618,
	FONT_NEXT, 248, 611,
	FONT_NEXT, 116, 600,
	FONT_END, 139, 573,
	FONT_BEGIN, 139, 573,
	FONT_NEXT, 248, 611,
	FONT_NEXT, 168, 535,
	FONT_END, 203, 486,
	FONT_BEGIN, 203, 486,
	FONT_NEXT, 248, 611,
	FONT_END, 251, 592,
	FONT_BEGIN, 203, 486,
	FONT_NEXT, 251, 592,
	FONT_END, 265, 565,
	FONT_BEGIN, 203, 486,
	FONT_NEXT, 265, 565,
	FONT_END, 291, 523,
	FONT_BEGIN, 203, 486,
	FONT_NEXT, 291, 523,
	FONT_NEXT, 312, 326,
	FONT_NEXT, 333, 463,
	FONT_END, 338, 288,
	FONT_BEGIN, 312, 326,
	FONT_NEXT, 338, 288,
	FONT_END, 219, 140,
	FONT_BEGIN, 312, 326,
	FONT_NEXT, 219, 140,
	FONT_NEXT, 155, 133,
	FONT_NEXT, 185, 95,
	FONT_END, 172, 73,
	FONT_BEGIN, 155, 133,
	FONT_NEXT, 172, 73,
	FONT_END, 167, 56,
	FONT_BEGIN, 155, 133,
	FONT_NEXT, 167, 56,
	FONT_NEXT, 128, 100,
	FONT_END, 106, 74,
	FONT_BEGIN, 106, 74,
	FONT_NEXT, 167, 56,
	FONT_NEXT, 73, 41,
	FONT_NEXT, 10, 0,
	FONT_NEXT, 44, 24,
	FONT_END, 10, 19,
	FONT_BEGIN, 324, 662,
	FONT_NEXT, 324, 643,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 290, 641,
	FONT_END, 266, 637,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 266, 637,
	FONT_END, 252, 628,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 252, 628,
	FONT_END, 248, 611,
	FONT_BEGIN, 458, 643,
	FONT_NEXT, 458, 662,
	FONT_NEXT, 505, 637,
	FONT_NEXT, 592, 599,
	FONT_NEXT, 521, 628,
	FONT_END, 528, 610,
	FONT_BEGIN, 528, 610,
	FONT_NEXT, 592, 599,
	FONT_END, 547, 549,
	FONT_BEGIN, 528, 610,
	FONT_NEXT, 547, 549,
	FONT_NEXT, 516, 579,
	FONT_NEXT, 401, 367,
	FONT_NEXT, 488, 542,
	FONT_END, 375, 404,
	FONT_BEGIN, 375, 404,
	FONT_NEXT, 401, 367,
	FONT_END, 338, 288,
	FONT_BEGIN, 375, 404,
	FONT_NEXT, 338, 288,
	FONT_END, 333, 463,
	FONT_BEGIN, 696, 662,
	FONT_NEXT, 696, 643,
	FONT_NEXT, 458, 662,
	FONT_NEXT, 660, 638,
	FONT_END, 627, 627,
	FONT_BEGIN, 458, 662,
	FONT_NEXT, 627, 627,
	FONT_END, 592, 599,
	FONT_BEGIN, 704, 19,
	FONT_NEXT, 704, 0,
	FONT_NEXT, 670, 24,
	FONT_NEXT, 407, 0,
	FONT_NEXT, 643, 37,
	FONT_END, 619, 58,
	FONT_BEGIN, 619, 58,
	FONT_NEXT, 407, 0,
	FONT_END, 464, 25,
	FONT_BEGIN, 619, 58,
	FONT_NEXT, 464, 25,
	FONT_NEXT, 593, 93,
	FONT_NEXT, 479, 35,
	FONT_END, 484, 53,
	FONT_BEGIN, 593, 93,
	FONT_NEXT, 484, 53,
	FONT_NEXT, 401, 367,
	FONT_NEXT, 478, 72,
	FONT_END, 464, 98,
	FONT_BEGIN, 401, 367,
	FONT_NEXT, 464, 98,
	FONT_END, 433, 148,
	FONT_BEGIN, 401, 367,
	FONT_NEXT, 433, 148,
	FONT_END, 338, 288,
	FONT_BEGIN, 407, 19,
	FONT_NEXT, 440, 21,
	FONT_NEXT, 407, 0,
	FONT_END, 464, 25,
	FONT_BEGIN, 243, 19,
	FONT_NEXT, 243, 0,
	FONT_NEXT, 190, 26,
	FONT_NEXT, 10, 0,
	FONT_NEXT, 173, 37,
	FONT_END, 167, 56,
	FONT_ADVANCE, 722, 0
    },
    {
	89,
	FONT_BEGIN, 302, 662,
	FONT_NEXT, 302, 643,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 271, 641,
	FONT_END, 249, 637,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 249, 637,
	FONT_END, 235, 628,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 235, 628,
	FONT_END, 231, 612,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 231, 612,
	FONT_END, 81, 619,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 81, 619,
	FONT_END, 51, 637,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 51, 637,
	FONT_END, 22, 643,
	FONT_BEGIN, 484, 643,
	FONT_NEXT, 484, 662,
	FONT_NEXT, 530, 638,
	FONT_NEXT, 646, 624,
	FONT_END, 610, 590,
	FONT_BEGIN, 530, 638,
	FONT_NEXT, 610, 590,
	FONT_NEXT, 546, 628,
	FONT_NEXT, 589, 564,
	FONT_NEXT, 553, 610,
	FONT_NEXT, 565, 529,
	FONT_NEXT, 539, 573,
	FONT_NEXT, 417, 303,
	FONT_NEXT, 396, 347,
	FONT_NEXT, 417, 109,
	FONT_END, 313, 72,
	FONT_BEGIN, 396, 347,
	FONT_NEXT, 313, 72,
	FONT_END, 315, 120,
	FONT_BEGIN, 396, 347,
	FONT_NEXT, 315, 120,
	FONT_END, 315, 294,
	FONT_BEGIN, 396, 347,
	FONT_NEXT, 315, 294,
	FONT_NEXT, 248, 569,
	FONT_NEXT, 184, 486,
	FONT_NEXT, 231, 612,
	FONT_NEXT, 149, 535,
	FONT_END, 121, 573,
	FONT_BEGIN, 231, 612,
	FONT_NEXT, 121, 573,
	FONT_END, 99, 600,
	FONT_BEGIN, 231, 612,
	FONT_NEXT, 99, 600,
	FONT_END, 81, 619,
	FONT_BEGIN, 703, 662,
	FONT_NEXT, 703, 643,
	FONT_NEXT, 484, 662,
	FONT_NEXT, 675, 638,
	FONT_END, 646, 624,
	FONT_BEGIN, 520, 19,
	FONT_NEXT, 520, 0,
	FONT_NEXT, 465, 23,
	FONT_NEXT, 214, 0,
	FONT_NEXT, 434, 37,
	FONT_END, 420, 64,
	FONT_BEGIN, 420, 64,
	FONT_NEXT, 214, 0,
	FONT_END, 271, 24,
	FONT_BEGIN, 420, 64,
	FONT_NEXT, 271, 24,
	FONT_END, 301, 41,
	FONT_BEGIN, 420, 64,
	FONT_NEXT, 301, 41,
	FONT_NEXT, 417, 109,
	FONT_END, 313, 72,
	FONT_BEGIN, 214, 19,
	FONT_NEXT, 246, 20,
	FONT_NEXT, 214, 0,
	FONT_END, 271, 24,
	FONT_ADVANCE, 722, 0
    },
    {
	90,
	FONT_BEGIN, 577, 662,
	FONT_NEXT, 577, 647,
	FONT_NEXT, 51, 662,
	FONT_NEXT, 446, 624,
	FONT_END, 225, 624,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 225, 624,
	FONT_END, 177, 621,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 177, 621,
	FONT_END, 140, 612,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 140, 612,
	FONT_END, 112, 599,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 112, 599,
	FONT_END, 92, 582,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 92, 582,
	FONT_END, 68, 540,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 68, 540,
	FONT_END, 57, 491,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 57, 491,
	FONT_END, 31, 491,
	FONT_BEGIN, 597, 176,
	FONT_NEXT, 573, 0,
	FONT_NEXT, 574, 176,
	FONT_END, 556, 123,
	FONT_BEGIN, 556, 123,
	FONT_NEXT, 573, 0,
	FONT_NEXT, 528, 79,
	FONT_END, 481, 49,
	FONT_BEGIN, 481, 49,
	FONT_NEXT, 573, 0,
	FONT_NEXT, 446, 40,
	FONT_NEXT, 9, 0,
	FONT_NEXT, 402, 38,
	FONT_END, 145, 38,
	FONT_BEGIN, 145, 38,
	FONT_NEXT, 9, 0,
	FONT_END, 9, 15,
	FONT_BEGIN, 145, 38,
	FONT_NEXT, 9, 15,
	FONT_END, 446, 624,
	FONT_BEGIN, 145, 38,
	FONT_NEXT, 446, 624,
	FONT_END, 577, 647,
	FONT_ADVANCE, 611, 0
    },
    {
	91,
	FONT_BEGIN, 299, 662,
	FONT_NEXT, 299, 637,
	FONT_NEXT, 88, 662,
	FONT_NEXT, 209, 637,
	FONT_END, 182, 632,
	FONT_BEGIN, 88, 662,
	FONT_NEXT, 182, 632,
	FONT_END, 169, 620,
	FONT_BEGIN, 88, 662,
	FONT_NEXT, 169, 620,
	FONT_END, 164, 593,
	FONT_BEGIN, 88, 662,
	FONT_NEXT, 164, 593,
	FONT_END, 164, -79,
	FONT_BEGIN, 88, 662,
	FONT_NEXT, 164, -79,
	FONT_NEXT, 88, -156,
	FONT_NEXT, 170, -110,
	FONT_END, 184, -125,
	FONT_BEGIN, 88, -156,
	FONT_NEXT, 184, -125,
	FONT_END, 213, -131,
	FONT_BEGIN, 88, -156,
	FONT_NEXT, 213, -131,
	FONT_NEXT, 299, -156,
	FONT_END, 299, -131,
	FONT_ADVANCE, 333, 0
    },
    {
	92,
	FONT_BEGIN, 287, -14,
	FONT_NEXT, 219, -14,
	FONT_NEXT, 58, 676,
	FONT_END, -9, 676,
	FONT_ADVANCE, 278, 0
    },
    {
	93,
	FONT_BEGIN, 34, 637,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 120, 637,
	FONT_END, 148, 630,
	FONT_BEGIN, 148, 630,
	FONT_NEXT, 34, 662,
	FONT_END, 245, 662,
	FONT_BEGIN, 148, 630,
	FONT_NEXT, 245, 662,
	FONT_NEXT, 162, 615,
	FONT_END, 169, 585,
	FONT_BEGIN, 169, 585,
	FONT_NEXT, 245, 662,
	FONT_END, 245, -156,
	FONT_BEGIN, 169, 585,
	FONT_NEXT, 245, -156,
	FONT_NEXT, 169, -87,
	FONT_END, 163, -115,
	FONT_BEGIN, 163, -115,
	FONT_NEXT, 245, -156,
	FONT_NEXT, 150, -127,
	FONT_NEXT, 34, -156,
	FONT_NEXT, 124, -131,
	FONT_END, 34, -131,
	FONT_ADVANCE, 333, 0
    },
    {
	94,
	FONT_BEGIN, 446, 297,
	FONT_NEXT, 378, 297,
	FONT_NEXT, 265, 662,
	FONT_NEXT, 235, 586,
	FONT_NEXT, 205, 662,
	FONT_NEXT, 92, 297,
	FONT_END, 24, 297,
	FONT_ADVANCE, 469, 0
    },
    {
	95,
	FONT_BEGIN, 500, -75,
	FONT_NEXT, 500, -125,
	FONT_NEXT, 0, -75,
	FONT_END, 0, -125,
	FONT_ADVANCE, 500, 0
    },
    {
	96,
	FONT_BEGIN, 236, 657,
	FONT_NEXT, 195, 625,
	FONT_NEXT, 227, 676,
	FONT_END, 196, 658,
	FONT_BEGIN, 196, 658,
	FONT_NEXT, 195, 625,
	FONT_NEXT, 159, 625,
	FONT_NEXT, 170, 595,
	FONT_END, 157, 569,
	FONT_BEGIN, 159, 625,
	FONT_NEXT, 157, 569,
	FONT_NEXT, 128, 580,
	FONT_NEXT, 154, 551,
	FONT_END, 146, 449,
	FONT_BEGIN, 128, 580,
	FONT_NEXT, 146, 449,
	FONT_END, 124, 478,
	FONT_BEGIN, 128, 580,
	FONT_NEXT, 124, 478,
	FONT_END, 115, 529,
	FONT_BEGIN, 254, 491,
	FONT_NEXT, 248, 463,
	FONT_NEXT, 247, 515,
	FONT_NEXT, 234, 445,
	FONT_NEXT, 232, 531,
	FONT_NEXT, 196, 433,
	FONT_NEXT, 192, 541,
	FONT_NEXT, 173, 436,
	FONT_NEXT, 177, 539,
	FONT_END, 168, 537,
	FONT_BEGIN, 168, 537,
	FONT_NEXT, 173, 436,
	FONT_END, 146, 449,
	FONT_BEGIN, 168, 537,
	FONT_NEXT, 146, 449,
	FONT_NEXT, 158, 540,
	FONT_END, 154, 551,
	FONT_ADVANCE, 333, 0
    },
    {
	97,
	FONT_BEGIN, 56, 349,
	FONT_NEXT, 65, 383,
	FONT_NEXT, 65, 321,
	FONT_END, 79, 309,
	FONT_BEGIN, 79, 309,
	FONT_NEXT, 65, 383,
	FONT_END, 94, 419,
	FONT_BEGIN, 79, 309,
	FONT_NEXT, 94, 419,
	FONT_NEXT, 99, 305,
	FONT_END, 131, 318,
	FONT_BEGIN, 131, 318,
	FONT_NEXT, 94, 419,
	FONT_END, 139, 387,
	FONT_BEGIN, 131, 318,
	FONT_NEXT, 139, 387,
	FONT_END, 144, 348,
	FONT_BEGIN, 37, 94,
	FONT_NEXT, 41, 128,
	FONT_NEXT, 45, 49,
	FONT_NEXT, 53, 158,
	FONT_NEXT, 69, 16,
	FONT_NEXT, 73, 183,
	FONT_END, 100, 206,
	FONT_BEGIN, 69, 16,
	FONT_NEXT, 100, 206,
	FONT_NEXT, 103, -4,
	FONT_END, 125, 126,
	FONT_BEGIN, 125, 126,
	FONT_NEXT, 100, 206,
	FONT_NEXT, 125, 128,
	FONT_END, 129, 157,
	FONT_BEGIN, 129, 157,
	FONT_NEXT, 100, 206,
	FONT_NEXT, 149, 192,
	FONT_END, 169, 210,
	FONT_BEGIN, 169, 210,
	FONT_NEXT, 100, 206,
	FONT_END, 179, 248,
	FONT_BEGIN, 169, 210,
	FONT_NEXT, 179, 248,
	FONT_NEXT, 197, 229,
	FONT_END, 236, 249,
	FONT_BEGIN, 236, 249,
	FONT_NEXT, 179, 248,
	FONT_NEXT, 287, 268,
	FONT_NEXT, 287, 292,
	FONT_NEXT, 287, 123,
	FONT_NEXT, 287, 353,
	FONT_NEXT, 288, 63,
	FONT_END, 297, 21,
	FONT_BEGIN, 297, 21,
	FONT_NEXT, 287, 353,
	FONT_NEXT, 305, 443,
	FONT_NEXT, 279, 396,
	FONT_NEXT, 268, 455,
	FONT_NEXT, 259, 421,
	FONT_NEXT, 219, 460,
	FONT_NEXT, 234, 433,
	FONT_END, 210, 436,
	FONT_BEGIN, 219, 460,
	FONT_NEXT, 210, 436,
	FONT_NEXT, 178, 456,
	FONT_NEXT, 162, 423,
	FONT_NEXT, 144, 448,
	FONT_NEXT, 145, 407,
	FONT_END, 139, 387,
	FONT_BEGIN, 144, 448,
	FONT_NEXT, 139, 387,
	FONT_END, 94, 419,
	FONT_BEGIN, 287, 123,
	FONT_NEXT, 288, 63,
	FONT_NEXT, 281, 88,
	FONT_NEXT, 222, 14,
	FONT_NEXT, 271, 77,
	FONT_END, 253, 66,
	FONT_BEGIN, 253, 66,
	FONT_NEXT, 222, 14,
	FONT_NEXT, 226, 55,
	FONT_END, 191, 48,
	FONT_BEGIN, 191, 48,
	FONT_NEXT, 222, 14,
	FONT_END, 183, -4,
	FONT_BEGIN, 191, 48,
	FONT_NEXT, 183, -4,
	FONT_NEXT, 165, 53,
	FONT_NEXT, 143, -10,
	FONT_NEXT, 144, 69,
	FONT_END, 130, 93,
	FONT_BEGIN, 130, 93,
	FONT_NEXT, 143, -10,
	FONT_END, 103, -4,
	FONT_BEGIN, 130, 93,
	FONT_NEXT, 103, -4,
	FONT_END, 125, 126,
	FONT_BEGIN, 368, 300,
	FONT_NEXT, 368, 105,
	FONT_NEXT, 365, 350,
	FONT_NEXT, 353, -10,
	FONT_NEXT, 349, 402,
	FONT_NEXT, 315, -1,
	FONT_NEXT, 331, 425,
	FONT_END, 305, 443,
	FONT_BEGIN, 305, 443,
	FONT_NEXT, 315, -1,
	FONT_END, 297, 21,
	FONT_BEGIN, 305, 443,
	FONT_END, 297, 21,
	FONT_BEGIN, 442, 66,
	FONT_NEXT, 442, 40,
	FONT_NEXT, 423, 53,
	FONT_NEXT, 412, 11,
	FONT_NEXT, 397, 47,
	FONT_NEXT, 387, -4,
	FONT_NEXT, 380, 51,
	FONT_NEXT, 353, -10,
	FONT_NEXT, 371, 65,
	FONT_END, 368, 105,
	FONT_ADVANCE, 444, 0
    },
    {
	98,
	FONT_BEGIN, 3, 623,
	FONT_NEXT, 3, 639,
	FONT_NEXT, 25, 624,
	FONT_END, 50, 620,
	FONT_BEGIN, 50, 620,
	FONT_NEXT, 3, 639,
	FONT_END, 148, 683,
	FONT_BEGIN, 50, 620,
	FONT_NEXT, 148, 683,
	FONT_NEXT, 63, 609,
	FONT_END, 69, 573,
	FONT_BEGIN, 69, 573,
	FONT_NEXT, 148, 683,
	FONT_END, 127, 8,
	FONT_BEGIN, 69, 573,
	FONT_NEXT, 127, 8,
	FONT_END, 86, 28,
	FONT_BEGIN, 69, 573,
	FONT_NEXT, 86, 28,
	FONT_END, 73, 40,
	FONT_BEGIN, 69, 573,
	FONT_NEXT, 73, 40,
	FONT_END, 69, 54,
	FONT_BEGIN, 153, 379,
	FONT_NEXT, 155, 379,
	FONT_NEXT, 153, 322,
	FONT_END, 165, 357,
	FONT_BEGIN, 165, 357,
	FONT_NEXT, 155, 379,
	FONT_END, 167, 401,
	FONT_BEGIN, 165, 357,
	FONT_NEXT, 167, 401,
	FONT_NEXT, 192, 380,
	FONT_NEXT, 196, 428,
	FONT_NEXT, 224, 393,
	FONT_NEXT, 237, 450,
	FONT_NEXT, 253, 397,
	FONT_END, 284, 392,
	FONT_BEGIN, 284, 392,
	FONT_NEXT, 237, 450,
	FONT_END, 290, 460,
	FONT_BEGIN, 284, 392,
	FONT_NEXT, 290, 460,
	FONT_NEXT, 311, 379,
	FONT_NEXT, 332, 454,
	FONT_NEXT, 350, 333,
	FONT_NEXT, 368, 440,
	FONT_NEXT, 372, 270,
	FONT_END, 380, 201,
	FONT_BEGIN, 380, 201,
	FONT_NEXT, 368, 440,
	FONT_END, 399, 417,
	FONT_BEGIN, 380, 201,
	FONT_NEXT, 399, 417,
	FONT_END, 382, 44,
	FONT_BEGIN, 380, 201,
	FONT_NEXT, 382, 44,
	FONT_NEXT, 375, 145,
	FONT_NEXT, 340, 16,
	FONT_NEXT, 357, 86,
	FONT_END, 340, 61,
	FONT_BEGIN, 340, 61,
	FONT_NEXT, 340, 16,
	FONT_NEXT, 317, 40,
	FONT_NEXT, 287, -4,
	FONT_NEXT, 287, 26,
	FONT_END, 249, 22,
	FONT_BEGIN, 249, 22,
	FONT_NEXT, 287, -4,
	FONT_END, 224, -10,
	FONT_BEGIN, 249, 22,
	FONT_NEXT, 224, -10,
	FONT_NEXT, 223, 24,
	FONT_NEXT, 178, -6,
	FONT_NEXT, 191, 32,
	FONT_END, 164, 47,
	FONT_BEGIN, 164, 47,
	FONT_NEXT, 178, -6,
	FONT_END, 127, 8,
	FONT_BEGIN, 164, 47,
	FONT_NEXT, 127, 8,
	FONT_NEXT, 153, 70,
	FONT_NEXT, 148, 683,
	FONT_NEXT, 153, 322,
	FONT_END, 153, 379,
	FONT_BEGIN, 153, 379,
	FONT_NEXT, 148, 683,
	FONT_END, 153, 681,
	FONT_BEGIN, 153, 379,
	FONT_END, 153, 681,
	FONT_BEGIN, 468, 238,
	FONT_NEXT, 455, 161,
	FONT_NEXT, 457, 317,
	FONT_END, 424, 389,
	FONT_BEGIN, 424, 389,
	FONT_NEXT, 455, 161,
	FONT_END, 439, 119,
	FONT_BEGIN, 424, 389,
	FONT_NEXT, 439, 119,
	FONT_END, 415, 80,
	FONT_BEGIN, 424, 389,
	FONT_NEXT, 415, 80,
	FONT_NEXT, 399, 417,
	FONT_END, 382, 44,
	FONT_ADVANCE, 500, 0
    },
    {
	99,
	FONT_BEGIN, 25, 213,
	FONT_NEXT, 30, 270,
	FONT_NEXT, 29, 158,
	FONT_END, 42, 111,
	FONT_BEGIN, 42, 111,
	FONT_NEXT, 30, 270,
	FONT_END, 44, 320,
	FONT_BEGIN, 42, 111,
	FONT_NEXT, 44, 320,
	FONT_NEXT, 63, 73,
	FONT_NEXT, 67, 363,
	FONT_NEXT, 88, 42,
	FONT_NEXT, 96, 398,
	FONT_NEXT, 102, 253,
	FONT_END, 106, 302,
	FONT_BEGIN, 106, 302,
	FONT_NEXT, 96, 398,
	FONT_NEXT, 116, 342,
	FONT_NEXT, 130, 425,
	FONT_NEXT, 133, 373,
	FONT_END, 152, 397,
	FONT_BEGIN, 152, 397,
	FONT_NEXT, 130, 425,
	FONT_END, 168, 444,
	FONT_BEGIN, 152, 397,
	FONT_NEXT, 168, 444,
	FONT_NEXT, 195, 423,
	FONT_END, 231, 431,
	FONT_BEGIN, 231, 431,
	FONT_NEXT, 168, 444,
	FONT_END, 249, 460,
	FONT_BEGIN, 231, 431,
	FONT_NEXT, 249, 460,
	FONT_NEXT, 262, 427,
	FONT_END, 280, 418,
	FONT_BEGIN, 280, 418,
	FONT_NEXT, 249, 460,
	FONT_END, 306, 450,
	FONT_BEGIN, 280, 418,
	FONT_NEXT, 306, 450,
	FONT_NEXT, 297, 383,
	FONT_END, 303, 361,
	FONT_BEGIN, 303, 361,
	FONT_NEXT, 306, 450,
	FONT_NEXT, 320, 329,
	FONT_END, 334, 318,
	FONT_BEGIN, 334, 318,
	FONT_NEXT, 306, 450,
	FONT_NEXT, 352, 315,
	FONT_NEXT, 355, 429,
	FONT_NEXT, 386, 329,
	FONT_NEXT, 387, 392,
	FONT_END, 398, 359,
	FONT_BEGIN, 412, 147,
	FONT_NEXT, 369, 74,
	FONT_NEXT, 398, 156,
	FONT_END, 340, 89,
	FONT_BEGIN, 340, 89,
	FONT_NEXT, 369, 74,
	FONT_END, 322, 25,
	FONT_BEGIN, 340, 89,
	FONT_NEXT, 322, 25,
	FONT_NEXT, 302, 69,
	FONT_NEXT, 269, -2,
	FONT_NEXT, 255, 62,
	FONT_NEXT, 212, -10,
	FONT_NEXT, 195, 75,
	FONT_NEXT, 149, 2,
	FONT_NEXT, 147, 114,
	FONT_NEXT, 88, 42,
	FONT_NEXT, 114, 174,
	FONT_END, 102, 253,
	FONT_ADVANCE, 444, 0
    },
    {
	100,
	FONT_BEGIN, 113, 247,
	FONT_NEXT, 116, 195,
	FONT_NEXT, 103, 25,
	FONT_NEXT, 125, 152,
	FONT_END, 139, 116,
	FONT_BEGIN, 103, 25,
	FONT_NEXT, 139, 116,
	FONT_END, 157, 88,
	FONT_BEGIN, 103, 25,
	FONT_NEXT, 157, 88,
	FONT_NEXT, 164, -4,
	FONT_NEXT, 201, 53,
	FONT_NEXT, 209, -10,
	FONT_NEXT, 251, 42,
	FONT_NEXT, 257, -4,
	FONT_NEXT, 281, 46,
	FONT_NEXT, 294, 11,
	FONT_NEXT, 308, 58,
	FONT_NEXT, 320, 32,
	FONT_NEXT, 328, 77,
	FONT_NEXT, 338, 54,
	FONT_END, 340, 54,
	FONT_BEGIN, 340, 54,
	FONT_NEXT, 328, 77,
	FONT_END, 340, 102,
	FONT_BEGIN, 340, 54,
	FONT_NEXT, 340, 102,
	FONT_NEXT, 340, -7,
	FONT_NEXT, 340, 332,
	FONT_NEXT, 340, 417,
	FONT_NEXT, 327, 376,
	FONT_NEXT, 290, 449,
	FONT_NEXT, 303, 407,
	FONT_END, 271, 425,
	FONT_BEGIN, 290, 449,
	FONT_NEXT, 271, 425,
	FONT_NEXT, 234, 460,
	FONT_NEXT, 237, 432,
	FONT_END, 194, 422,
	FONT_BEGIN, 234, 460,
	FONT_NEXT, 194, 422,
	FONT_NEXT, 192, 454,
	FONT_NEXT, 154, 390,
	FONT_NEXT, 154, 439,
	FONT_END, 119, 416,
	FONT_BEGIN, 119, 416,
	FONT_NEXT, 154, 390,
	FONT_END, 124, 333,
	FONT_BEGIN, 119, 416,
	FONT_NEXT, 124, 333,
	FONT_END, 116, 293,
	FONT_BEGIN, 119, 416,
	FONT_NEXT, 116, 293,
	FONT_NEXT, 88, 386,
	FONT_NEXT, 113, 247,
	FONT_END, 103, 25,
	FONT_BEGIN, 88, 386,
	FONT_NEXT, 103, 25,
	FONT_END, 74, 53,
	FONT_BEGIN, 88, 386,
	FONT_NEXT, 74, 53,
	FONT_NEXT, 43, 307,
	FONT_NEXT, 49, 92,
	FONT_END, 33, 145,
	FONT_BEGIN, 43, 307,
	FONT_NEXT, 33, 145,
	FONT_NEXT, 31, 262,
	FONT_END, 27, 214,
	FONT_BEGIN, 272, 623,
	FONT_NEXT, 272, 639,
	FONT_NEXT, 296, 624,
	FONT_END, 321, 620,
	FONT_BEGIN, 321, 620,
	FONT_NEXT, 272, 639,
	FONT_END, 419, 683,
	FONT_BEGIN, 321, 620,
	FONT_NEXT, 419, 683,
	FONT_NEXT, 334, 609,
	FONT_END, 340, 573,
	FONT_BEGIN, 340, 573,
	FONT_NEXT, 419, 683,
	FONT_END, 344, -10,
	FONT_BEGIN, 340, 573,
	FONT_NEXT, 344, -10,
	FONT_END, 340, -7,
	FONT_BEGIN, 340, 573,
	FONT_NEXT, 340, -7,
	FONT_END, 340, 417,
	FONT_BEGIN, 491, 58,
	FONT_NEXT, 491, 42,
	FONT_NEXT, 452, 58,
	FONT_NEXT, 344, -10,
	FONT_NEXT, 432, 68,
	FONT_END, 425, 87,
	FONT_BEGIN, 425, 87,
	FONT_NEXT, 344, -10,
	FONT_NEXT, 424, 114,
	FONT_NEXT, 419, 683,
	FONT_END, 424, 681,
	FONT_ADVANCE, 500, 0
    },
    {
	101,
	FONT_BEGIN, 424, 157,
	FONT_NEXT, 417, 140,
	FONT_NEXT, 408, 164,
	FONT_NEXT, 406, 117,
	FONT_NEXT, 386, 131,
	FONT_NEXT, 368, 61,
	FONT_NEXT, 355, 97,
	FONT_NEXT, 304, 11,
	FONT_NEXT, 311, 70,
	FONT_END, 253, 59,
	FONT_BEGIN, 253, 59,
	FONT_NEXT, 304, 11,
	FONT_END, 262, -5,
	FONT_BEGIN, 253, 59,
	FONT_NEXT, 262, -5,
	FONT_END, 212, -10,
	FONT_BEGIN, 253, 59,
	FONT_NEXT, 212, -10,
	FONT_NEXT, 202, 68,
	FONT_NEXT, 172, -7,
	FONT_NEXT, 153, 101,
	FONT_NEXT, 135, 5,
	FONT_NEXT, 132, 130,
	FONT_NEXT, 104, 23,
	FONT_NEXT, 114, 168,
	FONT_END, 101, 216,
	FONT_BEGIN, 101, 216,
	FONT_NEXT, 104, 23,
	FONT_END, 76, 48,
	FONT_BEGIN, 101, 216,
	FONT_NEXT, 76, 48,
	FONT_NEXT, 94, 277,
	FONT_END, 68, 373,
	FONT_BEGIN, 68, 373,
	FONT_NEXT, 76, 48,
	FONT_END, 54, 80,
	FONT_BEGIN, 68, 373,
	FONT_NEXT, 54, 80,
	FONT_NEXT, 45, 330,
	FONT_NEXT, 38, 119,
	FONT_NEXT, 30, 277,
	FONT_NEXT, 28, 163,
	FONT_END, 25, 214,
	FONT_BEGIN, 303, 309,
	FONT_NEXT, 94, 277,
	FONT_NEXT, 97, 309,
	FONT_NEXT, 68, 373,
	FONT_END, 97, 406,
	FONT_BEGIN, 97, 309,
	FONT_NEXT, 97, 406,
	FONT_NEXT, 113, 364,
	FONT_NEXT, 129, 430,
	FONT_NEXT, 137, 399,
	FONT_NEXT, 163, 447,
	FONT_NEXT, 168, 418,
	FONT_END, 207, 424,
	FONT_BEGIN, 207, 424,
	FONT_NEXT, 163, 447,
	FONT_END, 229, 460,
	FONT_BEGIN, 207, 424,
	FONT_NEXT, 229, 460,
	FONT_NEXT, 254, 412,
	FONT_END, 282, 384,
	FONT_BEGIN, 282, 384,
	FONT_NEXT, 229, 460,
	FONT_END, 294, 449,
	FONT_BEGIN, 282, 384,
	FONT_NEXT, 294, 449,
	FONT_NEXT, 303, 309,
	FONT_NEXT, 348, 417,
	FONT_END, 386, 360,
	FONT_BEGIN, 303, 309,
	FONT_NEXT, 386, 360,
	FONT_END, 398, 322,
	FONT_BEGIN, 303, 309,
	FONT_NEXT, 398, 322,
	FONT_NEXT, 94, 277,
	FONT_END, 405, 277,
	FONT_ADVANCE, 444, 0
    },
    {
	102,
	FONT_BEGIN, 383, 622,
	FONT_NEXT, 379, 603,
	FONT_NEXT, 375, 645,
	FONT_NEXT, 369, 590,
	FONT_NEXT, 354, 665,
	FONT_NEXT, 340, 580,
	FONT_NEXT, 322, 678,
	FONT_NEXT, 246, 655,
	FONT_NEXT, 283, 683,
	FONT_END, 223, 675,
	FONT_BEGIN, 223, 675,
	FONT_NEXT, 246, 655,
	FONT_END, 213, 646,
	FONT_BEGIN, 223, 675,
	FONT_NEXT, 213, 646,
	FONT_NEXT, 178, 654,
	FONT_NEXT, 195, 624,
	FONT_END, 186, 566,
	FONT_BEGIN, 178, 654,
	FONT_NEXT, 186, 566,
	FONT_END, 186, 450,
	FONT_BEGIN, 178, 654,
	FONT_NEXT, 186, 450,
	FONT_END, 99, 58,
	FONT_BEGIN, 178, 654,
	FONT_NEXT, 99, 58,
	FONT_END, 103, 104,
	FONT_BEGIN, 178, 654,
	FONT_NEXT, 103, 104,
	FONT_NEXT, 146, 624,
	FONT_END, 125, 587,
	FONT_BEGIN, 125, 587,
	FONT_NEXT, 103, 104,
	FONT_NEXT, 105, 510,
	FONT_END, 103, 476,
	FONT_BEGIN, 103, 476,
	FONT_NEXT, 103, 104,
	FONT_NEXT, 103, 450,
	FONT_NEXT, 103, 418,
	FONT_NEXT, 21, 450,
	FONT_END, 21, 418,
	FONT_BEGIN, 309, 450,
	FONT_NEXT, 309, 418,
	FONT_NEXT, 186, 450,
	FONT_NEXT, 187, 418,
	FONT_END, 187, 104,
	FONT_BEGIN, 186, 450,
	FONT_NEXT, 187, 104,
	FONT_NEXT, 99, 58,
	FONT_END, 86, 31,
	FONT_BEGIN, 86, 31,
	FONT_NEXT, 187, 104,
	FONT_END, 188, 64,
	FONT_BEGIN, 86, 31,
	FONT_NEXT, 188, 64,
	FONT_END, 20, 0,
	FONT_BEGIN, 86, 31,
	FONT_NEXT, 20, 0,
	FONT_NEXT, 60, 19,
	FONT_END, 20, 15,
	FONT_BEGIN, 280, 15,
	FONT_NEXT, 280, 0,
	FONT_NEXT, 226, 21,
	FONT_NEXT, 20, 0,
	FONT_NEXT, 199, 37,
	FONT_END, 188, 64,
	FONT_ADVANCE, 333, 0
    },
    {
	103,
	FONT_BEGIN, 69, 293,
	FONT_NEXT, 73, 334,
	FONT_NEXT, 75, 251,
	FONT_NEXT, 85, 369,
	FONT_NEXT, 93, 216,
	FONT_END, 122, 186,
	FONT_BEGIN, 122, 186,
	FONT_NEXT, 85, 369,
	FONT_END, 126, 421,
	FONT_BEGIN, 122, 186,
	FONT_NEXT, 126, 421,
	FONT_END, 152, 342,
	FONT_BEGIN, 122, 186,
	FONT_NEXT, 152, 342,
	FONT_END, 157, 282,
	FONT_BEGIN, 122, 186,
	FONT_NEXT, 157, 282,
	FONT_NEXT, 162, 163,
	FONT_NEXT, 174, 228,
	FONT_END, 175, 146,
	FONT_BEGIN, 162, 163,
	FONT_NEXT, 175, 146,
	FONT_END, 155, 129,
	FONT_BEGIN, 162, 163,
	FONT_NEXT, 155, 129,
	FONT_NEXT, 132, 136,
	FONT_NEXT, 139, 109,
	FONT_END, 133, 91,
	FONT_BEGIN, 132, 136,
	FONT_NEXT, 133, 91,
	FONT_END, 126, 1,
	FONT_BEGIN, 132, 136,
	FONT_NEXT, 126, 1,
	FONT_NEXT, 110, 115,
	FONT_NEXT, 89, 21,
	FONT_NEXT, 84, 85,
	FONT_NEXT, 77, 35,
	FONT_NEXT, 74, 67,
	FONT_END, 73, 54,
	FONT_BEGIN, 175, 146,
	FONT_NEXT, 174, 228,
	FONT_NEXT, 193, 154,
	FONT_NEXT, 206, 189,
	FONT_END, 229, 177,
	FONT_BEGIN, 193, 154,
	FONT_NEXT, 229, 177,
	FONT_NEXT, 247, 149,
	FONT_NEXT, 256, 174,
	FONT_NEXT, 295, 156,
	FONT_NEXT, 296, 185,
	FONT_END, 318, 213,
	FONT_BEGIN, 295, 156,
	FONT_NEXT, 318, 213,
	FONT_NEXT, 347, 182,
	FONT_NEXT, 327, 245,
	FONT_END, 329, 270,
	FONT_BEGIN, 347, 182,
	FONT_NEXT, 329, 270,
	FONT_NEXT, 338, 437,
	FONT_NEXT, 325, 307,
	FONT_NEXT, 287, 454,
	FONT_NEXT, 310, 361,
	FONT_END, 279, 410,
	FONT_BEGIN, 287, 454,
	FONT_NEXT, 279, 410,
	FONT_NEXT, 241, 460,
	FONT_NEXT, 256, 426,
	FONT_END, 227, 432,
	FONT_BEGIN, 241, 460,
	FONT_NEXT, 227, 432,
	FONT_NEXT, 182, 450,
	FONT_NEXT, 200, 427,
	FONT_END, 176, 412,
	FONT_BEGIN, 182, 450,
	FONT_NEXT, 176, 412,
	FONT_NEXT, 126, 421,
	FONT_NEXT, 158, 384,
	FONT_END, 152, 342,
	FONT_BEGIN, 28, -121,
	FONT_NEXT, 36, -89,
	FONT_NEXT, 41, -159,
	FONT_NEXT, 57, -57,
	FONT_NEXT, 78, -190,
	FONT_NEXT, 98, -90,
	FONT_END, 105, -115,
	FONT_BEGIN, 78, -190,
	FONT_NEXT, 105, -115,
	FONT_END, 130, -138,
	FONT_BEGIN, 78, -190,
	FONT_NEXT, 130, -138,
	FONT_NEXT, 134, -211,
	FONT_NEXT, 176, -155,
	FONT_NEXT, 205, -218,
	FONT_NEXT, 248, -161,
	FONT_NEXT, 282, -208,
	FONT_NEXT, 326, -154,
	FONT_NEXT, 366, -176,
	FONT_NEXT, 384, -133,
	FONT_NEXT, 403, -153,
	FONT_NEXT, 420, -102,
	FONT_NEXT, 433, -124,
	FONT_NEXT, 433, -64,
	FONT_NEXT, 440, 13,
	FONT_END, 404, 43,
	FONT_BEGIN, 404, 43,
	FONT_NEXT, 433, -64,
	FONT_END, 424, -38,
	FONT_BEGIN, 404, 43,
	FONT_NEXT, 424, -38,
	FONT_END, 399, -24,
	FONT_BEGIN, 404, 43,
	FONT_NEXT, 399, -24,
	FONT_NEXT, 375, 53,
	FONT_NEXT, 360, -18,
	FONT_NEXT, 340, 58,
	FONT_NEXT, 310, -15,
	FONT_NEXT, 211, 64,
	FONT_NEXT, 251, -14,
	FONT_END, 210, -12,
	FONT_BEGIN, 211, 64,
	FONT_NEXT, 210, -12,
	FONT_NEXT, 160, 69,
	FONT_NEXT, 147, -2,
	FONT_NEXT, 140, 77,
	FONT_NEXT, 126, 1,
	FONT_END, 133, 91,
	FONT_BEGIN, 147, -2,
	FONT_NEXT, 110, -49,
	FONT_NEXT, 126, 1,
	FONT_END, 57, -57,
	FONT_BEGIN, 57, -57,
	FONT_NEXT, 110, -49,
	FONT_END, 98, -90,
	FONT_BEGIN, 57, -57,
	FONT_END, 98, -90,
	FONT_BEGIN, 461, -49,
	FONT_NEXT, 453, -89,
	FONT_NEXT, 457, -22,
	FONT_END, 440, 13,
	FONT_BEGIN, 440, 13,
	FONT_NEXT, 453, -89,
	FONT_END, 433, -124,
	FONT_BEGIN, 440, 13,
	FONT_END, 433, -124,
	FONT_BEGIN, 470, 427,
	FONT_NEXT, 470, 388,
	FONT_NEXT, 393, 427,
	FONT_NEXT, 387, 388,
	FONT_NEXT, 338, 437,
	FONT_END, 347, 182,
	FONT_BEGIN, 347, 182,
	FONT_NEXT, 387, 388,
	FONT_NEXT, 389, 227,
	FONT_NEXT, 400, 352,
	FONT_NEXT, 401, 258,
	FONT_NEXT, 404, 328,
	FONT_END, 406, 296,
	FONT_ADVANCE, 500, 0
    },
    {
	104,
	FONT_BEGIN, 157, 680,
	FONT_NEXT, 157, 378,
	FONT_NEXT, 152, 683,
	FONT_NEXT, 157, 343,
	FONT_END, 157, 102,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 157, 102,
	FONT_END, 70, 58,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 70, 58,
	FONT_END, 73, 102,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 73, 102,
	FONT_END, 73, 573,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 73, 573,
	FONT_END, 67, 609,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 67, 609,
	FONT_END, 54, 620,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 54, 620,
	FONT_NEXT, 10, 639,
	FONT_NEXT, 29, 624,
	FONT_END, 10, 623,
	FONT_BEGIN, 427, 301,
	FONT_NEXT, 427, 102,
	FONT_NEXT, 424, 342,
	FONT_NEXT, 339, 56,
	FONT_NEXT, 411, 395,
	FONT_END, 396, 420,
	FONT_BEGIN, 396, 420,
	FONT_NEXT, 339, 56,
	FONT_NEXT, 374, 440,
	FONT_NEXT, 343, 102,
	FONT_NEXT, 343, 454,
	FONT_NEXT, 343, 300,
	FONT_END, 338, 344,
	FONT_BEGIN, 343, 454,
	FONT_NEXT, 338, 344,
	FONT_NEXT, 303, 460,
	FONT_NEXT, 325, 378,
	FONT_END, 301, 398,
	FONT_BEGIN, 303, 460,
	FONT_NEXT, 301, 398,
	FONT_NEXT, 260, 454,
	FONT_NEXT, 266, 406,
	FONT_END, 216, 392,
	FONT_BEGIN, 260, 454,
	FONT_NEXT, 216, 392,
	FONT_NEXT, 221, 437,
	FONT_END, 187, 411,
	FONT_BEGIN, 187, 411,
	FONT_NEXT, 216, 392,
	FONT_END, 187, 373,
	FONT_BEGIN, 187, 411,
	FONT_NEXT, 187, 373,
	FONT_NEXT, 159, 378,
	FONT_NEXT, 157, 343,
	FONT_END, 157, 378,
	FONT_BEGIN, 487, 15,
	FONT_NEXT, 487, 0,
	FONT_NEXT, 456, 22,
	FONT_NEXT, 275, 0,
	FONT_NEXT, 438, 34,
	FONT_END, 429, 58,
	FONT_BEGIN, 429, 58,
	FONT_NEXT, 275, 0,
	FONT_END, 327, 31,
	FONT_BEGIN, 429, 58,
	FONT_NEXT, 327, 31,
	FONT_NEXT, 427, 102,
	FONT_END, 339, 56,
	FONT_BEGIN, 275, 15,
	FONT_NEXT, 306, 19,
	FONT_NEXT, 275, 0,
	FONT_END, 327, 31,
	FONT_BEGIN, 225, 15,
	FONT_NEXT, 225, 0,
	FONT_NEXT, 193, 19,
	FONT_NEXT, 9, 0,
	FONT_NEXT, 172, 31,
	FONT_END, 160, 56,
	FONT_BEGIN, 160, 56,
	FONT_NEXT, 9, 0,
	FONT_END, 61, 33,
	FONT_BEGIN, 160, 56,
	FONT_NEXT, 61, 33,
	FONT_NEXT, 157, 102,
	FONT_END, 70, 58,
	FONT_BEGIN, 9, 15,
	FONT_NEXT, 41, 21,
	FONT_NEXT, 9, 0,
	FONT_END, 61, 33,
	FONT_ADVANCE, 500, 0
    },
    {
	105,
	FONT_BEGIN, 179, 457,
	FONT_NEXT, 179, 102,
	FONT_NEXT, 175, 460,
	FONT_NEXT, 91, 55,
	FONT_END, 95, 102,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 95, 102,
	FONT_END, 95, 334,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 95, 334,
	FONT_END, 91, 368,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 91, 368,
	FONT_END, 83, 386,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 83, 386,
	FONT_END, 60, 394,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 60, 394,
	FONT_NEXT, 20, 405,
	FONT_END, 20, 390,
	FONT_BEGIN, 16, 15,
	FONT_NEXT, 54, 18,
	FONT_NEXT, 16, 0,
	FONT_END, 180, 61,
	FONT_BEGIN, 180, 61,
	FONT_NEXT, 54, 18,
	FONT_END, 78, 30,
	FONT_BEGIN, 180, 61,
	FONT_NEXT, 78, 30,
	FONT_NEXT, 179, 102,
	FONT_END, 91, 55,
	FONT_BEGIN, 253, 15,
	FONT_NEXT, 253, 0,
	FONT_NEXT, 212, 21,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 190, 35,
	FONT_END, 180, 61,
	FONT_BEGIN, 180, 632,
	FONT_NEXT, 176, 611,
	FONT_NEXT, 165, 668,
	FONT_NEXT, 165, 595,
	FONT_NEXT, 148, 678,
	FONT_NEXT, 148, 584,
	FONT_NEXT, 128, 683,
	FONT_NEXT, 128, 581,
	FONT_NEXT, 105, 677,
	FONT_NEXT, 105, 586,
	FONT_NEXT, 89, 664,
	FONT_NEXT, 89, 599,
	FONT_END, 78, 632,
	FONT_ADVANCE, 278, 0
    },
    {
	106,
	FONT_BEGIN, 32, 390,
	FONT_NEXT, 32, 406,
	FONT_NEXT, 74, 394,
	FONT_NEXT, 188, 460,
	FONT_NEXT, 97, 386,
	FONT_END, 105, 368,
	FONT_BEGIN, 105, 368,
	FONT_NEXT, 188, 460,
	FONT_END, 184, -84,
	FONT_BEGIN, 105, 368,
	FONT_NEXT, 184, -84,
	FONT_NEXT, 109, 334,
	FONT_NEXT, 156, -153,
	FONT_END, 133, -180,
	FONT_BEGIN, 109, 334,
	FONT_NEXT, 133, -180,
	FONT_NEXT, 109, -45,
	FONT_END, 108, -102,
	FONT_BEGIN, 108, -102,
	FONT_NEXT, 133, -180,
	FONT_END, 103, -201,
	FONT_BEGIN, 108, -102,
	FONT_NEXT, 103, -201,
	FONT_NEXT, 102, -146,
	FONT_NEXT, 67, -214,
	FONT_NEXT, 87, -174,
	FONT_END, 59, -184,
	FONT_BEGIN, 59, -184,
	FONT_NEXT, 67, -214,
	FONT_END, 23, -218,
	FONT_BEGIN, 59, -184,
	FONT_NEXT, 23, -218,
	FONT_NEXT, -30, -124,
	FONT_NEXT, -12, -215,
	FONT_END, -42, -204,
	FONT_BEGIN, -30, -124,
	FONT_NEXT, -42, -204,
	FONT_NEXT, -58, -135,
	FONT_NEXT, -63, -187,
	FONT_END, -70, -162,
	FONT_BEGIN, 193, 457,
	FONT_NEXT, 193, 0,
	FONT_NEXT, 188, 460,
	FONT_END, 184, -84,
	FONT_BEGIN, 194, 632,
	FONT_NEXT, 190, 611,
	FONT_NEXT, 179, 668,
	FONT_NEXT, 179, 595,
	FONT_NEXT, 162, 678,
	FONT_NEXT, 162, 584,
	FONT_NEXT, 142, 683,
	FONT_NEXT, 142, 581,
	FONT_NEXT, 119, 677,
	FONT_NEXT, 119, 586,
	FONT_NEXT, 103, 664,
	FONT_NEXT, 103, 599,
	FONT_END, 92, 632,
	FONT_ADVANCE, 278, 0
    },
    {
	107,
	FONT_BEGIN, 166, 681,
	FONT_NEXT, 166, 265,
	FONT_NEXT, 162, 683,
	FONT_NEXT, 166, 248,
	FONT_END, 166, 67,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 166, 67,
	FONT_END, 79, 50,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 79, 50,
	FONT_END, 82, 82,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 82, 82,
	FONT_END, 82, 564,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 82, 564,
	FONT_END, 80, 592,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 80, 592,
	FONT_END, 74, 611,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 74, 611,
	FONT_END, 60, 621,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 60, 621,
	FONT_NEXT, 7, 639,
	FONT_NEXT, 37, 625,
	FONT_END, 7, 623,
	FONT_BEGIN, 276, 436,
	FONT_NEXT, 276, 450,
	FONT_NEXT, 301, 434,
	FONT_END, 316, 430,
	FONT_BEGIN, 316, 430,
	FONT_NEXT, 276, 450,
	FONT_END, 377, 404,
	FONT_BEGIN, 316, 430,
	FONT_NEXT, 377, 404,
	FONT_NEXT, 326, 417,
	FONT_NEXT, 347, 381,
	FONT_END, 309, 350,
	FONT_BEGIN, 326, 417,
	FONT_NEXT, 309, 350,
	FONT_NEXT, 320, 401,
	FONT_END, 303, 383,
	FONT_BEGIN, 303, 383,
	FONT_NEXT, 309, 350,
	FONT_END, 264, 309,
	FONT_BEGIN, 303, 383,
	FONT_NEXT, 264, 309,
	FONT_NEXT, 168, 263,
	FONT_NEXT, 235, 282,
	FONT_END, 168, 248,
	FONT_BEGIN, 168, 263,
	FONT_NEXT, 168, 248,
	FONT_NEXT, 166, 265,
	FONT_END, 166, 248,
	FONT_BEGIN, 480, 450,
	FONT_NEXT, 480, 435,
	FONT_NEXT, 276, 450,
	FONT_NEXT, 442, 433,
	FONT_END, 402, 419,
	FONT_BEGIN, 276, 450,
	FONT_NEXT, 402, 419,
	FONT_END, 377, 404,
	FONT_BEGIN, 505, 15,
	FONT_NEXT, 505, 0,
	FONT_NEXT, 482, 18,
	FONT_NEXT, 287, 0,
	FONT_NEXT, 455, 28,
	FONT_END, 424, 49,
	FONT_BEGIN, 424, 49,
	FONT_NEXT, 287, 0,
	FONT_END, 319, 18,
	FONT_BEGIN, 424, 49,
	FONT_NEXT, 319, 18,
	FONT_NEXT, 388, 88,
	FONT_NEXT, 327, 31,
	FONT_NEXT, 235, 282,
	FONT_NEXT, 321, 43,
	FONT_END, 306, 64,
	FONT_BEGIN, 235, 282,
	FONT_NEXT, 306, 64,
	FONT_END, 168, 248,
	FONT_BEGIN, 287, 15,
	FONT_NEXT, 306, 15,
	FONT_NEXT, 287, 0,
	FONT_END, 319, 18,
	FONT_BEGIN, 241, 15,
	FONT_NEXT, 241, 0,
	FONT_NEXT, 221, 16,
	FONT_NEXT, 7, 0,
	FONT_NEXT, 181, 26,
	FONT_END, 169, 42,
	FONT_BEGIN, 169, 42,
	FONT_NEXT, 7, 0,
	FONT_NEXT, 166, 67,
	FONT_NEXT, 69, 32,
	FONT_END, 79, 50,
	FONT_BEGIN, 7, 15,
	FONT_NEXT, 46, 22,
	FONT_NEXT, 7, 0,
	FONT_END, 69, 32,
	FONT_ADVANCE, 500, 0
    },
    {
	108,
	FONT_BEGIN, 182, 681,
	FONT_NEXT, 182, 84,
	FONT_NEXT, 178, 683,
	FONT_NEXT, 94, 53,
	FONT_END, 98, 87,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 98, 87,
	FONT_END, 98, 564,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 98, 564,
	FONT_END, 96, 592,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 96, 592,
	FONT_END, 90, 611,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 90, 611,
	FONT_END, 76, 621,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 76, 621,
	FONT_NEXT, 19, 639,
	FONT_NEXT, 53, 625,
	FONT_END, 19, 623,
	FONT_BEGIN, 257, 15,
	FONT_NEXT, 257, 0,
	FONT_NEXT, 220, 18,
	FONT_NEXT, 21, 0,
	FONT_NEXT, 197, 28,
	FONT_END, 185, 49,
	FONT_BEGIN, 185, 49,
	FONT_NEXT, 21, 0,
	FONT_END, 81, 31,
	FONT_BEGIN, 185, 49,
	FONT_NEXT, 81, 31,
	FONT_NEXT, 182, 84,
	FONT_END, 94, 53,
	FONT_BEGIN, 21, 15,
	FONT_NEXT, 57, 20,
	FONT_NEXT, 21, 0,
	FONT_END, 81, 31,
	FONT_ADVANCE, 278, 0
    },
    {
	109,
	FONT_BEGIN, 166, 458,
	FONT_NEXT, 166, 383,
	FONT_NEXT, 159, 460,
	FONT_NEXT, 80, 45,
	FONT_END, 86, 85,
	FONT_BEGIN, 159, 460,
	FONT_NEXT, 86, 85,
	FONT_END, 86, 338,
	FONT_BEGIN, 159, 460,
	FONT_NEXT, 86, 338,
	FONT_END, 82, 374,
	FONT_BEGIN, 159, 460,
	FONT_NEXT, 82, 374,
	FONT_END, 74, 393,
	FONT_BEGIN, 159, 460,
	FONT_NEXT, 74, 393,
	FONT_NEXT, 19, 415,
	FONT_NEXT, 51, 402,
	FONT_END, 19, 398,
	FONT_BEGIN, 706, 282,
	FONT_NEXT, 706, 76,
	FONT_NEXT, 702, 341,
	FONT_NEXT, 618, 49,
	FONT_NEXT, 686, 398,
	FONT_NEXT, 622, 87,
	FONT_NEXT, 650, 442,
	FONT_END, 622, 455,
	FONT_BEGIN, 622, 455,
	FONT_NEXT, 622, 87,
	FONT_END, 622, 298,
	FONT_BEGIN, 622, 455,
	FONT_NEXT, 622, 298,
	FONT_END, 612, 372,
	FONT_BEGIN, 622, 455,
	FONT_NEXT, 612, 372,
	FONT_NEXT, 588, 460,
	FONT_NEXT, 590, 397,
	FONT_END, 549, 408,
	FONT_BEGIN, 588, 460,
	FONT_NEXT, 549, 408,
	FONT_NEXT, 532, 450,
	FONT_NEXT, 511, 403,
	FONT_NEXT, 485, 427,
	FONT_NEXT, 481, 390,
	FONT_NEXT, 449, 399,
	FONT_NEXT, 438, 347,
	FONT_NEXT, 427, 376,
	FONT_NEXT, 438, 95,
	FONT_END, 349, 47,
	FONT_BEGIN, 427, 376,
	FONT_NEXT, 349, 47,
	FONT_NEXT, 414, 406,
	FONT_NEXT, 354, 86,
	FONT_NEXT, 393, 433,
	FONT_END, 362, 452,
	FONT_BEGIN, 362, 452,
	FONT_NEXT, 354, 86,
	FONT_END, 354, 303,
	FONT_BEGIN, 362, 452,
	FONT_NEXT, 354, 303,
	FONT_END, 350, 347,
	FONT_BEGIN, 362, 452,
	FONT_NEXT, 350, 347,
	FONT_NEXT, 320, 460,
	FONT_NEXT, 339, 380,
	FONT_END, 317, 400,
	FONT_BEGIN, 320, 460,
	FONT_NEXT, 317, 400,
	FONT_NEXT, 281, 454,
	FONT_NEXT, 285, 408,
	FONT_END, 237, 399,
	FONT_BEGIN, 281, 454,
	FONT_NEXT, 237, 399,
	FONT_NEXT, 244, 438,
	FONT_END, 166, 383,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 237, 399,
	FONT_END, 201, 380,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 201, 380,
	FONT_END, 178, 360,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 178, 360,
	FONT_END, 170, 349,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 170, 349,
	FONT_END, 170, 67,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 170, 67,
	FONT_NEXT, 80, 45,
	FONT_END, 66, 25,
	FONT_BEGIN, 66, 25,
	FONT_NEXT, 170, 67,
	FONT_END, 16, 0,
	FONT_BEGIN, 66, 25,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 43, 16,
	FONT_END, 16, 15,
	FONT_BEGIN, 775, 15,
	FONT_NEXT, 775, 0,
	FONT_NEXT, 749, 17,
	FONT_NEXT, 556, 0,
	FONT_NEXT, 723, 26,
	FONT_END, 711, 40,
	FONT_BEGIN, 711, 40,
	FONT_NEXT, 556, 0,
	FONT_NEXT, 706, 76,
	FONT_NEXT, 607, 29,
	FONT_END, 618, 49,
	FONT_BEGIN, 556, 15,
	FONT_NEXT, 587, 19,
	FONT_NEXT, 556, 0,
	FONT_END, 607, 29,
	FONT_BEGIN, 510, 15,
	FONT_NEXT, 510, 0,
	FONT_NEXT, 481, 17,
	FONT_NEXT, 286, 0,
	FONT_NEXT, 458, 26,
	FONT_END, 443, 50,
	FONT_BEGIN, 443, 50,
	FONT_NEXT, 286, 0,
	FONT_END, 336, 27,
	FONT_BEGIN, 443, 50,
	FONT_NEXT, 336, 27,
	FONT_NEXT, 438, 95,
	FONT_END, 349, 47,
	FONT_BEGIN, 286, 15,
	FONT_NEXT, 315, 18,
	FONT_NEXT, 286, 0,
	FONT_END, 336, 27,
	FONT_BEGIN, 238, 15,
	FONT_NEXT, 238, 0,
	FONT_NEXT, 190, 23,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 175, 38,
	FONT_END, 170, 67,
	FONT_ADVANCE, 778, 0
    },
    {
	110,
	FONT_BEGIN, 161, 458,
	FONT_NEXT, 161, 379,
	FONT_NEXT, 154, 460,
	FONT_NEXT, 76, 53,
	FONT_END, 80, 90,
	FONT_BEGIN, 154, 460,
	FONT_NEXT, 80, 90,
	FONT_END, 80, 338,
	FONT_BEGIN, 154, 460,
	FONT_NEXT, 80, 338,
	FONT_END, 76, 374,
	FONT_BEGIN, 154, 460,
	FONT_NEXT, 76, 374,
	FONT_END, 68, 393,
	FONT_BEGIN, 154, 460,
	FONT_NEXT, 68, 393,
	FONT_NEXT, 16, 415,
	FONT_NEXT, 45, 402,
	FONT_END, 16, 398,
	FONT_BEGIN, 424, 310,
	FONT_NEXT, 424, 81,
	FONT_NEXT, 420, 351,
	FONT_NEXT, 335, 54,
	FONT_NEXT, 412, 385,
	FONT_END, 382, 431,
	FONT_BEGIN, 382, 431,
	FONT_NEXT, 335, 54,
	FONT_END, 340, 99,
	FONT_BEGIN, 382, 431,
	FONT_NEXT, 340, 99,
	FONT_NEXT, 344, 453,
	FONT_NEXT, 340, 308,
	FONT_END, 336, 348,
	FONT_BEGIN, 344, 453,
	FONT_NEXT, 336, 348,
	FONT_NEXT, 307, 460,
	FONT_NEXT, 323, 379,
	FONT_END, 299, 398,
	FONT_BEGIN, 307, 460,
	FONT_NEXT, 299, 398,
	FONT_NEXT, 266, 453,
	FONT_NEXT, 263, 405,
	FONT_NEXT, 230, 436,
	FONT_NEXT, 216, 390,
	FONT_NEXT, 161, 379,
	FONT_NEXT, 164, 348,
	FONT_END, 164, 67,
	FONT_BEGIN, 161, 379,
	FONT_NEXT, 164, 67,
	FONT_NEXT, 76, 53,
	FONT_END, 66, 31,
	FONT_BEGIN, 66, 31,
	FONT_NEXT, 164, 67,
	FONT_END, 18, 0,
	FONT_BEGIN, 66, 31,
	FONT_NEXT, 18, 0,
	FONT_NEXT, 47, 19,
	FONT_END, 18, 15,
	FONT_BEGIN, 485, 15,
	FONT_NEXT, 485, 0,
	FONT_NEXT, 454, 20,
	FONT_NEXT, 277, 0,
	FONT_NEXT, 436, 31,
	FONT_END, 426, 51,
	FONT_BEGIN, 426, 51,
	FONT_NEXT, 277, 0,
	FONT_NEXT, 424, 81,
	FONT_NEXT, 322, 29,
	FONT_END, 335, 54,
	FONT_BEGIN, 277, 15,
	FONT_NEXT, 302, 18,
	FONT_NEXT, 277, 0,
	FONT_END, 322, 29,
	FONT_BEGIN, 230, 15,
	FONT_NEXT, 230, 0,
	FONT_NEXT, 197, 19,
	FONT_NEXT, 18, 0,
	FONT_NEXT, 177, 29,
	FONT_END, 167, 45,
	FONT_BEGIN, 167, 45,
	FONT_NEXT, 18, 0,
	FONT_END, 164, 67,
	FONT_BEGIN, 167, 45,
	FONT_END, 164, 67,
	FONT_ADVANCE, 500, 0
    },
    {
	111,
	FONT_BEGIN, 470, 228,
	FONT_NEXT, 456, 149,
	FONT_NEXT, 465, 279,
	FONT_END, 453, 325,
	FONT_BEGIN, 453, 325,
	FONT_NEXT, 456, 149,
	FONT_END, 416, 71,
	FONT_BEGIN, 453, 325,
	FONT_NEXT, 416, 71,
	FONT_NEXT, 433, 365,
	FONT_END, 406, 398,
	FONT_BEGIN, 406, 398,
	FONT_NEXT, 416, 71,
	FONT_END, 385, 39,
	FONT_BEGIN, 406, 398,
	FONT_NEXT, 385, 39,
	FONT_NEXT, 373, 424,
	FONT_NEXT, 380, 199,
	FONT_END, 370, 287,
	FONT_BEGIN, 373, 424,
	FONT_NEXT, 370, 287,
	FONT_NEXT, 335, 444,
	FONT_NEXT, 343, 362,
	FONT_END, 322, 390,
	FONT_BEGIN, 335, 444,
	FONT_NEXT, 322, 390,
	FONT_NEXT, 292, 455,
	FONT_NEXT, 298, 413,
	FONT_END, 269, 427,
	FONT_BEGIN, 292, 455,
	FONT_NEXT, 269, 427,
	FONT_NEXT, 245, 460,
	FONT_NEXT, 237, 432,
	FONT_NEXT, 197, 455,
	FONT_NEXT, 191, 422,
	FONT_NEXT, 154, 441,
	FONT_NEXT, 154, 393,
	FONT_NEXT, 117, 419,
	FONT_NEXT, 128, 344,
	FONT_END, 119, 276,
	FONT_BEGIN, 117, 419,
	FONT_NEXT, 119, 276,
	FONT_END, 90, 58,
	FONT_BEGIN, 117, 419,
	FONT_NEXT, 90, 58,
	FONT_NEXT, 86, 390,
	FONT_NEXT, 64, 93,
	FONT_NEXT, 62, 355,
	FONT_NEXT, 45, 133,
	FONT_NEXT, 43, 316,
	FONT_NEXT, 33, 179,
	FONT_END, 29, 228,
	FONT_BEGIN, 90, 58,
	FONT_NEXT, 119, 276,
	FONT_NEXT, 122, 29,
	FONT_NEXT, 124, 204,
	FONT_END, 145, 119,
	FONT_BEGIN, 122, 29,
	FONT_NEXT, 145, 119,
	FONT_NEXT, 159, 8,
	FONT_NEXT, 164, 80,
	FONT_END, 189, 47,
	FONT_BEGIN, 159, 8,
	FONT_NEXT, 189, 47,
	FONT_NEXT, 201, -6,
	FONT_NEXT, 221, 26,
	FONT_NEXT, 248, -10,
	FONT_NEXT, 262, 18,
	FONT_NEXT, 301, -4,
	FONT_NEXT, 301, 26,
	FONT_END, 340, 54,
	FONT_BEGIN, 301, -4,
	FONT_NEXT, 340, 54,
	FONT_NEXT, 346, 13,
	FONT_NEXT, 356, 78,
	FONT_END, 368, 110,
	FONT_BEGIN, 346, 13,
	FONT_NEXT, 368, 110,
	FONT_NEXT, 385, 39,
	FONT_NEXT, 377, 150,
	FONT_END, 380, 199,
	FONT_ADVANCE, 500, 0
    },
    {
	112,
	FONT_BEGIN, 159, 458,
	FONT_NEXT, 159, 385,
	FONT_NEXT, 153, 460,
	FONT_NEXT, 159, 334,
	FONT_END, 159, 88,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 159, 88,
	FONT_END, 159, 33,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 159, 33,
	FONT_END, 159, -124,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 159, -124,
	FONT_END, 73, -160,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 73, -160,
	FONT_END, 75, -131,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 75, -131,
	FONT_END, 75, 337,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 75, 337,
	FONT_END, 73, 362,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 73, 362,
	FONT_END, 69, 380,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 69, 380,
	FONT_END, 57, 390,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 57, 390,
	FONT_NEXT, 9, 409,
	FONT_NEXT, 37, 394,
	FONT_END, 9, 393,
	FONT_BEGIN, 470, 245,
	FONT_NEXT, 456, 156,
	FONT_NEXT, 466, 292,
	FONT_END, 456, 334,
	FONT_BEGIN, 456, 334,
	FONT_NEXT, 456, 156,
	FONT_NEXT, 420, 402,
	FONT_NEXT, 417, 74,
	FONT_NEXT, 368, 445,
	FONT_NEXT, 384, 215,
	FONT_END, 383, 229,
	FONT_BEGIN, 368, 445,
	FONT_NEXT, 383, 229,
	FONT_END, 381, 253,
	FONT_BEGIN, 368, 445,
	FONT_NEXT, 381, 253,
	FONT_END, 366, 316,
	FONT_BEGIN, 368, 445,
	FONT_NEXT, 366, 316,
	FONT_NEXT, 305, 460,
	FONT_NEXT, 350, 347,
	FONT_END, 328, 374,
	FONT_BEGIN, 305, 460,
	FONT_NEXT, 328, 374,
	FONT_END, 297, 392,
	FONT_BEGIN, 305, 460,
	FONT_NEXT, 297, 392,
	FONT_NEXT, 252, 451,
	FONT_NEXT, 257, 400,
	FONT_END, 227, 395,
	FONT_BEGIN, 252, 451,
	FONT_NEXT, 227, 395,
	FONT_NEXT, 212, 432,
	FONT_NEXT, 196, 381,
	FONT_NEXT, 181, 406,
	FONT_NEXT, 171, 360,
	FONT_NEXT, 161, 383,
	FONT_NEXT, 159, 334,
	FONT_END, 159, 385,
	FONT_BEGIN, 159, 88,
	FONT_NEXT, 167, 67,
	FONT_NEXT, 159, 33,
	FONT_NEXT, 189, 46,
	FONT_NEXT, 206, -1,
	FONT_NEXT, 221, 29,
	FONT_NEXT, 260, -10,
	FONT_NEXT, 261, 22,
	FONT_END, 294, 27,
	FONT_BEGIN, 260, -10,
	FONT_NEXT, 294, 27,
	FONT_NEXT, 308, -4,
	FONT_NEXT, 334, 53,
	FONT_NEXT, 351, 13,
	FONT_NEXT, 353, 77,
	FONT_END, 369, 111,
	FONT_BEGIN, 351, 13,
	FONT_NEXT, 369, 111,
	FONT_END, 380, 156,
	FONT_BEGIN, 351, 13,
	FONT_NEXT, 380, 156,
	FONT_NEXT, 387, 40,
	FONT_NEXT, 384, 215,
	FONT_END, 417, 74,
	FONT_BEGIN, 5, -200,
	FONT_NEXT, 43, -194,
	FONT_NEXT, 5, -217,
	FONT_END, 159, -124,
	FONT_BEGIN, 159, -124,
	FONT_NEXT, 43, -194,
	FONT_END, 64, -180,
	FONT_BEGIN, 159, -124,
	FONT_NEXT, 64, -180,
	FONT_END, 73, -160,
	FONT_BEGIN, 247, -199,
	FONT_NEXT, 247, -217,
	FONT_NEXT, 202, -197,
	FONT_NEXT, 5, -217,
	FONT_NEXT, 176, -186,
	FONT_END, 162, -163,
	FONT_BEGIN, 162, -163,
	FONT_NEXT, 5, -217,
	FONT_END, 159, -124,
	FONT_BEGIN, 162, -163,
	FONT_END, 159, -124,
	FONT_ADVANCE, 500, 0
    },
    {
	113,
	FONT_BEGIN, 110, 238,
	FONT_NEXT, 117, 169,
	FONT_NEXT, 72, 44,
	FONT_END, 124, 3,
	FONT_BEGIN, 124, 3,
	FONT_NEXT, 117, 169,
	FONT_END, 140, 110,
	FONT_BEGIN, 124, 3,
	FONT_NEXT, 140, 110,
	FONT_END, 180, 67,
	FONT_BEGIN, 124, 3,
	FONT_NEXT, 180, 67,
	FONT_NEXT, 188, -10,
	FONT_NEXT, 206, 55,
	FONT_NEXT, 234, -3,
	FONT_NEXT, 238, 51,
	FONT_NEXT, 278, 14,
	FONT_NEXT, 288, 60,
	FONT_NEXT, 314, 38,
	FONT_NEXT, 318, 73,
	FONT_END, 333, 88,
	FONT_BEGIN, 314, 38,
	FONT_NEXT, 333, 88,
	FONT_NEXT, 336, 62,
	FONT_END, 341, 62,
	FONT_BEGIN, 341, 62,
	FONT_NEXT, 333, 88,
	FONT_END, 341, 127,
	FONT_BEGIN, 341, 62,
	FONT_NEXT, 341, 127,
	FONT_NEXT, 341, -124,
	FONT_NEXT, 341, 333,
	FONT_NEXT, 360, 425,
	FONT_NEXT, 339, 360,
	FONT_END, 328, 393,
	FONT_BEGIN, 360, 425,
	FONT_NEXT, 328, 393,
	FONT_NEXT, 308, 450,
	FONT_NEXT, 300, 420,
	FONT_NEXT, 247, 460,
	FONT_NEXT, 276, 428,
	FONT_END, 245, 432,
	FONT_BEGIN, 247, 460,
	FONT_NEXT, 245, 432,
	FONT_NEXT, 201, 455,
	FONT_NEXT, 189, 418,
	FONT_NEXT, 159, 440,
	FONT_NEXT, 147, 380,
	FONT_NEXT, 121, 417,
	FONT_NEXT, 119, 319,
	FONT_NEXT, 88, 387,
	FONT_NEXT, 110, 238,
	FONT_END, 72, 44,
	FONT_BEGIN, 88, 387,
	FONT_NEXT, 72, 44,
	FONT_NEXT, 61, 351,
	FONT_NEXT, 52, 75,
	FONT_NEXT, 41, 308,
	FONT_NEXT, 37, 113,
	FONT_NEXT, 28, 262,
	FONT_NEXT, 27, 159,
	FONT_END, 24, 212,
	FONT_BEGIN, 425, 456,
	FONT_NEXT, 425, -141,
	FONT_NEXT, 421, 460,
	FONT_NEXT, 337, -157,
	FONT_NEXT, 414, 457,
	FONT_NEXT, 341, -124,
	FONT_END, 360, 425,
	FONT_BEGIN, 252, -200,
	FONT_NEXT, 297, -194,
	FONT_NEXT, 252, -217,
	FONT_END, 425, -141,
	FONT_BEGIN, 425, -141,
	FONT_NEXT, 297, -194,
	FONT_END, 324, -180,
	FONT_BEGIN, 425, -141,
	FONT_NEXT, 324, -180,
	FONT_END, 337, -157,
	FONT_BEGIN, 488, -203,
	FONT_NEXT, 488, -217,
	FONT_NEXT, 459, -196,
	FONT_NEXT, 252, -217,
	FONT_NEXT, 439, -187,
	FONT_END, 428, -170,
	FONT_BEGIN, 428, -170,
	FONT_NEXT, 252, -217,
	FONT_END, 425, -141,
	FONT_BEGIN, 428, -170,
	FONT_END, 425, -141,
	FONT_ADVANCE, 500, 0
    },
    {
	114,
	FONT_BEGIN, 160, 458,
	FONT_NEXT, 160, 369,
	FONT_NEXT, 155, 460,
	FONT_NEXT, 160, 315,
	FONT_END, 160, 90,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 160, 90,
	FONT_END, 72, 51,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 72, 51,
	FONT_END, 76, 84,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 76, 84,
	FONT_END, 76, 334,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 76, 334,
	FONT_END, 72, 368,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 72, 368,
	FONT_END, 64, 386,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 64, 386,
	FONT_NEXT, 7, 406,
	FONT_NEXT, 41, 394,
	FONT_END, 7, 390,
	FONT_BEGIN, 335, 406,
	FONT_NEXT, 325, 374,
	FONT_NEXT, 331, 428,
	FONT_END, 320, 445,
	FONT_BEGIN, 320, 445,
	FONT_NEXT, 325, 374,
	FONT_END, 297, 362,
	FONT_BEGIN, 320, 445,
	FONT_NEXT, 297, 362,
	FONT_NEXT, 303, 456,
	FONT_END, 281, 460,
	FONT_BEGIN, 281, 460,
	FONT_NEXT, 297, 362,
	FONT_END, 274, 367,
	FONT_BEGIN, 281, 460,
	FONT_NEXT, 274, 367,
	FONT_NEXT, 252, 455,
	FONT_NEXT, 258, 379,
	FONT_END, 228, 397,
	FONT_BEGIN, 252, 455,
	FONT_NEXT, 228, 397,
	FONT_NEXT, 224, 441,
	FONT_NEXT, 207, 388,
	FONT_NEXT, 195, 413,
	FONT_NEXT, 185, 368,
	FONT_NEXT, 162, 369,
	FONT_NEXT, 167, 341,
	FONT_END, 160, 315,
	FONT_BEGIN, 162, 369,
	FONT_NEXT, 160, 315,
	FONT_END, 160, 369,
	FONT_BEGIN, 245, 15,
	FONT_NEXT, 245, 0,
	FONT_NEXT, 210, 17,
	FONT_NEXT, 5, 0,
	FONT_NEXT, 183, 27,
	FONT_END, 166, 49,
	FONT_BEGIN, 166, 49,
	FONT_NEXT, 5, 0,
	FONT_END, 61, 32,
	FONT_BEGIN, 166, 49,
	FONT_NEXT, 61, 32,
	FONT_NEXT, 160, 90,
	FONT_END, 72, 51,
	FONT_BEGIN, 5, 15,
	FONT_NEXT, 39, 22,
	FONT_NEXT, 5, 0,
	FONT_END, 61, 32,
	FONT_ADVANCE, 333, 0
    },
    {
	115,
	FONT_BEGIN, 51, 338,
	FONT_NEXT, 59, 380,
	FONT_NEXT, 60, 288,
	FONT_NEXT, 84, 420,
	FONT_NEXT, 86, 250,
	FONT_NEXT, 113, 372,
	FONT_END, 120, 337,
	FONT_BEGIN, 86, 250,
	FONT_NEXT, 120, 337,
	FONT_NEXT, 123, 219,
	FONT_NEXT, 133, 318,
	FONT_END, 156, 301,
	FONT_BEGIN, 123, 219,
	FONT_NEXT, 156, 301,
	FONT_NEXT, 168, 192,
	FONT_END, 226, 159,
	FONT_BEGIN, 226, 159,
	FONT_NEXT, 156, 301,
	FONT_NEXT, 264, 127,
	FONT_NEXT, 264, 237,
	FONT_NEXT, 278, 85,
	FONT_NEXT, 299, 21,
	FONT_NEXT, 270, 49,
	FONT_NEXT, 252, -3,
	FONT_NEXT, 250, 27,
	FONT_NEXT, 203, -10,
	FONT_NEXT, 224, 15,
	FONT_END, 197, 12,
	FONT_BEGIN, 197, 12,
	FONT_NEXT, 203, -10,
	FONT_END, 138, -1,
	FONT_BEGIN, 197, 12,
	FONT_NEXT, 138, -1,
	FONT_NEXT, 163, 15,
	FONT_END, 137, 26,
	FONT_BEGIN, 137, 26,
	FONT_NEXT, 138, -1,
	FONT_END, 87, 8,
	FONT_BEGIN, 137, 26,
	FONT_NEXT, 87, 8,
	FONT_NEXT, 100, 62,
	FONT_END, 79, 107,
	FONT_BEGIN, 79, 107,
	FONT_NEXT, 87, 8,
	FONT_END, 73, 5,
	FONT_BEGIN, 79, 107,
	FONT_NEXT, 73, 5,
	FONT_NEXT, 68, 152,
	FONT_NEXT, 65, -4,
	FONT_NEXT, 52, 152,
	FONT_END, 52, -4,
	FONT_BEGIN, 315, 314,
	FONT_NEXT, 300, 314,
	FONT_NEXT, 311, 451,
	FONT_END, 300, 451,
	FONT_BEGIN, 300, 451,
	FONT_NEXT, 300, 314,
	FONT_NEXT, 283, 440,
	FONT_NEXT, 279, 376,
	FONT_NEXT, 247, 450,
	FONT_NEXT, 252, 413,
	FONT_END, 221, 432,
	FONT_BEGIN, 247, 450,
	FONT_NEXT, 221, 432,
	FONT_NEXT, 191, 460,
	FONT_NEXT, 189, 437,
	FONT_NEXT, 128, 448,
	FONT_NEXT, 153, 430,
	FONT_END, 130, 414,
	FONT_BEGIN, 128, 448,
	FONT_NEXT, 130, 414,
	FONT_END, 117, 393,
	FONT_BEGIN, 128, 448,
	FONT_NEXT, 117, 393,
	FONT_NEXT, 84, 420,
	FONT_END, 113, 372,
	FONT_BEGIN, 348, 119,
	FONT_NEXT, 334, 62,
	FONT_NEXT, 341, 158,
	FONT_END, 324, 189,
	FONT_BEGIN, 324, 189,
	FONT_NEXT, 334, 62,
	FONT_END, 299, 21,
	FONT_BEGIN, 324, 189,
	FONT_NEXT, 299, 21,
	FONT_END, 264, 237,
	FONT_ADVANCE, 389, 0
    },
    {
	116,
	FONT_BEGIN, 13, 425,
	FONT_NEXT, 26, 441,
	FONT_NEXT, 17, 418,
	FONT_NEXT, 57, 465,
	FONT_NEXT, 70, 418,
	FONT_NEXT, 102, 516,
	FONT_END, 96, 16,
	FONT_BEGIN, 70, 418,
	FONT_NEXT, 96, 16,
	FONT_END, 77, 54,
	FONT_BEGIN, 70, 418,
	FONT_NEXT, 77, 54,
	FONT_END, 70, 117,
	FONT_BEGIN, 154, 566,
	FONT_NEXT, 154, 450,
	FONT_NEXT, 147, 579,
	FONT_NEXT, 154, 418,
	FONT_END, 154, 132,
	FONT_BEGIN, 147, 579,
	FONT_NEXT, 154, 132,
	FONT_END, 126, -5,
	FONT_BEGIN, 147, 579,
	FONT_NEXT, 126, -5,
	FONT_NEXT, 122, 544,
	FONT_NEXT, 96, 16,
	FONT_END, 102, 516,
	FONT_BEGIN, 255, 450,
	FONT_NEXT, 255, 418,
	FONT_NEXT, 154, 450,
	FONT_END, 154, 418,
	FONT_BEGIN, 279, 66,
	FONT_NEXT, 257, 35,
	FONT_NEXT, 266, 77,
	FONT_END, 243, 54,
	FONT_BEGIN, 243, 54,
	FONT_NEXT, 257, 35,
	FONT_END, 228, 11,
	FONT_BEGIN, 243, 54,
	FONT_NEXT, 228, 11,
	FONT_NEXT, 205, 42,
	FONT_NEXT, 196, -5,
	FONT_NEXT, 175, 51,
	FONT_NEXT, 162, -10,
	FONT_NEXT, 160, 75,
	FONT_NEXT, 126, -5,
	FONT_END, 154, 132,
	FONT_ADVANCE, 278, 0
    },
    {
	117,
	FONT_BEGIN, 9, 436,
	FONT_NEXT, 9, 450,
	FONT_NEXT, 51, 425,
	FONT_NEXT, 155, 450,
	FONT_NEXT, 65, 407,
	FONT_NEXT, 155, 124,
	FONT_END, 154, -5,
	FONT_BEGIN, 65, 407,
	FONT_NEXT, 154, -5,
	FONT_NEXT, 71, 372,
	FONT_NEXT, 115, 15,
	FONT_END, 83, 54,
	FONT_BEGIN, 71, 372,
	FONT_NEXT, 83, 54,
	FONT_END, 74, 83,
	FONT_BEGIN, 71, 372,
	FONT_NEXT, 74, 83,
	FONT_END, 71, 120,
	FONT_BEGIN, 338, -7,
	FONT_NEXT, 338, 76,
	FONT_NEXT, 340, -9,
	FONT_END, 333, 370,
	FONT_BEGIN, 333, 370,
	FONT_NEXT, 338, 76,
	FONT_NEXT, 333, 135,
	FONT_END, 328, 100,
	FONT_BEGIN, 328, 100,
	FONT_NEXT, 338, 76,
	FONT_END, 295, 33,
	FONT_BEGIN, 328, 100,
	FONT_NEXT, 295, 33,
	FONT_NEXT, 317, 84,
	FONT_END, 274, 57,
	FONT_BEGIN, 274, 57,
	FONT_NEXT, 295, 33,
	FONT_END, 264, 9,
	FONT_BEGIN, 274, 57,
	FONT_NEXT, 264, 9,
	FONT_NEXT, 230, 48,
	FONT_NEXT, 234, -4,
	FONT_END, 208, -9,
	FONT_BEGIN, 230, 48,
	FONT_NEXT, 208, -9,
	FONT_NEXT, 190, 57,
	FONT_NEXT, 190, -10,
	FONT_NEXT, 167, 80,
	FONT_NEXT, 154, -5,
	FONT_NEXT, 157, 106,
	FONT_END, 155, 124,
	FONT_BEGIN, 479, 50,
	FONT_NEXT, 479, 36,
	FONT_NEXT, 444, 53,
	FONT_NEXT, 340, -9,
	FONT_NEXT, 425, 64,
	FONT_END, 418, 82,
	FONT_BEGIN, 418, 82,
	FONT_NEXT, 340, -9,
	FONT_NEXT, 417, 107,
	FONT_NEXT, 333, 370,
	FONT_END, 331, 396,
	FONT_BEGIN, 417, 107,
	FONT_NEXT, 331, 396,
	FONT_NEXT, 417, 450,
	FONT_NEXT, 322, 415,
	FONT_NEXT, 259, 450,
	FONT_NEXT, 300, 427,
	FONT_END, 259, 433,
	FONT_ADVANCE, 500, 0
    },
    {
	118,
	FONT_BEGIN, 215, 450,
	FONT_NEXT, 215, 435,
	FONT_NEXT, 19, 450,
	FONT_NEXT, 183, 428,
	FONT_END, 172, 419,
	FONT_BEGIN, 19, 450,
	FONT_NEXT, 172, 419,
	FONT_END, 169, 405,
	FONT_BEGIN, 19, 450,
	FONT_NEXT, 169, 405,
	FONT_END, 48, 427,
	FONT_BEGIN, 19, 450,
	FONT_NEXT, 48, 427,
	FONT_END, 19, 435,
	FONT_BEGIN, 338, 435,
	FONT_NEXT, 338, 450,
	FONT_NEXT, 370, 426,
	FONT_NEXT, 427, 393,
	FONT_NEXT, 385, 402,
	FONT_NEXT, 412, 357,
	FONT_NEXT, 381, 383,
	FONT_NEXT, 284, 36,
	FONT_NEXT, 373, 355,
	FONT_END, 345, 280,
	FONT_BEGIN, 345, 280,
	FONT_NEXT, 284, 36,
	FONT_NEXT, 280, 114,
	FONT_NEXT, 269, 0,
	FONT_NEXT, 178, 370,
	FONT_NEXT, 257, -14,
	FONT_END, 246, -7,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 246, -7,
	FONT_END, 239, 7,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 239, 7,
	FONT_END, 230, 33,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 230, 33,
	FONT_END, 217, 63,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 217, 63,
	FONT_END, 200, 106,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 200, 106,
	FONT_END, 156, 212,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 156, 212,
	FONT_NEXT, 169, 405,
	FONT_NEXT, 110, 319,
	FONT_END, 90, 364,
	FONT_BEGIN, 169, 405,
	FONT_NEXT, 90, 364,
	FONT_END, 74, 398,
	FONT_BEGIN, 169, 405,
	FONT_NEXT, 74, 398,
	FONT_END, 48, 427,
	FONT_BEGIN, 477, 450,
	FONT_NEXT, 477, 435,
	FONT_NEXT, 338, 450,
	FONT_NEXT, 455, 429,
	FONT_END, 440, 417,
	FONT_BEGIN, 338, 450,
	FONT_NEXT, 440, 417,
	FONT_END, 427, 393,
	FONT_ADVANCE, 500, 0
    },
    {
	119,
	FONT_BEGIN, 201, 450,
	FONT_NEXT, 201, 435,
	FONT_NEXT, 21, 450,
	FONT_NEXT, 169, 427,
	FONT_END, 158, 417,
	FONT_BEGIN, 21, 450,
	FONT_NEXT, 158, 417,
	FONT_END, 155, 401,
	FONT_BEGIN, 21, 450,
	FONT_NEXT, 155, 401,
	FONT_END, 49, 420,
	FONT_BEGIN, 21, 450,
	FONT_NEXT, 49, 420,
	FONT_END, 21, 435,
	FONT_BEGIN, 262, 435,
	FONT_NEXT, 262, 450,
	FONT_NEXT, 288, 429,
	FONT_END, 308, 413,
	FONT_BEGIN, 308, 413,
	FONT_NEXT, 262, 450,
	FONT_END, 407, 398,
	FONT_BEGIN, 308, 413,
	FONT_NEXT, 407, 398,
	FONT_NEXT, 327, 376,
	FONT_NEXT, 372, 265,
	FONT_NEXT, 338, 347,
	FONT_END, 351, 310,
	FONT_BEGIN, 351, 310,
	FONT_NEXT, 372, 265,
	FONT_END, 260, 25,
	FONT_BEGIN, 351, 310,
	FONT_NEXT, 260, 25,
	FONT_NEXT, 260, 111,
	FONT_END, 224, 205,
	FONT_BEGIN, 224, 205,
	FONT_NEXT, 260, 25,
	FONT_END, 244, -5,
	FONT_BEGIN, 224, 205,
	FONT_NEXT, 244, -5,
	FONT_END, 235, -14,
	FONT_BEGIN, 224, 205,
	FONT_NEXT, 235, -14,
	FONT_END, 224, -5,
	FONT_BEGIN, 224, 205,
	FONT_NEXT, 224, -5,
	FONT_NEXT, 190, 290,
	FONT_NEXT, 217, 8,
	FONT_END, 209, 30,
	FONT_BEGIN, 190, 290,
	FONT_NEXT, 209, 30,
	FONT_END, 74, 372,
	FONT_BEGIN, 190, 290,
	FONT_NEXT, 74, 372,
	FONT_NEXT, 164, 358,
	FONT_END, 157, 383,
	FONT_BEGIN, 157, 383,
	FONT_NEXT, 74, 372,
	FONT_NEXT, 155, 401,
	FONT_NEXT, 60, 401,
	FONT_END, 49, 420,
	FONT_BEGIN, 465, 450,
	FONT_NEXT, 465, 435,
	FONT_NEXT, 262, 450,
	FONT_NEXT, 423, 425,
	FONT_END, 411, 415,
	FONT_BEGIN, 262, 450,
	FONT_NEXT, 411, 415,
	FONT_END, 407, 398,
	FONT_BEGIN, 571, 435,
	FONT_NEXT, 571, 450,
	FONT_NEXT, 602, 425,
	FONT_NEXT, 671, 419,
	FONT_END, 653, 381,
	FONT_BEGIN, 602, 425,
	FONT_NEXT, 653, 381,
	FONT_NEXT, 611, 416,
	FONT_END, 615, 402,
	FONT_BEGIN, 615, 402,
	FONT_NEXT, 653, 381,
	FONT_NEXT, 610, 374,
	FONT_NEXT, 515, 35,
	FONT_NEXT, 598, 338,
	FONT_END, 508, 116,
	FONT_BEGIN, 508, 116,
	FONT_NEXT, 515, 35,
	FONT_END, 505, 10,
	FONT_BEGIN, 508, 116,
	FONT_NEXT, 505, 10,
	FONT_NEXT, 428, 330,
	FONT_NEXT, 498, -5,
	FONT_END, 487, -14,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 487, -14,
	FONT_END, 477, -6,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 477, -6,
	FONT_END, 471, 7,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 471, 7,
	FONT_END, 463, 29,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 463, 29,
	FONT_END, 372, 265,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 372, 265,
	FONT_NEXT, 411, 371,
	FONT_END, 407, 398,
	FONT_BEGIN, 694, 450,
	FONT_NEXT, 694, 435,
	FONT_NEXT, 571, 450,
	FONT_END, 671, 419,
	FONT_ADVANCE, 722, 0
    },
    {
	120,
	FONT_BEGIN, 24, 435,
	FONT_NEXT, 24, 450,
	FONT_NEXT, 64, 428,
	FONT_NEXT, 188, 412,
	FONT_NEXT, 83, 410,
	FONT_END, 110, 375,
	FONT_BEGIN, 110, 375,
	FONT_NEXT, 188, 412,
	FONT_END, 194, 391,
	FONT_BEGIN, 110, 375,
	FONT_NEXT, 194, 391,
	FONT_NEXT, 204, 231,
	FONT_NEXT, 210, 362,
	FONT_END, 221, 197,
	FONT_BEGIN, 204, 231,
	FONT_NEXT, 221, 197,
	FONT_END, 142, 74,
	FONT_BEGIN, 204, 231,
	FONT_NEXT, 142, 74,
	FONT_NEXT, 90, 66,
	FONT_NEXT, 122, 33,
	FONT_NEXT, 68, 39,
	FONT_END, 51, 24,
	FONT_BEGIN, 51, 24,
	FONT_NEXT, 122, 33,
	FONT_END, 17, 0,
	FONT_BEGIN, 51, 24,
	FONT_NEXT, 17, 0,
	FONT_END, 17, 15,
	FONT_BEGIN, 231, 450,
	FONT_NEXT, 231, 435,
	FONT_NEXT, 24, 450,
	FONT_NEXT, 202, 431,
	FONT_END, 192, 424,
	FONT_BEGIN, 24, 450,
	FONT_NEXT, 192, 424,
	FONT_END, 188, 412,
	FONT_BEGIN, 275, 435,
	FONT_NEXT, 275, 450,
	FONT_NEXT, 301, 431,
	FONT_END, 311, 424,
	FONT_BEGIN, 311, 424,
	FONT_NEXT, 275, 450,
	FONT_END, 379, 417,
	FONT_BEGIN, 311, 424,
	FONT_NEXT, 379, 417,
	FONT_END, 352, 391,
	FONT_BEGIN, 311, 424,
	FONT_NEXT, 352, 391,
	FONT_NEXT, 315, 412,
	FONT_END, 313, 402,
	FONT_BEGIN, 313, 402,
	FONT_NEXT, 352, 391,
	FONT_END, 269, 271,
	FONT_BEGIN, 313, 402,
	FONT_NEXT, 269, 271,
	FONT_NEXT, 304, 386,
	FONT_END, 284, 356,
	FONT_BEGIN, 284, 356,
	FONT_NEXT, 269, 271,
	FONT_NEXT, 248, 304,
	FONT_NEXT, 221, 197,
	FONT_END, 210, 362,
	FONT_BEGIN, 433, 450,
	FONT_NEXT, 433, 435,
	FONT_NEXT, 275, 450,
	FONT_NEXT, 403, 429,
	FONT_END, 379, 417,
	FONT_BEGIN, 278, 15,
	FONT_NEXT, 309, 20,
	FONT_NEXT, 278, 0,
	FONT_END, 397, 75,
	FONT_BEGIN, 397, 75,
	FONT_NEXT, 309, 20,
	FONT_END, 318, 41,
	FONT_BEGIN, 397, 75,
	FONT_NEXT, 318, 41,
	FONT_NEXT, 269, 271,
	FONT_NEXT, 311, 60,
	FONT_END, 302, 73,
	FONT_BEGIN, 269, 271,
	FONT_NEXT, 302, 73,
	FONT_END, 221, 197,
	FONT_BEGIN, 479, 15,
	FONT_NEXT, 479, 0,
	FONT_NEXT, 445, 23,
	FONT_NEXT, 278, 0,
	FONT_NEXT, 423, 41,
	FONT_END, 397, 75,
	FONT_BEGIN, 162, 15,
	FONT_NEXT, 162, 0,
	FONT_NEXT, 136, 17,
	FONT_NEXT, 17, 0,
	FONT_END, 122, 33,
	FONT_ADVANCE, 500, 0
    },
    {
	121,
	FONT_BEGIN, 220, 450,
	FONT_NEXT, 220, 435,
	FONT_NEXT, 14, 450,
	FONT_NEXT, 182, 430,
	FONT_END, 167, 421,
	FONT_BEGIN, 14, 450,
	FONT_NEXT, 167, 421,
	FONT_END, 162, 406,
	FONT_BEGIN, 14, 450,
	FONT_NEXT, 162, 406,
	FONT_END, 39, 428,
	FONT_BEGIN, 14, 450,
	FONT_NEXT, 39, 428,
	FONT_END, 14, 436,
	FONT_BEGIN, 340, 435,
	FONT_NEXT, 340, 450,
	FONT_NEXT, 376, 428,
	FONT_NEXT, 439, 414,
	FONT_END, 427, 390,
	FONT_BEGIN, 376, 428,
	FONT_NEXT, 427, 390,
	FONT_NEXT, 388, 407,
	FONT_NEXT, 273, -18,
	FONT_NEXT, 380, 379,
	FONT_END, 365, 339,
	FONT_BEGIN, 365, 339,
	FONT_NEXT, 273, -18,
	FONT_NEXT, 287, 117,
	FONT_END, 172, 370,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 273, -18,
	FONT_END, 241, 20,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 241, 20,
	FONT_END, 233, 43,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 233, 43,
	FONT_END, 215, 83,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 215, 83,
	FONT_END, 194, 125,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 194, 125,
	FONT_END, 179, 158,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 179, 158,
	FONT_END, 65, 404,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 65, 404,
	FONT_NEXT, 162, 406,
	FONT_END, 39, 428,
	FONT_BEGIN, 475, 450,
	FONT_NEXT, 475, 435,
	FONT_NEXT, 340, 450,
	FONT_NEXT, 451, 427,
	FONT_END, 439, 414,
	FONT_BEGIN, 30, -160,
	FONT_NEXT, 36, -136,
	FONT_NEXT, 34, -181,
	FONT_END, 47, -199,
	FONT_BEGIN, 47, -199,
	FONT_NEXT, 36, -136,
	FONT_END, 51, -123,
	FONT_BEGIN, 47, -199,
	FONT_NEXT, 51, -123,
	FONT_NEXT, 70, -213,
	FONT_NEXT, 78, -116,
	FONT_NEXT, 103, -218,
	FONT_NEXT, 118, -125,
	FONT_END, 149, -134,
	FONT_BEGIN, 103, -218,
	FONT_NEXT, 149, -134,
	FONT_NEXT, 154, -206,
	FONT_NEXT, 167, -129,
	FONT_END, 185, -113,
	FONT_BEGIN, 154, -206,
	FONT_NEXT, 185, -113,
	FONT_NEXT, 197, -169,
	FONT_NEXT, 214, -63,
	FONT_END, 233, -11,
	FONT_BEGIN, 197, -169,
	FONT_NEXT, 233, -11,
	FONT_NEXT, 235, -106,
	FONT_NEXT, 239, 8,
	FONT_END, 241, 20,
	FONT_BEGIN, 235, -106,
	FONT_NEXT, 241, 20,
	FONT_END, 273, -18,
	FONT_ADVANCE, 500, 0
    },
    {
	122,
	FONT_BEGIN, 403, 450,
	FONT_NEXT, 403, 435,
	FONT_NEXT, 56, 450,
	FONT_NEXT, 293, 420,
	FONT_END, 155, 420,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 155, 420,
	FONT_END, 112, 413,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 112, 413,
	FONT_END, 88, 396,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 88, 396,
	FONT_END, 76, 368,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 76, 368,
	FONT_END, 71, 332,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 71, 332,
	FONT_END, 53, 332,
	FONT_BEGIN, 418, 135,
	FONT_NEXT, 404, 0,
	FONT_NEXT, 400, 139,
	FONT_END, 388, 89,
	FONT_BEGIN, 388, 89,
	FONT_NEXT, 404, 0,
	FONT_NEXT, 369, 55,
	FONT_END, 334, 36,
	FONT_BEGIN, 334, 36,
	FONT_NEXT, 404, 0,
	FONT_NEXT, 307, 31,
	FONT_NEXT, 27, 0,
	FONT_NEXT, 272, 30,
	FONT_END, 134, 30,
	FONT_BEGIN, 134, 30,
	FONT_NEXT, 27, 0,
	FONT_END, 27, 15,
	FONT_BEGIN, 134, 30,
	FONT_NEXT, 27, 15,
	FONT_END, 293, 420,
	FONT_BEGIN, 134, 30,
	FONT_NEXT, 293, 420,
	FONT_END, 403, 435,
	FONT_ADVANCE, 444, 0
    },
    {
	123,
	FONT_BEGIN, 100, 250,
	FONT_NEXT, 142, 266,
	FONT_NEXT, 142, 233,
	FONT_END, 168, 209,
	FONT_BEGIN, 168, 209,
	FONT_NEXT, 142, 266,
	FONT_END, 168, 248,
	FONT_BEGIN, 168, 209,
	FONT_NEXT, 168, 248,
	FONT_NEXT, 181, 178,
	FONT_NEXT, 215, 230,
	FONT_NEXT, 185, 136,
	FONT_NEXT, 210, -139,
	FONT_END, 196, -114,
	FONT_BEGIN, 185, 136,
	FONT_NEXT, 196, -114,
	FONT_END, 187, -82,
	FONT_BEGIN, 185, 136,
	FONT_NEXT, 187, -82,
	FONT_END, 185, -41,
	FONT_BEGIN, 185, 541,
	FONT_NEXT, 187, 581,
	FONT_NEXT, 185, 363,
	FONT_NEXT, 196, 612,
	FONT_END, 210, 637,
	FONT_BEGIN, 185, 363,
	FONT_NEXT, 210, 637,
	FONT_END, 215, 267,
	FONT_BEGIN, 185, 363,
	FONT_NEXT, 215, 267,
	FONT_NEXT, 181, 320,
	FONT_NEXT, 168, 250,
	FONT_NEXT, 168, 289,
	FONT_END, 142, 266,
	FONT_BEGIN, 142, 266,
	FONT_NEXT, 168, 250,
	FONT_END, 168, 248,
	FONT_BEGIN, 142, 266,
	FONT_END, 168, 248,
	FONT_BEGIN, 350, 680,
	FONT_NEXT, 350, 669,
	FONT_NEXT, 280, 675,
	FONT_NEXT, 305, 652,
	FONT_END, 277, 627,
	FONT_BEGIN, 280, 675,
	FONT_NEXT, 277, 627,
	FONT_NEXT, 228, 655,
	FONT_NEXT, 263, 592,
	FONT_END, 259, 546,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 259, 546,
	FONT_END, 259, 378,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 259, 378,
	FONT_END, 255, 330,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 255, 330,
	FONT_END, 242, 294,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 242, 294,
	FONT_END, 215, 267,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 215, 267,
	FONT_END, 210, 637,
	FONT_BEGIN, 259, 121,
	FONT_NEXT, 259, -47,
	FONT_NEXT, 255, 168,
	FONT_NEXT, 228, -156,
	FONT_NEXT, 242, 204,
	FONT_END, 215, 230,
	FONT_BEGIN, 215, 230,
	FONT_NEXT, 228, -156,
	FONT_END, 210, -139,
	FONT_BEGIN, 215, 230,
	FONT_END, 210, -139,
	FONT_BEGIN, 350, -170,
	FONT_NEXT, 350, -181,
	FONT_NEXT, 305, -154,
	FONT_NEXT, 280, -176,
	FONT_NEXT, 277, -129,
	FONT_NEXT, 228, -156,
	FONT_NEXT, 263, -94,
	FONT_END, 259, -47,
	FONT_ADVANCE, 480, 0
    },
    {
	124,
	FONT_BEGIN, 133, 676,
	FONT_NEXT, 133, -14,
	FONT_NEXT, 67, 676,
	FONT_END, 67, -14,
	FONT_ADVANCE, 200, 0
    },
    {
	125,
	FONT_BEGIN, 130, 669,
	FONT_NEXT, 130, 680,
	FONT_NEXT, 174, 652,
	FONT_NEXT, 199, 675,
	FONT_NEXT, 202, 627,
	FONT_END, 216, 592,
	FONT_BEGIN, 216, 592,
	FONT_NEXT, 199, 675,
	FONT_END, 251, 655,
	FONT_BEGIN, 216, 592,
	FONT_NEXT, 251, 655,
	FONT_NEXT, 221, 546,
	FONT_NEXT, 237, 294,
	FONT_END, 224, 330,
	FONT_BEGIN, 221, 546,
	FONT_NEXT, 224, 330,
	FONT_END, 221, 378,
	FONT_BEGIN, 295, 540,
	FONT_NEXT, 295, 363,
	FONT_NEXT, 292, 580,
	FONT_NEXT, 264, 268,
	FONT_NEXT, 283, 612,
	FONT_END, 269, 637,
	FONT_BEGIN, 269, 637,
	FONT_NEXT, 264, 268,
	FONT_NEXT, 251, 655,
	FONT_END, 237, 294,
	FONT_BEGIN, 380, 250,
	FONT_NEXT, 337, 233,
	FONT_NEXT, 337, 266,
	FONT_END, 311, 289,
	FONT_BEGIN, 311, 289,
	FONT_NEXT, 337, 233,
	FONT_END, 312, 251,
	FONT_BEGIN, 311, 289,
	FONT_NEXT, 312, 251,
	FONT_END, 264, 268,
	FONT_BEGIN, 311, 289,
	FONT_NEXT, 264, 268,
	FONT_NEXT, 298, 320,
	FONT_END, 295, 363,
	FONT_BEGIN, 221, 121,
	FONT_NEXT, 224, 168,
	FONT_NEXT, 221, -47,
	FONT_NEXT, 237, 204,
	FONT_NEXT, 251, -157,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 269, -139,
	FONT_END, 283, -114,
	FONT_BEGIN, 283, -114,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 292, -83,
	FONT_END, 295, -42,
	FONT_BEGIN, 295, -42,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 295, 136,
	FONT_END, 298, 178,
	FONT_BEGIN, 298, 178,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 311, 209,
	FONT_NEXT, 312, 249,
	FONT_NEXT, 337, 233,
	FONT_END, 312, 251,
	FONT_BEGIN, 130, -170,
	FONT_NEXT, 174, -154,
	FONT_NEXT, 130, -181,
	FONT_END, 199, -177,
	FONT_BEGIN, 199, -177,
	FONT_NEXT, 174, -154,
	FONT_END, 202, -129,
	FONT_BEGIN, 199, -177,
	FONT_NEXT, 202, -129,
	FONT_END, 216, -94,
	FONT_BEGIN, 199, -177,
	FONT_NEXT, 216, -94,
	FONT_NEXT, 251, -157,
	FONT_END, 221, -47,
	FONT_ADVANCE, 480, 0
    },
    {
	126,
	FONT_BEGIN, 502, 273,
	FONT_NEXT, 451, 214,
	FONT_NEXT, 466, 323,
	FONT_END, 428, 273,
	FONT_BEGIN, 428, 273,
	FONT_NEXT, 451, 214,
	FONT_END, 418, 194,
	FONT_BEGIN, 428, 273,
	FONT_NEXT, 418, 194,
	FONT_NEXT, 405, 257,
	FONT_NEXT, 377, 187,
	FONT_NEXT, 378, 251,
	FONT_END, 330, 263,
	FONT_BEGIN, 330, 263,
	FONT_NEXT, 377, 187,
	FONT_END, 324, 196,
	FONT_BEGIN, 330, 263,
	FONT_NEXT, 324, 196,
	FONT_NEXT, 276, 287,
	FONT_NEXT, 275, 220,
	FONT_NEXT, 219, 309,
	FONT_NEXT, 222, 244,
	FONT_END, 160, 255,
	FONT_BEGIN, 219, 309,
	FONT_NEXT, 160, 255,
	FONT_NEXT, 165, 319,
	FONT_END, 120, 311,
	FONT_BEGIN, 120, 311,
	FONT_NEXT, 160, 255,
	FONT_END, 130, 248,
	FONT_BEGIN, 120, 311,
	FONT_NEXT, 130, 248,
	FONT_END, 107, 232,
	FONT_BEGIN, 120, 311,
	FONT_NEXT, 107, 232,
	FONT_NEXT, 85, 291,
	FONT_NEXT, 76, 183,
	FONT_END, 40, 233,
	FONT_ADVANCE, 541, 0
    },
    {
	END_OF_LIST
    }
};

// Character 0 may not be defined for the bitmap font because it is used as
// BITMAP_END_OF_LIST.  We could use END_OF_LIST (which is 256), but that
// gets truncated to zero anyway, so lets be clean and use BITMAP_END_OF_LIST.

GLubyte bitmapFont[][1+13] = {
    {
	32,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	33,
	0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18
    }, 
    {
	34,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x36, 0x36, 0x36, 0x36
    }, 
    {
	35,
	0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66,
	0x66, 0xff, 0x66, 0x66, 0x00, 0x00
    }, 
    {
	36,
	0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f,
	0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18
    }, 
    {
	37,
	0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30,
	0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70
    }, 
    {
	38,
	0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70,
	0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38
    }, 
    {
	39,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e
    }, 
    {
	40,
	0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x30, 0x18, 0x0c
    }, 
    {
	41,
	0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c,
	0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30
    }, 
    {
	42,
	0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c,
	0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00
    }, 
    {
	43,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff,
	0xff, 0x18, 0x18, 0x18, 0x00, 0x00
    }, 
    {
	44,
	0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	45,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	46,
	0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	47,
	0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18,
	0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03
    }, 
    {
	48,
	0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3,
	0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c
    }, 
    {
	49,
	0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x78, 0x38, 0x18
    }, 
    {
	50,
	0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30,
	0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e
    }, 
    {
	51,
	0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07,
	0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e
    }, 
    {
	52,
	0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c
    }, 
    {
	53,
	0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07,
	0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff
    }, 
    {
	54,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7,
	0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e
    }, 
    {
	55,
	0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18,
	0x0c, 0x06, 0x03, 0x03, 0x03, 0xff
    }, 
    {
	56,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7,
	0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e
    }, 
    {
	57,
	0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03,
	0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e
    }, 
    {
	58,
	0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00,
	0x38, 0x38, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	59,
	0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00,
	0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00
    }, 
    {
	60,
	0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60,
	0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06
    }, 
    {
	61,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	62,
	0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06,
	0x03, 0x06, 0x0c, 0x18, 0x30, 0x60
    }, 
    {
	63,
	0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18,
	0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e
    }, 
    {
	64,
	0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3,
	0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00
    }, 
    {
	65,
	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff,
	0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18
    }, 
    {
	66,
	0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7,
	0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe
    }, 
    {
	67,
	0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0,
	0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e
    }, 
    {
	68,
	0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3,
	0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc
    }, 
    {
	69,
	0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0,
	0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff
    }, 
    {
	70,
	0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
	0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff
    }, 
    {
	71,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf,
	0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e
    }, 
    {
	72,
	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
	0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3
    }, 
    {
	73,
	0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x7e
    }, 
    {
	74,
	0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06
    }, 
    {
	75,
	0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0,
	0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3
    }, 
    {
	76,
	0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0,
	0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0
    }, 
    {
	77,
	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
	0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3
    }, 
    {
	78,
	0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf,
	0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3
    }, 
    {
	79,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3,
	0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e
    }, 
    {
	80,
	0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
	0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe
    }, 
    {
	81,
	0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3,
	0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c
    }, 
    {
	82,
	0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0,
	0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe
    }, 
    {
	83,
	0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07,
	0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e
    }, 
    {
	84,
	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xff
    }, 
    {
	85,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3,
	0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3
    }, 
    {
	86,
	0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66,
	0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3
    }, 
    {
	87,
	0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb,
	0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3
    }, 
    {
	88,
	0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c,
	0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3
    }, 
    {
	89,
	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3
    }, 
    {
	90,
	0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30,
	0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff
    }, 
    {
	91,
	0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x30, 0x30, 0x3c
    }, 
    {
	92,
	0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c,
	0x18, 0x18, 0x30, 0x30, 0x60, 0x60
    }, 
    {
	93,
	0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c,
	0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c
    }, 
    {
	94,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18
    }, 
    {
	95,
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	96,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x38, 0x30, 0x70
    }, 
    {
	97,
	0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03,
	0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	98,
	0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3,
	0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0
    }, 
    {
	99,
	0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0,
	0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	100,
	0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3,
	0x7f, 0x03, 0x03, 0x03, 0x03, 0x03
    }, 
    {
	101,
	0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3,
	0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	102,
	0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
	0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e
    }, 
    {
	103,
	0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3,
	0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	104,
	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
	0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0
    }, 
    {
	105,
	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x00, 0x00, 0x18, 0x00
    }, 
    {
	106,
	0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00
    }, 
    {
	107,
	0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8,
	0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0
    }, 
    {
	108,
	0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x78
    }, 
    {
	109,
	0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb,
	0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	110,
	0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6,
	0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	111,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6,
	0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	112,
	0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3,
	0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	113,
	0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3,
	0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	114,
	0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
	0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	115,
	0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0,
	0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	116,
	0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30,
	0x30, 0xfc, 0x30, 0x30, 0x30, 0x00
    }, 
    {
	117,
	0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6,
	0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	118,
	0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66,
	0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	119,
	0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3,
	0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	120,
	0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c,
	0x66, 0xc3, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	121,
	0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66,
	0x66, 0xc3, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	122,
	0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c,
	0x06, 0xff, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	123,
	0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38,
	0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f
    }, 
    {
	124,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18
    }, 
    {
	125,
	0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c,
	0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0
    }, 
    {
	126,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
	0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00
    },
    {
        BITMAP_END_OF_LIST
    }
};


GLenum tkCreateStrokeFont(GLuint fontBase)
{
    GLint mode, i, j;

    for (i = 0; strokeFont[i][0] != END_OF_LIST; i++) {
	glNewList(fontBase+(unsigned int)strokeFont[i][0], GL_COMPILE);
	for (j = 1; mode = strokeFont[i][j]; j += 3) {
	    if (mode == FONT_BEGIN) {
		glBegin(GL_LINE_STRIP);
		glVertex2f((float)strokeFont[i][j+1]*STROKE_SCALE,
			   (float)strokeFont[i][j+2]*STROKE_SCALE);
	    } else if (mode == FONT_NEXT) {
		glVertex2f((float)strokeFont[i][j+1]*STROKE_SCALE,
			   (float)strokeFont[i][j+2]*STROKE_SCALE);
	    } else if (mode == FONT_END) {
		glVertex2f((float)strokeFont[i][j+1]*STROKE_SCALE,
			   (float)strokeFont[i][j+2]*STROKE_SCALE);
		glEnd();
	    } else if (mode == FONT_ADVANCE) {
		glTranslatef((float)strokeFont[i][j+1]*STROKE_SCALE,
			     (float)strokeFont[i][j+2]*STROKE_SCALE, (GLfloat) 0.0);
		break;
	    }
	}
	glEndList();
    }
    return GL_TRUE;
}

GLenum tkCreateOutlineFont(GLuint fontBase)
{
    GLint mode, i, j;

    for (i = 0; outlineFont[i][0] != END_OF_LIST; i++) {
	glNewList(fontBase+(unsigned int)outlineFont[i][0], GL_COMPILE);
	for (j = 1; mode = outlineFont[i][j]; j += 3) {
	    if (mode == FONT_BEGIN) {
		glBegin(GL_LINE_STRIP);
		glVertex2f((float)outlineFont[i][j+1]*OUTLINE_SCALE,
			   (float)outlineFont[i][j+2]*OUTLINE_SCALE);
	    } else if (mode == FONT_NEXT) {
		glVertex2f((float)outlineFont[i][j+1]*OUTLINE_SCALE,
			   (float)outlineFont[i][j+2]*OUTLINE_SCALE);
	    } else if (mode == FONT_END) {
		glVertex2f((float)outlineFont[i][j+1]*OUTLINE_SCALE,
			   (float)outlineFont[i][j+2]*OUTLINE_SCALE);
		glEnd();
	    } else if (mode == FONT_ADVANCE) {
		glTranslatef((float)outlineFont[i][j+1]*OUTLINE_SCALE,
			     (float)outlineFont[i][j+2]*OUTLINE_SCALE, (GLfloat) 0.0);
		break;
	    }
	}
	glEndList();
    }
    return GL_TRUE;
}

GLenum tkCreateFilledFont(GLuint fontBase)
{
    GLint mode, i, j;

    for (i = 0; filledFont[i][0] != END_OF_LIST; i++) {
	glNewList(fontBase+(unsigned int)filledFont[i][0], GL_COMPILE);
	for (j = 1; mode = filledFont[i][j]; j += 3) {
	    if (mode == FONT_BEGIN) {
		glBegin(GL_TRIANGLE_STRIP);
		glVertex2f((float)filledFont[i][j+1]*FILLED_SCALE,
			   (float)filledFont[i][j+2]*FILLED_SCALE);
	    } else if (mode == FONT_NEXT) {
		glVertex2f((float)filledFont[i][j+1]*FILLED_SCALE,
			   (float)filledFont[i][j+2]*FILLED_SCALE);
	    } else if (mode == FONT_END) {
		glVertex2f((float)filledFont[i][j+1]*FILLED_SCALE,
			   (float)filledFont[i][j+2]*FILLED_SCALE);
		glEnd();
	    } else if (mode == FONT_ADVANCE) {
		glTranslatef((float)filledFont[i][j+1]*FILLED_SCALE,
			     (float)filledFont[i][j+2]*FILLED_SCALE, (GLfloat) 0.0);
		break;
	    }
	}
	glEndList();
    }
    return GL_TRUE;
}

GLenum tkCreateBitmapFont(GLuint fontBase)
{
    GLint i;

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    for (i = 0; bitmapFont[i][0] != BITMAP_END_OF_LIST; i++) {
	glNewList(fontBase+(unsigned int)bitmapFont[i][0], GL_COMPILE);
	glBitmap(8, 13, (GLfloat) 0.0, (GLfloat) 2.0, (GLfloat) 10.0, (GLfloat) 0.0, &bitmapFont[i][1]);
	glEndList();
    }
    return GL_TRUE;
}

void tkDrawStr(GLuint base, char *str)
{

    glPushAttrib(GL_LIST_BIT);
    glListBase(base);
    glCallLists(strlen(str), GL_UNSIGNED_BYTE, (unsigned char *)str);
    glPopAttrib();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\vect3d.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/* Routines to manipulate 3 dimensional vectors.  All these routines
 * should work even if the input and output vectors are the same.
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <GL/gl.h>
#include "3d.h"
#include "tk.h"

#define static

void (*errfunc)(char *) = 0;

void seterrorfunc(void (*func)(char *))
{
    errfunc = func;
}

void error(char *s)
{
    if (errfunc)
        (*errfunc)(s);
    else {
        MESSAGEBOX(GetFocus(), s, "Error", MB_OK);
        exit(1);
    }
}

void diff3(GLdouble p[3], GLdouble q[3], GLdouble diff[3])
{
    diff[0] = p[0] - q[0];
    diff[1] = p[1] - q[1];
    diff[2] = p[2] - q[2];
}

void add3(GLdouble p[3], GLdouble q[3], GLdouble sum[3])
{
    sum[0] = p[0] + q[0];
    sum[1] = p[1] + q[1];
    sum[2] = p[2] + q[2];
}

void scalarmult(GLdouble s, GLdouble v[3], GLdouble vout[3])
{
    vout[0] = v[0]*s;
    vout[1] = v[1]*s;
    vout[2] = v[2]*s;
}

GLdouble dot3(GLdouble p[3], GLdouble q[3])
{
    return p[0]*q[0] + p[1]*q[1] + p[2]*q[2];
}

GLdouble length3(GLdouble v[3])
{
    return sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
}

GLdouble dist3(GLdouble p[3], GLdouble q[3])
{
    GLdouble d[3];

    diff3(p, q, d);
    return length3(d);
}

void copy3(GLdouble old[3], GLdouble new[3])
{
    new[0] = old[0], new[1] = old[1], new[2] = old[2];
}

void crossprod(GLdouble v1[3], GLdouble v2[3], GLdouble prod[3])
{
    GLdouble p[3];      /* in case prod == v1 or v2 */

    p[0] = v1[1]*v2[2] - v2[1]*v1[2];
    p[1] = v1[2]*v2[0] - v2[2]*v1[0];
    p[2] = v1[0]*v2[1] - v2[0]*v1[1];
    prod[0] = p[0]; prod[1] = p[1]; prod[2] = p[2];
}

void normalize(GLdouble v[3])
{
    GLdouble d;

    d = sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
    if (d == (GLdouble)0.0) {
        error("normalize: zero length vector");
        v[0] = d = (GLdouble)1.0;
    }
    d = (GLdouble)1/d;
    v[0] *= d; v[1] *= d; v[2] *= d;
}

void identifymat3(GLdouble m[3][3])
{
    int i, j;

    for (i=0; i<3; i++)
        for (j=0; j<3; j++)
            m[i][j] = (i == j) ? (GLdouble)1.0 : (GLdouble)0.0;
}

void copymat3(GLdouble *to, GLdouble *from)
{
    int i;

    for (i=0; i<9; i++) {
        *to++ = *from++;
    }
}

void xformvec3(GLdouble v[3], GLdouble m[3][3], GLdouble vm[3])
{
    GLdouble result[3]; /* in case v == vm */
    int i;

    for (i=0; i<3; i++) {
        result[i] = v[0]*m[0][i] + v[1]*m[1][i] + v[2]*m[2][i];
    }
    for (i=0; i<3; i++) {
        vm[i] = result[i];
    }
}

long samepoint(GLdouble p1[3], GLdouble p2[3])
{
    if (p1[0] == p2[0] && p1[1] == p2[1] && p1[2] == p2[2])
        return 1;
    return 0;
}

void perpnorm(GLdouble p1[3], GLdouble p2[3], GLdouble p3[3], GLdouble n[3])
{
    GLdouble d1[3], d2[3];

    diff3(p2, p1, d1);
    diff3(p2, p3, d2);
    crossprod(d1, d2, n);
    normalize(n);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\xform.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <math.h>
#include <stdio.h>
#include <GL/gl.h>
#include "3d.h"

#define static

#define STACKDEPTH 10

typedef struct {
    GLdouble	mat[4][4];
    GLdouble	norm[3][3];
} mat_t;

static mat_t matstack[STACKDEPTH] = {
    {{{1.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 1.0}},
    {{1.0, 0.0, 0.0},
    {0.0, 1.0, 0.0},
    {0.0, 0.0, 1.0}}}
};
static int identitymat = 1;

static int mattop = 0;

void m_xformpt(GLdouble pin[3], GLdouble pout[3], 
    GLdouble nin[3], GLdouble nout[3])
{
    int	i;
    GLdouble	ptemp[3], ntemp[3];
    mat_t	*m = &matstack[mattop];

    if (identitymat) {
	for (i = 0; i < 3; i++) {
	    pout[i] = pin[i];
	    nout[i] = nin[i];
	}
	return;
    }
    for (i = 0; i < 3; i++) {
	ptemp[i] = pin[0]*m->mat[0][i] +
		   pin[1]*m->mat[1][i] +
		   pin[2]*m->mat[2][i] +
		   m->mat[3][i];
	ntemp[i] = nin[0]*m->norm[0][i] +
		   nin[1]*m->norm[1][i] +
		   nin[2]*m->norm[2][i];
    }
    for (i = 0; i < 3; i++) {
	pout[i] = ptemp[i];
	nout[i] = ntemp[i];
    }
    normalize(nout);
}

void m_xformptonly(GLdouble pin[3], GLdouble pout[3])
{
    int	i;
    GLdouble	ptemp[3];
    mat_t	*m = &matstack[mattop];

    if (identitymat) {
	for (i = 0; i < 3; i++) {
	    pout[i] = pin[i];
	}
	return;
    }
     for (i = 0; i < 3; i++) {
	ptemp[i] = pin[0]*m->mat[0][i] +
		   pin[1]*m->mat[1][i] +
		   pin[2]*m->mat[2][i] +
		   m->mat[3][i];
    }
    for (i = 0; i < 3; i++) {
	pout[i] = ptemp[i];
    }
}

void m_pushmatrix(void)
{
    if (mattop < STACKDEPTH-1) {
	matstack[mattop+1] = matstack[mattop];
	mattop++;
    } else
	error("m_pushmatrix: stack overflow\n");
}

void m_popmatrix(void)
{
    if (mattop > 0)
	mattop--;
    else
	error("m_popmatrix: stack underflow\n");
}

void m_translate(GLdouble x, GLdouble y, GLdouble z)
{
    int	i;
    mat_t	*m = &matstack[mattop];

    identitymat = 0;
    for (i = 0; i < 4; i++)
	m->mat[3][i] = x*m->mat[0][i] +
				 y*m->mat[1][i] +
				 z*m->mat[2][i] +
				 m->mat[3][i];
}

void m_scale(GLdouble x, GLdouble y, GLdouble z)
{
    int	i;
    mat_t	*m = &matstack[mattop];

    identitymat = 0;
    for (i = 0; i < 3; i++) {
	m->mat[0][i] *= x;
	m->mat[1][i] *= y;
	m->mat[2][i] *= z;
    }
    for (i = 0; i < 3; i++) {
	m->norm[0][i] /= x;
	m->norm[1][i] /= y;
	m->norm[2][i] /= z;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\clear.cxx ===
/******************************Module*Header*******************************\
* Module Name: clear.cxx
*
* Window clearing functions
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <sys/timeb.h>
#include <GL/gl.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <math.h>

#include "mtk.h"
#include "timer.hxx"
#include "util.hxx"
#include "clear.hxx"

#define SS_CLEAR_BASE_DIV 32
#define SS_CLEAR_BASE_SIZE 16


/******************************Public*Routine******************************\
* ss_RectWipeClear
*
* Clears by drawing top, bottom, left, right rectangles that shrink in size
* towards the center.
*
* Calibration is used to try to maintain an ideal clear time.
*
\**************************************************************************/

int
mtk_RectWipeClear( int width, int height, int repCount )
{
    int i, j, xinc, yinc, numDivs;
    int xmin, xmax, ymin, ymax;
    int w, h;
    BOOL bCalibrate = FALSE;
    float elapsed;
    static float idealTime = 0.7f;
    TIMER timer;

    xinc = 1;
    yinc = 1;
    numDivs = height; // assumes height <= width

    xmin = ymin = 0;
    xmax = width-1;
    ymax = height-1;

    glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );

    glEnable( GL_SCISSOR_TEST );

    if( repCount == 0 ) {
        bCalibrate = TRUE;
        repCount = 1;
        timer.Start();
    }

    for( i = 0; i < (numDivs/2); i ++ ) {
      w = xmax - xmin + 1;
      h = ymax - ymin + 1;

      for( j = 0; j < repCount; j ++ ) {
        // bottom
        glScissor( xmin, ymin, w, 1 );
        glClear( GL_COLOR_BUFFER_BIT );

        // left
        glScissor( xmin, ymin, 1, h );
        glClear( GL_COLOR_BUFFER_BIT );

        // right
        glScissor( xmax, ymin, 1, h );
        glClear( GL_COLOR_BUFFER_BIT );

        // top
        glScissor( xmin, ymax, w, 1 );
        glClear( GL_COLOR_BUFFER_BIT );

        glFlush(); // to eliminate 'bursts'
      }

      xmin += xinc;
      xmax -= xinc;
      ymin += yinc;
      ymax -= yinc;
    }

    if( bCalibrate ) {
        elapsed = timer.Stop();

        // try to maintain ideal clear time
        if( elapsed < idealTime ) {
            // increase repCount to slow down the clear
            if( elapsed == 0.0 )
                repCount = 10;  // just in case
            else
                repCount = (int) ((idealTime / elapsed) + 0.5);
        }
    }

    glDisable( GL_SCISSOR_TEST );

    return repCount;
}

#define SS_CLEAR_BASE_DIV 32

/******************************Public*Routine******************************\
*
* SS_DIGITAL_DISSOLVE_CLEAR constructor
*
\**************************************************************************/

SS_DIGITAL_DISSOLVE_CLEAR::
SS_DIGITAL_DISSOLVE_CLEAR()
{
    rectBuf = NULL;
    rectBufSize = 0;
    rectSize = SS_CLEAR_BASE_SIZE;
}

/******************************Public*Routine******************************\
*
* SS_DIGITAL_DISSOLVE_CLEAR destructor
*
\**************************************************************************/

SS_DIGITAL_DISSOLVE_CLEAR::
~SS_DIGITAL_DISSOLVE_CLEAR()
{
    if( rectBuf )
        LocalFree( rectBuf );
}

/******************************Public*Routine******************************\
* CalibrateClear
*
* Try to calibrate the clear so it takes the specified time
\**************************************************************************/

//#define AUTO_CALIBRATE 1

int SS_DIGITAL_DISSOLVE_CLEAR::
CalibrateClear( int width, int height, float fClearTime )
{
    float factor;
    int idealNRects;
    int nRects;
    int baseSize;
    TIMER timer;
    float elapsed;

    baseSize = (width < height ? width : height) / SS_CLEAR_BASE_DIV;
    if( baseSize == 0 )
        baseSize = 1;

    timer.Start();

#ifdef AUTO_CALIBRATE
    // Clear a small region (quarter-screen) and extrapolate
    Clear( width >> 1, height >> 1, baseSize );
#else
    Clear( width, height, baseSize );
#endif

    elapsed = timer.Stop();
#ifdef AUTO_CALIBRATE
    // extrapolate to full screen time
    // mf: this approximation resulted in clears being somewhat less than ideal
    //  I guess this means more time than I thought was spent in scanning up
    //  or down for uncleared rects
    elapsed *= 4.0f;
#endif

    // Adjust size of rects for ideal clear time

    if( elapsed <= 0.0f ) {
        rectSize = 1;
        return rectSize;
    }

    nRects = RectangleCount( width, height, baseSize );
    factor = fClearTime / elapsed;
    idealNRects = (int) (factor * (float)nRects);
    rectSize = (int) (sqrt( (double)(width*height) / (double)idealNRects ) + 0.5);
    if( rectSize == 0 )
        rectSize = 1;

    return rectSize;
}

/******************************Public*Routine******************************\
* 
* SS_DIGITAL_DISSOLVE_CLEAR::Clear
*
* Clears by drawing random rectangles
*
\**************************************************************************/


BOOL SS_DIGITAL_DISSOLVE_CLEAR::
Clear( int width, int height )
{
    return Clear( width, height, rectSize );
}

BOOL SS_DIGITAL_DISSOLVE_CLEAR::
Clear( int width, int height, int size )
{
    BOOL *pRect;
    BOOL bCalibrate = FALSE;
    int count, nRects;
    int i, xdim, ydim;
    static float idealTime = 2.0f;

    if( (size <= 0) || !width || !height )
        return FALSE;

    // determine xdim, ydim from size
    xdim = SS_ROUND_UP( (float)width / (float)size );
    ydim = SS_ROUND_UP( (float)height / (float) size );

    // figure out how many rects needed
    count = nRects = xdim * ydim;

    // make sure enough room
    if( !ValidateBufSize( nRects ) )
        return FALSE;

    // reset the rect array to uncleared

    pRect = rectBuf;
    for( i = 0; i < count; i ++, pRect++ )
        *pRect = FALSE;

    // Clear random rectangles

    glEnable( GL_SCISSOR_TEST );

    while( count ) {
        // pick a random rect
        i = ss_iRand( nRects );

        if( rectBuf[i] ) {
            // This rect has already been cleared - find an empty one
            // Scan up and down from x,y, looking at the array linearly

            int up, down;
            BOOL searchUp = FALSE;

            up = down = i;

            pRect = rectBuf;
            while( *(pRect + i) ) {
                if( searchUp ) {
                    // search up side
                    if( up < (nRects-1) ) {
                        up++;
                    }
                    i = up;
                } else {
                    // search down side
                    if( down > 0 ) {
                        down--;
                    }
                    i = down;
                }
                searchUp = !searchUp;
            }
        }

        // clear the x,y rect
        glScissor( (i % xdim)*size, (i / xdim)*size, size, size );
        glClear( GL_COLOR_BUFFER_BIT );
        glFlush();

        rectBuf[i] = TRUE; // mark as taken
        count--;
    }

    glDisable( GL_SCISSOR_TEST );

    return TRUE;
}

/******************************Public*Routine******************************\
* RectangleCount
*
\**************************************************************************/

int SS_DIGITAL_DISSOLVE_CLEAR::
RectangleCount( int width, int height, int size )
{
    return  SS_ROUND_UP( (float)width / (float)size ) *
            SS_ROUND_UP( (float)height / (float) size );
}

/******************************Public*Routine******************************\
* ValidateBufSize
*
\**************************************************************************/

BOOL SS_DIGITAL_DISSOLVE_CLEAR::
ValidateBufSize( int nRects )
{
    if( nRects > rectBufSize ) {
        // need a bigger rect buf
        BOOL *r = (BOOL *) LocalAlloc( LMEM_FIXED, sizeof(BOOL) * nRects );
        if( !r )
            return FALSE;
        if( rectBuf )
            LocalFree( rectBuf );
        rectBuf = r;
        rectBufSize = nRects;
    }
    return TRUE;
}

/******************************Public*Routine******************************\
* DrawGdiRect
*
* Clears the rect with the brush
\**************************************************************************/

void
DrawGdiRect( HDC hdc, HBRUSH hbr, RECT *pRect ) 
{
    if( pRect == NULL )
        return;

    FillRect( hdc, pRect, hbr );
    GdiFlush();
}

#ifdef SS_INITIAL_CLEAR
/*-----------------------------------------------------------------------
|                                                                       
|    RectWipeClear(width, height):  
|       - Does a rectangular wipe (or clear) by drawing in a sequence   
|         of rectangles using Gdi                                       
|       MOD: add calibrator capability to adjust speed for different
|            architectures
|       MOD: this can be further optimized by caching the brush
|
-----------------------------------------------------------------------*/
void 
mtk_GdiRectWipeClear( HWND hwnd, int width, int height )
{
    HDC hdc;
    HBRUSH hbr;
    RECT rect;
    int i, j, xinc, yinc, numDivs = 500;
    int xmin, xmax, ymin, ymax;
    int repCount = 10;

    xinc = 1;
    yinc = 1;
    numDivs = height;
    xmin = ymin = 0;
    xmax = width;
    ymax = height;

    hdc = GetDC( hwnd );

    hbr = CreateSolidBrush( RGB( 0, 0, 0 ) );

    for( i = 0; i < (numDivs/2 - 1); i ++ ) {
      for( j = 0; j < repCount; j ++ ) {
        rect.left = xmin; rect.top = ymin;
        rect.right = xmax; rect.bottom = ymin + yinc;
        FillRect( hdc, &rect, hbr );
        rect.top = ymax - yinc;
        rect.bottom = ymax;
        FillRect( hdc, &rect, hbr );
        rect.top = ymin + yinc;
        rect.right = xmin + xinc; rect.bottom = ymax - yinc;
        FillRect( hdc, &rect, hbr );
        rect.left = xmax - xinc; rect.top = ymin + yinc;
        rect.right = xmax; rect.bottom = ymax - yinc;
        FillRect( hdc, &rect, hbr );
      }

      xmin += xinc;
      xmax -= xinc;
      ymin += yinc;
      ymax -= yinc;
    }

    // clear last square in middle

    rect.left = xmin; rect.top = ymin;
    rect.right = xmax; rect.bottom = ymax;
    FillRect( hdc, &rect, hbr );

    DeleteObject( hbr );

    ReleaseDC( hwnd, hdc );

    GdiFlush();
}
#endif // SS_INITIAL_CLEAR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\color.c ===
#include <windows.h>
#include <math.h>
#include <GL/gl.h>
#include "mtk.h"


/******************************Public*Routine******************************\
* HsvToRgb
*
* HSV to RGB color space conversion.  From pg. 593 of Foley & van Dam.
*
\**************************************************************************/

void 
ss_HsvToRgb(float h, float s, float v, RGBA *color )
{
    float i, f, p, q, t;

    // set alpha value, so caller doesn't have to worry about undefined value
    color->a = 1.0f;

    if (s == 0.0f)     // assume h is undefined
        color->r = color->g = color->b = v;
    else {
        if (h >= 360.0f)
            h = 0.0f;
        h = h / 60.0f;
        i = (float) floor(h);
        f = h - i;
        p = v * (1.0f - s);
        q = v * (1.0f - (s * f));
        t = v * (1.0f - (s * (1.0f - f)));
        switch ((int)i) {
        case 0:
            color->r = v;
            color->g = t;
            color->b = p;
            break;
        case 1:
            color->r = q;
            color->g = v;
            color->b = p;
            break;
        case 2:
            color->r = p;
            color->g = v;
            color->b = t;
            break;
        case 3:
            color->r = p;
            color->g = q;
            color->b = v;
            break;
        case 4:
            color->r = t;
            color->g = p;
            color->b = v;
            break;
        case 5:
            color->r = v;
            color->g = p;
            color->b = q;
            break;
        default:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\fastdib.c ===
/******************************Module*Header*******************************\
* Module Name: fastdib.c
*
* CreateCompatibleDIB implementation.
*
* Created: 23-Jan-1996 21:08:18
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#include "mtk.h"

BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector);
static BOOL bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static BOOL bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static UINT MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                                      LPPALETTEENTRY lppe);
static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal,
                                        BYTE *pajVector);

/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DIB <= 8bpp, then the DIB color table is initialized based on the
* specified palette.  If the palette handle is NULL, then the system
* palette is used.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Note: On palettized displays, if the system palette changes the
*       UpdateDIBColorTable function should be called to maintain
*       the identity palette mapping between the DIB and the display.
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//HBITMAP APIENTRY
HBITMAP
SSDIB_CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight,
                    PVOID *ppvBits)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        SS_DBGPRINT("CreateCompatibleDIB: not OBJ_DC\n");
        return hbmRet;
    }

    memset(aj, 0, sizeof(aj));
    if ( bFillBitmapInfo(hdc, hpal, pbmi) )
    {
        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = ulWidth;
        pbmi->bmiHeader.biHeight = ulHeight;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);
        GdiFlush();

        if ( !hbmRet )
        {
            SS_DBGPRINT("CreateCompatibleDIB: CreateDIBSection failed\n");
        }
    }
    else
    {
        SS_DBGPRINT("CreateCompatibleDIB: bFillBitmapInfo failed\n");
    }

    return hbmRet;
}

/******************************Public*Routine******************************\
* UpdateDIBColorTable
*
* Synchronize the DIB color table to the specified palette hpal.
* If hpal is NULL, then use the system palette.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
SSDIB_UpdateColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;
    BYTE aj[(sizeof(RGBQUAD) + sizeof(PALETTEENTRY)) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    LPRGBQUAD prgb = (LPRGBQUAD) (lppe + 256);
    ULONG i, cColors;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        SS_DBGPRINT("UpdateDIBColorTable: not OBJ_DC\n");
        return bRet;
    }
    if ( GetObjectType(hdcMem) != OBJ_MEMDC )
    {
        SS_DBGPRINT("UpdateDIBColorTable: not OBJ_MEMDC\n");
        return bRet;
    }

    //
    // Get the bitmap handle out of the memdc.
    //

    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP);

    //
    // Validate bitmap (must be DIB section).
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds)) &&
         ds.dsBm.bmBits )
    {
        //
        // Get palette entries from specified palette or system palette.
        //

        cColors = 1 << ds.dsBmih.biBitCount;


        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe)
           )
        {
            UINT i;

            //
            // Convert to RGBQUAD.
            //

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            //
            // Set the DIB color table.
            //

            bRet = (BOOL) SetDIBColorTable(hdcMem, 0, cColors, prgb);

            if (!bRet)
            {
                SS_DBGPRINT("UpdateDIBColorTable: SetDIBColorTable failed\n");
            }
        }
        else
        {
            SS_DBGPRINT("UpdateDIBColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }
    else
    {
        SS_DBGPRINT("UpdateDIBColorTable: GetObject failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL APIENTRY
GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        // For backwards compatibility with Get/SetBitmapBits, GDI does
        // not accurately report the bitmap pitch in bmWidthBytes.  It
        // always computes bmWidthBytes assuming WORD-aligned scanlines
        // regardless of the platform.
        //
        // Therefore, if the platform is WinNT, which uses DWORD-aligned
        // scanlines, adjust the bmWidthBytes value.

        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                SS_DBGPRINT1("GetCompatibleDIBInfo: GetVersionEx failed with %d\n", GetLastError());
                return bRet;
            }
        }

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((int) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        SS_DBGPRINT("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetDIBTranslationVector
*
* Copies the translation vector that maps colors in the specified palette,
* hpal, to the DIB selected into the specified DC, hdcMem.
*
* Effects:
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL APIENTRY
GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;

    //
    // Validate parameters.
    //

    if ( GetObjectType(hdcMem) != OBJ_MEMDC ||
         GetObjectType(hpal) != OBJ_PAL ||
         !pbVector )
    {
        SS_DBGPRINT("GetDIBTranslationVector: bad parameter\n");
        return bRet;
    }

    //
    // The function bComputeLogicalToSurfaceMap cannot handle palettes
    // greater than 256 entries.
    //

    if ( GetPaletteEntries(hpal, 0, 1, NULL) > 256 )
    {
        SS_DBGPRINT("GetDIBTranslationVector: palette too big\n");
        return bRet;
    }

    //
    // The DIB must have a color table.
    //

    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP);
    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && (ds.dsBmih.biBitCount <= 8) )
    {
        bRet = bComputeLogicalToSurfaceMap(hdcMem, hpal, pbVector);
    }
    else
    {
        SS_DBGPRINT("GetDIBTranslationVector: not a DIB section\n");
        return bRet;
    }

    return bRet;
}

//////////////////// Below here are internal-only routines ////////////////////

/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if ( pbmi->bmiHeader.biBitCount <= 8 )
        {
            bRet = bFillColorTable(hdc, hpal, pbmi);
        }
        else
        {
            if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
            {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
            }

            bRet = TRUE;
        }

        DeleteObject(hbm);
    }
    else
    {
        SS_DBGPRINT("bFillBitmapInfo: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG i, cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;
    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            SS_DBGPRINT("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bComputeLogicalToSurfaceMap
*
* Copy logical palette to surface palette translation vector to the buffer
* pointed to by pajVector.  The logical palette is specified by hpal.  The
* surface is specified by hdc.
*
* Note: The hdc may identify either a direct (display) dc or a DIB memory dc.
* If hdc is a display dc, then the surface palette is the system palette.
* If hdc is a memory dc, then the surface palette is the DIB color table.
*
* History:
*  27-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL 
bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal, BYTE *pajVector)
{
    BOOL bRet = FALSE;
    HPALETTE hpalSurf;
    ULONG cEntries, cSysEntries;
    DWORD dwDcType = GetObjectType(hdc);
    LPPALETTEENTRY lppeTmp, lppeEnd;

    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)];
    LOGPALETTE *ppal = (LOGPALETTE *) aj;
    LPPALETTEENTRY lppeSurf = &ppal->palPalEntry[0];
    LPPALETTEENTRY lppe = lppeSurf + 256;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

    //
    // Determine number of colors in each palette.
    //

    cEntries = GetPaletteEntries(hpal, 0, 1, NULL);
    if ( dwDcType == OBJ_DC )
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, 1, NULL);
    else
        cSysEntries = 256;

    //
    // Get the logical palette entries.
    //

    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe);

    //
    // Get the surface palette entries.
    //

    if ( dwDcType == OBJ_DC )
    {
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf);

        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        for (; lppeTmp < lppeEnd; lppeTmp++)
            lppeTmp->peFlags = 0;
    }
    else
    {
        RGBQUAD *prgbTmp;

        //
        // First get RGBQUADs from DIB color table...
        //

        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb);

        //
        // ...then convert RGBQUADs into PALETTEENTRIES.
        //

        prgbTmp = prgb;
        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        while ( lppeTmp < lppeEnd )
        {
            lppeTmp->peRed   = prgbTmp->rgbRed;
            lppeTmp->peGreen = prgbTmp->rgbGreen;
            lppeTmp->peBlue  = prgbTmp->rgbBlue;
            lppeTmp->peFlags = 0;

            lppeTmp++;
            prgbTmp++;

        }
    }

    //
    // Construct a translation vector by using GetNearestPaletteIndex to
    // map each entry in the logical palette to the surface palette.
    //

    if ( cEntries && cSysEntries )
    {
        //
        // Create a temporary logical palette that matches the surface
        // palette retrieved above.
        //

        ppal->palVersion = 0x300;
        ppal->palNumEntries = (USHORT) cSysEntries;

        if ( hpalSurf = CreatePalette(ppal) )
        {
            //
            // Translate each logical palette entry into a surface palette
            // index.
            //

            lppeTmp = lppe;
            lppeEnd = lppe + cEntries;

            for ( ; lppeTmp < lppeEnd; lppeTmp++, pajVector++)
            {
                *pajVector = (BYTE) GetNearestPaletteIndex(
                                        hpalSurf,
                                        RGB(lppeTmp->peRed,
                                            lppeTmp->peGreen,
                                            lppeTmp->peBlue)
                                        );
            }

            bRet = TRUE;

            DeleteObject(hpalSurf);
        }
        else
        {
            SS_DBGPRINT("bComputeLogicalToSurfaceMap: CreatePalette failed\n");
        }
    }
    else
    {
        SS_DBGPRINT("bComputeLogicalToSurfaceMap: failed to get pal info\n");
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libaux\tkimage.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"

#define static


#define IMAGIC      0x01da
#define IMAGIC_SWAP 0xda01

#define SWAP_SHORT_BYTES(x) ((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8))
#define SWAP_LONG_BYTES(x) (((((x) & 0xff) << 24) | (((x) & 0xff00) << 8)) | \
                            ((((x) & 0xff0000) >> 8) | (((x) & 0xff000000) >> 24)))

typedef struct _rawImageRec {
    unsigned short imagic;
    unsigned short type;
    unsigned short dim;
    unsigned short sizeX, sizeY, sizeZ;
    unsigned long min, max;
    unsigned long wasteBytes;
    char name[80];
    unsigned long colorMap;
    HANDLE file;
    unsigned char *tmp, *tmpR, *tmpG, *tmpB;
    unsigned long rleEnd;
    unsigned long *rowStart;
    long *rowSize;
} rawImageRec;

static void RawImageClose(rawImageRec *raw);

static rawImageRec *RawImageOpenAW(char *fileName, BOOL bUnicode)
{
    rawImageRec *raw;
    unsigned long *rowStart, *rowSize, ulTmp;
    int x;
    DWORD dwBytesRead;

    raw = (rawImageRec *)malloc(sizeof(rawImageRec));
    if (raw == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        return NULL;
    }

    raw->file = bUnicode ? CreateFileW((LPWSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0) :
                           CreateFileA((LPSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
    if (raw->file == INVALID_HANDLE_VALUE) {
        char ach[256];

        bUnicode ? wsprintf(ach, "Failed to open image file %ws.\n", fileName) :
                   wsprintf(ach, "Failed to open image file %s.\n", fileName);

        MESSAGEBOX(GetFocus(), ach, "Error", MB_OK);

        free( raw );
        return NULL;
    }

    ReadFile(raw->file, (LPVOID) raw, 12, &dwBytesRead, (LPOVERLAPPED) NULL);

    if (raw->imagic == IMAGIC_SWAP) {
        raw->type = SWAP_SHORT_BYTES(raw->type);
        raw->dim = SWAP_SHORT_BYTES(raw->dim);
        raw->sizeX = SWAP_SHORT_BYTES(raw->sizeX);
        raw->sizeY = SWAP_SHORT_BYTES(raw->sizeY);
        raw->sizeZ = SWAP_SHORT_BYTES(raw->sizeZ);
    } else if (raw->imagic != IMAGIC) {
        // magic number is absent - conclude file is invalid (?)
        MESSAGEBOX(GetFocus(), "Invalid rgb file.", "Error", MB_OK);
        RawImageClose( raw );
        return NULL;
    }
        
    raw->tmp = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpR = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpG = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpB = (unsigned char *)malloc(raw->sizeX*256);
    if (raw->tmp == NULL || raw->tmpR == NULL || raw->tmpG == NULL ||
        raw->tmpB == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        RawImageClose( raw );
        return NULL;
    }

    if ((raw->type & 0xFF00) == 0x0100) {
        x = raw->sizeY * raw->sizeZ * sizeof(long);
        raw->rowStart = (unsigned long *)malloc(x);
        raw->rowSize = (long *)malloc(x);
        if (raw->rowStart == NULL || raw->rowSize == NULL) {
            MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
            RawImageClose( raw );
            return NULL;
        }
        raw->rleEnd = 512 + (2 * x);
        SetFilePointer(raw->file, 512, NULL, FILE_BEGIN);
        ReadFile(raw->file, (LPVOID) raw->rowStart, x, &dwBytesRead,
                 (LPOVERLAPPED) NULL);
        ReadFile(raw->file, (LPVOID) raw->rowSize, x, &dwBytesRead,
                 (LPOVERLAPPED) NULL);
        if (raw->imagic == IMAGIC_SWAP) {
            x /= sizeof(long);
            rowStart = raw->rowStart;
            rowSize = raw->rowSize;
            while (x--) {
                ulTmp = *rowStart;
                *rowStart++ = SWAP_LONG_BYTES(ulTmp);
                ulTmp = *rowSize;
                *rowSize++ = SWAP_LONG_BYTES(ulTmp);
            }
        }
    }
    return raw;
}

static void RawImageClose(rawImageRec *raw)
{
    if( !raw )
        return;
    CloseHandle(raw->file);
    if( raw->tmp ) free(raw->tmp);
    if( raw->tmpR ) free(raw->tmpR);
    if( raw->tmpG ) free(raw->tmpG);
    if( raw->tmpB ) free(raw->tmpB);
    free(raw);
}

static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z)
{
    unsigned char *iPtr, *oPtr, pixel;
    int count;
    DWORD dwBytesRead;

    if ((raw->type & 0xFF00) == 0x0100) {
        SetFilePointer(raw->file, raw->rowStart[y+z*raw->sizeY], NULL, FILE_BEGIN);
        ReadFile(raw->file, (LPVOID) raw->tmp,
                 (unsigned int)raw->rowSize[y+z*raw->sizeY], &dwBytesRead,
                 (LPOVERLAPPED) NULL);

        iPtr = raw->tmp;
        oPtr = buf;
        while (1) {
            pixel = *iPtr++;
            count = (int)(pixel & 0x7F);
            if (!count) {
                return;
            }
            if (pixel & 0x80) {
                while (count--) {
                    *oPtr++ = *iPtr++;
                }
            } else {
                pixel = *iPtr++;
                while (count--) {
                    *oPtr++ = pixel;
                }
            }
        }
    } else {
        SetFilePointer(raw->file, 512+(y*raw->sizeX)+(z*raw->sizeX*raw->sizeY),
                       NULL, FILE_BEGIN);
        ReadFile(raw->file, (LPVOID) buf, raw->sizeX, &dwBytesRead,
                 (LPOVERLAPPED) NULL);
    }
}

static void RawImageGetData(rawImageRec *raw, TK_RGBImageRec *final)
{
    unsigned char *ptr;
    int i, j;

    final->data = (unsigned char *)malloc((raw->sizeX+1)*(raw->sizeY+1)*4);
    if (final->data == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        return;
    }

    ptr = final->data;
    for (i = 0; i < raw->sizeY; i++) {
        RawImageGetRow(raw, raw->tmpR, i, 0);
        RawImageGetRow(raw, raw->tmpG, i, 1);
        RawImageGetRow(raw, raw->tmpB, i, 2);
        for (j = 0; j < raw->sizeX; j++) {
            *ptr++ = *(raw->tmpR + j);
            *ptr++ = *(raw->tmpG + j);
            *ptr++ = *(raw->tmpB + j);
        }
    }
}

TK_RGBImageRec *tkRGBImageLoad(char *fileName)
{
    return tkRGBImageLoadAW(fileName, FALSE);
}

TK_RGBImageRec *tkRGBImageLoadAW(char *fileName, BOOL bUnicode)
{
    rawImageRec *raw;
    TK_RGBImageRec *final;

    if( !(raw = RawImageOpenAW(fileName, bUnicode)) )
        return NULL;

    final = (TK_RGBImageRec *)malloc(sizeof(TK_RGBImageRec));
    if (final == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        RawImageClose(raw);
        return NULL;
    }
    final->sizeX = raw->sizeX;
    final->sizeY = raw->sizeY;
    RawImageGetData(raw, final);
    RawImageClose(raw);
    return final;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\math.c ===
/******************************Module*Header*******************************\
* Module Name: math.c
*
* Misc. useful math utility functions.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <GL\gl.h>
#include <math.h>
#include "mtk.h"

#define ZERO_EPS    0.00000001

POINT3D ss_ptZero = {0.0f, 0.0f, 0.0f};


void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]) + mat->M[0][3];

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]) + mat->M[1][3];

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]) + mat->M[2][3];

    ptOut->x = (float) x;
    ptOut->y = (float) y;
    ptOut->z = (float) z;
}

void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;
    double len;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]);

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]);

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]);

    len = (x * x) + (y * y) + (z * z);
    if (len >= ZERO_EPS)
        len = 1.0 / sqrt(len);
    else
        len = 1.0;

    ptOut->x = (float) (x * len);
    ptOut->y = (float) (y * len);
    ptOut->z = (float) (z * len);
    return;
}

void ss_matrixIdent(MATRIX *mat)
{
    mat->M[0][0] = 1.0f; mat->M[0][1] = 0.0f;
    mat->M[0][2] = 0.0f; mat->M[0][3] = 0.0f;

    mat->M[1][0] = 0.0f; mat->M[1][1] = 1.0f;
    mat->M[1][2] = 0.0f; mat->M[1][3] = 0.0f;

    mat->M[2][0] = 0.0f; mat->M[2][1] = 0.0f;
    mat->M[2][2] = 1.0f; mat->M[2][3] = 0.0f;

    mat->M[3][0] = 0.0f; mat->M[3][1] = 0.0f;
    mat->M[3][2] = 0.0f; mat->M[3][3] = 1.0f;
}

void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta)
{
    float xScale, yScale, zScale;
    float sinX, cosX;
    float sinY, cosY;
    float sinZ, cosZ;

    xScale = m->M[0][0];
    yScale = m->M[1][1];
    zScale = m->M[2][2];
    sinX = (float) sin(xTheta);
    cosX = (float) cos(xTheta);
    sinY = (float) sin(yTheta);
    cosY = (float) cos(yTheta);
    sinZ = (float) sin(zTheta);
    cosZ = (float) cos(zTheta);

    m->M[0][0] = (float) ((cosZ * cosY) * xScale);
    m->M[0][1] = (float) ((cosZ * -sinY * -sinX + sinZ * cosX) * yScale);
    m->M[0][2] = (float) ((cosZ * -sinY * cosX + sinZ * sinX) * zScale);

    m->M[1][0] = (float) (-sinZ * cosY * xScale);
    m->M[1][1] = (float) ((-sinZ * -sinY * -sinX + cosZ * cosX) * yScale);
    m->M[1][2] = (float) ((-sinZ * -sinY * cosX + cosZ * sinX) * zScale);

    m->M[2][0] = (float) (sinY * xScale);
    m->M[2][1] = (float) (cosY * -sinX * yScale);
    m->M[2][2] = (float) (cosY * cosX * zScale);
}

void ss_matrixTranslate(MATRIX *m, double xTrans, double yTrans,
                     double zTrans)
{
    m->M[0][3] = (float) xTrans;
    m->M[1][3] = (float) yTrans;
    m->M[2][3] = (float) zTrans;
}


void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 )
{
    int i, j;

    for( j = 0; j < 4; j ++ ) {
    	for( i = 0; i < 4; i ++ ) {
	    m1->M[j][i] = m2->M[j][0] * m3->M[0][i] +
			  m2->M[j][1] * m3->M[1][i] +
			  m2->M[j][2] * m3->M[2][i] +
			  m2->M[j][3] * m3->M[3][i];
	}
    }
}

void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3)
{
    float crossX, crossY, crossZ;
    float abX, abY, abZ;
    float acX, acY, acZ;
    float sqrLength;
    float invLength;

    abX = p2->x - p1->x;       // calculate p2 - p1
    abY = p2->y - p1->y;
    abZ = p2->z - p1->z;

    acX = p3->x - p1->x;       // calculate p3 - p1
    acY = p3->y - p1->y;
    acZ = p3->z - p1->z;

    crossX = (abY * acZ) - (abZ * acY);    // get cross product
    crossY = (abZ * acX) - (abX * acZ);    // (p2 - p1) X (p3 - p1)
    crossZ = (abX * acY) - (abY * acX);

    sqrLength = (crossX * crossX) + (crossY * crossY) +
                 (crossZ * crossZ);

    if (sqrLength > ZERO_EPS)
        invLength = (float) (1.0 / sqrt(sqrLength));
    else
        invLength = 1.0f;

    norm->x = crossX * invLength;
    norm->y = crossY * invLength;
    norm->z = crossZ * invLength;
}

void mtk_NormalizePoints(POINT3D *p, ULONG cPts)
{
    float len;
    ULONG i;

    for (i = 0; i < cPts; i++, p++) {
        len = (p->x * p->x) + (p->y * p->y) + (p->z * p->z);
        if (len > ZERO_EPS)
            len = (float) (1.0 / sqrt(len));
        else
            len = 1.0f;

        p->x *= len;
        p->y *= len;
        p->z *= len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\mtkbmp.cxx ===
/******************************Module*Header*******************************\
* Module Name: mtkbmp.cxx
*
* mtk bitmap
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include "mtk.hxx"
#include "mtkbmp.hxx"

/******************************Public*Routine******************************\
*
\**************************************************************************/

MTKBMP::MTKBMP( HDC hdcWinArg )
{
    hBitmap = NULL;
    hdcWin = hdcWinArg;
    hdc = CreateCompatibleDC( hdcWin );
    size.width = size.height = 0;
}

MTKBMP::~MTKBMP()
{
    if( hBitmap )
        DeleteObject( hBitmap );
}

BOOL
MTKBMP::Resize( ISIZE *pSize )
{
    if( (pSize->width <= 0) || (pSize->height <= 0) ) {
        SS_ERROR( "MTKBMP::Resize : Invalid size parameters\n" );
        return FALSE;
    }

    if( (pSize->width == size.width) && (pSize->height == size.height) )
        // Same size
        return TRUE;

    size = *pSize;

    PVOID pvBits;  //mf: doesn't seem like we need this
#if 1
    // Use system palette
//mf: don't know why we have to use hdcWin here, but if I use hdc, get 
// error : 'not OBJ_DC'
    HBITMAP hbmNew = 
        SSDIB_CreateCompatibleDIB(hdcWin, NULL, size.width, size.height, &pvBits);
#else
//mf: uhh, this never worked or something, right ?
    // Use log palette
    HBITMAP hbmNew = SSDIB_CreateCompatibleDIB(hdcWin, 
                                    gpssPal ? gpssPal->hPal : NULL, 
                                    size.width, size.height, &pvBits);
#endif
    if (hbmNew)
    {
        if( hBitmap != NULL )
        {
            SelectObject( hdc, hBitmap );
            DeleteObject( hBitmap );
        }

        hBitmap = hbmNew;
        SelectObject( hdc, hBitmap );
    }
    return TRUE;
}

/******************************Public*Routine******************************\
\**************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\glutil.cxx ===
/******************************Module*Header*******************************\
* Module Name: glutil.cxx
*
* Misc. utility functions
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <GL/gl.h>
#include <sys/types.h>
#include <math.h>

#include "mtk.h"
#include "glutil.hxx"

MTK_OS_INFO gOSInfo;
MTK_GL_CAPS gGLCaps; // this should be per context, eventually

void (__stdcall *glAddSwapHintRect)(GLint, GLint, GLint, GLint);

/******************************Public*Routine******************************\
* ss_fOnGL11
*
* True if running on OpenGL v.1.1x
*
\**************************************************************************/

BOOL
mtk_fOnGL11( void )
{
    return gGLCaps.bGLv1_1;
}

/******************************Public*Routine******************************\
* ss_fOnNT35
*
* True if running on NT version 3.51 or less
*
\**************************************************************************/

BOOL 
mtk_fOnNT35( void )
{
    return gOSInfo.fOnNT35;
}

/******************************Public*Routine******************************\
* ss_fOnWin95
*
* True if running on Windows 95
*
\**************************************************************************/

BOOL 
mtk_fOnWin95( void )
{
    return gOSInfo.fOnWin95;
}

/******************************Public*Routine******************************\
* MyAddSwapHintRect
*
\**************************************************************************/

static void _stdcall 
MyAddSwapHintRect(GLint xs, GLint ys, GLint xe, GLint ye)
{
    return;
}

/******************************Public*Routine******************************\
* QueryAddSwapHintRectWIN
*
\**************************************************************************/

//mf: again, per context problem
BOOL
mtk_QueryAddSwapHintRect()
{
    glAddSwapHintRect = (PFNGLADDSWAPHINTRECTWINPROC)
        wglGetProcAddress("glAddSwapHintRectWIN");
    if (glAddSwapHintRect == NULL) {
        glAddSwapHintRect = MyAddSwapHintRect;
        return FALSE;
    }
    return TRUE;
}


/******************************Public*Routine******************************\
* mtk_bAddSwapHintRect()
*
\**************************************************************************/

BOOL 
mtk_bAddSwapHintRect()
{
    return gGLCaps.bAddSwapHintRect;
}

/******************************Public*Routine******************************\
\**************************************************************************/

MTK_OS_INFO::MTK_OS_INFO()
{
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    fOnWin95 = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
    fOnNT35 = 
    ( 
        (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
        (osvi.dwMajorVersion == 3 && osvi.dwMinorVersion <= 51)
    );
}

/******************************Public*Routine******************************\
\**************************************************************************/

MTK_GL_CAPS::MTK_GL_CAPS()
{
    bGLv1_1 = FALSE;
    bTextureObjects = FALSE;
    bAddSwapHintRect = FALSE;
    bPalettedTexture = FALSE;
}

void
MTK_GL_CAPS::Query()
{
    bGLv1_1 = (BOOL) strstr( (char *) glGetString(GL_VERSION), "1.1" );
    if( bGLv1_1 )
        bTextureObjects = TRUE;
    if( !bTextureObjects )
        SS_DBGINFO( "MTK_GL_CAPS: Texture Objects disabled\n" );
    bAddSwapHintRect = mtk_QueryAddSwapHintRect();
    bPalettedTexture = mtk_QueryPalettedTextureEXT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\mtkanim.cxx ===
/******************************Module*Header*******************************\
* Module Name: mtkanim.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include "mtk.hxx"
#include "mtkanim.hxx"

/**************************************************************************\
* MTKANIMATOR constructors
*
* The object needs to be attached to an hwnd, since it's required for timer
* creation, and msg posting.
\**************************************************************************/

MTKANIMATOR::MTKANIMATOR()
{
    hwnd = NULL;
    Init();
}

MTKANIMATOR::MTKANIMATOR( HWND hwndAttach )
: hwnd( hwndAttach )
{
    Init();
}

/**************************************************************************\
*
\**************************************************************************/

void
MTKANIMATOR::Init()
{
    idTimer =       0;
    nFrames = 0;
    mode = MTK_ANIMATE_CONTINUOUS;
    msUpdateInterval = 0;
    AnimateFunc =   NULL;
}

/**************************************************************************\
* MTKANIMATOR destructor
*
\**************************************************************************/

MTKANIMATOR::~MTKANIMATOR()
{
    Stop();
}

/**************************************************************************\
* SetFunc
*
* Set the animation function callback.  This immediately replaces the previous
* callback, and if a timer is currently running, then the new function gets
* called.  If the new callback is NULL, then the timer is stopped.
*
\**************************************************************************/

void
MTKANIMATOR::SetFunc( MTK_ANIMATEPROC Func )
{
    AnimateFunc = Func;

    if( ! AnimateFunc ) {
        Stop();
    }
}

/**************************************************************************\
* SetMode
*
\**************************************************************************/

void
MTKANIMATOR::SetMode( UINT newMode, float *fParam )
{
    switch( newMode ) {
        case MTK_ANIMATE_CONTINUOUS :
            // First param is animation period ( 1/fps )
         {
            float fUpdateInterval = fParam[0];
            if( fUpdateInterval < 0.0f )
                SS_WARNING( "MTKANIMATOR::SetMode: bad update interval parameter\n" );
                fUpdateInterval = 0.0f;
            msUpdateInterval = (UINT) (fUpdateInterval * 1000.0f);
         }
            break;

        case MTK_ANIMATE_INTERVAL :
            // First param is number of frames,
            // Second param is total desired duration of the animation
         {
            int iFrameCount = (int) fParam[0];
            float fDuration = fParam[1];

            // Check parameters
            // fDuration = 0.0f is valid - it means go as fast as possible...
            if( (fDuration < 0.0f) || (iFrameCount <= 0) )
                SS_ERROR( "MTKANIMATOR::SetMode: bad parameter\n" );
                return;
            nFrames = iFrameCount;
            msUpdateInterval = (UINT) ( (fDuration / (float) nFrames) * 1000.0f);
         }
            break;

        default :
            return;
    }
    mode = newMode;
}

/**************************************************************************\
* Start
*
* Start the animation by creating a new timer, if there is a valid animation
* callback function.
*
\**************************************************************************/

void
MTKANIMATOR::Start( )
{
    // Create new timer
    if( idTimer  || !AnimateFunc )
        return;  // Timer already running, or no animate func

    idTimer = SetTimer( hwnd, MTK_ANIMATE_TIMER_ID, msUpdateInterval, NULL );
    if( ! idTimer )
        SS_WARNING( "MTKANIMATOR::Start: SetTimer failure\n" );
}

/**************************************************************************\
* Stop
*
* Stop the animation by killing the timer.  Remove any WM_TIMER msgs
*
\**************************************************************************/

void
MTKANIMATOR::Stop( )
{
    if( !idTimer )
        return;

    if( ! KillTimer( hwnd, MTK_ANIMATE_TIMER_ID ) )
        SS_WARNING( "MTKANIMATOR::Stop: KillTimer failure\n" );

    // remove any timer messages from queue
    MSG Msg;
    PeekMessage( &Msg, hwnd, WM_TIMER, WM_TIMER, PM_REMOVE );
    idTimer = 0;
}

//mf: need better name for this
/**************************************************************************\
*
* Call the animate function
*
* A return value of FALSE indicates that an interval based animation has
* finished - TRUE otherwise.
*
\**************************************************************************/

BOOL
MTKANIMATOR::Draw( )
{
    if( !AnimateFunc )
        return TRUE;

    (*AnimateFunc)();

    if( mode == MTK_ANIMATE_INTERVAL ) {
        if( --nFrames <= 0 )
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\mtkdebug.h ===
/******************************Module*Header*******************************\
* Module Name: ssdebug.h
*
* Debugging stuff
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#ifndef __ssdebug_h__
#define __ssdebug_h__

ULONG DbgPrint(PCH Format, ...);

#define SS_LEVEL_ERROR 1L
#define SS_LEVEL_INFO  2L
#define SS_LEVEL_ENTRY 8L

#if DBG

extern long ssDebugMsg;
extern long ssDebugLevel;

#define SS_DBGPRINT( str )          DbgPrint("SS: " str )
#define SS_DBGPRINT1( str, a )      DbgPrint("SS: " str, a )
#define SS_DBGPRINT2( str, a, b )   DbgPrint("SS: " str, a, b )
#define SS_DBGPRINT3( str, a, b, c )   DbgPrint("SS: " str, a, b, c )
#define SS_DBGPRINT4( str, a, b, c, d )   DbgPrint("SS: " str, a, b, c, d )

#define SS_WARNING(str)             DbgPrint("SS: " str )
#define SS_WARNING1(str,a)          DbgPrint("SS: " str,a)
#define SS_WARNING2(str,a,b)        DbgPrint("SS: " str,a,b)

#define SS_RIP(str)                 {SS_WARNING(str); DebugBreak();}
#define SS_RIP1(str,a)              {SS_WARNING1(str,a); DebugBreak();}
#define SS_RIP2(str,a,b)            {SS_WARNING2(str,a,b); DebugBreak();}

#define SS_ASSERT(expr,str)            if(!(expr)) SS_RIP(str)
#define SS_ASSERT1(expr,str,a)         if(!(expr)) SS_RIP1(str,a)
#define SS_ASSERT2(expr,str,a,b)       if(!(expr)) SS_RIP2(str,a,b)

#define SS_ALLOC_FAILURE(str) \
    DbgPrint( "%s : Memory allocation failure\n", str );

#define SS_DBGMSG( str )         if( ssDebugMsg ) SS_DBGPRINT( str )
#define SS_DBGMSG1( str, a )     if( ssDebugMsg ) SS_DBGPRINT1( str, a )
#define SS_DBGMSG2( str, a, b )  if( ssDebugMsg ) SS_DBGPRINT2( str, a, b )

//
// Use SS_DBGLEVEL for general purpose debug messages gated by an
// arbitrary warning level.
//
#define SS_DBGLEVEL(n,str)         if (ssDebugLevel >= (n)) SS_DBGPRINT(str)
#define SS_DBGLEVEL1(n,str,a)      if (ssDebugLevel >= (n)) SS_DBGPRINT1(str,a)
#define SS_DBGLEVEL2(n,str,a,b)    if (ssDebugLevel >= (n)) SS_DBGPRINT2(str,a,b)    

#define SS_ERROR(str)              SS_DBGLEVEL( SS_LEVEL_ERROR, str ) 
#define SS_ERROR1(str,a)           SS_DBGLEVEL1( SS_LEVEL_ERROR, str, a ) 
#define SS_ERROR2(str,a)           SS_DBGLEVEL2( SS_LEVEL_ERROR, str, a, b ) 

#define SS_DBGINFO(str)            SS_DBGLEVEL( SS_LEVEL_INFO, str ) 
#define SS_DBGINFO1(str,a)         SS_DBGLEVEL1( SS_LEVEL_INFO, str, a ) 
#define SS_DBGINFO2(str,a,b)       SS_DBGLEVEL2( SS_LEVEL_INFO, str, a, b ) 

#else

#define SS_DBGPRINT( str )
#define SS_DBGPRINT1( str, a )
#define SS_DBGPRINT2( str, a, b )
#define SS_DBGPRINT3( str, a, b, c )
#define SS_DBGPRINT4( str, a, b, c, d )

#define SS_WARNING(str)
#define SS_WARNING1(str,a)
#define SS_WARNING2(str,a,b)

#define SS_RIP(str)
#define SS_RIP1(str,a)
#define SS_RIP2(str,a,b)

#define SS_ASSERT(expr,str)         assert( expr )
#define SS_ASSERT1(expr,str,a)      assert( expr )
#define SS_ASSERT2(expr,str,a,b)    assert( expr )

#define SS_ALLOC_FAILURE(str)

#define SS_DBGMSG( str )
#define SS_DBGMSG1( str, a )
#define SS_DBGMSG2( str, a, b )

#define SS_DBGLEVEL(n,str)
#define SS_DBGLEVEL1(n,str,a)
#define SS_DBGLEVEL2(n,str,a,b)

#define SS_ERROR(str)
#define SS_ERROR1(str,a)
#define SS_ERROR2(str,a,b)

#define SS_DBGINFO(str)
#define SS_DBGINFO1(str,a)
#define SS_DBGINFO2(str,a,b)

#endif // DBG

#endif // __ssdebug_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\mtkwin.cxx ===
/******************************Module*Header*******************************\
* Module Name: mtkwin.cxx
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include "mtk.hxx"
#include "glutil.hxx"
#include "mtkwin.hxx"
#include "mtkwproc.hxx"
#include "mtkinit.hxx"

/**************************************************************************\
* MTKWIN constructor
*
\**************************************************************************/

MTKWIN::MTKWIN()
{
    Reset();
}

/**************************************************************************\
* Reset
*
* Reset parameters to default init state
\**************************************************************************/

void
MTKWIN::Reset()
{
    // Basic initialization

    bOwnWindow = FALSE;
    wFlags = 0;
    hwnd = 0;
    hdc = 0;
    hrc = 0;
    pos.x = pos.y = 0;
    size.width = size.height = 0;
    pBackBitmap =   NULL;
    pBackgroundBitmap =   NULL;
    bDoubleBuf =    FALSE;
    bFullScreen =   FALSE;
    execRefCount =  0;

    ReshapeFunc =   NULL;
    RepaintFunc =   NULL;
    DisplayFunc =   NULL;
    MouseMoveFunc = NULL;
    MouseDownFunc = NULL;
    MouseUpFunc =   NULL;
    KeyDownFunc =   NULL;

    FinishFunc =    NULL;
    DataPtr =       NULL;
}

/**************************************************************************\
* MTKWIN destructor
*
* This can be called when a window is closed, or by the ss client
*
\**************************************************************************/

MTKWIN::~MTKWIN()
{
//mf: !!! we're in trouble if user calls this directly, because would then need to
// post a DESTROY msg, here putting us in an endless loop...
// -> could have a flag set so we know if user or internal call

//mf: another potential timing problem here : If user calls MTKWIN::Return(),
// which posts an MTK_WM_RETURN msg to the windows queue, and then calls here
// before the msg is processed, we could delete the MTKWIN here before exiting
// the msg loop.  So here we should make sure the msg loop is exited by
// calling Return() or something.  This should be easy to verify via a
// reference count

    if( execRefCount ) {
        SS_ERROR1( "MTKWIN::~MTKWIN : execRefCount is %d\n", execRefCount );
        // mf: ? can we exit the msg loop here ?
//mf: this din't get through
#if 1
        SendMessage( hwnd, MTK_WM_RETURN, 0, 0l );
#else
        if( ! PostMessage( hwnd, MTK_WM_RETURN, 0, 0l ) )
            SS_ERROR( "MTKWIN dtor : MTK_WM_RETURN msg not posted\n" );
#endif
        
    }

    if( pBackBitmap )
        delete pBackBitmap;

    if( pBackgroundBitmap )
        delete pBackgroundBitmap;

    if( hwnd ) {
        animator.Stop();
        // Remove from SSWTable
        sswTable.Remove( hwnd );
    }

    // Clean up GL

//mf: !!!
//mf: This assumes FinishFunc is only related to gl
    if( hrc ) {
        // FinishFunc still needs gl
        if( FinishFunc )
#if 0
            (*FinishFunc)( DataPtr );
#else
            (*FinishFunc)();
#endif

        wglMakeCurrent( NULL, NULL );
        if( ! (wFlags & SS_HRC_PROXY_BIT) )
            wglDeleteContext( hrc );
    }

    //  Release the dc
    if( hdc ) {
        HWND hwndForHdc = hwnd;
        ReleaseDC(hwndForHdc, hdc);
    }
}

/**************************************************************************\
* Create
*
* Create window.
*
\**************************************************************************/

BOOL
MTKWIN::Create( LPCTSTR pszWindowTitle, ISIZE *pSize, IPOINT2D *pPos,
                UINT winConfig, WNDPROC userWndProc )
{
    HWND    hwndParent;
    UINT    uStyle = 0;
    UINT    uExStyle = 0;
    HINSTANCE  hInstance;
    int     width, height;

    if( ! mtk_Init( this ) )
        return FALSE;
    
    bOwnWindow = TRUE; // We're creating the window, it's not a wrapper

    if( winConfig & MTK_FULLSCREEN ) {
//mf: this really only valid if no border
        bFullScreen = TRUE;
        pos.x = 0;
        pos.y = 0;
        size.width = GetSystemMetrics( SM_CXSCREEN );
        size.height = GetSystemMetrics( SM_CYSCREEN );
        uExStyle |= WS_EX_TOPMOST;
    } else {
        pos = *pPos;
        size = *pSize;
    }

    LPCTSTR pszClass;
    HBRUSH hBrush = ghbrbg;
    HCURSOR hCursor = ghArrowCursor;
    WNDPROC wndProc;

    if( bTransparent = (winConfig & MTK_TRANSPARENT) ) {
        uExStyle |= WS_EX_TRANSPARENT;
        hBrush = NULL;
    }

//mf: if winsize, winpos NULL, pick default size, pos
    if( winConfig & MTK_NOBORDER ) {
        uStyle |= WS_POPUP;
        width = size.width;
        height = size.height;
    } else {
        uStyle |= WS_OVERLAPPEDWINDOW;
        /*
         *  Make window large enough to hold a client area of requested size
         */
        RECT WinRect;

//mf: either of these should work
#if 0
        WinRect.left   = 0;
        WinRect.right  = size.width;
        WinRect.top    = 0;
        WinRect.bottom = size.height;
#else
        WinRect.left   = pos.x;
        WinRect.right  = pos.x + size.width;
        WinRect.top    = pos.y;
        WinRect.bottom = pos.y + size.height;
#endif

        AdjustWindowRectEx(&WinRect, uStyle, FALSE, uExStyle );
        width = WinRect.right - WinRect.left;
        height = WinRect.bottom - WinRect.top;
    }

    if( winConfig & MTK_NOCURSOR )
        hCursor = NULL;

    if( userWndProc )
        wndProc = userWndProc;
    else
        wndProc = mtkWndProc;

    // Register window class
    pszClass = mtk_RegisterClass( wndProc, NULL, hBrush, hCursor );

    hInstance = GetModuleHandle( NULL );
    hwndParent = NULL; // for now
    
    hwnd = CreateWindowEx(
                                 uExStyle,
                                 pszClass,
                                 pszWindowTitle,
                                 uStyle,
                                 pos.x,
                                 pos.y,
                                 width,
                                 height,
                                 hwndParent,
                                 NULL,               // menu
                                 hInstance,
                                 (LPVOID) this
                                );

    if (!hwnd) {
        SS_WARNING( "SSW::CreateSSWindow : CreateWindowEx failure\n" );
        return FALSE;
    }

    if( bTransparent ) {
        // Create a bitmap buffer that tracks the window size.  This will be
        // used to store a window background.
        ConfigureForGdi();
        pBackgroundBitmap = new MTKBMP( hdc );
        if( !pBackgroundBitmap ) {
            SS_WARNING( "MTKWIN::Create: couldn't create background bitmap\n" );
        } else {
            // Set bitmap's size to the window's size
            pBackgroundBitmap->Resize( &size );
        }
    }

    animator.SetHwnd( hwnd );

    ShowWindow(hwnd, SW_SHOW);

    return TRUE;
}

/**************************************************************************\
* ConfigureForGdi
*
* Creates an hdc for the window
*
\**************************************************************************/

BOOL
MTKWIN::ConfigureForGdi()
{
    if( hdc )
        // already configured
        return TRUE;

    // Figure window to get hdc from
#if 0
    HWND hwndForHdc = hwnd ? hwnd : psswParent ? psswParent->hwnd : NULL;
#else
    HWND hwndForHdc = hwnd;
#endif

    if( !hwndForHdc || !(hdc = GetDC(hwndForHdc)) ) {
        SS_WARNING( "SSW::ConfigureForGdi failed\n" );
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************\
* ConfigureForGL
*
* Creates a GL rendering context for the specified window
*
\**************************************************************************/

BOOL
MTKWIN::Config( UINT glConfig )
{
    return Config( glConfig, NULL );
}

BOOL
MTKWIN::Config( UINT glConfig, PVOID pConfigData )
{
    if( hrc )
        // Already configured...
        return TRUE;

    if( ConfigureForGdi() &&
        (hrc = hrcSetupGL( glConfig, pConfigData )) )
        return TRUE;

    SS_WARNING( "SSW::ConfigureForGL failed\n" );
    return FALSE;
}

/**************************************************************************\
* hrcSetupGL
*
* Setup OpenGL.
*
\**************************************************************************/

#define NULL_RC ((HGLRC) 0)

HGLRC 
MTKWIN::hrcSetupGL( UINT glConfig, PVOID pData )
{
    HGLRC hrc;
    HDC hgldc;
    int pfFlags = 0;
    PIXELFORMATDESCRIPTOR pfd = {0};

    // Setup pixel format flags

    // Double buffering can either be done with a double-buffered pixel
    // format, or by using a local back buffer bitmap that tracks the window
    // size.  The latter allows us more control with buffer swaps.

    bDoubleBuf = glConfig & MTK_DOUBLE;
    BOOL bBitmapBackBuf = glConfig & MTK_BITMAP;
    if( bDoubleBuf ) {
        if( bBitmapBackBuf ) 
            pfFlags |= SS_BITMAP_BIT;
        else
            pfFlags |= SS_DOUBLEBUF_BIT;
    }
    if( glConfig & MTK_DEPTH )
        pfFlags |= SS_DEPTH32_BIT;
    if( glConfig & MTK_DEPTH16 )
        pfFlags |= SS_DEPTH16_BIT;
    if( glConfig & MTK_ALPHA )
        pfFlags |= SS_ALPHA_BIT;
    

    // If preview mode or config mode, don't allow pixel formats that need
    // the system palette, as this will create much ugliness.
    if( !bFullScreen )
        pfFlags |= SS_NO_SYSTEM_PALETTE_BIT;

//mf: don't really need pixel format for window if using back bitmap method,
// but if user wants to draw to front buffer, then we'll need it.  So, we'll
// always set it here.
    if( !SSU_SetupPixelFormat( hdc, pfFlags, &pfd ) )
        return NULL_RC;

//mf: ???
    // Update pfFlags based on pfd returned
    // !!! mf: klugey, fix after SUR
    // (for now, the only ones we care about are the generic/accelerated flags)
    if(  (pfd.dwFlags & (PFD_GENERIC_FORMAT|PFD_GENERIC_ACCELERATED))
		 == PFD_GENERIC_FORMAT )
        pfFlags |= SS_GENERIC_UNACCELERATED_BIT;

    if( SSU_bNeedPalette( &pfd ) ) {
        // Note: even if bStretch, need to set up palette here so they match
        if( !gpssPal ) {
            SS_PAL *pssPal;
#if 1
            BOOL bTakeOverPalette = bFullScreen ? TRUE : FALSE;
#else
//mf: For next rev, we don't have to force palette takeover - but it will
// automically be invoked for any case like MCD, etc.
            BOOL bTakeOverPalette = FALSE;
#endif

            // The global palette has not been created yet - do it
            // SS_PAL creation requires pixel format descriptor for color bit
            // information, etc. (the pfd is cached in SS_PAL, since for
            // palette purposes it is the same for all windows)
            pssPal = new SS_PAL( hdc, &pfd, bTakeOverPalette );
            if( !pssPal )
                return NULL_RC;
            // Set approppriate palette manage proc
            if( bFullScreen )
                pssPal->paletteManageProc = FullScreenPaletteManageProc;
            else
                // use regular palette manager proc
                pssPal->paletteManageProc = PaletteManageProc;
            gpssPal = pssPal;
        }
        // Realize the global palette in this window
        //mf: assume we're realizing in foreground
        HWND hwndPal = hwnd;
        if( hwndPal )
            gpssPal->Realize( hwndPal, hdc, FALSE );
    }

    if( bBitmapBackBuf ) {
        pBackBitmap = new MTKBMP( hdc );
        if( !pBackBitmap ) {
            SS_WARNING( "MTKWIN::hrcSetupGL : couldn't create back bitmap\n" );
            return NULL_RC;
        }
        // Set bitmap's size to the window's size
        pBackBitmap->Resize( &size );
        hgldc = pBackBitmap->hdc;
        // Setup pixelformat
        if( !SSU_SetupPixelFormat( hgldc, pfFlags, &pfd ) )
            return NULL_RC;
        // If window needed a palette, so does the bitmap...
        if( gpssPal )
            SSDIB_UpdateColorTable( hgldc, hdc, gpssPal->hPal );
    } else {
        hgldc = hdc;
    }

    // Create a new hrc
    hrc = wglCreateContext(hgldc);

    if( !hrc || !wglMakeCurrent(hgldc, hrc) ) {
        SS_WARNING( "SSW::hrcSetupGL : hrc context failure\n" );
        return NULL_RC;
    }

    SS_DBGLEVEL2( SS_LEVEL_INFO, 
        "SSW::hrcSetupGL: wglMakeCurrent( hrc=0x%x, hwnd=0x%x )\n", hrc, hwnd );

//mf: Note that these queries are based on a single gl window screen saver.  In
// a more complicated scenario, these capabilities could be queried on a
// per-window basis (since support could vary with pixel formats).

    gGLCaps.Query();

    // Send another reshape msg to the app, since the first one on window
    // create would have been sent before we had an rc
    Reshape();

    return hrc;
}

/**************************************************************************\
* MakeCurrent
*
* Call wglMakeCurrent for this window's hrc.  Note: an ss client may have
* more than one hrc (e.g. pipes), in which case it is the client's
* responsibility to make current.
\**************************************************************************/

void
MTKWIN::MakeCurrent()
{
    if( ! wglMakeCurrent( hdc, hrc ) )
        SS_WARNING( "SSW::MakeCurrent : wglMakeCurrent failure\n" );
}

// Callback functions:

/******************************Public*Routine******************************\
* ss_ReshapeFunc
*
\**************************************************************************/

void 
MTKWIN::SetReshapeFunc(MTK_RESHAPEPROC Func)
{
    ReshapeFunc = Func;
}

/******************************Public*Routine******************************\
* ss_RepaintFunc
*
\**************************************************************************/

void 
MTKWIN::SetRepaintFunc(MTK_REPAINTPROC Func)
{
    RepaintFunc = Func;
}

void 
MTKWIN::SetDisplayFunc(MTK_DISPLAYPROC Func)
{
    DisplayFunc = Func;
}

/******************************Public*Routine******************************\
* SetAnimateFunc
*
\**************************************************************************/

void 
MTKWIN::SetAnimateFunc(MTK_ANIMATEPROC Func )
{
    animator.SetFunc( Func );
    // If we are in msg loop and Func is non-NULL, have to make sure 
    // animator starts again... (awkward).  If animator was already started,
    // this will do nothing
    if( execRefCount && Func )
        animator.Start();
}

/******************************Public*Routine******************************\
* Animate
*
* Call the animation function
*
* If animate mode is interval (as opposed to continuous),
* animate the number of supplied frames.  The animation count is decremented
* by the WndProc processing the WM_TIMER messages.  Exits the msg loop when
* the desired number fo frames has been animated.
*
\**************************************************************************/

//mf: had to rename from Animate to mtkAnimate due to name conflicts at link
// time

void
MTKWIN::mtkAnimate()
{
    if( ! animator.Draw() )
        Return();
}


/******************************Public*Routine******************************\
* SetAnimateMode
*
*
\**************************************************************************/

void
MTKWIN::SetAnimateMode( UINT mode, float *fParam )
{
    animator.SetMode( mode, fParam );
}

/******************************Public*Routine******************************\
* Exec
*
* Starts the message loop for the window.
*
* If an animation has been requested prior to this call, then a new animation
* timer is setup.  This msg loop can terminate in the following ways :
*   1) The window is closed
*   2) An interval animation was requested, and the required number of frames
*      have been drawn
*   3) The user calls MTKWIN::Return(), which will cause the MTKWIN::Exec()
*      call to return
*
* For now :
* Returns TRUE on normal termination, FALSE if the window it's animating in
* gets closed.
*
\**************************************************************************/

BOOL
MTKWIN::Exec()
{
    // If user is already in here, get out
    if( execRefCount )
        return TRUE;
    execRefCount++;

    // Stop any existing timer (this will flush WM_TIMER msg's)
    animator.Stop();

    // Start new animation timer (if animator modes are set)
    animator.Start();

    MSG msg;
    BOOL bNotQuitMsg;
    while( bNotQuitMsg = GetMessage( &msg, hwnd, 0, 0 ) )
    {
        if( msg.message == MTK_WM_RETURN ) {
            // User or mtk wants to terminate msg loop and return control
            // (mf: could pick up return parameter here...)
//            SS_DBGPRINT1( "MTKWIN::Exec got WM_RETURN for %p\n", this );
            break;
        }
//mf: ? better way of doing this ?
        else if( ! msg.hwnd ) {
            // Window has been destroyed, get out !
            SS_DBGPRINT( "MTKWIN::Exec : hwnd = 0, forcing msg loop exit\n" );
            return FALSE;
        }
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    animator.Stop();

    execRefCount--;

    if( bNotQuitMsg )
        return TRUE;
    else {
        SS_DBGPRINT1( "MTKWIN::Exec got WM_QUIT for %p\n", this );
        return FALSE;
    }
}

/******************************Public*Routine******************************\
* Return
*
* Called by the user when they want to return from the Exec() call which
* started the message loop.
*
* mf: could include parameter here
*
\**************************************************************************/

void
MTKWIN::Return() 
{
    animator.Stop();
    PostMessage( hwnd, MTK_WM_RETURN, 0, 0l );
}

void 
MTKWIN::SetMouseMoveFunc(MTK_MOUSEMOVEPROC Func)
{
    MouseMoveFunc = Func;
}

void 
MTKWIN::SetMouseUpFunc(MTK_MOUSEUPPROC Func)
{
    MouseUpFunc = Func;
}

void 
MTKWIN::SetMouseDownFunc(MTK_MOUSEDOWNPROC Func)
{
    MouseDownFunc = Func;
}

void 
MTKWIN::SetKeyDownFunc(MTK_KEYDOWNPROC Func)
{
    KeyDownFunc = Func;
}

void 
MTKWIN::GetMouseLoc( int *x, int *y )
{
    POINT Point;

    *x = 0;
    *y = 0;

    GetCursorPos(&Point);

    /*
     *  GetCursorPos returns screen coordinates,
     *  we want window coordinates
     */

    *x = Point.x - pos.x;
    *y = Point.y - pos.y;
}

void
MTKWIN::Close()
{
    DestroyWindow( hwnd );
}

/******************************Public*Routine******************************\
* ss_FinishFunc
*
\**************************************************************************/

void 
MTKWIN::SetFinishFunc(MTK_FINISHPROC Func)
{
    FinishFunc = Func;
}

/**************************************************************************\
* Resize
*
* Resize wrapper
*
* Called in response to WM_SIZE.
*
\**************************************************************************/

void
MTKWIN::Resize( int width, int height )
{
    size.width  = width;
    size.height = height;

    if( pBackBitmap )
        pBackBitmap->Resize( &size );
    if( pBackgroundBitmap )
        pBackgroundBitmap->Resize( &size );
    Reshape();
}

/**************************************************************************\
* Repaint
*
* Repaint wrapper
*
* Called in response to WM_PAINT.
*
\**************************************************************************/

#define NULL_UPDATE_RECT( pRect ) \
     (  ((pRect)->left == 0) && \
        ((pRect)->right == 0) && \
        ((pRect)->top == 0) && \
        ((pRect)->bottom == 0) )

void
MTKWIN::Repaint( BOOL bCheckUpdateRect )
{
    if( !hwnd )
        return;

    RECT rect, *pRect = NULL;

    if( bCheckUpdateRect ) {
        GetUpdateRect( hwnd, &rect, FALSE );
//mf
    SS_DBGPRINT4( "MTKWIN::Repaint rect: %d - %d, %d - %d\n", rect.left, rect.right,
                   rect.top, rect.bottom );
        // mf: Above supposed to return NULL if rect is all 0's, 
        // but this doesn't happen
        if( NULL_UPDATE_RECT( &rect ) )
            return;
        pRect = &rect;
    }

    // transparent window thing
    if( pBackgroundBitmap ) {
        if( !pRect ) {
            // UpdateBg doesn't handle null rect
            pRect = &rect;
            GetClientRect( hwnd, pRect );
        }
        UpdateBackgroundBitmap( pRect );
    }

#if 0
    if( RepaintFunc )
        (*RepaintFunc)( pRect );
#else
#if 0
    Display();
#else
//mf: test: ? help bg update problem ?? nope, din't seem to...
    MSG Message;
    if (!PeekMessage(&Message, hwnd, MTK_WM_REDRAW, MTK_WM_REDRAW, PM_NOREMOVE) )
    {
        PostMessage( hwnd, MTK_WM_REDRAW, 0, 0l );
    }
#endif
#endif
}

void
MTKWIN::Display()
{
    if( DisplayFunc )
        (*DisplayFunc)();
}

//mf: not using these in current scheme, although might if use 'ss' mode
#if 0
/**************************************************************************\
* UpdateWindow
*
* Update the window
*
* Currently this assumes all windows are being animated (i.e. not showing
*   a static image)
*
* Things *must* happen in the order defined here, so they work on generic as
* well as hardware implementations.
* Note: Move must happen after SwapBuf, and will cause some encroaching on
* the current display, as the parent window repaints after the move.  Therefore
* apps must take care to leave an empty border around their rendered image,
* equal to the maximum window move delta.
*
\**************************************************************************/

void
MTKWIN::UpdateWindow()
{ 
    if( !AnimateFunc )
        return;

    // bDoubleBuf and pStretch should be mutually exclusive...

    if( bDoubleBuf ) {
        UpdateDoubleBufWin();
    } else {
//mf: ? where's the clearing here ?  (true, no one uses this path...)
#if 0
        (*AnimateFunc)( DataPtr );
#else
        (*AnimateFunc)();
#endif
    }
}

/**************************************************************************\
* UpdateDoubleBufWin
*
* This is used when moving a double buffered window around.  It will
* work for all configurations.
*
\**************************************************************************/

void
MTKWIN::UpdateDoubleBufWin()
{ 
    RECT updateRect;

    // Update the back buffer

#if 0
    (*AnimateFunc)( DataPtr );
#else
    (*AnimateFunc)();
#endif

    // Swap to the new window position
    SwapBuffers( hdc );
}
#endif

/**************************************************************************\
* GetSSWindowRect
*
* Return window position and size in supplied RECT structure
*
* - This rect is relative to the parent
\**************************************************************************/

void
MTKWIN::GetSSWindowRect( LPRECT lpRect )
{
    lpRect->left = pos.x;
    lpRect->top = pos.y;
    lpRect->right = pos.x + size.width;
    lpRect->bottom = pos.y + size.height;
}

/**************************************************************************\
* GLPosY
*
* Return y-coord of window position in GL coordinates (a win32 window position
* (starts from top left, while GL starts from bottom left)
*
\**************************************************************************/

int
MTKWIN::GLPosY()
{
//mf: !!!
#if 0
    return psswParent->size.height - size.height - pos.y;
#else
    return 0;
#endif
}


/**************************************************************************\
* SwapBuffers
*
\**************************************************************************/

//mf: name problem...
void
MTKWIN::mtkSwapBuffers()
{
    if( bDoubleBuf ) {
        if( pBackBitmap )
            CopyBackBuffer();
        else
            SwapBuffers( hdc );
    }
}

/**************************************************************************\
*
*
\**************************************************************************/

void
MTKWIN::Flush()
{
    glFlush();
    if( bDoubleBuf ) {
        mtkSwapBuffers();
    }
}

/**************************************************************************\
* CopyBackBuffer
*
* Like SwapBuffers, but copies from local bitmap to front buffer
*
* Also capable of copying over 1 or more rects of the bitmap, rather than the
* whole thing. mf: Might need local implementation of swaphintrect here, to
* collect and reduce the rects
\**************************************************************************/

void
MTKWIN::CopyBackBuffer()
{
    if( !pBackBitmap )
        return;

    // Do a BitBlt from back buffer to the window (may as well put stretch in
    // here ?

    if( (size.width == pBackBitmap->size.width) &&
        (size.height == pBackBitmap->size.height) ) // buffers same size
    {
        BitBlt(hdc, 0, 0, size.width, size.height,
               pBackBitmap->hdc, 0, 0, SRCCOPY);
    }
    else
    {
        SS_WARNING( "MTKWIN::CopyBackBuffer: bitmap size mismatch\n" );
        StretchBlt(hdc, 0, 0, 
                   size.width, size.height,
                   pBackBitmap->hdc, 0, 0, 
                   pBackBitmap->size.width, pBackBitmap->size.height,
                   SRCCOPY);
    }
    GdiFlush();
}


/**************************************************************************\
* UpdateBackgroundBitmap
*
* Updates the background bitmap with screen bits
*
\**************************************************************************/

void
MTKWIN::UpdateBackgroundBitmap( RECT *pRect )
{
    if( !pBackgroundBitmap ) {
        SS_WARNING( "MTKWIN::UpdateBackgroundBitmap : No background bitmap\n" );
        return;
    }

//  mf:!!!  handle update rect parameter
    MTKBMP *pBmpDest = pBackgroundBitmap;

    // Get a screen DC
    HDC hdcScreen = GetDC( NULL );

#if DBG
    if( !hdcScreen ) {
        SS_WARNING( "MTKWIN::UpdateBackgroundBitmap : failed to get screen hdc\n" );
        return;
    }
#endif

//mf
#if 0
    SS_DBGPRINT4( "MTKWIN::UpdateBackgroundBitmap : %d - %d, %d - %d\n", pRect->left, pRect->right,
                   pRect->top, pRect->bottom );
#endif
    // Calc the screen origin of the window
    RECT screenRect = {0, 0 }; // just need left and top points
    MapWindowPoints( hwnd, NULL, (POINT *) &screenRect, 2 );

    // Offset screenRect with the supplied rect
    screenRect.left += pRect->left;
    screenRect.top += pRect->top;
    // Set update size
//mf: thought I should have to add 1 here, but I guess pRect is non-inclusive...
    ISIZE updateSize = { pRect->right - pRect->left,
                         pRect->bottom - pRect->top };

    if( (size.width == pBmpDest->size.width) &&
        (size.height == pBmpDest->size.height) ) // buffers same size
    {
        BitBlt(pBmpDest->hdc, 
               pRect->left, pRect->top, 
               updateSize.width, updateSize.height,
               hdcScreen, 
               screenRect.left, screenRect.top, SRCCOPY);
    }
    else
    {
#if 0
//mf: ignore this for now
        // Shouldn't happen, since BackgroundBitmap tracks window size
        StretchBlt(pBmpDest->hdc, 0, 0, 
                   pBmpDest->size.width, pBmpDest->size.height,
                   hdcScreen, screenRect.left, screenRect.top, 
                   size.width, size.height,
                   SRCCOPY);
#else
        SS_WARNING( "MTKWIN::UpdateBackgroundBitmap : bitmap size mismatch\n" );
#endif
    }
    GdiFlush();
}

/**************************************************************************\
* ClearToBackground
*
* Copy from the background bitmap to the window.  If the window is doublebuf,
* then we copy to the backbuffer instead of the window.
*
\**************************************************************************/

void
MTKWIN::ClearToBackground()
{
    if( !pBackgroundBitmap ) {
        SS_WARNING( "MTKWIN::ClearToBackgournd : No background bitmap\n" );
        return;
    }

    MTKBMP *pBmpSrc = pBackgroundBitmap;

    HDC hdcDest;
    if( bDoubleBuf ) {
        if( !pBackBitmap )
            return;
//mf: assumption here that backbitmap size is same as window
        hdcDest = pBackBitmap->hdc;
    } else
        hdcDest = hdc;

    if( (size.width == pBmpSrc->size.width) &&
        (size.height == pBmpSrc->size.height) ) // buffers same size
    {
        BitBlt(hdcDest, 0, 0, size.width, size.height,
               pBmpSrc->hdc, 0, 0, SRCCOPY);
    }
    else
    {
        StretchBlt(hdcDest, 0, 0, 
                   size.width, size.height,
                   pBmpSrc->hdc, 0, 0, 
                   pBmpSrc->size.width, pBmpSrc->size.height,
                   SRCCOPY);
    }
    GdiFlush();
}


/**************************************************************************\
* Reshape
*
* Reshape wrapper

* Sends reshape msg to screen saver
* This is the size of the surface that gl renders onto, which can be a bitmap.
*
\**************************************************************************/

void
MTKWIN::Reshape()
{
    // Point to size of window, or bitmap if it has one
    ISIZE *pSize = &size;

    // If the window has an hrc, set default viewport
//mf: so app doesn't have to worry about it ?

    if( hrc ) {
        glViewport( 0, 0, pSize->width, pSize->height );
    }

    if( ReshapeFunc ) {
#if 0
        (*ReshapeFunc)( pSize->width, pSize->height, DataPtr );
#else
        (*ReshapeFunc)( pSize->width, pSize->height );
#endif
    }
}

/******************************Public*Routine******************************\
* GdiClear
*
* Clears window using Gdi FillRect
\**************************************************************************/

void
MTKWIN::GdiClear()
{
    if( !hdc )
        return;

    RECT rect;

    GetClientRect( hwnd, &rect );

//mf: rect is exclusive, so shouldn't we have to add 1 ?
    FillRect( hdc, &rect, ghbrbg );
    GdiFlush();
}

//mf: unicode...
void
MTKWIN::SetTitle( char *title )
{
    SetWindowText( hwnd, title );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\mtk.h ===
/******************************Module*Header*******************************\
* Module Name: mtk.h
*
* Defines and externals for m toolkit
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#ifndef __mtk_h__
#define __mtk_h__

#include <windows.h>
#include <assert.h>

#include "tk.h"

#ifdef __cplusplus
extern "C" {
#endif

#include "mtkdebug.h"
#include "trackbal.h"

#define FAILURE             0
#define SUCCESS             1

// Maximum texture bitmap dimensions.

#define TEX_WIDTH_MAX   1280
#define TEX_HEIGHT_MAX  1024

#define PI 3.14159265358979323846f
// double version of PI
#define PI_D 3.14159265358979323846264338327950288419716939937510
#define ONE_OVER_PI (1.0f / PI)
#define ROOT_TWO 1.414213562373f

#define GEN_STRING_SIZE 64

// texture quality level
enum {
    TEXQUAL_DEFAULT = 0,
    TEXQUAL_HIGH
};

typedef struct _point2d {
    GLfloat x;
    GLfloat y;
} POINT2D;

typedef struct _ipoint2d {
    int x;
    int y;
} IPOINT2D;

typedef struct _point3d {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} POINT3D;

typedef struct _dpoint3d {
    GLdouble x;
    GLdouble y;
    GLdouble z;
} DPOINT3D;

typedef struct _ipoint3d {
    int x;
    int y;
    int z;
} IPOINT3D;

typedef struct _texpoint2d {
    GLfloat s;
    GLfloat t;
} TEX_POINT2D;

typedef struct _isize {
    int width;
    int height;
} ISIZE;

typedef struct _fsize {
    GLfloat width;
    GLfloat height;
} FSIZE;

typedef struct _glrect {
    float   x, y;
    float   width, height;
} GLRECT;

typedef struct _glirect {
    int x, y;
    int width, height;
} GLIRECT;

#ifndef GL_EXT_paletted_texture
#define GL_COLOR_INDEX1_EXT                   0x80E2
#define GL_COLOR_INDEX2_EXT                   0x80E3
#define GL_COLOR_INDEX4_EXT                   0x80E4
#define GL_COLOR_INDEX8_EXT                   0x80E5
#define GL_COLOR_INDEX12_EXT                  0x80E6
#define GL_COLOR_INDEX16_EXT                  0x80E7
typedef void (APIENTRY * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, GLvoid *data);
#endif

// texture resource

#define RT_RGB          99
#define RT_MYBMP        100
#define RT_A8           101

// texture resource types
enum {
    TEX_UNKNOWN = 0,
    TEX_RGB,
    TEX_BMP,
    TEX_A8
};

typedef struct {
    int     type;
    int     name;
} TEX_RES;

typedef struct _MATRIX {
    GLfloat M[4][4];
} MATRIX;

typedef struct strRGBA {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
} RGBA;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
} RGB8;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
    BYTE a;
} RGBA8;

// Defines for pixel format (internal use)
#define SS_DOUBLEBUF_BIT    (1 << 0)
#define SS_DEPTH16_BIT      (1 << 1)
#define SS_DEPTH32_BIT      (1 << 2)
#define SS_ALPHA_BIT        (1 << 3)
#define SS_BITMAP_BIT       (1 << 4)
#define SS_NO_SYSTEM_PALETTE_BIT       (1 << 5)
#define SS_GENERIC_UNACCELERATED_BIT   (1 << 6)

#define SS_HAS_DOUBLEBUF(x) ((x) & SS_DOUBLEBUF_BIT)
#define SS_HAS_DEPTH16(x)	((x) & SS_DEPTH16_BIT)
#define SS_HAS_DEPTH32(x)	((x) & SS_DEPTH32_BIT)
#define SS_HAS_ALPHA(x)     ((x) & SS_ALPHA_BIT)
#define SS_HAS_BITMAP(x)    ((x) & SS_BITMAP_BIT)

typedef struct _MATERIAL {
    RGBA ka;
    RGBA kd;
    RGBA ks;
    GLfloat specExp;
} MATERIAL;

// texture file info

//mf: !!!, uhhh not yet
#if 1
typedef struct {
    int     nOffset;  // filename offset into pathname
    TCHAR   szPathName[MAX_PATH];  // texture pathname
} TEXFILE;
#else
typedef struct {
    int     nOffset;  // filename offset into pathname
    LPTSTR  szPathName;
} TEXFILE;
#endif

// Useful macros

#define SS_MAX( a, b ) \
    ( a > b ? a : b )

#define SS_MIN( a, b ) \
    ( a < b ? a : b )

// macro to round up floating values
#define SS_ROUND_UP( fval ) \
    ( (((fval) - (FLOAT)(int)(fval)) > 0.0f) ? (int) ((fval)+1.0f) : (int) (fval) )

// macros to clamp a value within a range
#define SS_CLAMP_TO_RANGE( a, lo, hi ) ( (a < lo) ? lo : ((a > hi) ? hi : a) )
#define SS_CLAMP_TO_RANGE2( a, lo, hi ) \
    ( a = (a < lo) ? lo : ((a > hi) ? hi : a) )

// degree<->radian macros
#define ONE_OVER_180 (1.0f / 180.0f)
#define SS_DEG_TO_RAD( a ) ( (a*PI) * ONE_OVER_180 )
#define SS_RAD_TO_DEG( a ) ( (a*180.0f) * ONE_OVER_PI )

// window related

extern void mtkQuit();  // Harsh way to kill the app
//extern int mtk_Exec();  // like tkExec()

// pixel forat

extern BOOL SSU_SetupPixelFormat( HDC hdc, int flags, PIXELFORMATDESCRIPTOR *ppfd );
extern BOOL SSU_bNeedPalette( PIXELFORMATDESCRIPTOR *ppfd );
extern int SSU_PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd );

// material processing

extern void ss_InitTeaMaterials();
extern void ss_InitTexMaterials();
extern void ss_InitMaterials();
extern void ss_SetMaterial( MATERIAL *pMat );
extern void ss_SetMaterialIndex( int index );
extern MATERIAL *ss_RandomTeaMaterial( BOOL bSet );
extern int  ss_RandomTeaMaterialIndex( BOOL bSet );
extern MATERIAL *ss_RandomTexMaterial( BOOL bSet );
extern int  ss_RandomTexMaterialIndex( BOOL bSet );
extern void ss_CreateMaterialGradient( MATERIAL *matInc, MATERIAL *startMat,
                        MATERIAL *endMat, int transCount );
extern void ss_TransitionMaterial( MATERIAL *transMat, MATERIAL *transMatInc );

// color

extern void ss_HsvToRgb(float h, float s, float v, RGBA *color );

// clear

extern int mtk_RectWipeClear( int width, int height, int repCount );
extern int mtk_DigitalDissolveClear( int width, int height, int size );

// utility

extern void ss_RandInit( void );
extern int ss_iRand( int max );
extern int ss_iRand2( int min, int max );
extern FLOAT ss_fRand( FLOAT min, FLOAT max );
extern BOOL mtk_ChangeDisplaySettings( int width, int height, int bitDepth );
extern void mtk_RestoreDisplaySettings();
extern void ss_QueryDisplaySettings( void );
extern void mtk_QueryGLVersion( void );
extern BOOL mtk_fOnWin95( void );
extern BOOL mtk_fOnNT35( void );
extern BOOL mtk_fOnGL11( void );
extern BOOL mtk_bAddSwapHintRect();
extern HBITMAP
SSDIB_CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight,
                    PVOID *ppvBits);
extern BOOL APIENTRY SSDIB_UpdateColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal);


// texture file processing

extern BOOL mtk_VerifyTextureFilePath( TEXFILE *ptf );
extern BOOL mtk_VerifyTextureFileData( TEXFILE *ptf );
extern void mtk_InitAutoTexture( TEX_POINT2D *pTexRep );

// texture objects

extern BOOL mtk_TextureObjectsEnabled( void );

// Paletted texture support
extern BOOL mtk_PalettedTextureEnabled(void);
extern BOOL mtk_QueryPalettedTextureEXT(void);

// math functions

extern POINT3D ss_ptZero;
extern void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_matrixIdent(MATRIX *);
extern void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta);
extern void ss_matrixTranslate(MATRIX *, double xTrans, double yTrans, double zTrans);
extern void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 );
extern void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3);
extern void mtk_NormalizePoints(POINT3D *, ULONG);

#ifdef __cplusplus
}
#endif

#endif // __mtk_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\mtkinit.cxx ===
/******************************Module*Header*******************************\
* Module Name: mtkinit.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>

#include "mtk.hxx"
#include "mtkwin.hxx"
#include "mtkwproc.hxx"
#include "mtkinit.hxx"

SS_PAL  *gpssPal = NULL;
HBRUSH  ghbrbg = (HBRUSH) 0; // global handle to background brush
HCURSOR ghArrowCursor;
BOOL    gbMessageLoopStarted = FALSE;
MTKWIN  *gpMtkwinMain = NULL; // 'main' or root window

// Global strings.
#define GEN_STRING_SIZE 64

// This windows class stuff bites
// These 2 aren't used for now, they might be templates for later
LPCTSTR pszMainWindowClass = TEXT("MtkMainClass");  // main class name
LPCTSTR pszUserWindowClass = TEXT("MtkUserClass");  // user class name

static TCHAR szClassName[5] = TEXT("0001" );
static LPTSTR pszCurClass = szClassName;

// forward declarations of internal fns

/**************************************************************************\
* GLDoScreenSave
*
* Runs the screen saver in the specified mode
*
* GL version of DoScreenSave in scrnsave.c
*
* Does basic init, creates initial set of windows, and starts the message
* loop, which runs until terminated by some event.
*
\**************************************************************************/

// Called by every window on creation

BOOL
mtk_Init( MTKWIN *pMtkwin )
{
    static BOOL bInited = FALSE;

    if( bInited )
        return TRUE;

    // Set root window

// !!! ATTENTION !!! this mechanism will fail when a thread destroys all windows,
// and then creates more
// -> use reference count in sswtable

    gpMtkwinMain = pMtkwin;

    // Initialize randomizer
    ss_RandInit();

    // Various globals
    gpssPal = NULL;

    // Create multi-purpose black bg brush
    ghbrbg = (HBRUSH) GetStockObject( BLACK_BRUSH );

    // For now (no ss) cursor is arrow
    ghArrowCursor = LoadCursor( NULL, IDC_ARROW );

    bInited = TRUE;
    return TRUE;
}

/**************************************************************************\
* mtk_RegisterClass
*
\**************************************************************************/

LPTSTR
mtk_RegisterClass( WNDPROC wndProc, LPTSTR pszClass, HBRUSH hbrBg, HCURSOR hCursor )
{
    WNDCLASS cls;
    LPTSTR pszTheClass;

    // If no class name provided, make one by pre-incrementing the current
    // class name.  (Can't icrement at end of function, since class used must
    // match return value

    if( !pszClass ) {
        pszCurClass[0] += 1;
        pszTheClass = pszCurClass;
    } else {
        pszTheClass = pszClass;
    }

    cls.style = CS_VREDRAW | CS_HREDRAW;
    cls.lpfnWndProc = wndProc;
    cls.cbClsExtra = 0;
    cls.cbWndExtra = 0;
    cls.hInstance = GetModuleHandle( NULL );
    cls.hIcon = LoadIcon( NULL, IDI_APPLICATION );
    cls.hCursor = hCursor;
    cls.hbrBackground = hbrBg;
    cls.lpszMenuName = (LPTSTR)NULL;
    cls.lpszClassName = pszTheClass;

    if( ! RegisterClass(&cls) )
        return NULL;

    return pszTheClass;
}

#if 0
/**************************************************************************\
* CloseWindows
*
* Close down any open windows.
*
* This sends a WM_CLOSE message to the top-level window if it is still open.  If
* the window has any children, they are also closed.  For each window, the
* SSW destructor is called.
\**************************************************************************/

void
SCRNSAVE::CloseWindows()
{
    if( psswMain ) {
        if( psswMain->bOwnWindow )
            DestroyWindow( psswMain->hwnd );
        else
            delete psswMain;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\texa8.cxx ===
/******************************Module*Header*******************************\
* Module Name: ssa8.c
*
* Operations on .a8 files
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "mtk.h"
#include "texture.hxx"

#define ESCAPE 0
#define ESC_ENDLINE 0
#define ESC_ENDBITMAP 1
#define ESC_DELTA 2
#define ESC_RANDOM 3
#define RANDOM_COUNT(c) ((c)-(ESC_RANDOM-1))

#define COUNT_SIZE 256
#define MAXRUN (COUNT_SIZE-1)
#define MAXRND (RANDOM_COUNT(COUNT_SIZE)-1)

typedef unsigned char *HwMem;
typedef unsigned long HwMemSize;
#define HW_UNALIGNED UNALIGNED

static HwMemSize HwuRld(HwMem src, HwMem dest, HwMemSize stride)
{
    unsigned short code;
    unsigned char run, esc;
    size_t len;
    HwMem s;
    HwMem f;

    s = src;
    f = dest;
    for (;;)
    {
#if 0
// orig
        code = *((unsigned short HW_UNALIGNED *)s)++;
#else
//        code = *( ((unsigned short *)s)++ );
//mf: will this incremement OK ?
        code = *( ((unsigned short HW_UNALIGNED *)s ++) );
#endif
        run = code & 0xff;
        esc = code >> 8;
        if (run == ESCAPE)
        {
            if (esc == ESC_ENDBITMAP)
            {
                break;
            }
            else if (esc == ESC_DELTA)
            {
#if 0
                len = *((unsigned short HW_UNALIGNED *)s)++;
#else
                len = *((unsigned short HW_UNALIGNED *)s++);
#endif
                while (len-- > 0)
                {
                    *f = 0;
                    f += stride;
                }
            }
            else if (esc >= ESC_RANDOM)
            {
                len = RANDOM_COUNT(esc);
                while (len-- > 0)
                {
                    *f = *s++;
                    f += stride;
                }
            }
        }
        else
        {
            while (run-- > 0)
            {
                *f = esc;
                f += stride;
            }
        }
    }
    
    return s-src;
}

static HwMemSize HwuRldTo32(HwMem src, HwMem dest, HwMemSize stride,
                            DWORD *translate)
{
    unsigned short code;
    unsigned char run, esc;
    size_t len;
    HwMem s;
    DWORD *f, tran;

    s = src;
    f = (DWORD *)dest;
    for (;;)
    {
#if 0
        code = *((unsigned short HW_UNALIGNED *)s)++;
#else
        code = *((unsigned short HW_UNALIGNED *)s++);
#endif
        run = code & 0xff;
        esc = code >> 8;
        if (run == ESCAPE)
        {
            if (esc == ESC_ENDBITMAP)
            {
                break;
            }
            else if (esc == ESC_DELTA)
            {
#if 0
                len = *((unsigned short HW_UNALIGNED *)s)++;
#else
                len = *((unsigned short HW_UNALIGNED *)s++);
#endif
                while (len-- > 0)
                {
                    *f = translate[0];
                    f += stride;
                }
            }
            else if (esc >= ESC_RANDOM)
            {
                len = RANDOM_COUNT(esc);
                while (len-- > 0)
                {
                    *f = translate[*s++];
                    f += stride;
                }
            }
        }
        else
        {
            tran = translate[esc];
            while (run-- > 0)
            {
                *f = tran;
                f += stride;
            }
        }
    }
    
    return s-src;
}

#define ALPHA_SIGNATURE 0xa0a1a2a3
#define COMPRESS_NONE 0
#define COMPRESS_RLE  1

BOOL 
TEXTURE::A8ImageLoad(void *pvResource )
{
    DWORD compress;
    DWORD size;
    DWORD *pal;
    BYTE *buf;
    DWORD *pdwA8;
    PUCHAR data;

    pdwA8 = (DWORD *)pvResource;

    // Check data signature for alpha texture format
    if (*pdwA8 != ALPHA_SIGNATURE)
    {
        return FALSE;
    }
    pdwA8++;

    width = *pdwA8++;
    height = *pdwA8++;

    // Make sure depth is 8bpp
    if (*pdwA8 != 8)
    {
        return FALSE;
    }
    pdwA8++;
    
    size = width*height;

    // Compression type
    compress = *pdwA8++;
    // Compressed data size only if compressed, not used
    pdwA8++;

    // Remember pointer to palette data
    pal = pdwA8;
    pdwA8 += 256;

    if (mtk_PalettedTextureEnabled())
    {
        // Allocate data for final image
        data = (PUCHAR) malloc(size);
        if (data == NULL)
        {
            return FALSE;
        }
    
        pal_size = 256;
        pal = (DWORD *) malloc(pal_size*sizeof(RGBQUAD));
        if (pal == NULL)
        {
            free(data);
            return FALSE;
        }
        memcpy(pal, pal, pal_size*sizeof(RGBQUAD));

        // Unpack 8bpp data into final image
        if (compress == COMPRESS_NONE)
        {
            memcpy(data, pdwA8, size);
        }
        else
        {
            HwuRld((HwMem)pdwA8, data, 1);
        }

        format = GL_COLOR_INDEX;
        components = GL_COLOR_INDEX8_EXT;
    }
    else
    {
        // Allocate data for final image
        data = (PUCHAR) malloc(size*sizeof(DWORD));
        if (data == NULL)
        {
            return FALSE;
        }
    
        pal_size = 0;
        pal = NULL;

        // Unpack 8bpp data into final image
        if (compress == COMPRESS_NONE)
        {
            DWORD i;
            BYTE *src;
            DWORD *dst;

            src = (BYTE *)pdwA8;
            dst = (DWORD *)data;
            for (i = 0; i < size; i++)
            {
                *dst++ = pal[*src++];
            }
        }
        else
        {
            HwuRldTo32((HwMem)pdwA8, data, 1, pal);
        }

        format = GL_BGRA_EXT;
        components = 4;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\texbmp.cxx ===
/******************************Module*Header*******************************\
* Module Name: ssdib.c
*
* Operations on .bmp files
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> 

#include "mtk.h"
#include "texture.hxx"

#define BFT_BITMAP  0x4d42  // 'BM' -- indicates structure is BITMAPFILEHEADER

// struct BITMAPFILEHEADER {
//      WORD  bfType
//      DWORD bfSize
//      WORD  bfReserved1
//      WORD  bfReserved2
//      DWORD bfOffBits
// }
#define OFFSET_bfType       0
#define OFFSET_bfSize       2
#define OFFSET_bfReserved1  6
#define OFFSET_bfReserved2  8
#define OFFSET_bfOffBits    10
#define SIZEOF_BITMAPFILEHEADER 14

// Read a WORD-aligned DWORD.  Needed because BITMAPFILEHEADER has
// WORD-alignment.
#define READDWORD(pv)   ( (DWORD)((PWORD)(pv))[0]               \
                          | ((DWORD)((PWORD)(pv))[1] << 16) )   \

// Computes the number of BYTES needed to contain n number of bits.
#define BITS2BYTES(n)   ( ((n) + 7) >> 3 )

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DibNumColors(VOID FAR * pv)                                *
 *                                                                          *
 *  PURPOSE    : Determines the number of colors in the DIB by looking at   *
 *               the BitCount filed in the info block.                      *
 *                                                                          *
 *  RETURNS    : The number of colors in the DIB.                           *
 *                                                                          *
 * Stolen from SDK ShowDIB example.                                         *
 ****************************************************************************/

static WORD DibNumColors(VOID FAR * pv)
{
    WORD                bits;
    BITMAPINFOHEADER UNALIGNED *lpbi;
    BITMAPCOREHEADER UNALIGNED *lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     *
     *  Because of the way we use this call, BITMAPINFOHEADER may be out
     *  of alignment if it follows a BITMAPFILEHEADER.  So use the macro
     *  to safely access DWORD fields.
     */
    if (READDWORD(&lpbi->biSize) != sizeof(BITMAPCOREHEADER)){
        if (READDWORD(&lpbi->biClrUsed) != 0)
        {
            return (WORD) READDWORD(&lpbi->biClrUsed);
        }
        bits = lpbi->biBitCount;
    }
    else
        bits = lpbc->bcBitCount;

    switch (bits){
        case 1:
            return 2;
        case 4:
            return 16;
        case 8:
            return 256;
        default:
            /* A 24 bitcount DIB has no color table */
            return 0;
    }
}

static PBYTE PackTexImage( BITMAPINFOHEADER *pbmih, PBYTE pjSrc )
{
// Note the malloc used here, for consistency with tk (app may use free() on it)
//mf: can change to overwrite pjSrc, instead of allocating new memomory, once
// no longer using TEX_BMP resource or old way of reading .bmp files
    PBYTE pjTKBits = (PBYTE) malloc(pbmih->biSizeImage);
    if( !pjTKBits )
    {
        return NULL;
    }

    PBYTE pjDst = pjTKBits;

    // src lines end on LONG boundary - so need to skip over any padding bytes

    int padBytes = pbmih->biWidth % sizeof(LONG);
    
    int rowSize = pbmih->biWidth * sizeof(RGB8);
    if( !padBytes ) {
        RtlCopyMemory( pjDst, pjSrc, pbmih->biHeight * rowSize );
    } else {
        for (int i = 0; i < pbmih->biHeight; i++ )
        {
            RtlCopyMemory( pjDst, pjSrc, rowSize );
            pjDst += rowSize;
            pjSrc += (rowSize + padBytes );
        }
    }
    return pjTKBits; // to be free'd by the caller
}

/******************************Public*Routine******************************\
* ss_DIBImageLoad
*
* Hacked form of tk_DIBImageLoad(), for reading a .bmp file from a resource
*
* Loads a DIB file (specified as either an ANSI or Unicode filename,
* depending on the bUnicode flag) and converts it into a TK image format.
*
* The technique used is based on CreateDIBSection and SetDIBits.
* CreateDIBSection is used to create a DIB with a format easily converted
* into the TK image format (packed 24BPP RGB).  The only conversion 
* required is swapping R and B in each RGB triplet (see history below)
* The resulting bitmap is selected into a memory DC.
*
* The DIB file is mapped into memory and SetDIBits called to initialize
* the memory DC bitmap.  It is during this step that GDI converts the
* arbitrary DIB file format to RGB format.
*
* Finally, the RGB data in the DIB section is read out and repacked
* as 24BPP 'BGR'.
*
* Returns:
*   BOOL. 
*
* History:
*   - 11/30/95: [marcfo]
*     Modified from tkDIBImageLoad, to work on resource bmp file.
*     At first I tried accessing the bitmap resource as an RT_BITMAP, where
*     the resource compiler strips out file information, and leaves you simple
*     bitmap data.  But this only worked on the Alpha architecture, x86
*     produced a resource with corrupted image data (?palette :)).  So I ended
*     up just slamming the entire .bmp file in as a resource.
*
\**************************************************************************/

#if 0
//mf: this is no longer needed, since bitmaps are always 'BITMAP' resources now.
BOOL 
TEXTURE::DIBImageLoad(PVOID pv )
{
    BOOL             fSuccess = FALSE;
    WORD             wNumColors;    // Number of colors in color table
    BITMAPFILEHEADER *pbmf;         // Ptr to file header
    BITMAPINFOHEADER UNALIGNED *pbmihFile;
    BITMAPCOREHEADER UNALIGNED *pbmchFile; // Ptr to file's core header (if it exists)
    PVOID            pvBits;    // Ptr to bitmap bits in file
    PBYTE            pjBitsRGB;     // Ptr to 24BPP RGB image in DIB section
    PBYTE            pjTKBits = (PBYTE) NULL;   // Ptr to final TK image bits

    // These need to be cleaned up when we exit:
    HDC        hdcMem = (HDC) NULL;                 // 24BPP mem DC
    HBITMAP    hbmRGB = (HBITMAP) NULL;             // 24BPP RGB bitmap
    BITMAPINFO *pbmiSource = (BITMAPINFO *) NULL;   // Ptr to source BITMAPINFO
    BITMAPINFO *pbmiRGB = (BITMAPINFO *) NULL;      // Ptr to file's BITMAPINFO
    int i;

// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER
// followed immediately with the color table and the bitmap bits.

    pbmf = (BITMAPFILEHEADER *) pv;

    if ( pbmf->bfType == BFT_BITMAP )
    {
        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER);

    // BITMAPFILEHEADER is WORD aligned, so use safe macro to read DWORD
    // bfOffBits field.

        pvBits = (PVOID *) ((PBYTE) pbmf
                                + READDWORD((PBYTE) pbmf + OFFSET_bfOffBits));
    }
    else
    {
        pbmihFile = (BITMAPINFOHEADER *) pv;

    // Determination of where the bitmaps bits are needs to wait until we
    // know for sure whether we have a BITMAPINFOHEADER or a BITMAPCOREHEADER.
    }

// Determine the number of colors in the DIB palette.  This is non-zero
// only for 8BPP or less.

    wNumColors = DibNumColors(pbmihFile);

// Create a BITMAPINFO (with color table) for the DIB file.  Because the
// file may not have one (BITMAPCORE case) and potential alignment problems,
// we will create a new one in memory we allocate.
//
// We distinguish between BITMAPINFO and BITMAPCORE cases based upon
// BITMAPINFOHEADER.biSize.

    pbmiSource = (BITMAPINFO *)
        LocalAlloc(LMEM_FIXED, sizeof(BITMAPINFO)
                               + wNumColors * sizeof(RGBQUAD));
    if (!pbmiSource)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    // Note: need to use safe READDWORD macro because pbmihFile may
    // have only WORD alignment if it follows a BITMAPFILEHEADER.

    switch (READDWORD(&pbmihFile->biSize))
    {
    case sizeof(BITMAPINFOHEADER):

    // Convert WORD-aligned BITMAPINFOHEADER to aligned BITMAPINFO.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = READDWORD(&pbmihFile->biWidth);
        pbmiSource->bmiHeader.biHeight        = READDWORD(&pbmihFile->biHeight);
        pbmiSource->bmiHeader.biPlanes        = pbmihFile->biPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmihFile->biBitCount;
        pbmiSource->bmiHeader.biCompression   = 
                                        READDWORD(&pbmihFile->biCompression);
        pbmiSource->bmiHeader.biSizeImage     = 
                                        READDWORD(&pbmihFile->biSizeImage);
        pbmiSource->bmiHeader.biXPelsPerMeter = 
                                        READDWORD(&pbmihFile->biXPelsPerMeter);
        pbmiSource->bmiHeader.biYPelsPerMeter = 
                                        READDWORD(&pbmihFile->biYPelsPerMeter);
        pbmiSource->bmiHeader.biClrUsed       = 
                                        READDWORD(&pbmihFile->biClrUsed);
        pbmiSource->bmiHeader.biClrImportant  = 
                                        READDWORD(&pbmihFile->biClrImportant);

    // Copy color table.  It immediately follows the BITMAPINFOHEADER.

        memcpy((PVOID) &pbmiSource->bmiColors[0], (PVOID) (pbmihFile + 1),
               wNumColors * sizeof(RGBQUAD));

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBits)
            pvBits = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBQUAD));
        break;

    case sizeof(BITMAPCOREHEADER):
        pbmchFile = (BITMAPCOREHEADER *) pbmihFile;

    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = (DWORD) pbmchFile->bcWidth;
        pbmiSource->bmiHeader.biHeight        = (DWORD) pbmchFile->bcHeight;
        pbmiSource->bmiHeader.biPlanes        = pbmchFile->bcPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmchFile->bcBitCount;
        pbmiSource->bmiHeader.biCompression   = BI_RGB;
        pbmiSource->bmiHeader.biSizeImage     = 0;
        pbmiSource->bmiHeader.biXPelsPerMeter = 0;
        pbmiSource->bmiHeader.biYPelsPerMeter = 0;
        pbmiSource->bmiHeader.biClrUsed       = wNumColors;
        pbmiSource->bmiHeader.biClrImportant  = wNumColors;

    // Convert RGBTRIPLE color table into RGBQUAD color table.

        {
            RGBQUAD *rgb4 = pbmiSource->bmiColors;
            RGBTRIPLE *rgb3 = (RGBTRIPLE *) (pbmchFile + 1);

            for (i = 0; i < wNumColors; i++)
            {
                rgb4->rgbRed   = rgb3->rgbtRed  ;
                rgb4->rgbGreen = rgb3->rgbtGreen;
                rgb4->rgbBlue  = rgb3->rgbtBlue ;
                rgb4->rgbReserved = 0;

                rgb4++;
                rgb3++;
            }
        }

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBits)
            pvBits = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBTRIPLE));
        break;

    default:
        MESSAGEBOX(GetFocus(), "Unknown DIB file format.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Fill in default values (for fields that can have defaults).

    if (pbmiSource->bmiHeader.biSizeImage == 0)
        pbmiSource->bmiHeader.biSizeImage = 
            BITS2BYTES( (DWORD) pbmiSource->bmiHeader.biWidth * 
                                pbmiSource->bmiHeader.biBitCount ) * 
                                pbmiSource->bmiHeader.biHeight;
    if (pbmiSource->bmiHeader.biClrUsed == 0)
        pbmiSource->bmiHeader.biClrUsed = wNumColors;

// Create memory DC.

    hdcMem = CreateCompatibleDC(NULL);
    if (!hdcMem) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Create a 24BPP RGB DIB section and select it into the memory DC.

    pbmiRGB = (BITMAPINFO *)
              LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(BITMAPINFO) );
    if (!pbmiRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    pbmiRGB->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmiRGB->bmiHeader.biWidth         = pbmiSource->bmiHeader.biWidth;
    pbmiRGB->bmiHeader.biHeight        = pbmiSource->bmiHeader.biHeight;
    pbmiRGB->bmiHeader.biPlanes        = 1;
    pbmiRGB->bmiHeader.biBitCount      = 24;
    pbmiRGB->bmiHeader.biCompression   = BI_RGB;
    pbmiRGB->bmiHeader.biSizeImage     = pbmiRGB->bmiHeader.biWidth
                                         * abs(pbmiRGB->bmiHeader.biHeight) * 3;

    hbmRGB = CreateDIBSection(hdcMem, pbmiRGB, DIB_RGB_COLORS, 
                              (PVOID *) &pjBitsRGB, NULL, 0);

    if (!hbmRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); 
        goto tkDIBLoadImage_cleanup;
    }

    if (!SelectObject(hdcMem, hbmRGB))
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Slam the DIB file image into the memory DC.  GDI will do the work of
// translating whatever format the DIB file has into RGB format.

    if (!SetDIBits(hdcMem, hbmRGB, 0, pbmiSource->bmiHeader.biHeight, 
                   pvBits, pbmiSource, DIB_RGB_COLORS))
    {
        MESSAGEBOX(GetFocus(), "Image file conversion error.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }
    GdiFlush();     // make sure that SetDIBits executes

/// *******************************************************************

// Convert to TK image format (packed RGB format).
// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app
// can deallocate with free()).

    pjTKBits = PackTexImage( &pbmiRGB->bmiHeader, pjBitsRGB );
    if( !pjTKBits ) {
        SS_ERROR( "ConvertToOpenGLTexFormat : memory failure\n" );
        goto tkDIBLoadImage_cleanup;
    }

// Initialize the texture structure

    // If we get to here, we have suceeded!
    width = pbmiSource->bmiHeader.biWidth;
    height = pbmiSource->bmiHeader.biHeight;
    format = GL_RGB;
    components = 3;
// do we keep the data around , since it's not needed after the texture is
// downloaded into GL and have texObj's ?
    data = pjTKBits;
    pal_size = 0;
    pal = NULL;

    fSuccess = TRUE;
    
// Cleanup objects.

tkDIBLoadImage_cleanup:
    {
        if (hdcMem)
            DeleteDC(hdcMem);

        if (hbmRGB)
            DeleteObject(hbmRGB);

        if (pbmiRGB)
            LocalFree(pbmiRGB);

        if (pbmiSource)
            LocalFree(pbmiSource);
    }

// Check for error.

    if (!fSuccess)
    {
        if (pjTKBits)
            free(pjTKBits);
    }

    return fSuccess;
}
#endif

BOOL 
TEXTURE::DIBImageLoad( HBITMAP hbmRGB )
{
    BOOL             fSuccess = FALSE;
    PBYTE            pjTKBits = (PBYTE) NULL;   // Ptr to final TK image bits
    BITMAPINFOHEADER *pbmih;

    // These need to be cleaned up when we exit:
    PVOID            pvBits = NULL;    // Ptr to bitmap bits in file
    HDC        hdcMem = (HDC) NULL;                 // 24BPP mem DC
    BITMAPINFO *pbmiRGB = (BITMAPINFO *) NULL;      // Ptr to file's BITMAPINFO

    // Create memory DC.

    hdcMem = CreateCompatibleDC(NULL);
    if (!hdcMem) {
        SS_ERROR( "TEXTURE::DIBImageLoad : CreateCompatibleDC failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }

    // Allocate BITMAPINFO structure

    pbmiRGB = (BITMAPINFO *)
              LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(BITMAPINFO) );
    if (!pbmiRGB)
    {
        SS_ERROR( "TEXTURE::DIBImageLoad : memory failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }
    pbmih = (BITMAPINFOHEADER *) &pbmiRGB->bmiHeader;
    pbmih->biSize = sizeof( BITMAPINFOHEADER );

    // Query bitmap values into pbmih

    if( ! GetDIBits( hdcMem, hbmRGB, 0, 0, NULL, pbmiRGB, 
                     DIB_RGB_COLORS ) )
    {
        SS_ERROR( "TEXTURE::DIBImageLoad : GetDIBits failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }

    // Now pbmiRGB->bmiHeader should've been filled in with stuff

    pbmih->biPlanes        = 1;
    pbmih->biBitCount      = 24;
    pbmih->biCompression   = BI_RGB;
//mf:suppsedly this can be set to 0 for BI_RGB
    pbmih->biSizeImage     = pbmih->biWidth
                                         * abs(pbmih->biHeight) * 3;

    pvBits = (PVOID) LocalAlloc(LMEM_FIXED, pbmih->biSizeImage);
    if (!pvBits)
    {
        SS_ERROR( "TEXTURE::DIBImageLoad : memory failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }

    // Get the image bits

    if( ! GetDIBits( hdcMem, hbmRGB, 0, pbmih->biHeight, pvBits, 
                     pbmiRGB, DIB_RGB_COLORS ) )
    {
        SS_ERROR( "TEXTURE::DIBImageLoad : GetDIBits failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }


// Convert to TK image format (packed RGB format).
// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app
// can deallocate with free()).

    pjTKBits = PackTexImage( pbmih, (PBYTE) pvBits );
    if( !pjTKBits ) {
        SS_ERROR( "ConvertToOpenGLTexFormat : memory failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }

// Initialize the texture structure

    // If we get to here, we have suceeded!
    width = pbmih->biWidth;
    height = pbmih->biHeight;
    format = GL_BGR_EXT; 
    components = 3;
    data = pjTKBits;
    pal_size = 0;
    pal = NULL;

    fSuccess = TRUE;
    
// Cleanup objects.

tkDIBLoadImage2_cleanup:
    {
        if( pvBits )
            LocalFree(pvBits);
        if (hdcMem)
            DeleteDC(hdcMem);
        if (pbmiRGB)
            LocalFree(pbmiRGB);
    }

// Check for error.

    if (!fSuccess)
    {
        if (pjTKBits)
            free(pjTKBits);
    }

    return fSuccess;
}

/******************************Public*Routine******************************\
*
* bVerifyDIB
*
* Stripped down version of tkDIBImageLoadAW that verifies that a bitmap
* file is valid and, if so, returns the bitmap dimensions.
*
* Returns:
*   TRUE if valid bitmap file; otherwise, FALSE.
*
\**************************************************************************/

BOOL 
bVerifyDIB(LPTSTR pszFileName, ISIZE *pSize )
{
    BOOL bRet = FALSE;
    BITMAPFILEHEADER *pbmf;         // Ptr to file header
    BITMAPINFOHEADER *pbmihFile;    // Ptr to file's info header (if it exists)
    BITMAPCOREHEADER *pbmchFile;    // Ptr to file's core header (if it exists)

    // These need to be cleaned up when we exit:
    HANDLE     hFile = INVALID_HANDLE_VALUE;        // File handle
    HANDLE     hMap = (HANDLE) NULL;                // Mapping object handle
    PVOID      pvFile = (PVOID) NULL;               // Ptr to mapped file

// Map the DIB file into memory.

    hFile = CreateFile((LPTSTR) pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
    if (hFile == INVALID_HANDLE_VALUE)
        goto bVerifyDIB_cleanup;

    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!hMap)
        goto bVerifyDIB_cleanup;

    pvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (!pvFile)
        goto bVerifyDIB_cleanup;

// Check the file header.  If the BFT_BITMAP magic number is there,
// then the file format is a BITMAPFILEHEADER followed immediately
// by either a BITMAPINFOHEADER or a BITMAPCOREHEADER.  The bitmap
// bits, in this case, are located at the offset bfOffBits from the
// BITMAPFILEHEADER.
//
// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER
// followed immediately with the color table and the bitmap bits.

    pbmf = (BITMAPFILEHEADER *) pvFile;

    if ( pbmf->bfType == BFT_BITMAP )
        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER);
    else
        pbmihFile = (BITMAPINFOHEADER *) pvFile;

// Get the width and height from whatever header we have.
//
// We distinguish between BITMAPINFO and BITMAPCORE cases based upon
// BITMAPINFOHEADER.biSize.

    // Note: need to use safe READDWORD macro because pbmihFile may
    // have only WORD alignment if it follows a BITMAPFILEHEADER.

    switch (READDWORD(&pbmihFile->biSize))
    {
    case sizeof(BITMAPINFOHEADER):

        if( pSize != NULL ) {
            pSize->width  = READDWORD(&pbmihFile->biWidth);
            pSize->height = READDWORD(&pbmihFile->biHeight);
        }
        bRet = TRUE;

        break;

    case sizeof(BITMAPCOREHEADER):
        pbmchFile = (BITMAPCOREHEADER *) pbmihFile;

    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER.

        if( pSize != NULL ) {
            pSize->width  = (DWORD) pbmchFile->bcWidth;
            pSize->height = (DWORD) pbmchFile->bcHeight;
        }
        bRet = TRUE;

        break;

    default:
        break;
    }

bVerifyDIB_cleanup:

    if (pvFile)
        UnmapViewOfFile(pvFile);

    if (hMap)
        CloseHandle(hMap);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\toolkits\libmtk\palette.cxx ===
/******************************Module*Header*******************************\
* Module Name: palette.cxx
*
* Palette processing functions
*
* Adapted from tk.c
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include "mtk.h"
#include "palette.hxx"

#if(WINVER < 0x0400)
// Ordinarily not defined for versions before 4.00.
#define COLOR_3DDKSHADOW        21
#define COLOR_3DLIGHT           22
#define COLOR_INFOTEXT          23
#define COLOR_INFOBK            24
#endif

#define TKASSERT(x) SS_ASSERT( x, "palette processing failure\n" )

/******************************************************************************/

// Fixed palette support.

#define BLACK   PALETTERGB(0,0,0)
#define WHITE   PALETTERGB(255,255,255)
#define MAX_STATIC_COLORS   (COLOR_INFOBK - COLOR_SCROLLBAR + 1)
static int gNumStaticColors = MAX_STATIC_COLORS;

// TRUE if static system color settings have been replaced with B&W settings.

// TRUE if original static colors saved
//static BOOL tkStaticColorsSaved = FALSE;

// saved system static colors (initialize with default colors)
static COLORREF gacrSave[MAX_STATIC_COLORS];

// new B&W system static colors
static COLORREF gacrBlackAndWhite[] = {
    WHITE,  // COLOR_SCROLLBAR
    BLACK,  // COLOR_BACKGROUND
    BLACK,  // COLOR_ACTIVECAPTION
    WHITE,  // COLOR_INACTIVECAPTION
    WHITE,  // COLOR_MENU
    WHITE,  // COLOR_WINDOW
    BLACK,  // COLOR_WINDOWFRAME
    BLACK,  // COLOR_MENUTEXT
    BLACK,  // COLOR_WINDOWTEXT
    WHITE,  // COLOR_CAPTIONTEXT
    WHITE,  // COLOR_ACTIVEBORDER
    WHITE,  // COLOR_INACTIVEBORDER
    WHITE,  // COLOR_APPWORKSPACE
    BLACK,  // COLOR_HIGHLIGHT
    WHITE,  // COLOR_HIGHLIGHTTEXT
    WHITE,  // COLOR_BTNFACE
    BLACK,  // COLOR_BTNSHADOW
    BLACK,  // COLOR_GRAYTEXT
    BLACK,  // COLOR_BTNTEXT
    BLACK,  // COLOR_INACTIVECAPTIONTEXT
    BLACK,  // COLOR_BTNHIGHLIGHT
    BLACK,  // COLOR_3DDKSHADOW
    WHITE,  // COLOR_3DLIGHT
    BLACK,  // COLOR_INFOTEXT
    WHITE   // COLOR_INFOBK
    };
static INT gaiStaticIndex[] = {
    COLOR_SCROLLBAR          ,
    COLOR_BACKGROUND         ,
    COLOR_ACTIVECAPTION      ,
    COLOR_INACTIVECAPTION    ,
    COLOR_MENU               ,
    COLOR_WINDOW             ,
    COLOR_WINDOWFRAME        ,
    COLOR_MENUTEXT           ,
    COLOR_WINDOWTEXT         ,
    COLOR_CAPTIONTEXT        ,
    COLOR_ACTIVEBORDER       ,
    COLOR_INACTIVEBORDER     ,
    COLOR_APPWORKSPACE       ,
    COLOR_HIGHLIGHT          ,
    COLOR_HIGHLIGHTTEXT      ,
    COLOR_BTNFACE            ,
    COLOR_BTNSHADOW          ,
    COLOR_GRAYTEXT           ,
    COLOR_BTNTEXT            ,
    COLOR_INACTIVECAPTIONTEXT,
    COLOR_BTNHIGHLIGHT       ,
    COLOR_3DDKSHADOW         ,
    COLOR_3DLIGHT            ,
    COLOR_INFOTEXT           ,
    COLOR_INFOBK
    };

#define RESTORE_FROM_REGISTRY   1
#if RESTORE_FROM_REGISTRY
// Registry names for the system colors.
static CHAR *gaszSysClrNames[] = {
    "Scrollbar",      // COLOR_SCROLLBAR              0
    "Background",     // COLOR_BACKGROUND             1   (also COLOR_DESKTOP)
    "ActiveTitle",    // COLOR_ACTIVECAPTION          2
    "InactiveTitle",  // COLOR_INACTIVECAPTION        3
    "Menu",           // COLOR_MENU                   4
    "Window",         // COLOR_WINDOW                 5
    "WindowFrame",    // COLOR_WINDOWFRAME            6
    "MenuText",       // COLOR_MENUTEXT               7
    "WindowText",     // COLOR_WINDOWTEXT             8
    "TitleText",      // COLOR_CAPTIONTEXT            9
    "ActiveBorder",   // COLOR_ACTIVEBORDER          10
    "InactiveBorder", // COLOR_INACTIVEBORDER        11
    "AppWorkspace",   // COLOR_APPWORKSPACE          12
    "Hilight",        // COLOR_HIGHLIGHT             13
    "HilightText",    // COLOR_HIGHLIGHTTEXT         14
    "ButtonFace",     // COLOR_BTNFACE               15   (also COLOR_3DFACE)
    "ButtonShadow",   // COLOR_BTNSHADOW             16   (also COLOR_3DSHADOW)
    "GrayText",       // COLOR_GRAYTEXT              17
    "ButtonText",     // COLOR_BTNTEXT               18
    "InactiveTitleText", // COLOR_INACTIVECAPTIONTEXT   19
    "ButtonHilight",  // COLOR_BTNHIGHLIGHT          20   (also COLOR_3DHILIGHT)
    "ButtonDkShadow", // COLOR_3DDKSHADOW            21
    "ButtonLight",    // COLOR_3DLIGHT               22
    "InfoText",       // COLOR_INFOTEXT              23
    "InfoWindow"      // COLOR_INFOBK                24
};

static BOOL GetRegistrySysColors(COLORREF *, int);
#endif

unsigned char ss_ComponentFromIndex(int i, int nbits, int shift );
static int ss_PixelFormatDescriptorFromDc( HDC hdc, PIXELFORMATDESCRIPTOR *Pfd );

LONG 
NullPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

/******************************************************************************/

#if RESTORE_FROM_REGISTRY
/******************************Public*Routine******************************\
* GetRegistrySysColors
*
* Reads the Control Panel's color settings from the registry and stores
* those values in pcr.  If we fail to get any value, then the corresponding
* entry in pcr is not mod