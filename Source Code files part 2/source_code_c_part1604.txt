    
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            PRINT1("error %d obtaining address-table size", dwErr);
            break;
        }
    
        AddrTable = (PMIB_IPADDRTABLE)HeapAlloc(GetProcessHeap(), 0, dwSize);

        if (!AddrTable) {
            dwErr = GetLastError();
            PRINT2("error %d allocating %d-byte for addresses", dwErr, dwSize);
            dwErr = ERROR_INSUFFICIENT_BUFFER; break;
        }
    
        dwErr = GetIpAddrTable(AddrTable, &dwSize, FALSE);

        if (dwErr != NO_ERROR) {
            PRINT1("error %d getting address table", dwErr);
            break;
        }
    
    } while(FALSE);

    if (dwErr != NO_ERROR) {
        if (IfTable) { HeapFree(GetProcessHeap(), 0, IfTable); }
        if (AddrTable) { HeapFree(GetProcessHeap(), 0, AddrTable); }
        return dwErr;
    }

    //
    // Find the user's interface in the interface-table
    //

    dwErr = ERROR_INVALID_PARAMETER;
    for (i = 0; i < (DWORD)IfTable->NumAdapters; i++) {
        PRINT2("%d: %ls", IfTable->Adapter[i].Index, IfTable->Adapter[i].Name+dwPrefixLength);
        if (lstrcmpiW(
                IfTable->Adapter[i].Name+dwPrefixLength, g_bind.RIB_Netcard
                ) != 0) {
            continue;
        }

        //
        // We've found the interface.
        // Now look in the address-table for its address.
        //

        for (j = 0; j < AddrTable->dwNumEntries; j++) {
            PRINT2("%d: %s", AddrTable->table[j].dwIndex, INET_NTOA(AddrTable->table[j].dwAddr));
            if (AddrTable->table[j].dwIndex != IfTable->Adapter[i].Index) {
                continue;
            }

            //
            // We've found the address.
            //

            g_bind.RIB_Address = AddrTable->table[j].dwAddr;
            g_bind.RIB_Netmask = AddrTable->table[j].dwMask;
            dwErr = NO_ERROR;
            break;
        }

        if (j >= AddrTable->dwNumEntries) {
            PRINT0("the address for the interface could not be found");
        }

        break;
    }

    if (i >= (DWORD)IfTable->NumAdapters) {
        PRINT0("the interface specified could not be found");
    }

    HeapFree(GetProcessHeap(), 0, IfTable);
    HeapFree(GetProcessHeap(), 0, AddrTable);
    return dwErr;
#else
    HKEY hkeyNetcard;
    PSTR pszAddress, pszNetmask;
    CHAR szNetcard[256], szValue[256];
    DWORD dwErr, dwType, dwSize, dwEnableDhcp;

    //
    // open the TCP/IP parameters key for the interface specified
    //

    strcpy(szNetcard, STR_SERVICES);
    strcat(szNetcard, g_bind.RIB_Netcard);
    strcat(szNetcard, STR_PARAMSTCP);

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE, szNetcard, 0, KEY_ALL_ACCESS, &hkeyNetcard
                );

    if (dwErr != NO_ERROR) {

        PRINT2("error %d opening registry key %s", dwErr, szNetcard);
        return dwErr;
    }


    do {


        //
        // read the dhcp key to see whether DHCP is enabled
        //
    
        dwSize = sizeof(DWORD);

        dwErr = RegQueryValueEx(
                    hkeyNetcard, STR_ENABLEDHCP, NULL,
                    &dwType, (PBYTE)&dwEnableDhcp, &dwSize
                    );
    
        if (dwErr != NO_ERROR) {

            PRINT3(
                "error %d reading value %s under key %s",
                dwErr, STR_ENABLEDHCP, szNetcard
                );
            break;
        }


        if (dwEnableDhcp) {
            pszAddress = STR_DHCPADDR;
            pszNetmask = STR_DHCPMASK;
        }
        else {
            pszAddress = STR_ADDRESS;
            pszNetmask = STR_NETMASK;
        }

    
        //
        // read the IP address and convert it  
        //

        dwSize = sizeof(szValue);

        dwErr = RegQueryValueEx(
                    hkeyNetcard, pszAddress, NULL,
                    &dwType, (PBYTE)szValue, &dwSize
                    );

        if (dwErr != NO_ERROR) {

            PRINT3(
                "error %d reading value %s under key %s",
                dwErr, pszAddress, szNetcard
                );
            break;
        }

        g_bind.RIB_Address = inet_addr(szValue);

        PRINT2("%s == %s", pszAddress, szValue);


        //
        // read the network mask and convert it
        //

        dwSize = sizeof(szValue);

        dwErr = RegQueryValueEx(
                    hkeyNetcard, pszNetmask, NULL,
                    &dwType, (PBYTE)szValue, &dwSize
                    );

        if (dwErr != NO_ERROR) {

            PRINT3(
                "error %d reading value %s under key %s",
                dwErr, pszNetmask, szNetcard
                );
            break;
        }

        g_bind.RIB_Netmask = inet_addr(szValue);

        PRINT2("%s == %s", pszNetmask, szValue);

    } while(FALSE);


    RegCloseKey(hkeyNetcard);

    return dwErr;
#endif
}



DWORD
RegGetConfig(
    VOID
    )
{

    CHAR szRipTest[256];
    DWORD dwErr, dwCreated;
    PREG_OPTION pro, proend;
    HKEY hkeyRipTest, hkeyIf;
    DWORD dwNetmask, dwPrefixLength;
    DWORD dwCount, dwLowestAddress, dwHighestAddress;


    //
    // create the RipTest key in case it doesn't exist
    //

    strcpy(szRipTest, STR_SERVICES);
    strcat(szRipTest, STR_RIPTEST);

    dwErr = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE, szRipTest, 0, NULL, 0,
                KEY_ALL_ACCESS, NULL, &hkeyRipTest, &dwCreated
                );

    if (dwErr != NO_ERROR) {

        PRINT2("error %d creating registry key %s", dwErr, szRipTest);
        return dwErr;
    }


    //
    // create the key for the interface in case it doesn't exist
    //

    dwErr = RegCreateKeyExW(
                hkeyRipTest, g_bind.RIB_Netcard, 0, NULL, 0,
                KEY_ALL_ACCESS, NULL, &hkeyIf, &dwCreated
                );
    
    RegCloseKey(hkeyRipTest);

    if (dwErr != NO_ERROR) {

        PRINT3(
            "error %d creating subkey %S under registry key %s",
            dwErr, g_bind.RIB_Netcard, szRipTest
            );
        return dwErr;
    }


    PRINT0("loading options from registry: ");

    proend = g_options + (sizeof(g_options) / sizeof(REG_OPTION));

    for (pro = g_options; pro < proend; pro++) {

        //
        // read or initialize the option
        //

        pro->RO_GetOpt(hkeyIf, pro);
    }

    RegCloseKey(hkeyIf);



    //
    // if the defaults were used, give the user a chance to change them
    //

    if (dwCreated == REG_CREATED_NEW_KEY) {

        PRINT0("Default parameters have been written to the registry.");
        PRINT2("Please check the key %s\\%S,", szRipTest, g_bind.RIB_Netcard);
        PRINT0("modify the values if necessary, and run RIPTEST again.\n");

        return ERROR_CAN_NOT_COMPLETE;
    }


    //
    // check the route parameters for errors:
    //
    // make sure the class of the route is valid
    //

    dwLowestAddress = g_cfg.RIC_RouteStart;

    if (IS_LOOPBACK_ADDR(dwLowestAddress) ||
        CLASSD_ADDR(dwLowestAddress) || CLASSE_ADDR(dwLowestAddress)) {

        PRINT1(
            "ERROR: route %s is of an invalid network class",
            INET_NTOA(dwLowestAddress)
            );
        return ERROR_INVALID_PARAMETER;
    }


    //
    // make sure that from the specified starting address,
    // there are enough routes in the network class to generate
    // the configured number of routes
    //

    dwCount = g_cfg.RIC_RouteCount;
    dwNetmask = g_cfg.RIC_RouteMask;
    dwPrefixLength = PREFIX_LENGTH(dwNetmask);

    dwLowestAddress &= dwNetmask;
    dwHighestAddress = NTH_ADDRESS(dwLowestAddress, dwPrefixLength, dwCount);

    if (IS_LOOPBACK_ADDR(dwHighestAddress) ||
        NETCLASS_MASK(dwLowestAddress) != NETCLASS_MASK(dwHighestAddress)) {

        PRINT1(
            "ERROR: starting route %s is too near the end of its network class",
            INET_NTOA(dwLowestAddress)
            );
        return ERROR_INVALID_PARAMETER;
    }


    //
    // make sure that the authentication type is a supported value
    //

    if (g_cfg.RIC_AuthType != IPRIP_AUTHTYPE_NONE &&
        g_cfg.RIC_AuthType != IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        PRINT1(
            "ERROR: authentication type %d is not supported",
            g_cfg.RIC_AuthType
            );
        return ERROR_INVALID_PARAMETER;
    }


    //
    // make sure the number of packet entries isn't out-of-range
    //

    if (g_cfg.RIC_PacketEntryCount > 25) {

        PRINT1(
            "ERROR: packet-enty count %d is too large",
            g_cfg.RIC_PacketEntryCount
            );
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}



DWORD
RegGetAddress(
    HKEY hKey,
    PREG_OPTION pOpt
    )
{

    CHAR szValue[256];
    DWORD dwErr, dwType, dwSize;

    //
    // attempt to read the value
    //

    dwSize = sizeof(szValue);

    dwErr = RegQueryValueEx(
                hKey, pOpt->RO_Name, NULL, &dwType, (PBYTE)szValue, &dwSize
                );

    if (dwErr != NO_ERROR) {

        //
        // attempt to write the default value to the registry
        //

        strcpy(szValue, INET_NTOA(*(PDWORD)pOpt->RO_DefVal));
        dwSize = strlen(szValue) + 1;
        dwType = REG_SZ;

        dwErr = RegSetValueEx(
                    hKey, pOpt->RO_Name, NULL, dwType, (PBYTE)szValue, dwSize
                    );
    }


    //
    // by now the value in the registry should be in szValue
    //

    *(PDWORD)pOpt->RO_OptVal = inet_addr(szValue);

    PRINT2("%20s == %s", pOpt->RO_Name, szValue);

    return dwErr;
}



DWORD
RegGetDWORD(
    HKEY hKey,
    PREG_OPTION pOpt
    )
{

    DWORD dwErr, dwValue, dwType, dwSize;


    //
    // attempt to read the value
    //

    dwSize = sizeof(DWORD);

    dwErr = RegQueryValueEx(
                hKey, pOpt->RO_Name, NULL, &dwType, (PBYTE)&dwValue, &dwSize
                );

    if (dwErr != NO_ERROR) {

        //
        // attempt to write the default value to the registry
        //

        dwValue = *(PDWORD)pOpt->RO_DefVal;
        dwSize = sizeof(DWORD);
        dwType = REG_DWORD;

        dwErr = RegSetValueEx(
                    hKey, pOpt->RO_Name, NULL, dwType, (PBYTE)&dwValue, dwSize
                    );
    }


    //
    // by now the value in the registry should be in dwValue
    //

    *(PDWORD)pOpt->RO_OptVal = dwValue;

    PRINT2("%20s == %d", pOpt->RO_Name, dwValue);

    return dwErr;
}



DWORD
RegGetBinary(
    HKEY hKey,
    PREG_OPTION pOpt
    )
{

    PBYTE pValue;
    DWORD dwErr, dwType, dwSize;


    //
    // attempt to read the value
    //

    dwSize = pOpt->RO_Size;
    pValue = (PBYTE)pOpt->RO_OptVal;

    dwErr = RegQueryValueEx(
                hKey, pOpt->RO_Name, NULL, &dwType, pValue, &dwSize
                );

    if (dwErr != NO_ERROR) {

        //
        // attempt to write the default value to the registry
        //

        pValue = (PBYTE)pOpt->RO_DefVal;
        dwSize = pOpt->RO_Size;
        dwType = REG_BINARY;

        dwErr = RegSetValueEx(
                    hKey, pOpt->RO_Name, NULL, dwType, pValue, dwSize
                    );

        RtlCopyMemory(pOpt->RO_OptVal, pOpt->RO_DefVal, pOpt->RO_Size);
    }

    {
        PBYTE pb, pbend;
        CHAR *psz, szValue[256], szDigits[] = "0123456789ABCDEF";
    
        psz = szValue;
        pbend = (PBYTE)pOpt->RO_OptVal + pOpt->RO_Size;

        for (pb = (PBYTE)pOpt->RO_OptVal; pb < pbend; pb++) {
            *psz++ = szDigits[*pb / 16];
            *psz++ = szDigits[*pb % 16];
            *psz++ = ':';
        }
        if (psz != szValue) { --psz; }
        *psz = '\0';

        PRINT2("%20s == %s", pOpt->RO_Name, szValue);
    }

    return dwErr;
}



//
// main stress function
//
DWORD
RipTest(
    VOID
    )
{

    SOCKET sock;
    SOCKADDR_IN sinaddr;
    DWORD dwErr, dwMetric;
    IPForwardEntry *ifelist;
    LIST_ENTRY rtrlist, *ple;
    PRIPTEST_ROUTER_INFO prrs;



    InitializeListHead(&rtrlist);

    do {

        //
        // create and set up socket to be used for route transmission
        //
    
        dwErr = InitializeSocket(&sock, RIPTEST_PORT);
    
        if (dwErr != NO_ERROR) {
            break;
        }
    
        //
        // transmit single route request on non-RIP port,
        // and build a list of responding routers
        //
    
        dwErr = DiscoverRouters(sock, &rtrlist);
    
        if (dwErr != NO_ERROR) { closesocket(sock); break; }
    
    
        //
        // generate the list of routes as configured
        //
    
        dwErr = GenerateRoutes(&ifelist);
    
        if (dwErr != NO_ERROR) { closesocket(sock); break; }
        
        //
        // re-initialize the socket, this time to the RIP port
        //
    
        closesocket(sock);

        dwErr = InitializeSocket(&sock, IPRIP_PORT);
        if (dwErr == SOCKET_ERROR) {
            break;
        }
    
    
    
        for (dwMetric = 8; (INT)dwMetric >= 2; dwMetric -= 3) {
    
            //
            // transmit the route table with the specified metric
            //

            dwErr = TransmitRoutes(sock, dwMetric, ifelist);


            //
            // give the router time to process the advertisements:
            // we allow 30 milliseconds per route, with a minimum of 15 seconds
            //

            Sleep(max(15000, 30 * g_cfg.RIC_RouteCount));


            //
            // make connections to Router on each of the responding machines,
            // and use MIB api functions to retrieve the route table.
            // Verify that the routes transmitted are present, 
            // and add the servers to the displayed statistics
            //
        
            dwErr = VerifyRouteTables(dwMetric, &rtrlist, ifelist);
        }

        if (g_cfg.RIC_RouteTimeout != 0) {

            //
            // use timeout to clear routes
            //

            PRINT1(
                "waiting %d milliseconds for routes to timeout",
                max(15000, g_cfg.RIC_RouteTimeout * 1000)
                );
            Sleep(max(15000, g_cfg.RIC_RouteTimeout * 1000));
        }
        else {

            //
            // send updates to clean up the routes
            //
    
            PRINT0("sending announcements to purge routes advertised");

            dwErr = TransmitRoutes(sock, 16, ifelist);
    
            Sleep(max(15000, 30 * g_cfg.RIC_RouteCount));
        }

        closesocket(sock);

    } while(FALSE);


    //
    // cleanup the server list
    //

    while (!IsListEmpty(&rtrlist)) {

        ple = RemoveHeadList(&rtrlist);
        prrs = CONTAINING_RECORD(ple, RIPTEST_ROUTER_INFO, RRS_Link);

        HeapFree(GetProcessHeap(), 0, prrs);
    }


    if (ifelist != NULL) { HeapFree(GetProcessHeap(), 0, ifelist); }

    return dwErr;
}



DWORD
InitializeSocket(
    SOCKET *psock,
    WORD wPort
    )
{

    SOCKET sock;
    DWORD dwErr, dwOption;


    // 
    // create the socket
    //

    sock = socket(AF_INET, SOCK_DGRAM, 0);

    if (sock == INVALID_SOCKET) {

        dwErr = WSAGetLastError();
        PRINT1("error %d creating socket", dwErr);
        return dwErr;
    }


    //
    // enable address sharing
    //

    dwOption = 1;
    dwErr = setsockopt(
                sock,
                SOL_SOCKET,
                SO_REUSEADDR,
                (PCCH)&dwOption,
                sizeof(DWORD)
                );
    if (dwErr == SOCKET_ERROR) {

        dwErr = WSAGetLastError();
        PRINT1("error %d enabling address re-use on socket", dwErr);
    }


    //
    // enlarge the receive buffer
    //

    dwOption = g_cfg.RIC_SockBufSize;
    dwErr = setsockopt(
                sock,
                SOL_SOCKET,
                SO_RCVBUF,
                (PCCH)&dwOption,
                sizeof(DWORD)
                );
    if (dwErr == SOCKET_ERROR) {

        dwErr = WSAGetLastError();
        PRINT2("error %d enlarging recv buffer to %d bytes", dwErr, dwOption);
    }


    //
    // enlarge the send buffer
    //

    dwOption = g_cfg.RIC_SockBufSize;
    dwErr = setsockopt(
                sock,
                SOL_SOCKET,
                SO_SNDBUF,
                (PCCH)&dwOption,
                sizeof(DWORD)
                );
    if (dwErr == SOCKET_ERROR) {

        dwErr = WSAGetLastError();
        PRINT2("error %d enlarging send buffer to %d bytes", dwErr, dwOption);
    }   


    do {

        SOCKADDR_IN sinaddr;


        if (g_cfg.RIC_RouteTarget != IPRIP_MULTIADDR) {

            //
            // enable broadcasting
            //
            dwOption = 1;
            dwErr = setsockopt(
                        sock,
                        SOL_SOCKET,
                        SO_BROADCAST,
                        (PCCH)&dwOption,
                        sizeof(DWORD)
                        );
            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d enabling broadcast on socket", dwErr);
                break;
            }
    

            //
            // bind the socket to the RIPTEST port
            //

            sinaddr.sin_family = AF_INET;
            sinaddr.sin_port = htons(wPort);
            sinaddr.sin_addr.s_addr = g_bind.RIB_Address;

            dwErr = bind(sock, (PSOCKADDR)&sinaddr, sizeof(SOCKADDR_IN));

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d binding socket", dwErr);
                break;
            }

            dwErr = NO_ERROR;
        }
        else {

            struct ip_mreq imOption;


            //
            // bind to the specified port
            //

            sinaddr.sin_family = AF_INET;
            sinaddr.sin_port = htons(wPort);
            sinaddr.sin_addr.s_addr = g_bind.RIB_Address;

            dwErr = bind(sock, (PSOCKADDR)&sinaddr, sizeof(SOCKADDR_IN));

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d binding socket", dwErr);
                break;
            }

            //
            // set the outgoing interface for multicasts
            //

            sinaddr.sin_addr.s_addr = g_bind.RIB_Address;

            dwErr = setsockopt(
                        sock,
                        IPPROTO_IP,
                        IP_MULTICAST_IF,
                        (PCCH)&sinaddr.sin_addr,
                        sizeof(IN_ADDR)
                        );
            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d setting multicast interface", dwErr);
                break;
            }


            //
            // join the RIP multicast group
            //

            imOption.imr_multiaddr.s_addr = IPRIP_MULTIADDR;
            imOption.imr_interface.s_addr = g_bind.RIB_Address;

            dwErr = setsockopt(
                        sock,
                        IPPROTO_IP,
                        IP_ADD_MEMBERSHIP,
                        (PCCH)&imOption,
                        sizeof(struct ip_mreq)
                        );
            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d joining multicast group", dwErr);
                break;
            }

            dwErr = NO_ERROR;
        }

    } while(FALSE);

    if (dwErr != NO_ERROR) { closesocket(sock); }
    else { *psock = sock; }

    return dwErr;
}



DWORD
DiscoverRouters(
    SOCKET sock,
    PLIST_ENTRY rtrlist
    )
{

    INT iLength;
    PIPRIP_ENTRY pie;
    PIPRIP_HEADER phdr;
    SOCKADDR_IN sindest;
    DWORD dwErr, dwSize;
    PIPRIP_AUTHENT_ENTRY pae;
    BYTE pbuf[MAX_PACKET_SIZE];

    INT iErr;
    FD_SET fs;
    TIMEVAL tv;
    DWORD dwTicks, dwTicksBefore, dwTicksAfter;


    PRINT0("attempting to discover neighboring routers...");

    //
    // construct the RIP packet
    //

    phdr = (PIPRIP_HEADER)pbuf;
    pie = (PIPRIP_ENTRY)(phdr + 1);
    pae = (PIPRIP_AUTHENT_ENTRY)(phdr + 1);

    phdr->IH_Command = IPRIP_REQUEST;
    phdr->IH_Version = (CHAR)g_cfg.RIC_PacketVersion;
    phdr->IH_Reserved = 0;


    //
    // setup the authentication entry if necessary;
    // note that the code allows authentication in RIPv1 packets
    //

    if (g_cfg.RIC_AuthType == IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        pae->IAE_AddrFamily = ADDRFAMILY_AUTHENT;
        pae->IAE_AuthType = (WORD)g_cfg.RIC_AuthType;
        RtlCopyMemory(
            pae->IAE_AuthKey,
            g_cfg.RIC_AuthKey,
            IPRIP_MAX_AUTHKEY_SIZE
            );

        ++pie;
    }


    //
    // setup the single packet entry; we request a meaningless address
    //

    pie->IE_AddrFamily = htons(AF_INET);
    pie->IE_RouteTag = 0;
    pie->IE_Destination = 0xccddeeff;
    pie->IE_SubnetMask = 0;
    pie->IE_Nexthop = 0;
    pie->IE_Metric = htonl(IPRIP_INFINITE);


    dwSize = (ULONG) ((PBYTE)(pie + 1) - pbuf);


    //
    // send the route request to the RIP port
    //

    PRINT1("\tsending REQUEST to %s", INET_NTOA(g_cfg.RIC_RouteTarget));

    sindest.sin_family = AF_INET;
    sindest.sin_port = htons(IPRIP_PORT);
    sindest.sin_addr.s_addr = g_cfg.RIC_RouteTarget;

    iLength = sendto(
                sock, (PCCH)pbuf, dwSize, 0,
                (PSOCKADDR)&sindest, sizeof(SOCKADDR_IN)
                );
    if (iLength == SOCKET_ERROR || (DWORD)iLength < dwSize) {

        dwErr = WSAGetLastError();
        PRINT1("error %d sending route request", dwErr);
        return dwErr;
    }



    //
    // wait a while before collecting responses
    //

    Sleep(10000);


    //
    // repeatedly receive for the next 10 seconds
    //

    tv.tv_sec = 10;
    tv.tv_usec = 0;


    //
    // this loop executes until 10 seconds have elapsed
    //

    while (tv.tv_sec > 0) {

        FD_ZERO(&fs);
        FD_SET(sock, &fs);

        //
        // get the tick count beofre starting select
        //

        dwTicksBefore = GetTickCount();


        //
        // enter the call to select
        //

        iErr = select(0, &fs, NULL, NULL, &tv);


        //
        // compute the elapsed time
        //

        dwTicksAfter = GetTickCount();

        if (dwTicksAfter < dwTicksBefore) {
            dwTicks = dwTicksAfter + ((DWORD)-1 - dwTicksBefore);
        }
        else {
            dwTicks = dwTicksAfter - dwTicksBefore;
        }

        //
        // update the timeout
        //

        if (tv.tv_usec < (INT)(dwTicks % 1000) * 1000) {

            //
            // borrow a second from the tv_sec field
            //

            --tv.tv_sec;
            tv.tv_usec += 1000000;
        }

        tv.tv_usec -= (dwTicks % 1000) * 1000;
        tv.tv_sec -= (dwTicks / 1000);



        //  
        // process any incoming packets there might be
        //

        if (iErr != 0 && iErr != SOCKET_ERROR && FD_ISSET(sock, &fs)) {

            INT addrlen;
            SOCKADDR_IN sinsrc;
            PRIPTEST_ROUTER_INFO prs;


            //
            // receive the packet
            //

            addrlen = sizeof(sinsrc);

            iLength = recvfrom(
                        sock, (PCHAR)pbuf, MAX_PACKET_SIZE, 0,
                        (PSOCKADDR)&sinsrc, &addrlen
                        );
            if (iLength == 0 || iLength == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                PRINT1("error %d receiving packet", dwErr);
                continue;
            }


            //
            // create a list entry for the responding router
            //

            dwErr = CreateRouterStatsEntry(
                        rtrlist, sinsrc.sin_addr.s_addr, &prs
                        );

            if (dwErr == NO_ERROR) {
                PRINT2(
                    "\treceived RESPONSE from %s (%s)",
                    INET_NTOA(sinsrc.sin_addr), prs->RRS_DnsName
                    );
            }
        }
    }

    if (rtrlist->Flink == rtrlist) {
        PRINT0("\tno neighboring routers discovered");
    }

    return NO_ERROR;
}



DWORD
GenerateRoutes(
    IPForwardEntry **pifelist
    )
{

    CHAR szAddress[20];
    IPForwardEntry *ifelist, *ife;
    DWORD dwRouteCount, dwNetworkCount;
    DWORD dwStartOffset, dwLowestAddress, dwHighestAddress;
    DWORD dw, dwErr, dwAddress, dwNexthop, dwSubnetMask, dwPrefixLength;


    dwNexthop = g_cfg.RIC_RouteNexthop;
    dwSubnetMask = g_cfg.RIC_RouteMask;
    dwPrefixLength = PREFIX_LENGTH(dwSubnetMask);


    //
    // find the last address in the start-address's network class
    //

    dwLowestAddress = g_cfg.RIC_RouteStart;

    dwHighestAddress =
        (CLASSA_ADDR(dwLowestAddress) ? inet_addr("126.255.255.255") :
        (CLASSB_ADDR(dwLowestAddress) ? inet_addr("191.255.255.255") :
        (CLASSC_ADDR(dwLowestAddress) ? inet_addr("223.255.255.255") : 0)));


    //
    // figure out how many networks the range can be split into
    // using the specified network mask
    //

    dwLowestAddress &= dwSubnetMask;
    dwNetworkCount = ((ntohl(dwHighestAddress) >> (32 - dwPrefixLength)) -
                      (ntohl(dwLowestAddress) >> (32 - dwPrefixLength)));


    //
    // choose a starting address for this iteration:
    // we have at most K routes, and we are sending n routes,
    // so the starting route must be at an offset of between 0 and (K - n)
    //

    dwRouteCount = g_cfg.RIC_RouteCount;

    dwStartOffset = RANDOM(&g_seed, 0, (dwNetworkCount - dwRouteCount));


    //
    // allocate the array of routes
    //

    *pifelist =
    ifelist = (IPForwardEntry *)HeapAlloc(
                                GetProcessHeap(), 0,
                                dwRouteCount * sizeof(IPForwardEntry)
                                );
    if (ifelist == NULL) {
        dwErr = GetLastError();
        PRINT2(
            "error %d allocating %d bytes for route list",
            dwErr, dwRouteCount * sizeof(IPForwardEntry)
            );
        return dwErr;
    }

    RtlZeroMemory(ifelist, dwRouteCount * sizeof(IPForwardEntry));


    //
    // fill the table with routes
    //

    for (dw = dwStartOffset; dw < (dwStartOffset + dwRouteCount); dw++) {

        dwAddress = NTH_ADDRESS(dwLowestAddress, dwPrefixLength, dw);

        ife = ifelist + (dw - dwStartOffset);
        ife->dwForwardDest = dwAddress;
        ife->dwForwardMask = dwSubnetMask;
        ife->dwForwardNextHop = dwNexthop;
    }


    return NO_ERROR;
}



DWORD
TransmitRoutes(
    SOCKET sock,
    DWORD dwMetric,
    IPForwardEntry *ifelist
    )
{

    INT iLength;
    WORD wRouteTag;
    PIPRIP_HEADER pih;
    SOCKADDR_IN sindest;
    PIPRIP_ENTRY pie, pistart, piend;
    PIPRIP_AUTHENT_ENTRY pae;
    IPForwardEntry *ife, *ifend;
    BYTE pbuf[2 * MAX_PACKET_SIZE];
    DWORD dwErr, dwEntryCount;


    //
    // setup the message's header
    //

    pih = (PIPRIP_HEADER)pbuf;
    pae = (PIPRIP_AUTHENT_ENTRY)(pih + 1);
    pistart = (PIPRIP_ENTRY)(pih + 1);


    pih->IH_Command = IPRIP_RESPONSE;
    pih->IH_Version = (CHAR)g_cfg.RIC_PacketVersion;
    pih->IH_Reserved = 0;


    //
    // setup the authentication entry if necessary;
    // note that the code allows authentication in RIPv1 packets
    //

    if (g_cfg.RIC_AuthType == IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        pae->IAE_AddrFamily = ADDRFAMILY_AUTHENT;
        pae->IAE_AuthType = (WORD)g_cfg.RIC_AuthType;
        RtlCopyMemory(
            pae->IAE_AuthKey,
            g_cfg.RIC_AuthKey,
            IPRIP_MAX_AUTHKEY_SIZE
            );

        ++pistart;
    }


    //
    // pick off the configured number of routes to put in the packet
    //

    if (g_cfg.RIC_PacketEntryCount != 0) {

        dwEntryCount = g_cfg.RIC_PacketEntryCount;
    }
    else {

        //
        // choose a random number of entries
        //

        if (g_cfg.RIC_AuthType == IPRIP_AUTHTYPE_NONE) {
            dwEntryCount = RANDOM(&g_seed, 1, 25);
        }
        else {
            dwEntryCount = RANDOM(&g_seed, 1, 24);
        }
    }


    wRouteTag = LOWORD(g_cfg.RIC_RouteTag);

    sindest.sin_family = AF_INET;
    sindest.sin_port = htons(IPRIP_PORT);
    sindest.sin_addr.s_addr = g_cfg.RIC_RouteTarget;

    {
        DWORD dwCount;
        CHAR szDest[20], szFirst[20], szLast[20];
    
        dwCount = g_cfg.RIC_RouteCount;
        strcpy(szDest, INET_NTOA(sindest.sin_addr));
        strcpy(szFirst, INET_NTOA(ifelist->dwForwardDest));
        strcpy(szLast, INET_NTOA((ifelist + dwCount - 1)->dwForwardDest));
    
        PRINT5(
            "sending %d routes (%s - %s) to %s using metric %d",
            dwCount, szFirst, szLast, szDest, dwMetric
            );
    }


    //
    // loop filling the buffer with packets and sending it when its full
    //

    piend = pistart + dwEntryCount;
    ifend = ifelist + g_cfg.RIC_RouteCount;

    for (ife = ifelist, pie = pistart; ife < ifend; ife++, pie++) {

        //
        // send the current buffer if it is full
        //

        if (pie >= piend) {

            //
            // sleep for the specified packet-gap
            //

            Sleep(g_cfg.RIC_PacketGap);


            iLength = sendto(
                        sock, (PCCH)pbuf, (ULONG)((PBYTE)pie - pbuf), 0,
                        (PSOCKADDR)&sindest, sizeof(SOCKADDR_IN)
                        );
            if (iLength == SOCKET_ERROR || iLength < ((PBYTE)piend - pbuf)) {

                dwErr = WSAGetLastError();
                PRINT2(
                    "error %d sending packet to %s",
                    dwErr, INET_NTOA(sindest.sin_addr)
                    );
            }


            if (g_cfg.RIC_PacketEntryCount != 0) {
        
                dwEntryCount = g_cfg.RIC_PacketEntryCount;
            }
            else {
        
                //
                // choose a random number of entries
                //
        
                if (g_cfg.RIC_AuthType == IPRIP_AUTHTYPE_NONE) {
                    dwEntryCount = RANDOM(&g_seed, 1, 25);
                }
                else {
                    dwEntryCount = RANDOM(&g_seed, 1, 24);
                }
            }

            piend = pistart + dwEntryCount;
            pie = pistart;
        }


        //
        // add another entry
        //

        pie->IE_AddrFamily = htons(AF_INET);
        pie->IE_Destination = ife->dwForwardDest;
        pie->IE_Metric = htonl(dwMetric);
        pie->IE_RouteTag = htons(wRouteTag);
        pie->IE_Nexthop = ife->dwForwardNextHop;
        pie->IE_SubnetMask = ife->dwForwardMask;

    }

    //
    // if there is anything left, send it
    //

    if (pie > pistart) {
        iLength = sendto(
                    sock, (PCCH)pbuf, (ULONG)((PBYTE)pie - pbuf), 0,
                    (PSOCKADDR)&sindest, sizeof(SOCKADDR_IN)
                    );
    }

    return NO_ERROR;
}



DWORD
VerifyRouteTables(
    DWORD dwMetric,
    PLIST_ENTRY rtrlist,
    IPForwardEntry *ifelist
    )
{

    PLIST_ENTRY ple;
    MIB_OPAQUE_QUERY roq;
    MIB_OPAQUE_INFO *proi;
    WCHAR pwsRouter[256];
    MIB_SERVER_HANDLE hRouter;
    PRIPTEST_ROUTER_INFO prrs;
    MIB_IPFORWARDTABLE *ifrlist;
    IPForwardEntry *ife, *ifend;
    MIB_IPFORWARDROW *ifr, *ifrend;
    DWORD dwInvalidMetrics, dwRoutesMissing;
    DWORD dwErr, dwNumEntries, dwInSize, dwOutSize;


    //
    // go through the list of routers, connecting to the Router
    // on each machine and querying its routing table
    //

    for (ple = rtrlist->Flink; ple != rtrlist; ple = ple->Flink) {

        prrs = CONTAINING_RECORD(ple, RIPTEST_ROUTER_INFO, RRS_Link);

        PRINT1("-----STATS FOR %s-----", prrs->RRS_DnsName);

        //
        // initialize the query arguments
        //

        mbstowcs(pwsRouter, prrs->RRS_DnsName, strlen(prrs->RRS_DnsName) + 1);

        roq.dwVarId = IP_FORWARDTABLE;
        dwInSize = sizeof(MIB_OPAQUE_QUERY) - sizeof(DWORD);
        proi = NULL;
        dwOutSize = 0;


        //
        // perform the query
        //

        dwErr = MprAdminMIBServerConnect(pwsRouter, &hRouter);

        if (dwErr != NO_ERROR) {
            continue;
        }

        dwErr = MprAdminMIBEntryGet(
                    hRouter, PID_IP, IPRTRMGR_PID,
                    (PVOID)&roq, dwInSize, (PVOID *)&proi, &dwOutSize
                    );


        if (dwErr != NO_ERROR) {

            PRINT2(
                "error %d querying route table on server %s",
                dwErr, prrs->RRS_DnsName
                );
            MprAdminMIBServerDisconnect(hRouter);
            continue;
        }
        else
        if (proi == NULL) {

            PRINT1(
                "empty route table retrieved from server %s",
                prrs->RRS_DnsName
                );
            MprAdminMIBServerDisconnect(hRouter);
            continue;
        }



        //
        // look through the table of routes retrieved,
        // to verify thats the routes advertised are among them
        //

        dwRoutesMissing = 0;
        dwInvalidMetrics = 0;

        ifrlist = (PMIB_IPFORWARDTABLE)(proi->rgbyData);

        dwNumEntries = ifrlist->dwNumEntries;
        ifend = ifelist + g_cfg.RIC_RouteCount;

        for (ife = ifelist; ife < ifend; ife++) {

            //
            // each time we find an advertised route,
            // we swap it to the end of the table; 
            // thus, the size of the table that we need to search
            // decreases with the number of routes we have found
            //

            ifrend = ifrlist->table + dwNumEntries;

            for (ifr = ifrlist->table; ifr < ifrend; ifr++) {

                if (ife->dwForwardDest == ifr->dwForwardDest) {

                    if (ifr->dwForwardMetric1 == (dwMetric + 1)) {
                        ife->dwForwardMetric5 = ROUTE_STATUS_OK;
                    }
                    else {

                        //
                        // set the status for this route
                        //

                        ++dwInvalidMetrics;
                        ife->dwForwardMetric5 = ROUTE_STATUS_METRIC;

                        PRINT3(
                            "\troute to %s has metric %d, expected %d",
                            INET_NTOA(ife->dwForwardDest),
                            ife->dwForwardMetric1, dwMetric + 1
                            );
                    }


                    //
                    // overwrite with the item at the end of the table;
                    // if we are at the end of the table, do nothing
                    //

                    if (ifr != (ifrend - 1)) { *ifr = *(ifrend - 1); }
                    --dwNumEntries;

                    break;
                }
            }


            //
            // if the item wasn't found, mark it as such
            //

            if (ifr >= ifrend) {

                ++dwRoutesMissing;
                ife->dwForwardMetric5 = ROUTE_STATUS_MISSING;

                PRINT1("\troute to %s missing", INET_NTOA(ife->dwForwardDest));
            }
        }


        MprAdminMIBBufferFree(proi);
        MprAdminMIBServerDisconnect(hRouter);

        PRINT2("%20s == %d", "routes missing", dwRoutesMissing);
        PRINT2("%20s == %d", "invalid metrics", dwInvalidMetrics);
    }

    return NO_ERROR;
}



DWORD
CreateRouterStatsEntry(
    PLIST_ENTRY rtrlist,
    DWORD dwAddress,
    PRIPTEST_ROUTER_INFO *pprrs
    )
{

    DWORD dwErr;
    PHOSTENT phe;
    PRIPTEST_ROUTER_INFO prrs;


    phe = gethostbyaddr((const char *)&dwAddress, sizeof(DWORD), PF_INET);

    if (phe == NULL) {
        dwErr = WSAGetLastError();
        PRINT2(
            "error %d retrieving name for host %s", dwErr, INET_NTOA(dwAddress)
            );
        return dwErr;
    }

    prrs = (PRIPTEST_ROUTER_INFO)HeapAlloc(
                                    GetProcessHeap(), 0,
                                    sizeof(RIPTEST_ROUTER_INFO)
                                    );
    if (prrs == NULL) {
        dwErr = GetLastError();
        PRINT2(
            "error %d allocating %d bytes for router stats",
            dwErr, sizeof(RIPTEST_ROUTER_INFO)
            );
        return dwErr;
    }


    RtlZeroMemory(prrs, sizeof(RIPTEST_ROUTER_INFO));

    prrs->RRS_Address = dwAddress;
    strcpy(prrs->RRS_DnsName, phe->h_name);

    InsertHeadList(rtrlist, &prrs->RRS_Link);

    if (pprrs != NULL) { *pprrs = prrs; }

    return NO_ERROR;
}



DWORD
PrintUsage(
    VOID
    )
{

    printf("usage:  riptest [adapter_guid]");
    printf("\n\te.g. riptest {73C2D5F0-A352-11D1-9043-0060089FC48B}\n");
    printf("\n\tThe first time RIPTEST is run, it sets up the registry");
    printf("\n\twith defaults for the specified adapter.");
    printf("\n");

    return NO_ERROR;
}


} // end extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\riptest.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    riptest.h
//
// History:
//  Abolade Gbadegesin  Oct-16-1995     Created
//
// Declarations for the RIP test program.
//============================================================================


//
// These strings are used to access the registry
//

#define STR_SERVICES        "System\\CurrentControlSet\\Services\\"
#define STR_RIPTEST         "RipTest"
#define STR_PARAMSTCP       "\\Parameters\\Tcpip"

#define STR_ENABLEDHCP      "EnableDhcp"
#define STR_ADDRESS         "IPAddress"
#define STR_NETMASK         "SubnetMask"
#define STR_DHCPADDR        "DhcpIPAddress"
#define STR_DHCPMASK        "DhcpSubnetMask"

#define STR_ROUTECOUNT      "RouteCount"
#define STR_ROUTESTART      "RouteStart"
#define STR_ROUTEMASK       "RouteMask"
#define STR_ROUTENEXTHOP    "RouteNexthop"
#define STR_ROUTETAG        "RouteTag"
#define STR_ROUTETARGET     "RouteTarget"
#define STR_ROUTETIMEOUT    "RouteTimeout"
#define STR_PACKETVERSION   "PacketVersion"
#define STR_PACKETENTRYCOUNT "PacketEntryCount"
#define STR_PACKETGAP       "PacketGap"
#define STR_AUTHKEY         "AuthKey"
#define STR_AUTHTYPE        "AuthType"
#define STR_SOCKBUFSIZE     "SockBufSize"


//
// these definitions are used for socket setup
//
#define RIP_PORT            520
#define RIPTEST_PORT        521

//
// the field ire_metric5 is used as a status field, with these values
//

#define ROUTE_STATUS_OK         0
#define ROUTE_STATUS_METRIC     1
#define ROUTE_STATUS_MISSING    2


//
//
//

typedef MIB_IPFORWARDROW IPForwardEntry;

//
// This type is for a generic registry-access function.
// Such a function reads the given key, and if the option
// specified is found, it reads it. Otherwise, it uses the default
// and writes the default value to the registry.
//

struct _REG_OPTION;

typedef
DWORD
(*REG_GETOPT_FUNCTION)(
    HKEY hKey, 
    struct _REG_OPTION *pOpt
    );



//
// This type is for a generic RIPTEST option.
//
//  RO_Name     used to retrieve the value from its registry key
//  RO_Size     for strings and binary values; gives maximum size
//  RO_OptVal   contains the option's value 
//  RO_DefVal   contains the default value for the option
//  RO_GetOpt   contains the function used to retrieve this value
//

typedef struct _REG_OPTION {

    PSTR        RO_Name;
    DWORD       RO_Size;
    PVOID       RO_OptVal;
    PVOID       RO_DefVal;
    REG_GETOPT_FUNCTION RO_GetOpt;

} REG_OPTION, *PREG_OPTION;



//
// This type is used to hold all RIPTEST's parameters for a given interface
//  

typedef struct _RIPTEST_IF_CONFIG {

    DWORD       RIC_RouteCount;
    DWORD       RIC_RouteStart;
    DWORD       RIC_RouteMask;
    DWORD       RIC_RouteNexthop;
    DWORD       RIC_RouteTag;
    DWORD       RIC_RouteTarget;
    DWORD       RIC_RouteTimeout;
    DWORD       RIC_PacketVersion;
    DWORD       RIC_PacketEntryCount;
    DWORD       RIC_PacketGap;
    BYTE        RIC_AuthKey[IPRIP_MAX_AUTHKEY_SIZE];
    DWORD       RIC_AuthType;
    DWORD       RIC_SockBufSize;

} RIPTEST_IF_CONFIG, *PRIPTEST_IF_CONFIG;


//
// structure used to store binding for an interface
//

typedef struct _RIPTEST_IF_BINDING {

    DWORD       RIB_Address;
    DWORD       RIB_Netmask;
    WCHAR       RIB_Netcard[128];

} RIPTEST_IF_BINDING, *PRIPTEST_IF_BINDING;


//
// struct used to store information for a responding router 
//

typedef struct _RIPTEST_ROUTER_INFO {

    DWORD       RRS_Address;
    CHAR        RRS_DnsName[64];

    LIST_ENTRY  RRS_Link;

} RIPTEST_ROUTER_INFO, *PRIPTEST_ROUTER_INFO;


//
// macros used to compute prefix length of a network mask:
// the prefix length is the nubmer of bits set in the mask, assuming
// that the mask is contiguous
//

#define PREFIX_LENGTH(a)   PREFIX_LENGTH32(a)

#define PREFIX_LENGTH32(a)    \
    (((a) & 0x00000100) ? PREFIX_LENGTH16((a) >> 16) + 16   \
                        : PREFIX_LENGTH16(a))

#define PREFIX_LENGTH16(a)  \
    (((a) & 0x0001) ? PREFIX_LENGTH8((a) >> 8) + 8  \
                    : PREFIX_LENGTH8(a))

#define PREFIX_LENGTH8(a)   \
    (((a) & 0x01) ? 8 : \
    (((a) & 0x02) ? 7 : \
    (((a) & 0x04) ? 6 : \
    (((a) & 0x08) ? 5 : \
    (((a) & 0x10) ? 4 : \
    (((a) & 0x20) ? 3 : \
    (((a) & 0x40) ? 2 : \
    (((a) & 0x80) ? 1 : 0))))))))


//
//
//

#define NTH_ADDRESS(addr, preflen, n)   \
    htonl(((ntohl(addr) >> (32 - (preflen))) + (n)) << (32 - (preflen)))

//
//
//

#if 1
#define RANDOM(seed, min, max)  \
    ((min) +    \
    (DWORD)((DOUBLE)rand() / ((DOUBLE)RAND_MAX + 1) * \
            ((max) - (min) + 1)))
#else
#define RANDOM(seed, min, max)  \
    ((min) +    \
    (DWORD)((DOUBLE)RtlRandom(seed) / ((DOUBLE)MAXLONG + 1) * \
            ((max) - (min) + 1)))
#endif


//
// IP address conversion macro
//
#define INET_NTOA(addr) inet_ntoa( *(PIN_ADDR)&(addr) )


//
// macros used to generate tracing output
//

#ifdef RTUTILS

#define PRINTREGISTER(a)  TraceRegister(a)
#define PRINTDEREGISTER(a)  TraceDeregister(a)

#define PRINT0(a) \
        TracePrintf(g_TraceID,a)
#define PRINT1(a,b) \
        TracePrintf(g_TraceID,a,b)
#define PRINT2(a,b,c) \
        TracePrintf(g_TraceID,a,b,c)
#define PRINT3(a,b,c,d) \
        TracePrintf(g_TraceID,a,b,c,d)
#define PRINT4(a,b,c,d,e) \
        TracePrintf(g_TraceID,a,b,c,d,e)
#define PRINT5(a,b,c,d,e,f) \
        TracePrintf(g_TraceID,a,b,c,d,e,f)

#else

#define PRINTREGISTER(a) INVALID_TRACEID
#define PRINTDEREGISTER(a) INVALID_TRACEID

#define PRINT0(a) \
        printf("\n"a)
#define PRINT1(a,b) \
        printf("\n"a,b)
#define PRINT2(a,b,c) \
        printf("\n"a,b,c)
#define PRINT3(a,b,c,d) \
        printf("\n"a,b,c,d)
#define PRINT4(a,b,c,d,e) \
        printf("\n"a,b,c,d,e)
#define PRINT5(a,b,c,d,e,f) \
        printf("\n"a,b,c,d,e,f)

#endif


//
// functions used to access options in the registry
//

DWORD
RegGetConfig(
    VOID
    );

DWORD
RegGetAddress(
    HKEY hKey,
    PREG_OPTION pOpt
    );

DWORD
RegGetDWORD(
    HKEY hKey,
    PREG_OPTION pOpt
    );

DWORD
RegGetBinary(
    HKEY hKey,
    PREG_OPTION pOpt
    );

DWORD
RegGetIfBinding(
    VOID
    );

DWORD
InitializeSocket(
    SOCKET *psock,
    WORD wPort
    );

DWORD
GenerateRoutes(
    IPForwardEntry **pifelist
    );

DWORD
DiscoverRouters(
    SOCKET sock,
    PLIST_ENTRY rtrlist
    );

DWORD
TransmitRoutes(
    SOCKET sock,
    DWORD dwMetric,
    IPForwardEntry *ifelist
    );

DWORD
VerifyRouteTables(
    DWORD dwMetric,
    PLIST_ENTRY rtrlist,
    IPForwardEntry *ifelist
    );

DWORD
CreateRouterStatsEntry(
    PLIST_ENTRY rtrlist,
    DWORD dwAddress,
    PRIPTEST_ROUTER_INFO *pprrs
    );

DWORD
PrintUsage(
    VOID
    );

DWORD
RipTest(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\queue.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: queue.c
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// timer queue, change queue, and event message queue implementation
//============================================================================

#include "pchrip.h"
#pragma hdrstop



//----------------------------------------------------------------------------
// Function:    EnqueueSendEntry
//
// This function adds an entry to the end of the queue of changed routes.
// It assumes the queue is already locked, and since it needs to check
// the maximum queue size, it assumes the global config is locked for
// reading or writing
//----------------------------------------------------------------------------
DWORD
EnqueueSendEntry(
    PLOCKED_LIST pQueue,
    PRIP_IP_ROUTE pRoute
    ) {

    DWORD dwErr;
    PLIST_ENTRY phead, ple;
    PSEND_QUEUE_ENTRY psqe;
    RIP_IP_ROUTE rir;
    

    phead = &pQueue->LL_Head;

    if (IsListEmpty(phead)) {
        psqe = NULL;
    }
    else {

        ple = phead->Blink;
        psqe = CONTAINING_RECORD(ple, SEND_QUEUE_ENTRY, SQE_Link);
    }


    if (psqe == NULL || psqe->SQE_Count >= MAX_PACKET_ENTRIES) {

        //
        // we'll need to allocate a new entry
        // check that the max queue size is not exceeded
        //

        if ((DWORD)ig.IG_SendQueueSize >= ig.IG_Config->GC_MaxSendQueueSize) {

            TRACE2(
                SEND,
                "dropping route: send queue size is %d bytes and max is %d bytes",
                ig.IG_SendQueueSize, ig.IG_Config->GC_MaxSendQueueSize
                );

            return ERROR_INSUFFICIENT_BUFFER;
        }


        psqe = RIP_ALLOC(sizeof(SEND_QUEUE_ENTRY));
        if (psqe == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for send queue entry",
                dwErr, sizeof(SEND_QUEUE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            return dwErr;
        }

        psqe->SQE_Count = 0;
        InsertTailList(phead, &psqe->SQE_Link);
    
        ig.IG_SendQueueSize += sizeof(SEND_QUEUE_ENTRY);
    }


    *(psqe->SQE_Routes + psqe->SQE_Count) = *pRoute;
    ++psqe->SQE_Count;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DequeueSendEntry
//
// This function removes an entry from the head of the queue of changed routes
// assuming the queue is already locked
//----------------------------------------------------------------------------
DWORD
DequeueSendEntry(
    PLOCKED_LIST pQueue,
    PRIP_IP_ROUTE pRoute
    ) {

    PLIST_ENTRY phead, ple;
    PSEND_QUEUE_ENTRY psqe;

    phead = &pQueue->LL_Head;

    if (IsListEmpty(phead)) {
        return ERROR_NO_MORE_ITEMS;
    }

    ple = phead->Flink;
    psqe = CONTAINING_RECORD(ple, SEND_QUEUE_ENTRY, SQE_Link);

    --psqe->SQE_Count;
    *pRoute = *(psqe->SQE_Routes + psqe->SQE_Count);

    if (psqe->SQE_Count == 0) {

        RemoveEntryList(&psqe->SQE_Link);
        RIP_FREE(psqe);

        ig.IG_SendQueueSize -= sizeof(SEND_QUEUE_ENTRY);
        if (ig.IG_SendQueueSize < 0) { ig.IG_SendQueueSize = 0; }
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    FlushSendQueue
//
// This function removes all entries from the send-queue. It assumes
// that the queue is locked.
//----------------------------------------------------------------------------
DWORD
FlushSendQueue(
    PLOCKED_LIST pQueue
    ) {

    PLIST_ENTRY ple, phead;
    PSEND_QUEUE_ENTRY psqe;

    phead = &pQueue->LL_Head;

    while (!IsListEmpty(phead)) {

        ple = RemoveHeadList(phead);
        psqe = CONTAINING_RECORD(ple, SEND_QUEUE_ENTRY, SQE_Link);

        RIP_FREE(psqe);
    }

    ig.IG_SendQueueSize = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    EnqueueRecvEntry
//
// assumes that recv queue is locked and that global config is locked
// for reading or writing
//----------------------------------------------------------------------------
DWORD
EnqueueRecvEntry(
    PLOCKED_LIST pQueue,
    DWORD dwCommand,
    PBYTE pRoutes
    ) {

    DWORD dwErr;
    PLIST_ENTRY phead;
    PRECV_QUEUE_ENTRY prqe;


    //
    // check that the max queue size is not exceeded
    //

    if ((DWORD)ig.IG_RecvQueueSize >= ig.IG_Config->GC_MaxRecvQueueSize) {

        TRACE2(
            RECEIVE,
            "dropping route: recv queue size is %d bytes and max is %d bytes",
            ig.IG_RecvQueueSize, ig.IG_Config->GC_MaxRecvQueueSize
            );

        return ERROR_INSUFFICIENT_BUFFER;
    }


    phead = &pQueue->LL_Head;

    prqe = RIP_ALLOC(sizeof(RECV_QUEUE_ENTRY));
    if (prqe == NULL) {

        dwErr = GetLastError();
        TRACE2(
            ANY, "error %d allocating %d bytes for receive queue entry",
            dwErr, sizeof(RECV_QUEUE_ENTRY)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }

    prqe->RQE_Routes = pRoutes;
    prqe->RQE_Command = dwCommand;

    InsertTailList(phead, &prqe->RQE_Link);

    ig.IG_RecvQueueSize += sizeof(RECV_QUEUE_ENTRY);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DequeueRecvEntry
//
// Retrieves the first item in the receive-queue.
// Assumes that recv queue is locked 
//----------------------------------------------------------------------------
DWORD
DequeueRecvEntry(
    PLOCKED_LIST pQueue,
    PDWORD pdwCommand,
    PBYTE *ppRoutes
    ) {

    PLIST_ENTRY ple, phead;
    PRECV_QUEUE_ENTRY prqe;


    phead = &pQueue->LL_Head;

    if (IsListEmpty(phead)) { return ERROR_NO_MORE_ITEMS; }

    ple = RemoveHeadList(phead);

    prqe = CONTAINING_RECORD(ple, RECV_QUEUE_ENTRY, RQE_Link);

    *ppRoutes = prqe->RQE_Routes;
    *pdwCommand = prqe->RQE_Command;

    RIP_FREE(prqe);

    ig.IG_RecvQueueSize -= sizeof(RECV_QUEUE_ENTRY);
    if (ig.IG_RecvQueueSize < 0) { ig.IG_RecvQueueSize = 0; }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    FlushRecvQueue
//
// Removes all entries from the receive queue.
// Assumes that the queue is locked.
//----------------------------------------------------------------------------
DWORD
FlushRecvQueue(
    PLOCKED_LIST pQueue
    ) {

    PLIST_ENTRY ple, phead;
    PRECV_QUEUE_ENTRY prqe;

    phead = &pQueue->LL_Head;

    while (!IsListEmpty(phead)) {

        ple = RemoveHeadList(phead);
        prqe = CONTAINING_RECORD(ple, RECV_QUEUE_ENTRY, RQE_Link);

        RIP_FREE(prqe->RQE_Routes);
        RIP_FREE(prqe);
    }

    ig.IG_RecvQueueSize = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    EnqueueEvent
//
// This function adds an entry to the end of the queue of
// Router Manager events. It assumes the queue is locked.
//----------------------------------------------------------------------------
DWORD
EnqueueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS Event,
    MESSAGE Result
    ) {


    DWORD dwErr;
    PLIST_ENTRY phead;
    PEVENT_QUEUE_ENTRY peqe;

    phead = &pQueue->LL_Head;

    peqe = RIP_ALLOC(sizeof(EVENT_QUEUE_ENTRY));
    if (peqe == NULL) {

        dwErr = GetLastError();
        TRACE2(
            ANY, "error %d allocating %d bytes for event quue entry",
            dwErr, sizeof(EVENT_QUEUE_ENTRY)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }

    peqe->EQE_Event = Event;
    peqe->EQE_Result = Result;

    InsertTailList(phead, &peqe->EQE_Link);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    DequeueEvent
//
// This function removes an entry from the head of the queue
// of Router Manager events. It assumes the queue is locked
//----------------------------------------------------------------------------
DWORD
DequeueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS *pEvent,
    PMESSAGE pResult
    ) {

    PLIST_ENTRY phead, ple;
    PEVENT_QUEUE_ENTRY peqe;

    phead = &pQueue->LL_Head;
    if (IsListEmpty(phead)) {
        return ERROR_NO_MORE_ITEMS;
    }

    ple = RemoveHeadList(phead);
    peqe = CONTAINING_RECORD(ple, EVENT_QUEUE_ENTRY, EQE_Link);

    *pEvent = peqe->EQE_Event;
    *pResult = peqe->EQE_Result;

    RIP_FREE(peqe);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\route.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: queue.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and macros used for internal route structures.
//============================================================================


#ifndef _ROUTE_H_
#define _ROUTE_H_

typedef struct _PROTOCOL_SPECIFIC_DATA {

    DWORD   PSD_Data[4];
    
} PROTOCOL_SPECIFIC_DATA, *PPROTOCOL_SPECIFIC_DATA;


typedef struct _IP_NETWORK {

    DWORD   N_NetNumber;
    DWORD   N_NetMask;
    
} IP_NETWORK, *PIP_NETWORK;


typedef struct _IP_SPECIFIC_DATA {

    DWORD   FSD_Metric;
    DWORD   FSD_Metric1;
    
} IP_SPECIFIC_DATA, *PIP_SPECIFIC_DATA;


typedef struct _RIP_IP_ROUTE {

    DWORD                   RR_RoutingProtocol;
    DWORD                   RR_InterfaceID;
    PROTOCOL_SPECIFIC_DATA  RR_ProtocolSpecificData;
    IP_NETWORK              RR_Network;
    IP_NETWORK              RR_NextHopAddress;
    IP_SPECIFIC_DATA        RR_FamilySpecificData;

    RTM_DEST_HANDLE         hDest;

} RIP_IP_ROUTE, *PRIP_IP_ROUTE;


DWORD
GetRouteInfo(
    IN  RTM_ROUTE_HANDLE    hRoute,
    IN  PRTM_ROUTE_INFO     pInRouteInfo, OPTIONAL
    IN  PRTM_DEST_INFO      pInDestInfo,  OPTIONAL
    OUT PRIP_IP_ROUTE       pRoute
    );

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\queue.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: queue.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and macros used for various queues.
//============================================================================

#ifndef _QUEUE_H_
#define _QUEUE_H_


//
// type definitions for send queue
//

typedef struct _SEND_QUEUE_ENTRY {

    LIST_ENTRY      SQE_Link;
    DWORD           SQE_Count;
    RIP_IP_ROUTE    SQE_Routes[MAX_PACKET_ENTRIES];

} SEND_QUEUE_ENTRY, *PSEND_QUEUE_ENTRY;


DWORD
EnqueueSendEntry(
    PLOCKED_LIST pQueue,
    PRIP_IP_ROUTE pRoute
    );

DWORD
DequeueSendEntry(
    PLOCKED_LIST pQueue,
    PRIP_IP_ROUTE pRoute
    );

DWORD
FlushSendQueue(
    PLOCKED_LIST pQueue
    );



//
// type definitions for the receive queue
//

typedef struct _RECV_QUEUE_ENTRY {

    LIST_ENTRY  RQE_Link;
    PBYTE       RQE_Routes;
    DWORD       RQE_Command;

} RECV_QUEUE_ENTRY, *PRECV_QUEUE_ENTRY;


DWORD
EnqueueRecvEntry(
    PLOCKED_LIST pQueue,
    DWORD dwCommand,
    PBYTE pRoutes
    );

DWORD
DequeueRecvEntry(
    PLOCKED_LIST pQueue,
    PDWORD dwCommand,
    PBYTE *ppRoutes
    );


DWORD
FlushRecvQueue(
    PLOCKED_LIST pQueue
    );



//
// type definitions for event message queue
//

typedef struct _EVENT_QUEUE_ENTRY {

    LIST_ENTRY              EQE_Link;
    ROUTING_PROTOCOL_EVENTS EQE_Event;
    MESSAGE                 EQE_Result;

} EVENT_QUEUE_ENTRY, *PEVENT_QUEUE_ENTRY;


DWORD
EnqueueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS Event,
    MESSAGE Result
    );

DWORD
DequeueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS *pEvent,
    PMESSAGE pResult
    );



#endif // _QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\sync.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    sync.c
//
// History:
//  Abolade Gbadegesin  Jan-12-1996     Created.
//
// Synchronization routines used by IPRIP.
//============================================================================


#include "pchrip.h"




//----------------------------------------------------------------------------
// Function:    QueueRipWorker  
//
// This function is called to queue a RIP function in a safe fashion;
// if cleanup is in progress or if RIP has stopped, this function
// discards the work-item.
//----------------------------------------------------------------------------

DWORD
QueueRipWorker(
    WORKERFUNCTION pFunction,
    PVOID pContext
    ) {

    DWORD dwErr = NO_ERROR;

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status != IPRIP_STATUS_RUNNING) {

        //
        // cannot queue a work function when RIP has quit or is quitting
        //

        dwErr = ERROR_CAN_NOT_COMPLETE;
    }
    else {

        BOOL bSuccess;
        
        ++ig.IG_ActivityCount;

        bSuccess = QueueUserWorkItem(
                        (LPTHREAD_START_ROUTINE)pFunction,
                        pContext, 0
                        );

        if (!bSuccess) {
            dwErr = GetLastError();
            --ig.IG_ActivityCount;
        }
    }

    LeaveCriticalSection(&ig.IG_CS);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    EnterRipAPI
//
// This function is called to when entering a RIP api, as well as
// when entering the input thread and timer thread.
// It checks to see if RIP has stopped, and if so it quits; otherwise
// it increments the count of active threads.
//----------------------------------------------------------------------------

BOOL
EnterRipAPI(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status == IPRIP_STATUS_RUNNING) {

        //
        // RIP is running, so the API may continue
        //

        ++ig.IG_ActivityCount;

        bEntered = TRUE;
    }
    else {

        //
        // RIP is not running, so the API exits quietly
        //

        bEntered = FALSE;
    }

    LeaveCriticalSection(&ig.IG_CS);

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    EnterRipWorker
//
// This function is called when entering a RIP worker-function.
// Since there is a lapse between the time a worker-function is queued
// and the time the function is actually invoked by a worker thread,
// this function must check to see if RIP has stopped or is stopping;
// if this is the case, then it decrements the activity count, 
// releases the activity semaphore, and quits.
//----------------------------------------------------------------------------

BOOL
EnterRipWorker(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status == IPRIP_STATUS_RUNNING) {

        //
        // RIP is running, so the function may continue
        //

        bEntered = TRUE;
    }
    else
    if (ig.IG_Status == IPRIP_STATUS_STOPPING) {

        //
        // RIP is not running, but it was, so the function must stop.
        // 

        --ig.IG_ActivityCount;

        ReleaseSemaphore(ig.IG_ActivitySemaphore, 1, NULL);

        bEntered = FALSE;
    }
    else {

        //
        // RIP probably never started. quit quietly
        //

        bEntered = FALSE;
    }


    LeaveCriticalSection(&ig.IG_CS);

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    LeaveRipWorker
//
// This function is called when leaving a RIP API or worker function.
// It decrements the activity count, and if it detects that RIP has stopped
// or is stopping, it releases the activity semaphore.
//----------------------------------------------------------------------------

VOID
LeaveRipWorker(
    ) {

    EnterCriticalSection(&ig.IG_CS);

    --ig.IG_ActivityCount;

    if (ig.IG_Status == IPRIP_STATUS_STOPPING) {

        ReleaseSemaphore(ig.IG_ActivitySemaphore, 1, NULL);
    }


    LeaveCriticalSection(&ig.IG_CS);

}




//----------------------------------------------------------------------------
// Function:    CreateReadWriteLock
//
// Initializes a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    pRWL->RWL_ReaderCount = 0;

    try {
        InitializeCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    pRWL->RWL_ReaderDoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (pRWL->RWL_ReaderDoneEvent != NULL) {
        return GetLastError();
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    DeleteReadWriteLock
//
// Frees resources used by a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    CloseHandle(pRWL->RWL_ReaderDoneEvent);
    pRWL->RWL_ReaderDoneEvent = NULL;
    DeleteCriticalSection(&pRWL->RWL_ReadWriteBlock);
    pRWL->RWL_ReaderCount = 0;
}




//----------------------------------------------------------------------------
// Function:    AcquireReadLock
//
// Secures shared ownership of the lock object for the caller.
//
// readers enter the read-write critical section, increment the count,
// and leave the critical section
//----------------------------------------------------------------------------

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock); 
    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&pRWL->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
// Function:    ReleaseReadLock
//
// Relinquishes shared ownership of the lock object.
//
// the last reader sets the event to wake any waiting writers
//----------------------------------------------------------------------------

VOID
ReleaseReadLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) < 0) {
        SetEvent(pRWL->RWL_ReaderDoneEvent); 
    }
}



//----------------------------------------------------------------------------
// Function:    AcquireWriteLock
//
// Secures exclusive ownership of the lock object.
//
// the writer blocks other threads by entering the ReadWriteBlock section,
// and then waits for any thread(s) owning the lock to finish
//----------------------------------------------------------------------------

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock);
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) >= 0) { 
        WaitForSingleObject(pRWL->RWL_ReaderDoneEvent, INFINITE);
    }
}




//----------------------------------------------------------------------------
// Function:    ReleaseWriteLock
//
// Relinquishes exclusive ownership of the lock object.
//
// the writer releases the lock by setting the count to zero
// and then leaving the ReadWriteBlock critical section
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    pRWL->RWL_ReaderCount = 0;
    LeaveCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\sync.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and macros used to implement synchronization.
//============================================================================

#ifndef _SYNC_H_
#define _SYNC_H_


//
// type definition for multiple-reader/single-writer lock
// Note: there is a similar facility provided by nturtl.h
// through the structure RTL_RESOURCE and several functions.
// However, that implementation has the potential for starving
// a thread trying to acquire write accesss, if there are a large
// number of threads interested in acquiring read access.
// Such a scenario is avoided in the implementation given in this
// header. However, a mapping is also given to the RTL_RESOURCE
// functionality, so that IPRIP can be compiled to use either form
//

#ifdef RIP_RWL

//
// use IPRIP's definitions
//

typedef struct _READ_WRITE_LOCK {

    CRITICAL_SECTION    RWL_ReadWriteBlock;
    LONG                RWL_ReaderCount;
    HANDLE              RWL_ReaderDoneEvent;

} READ_WRITE_LOCK, *PREAD_WRITE_LOCK;


DWORD CreateReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID DeleteReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireReadLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseReadLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireWriteLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseWriteLock(PREAD_WRITE_LOCK pRWL);


//
// macro functions for manipulating a read-write lock
//

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
    CreateReadWriteLock(pRWL)
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
    DeleteReadWriteLock(pRWL)

#define READ_WRITE_LOCK_CREATED(pRWL)                                       \
            ((pRWL)->RWL_ReaderDoneEvent != NULL)


#define ACQUIRE_READ_LOCK(pRWL)                                             \
    AcquireReadLock(pRWL)

#define RELEASE_READ_LOCK(pRWL)                                             \
    ReleaseReadLock(pRWL)

#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
    AcquireWriteLock(pRWL)

#define RELEASE_WRITE_LOCK(pRWL)                                            \
    ReleaseWriteLock(pRWL)

#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
    (ReleaseReadLock(pRWL), AcquireWriteLock(pRWL))

#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
    (ReleaseWriteLock(pRWL), AcquireReadLock(pRWL))


#else // i.e. !RIP_RWL


//
// use the RTL_RESOURCE mechanism
//

typedef RTL_RESOURCE READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
            RtlInitializeResource((pRWL))
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
            RtlDeleteResource((pRWL))
#define READ_WRITE_LOCK_CREATED(pRWL)   (TRUE)
#define ACQUIRE_READ_LOCK(pRWL)                                             \
            RtlAcquireResourceShared((pRWL),TRUE)
#define RELEASE_READ_LOCK(pRWL)                                             \
            RtlReleaseResource((pRWL))
#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
            RtlAcquireResourceExclusive((pRWL),TRUE)
#define RELEASE_WRITE_LOCK(pRWL)                                            \
            RtlReleaseResource((pRWL))
#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
            RtlConvertSharedToExclusive((pRWL))
#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
            RtlConvertExclusiveToShared((pRWL))

#endif // RIP_RWL



//
// type definition for generic locked list
// access is sychronized with a critical section
//

typedef struct _LOCKED_LIST {
    LIST_ENTRY          LL_Head;
    CRITICAL_SECTION    LL_Lock;
    DWORD               LL_Created;
} LOCKED_LIST, *PLOCKED_LIST;



//
// macro functions for manipulating the locked list
//

#define CREATE_LOCKED_LIST(pLL)                                             \
            InitializeListHead(&(pLL)->LL_Head);                            \
            InitializeCriticalSection(&(pLL)->LL_Lock);                     \
            (pLL)->LL_Created = 0x12345678

#define LOCKED_LIST_CREATED(pLL)                            \
            ((pLL)->LL_Created == 0x12345678)

#define DELETE_LOCKED_LIST(pLL,type,field) {                \
            PLIST_ENTRY _ple;                               \
            (pLL)->LL_Created = 0;                          \
            DeleteCriticalSection(&(pLL)->LL_Lock);         \
            while (!IsListEmpty(&(pLL)->LL_Head)) {         \
                _ple = RemoveHeadList(&(pLL)->LL_Head);     \
                RIP_FREE(CONTAINING_RECORD(_ple,type,field));\
            }                                               \
        }

#define ACQUIRE_LIST_LOCK(pLL)                              \
            EnterCriticalSection(&(pLL)->LL_Lock)

#define RELEASE_LIST_LOCK(pLL)                              \
            LeaveCriticalSection(&(pLL)->LL_Lock)


#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\table.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: table.c
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
//      V Raman             Oct-3-1996
//                          Added code to create/delete/wait on
//                          ITE_DeactivateEvent.  Also added code to set
//                          ITE_Flags when deactivate is pending.
//
//      V Raman             Oct-27-1996
//                          Removed deactivate event and made 
//                          DeactivateInterface synchronous
//                          
// interface table and peer table implementation
//============================================================================

#include "pchrip.h"
#pragma hdrstop


DWORD CreateIfSocket(PIF_TABLE_ENTRY pITE);
DWORD DeleteIfSocket(PIF_TABLE_ENTRY pITE);
DWORD InsertIfByAddress(PIF_TABLE pTable, PIF_TABLE_ENTRY pITE);
DWORD InsertPeerByAddress(PPEER_TABLE pTable, PPEER_TABLE_ENTRY pPTE);
DWORD AddNeighborToIfConfig(DWORD dwRemoteAddress, PIF_TABLE_ENTRY pite);



//----------------------------------------------------------------------------
// Function:    CreateIfTable
//
// initializes an interface table
//----------------------------------------------------------------------------

DWORD
CreateIfTable(
    PIF_TABLE pTable
    ) {

    DWORD dwErr;
    PLIST_ENTRY phead, plstart, plend;


    //
    // initialize the multiple-reader/single-writer synchronization object
    //

    dwErr = CreateReadWriteLock(&pTable->IT_RWL);
    if (dwErr != NO_ERROR) {
        TRACE1(IF, "error %d creating read-write-lock", dwErr);
        return dwErr;
    }


    //
    // initialize the hash table
    //

    plstart = pTable->IT_HashTableByIndex;
    plend = plstart + IF_HASHTABLE_SIZE;
    for (phead = plstart; phead < plend; phead++) {
        InitializeListHead(phead);
    }

    //
    // initialize the lists ordered by address and by index
    //

    InitializeListHead(&pTable->IT_ListByAddress);
    InitializeListHead(&pTable->IT_ListByIndex);


    //
    // initialize the table's critical section
    //

    try {
        InitializeCriticalSection(&pTable->IT_CS);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = GetExceptionCode();
    }


    //
    // Create timers for full updates and for triggered updates
    //

    if (!CreateTimerQueueTimer(
            &pTable->IT_FinishFullUpdateTimer,
            ig.IG_TimerQueueHandle,
            WorkerFunctionFinishFullUpdate, NULL,
            10000000, 10000000, 0
            )) {

        dwErr = GetLastError();
        TRACE1(IF, "error %d creating finish full update timer", dwErr);
        return dwErr;
    }            
    
    if (!CreateTimerQueueTimer(
            &pTable->IT_FinishTriggeredUpdateTimer,
            ig.IG_TimerQueueHandle,
            WorkerFunctionFinishTriggeredUpdate, NULL,
            10000000, 10000000, 0
            )) {

        dwErr = GetLastError();
        TRACE1(IF, "error %d creating finish triggered update timer", dwErr);
        return dwErr;
    }            


    //
    // initialize remainder of struct
    //

    if (dwErr == NO_ERROR) {

        pTable->IT_Created = 0x12345678;
        pTable->IT_Flags = 0;

        pTable->IT_LastUpdateTime.LowPart =
        pTable->IT_LastUpdateTime.HighPart = 0;
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DeleteIfTable
//
// frees resources used by an interface table.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeleteIfTable(
    PIF_TABLE pTable
    ) {

    DWORD dwIndex;
    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, plend, phead;


    //
    // free memory for all existing interfaces
    //

    plend = pTable->IT_HashTableByIndex + IF_HASHTABLE_SIZE;
    for (ple = plend - IF_HASHTABLE_SIZE; ple < plend; ple++) {

        while (!IsListEmpty(ple)) {

            phead = RemoveHeadList(ple);
            pite = CONTAINING_RECORD(phead, IF_TABLE_ENTRY, ITE_HTLinkByIndex);

            if (IF_IS_BOUND(pite)) {

                DeleteIfSocket(pite);

                if (IF_IS_ENABLED(pite)) {
                    RemoveEntryList(&pite->ITE_LinkByAddress);
                }

                RIP_FREE(pite->ITE_Binding);
            }
            
            RIP_FREE(pite->ITE_Config);
            RIP_FREE(pite);
        }
    }


    //
    // delete synchronization objects
    //

    DeleteCriticalSection(&pTable->IT_CS);
    DeleteReadWriteLock(&pTable->IT_RWL);

    pTable->IT_Created = 0;
    pTable->IT_Flags = 0;
    
    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    CreateIfEntry
//
// inserts an entry into the interface table.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
CreateIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    NET_INTERFACE_TYPE dwIfType,
    PIPRIP_IF_CONFIG pConfig,
    PIF_TABLE_ENTRY *ppEntry
    ) {

    DWORD dwErr, dwSize;
    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, phead;
    PIPRIP_IF_CONFIG picsrc, picdst;

    if (ppEntry != NULL) { *ppEntry = NULL; }

    dwErr = NO_ERROR;


    do {

        //
        // fail if the interface exists
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite != NULL) {

            pite = NULL;
            TRACE1(IF, "interface %d already exists", dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }
    

        //
        // allocate memory for the new interface
        //

        pite = RIP_ALLOC(sizeof(IF_TABLE_ENTRY));

        if (pite == NULL) {

            dwErr = GetLastError();
            TRACE3(
                ANY, "error %d allocating %d bytes for interface %d",
                dwErr, sizeof(IF_TABLE_ENTRY), dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize interface fields
        //
    
        pite->ITE_Index = dwIndex;
        pite->ITE_Type = dwIfType;
    
        //
        // Change semantics to come up in UNBOUND-DISABLED state
        //
 
        //pite->ITE_Flags = ITEFLAG_ENABLED;
        pite-> ITE_Flags = 0;
        
        pite->ITE_Config = NULL;
        pite->ITE_Binding = NULL;
        pite->ITE_Sockets = NULL;
        pite->ITE_FullOrDemandUpdateTimer = NULL;

        picsrc = (PIPRIP_IF_CONFIG)pConfig;
        dwSize = IPRIP_IF_CONFIG_SIZE(picsrc);
        

        //
        // validate the configuration parameters
        //

        dwErr = ValidateIfConfig(pConfig);
        if (dwErr != NO_ERROR) {
            TRACE1(IF, "invalid config specified for interface %d", dwIndex);
            break;
        }


        //
        // allocate space to hold the interface configuration
        //

        pite->ITE_Config = picdst = RIP_ALLOC(dwSize);

        if (picdst == NULL) {

            dwErr = GetLastError();
            TRACE3(
                IF, "error %d allocating %d bytes for interface %d config",
                dwErr, dwSize, dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy the configuration
        //

        CopyMemory(picdst, picsrc, dwSize);


        //
        // initialize the binding information and interface stats
        //

        pite->ITE_Binding = NULL;
        ZeroMemory(&pite->ITE_Stats, sizeof(IPRIP_IF_STATS));
    

        //
        // insert the interface in the hash table
        //

        InsertHeadList(
            pTable->IT_HashTableByIndex + IF_HASHVALUE(dwIndex),
            &pite->ITE_HTLinkByIndex
            );


        //
        // insert the interface in the list ordered by index
        //

        phead = &pTable->IT_ListByIndex;
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            PIF_TABLE_ENTRY ptemp;

            ptemp = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByIndex);
            if (pite->ITE_Index < ptemp->ITE_Index) { break; }
        }

        InsertTailList(ple, &pite->ITE_LinkByIndex);

        if (ppEntry != NULL) { *ppEntry = pite; }
    
    } while(FALSE);


    if (dwErr != NO_ERROR && pite != NULL) {
        if (pite->ITE_Config != NULL) { RIP_FREE(pite->ITE_Config); }
        RIP_FREE(pite);
    }
    
    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DeleteIfEntry
//
// removes an entry from the interface table.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeleteIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    PIF_TABLE_ENTRY pite;

    //
    // find the interface if it exists
    //

    pite = GetIfByIndex(pTable, dwIndex);

    if (pite == NULL) {
        TRACE1(IF, "could not find interface %d", dwIndex);
        return ERROR_INVALID_PARAMETER;
    }


    //
    // cleanup the socket depending on its state
    //

    if (IF_IS_BOUND(pite)) {

        DeleteIfSocket(pite);

        if (IF_IS_ENABLED(pite)) {
            RemoveEntryList(&pite->ITE_LinkByAddress);
        }

        RIP_FREE(pite->ITE_Binding);
    }


    //
    // remove it from the list ordered by index
    // as well as from the hash table
    //

    RemoveEntryList(&pite->ITE_LinkByIndex);
    RemoveEntryList(&pite->ITE_HTLinkByIndex);


    RIP_FREE(pite->ITE_Config);
    RIP_FREE(pite);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    ValidateIfConfig
//
// Checks the parameters in an IPRIP_IF_CONFIG structure.
//----------------------------------------------------------------------------

DWORD
ValidateIfConfig(
    PIPRIP_IF_CONFIG pic
    ) {

    CHAR    szStr[12];
    
    if (pic->IC_Metric > IPRIP_INFINITE) {

        TRACE1(
            IF, "Invalid interface metric %d specified", 
            pic->IC_Metric
            );
            
        _ltoa(pic->IC_Metric, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Metric", szStr, ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }


    if (pic->IC_UpdateMode != IPRIP_UPDATE_PERIODIC &&
        pic->IC_UpdateMode != IPRIP_UPDATE_DEMAND) {

        TRACE1(
            IF, "Invalid update mode %d specified", 
            pic->IC_UpdateMode
            );
            
        _ltoa(pic->IC_UpdateMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Update Mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AcceptMode != IPRIP_ACCEPT_DISABLED &&
        pic->IC_AcceptMode != IPRIP_ACCEPT_RIP1 &&
        pic->IC_AcceptMode != IPRIP_ACCEPT_RIP1_COMPAT &&
        pic->IC_AcceptMode != IPRIP_ACCEPT_RIP2) {

        TRACE1(
            IF, "Invalid accept mode %d specified", 
            pic->IC_AcceptMode
            );
            
        _ltoa(pic->IC_AcceptMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Accept Mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
        pic->IC_AnnounceMode != IPRIP_ANNOUNCE_RIP1 &&
        pic->IC_AnnounceMode != IPRIP_ANNOUNCE_RIP1_COMPAT &&
        pic->IC_AnnounceMode != IPRIP_ANNOUNCE_RIP2) {

        TRACE1(
            IF, "Invalid announce mode %d specified", 
            pic->IC_AnnounceMode
            );
            
        _ltoa(pic->IC_AnnounceMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Announce Mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AuthenticationType != IPRIP_AUTHTYPE_NONE &&
        pic->IC_AuthenticationType != IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        TRACE1(
            IF, "Invalid authentication type %d specified", 
            pic->IC_AuthenticationType
            );
            
        _ltoa(pic->IC_AuthenticationType, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Authentication Type", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_UnicastPeerMode != IPRIP_PEER_DISABLED &&
        pic->IC_UnicastPeerMode != IPRIP_PEER_ALSO &&
        pic->IC_UnicastPeerMode != IPRIP_PEER_ONLY) {

        TRACE1(
            IF, "Invalid unicast peer mode %d specified", 
            pic->IC_UnicastPeerMode
            );
            
        _ltoa(pic->IC_UnicastPeerMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "unicast peer mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AcceptFilterMode != IPRIP_FILTER_DISABLED &&
        pic->IC_AcceptFilterMode != IPRIP_FILTER_INCLUDE &&
        pic->IC_AcceptFilterMode != IPRIP_FILTER_EXCLUDE) {

        TRACE1(
            IF, "Invalid accept filter mode %d specified", 
            pic->IC_AcceptFilterMode
            );
            
        _ltoa(pic->IC_AcceptFilterMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Accept filter mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_AnnounceFilterMode != IPRIP_FILTER_DISABLED &&
        pic->IC_AnnounceFilterMode != IPRIP_FILTER_INCLUDE &&
        pic->IC_AnnounceFilterMode != IPRIP_FILTER_EXCLUDE) {

        TRACE1(
            IF, "Invalid announce filter mode %d specified", 
            pic->IC_AnnounceFilterMode
            );
            
        _ltoa(pic->IC_AnnounceFilterMode, szStr, 10);
        LOGERR2(
            INVALID_IF_CONFIG, "Announce filter mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
        
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    BindIfEntry
//
// Updates the binding information for the specified interface.
// Assumes interface table is locked for writing
//----------------------------------------------------------------------------

DWORD
BindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    ) {

    DWORD i, j, dwErr = NO_ERROR, dwSize;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    PIP_ADAPTER_BINDING_INFO piabi;
    BOOL bFound;

    pib = NULL;

    do {

        //
        // retrieve the interface entry
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // If the interface is already bound, check to see if he is giving
        // us a different binding. If he is, then it is an error. Otherwise
        // we shall be obliging and not complain too much
        //

        if (IF_IS_BOUND(pite)) {
           
            TRACE1(IF, "interface %d is already bound", dwIndex);
 
            pib = pite->ITE_Binding;

            if(pib->IB_AddrCount != pBinding->AddressCount)
            {
                TRACE1(IF, "interface %d is bound and has different binding",dwIndex);

                dwErr = ERROR_INVALID_PARAMETER;

                break;
            }

            paddr = IPRIP_IF_ADDRESS_TABLE(pib);

            for(i = 0; i < pBinding->AddressCount; i++)
            {
                bFound = FALSE;
            
                for(j = 0; j < pib->IB_AddrCount; j++)
                {
                    if((paddr[j].IA_Address == pBinding->Address[i].Address) &&
                       (paddr[j].IA_Netmask == pBinding->Address[i].Mask))
                    {
                        bFound = TRUE;
                        
                        break;
                    }
                }

                if(!bFound)
                {
                    TRACE1(IF,"interface %d is bound and has different binding",dwIndex);

                    dwErr = ERROR_INVALID_PARAMETER;
            
                    break;
                }
            }

            //
            // At this time we have dwErr as either NO_ERROR or
            // ERROR_INVALID_PARAMETER. Either case we can break here
            // since we are done
            //

            break;
        }


        //
        // make sure there is at least one address
        //

        if (pBinding->AddressCount == 0) { break; }

        dwSize = sizeof(IPRIP_IF_BINDING) +
                    pBinding->AddressCount * sizeof(IPRIP_IP_ADDRESS);


        //
        // allocate memory to store the binding
        // in our format
        //

        pib = RIP_ALLOC(dwSize);

        if (pib == NULL) {

            dwErr = GetLastError();
            TRACE3(
                IF, "error %d allocating %d bytes for binding on interface %d",
                dwErr, dwSize, dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // convert the binding into our format
        //

        pib->IB_AddrCount = pBinding->AddressCount;
        paddr = IPRIP_IF_ADDRESS_TABLE(pib);
        
        for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
            paddr->IA_Address = pBinding->Address[i].Address;
            paddr->IA_Netmask = pBinding->Address[i].Mask;
        }


        //
        // save the binding in the interface entry
        //

        pite->ITE_Binding = pib;


#if 0
        //
        // for demand dial interfaces add neighbor
        //

        if ( pite-> ITE_Type == DEMAND_DIAL ) {

            dwErr = AddNeighborToIfConfig( pBinding-> RemoteAddress, pite );

            if ( dwErr != NO_ERROR ) { break ; }
        }
#endif

        //
        // create sockets for interface's addresses
        //

        dwErr = CreateIfSocket(pite);

        if (dwErr != NO_ERROR) {

            TRACE2(
                IF, "error %d creating sockets for interface %d", dwErr, dwIndex
                );

            break;
        }


        //
        // mark the interface as being bound
        //

        pite->ITE_Flags |= ITEFLAG_BOUND;

    
        //
        // we save the binding information in a private table
        // so it can be quickly accessed and searched when we are
        // trying to guess subnet masks given IP addresses;
        //
    
        ACQUIRE_BINDING_LOCK_EXCLUSIVE();
    
        dwErr = CreateBindingEntry(ig.IG_BindingTable, pib);
    
        RELEASE_BINDING_LOCK_EXCLUSIVE();
    

        //
        // if interface is also enabled, it is now active
        // so queue activation work-item
        //

        if (IF_IS_ENABLED(pite)) {

            //
            // place interface on the list of active interfaces
            //

            dwErr = InsertIfByAddress(pTable, pite);

            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d inserting interface %d in active list",
                    dwErr, dwIndex
                    );

                pite->ITE_Flags &= ~ITEFLAG_BOUND;

                DeleteIfSocket(pite);

                break;
            }


            //
            // queue the work-item to send initial request
            //

            dwErr = QueueRipWorker(
                        WorkerFunctionActivateInterface, (PVOID)UlongToPtr(dwIndex)
                        );
        
            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d queuing work-item for interface %d",
                    dwErr, dwIndex
                    );
                LOGERR0(QUEUE_WORKER_FAILED, dwErr);

                RemoveEntryList(&pite->ITE_LinkByAddress);

                pite->ITE_Flags &= ~ITEFLAG_BOUND;

                DeleteIfSocket(pite);

                break;
            }
        }

    } while(FALSE);


    if (dwErr != NO_ERROR) {

        if (pib) { RIP_FREE(pib); }

        if (pite) { pite->ITE_Binding = NULL; }
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    UnBindIfEntry
//
// removes the binding for the specified interface.
// assumes the interface table is locked for writing.
//----------------------------------------------------------------------------

DWORD
UnBindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE_ENTRY pite;


    do {

        //
        // retrieve the interface specified
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // quit if the interface is already unbound 
        //

        if (IF_IS_UNBOUND(pite)) {

            dwErr = ERROR_INVALID_PARAMETER;
            TRACE1(
                IF, "interface %d is already unbound", dwIndex
                );

            break;
        }


        //
        // clear the "bound" flag
        //

        pite->ITE_Flags &= ~ITEFLAG_BOUND;


        //
        // if the interface isn't enabled, close the socket for the interface;
        // if the interface is enabled, that means it was active
        // and we must queue the deactivation work-item
        //

        if (!IF_IS_ENABLED(pite)) {

            DeleteIfSocket(pite);

            ACQUIRE_BINDING_LOCK_EXCLUSIVE();
        
            dwErr = DeleteBindingEntry(ig.IG_BindingTable, pite->ITE_Binding);
        
            RELEASE_BINDING_LOCK_EXCLUSIVE();

            RIP_FREE(pite->ITE_Binding);
            pite->ITE_Binding = NULL;
        }
        else {

            //
            // the interface was active, so deactivate it
            //
            // remove from active list
            //

            RemoveEntryList(&pite->ITE_LinkByAddress);
        

            WorkerFunctionDeactivateInterface( (PVOID)UlongToPtr(dwIndex));

            //
            // close the socket ourselves if required
            //

            if ( pite-> ITE_Binding ) {
                
                DeleteIfSocket(pite);

                ACQUIRE_BINDING_LOCK_EXCLUSIVE();

                dwErr = DeleteBindingEntry(
                            ig.IG_BindingTable, pite->ITE_Binding
                            );
            
                RELEASE_BINDING_LOCK_EXCLUSIVE();

                RIP_FREE(pite->ITE_Binding);
                pite->ITE_Binding = NULL;
            }

            else {

                dwErr = NO_ERROR;
            }
            
        }
        
    } while(FALSE);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    EnableIfEntry
//
// configures an interface for RIP activity, including setting up
// a socket and linking the interface into the list ordered by address.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
EnableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD dwErr;
    PLIST_ENTRY ple, phead;
    PIF_TABLE_ENTRY pite;

    do {


        //
        // retrieve the interface
        //

        pite = GetIfByIndex(pTable, dwIndex);
    
        if (pite == NULL) {

            TRACE1(IF, "could not find interface %d",dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }
    

        //
        // quit if the interface is already enabled
        // 

        if (IF_IS_ENABLED(pite)) {

            TRACE1(IF, "interface %d is already enabled", dwIndex);
            dwErr = NO_ERROR;

            break;
        }
    
    
        pite->ITE_Flags |= ITEFLAG_ENABLED;
    

        //
        // if interface is already bound, it is now active,
        // so queue the interface activation work-item
        //

        if (IF_IS_BOUND(pite)) {


            //
            // place interface on the list of active interfaces
            //

            dwErr = InsertIfByAddress(pTable, pite);

            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d inserting interface %d in active list",
                    dwErr, dwIndex
                    );
    
                pite->ITE_Flags &= ~ITEFLAG_ENABLED;

                break;
            }


            //
            // queue the work-item to send initial request
            //

            dwErr = QueueRipWorker(
                        WorkerFunctionActivateInterface, (PVOID)UlongToPtr(dwIndex)
                        );
        
            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d queuing work-item for interface %d",
                    dwErr, dwIndex
                    );
                LOGERR0(QUEUE_WORKER_FAILED, dwErr);

                RemoveEntryList(&pite->ITE_LinkByAddress);
        
                pite->ITE_Flags &= ~ITEFLAG_ENABLED;

                break;
            }

        }

        dwErr = NO_ERROR;
        
    } while(FALSE);
    
    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    ConfigureIfEntry
//
// modifies the configuration for an already-existing interface
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
ConfigureIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIPRIP_IF_CONFIG pConfig
    ) {

    DWORD dwErr, dwSize;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG picsrc, picdst;

    dwErr = NO_ERROR;


    do {

        //
        // retrieve the interface to be configured
        //

        pite = GetIfByIndex(pTable, dwIndex);
    
        if (pite == NULL) {
            TRACE1(IF, "could not find interface %d", dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    

        //
        // get the size of the new configuration
        //

        picsrc = (PIPRIP_IF_CONFIG)pConfig;
        dwSize = IPRIP_IF_CONFIG_SIZE(picsrc);

    
        //
        // validate the new configuration
        //

        dwErr = ValidateIfConfig(picsrc);

        if (dwErr != NO_ERROR) {

            TRACE1(IF, "invalid config specified for interface %d", dwIndex);

            break;
        }
    

        //
        // allocate space to hold the new configuration
        //

        picdst = RIP_ALLOC(dwSize);
        if (picdst == NULL) {

            dwErr = GetLastError();
            TRACE3(
                IF, "error %d allocating %d bytes for interface %d config",
                dwErr, dwSize, dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy the new configuration, and free the old one
        //

        CopyMemory(picdst, picsrc, dwSize);

        if (pite->ITE_Config != NULL) { RIP_FREE(pite->ITE_Config); }
        pite->ITE_Config = picdst;



        //
        // if the interface is bound, re-initialize the interface
        //
    
        if (IF_IS_BOUND(pite)) {

            //
            // close the sockets and set them up again
            //

            dwErr = DeleteIfSocket(pite);

            dwErr = CreateIfSocket(pite);

            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d creating sockets for interface %d",
                    dwErr, dwIndex
                    );

                break;
            }
    


            //
            // re-activate the interface if it is active
            //

            if (IF_IS_ENABLED(pite)) {

                //
                // queue the work-item to activate the interface
                //

                dwErr = QueueRipWorker(
                            WorkerFunctionActivateInterface, (PVOID)UlongToPtr(dwIndex)
                            );

                if (dwErr != NO_ERROR) {

                    TRACE2(
                        IF, "error %d queueing work-item for interface %d",
                        dwErr, dwIndex
                        );
                    LOGERR0(QUEUE_WORKER_FAILED, dwErr);

                    break;
                }
            }
    
        }
    
        dwErr = NO_ERROR;

    } while(FALSE);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DisableIfEntry
//
// stops RIP activity on an interface, removing the interface
// from the list of interfaces ordered by address.
// this assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DisableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE_ENTRY pite;

    do {


        //
        // retrieve the interface to be disabled
        //

        pite = GetIfByIndex(pTable, dwIndex);
    
        if (pite == NULL) {
            TRACE1(IF, "could not find interface %d", dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    

        //
        // quit if already disabled
        //

        if (IF_IS_DISABLED(pite)) {
            TRACE1(IF, "interface %d is already disabled", dwIndex);
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // clear the enabled flag 
        //

        pite->ITE_Flags &= ~ITEFLAG_ENABLED;


        //
        // if this interface was not bound, clearing the flag is enough;
        // if the interface was bound (and therefore active),
        // deactivate it here
        //

        if (IF_IS_BOUND(pite)) {

            //
            // remove from active list
            //

            RemoveEntryList(&pite->ITE_LinkByAddress);
    

            //
            // execute the work-item to send final updates
            //

            WorkerFunctionDeactivateInterface( (PVOID) UlongToPtr(dwIndex) );
        }
        
        dwErr = NO_ERROR;

    } while(FALSE);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    CreateIfSocket
//
// creates sockets for an interface, setting it up according to
// the configuration including in the interface control block.
// this assumes the table containing the interface is locked for writing
//----------------------------------------------------------------------------

DWORD
CreateIfSocket(
    PIF_TABLE_ENTRY pite
    ) {

    SOCKADDR_IN sinsock;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    DWORD i, dwErr, dwOption, dwIndex;
    LPSTR lpszAddr;

    
    pic = pite->ITE_Config;
    pib = pite->ITE_Binding;
    dwIndex = pite->ITE_Index;

    //
    // allocate an array of sockets
    //

    pite->ITE_Sockets = RIP_ALLOC(pib->IB_AddrCount * sizeof(SOCKET));
    if (pite->ITE_Sockets == NULL) {

        dwErr = GetLastError();
        TRACE3(
            IF, "error %d allocating %d bytes for interface %d sockets",
            dwErr, pib->IB_AddrCount * sizeof(SOCKET), dwIndex
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }


    //
    // initialize the array of sockets
    //

    for (i = 0; i < pib->IB_AddrCount; i++) {
        pite->ITE_Sockets[i] = INVALID_SOCKET;
    }


    //
    // create sockets for each address in the binding
    //

    paddr = IPRIP_IF_ADDRESS_TABLE(pib);
    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {


        //
        // create the socket
        //

        pite->ITE_Sockets[i] = WSASocket(
                                AF_INET, SOCK_DGRAM, 0, NULL, 0, 0
                                );

        if (pite->ITE_Sockets[i] == INVALID_SOCKET) {

            dwErr = WSAGetLastError();
            lpszAddr = INET_NTOA(paddr->IA_Address);

            if (lpszAddr != NULL) {
                TRACE3(
                    IF, "error %d creating socket for interface %d (%s)",
                    dwErr, dwIndex, lpszAddr
                    );
                LOGERR1(CREATE_SOCKET_FAILED_2, lpszAddr, dwErr);
            }
            break;
        }


        //
        // try to allow re-use of this address
        //

        dwOption = 1;

        dwErr = setsockopt(
                    pite->ITE_Sockets[i], SOL_SOCKET, SO_REUSEADDR,
                    (PBYTE)&dwOption, sizeof(dwOption)
                    );

        if (dwErr == SOCKET_ERROR) {

            dwErr = WSAGetLastError();

            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE3(
                    IF, "error %d setting re-use flag for interface %d (%s)",
                    dwErr, dwIndex, INET_NTOA(paddr->IA_Address)
                    );
            }
        }


        //
        // enable broadcasting if not exclusively RIP2 mode,
        // or if there are any unicast peers configured
        //

        if (pic->IC_AcceptMode == IPRIP_ACCEPT_RIP1 ||
            pic->IC_AcceptMode == IPRIP_ACCEPT_RIP1_COMPAT ||
            pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1 ||
            pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1_COMPAT ||
            (pic->IC_UnicastPeerMode != IPRIP_PEER_DISABLED &&
             pic->IC_UnicastPeerCount != 0)) {
    

            //
            // make sure broadcasting is enabled for this socket
            //

            dwOption = 1;

            dwErr = setsockopt(
                        pite->ITE_Sockets[i], SOL_SOCKET, SO_BROADCAST,
                        (PBYTE)&dwOption, sizeof(dwOption)
                        );

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();

                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {        
                    TRACE3(
                        IF, "error %d enabling broadcast on interface %d (%s)",
                        dwErr, dwIndex, lpszAddr
                        );
                    LOGERR1(ENABLE_BROADCAST_FAILED, lpszAddr, dwErr);
                }
                break;
            }
        }



        //
        // bind the socket to the RIP port
        //

        sinsock.sin_family = AF_INET;
        sinsock.sin_port = htons(IPRIP_PORT);
        sinsock.sin_addr.s_addr = paddr->IA_Address;
    
        dwErr = bind(
                    pite->ITE_Sockets[i], (LPSOCKADDR)&sinsock,
                    sizeof(SOCKADDR_IN)
                    );

        if (dwErr == SOCKET_ERROR) {

            dwErr = WSAGetLastError();
            
            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE3(
                    IF, "error %d binding on socket for interface %d (%s)",
                    dwErr, dwIndex, lpszAddr
                    );
                LOGERR1(BIND_FAILED, lpszAddr, dwErr);
            }
            break;
        }



        //
        // enable multicasting if not exclusively RIP1/RIP1-compatible mode
        //

        if (pic->IC_AcceptMode == IPRIP_ACCEPT_RIP2 ||
            pic->IC_AcceptMode == IPRIP_ACCEPT_RIP1_COMPAT ||
            pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP2) {

            struct ip_mreq imOption;
        

            //
            // set the interface from which multicasts must be sent
            //

            sinsock.sin_addr.s_addr = paddr->IA_Address;

            dwErr = setsockopt(
                        pite->ITE_Sockets[i], IPPROTO_IP, IP_MULTICAST_IF,
                        (PBYTE)&sinsock.sin_addr, sizeof(IN_ADDR)
                        );

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();

                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        IF, "error %d setting interface %d (%s) as multicast",
                        dwErr, dwIndex, lpszAddr
                        );
                    LOGERR1(SET_MCAST_IF_FAILED, lpszAddr, dwErr);
                }
                break;
            }


            //
            // join the IPRIP multicast group
            //

            imOption.imr_multiaddr.s_addr = IPRIP_MULTIADDR;
            imOption.imr_interface.s_addr = paddr->IA_Address;

            dwErr = setsockopt(
                        pite->ITE_Sockets[i], IPPROTO_IP, IP_ADD_MEMBERSHIP,
                        (PBYTE)&imOption, sizeof(imOption)
                        );

            if (dwErr == SOCKET_ERROR) {

                dwErr = WSAGetLastError();
                
                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        IF, "error %d enabling multicast on interface %d (%s)",
                        dwErr, dwIndex, lpszAddr
                        );
                    LOGERR1(JOIN_GROUP_FAILED, lpszAddr, dwErr);
                }
                break;
            }
        }

        dwErr = NO_ERROR;
    }


    if (i < pib->IB_AddrCount) {

        //
        // something failed if we are here
        //
    
        DeleteIfSocket(pite);
    }


    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DeleteIfSocket
//
// closes the sockets used by an interface, if any.
// assumes that the interface is active, and that the interface table
// is locked for writing
//----------------------------------------------------------------------------

DWORD
DeleteIfSocket(
    PIF_TABLE_ENTRY pite
    ) {

    DWORD i;

    for (i = 0; i < pite->ITE_Binding->IB_AddrCount; i++) {

        if (pite->ITE_Sockets[i] != INVALID_SOCKET) {
    
            if (closesocket(pite->ITE_Sockets[i]) == SOCKET_ERROR) {
                TRACE1(IF, "error %d closing socket", WSAGetLastError());
            }
    
            pite->ITE_Sockets[i] = INVALID_SOCKET;
        }
    }


    RIP_FREE(pite->ITE_Sockets);
    pite->ITE_Sockets = NULL;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    GetIfByIndex
//
// returns the interface with the given index.
// assumes the table is locked for reading or writing
//----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByIndex(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    PIF_TABLE_ENTRY pite = NULL;
    PLIST_ENTRY phead, ple;

    phead = pTable->IT_HashTableByIndex + IF_HASHVALUE(dwIndex);

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_HTLinkByIndex);

        if (pite->ITE_Index == dwIndex) {
            break;
        }
    }

    if (ple == phead) { return NULL; }
    else { return pite; }
}




//----------------------------------------------------------------------------
// Function:    GetIfByAddress
//
// returns the interface bound to the given address.
// assumes the table is locked for reading or writing
//----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByAddress(
    PIF_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    ) {

    DWORD i;
    PIPRIP_IF_BINDING pib;
    PLIST_ENTRY phead, pfl;
    PIPRIP_IP_ADDRESS paddr;
    PIF_TABLE_ENTRY pite, piterec;

    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }

    phead = &pTable->IT_ListByAddress;
    pite = NULL;


    //
    // return record at head of list if mode is GetFirst
    //

    if (dwGetMode == GETMODE_FIRST) {
        if (phead->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            return NULL; 
        }
        else {
            pfl = phead->Flink;
            return CONTAINING_RECORD(pfl, IF_TABLE_ENTRY, ITE_LinkByAddress);
        }
    }


    //
    // search for the entry 
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {

        piterec = CONTAINING_RECORD(pfl, IF_TABLE_ENTRY, ITE_LinkByAddress);

        pib = piterec->ITE_Binding;

        paddr = IPRIP_IF_ADDRESS_TABLE(pib);

        for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
            if (dwAddress == paddr->IA_Address) { pite = piterec; break; }
        }

        if (pite) { break; }
    }



    //
    // return record after the one found if mode is GetNext
    //

    if (dwGetMode == GETMODE_NEXT && pite != NULL) {
        pfl = &pite->ITE_LinkByAddress;

        //
        // if entry found is last one, return NULL,
        // otherwise, return the following entry
        //

        if (pfl->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            pite = NULL;
        }
        else {
            pfl = pfl->Flink;
            pite = CONTAINING_RECORD(pfl, IF_TABLE_ENTRY, ITE_LinkByAddress);
        }
    }


    //
    // if the interface wasn't found, this will still be NULL
    //

    return pite;
}



//----------------------------------------------------------------------------
// Function:    GetIfByListIndex
//
// This function is similar to GetIfByAddress in that it supports
// three modes of retrieval, but it is different in that it looks
// in the list of interfaces sorted by index.
//----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByListIndex(
    PIF_TABLE pTable,
    DWORD dwIndex,
    DWORD dwGetMode,
    PDWORD pdwErr
    ) {

    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, phead;

    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }

    phead = &pTable->IT_ListByIndex;
    pite = NULL;

    //
    // return record at head of list if mode is GETMODE_FIRST;
    // if list is empty, return NULL.
    //

    if (dwGetMode == GETMODE_FIRST) {
        if (phead->Flink == phead) { 
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            return NULL; 
        }
        else {
            ple = phead->Flink;
            return CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByIndex);
        }
    }


    //
    // get the entry requested
    //

    pite = GetIfByIndex(pTable, dwIndex);


    //
    // if mode is GETMODE_NEXT, return the item after the one retrieved
    //

    if (dwGetMode == GETMODE_NEXT && pite != NULL) {

        ple = &pite->ITE_LinkByIndex;

        //
        // if entry found is last one, return NULL,
        // otherwise return the following entry
        //

        if (ple->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            pite = NULL;
        }
        else {
            ple = ple->Flink;
            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByIndex);
        }
    }


    return pite;
}



//----------------------------------------------------------------------------
// Function:    InsertIfByAddress
//
// inserts the given interface into the list of interfaces sorted by address.
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
InsertIfByAddress(
    PIF_TABLE pTable,
    PIF_TABLE_ENTRY pITE
    ) {

    INT cmp;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IP_ADDRESS paddr;
    DWORD dwAddress, dwITEAddress;
    PLIST_ENTRY phead, pfl;

    phead = &pTable->IT_ListByAddress;

    paddr = IPRIP_IF_ADDRESS_TABLE(pITE->ITE_Binding);
    dwAddress = paddr->IA_Address;


    //
    // search for the insertion point 
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {

        pite = CONTAINING_RECORD(pfl, IF_TABLE_ENTRY, ITE_LinkByAddress);

        paddr = IPRIP_IF_ADDRESS_TABLE(pite->ITE_Binding);

        dwITEAddress = paddr->IA_Address;

        if (INET_CMP(dwAddress, dwITEAddress, cmp) < 0) { break; }
        else if (cmp == 0) { return ERROR_ALREADY_EXISTS; }
    }

    InsertTailList(pfl, &pITE->ITE_LinkByAddress);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    AddNeighborToIfConfig
//
// Adds a unicast neighbor to an interface config block.
//----------------------------------------------------------------------------

DWORD
AddNeighborToIfConfig(
    DWORD               dwRemoteAddress,
    PIF_TABLE_ENTRY     pite
    ) {


    BOOL                bFound  = FALSE;
    
    DWORD               dwErr   = (DWORD) -1,
                        dwSize  = 0,
                        dwCnt   = 0;
                        
    PDWORD              pdwAddr = NULL;
    
    PIPRIP_IF_CONFIG    pic     = NULL,
                        picNew  = NULL;


    do
    {
        pic = pite-> ITE_Config;

        
        //
        // verify neighbor is not aready present
        //

        pdwAddr = IPRIP_IF_UNICAST_PEER_TABLE( pic );

        for ( dwCnt = 0; dwCnt < pic-> IC_UnicastPeerCount; dwCnt++ )
        {
            if ( dwRemoteAddress == pdwAddr[ dwCnt ] )
            {
                bFound = TRUE;
                break;
            }
        }


        //
        // entry exits, enable unicast peer mode and quit
        //

        if ( bFound )
        {
            LPSTR lpszAddr = INET_NTOA( dwRemoteAddress );

            pic-> IC_UnicastPeerMode = IPRIP_PEER_ALSO;

            dwErr = NO_ERROR;
            
            if (lpszAddr != NULL) {
                TRACE2(
                    IF, 
                    "Unicast neighbor %s already present in configuration on interface %d",
                     lpszAddr, pite-> ITE_Index
                );
            }            
            break;
        }

        
        //
        // allocate new config block
        //

        dwSize = IPRIP_IF_CONFIG_SIZE( pic ) + sizeof( DWORD );
    
        picNew = RIP_ALLOC( dwSize );

        if ( picNew == NULL )
        {
            dwErr = GetLastError();
            TRACE3(
                IF, "error %d allocating %d bytes for configuration on interface %d",
                dwErr, dwSize, pite-> ITE_Index
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy base structure
        //
        
        CopyMemory( picNew, pic, sizeof( IPRIP_IF_CONFIG ) );


        //
        // copy uicast peer table
        //

        CopyMemory( 
            IPRIP_IF_UNICAST_PEER_TABLE( picNew ),
            IPRIP_IF_UNICAST_PEER_TABLE( pic ),
            pic-> IC_UnicastPeerCount * sizeof( DWORD )
        );

        
        //
        // add new neighbor and set unicast neighbor mode
        //
        
        pdwAddr = IPRIP_IF_UNICAST_PEER_TABLE( picNew );

        pdwAddr[ picNew-> IC_UnicastPeerCount++ ] = dwRemoteAddress;

        picNew-> IC_UnicastPeerMode = IPRIP_PEER_ALSO;
        

        //
        // Copy accept and annouce filters
        //

        CopyMemory(
            IPRIP_IF_ACCEPT_FILTER_TABLE( picNew ),
            IPRIP_IF_ACCEPT_FILTER_TABLE( pic ),
            pic-> IC_AcceptFilterCount * sizeof( IPRIP_IP_ADDRESS )
        );

        CopyMemory(
            IPRIP_IF_ANNOUNCE_FILTER_TABLE( picNew ),
            IPRIP_IF_ANNOUNCE_FILTER_TABLE( pic ),
            pic-> IC_AnnounceFilterCount * sizeof( IPRIP_IP_ADDRESS )
        );


        //
        // save the new config 
        //
        
        pite-> ITE_Config = picNew;
        
        RIP_FREE( pic );

        dwErr = NO_ERROR;


    } while ( FALSE );

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    CreatePeerTable
//
// initializes the given peer table
//----------------------------------------------------------------------------

DWORD
CreatePeerTable(
    PPEER_TABLE pTable
    ) {

    DWORD dwErr;
    PLIST_ENTRY ple, plstart, plend;

    //
    // initialize the hash table of peers
    //

    plstart = pTable->PT_HashTableByAddress;
    plend = plstart + PEER_HASHTABLE_SIZE;

    for (ple = plstart; ple < plend; ple++) {
        InitializeListHead(ple);
    }


    //
    // initialize the list of peers ordered by address
    //

    InitializeListHead(&pTable->PT_ListByAddress);


    //
    // initialize the multiple-read/single-write synchronization object
    //

    dwErr = CreateReadWriteLock(&pTable->PT_RWL);
    if (dwErr == NO_ERROR) {
        pTable->PT_Created = 0x12345678;
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DeletePeerTable
//
// frees the resources used by the given peer table
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeletePeerTable(
    PPEER_TABLE pTable
    ) {

    PLIST_ENTRY ple, phead;
    PPEER_TABLE_ENTRY ppte;


    //
    // empty the hash table of peer stats structures
    //

    phead = &pTable->PT_ListByAddress;
    while (!IsListEmpty(phead)) {
        ple = RemoveHeadList(phead);
        ppte = CONTAINING_RECORD(ple, PEER_TABLE_ENTRY, PTE_LinkByAddress);
        RIP_FREE(ppte);
    }


    //
    // delete the table's synchronization object
    //

    DeleteReadWriteLock(&pTable->PT_RWL);

    pTable->PT_Created = 0;
    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    CreatePeerEntry
//
// creates an entry in the given table for a peer with the given address
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
CreatePeerEntry(
    PPEER_TABLE pTable,
    DWORD dwAddress,
    PPEER_TABLE_ENTRY *ppEntry
    ) {

    DWORD dwErr;
    PLIST_ENTRY ple, phead;
    PPEER_TABLE_ENTRY ppte;

    if (ppEntry != NULL) { *ppEntry = NULL; }

    //
    // make sure the entry does not already exist
    //

    ppte = GetPeerByAddress(pTable, dwAddress, GETMODE_EXACT, NULL);
    if (ppte != NULL) {
        if (ppEntry != NULL) { *ppEntry = ppte; }
        return NO_ERROR;
    }


    //
    // allocate memory for the new peer entry
    //

    ppte = RIP_ALLOC(sizeof(PEER_TABLE_ENTRY));

    if (ppte == NULL) {

        LPSTR lpszAddr = INET_NTOA(dwAddress);

        dwErr = GetLastError();

        if (lpszAddr != NULL) {
            TRACE3(
                IF, "error %d allocating %d bytes for peer %s entry",
                dwErr, sizeof(PEER_TABLE_ENTRY), lpszAddr
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);
        }
        return dwErr;
    }


    //
    // initialize the fields
    //

    ppte->PTE_Address = dwAddress;
    ZeroMemory(&ppte->PTE_Stats, sizeof(IPRIP_PEER_STATS));


    //
    // insert the peer stats entry in the hash table
    //

    phead = pTable->PT_HashTableByAddress + PEER_HASHVALUE(dwAddress);
    InsertHeadList(phead, &ppte->PTE_HTLinkByAddress);


    //
    // insert the entry in the list sorted by address
    //

    dwErr = InsertPeerByAddress(pTable, ppte);

    if (ppEntry != NULL) { *ppEntry = ppte; }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeletePeerEntry
//
// deletes the entry for the peer with the given address
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeletePeerEntry(
    PPEER_TABLE pTable,
    DWORD dwAddress
    ) {

    PPEER_TABLE_ENTRY ppte;

    //
    // quit if the entry cannot be found
    //

    ppte = GetPeerByAddress(pTable, dwAddress, GETMODE_EXACT, NULL);
    if (ppte == NULL) { return ERROR_INVALID_PARAMETER; }


    //
    // remove the entry from the hash-table 
    // and from the list sorted by address
    //

    RemoveEntryList(&ppte->PTE_LinkByAddress);
    RemoveEntryList(&ppte->PTE_HTLinkByAddress);

    RIP_FREE(ppte);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    GetPeerByAddress
//
// returns the entry for the peer with the given address
// assumes the table is locked for reading or writing
//----------------------------------------------------------------------------

PPEER_TABLE_ENTRY
GetPeerByAddress(
    PPEER_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    ) {

    PLIST_ENTRY phead, pfl;
    PPEER_TABLE_ENTRY ppte, ppterec;

    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }


    //
    // return head of list if in GetFirst mode
    //

    if (dwGetMode == GETMODE_FIRST) {
        phead = &pTable->PT_ListByAddress;
        if (phead->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            return NULL;
        }
        else {
            pfl = phead->Flink;
            return CONTAINING_RECORD(pfl, PEER_TABLE_ENTRY, PTE_LinkByAddress);
        }
    }



    phead = pTable->PT_HashTableByAddress + PEER_HASHVALUE(dwAddress);
    ppte = NULL;


    //
    // search for the entry
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {
        ppterec = CONTAINING_RECORD(pfl, PEER_TABLE_ENTRY, PTE_HTLinkByAddress);
        if (ppterec->PTE_Address == dwAddress) { ppte = ppterec; break; }
    }



    //
    // return entry after the one found if in GetNext mode
    //

    if (dwGetMode == GETMODE_NEXT && ppte != NULL) {
        phead = &pTable->PT_ListByAddress;
        pfl = &ppte->PTE_LinkByAddress;

        //
        // return NULL if entry is last one
        //

        if (pfl->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            return NULL;
        }
        else {
            pfl = pfl->Flink;
            return CONTAINING_RECORD(pfl, PEER_TABLE_ENTRY, PTE_LinkByAddress);
        }
    }


    //
    // if the peer wasn't found, this will still be NULL
    //

    return ppte;
}



//----------------------------------------------------------------------------
// Function:    InsertPeerByAddress
//
// inserts the given entry into the list of peers sorted by address
// assumes the table is locked for writing
//----------------------------------------------------------------------------

DWORD
InsertPeerByAddress(
    PPEER_TABLE pTable,
    PPEER_TABLE_ENTRY pPTE
    ) {

    INT cmp;
    PPEER_TABLE_ENTRY ppte;
    DWORD dwAddress, dwPTEAddress;
    PLIST_ENTRY phead, pfl;


    dwAddress = pPTE->PTE_Address;

    phead = &pTable->PT_ListByAddress;


    //
    // search for the peer entry
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {

        ppte = CONTAINING_RECORD(pfl, PEER_TABLE_ENTRY, PTE_LinkByAddress);

        dwPTEAddress = ppte->PTE_Address;

        if (INET_CMP(dwAddress, dwPTEAddress, cmp) < 0) { break; }
        else if (cmp == 0) { return ERROR_ALREADY_EXISTS; }
    }

    InsertTailList(pfl, &pPTE->PTE_LinkByAddress);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    CreateRouteTable
//
// Initializes a route table. Note that no synchronization is provided.
//----------------------------------------------------------------------------

DWORD
CreateRouteTable(
    PROUTE_TABLE pTable
    ) {

    PLIST_ENTRY plstart, plend, ple;


    //
    // initialize the hash table buckets
    //

    plstart = pTable->RT_HashTableByNetwork;
    plend = plstart + ROUTE_HASHTABLE_SIZE;

    for (ple = plstart; ple < plend; ple++) {
        InitializeListHead(ple);
    }


    pTable->RT_Created = 0x12345678;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteRouteTable
//
// Removes all entries from a route table and frees resources used.
//----------------------------------------------------------------------------

DWORD
DeleteRouteTable(
    PROUTE_TABLE pTable
    ) {

    PROUTE_TABLE_ENTRY prte;
    PLIST_ENTRY ple, plend, phead;


    //
    // empty the hash-table buckets
    //

    plend = pTable->RT_HashTableByNetwork + ROUTE_HASHTABLE_SIZE;

    for (ple = plend - ROUTE_HASHTABLE_SIZE; ple < plend; ple++) {

        while (!IsListEmpty(ple)) {

            phead = RemoveHeadList(ple);
            prte = CONTAINING_RECORD(phead, ROUTE_TABLE_ENTRY, RTE_Link);

            RIP_FREE(prte);
        }
    }
            


    pTable->RT_Created = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    WriteSummaryRoutes
//
// Writes to RTM all entries which are marked as summary routes.
//----------------------------------------------------------------------------

DWORD
WriteSummaryRoutes(
    PROUTE_TABLE pTable,
    HANDLE hRtmHandle
    ) {

    DWORD dwFlags, dwErr;
    PRIP_IP_ROUTE prir;
    PROUTE_TABLE_ENTRY prte;
    PLIST_ENTRY ple, phead, plstart, plend;

    BOOL bRelDest = FALSE, bRelRoute = FALSE;
    RTM_NET_ADDRESS rna;
    RTM_DEST_INFO rdi;
    PRTM_ROUTE_INFO prri;

    CHAR szNetwork[20], szNetmask[20];
                        
    
    //
    // allocate route info structure
    //
    
    prri = RIP_ALLOC(
            RTM_SIZE_OF_ROUTE_INFO( ig.IG_RtmProfile.MaxNextHopsInRoute )
            );

    if (prri == NULL)
    {
        dwErr = GetLastError();
        TRACE2(
            ANY, "error %d allocated %d bytes in WriteSummaryRoutes",
            dwErr, RTM_SIZE_OF_ROUTE_INFO(ig.IG_RtmProfile.MaxNextHopsInRoute)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }
    

    //
    // go through each bucket writing routes
    //

    plstart = pTable->RT_HashTableByNetwork;
    plend = plstart + ROUTE_HASHTABLE_SIZE;

    for (phead = plstart; phead < plend; phead++) {
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            prte = CONTAINING_RECORD(ple, ROUTE_TABLE_ENTRY, RTE_Link);
            prir = &prte->RTE_Route;

            bRelDest = bRelRoute = FALSE;

            
            do {
                
                //
                // if a valid route exists do not overwrite it with
                // a summary route
                //

                RTM_IPV4_SET_ADDR_AND_MASK( 
                    &rna, prir-> RR_Network.N_NetNumber,
                    prir-> RR_Network.N_NetMask
                    );
                
                dwErr = RtmGetExactMatchDestination(
                            hRtmHandle, &rna, RTM_BEST_PROTOCOL,
                            RTM_VIEW_MASK_UCAST, &rdi
                            );

                if (dwErr == NO_ERROR)
                {
                    bRelDest = TRUE;
                    
                    //
                    // Get info for the best route to this destination
                    //

                    dwErr = RtmGetRouteInfo(
                                hRtmHandle, rdi.ViewInfo[0].Route,
                                prri, NULL
                                );

                    if (dwErr != NO_ERROR)
                    {
                        TRACE1(
                            ANY, "error %d getting route info in"
                            "WriteSummaryRoutes", dwErr
                            );

                        break;
                    }

                    bRelRoute = TRUE;

                    
                    //
                    // Check if this route is active.  If it is skip
                    // adding an inactive summary route
                    //

                    if (!(prri-> Flags & RTM_ROUTE_FLAGS_INACTIVE)) {
                    
                        lstrcpy(szNetwork, INET_NTOA(prir-> RR_Network.N_NetNumber));
                        lstrcpy(szNetmask, INET_NTOA(prir-> RR_Network.N_NetMask));

                        TRACE2(
                            ROUTE,
                            "Route %s %s not overwritten in summary route addition",
                            szNetwork, szNetmask
                        );
                        
                        break;
                    }
                }


                //
                // you reach here only if you don't have an active
                // route to the summary route's destination
                //
                
                //
                // if this is a summary entry (i.e. is a RIP route
                // with the summary entry set)
                //

                if (prir->RR_RoutingProtocol == PROTO_IP_RIP &&
                    GETROUTEFLAG(prir) == ROUTEFLAG_SUMMARY) {

                    LPSTR lpszAddr;
                    
                    COMPUTE_ROUTE_METRIC(prir);

                    dwErr = AddRtmRoute(
                                hRtmHandle, prir, NULL, prte->RTE_TTL,
                                prte->RTE_HoldTTL, FALSE
                                );

                    lpszAddr = INET_NTOA(prir-> RR_Network.N_NetNumber);
                    if (lpszAddr != NULL) { 
                        lstrcpy(szNetwork, lpszAddr );
                        lpszAddr = INET_NTOA(prir-> RR_Network.N_NetMask);
                        if (lpszAddr != NULL) {
                            lstrcpy(szNetmask, INET_NTOA(prir-> RR_Network.N_NetMask));
#if ROUTE_DBG
                            TRACE2(
                                ROUTE, "Adding summary route %s %s", szNetwork, 
                                szNetmask
                            );
#endif
                            if (dwErr != NO_ERROR) {
                            
                                LPSTR lpszNexthop = 
                                        INET_NTOA(prir->RR_NextHopAddress.N_NetNumber);
                                if (lpszNexthop != NULL) {
                                    TRACE4(
                                        ROUTE,
                                        "error %d writing summary route to %s:%s via %s",
                                        dwErr,  szNetwork, szNetmask, lpszNexthop
                                        );
                                    LOGWARN2(
                                        ADD_ROUTE_FAILED_1, szNetwork, lpszNexthop, dwErr
                                        );
                                }
                            }
                        }
                    }
                }
                
            } while (FALSE);


            if (dwErr != NO_ERROR) {

                //
                // in case one of the INET_NTOA statements failed above, just
                // trace the fact that there was an error
                //
                
                TRACE1(
                    ROUTE,
                    "error %d writing summary route",
                    dwErr
                    );
            }
            
            //
            // release handles as required
            //
            
            if (bRelRoute) {
            
                dwErr = RtmReleaseRouteInfo(hRtmHandle, prri);

                if (dwErr != NO_ERROR) {

                    TRACE1(
                        ANY, "error %d releasing route info in"
                        " WriteSummaryRoutes", dwErr
                        );
                }
            }

            if (bRelDest) {

                dwErr = RtmReleaseDestInfo(hRtmHandle, &rdi);
                
                if (dwErr != NO_ERROR) {

                    TRACE1(
                        ANY, "error %d releasing route info in"
                        " WriteSummaryRoutes", dwErr
                        );
                }
            }
        }
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    CreateRouteEntry
//
// Makes an entry in the route table for the given route.
//----------------------------------------------------------------------------

DWORD
CreateRouteEntry(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute,
    DWORD dwTTL,
    DWORD dwHoldTTL
    ) {

    DWORD dwErr;
    PLIST_ENTRY ple;
    PROUTE_TABLE_ENTRY prte;

    //
    // see if the entry  exists first
    //

    if ((prte = GetRouteByRoute(pTable, pRoute)) != NULL) {

        //
        // just update the metric if the new route has a lower one
        //

        if (GETROUTEMETRIC(&prte->RTE_Route) > GETROUTEMETRIC(pRoute)) {
            SETROUTEMETRIC(&prte->RTE_Route, GETROUTEMETRIC(pRoute));
        }

        return NO_ERROR;
    }


    //
    // allocate space for the new route
    //

    prte = RIP_ALLOC(sizeof(ROUTE_TABLE_ENTRY));
    if (prte == NULL) {

        dwErr = GetLastError();
        TRACE2( 
            ANY, "error %d allocating %d bytes for route table entry",
            dwErr, sizeof(ROUTE_TABLE_ENTRY)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }


    //
    // initialize the entry's fields and copy the actual route structure
    //

    prte->RTE_TTL = dwTTL;
    prte->RTE_HoldTTL = dwHoldTTL;
    CopyMemory(&prte->RTE_Route, pRoute, sizeof(RIP_IP_ROUTE));


    //
    // insert the route in the hash table
    //

    ple = pTable->RT_HashTableByNetwork +
          ROUTE_HASHVALUE(pRoute->RR_Network.N_NetNumber);

    InsertHeadList(ple, &prte->RTE_Link);


#if ROUTE_DBG
    {
        LPSTR lpszAddr;
        char szNet[20], szMask[20];

        lpszAddr = INET_NTOA(pRoute-> RR_Network.N_NetNumber);
        if (lpszAddr != NULL) {
            lstrcpy(szNet, lpszAddr);

            lpszAddr = INET_NTOA(pRoute-> RR_Network.N_NetMask);
            if (lpszAddr != NULL) {
                lstrcpy(szMask, lpszAddr);

                lpszAddr = INET_NTOA(pRoute-> RR_NextHopAddress.N_NetNumber);
                if (lpszAddr != NULL) {
                    TRACE4(
                        ROUTE, "Creating summary route : Route %s %s via %s"
                        "on interface %d",
                        szNet, szMask, lpszAddr, pRoute-> RR_InterfaceID
                        );
                }
            }
        }
    }
    
#endif

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteRouteEntry
//
// Remove the entry which matches the given route.
//----------------------------------------------------------------------------

DWORD
DeleteRouteEntry(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute
    ) {

    PROUTE_TABLE_ENTRY prte;

    //
    // find the route to be deleted
    //

    prte = GetRouteByRoute(pTable, pRoute);
    if (prte == NULL) { return ERROR_INVALID_PARAMETER; }


    //
    // remove it from the hash table and free the memory it used
    //

    RemoveEntryList(&prte->RTE_Link);

    RIP_FREE(prte);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    GetRouteByRoute
//
// Searches for the route entry which matches the given route, if any,
// and returns a pointer to it if it is found.
//----------------------------------------------------------------------------

PROUTE_TABLE_ENTRY
GetRouteByRoute(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute
    ) {

    DWORD dwNetNumber;
    PLIST_ENTRY phead, pfl;
    PROUTE_TABLE_ENTRY prte, prterec;


    //
    // get the net number to be found and find the corresponding bucket
    //

    prte = NULL;
    dwNetNumber = pRoute->RR_Network.N_NetNumber;

    phead = pTable->RT_HashTableByNetwork + ROUTE_HASHVALUE(dwNetNumber);


    //
    // search the bucket for the route 
    //

    for (pfl = phead->Flink; pfl != phead; pfl = pfl->Flink) {
        prterec = CONTAINING_RECORD(pfl, ROUTE_TABLE_ENTRY, RTE_Link);
        if (prterec->RTE_Route.RR_Network.N_NetNumber == dwNetNumber) {
            prte = prterec; break;
        }
    }


    //
    // if the route wasn't found, this will still be NULL
    //

    return prte;
}





//----------------------------------------------------------------------------
// Function:    CreateBindingTable
//
// Initializes a table of bindings.
//----------------------------------------------------------------------------

DWORD
CreateBindingTable(
    PBINDING_TABLE pTable
    ) {

    DWORD dwErr;
    PLIST_ENTRY plend, ple;


    //
    // initialize the hash table of bindings
    //

    plend = pTable->BT_HashTableByNetwork + BINDING_HASHTABLE_SIZE;
    for (ple = plend - BINDING_HASHTABLE_SIZE; ple < plend; ple++) {
        InitializeListHead(ple);
    }


    //
    // initialize the table's synchronization object
    //

    dwErr = CreateReadWriteLock(&pTable->BT_RWL);

    if (dwErr == NO_ERROR) {
        pTable->BT_Created = 0x12345678;
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DeleteBindingTable
//
// Cleans up resources used by a binding table.
//----------------------------------------------------------------------------

DWORD
DeleteBindingTable(
    PBINDING_TABLE pTable
    ) {

    PBINDING_TABLE_ENTRY pbte;
    PLIST_ENTRY plend, ple, phead;


    //
    // destroy the synchronization object
    //

    DeleteReadWriteLock(&pTable->BT_RWL);


    //
    // empty the hash-table buckets
    //

    plend = pTable->BT_HashTableByNetwork + BINDING_HASHTABLE_SIZE;

    for (ple = plend - BINDING_HASHTABLE_SIZE; ple < plend; ple++) {

        while (!IsListEmpty(ple)) {

            phead = RemoveHeadList(ple);
            pbte = CONTAINING_RECORD(phead, BINDING_TABLE_ENTRY, BTE_Link);

            RIP_FREE(pbte);
        }
    }
            

    pTable->BT_Created = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    CreateBindingEntry
//
// Adds a binding to the table.
// assumes the binding table is locked for writing
//----------------------------------------------------------------------------

DWORD
CreateBindingEntry(
    PBINDING_TABLE pTable,
    PIPRIP_IF_BINDING pib
    ) {

    INT cmp;
    PLIST_ENTRY ple, phead;
    PIPRIP_IP_ADDRESS paddr;
    PBINDING_TABLE_ENTRY pbte;
    DWORD i, dwErr, dwAddress, dwNetmask, dwNetwork;


    //
    // go through the IP addresses in the interface binding,
    // adding each to the binding table
    //

    paddr = IPRIP_IF_ADDRESS_TABLE(pib);

    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
    
        dwAddress = paddr->IA_Address;
        dwNetmask = paddr->IA_Netmask;


        //
        // compute the network part of the binding
        //
    
        dwNetwork = (dwAddress & NETCLASS_MASK(dwAddress));
    
    
        //
        // get the hash bucket to which the binding belongs,
        // and find the insertion point in the bucket 
        //
    
        phead = pTable->BT_HashTableByNetwork + BINDING_HASHVALUE(dwNetwork);
    
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
    
            pbte = CONTAINING_RECORD(ple, BINDING_TABLE_ENTRY, BTE_Link);
    
            INET_CMP(dwNetwork, pbte->BTE_Network, cmp);
            if (cmp < 0) { break; }
            else
            if (cmp > 0) { continue; }
    
            //
            // the network parts are equal; further compare
            // against the IP address fields
            //
    
            INET_CMP(dwAddress, pbte->BTE_Address, cmp);
            if (cmp < 0) { break; }
            else
            if (cmp > 0) { continue; }
    
            //
            // the addresses are also equal; return an error
            //
    
            return ERROR_ALREADY_EXISTS;
        }
    
    
        //
        // we now have the insertion point, so create the new item
        //
    
        pbte = RIP_ALLOC(sizeof(BINDING_TABLE_ENTRY));
        if (pbte == NULL) {
    
            dwErr = GetLastError();
            TRACE2(
                IF, "error %d allocating %d bytes for binding entry",
                dwErr, sizeof(BINDING_TABLE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);
    
            return dwErr;
        }
    
    
        pbte->BTE_Address = dwAddress;
        pbte->BTE_Network = dwNetwork;
        pbte->BTE_Netmask = dwNetmask;
    
    
        //
        // insert the entry
        //
    
        InsertTailList(ple, &pbte->BTE_Link);
    
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteBindingEntry
//
// Removes a binding from the table.
// assumes the binding table is locked for writing
//----------------------------------------------------------------------------

DWORD
DeleteBindingEntry(
    PBINDING_TABLE pTable,
    PIPRIP_IF_BINDING pib
    ) {


    PLIST_ENTRY ple, phead;
    PIPRIP_IP_ADDRESS paddr;
    PBINDING_TABLE_ENTRY pbte;
    DWORD i, dwNetwork, dwAddress, dwNetmask;

    paddr = IPRIP_IF_ADDRESS_TABLE(pib);

    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {

        dwAddress = paddr->IA_Address;
        dwNetmask = paddr->IA_Netmask;


        //
        // get the hash bucket to be searched
        //
    
        dwNetwork = (dwAddress & NETCLASS_MASK(dwAddress));
    
        phead = pTable->BT_HashTableByNetwork + BINDING_HASHVALUE(dwNetwork);
    
    
        //
        // search the bucket for the binding specified
        //
    
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
    
            pbte = CONTAINING_RECORD(ple, BINDING_TABLE_ENTRY, BTE_Link);
    
            if (dwAddress != pbte->BTE_Address ||
                dwNetmask != pbte->BTE_Netmask) {
                continue;
            }
    
    
            //
            // the entry to be deleted has been found;
            // remove it from the list and free its memory
            //
    
            RemoveEntryList(&pbte->BTE_Link);
    
            RIP_FREE(pbte);

            break;
        }
    }


    return NO_ERROR;
}




//---------------------------------------------------------------------------
// Function:    GuessSubnetMask
//
// This function attempts to deduce the subnet mask of an IP address
// based on the configured addresses and masks on the local host.
// assumes the binding table is locked for reading or writing
//---------------------------------------------------------------------------

DWORD
GuessSubnetMask(
    DWORD dwAddress,
    PDWORD pdwNetclassMask
    ) {

    INT cmp;
    PLIST_ENTRY ple, phead;
    PBINDING_TABLE_ENTRY pbte;
    DWORD dwNetwork, dwNetmask, dwGuessMask;


    //
    // the mask for a default route (0.0.0.0) is zero
    //

    if (dwAddress == 0) {
        if (pdwNetclassMask != NULL) { *pdwNetclassMask = 0; }
        return 0;
    }



    //
    // the mask for the broadcast route is all-ones (255.255.255.255)
    //

    if (dwAddress == INADDR_BROADCAST) {
        if (pdwNetclassMask != NULL) { *pdwNetclassMask = INADDR_BROADCAST; }
        return INADDR_BROADCAST;
    }


    //
    // otherwise, we start with the network-class mask
    //

    dwGuessMask = dwNetmask = NETCLASS_MASK(dwAddress);
    if (pdwNetclassMask != NULL) { *pdwNetclassMask = dwNetmask; }


    //
    // if the route is a network route, we're done
    //

    if ((dwAddress & ~dwNetmask) == 0) { return dwNetmask; }


    //
    // otherwise, search through the bindings table
    // to see if one is on the same network as this address
    //

    dwNetwork = (dwAddress & dwNetmask);

    phead = ig.IG_BindingTable->BT_HashTableByNetwork +
            BINDING_HASHVALUE(dwNetwork);

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pbte = CONTAINING_RECORD(ple, BINDING_TABLE_ENTRY, BTE_Link);

        INET_CMP(dwNetwork, pbte->BTE_Network, cmp);

        if (cmp < 0) { break; }
        else
        if (cmp > 0) { continue; }


        //
        // this entry is on the same network as the address passed in
        // so see if the entry's netmask matches the address;
        // if it does, we're done; otherwise, save this mask
        // as a guess, and keep looking.
        // note that this exhaustive search is the only way we can
        // reliably guess masks for supernets
        //

        if ((dwAddress & pbte->BTE_Netmask) ==
            (pbte->BTE_Address & pbte->BTE_Netmask)) {

            return pbte->BTE_Netmask;
        }

        dwGuessMask = pbte->BTE_Netmask;
    }


    //
    // return whatever has been our best guess so far
    //

    return dwGuessMask;
}


DWORD
AddRtmRoute(
    RTM_ENTITY_HANDLE   hRtmHandle,
    PRIP_IP_ROUTE       prir,
    RTM_NEXTHOP_HANDLE  hNextHop        OPTIONAL,
    DWORD               dwTimeOut,
    DWORD               dwHoldTime,
    BOOL                bActive
    )
/*++

Routine Description :

    This function adds a route to the RTMv2 database.  In addition it
    creates the nexthop if one is not specified (via hNextHop), based
    on the next hop i/f and address specified in the RIP route.


Parameters :

    hRtmHandle  - Entity registration handle

    prir        - RIP route to be added

    hNextHop    - Handle to the next hop to be used for the route

    dwTimeout   - Route timeout interval

    dwHoldTime  - Route holddown interval (after delete)

    bActive     - TRUE if the route being added is an active route,
                  FALSE otherwise (in RIP's case for summary routes)


Return Value :

    NO_ERROR    - Success

    Rtm error code - Otherwise


Environment :

    Invoked from ProcessRouteEntry and WriteSummaryRoutes
    
--*/
{
    BOOL bRelDest = FALSE;
    
    DWORD dwErr, dwChangeFlags = 0;
    
    RTM_DEST_INFO rdi;
    
    RTM_NEXTHOP_INFO rni;

    RTM_ROUTE_INFO rri;

    RTM_NET_ADDRESS rna;

    CHAR szNetwork[20], szNetmask[20], szNextHop[20], szNextHopmask[20];
        
    
    do {
    
        //
        // char strings used to print IP address/mask info
        // Used in error cases only
        //
        
        lstrcpy(szNetwork, INET_NTOA(prir-> RR_Network.N_NetNumber));
        lstrcpy(szNetmask, INET_NTOA(prir-> RR_Network.N_NetMask));
        lstrcpy(szNextHop, INET_NTOA(prir-> RR_NextHopAddress.N_NetNumber));
        lstrcpy(szNextHopmask, INET_NTOA(prir-> RR_NextHopAddress.N_NetMask));

        
        //
        // Zero out the next hop and route memory
        //

        ZeroMemory(&rni, sizeof(RTM_NEXTHOP_INFO));
        ZeroMemory(&rri, sizeof(RTM_ROUTE_INFO));
        
        
        if (hNextHop == NULL) {
        
            //
            // Find next hop.
            //

            rni.InterfaceIndex = prir-> RR_InterfaceID;
            
            RTM_IPV4_SET_ADDR_AND_MASK(
                &rni.NextHopAddress, prir-> RR_NextHopAddress.N_NetNumber,
                IPV4_SOURCE_MASK
                );

            //
            // Save the nexthop mask in the entity specific info
            //
            
            *((PDWORD)&rni.EntitySpecificInfo) = prir-> RR_NextHopAddress.N_NetMask;
            

            rni.NextHopOwner = hRtmHandle;
            
            dwErr = RtmFindNextHop(hRtmHandle, &rni, &hNextHop, NULL);

            if (dwErr == ERROR_NOT_FOUND) {
            
                //
                // Next hop not found.  Create one
                //
                
                dwErr = RtmAddNextHop(
                            hRtmHandle, &rni, &hNextHop, &dwChangeFlags
                            );

                if (dwErr != NO_ERROR) {
                
                    TRACE3(
                        ROUTE, "error %d creating next hop %s %s",
                        dwErr, szNextHop, szNextHopmask
                    );

                    break;
                }
            }

            else if (dwErr != NO_ERROR) {
            
                TRACE3(
                    ANY, "error %d finding next hop %s %s", dwErr,
                    szNextHop, szNextHopmask
                    );

                break;
            }
        }


        //
        // Build route info structure
        //

        RTM_IPV4_SET_ADDR_AND_MASK(
            &rna, prir-> RR_Network.N_NetNumber, prir-> RR_Network.N_NetMask
            );
            
        rri.PrefInfo.Metric = prir-> RR_FamilySpecificData.FSD_Metric1;
        
        rri.BelongsToViews = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

        //
        // set entity specific info
        //

        SETRIPTAG(&rri, GETROUTETAG(prir));
        SETRIPFLAG(&rri, GETROUTEFLAG(prir));

    
        //
        // Set next hop info
        //

        rri.NextHopsList.NumNextHops = 1;
        rri.NextHopsList.NextHops[0] = hNextHop;

        rri.Neighbour = hNextHop;

        
        //
        // Call into router manager to set preference info
        //

        ig.IG_SupportFunctions.ValidateRoute(PROTO_IP_RIP, &rri, &rna);


        //
        // if this is an inactive route, 
        //  - set route flag to inactive.
        //  - set the views for route to none
        //

        if ( !bActive ) {

            rri.Flags1 = 0;
            rri.Flags = RTM_ROUTE_FLAGS_INACTIVE;
            rri.BelongsToViews = 0;
        }
        
        
        //
        // Add route to dest, convert timeout to milliseconds 
        //

        dwChangeFlags = RTM_ROUTE_CHANGE_FIRST;
        
        dwErr = RtmAddRouteToDest(
                    hRtmHandle, NULL, &rna, &rri, dwTimeOut * 1000, NULL,
                    0, NULL, &dwChangeFlags
                    );

        if ( dwErr != NO_ERROR ) {
        
            TRACE4(
                ANY, "error %d adding route %s %s via %s",
                dwErr, szNetwork, szNetmask, szNextHop
                );

            break;
        }


        if ( bActive )
        {
            //
            // Hold destination if this is an active route
            //

            dwErr = RtmGetExactMatchDestination(
                        hRtmHandle, &rna, RTM_BEST_PROTOCOL,
                        RTM_VIEW_MASK_UCAST, &rdi
                        );

            if ( dwErr != NO_ERROR ) {
            
                TRACE3(
                    ANY, "error %d getting just added destination %s:%s",
                    dwErr, szNetwork, szNetmask
                    );

                break;
            }

            bRelDest = TRUE;
            
            dwErr = RtmHoldDestination(
                        hRtmHandle, rdi.DestHandle, RTM_VIEW_MASK_UCAST, 
                        dwHoldTime * 1000
                        );

            if ( dwErr != NO_ERROR ) {
            
                TRACE3(
                    ANY, "error %d failed to hold destination %s %s",
                    dwErr, szNetwork, szNetmask
                    );

                break;
            }
        }
        
    } while(FALSE);


    //
    // release acquired handles
    //
    
    if ( bRelDest ) {
    
        dwErr = RtmReleaseDestInfo( hRtmHandle, &rdi );

        if ( dwErr != NO_ERROR ) {
        
            TRACE3(
                ANY, "error %d failed to relase just added destination %s %s",
                dwErr, szNetwork, szNetmask
                );
        }
        
    }

    return dwErr;
}



DWORD
GetRouteInfo(
    IN  RTM_ROUTE_HANDLE    hRoute,
    IN  PRTM_ROUTE_INFO     pInRouteInfo    OPTIONAL,
    IN  PRTM_DEST_INFO      pInDestInfo     OPTIONAL,
    OUT PRIP_IP_ROUTE       pRoute
    )
    
/*++

Routine Description:

    Wrapper for filling out the OSPF_RTMv2_ROUTE by retrieving various
    RTM infos.

Arguments:

    hRoute
    pInRouteInfo
    pInDestInfo
    pRoute

Return Value:

    RTM error code

--*/

{
    DWORD               dwErr;
    RTM_ROUTE_INFO      RouteInfo, *pRouteInfo;
    RTM_ENTITY_INFO     EntityInfo, *pEntityInfo;
    RTM_DEST_INFO       DestInfo, *pDestInfo;
    RTM_NEXTHOP_INFO    NextHopInfo, *pNextHopInfo;


    pRouteInfo   = NULL;
    pEntityInfo  = NULL;
    pDestInfo    = NULL;
    pNextHopInfo = NULL;
    


    do
    {
        ZeroMemory(pRoute, sizeof(RIP_IP_ROUTE));
        
        //
        // If the user hasnt already given us the route info, get it
        //

        if ( pInRouteInfo == NULL )
        {
            dwErr = RtmGetRouteInfo(
                        ig.IG_RtmHandle, hRoute, &RouteInfo, NULL
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "GetRouteInfo: Error %d from RtmGetRouteInfo\n", dwErr
                    );

                break;
            }

            pRouteInfo = &RouteInfo;
        }
        
        else
        {
            pRouteInfo = pInRouteInfo;
        }


        //
        // If the user hasnt given us the dest info, get it
        //

        if ( pInDestInfo == NULL )
        {
            dwErr = RtmGetDestInfo(
                        ig.IG_RtmHandle, pRouteInfo->DestHandle,
                        0, RTM_VIEW_MASK_UCAST, &DestInfo
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "GetRouteInfo: Error %d from RtmGetDestInfo\n", dwErr
                    );

                break;
            }

            pDestInfo = &DestInfo;
        }
        
        else
        {
            pDestInfo = pInDestInfo;
        }


        //
        // Get owner info if the protocol is not us
        //

        if ( pRouteInfo-> RouteOwner != ig.IG_RtmHandle )
        {
            dwErr = RtmGetEntityInfo(
                        ig.IG_RtmHandle, pRouteInfo->RouteOwner, &EntityInfo
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "GetRouteInfo: Error %d from RtmGetEntityInfo\n", 
                    dwErr
                    );

                break;
            }

            pEntityInfo = &EntityInfo;
        }
        
        
        //
        // Get the info about the first next hop
        //

        dwErr = RtmGetNextHopInfo(
                    ig.IG_RtmHandle,
                    pRouteInfo->NextHopsList.NextHops[0],
                    &NextHopInfo
                    );
    
        if ( dwErr != NO_ERROR )
        {
            TRACE1(
                ANY, "GetRouteInfo: Error %d from RtmGetEntityInfo\n", 
                dwErr
                );

            break;
        }

        pNextHopInfo = &NextHopInfo;


        //
        // Now copy out all the info.
        // First, the route info
        //

        pRoute-> RR_FamilySpecificData.FSD_Metric1 =
        pRoute-> RR_FamilySpecificData.FSD_Metric  = 
            pRouteInfo-> PrefInfo.Metric;


        //
        // copy out the protocol id from the entity info
        //

        if ( pEntityInfo != NULL )
        {
            pRoute-> RR_RoutingProtocol = pEntityInfo->EntityId.EntityProtocolId;
        }

        else
        {
            //
            // this is a RIP route
            //

            pRoute-> RR_RoutingProtocol = PROTO_IP_RIP;
            SETROUTEFLAG(pRoute, GETRIPFLAG(pRouteInfo));
            SETROUTETAG(pRoute, GETRIPTAG(pRouteInfo));
        }

        
        //
        // Copy out the dest info
        //
    
        RTM_IPV4_GET_ADDR_AND_MASK( 
            pRoute->RR_Network.N_NetNumber, 
            pRoute->RR_Network.N_NetMask, 
            &(pDestInfo->DestAddress) 
            );

        pRoute-> hDest = pDestInfo-> DestHandle;

        
        //
        // Copy out the next hop info
        //

        RTM_IPV4_GET_ADDR_AND_MASK( 
            pRoute->RR_NextHopAddress.N_NetNumber, 
            pRoute->RR_NextHopAddress.N_NetMask, 
            &(pNextHopInfo->NextHopAddress) 
            );
            
        //
        // retrive saved next hop mask
        //
        
        pRoute-> RR_NextHopAddress.N_NetMask = 
            *((PDWORD)&pNextHopInfo-> EntitySpecificInfo);
            

        pRoute-> RR_InterfaceID = pNextHopInfo->InterfaceIndex;

#if 0
        {
            char szNet[20], szMask[20], szNextHop[20], szNextHopMask[20];

            lstrcpy(szNet, INET_NTOA(pRoute-> RR_Network.N_NetNumber));
            lstrcpy(szMask, INET_NTOA(pRoute-> RR_Network.N_NetMask));
            lstrcpy(szNextHop, INET_NTOA(pRoute-> RR_NextHopAddress.N_NetNumber));
            lstrcpy(szNextHopMask, INET_NTOA(pRoute-> RR_NextHopAddress.N_NetMask));

            TRACE5(
                ROUTE, "GetRouteInfo : Route %s %s via %s %s on interface %d",
                szNet, szMask, szNextHop, szNextHopMask,
                pRoute-> RR_InterfaceID
                );

            TRACE3(
                ROUTE, "Has metric %d, flag %x, tag %d",
                GETROUTEMETRIC(pRoute), GETROUTEFLAG(pRoute),
                GETROUTETAG(pRoute)
                );

            TRACE2(
                ROUTE, "Protocol %d, original flag %d",
                pRoute-> RR_RoutingProtocol, GETRIPFLAG(pRouteInfo)
                );
        }
#endif

    } while( FALSE );
    
    
    //
    // Release the relevant infos
    //

    if ( pNextHopInfo != NULL )
    {
        RtmReleaseNextHopInfo( ig.IG_RtmHandle, pNextHopInfo );
    }

    if ( pEntityInfo != NULL )
    {
        RtmReleaseEntityInfo( ig.IG_RtmHandle, pEntityInfo );
    }


    //
    // Release the route and dest infos only if we were not passed them
    // in AND we successfully retrieved them
    //
    
    if ( ( pInDestInfo == NULL ) && ( pDestInfo != NULL ) )
    {
        RtmReleaseDestInfo( ig.IG_RtmHandle, pDestInfo );
    }


    if( ( pInRouteInfo == NULL ) && ( pRouteInfo != NULL ) )
    {
        RtmReleaseRouteInfo( ig.IG_RtmHandle, pRouteInfo );
    }
    
    return NO_ERROR;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ripagnt\defs.h ===
#ifndef __DEFS_H__
#define __DEFS_H__

//------------------------------------------------------------------------------
// Global config default values
//------------------------------------------------------------------------------

#define     IPRIP_DEF_LOG_LEVEL             d_globalLoggingLevel_none
#define     IPRIP_DEF_SEND_Q_SIZE           1024 * 1024
#define     IPRIP_DEF_RECV_Q_SIZE           1024 * 1024
#define     IPRIP_DEF_MIN_TRIG_UPDATE_INTR  5
#define     IPRIP_DEF_PEER_FILTER_MODE      d_globalPeerFilterMode_disable

#define     IP_ADDRESS_LEN  4

//------------------------------------------------------------------------------
// Interface Config default values
//------------------------------------------------------------------------------
#define     MAX_PROTOCOL_FLAG_VALUE         (DWORD) 0x1ff


//------------------------------------------------------------------------------
// Memory allocation/deallocation macros
//------------------------------------------------------------------------------

#define     RIP_MIB_ALLOC( x )          HeapAlloc( GetProcessHeap(), 0, (x) )
#define     RIP_MIB_FREE( x )           HeapFree( GetProcessHeap(), 0, (x) )

//------------------------------------------------------------------------------
// Macro to simplify use of DIM MIB functions
//------------------------------------------------------------------------------
#define     CONNECT_TO_ROUTER(res)                                          \
    (res) = ( g_hMIBServer ) ? NO_ERROR : ConnectToRouter()

#define     MIB_GET(type, w, x, y, z, res)                                  \
{                                                                           \
    CONNECT_TO_ROUTER(res);                                                 \
                                                                            \
    if ( (res) == NO_ERROR )                                                \
    {                                                                       \
        (res) = MprAdminMIBEntry ## type(                                   \
                    g_hMIBServer,                                           \
                    PID_IP,                                                 \
                    MS_IP_RIP,                                              \
                    (LPVOID) (w),                                           \
                    (x),                                                    \
                    (LPVOID *) (y),                                         \
                    (z)                                                     \
                );                                                          \
    }                                                                       \
}


#define     RIP_MIB_SET(x, y, res)                                          \
{                                                                           \
    CONNECT_TO_ROUTER(res);                                                 \
                                                                            \
    if ( (res) == NO_ERROR )                                                \
    {                                                                       \
        (res) = MprAdminMIBEntrySet(                                        \
                    g_hMIBServer,                                           \
                    PID_IP,                                                 \
                    MS_IP_RIP,                                              \
                    (LPVOID) (x),                                           \
                    (y)                                                     \
                );                                                          \
    }                                                                       \
}

#define     RIP_MIB_GET(w, x, y, z, res)                                    \
{                                                                           \
    MIB_GET(Get, w, x, y, z, res)                                           \
                                                                            \
    if ( ( (res) == RPC_S_SERVER_UNAVAILABLE ) ||                           \
         ( (res) == RPC_S_UNKNOWN_IF )         ||                           \
         ( (res) == ERROR_CAN_NOT_COMPLETE ) )                              \
    {                                                                       \
        TraceError( (res) );                                                \
        (res) = MIB_S_ENTRY_NOT_FOUND;                                      \
    }                                                                       \
}
    
#define     RIP_MIB_GETFIRST(w, x, y, z, res)                               \
{                                                                           \
    MIB_GET(GetFirst, w, x, y, z, res)                                      \
                                                                            \
    if ( ( (res) == RPC_S_SERVER_UNAVAILABLE ) ||                           \
         ( (res) == RPC_S_UNKNOWN_IF )         ||                           \
         ( (res) == ERROR_CAN_NOT_COMPLETE ) )                              \
    {                                                                       \
        TraceError( (res) );                                                \
        (res) = MIB_S_NO_MORE_ENTRIES;                                      \
    }                                                                       \
} 
   
#define     RIP_MIB_GETNEXT(w, x, y, z, res)                                \
{                                                                           \
    MIB_GET(GetNext, w, x, y, z, res)                                       \
                                                                            \
    if ( ( (res) == RPC_S_SERVER_UNAVAILABLE ) ||                           \
         ( (res) == RPC_S_UNKNOWN_IF )         ||                           \
         ( (res) == ERROR_CAN_NOT_COMPLETE ) )                              \
    {                                                                       \
        TraceError( (res) );                                                \
        (res) = MIB_S_NO_MORE_ENTRIES;                                      \
    }                                                                       \
}


//------------------------------------------------------------------------------
// Macros to simplify opertions on peer address tables
//------------------------------------------------------------------------------
#define     FIND_PEER_ENTRY(Item, Count, Table, Index)                      \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < (Count); __dwInd++ )                                  \
    {                                                                       \
        DWORD   __dwTmp;                                                    \
        if ( !InetCmp( (Item), (Table)[ __dwInd ], __dwTmp ) ) { break; }   \
    }                                                                       \
    (Index) = __dwInd;                                                      \
}

#define     DELETE_PEER_ENTRY(Index, Count, Src, Dst)                       \
{                                                                           \
    DWORD   __dwSrc = 0, __dwDst = 0;                                       \
    for ( ; __dwSrc < (Count); __dwSrc++ )                                  \
    {                                                                       \
        if ( __dwSrc == (Index) ) { continue; }                             \
        (Dst)[ __dwDst++ ] = (Src)[ __dwSrc ];                              \
    }                                                                       \
}

//------------------------------------------------------------------------------
// Macros to simplify opertions on IP address table
//------------------------------------------------------------------------------
#define     FIND_IP_ADDRESS(Addr, Count, Table, Index)                      \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < (Count); __dwInd++ )                                  \
    {                                                                       \
        DWORD __dwTmp;                                                      \
        if ( !InetCmp(                                                      \
                (Addr).IA_Address,                                          \
                (Table)[ __dwInd].IA_Address,                               \
                __dwTmp                                                     \
              ) &&                                                          \
             !InetCmp(                                                      \
                (Addr).IA_Netmask,                                          \
                (Table)[__dwInd].IA_Netmask,                                \
                __dwTmp                                                     \
              ) )                                                           \
        { break; }                                                          \
    }                                                                       \
    Index = __dwInd;                                                        \
}

//------------------------------------------------------------------------------
// Macros to simplify opertions on peer statistcs tables
//------------------------------------------------------------------------------
#define     GetPeerStatsInfo                    GetInterfaceInfo

//------------------------------------------------------------------------------
// Macros to simplify operations on filter tables
//------------------------------------------------------------------------------

#define     RIP_MIB_ACCEPT_FILTER           1

#define     RIP_MIB_ANNOUNCE_FILTER         2

#define     FIND_FILTER(pFilt, Count, pFiltLst, Index)                      \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < (Count); __dwInd++ )                                  \
    {                                                                       \
        DWORD __dwTmp;                                                      \
        if ( !InetCmp(                                                      \
                (pFilt)-> RF_LoAddress,                                     \
                (pFiltLst)[ __dwInd].RF_LoAddress,                          \
                __dwTmp                                                     \
              ) &&                                                          \
             !InetCmp(                                                      \
                (pFilt)-> RF_HiAddress,                                     \
                (pFiltLst)[__dwInd].RF_HiAddress,                           \
                __dwTmp                                                     \
              ) )                                                           \
        { break; }                                                          \
    }                                                                       \
    Index = __dwInd;                                                        \
}

#define     DELETE_FILTER(Index, Count, Src, Dst) \
    DELETE_PEER_ENTRY(Index, Count, Src, Dst)


//------------------------------------------------------------------------------
// Macros to convert between Asn and Win32 data types
//------------------------------------------------------------------------------

#define SetAsnInteger(dstBuf,val){                          \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_INTEGER);             \
	    (dstBuf)->asnValue.number = (AsnInteger)(val);      \
    }                                                       \
}

#define ForceSetAsnInteger(dstBuf,val){                     \
    (dstBuf)->asnType = ASN_INTEGER;                        \
    (dstBuf)->asnValue.number = (AsnInteger)(val);          \
}

#define SetAsnCounter(dstBuf,val){                          \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_COUNTER);     \
        (dstBuf)->asnValue.counter = (AsnCounter)(val);     \
    }                                                       \
}

#define SetAsnGauge(dstBuf,val){                            \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_GAUGE);       \
        (dstBuf)->asnValue.gauge = (AsnGauge)(val);         \
    }                                                       \
}

#define SetAsnTimeTicks(dstBuf,val){                        \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_TIMETICKS);   \
        (dstBuf)->asnValue.ticks = (AsnTimeticks)(val);     \
    }                                                       \
}

#define SetAsnOctetString(dstBuf,buffer,src,len){           \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);         \
        (dstBuf)->asnValue.string.length = len;             \
        (dstBuf)->asnValue.string.stream = (BYTE*)memcpy(buffer,src,len);\
        (dstBuf)->asnValue.string.dynamic = FALSE;          \
    }                                                       \
}

#define SetAsnIPAddr( dstBuf, val )                             \
{                                                               \
    if ((dstBuf)->asnType)			                            \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if( (dstBuf)->asnValue.address.stream)                  \
        {                                                       \
            (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;\
        }                                                       \
    }                                                           \
}

#define SetAsnIPAddress(dstBuf,buffer,val){                     \
    if ((dstBuf)->asnType)			                            \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if(!(dstBuf)->asnValue.address.stream)                  \
        {                                                       \
           (dstBuf)->asnValue.address.stream = (PBYTE)buffer;   \
           (dstBuf)->asnValue.address.dynamic = FALSE;          \
        }                                                       \
        (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;   \
    }                                                           \
}

#define ForceSetAsnIPAddress(dstBuf,buffer,val){                \
    (dstBuf)->asnType = ASN_RFC1155_IPADDRESS;                  \
    (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;         \
    if(!((dstBuf)->asnValue.address.stream))                    \
    {                                                           \
       (dstBuf)->asnValue.address.stream = (PBYTE)buffer;       \
       (dstBuf)->asnValue.address.dynamic = FALSE;              \
    }                                                           \
    (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;       \
}

#define SetAsnUshort(dstBuf,buffer,val){                   \
    if ((dstBuf)->asnType)			 \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);        \
        (dstBuf)->asnValue.string.length = 2;              \
        (buffer)[0] = (BYTE)(val&0xFF);                    \
        (buffer)[1] = (BYTE)((val>>8)&0xFF);               \
        (dstBuf)->asnValue.string.stream = (BYTE *)buffer; \
        (dstBuf)->asnValue.string.dynamic = FALSE;         \
    }                                                      \
}
#define SetAsnDispString(dstBuf,buffer,src,len){           \
    if ((dstBuf)->asnType)			 \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_RFC1213_DISPSTRING); \
        (dstBuf)->asnValue.string.length = strlen(src);    \
        if ((dstBuf)->asnValue.string.length>len)          \
        {                                                  \
            (dstBuf)->asnValue.string.length = len;        \
            (dstBuf)->asnValue.string.stream = (BYTE *)strncpy (buffer,src,\
                                                            (dstBuf)->asnValue.string.length);\
            (dstBuf)->asnValue.string.dynamic = FALSE;     \
        }                                                  \
    }                                                      \
}

#define SetToZeroOid(dstBuf,buffer){                       \
    if ((dstBuf)->asnType)			 \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OBJECTIDENTIFIER);   \
        (dstBuf)->asnValue.object.idLength = NULL_OID_LEN; \
        (dstBuf)->asnValue.object.ids = buffer;            \
        (dstBuf)->asnValue.object.ids[0]   = 0;            \
        (dstBuf)->asnValue.object.ids[1]   = 0;            \
    }                                                      \
}

#define GetAsnInteger(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.number):(defVal))

#define GetAsnCounter(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.counter):(defVal))

#define GetAsnTimeTicks(srcBuf, defval) \
    ( ( (srcBuf)-> asnType ) ? (srcBuf)-> asnValue.ticks : (defval) )

#define GetAsnOctetString(dst,srcBuf)                                                   \
    (((srcBuf)->asnType)?		                                                        \
     (memcpy(dst,(srcBuf)->asnValue.string.stream,(srcBuf)->asnValue.string.length))    \
     :NULL)	

#define GetAsnIPAddress(srcBuf,defVal)                                  \
    (DWORD)(((srcBuf)->asnType && (srcBuf)->asnValue.string.length)?    \
            (*(DWORD*)((srcBuf)->asnValue.address.stream)) : (defVal))	

                
#define IsAsnTypeNull(asnObj) (!((asnObj)->asnType))
#define IsAsnIPAddressTypeNull(asnObj) (!((asnObj)->asnType && (asnObj)->asnValue.address.length))



//------------------------------------------------------------------------------
// IP address / port comparison macros
//------------------------------------------------------------------------------

//
// LONG
// Cmp(DWORD dwFirst, DWORD dwSecond, LONG lResult)
//

#define Cmp(dwFirst,dwSecond,lResult) ((LONG)((lResult) = ((dwFirst) - (dwSecond))))

//
// LONG
// PortCmp(DWORD wPort1, DWORD wPort2, LONG lResult)
//

#define PortCmp(dwPort1, dwPort2,lResult) ((LONG)((lResult) = ((ntohs((WORD)dwPort1)) - (ntohs((WORD)dwPort2)))))

// The addresses are in Network order

//
// LONG
// InetCmp(DWORD IpAddr1, DWORD IpAddr2, LONG lResult)
//

#define InetCmp(dwIpAddr1,dwIpAddr2,res)                                                    \
    ((LONG)(((res) = (((dwIpAddr1) & 0x000000ff) - ((dwIpAddr2) & 0x000000ff))) ? (res)   : \
            (((res) = (((dwIpAddr1) & 0x0000ff00) - ((dwIpAddr2) & 0x0000ff00))) ? (res)  : \
             (((res) = (((dwIpAddr1) & 0x00ff0000) - ((dwIpAddr2) & 0x00ff0000))) ? (res) : \
              (((dwIpAddr1) & 0xff000000) - ((dwIpAddr2) & 0xff000000))))))                  


//------------------------------------------------------------------------------
// Debug tracing macros
//------------------------------------------------------------------------------

#ifdef MIB_DEBUG
#define TRACE0(Z)             TracePrintf(g_dwTraceId,Z)
#define TRACE1(Y,Z)           TracePrintf(g_dwTraceId,Y,Z)
#define TRACE2(X,Y,Z)         TracePrintf(g_dwTraceId,X,Y,Z)
#define TRACE3(W,X,Y,Z)       TracePrintf(g_dwTraceId,W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)     TracePrintf(g_dwTraceId,V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)   TracePrintf(g_dwTraceId,U,W,X,Y,Z)

#define TRACEW0(Z)            TracePrintfW(g_dwTraceId,Z)

#define TraceEnter(X)         TracePrintf(g_dwTraceId,"Entering " X)
#define TraceLeave(X)         TracePrintf(g_dwTraceId,"Leaving " X "\n")

#define TraceError(X) \
    TracePrintf( g_dwTraceId, "MprAdminMIB API returned : %d", (X) ); 

#define TraceError1(x)                              \
{                                                   \
    LPWSTR  __lpwszErr = NULL;                      \
                                                    \
    TRACE1( "MprAdminMIB API returned : %d", (x) ); \
    MprAdminGetErrorString( (x), &__lpwszErr );     \
                                                    \
    if ( __lpwszErr )                               \
    {                                               \
        TRACEW0( __lpwszErr );                      \
        LocalFree( __lpwszErr );                    \
    }                                               \
}                                               

#else
#define TRACE0(Z)
#define TRACE1(Y,Z)  
#define TRACE2(X,Y,Z)
#define TRACE3(W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)
#define TRACEW0(Z)            
#define TraceEnter(X) 
#define TraceLeave(X)
#define TraceError(x)
#endif


#define EnterReader(X)
#define ReleaseLock(X)
#define ReaderToWriter(X)
#define EnterWriter(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\work.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: work.c
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// worker function implementations
//============================================================================

#include "pchrip.h"
#pragma hdrstop

VOID
ProcessSocket(
    DWORD dwAddrIndex,
    PIF_TABLE_ENTRY pite,
    PIF_TABLE pTable
    );

VOID
EnqueueStartFullUpdate(
    PIF_TABLE_ENTRY pite,
    LARGE_INTEGER qwLastFullUpdateTime
    );

DWORD
EnqueueDemandUpdateCheck(
    PUPDATE_CONTEXT pwc
    );

VOID
EnqueueDemandUpdateMessage(
    DWORD dwInterfaceIndex,
    DWORD dwError
    );

DWORD
CountInterfaceRoutes(
    DWORD dwInterfaceIndex
    );

BOOL
ProcessResponseEntry(
    PIF_TABLE_ENTRY pITE,
    DWORD dwAddrIndex,
    DWORD dwSource,
    PIPRIP_ENTRY pIE,
    PIPRIP_PEER_STATS pPS
    );

DWORD
SendRouteOnIfList(
    UPDATE_BUFFER pBufList[],
    DWORD dwBufCount,
    DWORD dwSendMode,
    PROUTE_TABLE pSummaryTable,
    PRIP_IP_ROUTE pRoute
    );



//----------------------------------------------------------------------------
// Macro:   RTM_ROUTE_FROM_IPRIP_ENTRY
// Macro:   IPRIP_ENTRY_FROM_RTM_ROUTE
//
// These two macros are used to transfer data from an RTM route struct
// to an IPRIPv2 packet route entry, and vice versa.
// The first two bytes of an RTM route's ProtocolSpecificData array are used
// to store the route tag contained in the IPRIP packet route-entry
//----------------------------------------------------------------------------

#define RTM_ROUTE_FROM_IPRIP_ENTRY(r,i)                                     \
    (r)->RR_RoutingProtocol = PROTO_IP_RIP;                                       \
    SETROUTEMETRIC((r), ntohl((i)->IE_Metric));                             \
    (r)->RR_Network.N_NetNumber = (i)->IE_Destination;                      \
    (r)->RR_Network.N_NetMask = (i)->IE_SubnetMask;                         \
    (r)->RR_NextHopAddress.N_NetNumber = (i)->IE_Nexthop;                   \
    (r)->RR_NextHopAddress.N_NetMask = (i)->IE_SubnetMask;                  \
    SETROUTETAG((r), ntohs((i)->IE_RouteTag))

#define IPRIP_ENTRY_FROM_RTM_ROUTE(i,r)                                     \
    (i)->IE_AddrFamily = htons(AF_INET);                                    \
    (i)->IE_Metric = htonl(GETROUTEMETRIC(r));                              \
    (i)->IE_Destination = (r)->RR_Network.N_NetNumber;                      \
    (i)->IE_SubnetMask = (r)->RR_Network.N_NetMask;                         \
    (i)->IE_Nexthop = (r)->RR_NextHopAddress.N_NetNumber



//----------------------------------------------------------------------------
// Macro:   IS_ROUTE_IN_ACCEPT_FILTER
// Macro:   IS_ROUTE_IN_ANNOUNCE_FILTER
//
// The following three macros are used to search for a route
// in the accept filters and announce filters configured for an interface
// The last two macros invoke the first macro which executes the inner loop,
// since the inner loop is identical in both cases.
//----------------------------------------------------------------------------

#define IS_ROUTE_IN_FILTER(route,ret)                       \
    (ret) = 0;                                              \
    for ( ; _pfilt < _pfiltend; _pfilt++) {                 \
        _filt = _pfilt->RF_LoAddress;                       \
        if (INET_CMP(route, _filt, _cmp) == 0) { (ret) = 1; break; }    \
        else if (_cmp > 0) {                                \
            _filt = _pfilt->RF_HiAddress;                   \
            if (INET_CMP(route, _filt, _cmp) <= 0) { (ret) = 1; break; }\
        }                                                   \
    }

#define IS_ROUTE_IN_ACCEPT_FILTER(ic,route,ret) {           \
    INT _cmp;                                               \
    DWORD _filt;                                            \
    PIPRIP_ROUTE_FILTER _pfilt, _pfiltend;                  \
    _pfilt = IPRIP_IF_ACCEPT_FILTER_TABLE(ic);              \
    _pfiltend = _pfilt + (ic)->IC_AcceptFilterCount;        \
    IS_ROUTE_IN_FILTER(route,ret);                          \
}

#define IS_ROUTE_IN_ANNOUNCE_FILTER(ic,route,ret) {         \
    INT _cmp;                                               \
    DWORD _filt;                                            \
    PIPRIP_ROUTE_FILTER _pfilt, _pfiltend;                  \
    _pfilt = IPRIP_IF_ANNOUNCE_FILTER_TABLE(ic);            \
    _pfiltend = _pfilt + (ic)->IC_AnnounceFilterCount;      \
    IS_ROUTE_IN_FILTER(route,ret);                          \
}




//----------------------------------------------------------------------------
// Macro:   IS_PEER_IN_FILTER
//
// macro used to search the peer filters
//----------------------------------------------------------------------------

#define IS_PEER_IN_FILTER(gc,peer,ret) {                        \
    PDWORD _pdwPeer, _pdwPeerEnd;                               \
    (ret) = 0;                                                  \
    _pdwPeer = IPRIP_GLOBAL_PEER_FILTER_TABLE(gc);              \
    _pdwPeerEnd = _pdwPeer + (gc)->GC_PeerFilterCount;          \
    for ( ; _pdwPeer < _pdwPeerEnd; _pdwPeer++) {               \
        if (*_pdwPeer == (peer)) { (ret) = 1; break; }          \
    }                                                           \
}





//----------------------------------------------------------------------------
// UPDATE BUFFER MANAGEMENT
//
// The following types and functions are used to simplify
// the transmission of routes. The system consists of the struct
// UPDATE_BUFFER, which includes a function table and a byte buffer,
// and a number of three-function update buffer routine sets.
// The sets each contain a routine to start an update buffer,
// to add a route to an update buffer, and to finish an update buffer.
//
// There are separate versions for RIPv1 mode and RIPv2 mode. The function
// InitializeUpdateBuffer sets up the function table in an update buffer
// depending on the configuration for the interface with which the buffer
// is associated. This set-up eliminates the need to check the interface
// configuration every time an entry must be added; instead, the config
// is checked a single time to set up the function table, and afterward
// the function generating the update merely calls the functions in the table.
//
// The setup also depends on the mode in which the information is being sent.
// The address to which the information is being sent is stored in the
// update buffer, since this will be required every time a route is added.
// However, when a full-update is being generated on an interface operating
// in RIPv2 mode, the destination address stored is 224.0.0.9, but the
// actual destination network is the network of the out-going interface.
// Therefore, this address is also stored since it will be needed for
// split-horizon/poison-reverse/subnet-summary processing
//----------------------------------------------------------------------------

//
// these are the modes in which routes may be transmitted
//

#define SENDMODE_FULL_UPDATE        0
#define SENDMODE_TRIGGERED_UPDATE   1
#define SENDMODE_SHUTDOWN_UPDATE    2
#define SENDMODE_GENERAL_REQUEST    3
#define SENDMODE_GENERAL_RESPONSE1  4
#define SENDMODE_GENERAL_RESPONSE2  5
#define SENDMODE_SPECIFIC_RESPONSE1 6
#define SENDMODE_SPECIFIC_RESPONSE2 7



//
// this function set is for interfaces with announcements disabled
//

DWORD
StartBufferNull(
    PUPDATE_BUFFER pUB
    ) { return NO_ERROR; }

DWORD
AddEntryNull(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    ) { return NO_ERROR; }

DWORD
FinishBufferNull(
    PUPDATE_BUFFER pUB
    ) { return NO_ERROR; }


//
// this function-set is for RIPv1 interfaces
//

DWORD
StartBufferVersion1(
    PUPDATE_BUFFER pUB
    );
DWORD
AddEntryVersion1(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    );
DWORD
FinishBufferVersion1(
    PUPDATE_BUFFER pUB
    );


//
// this function-set is for RIPv2 interfaces
//

DWORD
StartBufferVersion2(
    PUPDATE_BUFFER pUB
    );
DWORD
AddEntryVersion2(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    );
DWORD
FinishBufferVersion2(
    PUPDATE_BUFFER pUB
    );




//----------------------------------------------------------------------------
// Function:    InitializeUpdateBuffer
//
// this function sets up the update-buffer, writing in the functions to use
// for restarting the buffer, adding entries, and finishing the buffer.
// It also stores the destination address to which the packet is being sent,
// as well as the network and netmask for the destination
// This assumes the binding table is locked.
//----------------------------------------------------------------------------

DWORD
InitializeUpdateBuffer(
    PIF_TABLE_ENTRY pITE,
    DWORD dwAddrIndex,
    PUPDATE_BUFFER pUB,
    DWORD dwSendMode,
    DWORD dwDestination,
    DWORD dwCommand
    ) {


    DWORD dwAnnounceMode;
    PIPRIP_IP_ADDRESS paddr;

    pUB->UB_Length = 0;


    //
    // save the pointer to the interface
    //

    pUB->UB_ITE = pITE;
    pUB->UB_AddrIndex = dwAddrIndex;
    paddr = IPRIP_IF_ADDRESS_TABLE(pITE->ITE_Binding) + dwAddrIndex;
    pUB->UB_Socket = pITE->ITE_Sockets[dwAddrIndex];
    pUB->UB_Address = paddr->IA_Address;
    pUB->UB_Netmask = paddr->IA_Netmask;


    //
    // save the command
    //

    pUB->UB_Command = dwCommand;


    //
    // store the absolute address to which this packet is destined,
    // which may differ from the address passed to sendto()
    // e.g. RIPv2 packets are destined for the interface's network,
    // but the address passed to sendto() is 224.0.0.9
    // if the destination passed in is 0, use the broadcast address
    // on the outgoing interface as the destination
    //

    if (dwDestination == 0) {

        if(paddr->IA_Netmask == 0xffffffff)
        {
            TRACE0(SEND,"MASK ALL ONES");

            pUB->UB_DestAddress = (paddr->IA_Address | ~(NETCLASS_MASK(paddr->IA_Address)));
        }
        else
        {
            pUB->UB_DestAddress = (paddr->IA_Address | ~paddr->IA_Netmask);
        }

        pUB->UB_DestNetmask = paddr->IA_Netmask;
    }
    else {

        pUB->UB_DestAddress = dwDestination;
        pUB->UB_DestNetmask = GuessSubnetMask(pUB->UB_DestAddress, NULL);
    }


    //
    // decide on the announce mode;
    // if the mode is DISABLED, we still send responses to SPECIFIC requests
    // on the interface, so set the mode to RIPv1/v2 if sending a specific
    // response on a disabled interface
    //

    dwAnnounceMode = pITE->ITE_Config->IC_AnnounceMode;

    if (dwAnnounceMode == IPRIP_ANNOUNCE_DISABLED) {
        if (dwSendMode == SENDMODE_SPECIFIC_RESPONSE1) {
            dwAnnounceMode = IPRIP_ANNOUNCE_RIP1;
        }
        else
        if (dwSendMode == SENDMODE_SPECIFIC_RESPONSE2) {
            dwAnnounceMode = IPRIP_ANNOUNCE_RIP2;
        }
    }


    //
    // set up the function table and destination address, which
    // depend on the announce-mode of the interface and on the sort
    // of information being transmitted
    //

    switch (dwAnnounceMode) {

        //
        // in RIP1 mode, packets are RIP1, broadcast
        //

        case IPRIP_ANNOUNCE_RIP1:

            pUB->UB_AddRoutine = AddEntryVersion1;
            pUB->UB_StartRoutine = StartBufferVersion1;
            pUB->UB_FinishRoutine = FinishBufferVersion1;

            pUB->UB_Destination.sin_port = htons(IPRIP_PORT);
            pUB->UB_Destination.sin_family = AF_INET;
            pUB->UB_Destination.sin_addr.s_addr = pUB->UB_DestAddress;

            break;



        //
        // in RIP1-compatible mode, packets are RIP2, broadcast,
        // except in the case of a general response to a RIP1 router,
        // in which case the packets are RIP1, unicast
        //

        case IPRIP_ANNOUNCE_RIP1_COMPAT:

            if (dwSendMode == SENDMODE_GENERAL_RESPONSE1) {

                pUB->UB_AddRoutine = AddEntryVersion1;
                pUB->UB_StartRoutine = StartBufferVersion1;
                pUB->UB_FinishRoutine = FinishBufferVersion1;
            }
            else {

                pUB->UB_AddRoutine = AddEntryVersion2;
                pUB->UB_StartRoutine = StartBufferVersion2;
                pUB->UB_FinishRoutine = FinishBufferVersion2;
            }

            pUB->UB_Destination.sin_port = htons(IPRIP_PORT);
            pUB->UB_Destination.sin_family = AF_INET;
            pUB->UB_Destination.sin_addr.s_addr = pUB->UB_DestAddress;

            break;


        //
        // in RIP2 mode, packets are RIP2, multicast, except in the case
        // of a general/specific responses, in which cases messages are unicast;
        // note that a RIP2-only router never sends a general response to
        // a request from a RIP1 router.
        //

        case IPRIP_ANNOUNCE_RIP2:

            pUB->UB_AddRoutine = AddEntryVersion2;
            pUB->UB_StartRoutine = StartBufferVersion2;
            pUB->UB_FinishRoutine = FinishBufferVersion2;

            pUB->UB_Destination.sin_port = htons(IPRIP_PORT);
            pUB->UB_Destination.sin_family = AF_INET;


            //
            // if sending to a specific destination, as a reponse
            // to a request or as a full update to a unicast peer,
            // set the IP address of the destination.
            // Else send to multicast address.
            //

            if ( dwDestination != 0 ) {
                pUB->UB_Destination.sin_addr.s_addr = pUB->UB_DestAddress;
            }
            else {
                pUB->UB_Destination.sin_addr.s_addr = IPRIP_MULTIADDR;
            }

            break;


        default:

            TRACE2(
                IF, "invalid announce mode on interface %d (%s)",
                pITE->ITE_Index, INET_NTOA(paddr->IA_Address)
                );

            pUB->UB_AddRoutine = AddEntryNull;
            pUB->UB_StartRoutine = StartBufferNull;
            pUB->UB_FinishRoutine = FinishBufferNull;

            return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    SendUpdateBuffer
//
// This function is invoked by the add-entry and finsih-buffer functions
// to send the contents of an update-buffer.
//----------------------------------------------------------------------------

DWORD
SendUpdateBuffer(
    PUPDATE_BUFFER pbuf
    ) {

    INT iLength;
    DWORD dwErr;

    TRACE1(SEND,"SENDING TO %s",INET_NTOA(pbuf->UB_Destination.sin_addr.s_addr));

    iLength = sendto(
                pbuf->UB_Socket, pbuf->UB_Buffer, pbuf->UB_Length, 0,
                (PSOCKADDR)&pbuf->UB_Destination, sizeof(SOCKADDR_IN)
                );

    if (iLength == SOCKET_ERROR || (DWORD)iLength < pbuf->UB_Length) {

        //
        // an error occurred
        //

        CHAR szDest[20], *lpszAddr;

        dwErr = WSAGetLastError();
        lstrcpy(szDest, INET_NTOA(pbuf->UB_Destination.sin_addr));
        lpszAddr = INET_NTOA(pbuf->UB_Address);

        TRACE4(
            SEND, "error %d sending update to %s on interface %d (%s)",
            dwErr, szDest, pbuf->UB_ITE->ITE_Index, lpszAddr
            );
        LOGWARN2(SENDTO_FAILED, lpszAddr, szDest, dwErr);

        InterlockedIncrement(&pbuf->UB_ITE->ITE_Stats.IS_SendFailures);
    }
    else {

        if (pbuf->UB_Command == IPRIP_REQUEST) {
            InterlockedIncrement(&pbuf->UB_ITE->ITE_Stats.IS_RequestsSent);
        }
        else {
            InterlockedIncrement(&pbuf->UB_ITE->ITE_Stats.IS_ResponsesSent);
        }

        dwErr = NO_ERROR;
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    StartBufferVersion1
//
// This starts a RIPv1 update-buffer, zeroing reserved fields,
// setting the version, and setting the command field
//----------------------------------------------------------------------------

DWORD
StartBufferVersion1(
    PUPDATE_BUFFER pUB
    ) {

    PIPRIP_HEADER pHdr;

    //
    // set up the header
    //

    pHdr = (PIPRIP_HEADER)pUB->UB_Buffer;
    pHdr->IH_Version = 1;
    pHdr->IH_Command = (BYTE)pUB->UB_Command;
    pHdr->IH_Reserved = 0;

    pUB->UB_Length = sizeof(IPRIP_HEADER);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    AddEntryVersion1
//
// This adds an entry to a RIPv1 buffer, first sending the buffer if it is full
//----------------------------------------------------------------------------

DWORD
AddEntryVersion1(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    ) {

    PIPRIP_ENTRY pie;

    //
    // if the buffer is full, transmit its contents and restart it
    //

    if ((pUB->UB_Length + sizeof(IPRIP_ENTRY)) > MAX_PACKET_SIZE) {

        SendUpdateBuffer(pUB);

        StartBufferVersion1(pUB);
    }


    //
    // point to the end of the buffer
    //

    pie = (PIPRIP_ENTRY)(pUB->UB_Buffer + pUB->UB_Length);

    IPRIP_ENTRY_FROM_RTM_ROUTE(pie, pRIR);


    //
    // zero out fields which are reserved in RIP1
    //

    pie->IE_SubnetMask = 0;
    pie->IE_RouteTag = 0;
    pie->IE_Nexthop = 0;

    pUB->UB_Length += sizeof(IPRIP_ENTRY);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    FinishBufferVersion1
//
// this sends the contents of a RIPv1 buffer, if any
//----------------------------------------------------------------------------

DWORD
FinishBufferVersion1(
    PUPDATE_BUFFER pUB
    ) {


    //
    // send the buffer if it contains any entries
    //

    if (pUB->UB_Length > sizeof(IPRIP_HEADER)) {
        SendUpdateBuffer(pUB);
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    StartBufferVersion2
//
// this starts a RIPv2 buffer
//----------------------------------------------------------------------------

DWORD
StartBufferVersion2(
    PUPDATE_BUFFER pUB
    ) {

    PIPRIP_HEADER pHdr;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_AUTHENT_ENTRY pae;


    //
    // setup header
    //

    pHdr = (PIPRIP_HEADER)pUB->UB_Buffer;
    pHdr->IH_Version = 2;
    pHdr->IH_Command = (BYTE)pUB->UB_Command;
    pHdr->IH_Reserved = 0;

    pUB->UB_Length = sizeof(IPRIP_HEADER);


    //
    // see if we need to set up the authentication entry
    //

    pic = pUB->UB_ITE->ITE_Config;

    if (pic->IC_AuthenticationType == IPRIP_AUTHTYPE_SIMPLE_PASSWORD) {

        pae = (PIPRIP_AUTHENT_ENTRY)(pUB->UB_Buffer + sizeof(IPRIP_HEADER));

        pae->IAE_AddrFamily = htons(ADDRFAMILY_AUTHENT);
        pae->IAE_AuthType = htons((WORD)pic->IC_AuthenticationType);

        CopyMemory(
            pae->IAE_AuthKey,
            pic->IC_AuthenticationKey,
            IPRIP_MAX_AUTHKEY_SIZE
            );

        pUB->UB_Length += sizeof(IPRIP_AUTHENT_ENTRY);
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    AddEntryVersion2
//
// this adds an entry to RIPv2 buffer, first sending the buffer if it is full
//----------------------------------------------------------------------------

DWORD
AddEntryVersion2(
    PUPDATE_BUFFER pUB,
    PRIP_IP_ROUTE pRIR
    ) {

    PIPRIP_ENTRY pie;


    //
    // send the contents if the buffer is full
    //

    if (pUB->UB_Length + sizeof(IPRIP_ENTRY) > MAX_PACKET_SIZE) {

        SendUpdateBuffer(pUB);

        StartBufferVersion2(pUB);
    }


    pie = (PIPRIP_ENTRY)(pUB->UB_Buffer + pUB->UB_Length);

    IPRIP_ENTRY_FROM_RTM_ROUTE(pie, pRIR);

    //
    // for RIP routes, we assume that the route tag will be set
    // in the RTM route struct already;
    // for non-RIP routes, we write the route tag
    // for the outgoing interface in the packet entry
    //

    if (pRIR->RR_RoutingProtocol == PROTO_IP_RIP) {
        pie->IE_RouteTag = htons(GETROUTETAG(pRIR));
    }
    else {
        pie->IE_RouteTag = htons(pUB->UB_ITE->ITE_Config->IC_RouteTag);
    }

    pUB->UB_Length += sizeof(IPRIP_ENTRY);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    FinishBufferVersion2
//
// this sends the contents of a RIPv2 buffer, if any
//----------------------------------------------------------------------------

DWORD
FinishBufferVersion2(
    PUPDATE_BUFFER pUB
    ) {

    //
    // the size above which we send depends on whether or not there
    // is an authentication entry
    //

    if (pUB->UB_ITE->ITE_Config->IC_AuthenticationType == IPRIP_AUTHTYPE_NONE) {

        if (pUB->UB_Length > sizeof(IPRIP_HEADER)) {
            SendUpdateBuffer(pUB);
        }
    }
    else {

        //
        // there is an authentication entry, so unless there
        // is also a route entry, we will not send this last buffer
        //

        if (pUB->UB_Length > (sizeof(IPRIP_HEADER) +
                              sizeof(IPRIP_AUTHENT_ENTRY))) {
            SendUpdateBuffer(pUB);
        }
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// ROUTE ENUMERATION ROUTINES
//
// The following definitions simplify the enumeration of routes
// when routing information is being sent from a single source on multiple
// interfaces, for instance when a triggered update is going out on all
// interfaces, or when a full-update is being sent, or when a number
// of interfaces are being shutdown. the function InitializeGetRoute looks at
// the mode in which it is supposed to send routes, and based on that
// builds a table of functions which will be used to enumerate the routes.
// In the case of a full-update, the enumeration functions would
// go to RTM to get the information; in the case of a triggered-update, they
// would dequeue routes from the send-queue.
//----------------------------------------------------------------------------


// the following are the type definitions of the functions
// in each get-route function group

typedef DWORD (*PGETROUTE_START)(PVOID *);
typedef DWORD (*PGETROUTE_NEXT)(PVOID *, PRIP_IP_ROUTE);
typedef DWORD (*PGETROUTE_FINISH)(PVOID *);



// The following three functions handle RTM route enumeration

DWORD
RtmGetRouteStart(
    PRTM_ENUM_HANDLE phEnumHandle
    );
DWORD
RtmGetRouteNext(
    RTM_ENUM_HANDLE hEnumHandle,
    PRIP_IP_ROUTE pRoute
    );
DWORD
RtmGetRouteFinish(
    RTM_ENUM_HANDLE hEnumHandle
    );



// The following three functions handle full-update route enumeration
//  (a full-update enumerates routes from RTM)

#define FullUpdateGetRouteStart         RtmGetRouteStart
#define FullUpdateGetRouteNext          RtmGetRouteNext
#define FullUpdateGetRouteFinish        RtmGetRouteFinish



// The following three functions handle triggered-update route enumeration
//  (a triggered-update enumerates routes from the send-queue)

DWORD
TriggeredUpdateGetRouteStart(
    PRTM_ENUM_HANDLE phEnumHandle
    );
DWORD
TriggeredUpdateGetRouteNext(
    RTM_ENUM_HANDLE hEnumHandle,
    PRIP_IP_ROUTE pRoute
    );
DWORD
TriggeredUpdateGetRouteFinish(
    RTM_ENUM_HANDLE hEnumHandle
    );



// The following three functions handle shutdown-update route enumeration.
//  On shutdown, routes are enumerated from RTM, but their metrics
//  are set to IPRIP_INFINITE-1 before being returned

#define ShutdownUpdateGetRouteStart     RtmGetRouteStart
DWORD ShutdownUpdateGetRouteNext(RTM_ENUM_HANDLE hEnumHandle, PRIP_IP_ROUTE pRoute);
#define ShutdownUpdateGetRouteFinish    RtmGetRouteFinish



// The following three functions handle general-response route enumeration
// a general response enumerates routes from RTM

#define GeneralResponseGetRouteStart    RtmGetRouteStart
#define GeneralResponseGetRouteNext     RtmGetRouteNext
#define GeneralResponseGetRouteFinish   RtmGetRouteFinish




//----------------------------------------------------------------------------
// Function:    InitializeGetRoute
//
// This functions sets up a get-route function group given the send-mode
//----------------------------------------------------------------------------

DWORD
InitializeGetRoute(
    DWORD dwSendMode,
    PGETROUTE_START *ppGS,
    PGETROUTE_NEXT *ppGN,
    PGETROUTE_FINISH *ppGF
    ) {


    switch (dwSendMode) {

        case SENDMODE_FULL_UPDATE:
            *ppGS = FullUpdateGetRouteStart;
            *ppGN = FullUpdateGetRouteNext;
            *ppGF = FullUpdateGetRouteFinish;
            break;

        case SENDMODE_TRIGGERED_UPDATE:
            *ppGS = TriggeredUpdateGetRouteStart;
            *ppGN = TriggeredUpdateGetRouteNext;
            *ppGF = TriggeredUpdateGetRouteFinish;
            break;

        case SENDMODE_SHUTDOWN_UPDATE:
            *ppGS = ShutdownUpdateGetRouteStart;
            *ppGN = ShutdownUpdateGetRouteNext;
            *ppGF = ShutdownUpdateGetRouteFinish;
            break;

        case SENDMODE_GENERAL_RESPONSE1:
        case SENDMODE_GENERAL_RESPONSE2:
            *ppGS = GeneralResponseGetRouteStart;
            *ppGN = GeneralResponseGetRouteNext;
            *ppGF = GeneralResponseGetRouteFinish;
            break;

        default:
            return ERROR_INVALID_PARAMETER;
            break;
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    RtmGetRouteStart
//
// starts an enumeration of RTM routes; includes only and all best routes
// the enumeration handle is written into ppEnumerator
//----------------------------------------------------------------------------

DWORD
RtmGetRouteStart(
    PRTM_ENUM_HANDLE phEnumHandle
    ) {
    
    DWORD dwErr;
    RTM_NET_ADDRESS rna;


    RTM_IPV4_MAKE_NET_ADDRESS( &rna, 0 , 0 );

    dwErr = RtmCreateDestEnum(
                ig.IG_RtmHandle, RTM_VIEW_MASK_ANY, 
                RTM_ENUM_START | RTM_ENUM_ALL_DESTS, &rna,
                RTM_BEST_PROTOCOL, phEnumHandle
                );

    if (dwErr != NO_ERROR) {
    
        TRACE1( ROUTE, "error %d when creating enumeration handle", dwErr );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    RtmGetRouteNext
//
// continues an enumeration of RTM routes
//----------------------------------------------------------------------------

DWORD
RtmGetRouteNext(
    RTM_ENUM_HANDLE hEnumHandle,
    PRIP_IP_ROUTE pRoute
    ) {

    BOOL bRelDest = FALSE, bRelUcast = FALSE;
    
    DWORD dwErr, dwNumDests = 1;

    RTM_DEST_INFO rdi, rdiTemp;
        
    char szNetwork[20], szNextHop[20];


    
    do {
    
        //
        // Get next route
        //

        do {
            dwErr = RtmGetEnumDests(
                        ig.IG_RtmHandle, hEnumHandle, &dwNumDests, &rdiTemp
                        );

            if (dwErr == ERROR_NO_MORE_ITEMS) {

                if (dwNumDests < 1) {
                
                    break;
                }

                dwErr = NO_ERROR;
            }

            else if (dwErr != NO_ERROR) {
            
                TRACE1(ANY, "error %d enumeratings dests", dwErr);
                break;
            }

            bRelDest = TRUE;


            //
            // Get route info for unicast view only
            //

            dwErr = RtmGetDestInfo(
                        ig.IG_RtmHandle, rdiTemp.DestHandle, RTM_BEST_PROTOCOL,
                        RTM_VIEW_MASK_UCAST, &rdi
                        );

            if (dwErr != NO_ERROR) {
            
                TRACE1(ANY, "error %d getting ucast info dests", dwErr);
                break;
            }

            bRelUcast = TRUE;


            //
            // Check if any route info is present in the UCAST view
            //

            if ( ( rdi.ViewInfo[0].HoldRoute == NULL ) &&
                 ( rdi.ViewInfo[0].Route == NULL ) )
            {
                //
                // This destination has no info in the UCAST view
                // Release all handles and get next route
                //
                
                dwErr = RtmReleaseDests(ig.IG_RtmHandle, 1, &rdi);

                if (dwErr != NO_ERROR) {
                
                    TRACE3(
                        ANY, "error %d releasing UCAST dest %s/%d", dwErr,
                        szNetwork, rdi.DestAddress.NumBits
                        );
                }

                dwErr = RtmReleaseDests(ig.IG_RtmHandle, 1, &rdiTemp);

                if (dwErr != NO_ERROR) {
                
                    TRACE3(
                        ANY, "error %d releasing dest %s/%d", dwErr,
                        szNetwork, rdi.DestAddress.NumBits
                        );
                }

                bRelDest = bRelUcast = FALSE;
                
                continue;
            }
                 
            
            //
            // convert to RIP internal representation, if hold down route present
            // use it as opposed to the best route.
            //

            dwErr = GetRouteInfo(
                        rdi.ViewInfo[0].HoldRoute ? rdi.ViewInfo[0].HoldRoute :
                                                    rdi.ViewInfo[0].Route,
                        NULL, &rdi, pRoute
                        );
                        
        } while (FALSE);
        

        if (dwErr != NO_ERROR) { 
        
            break; 
        }
            

        lstrcpy(szNetwork, INET_NTOA(pRoute->RR_Network.N_NetNumber));
        lstrcpy(szNextHop, INET_NTOA(pRoute->RR_NextHopAddress.N_NetNumber));
        

        //
        // set metrics as appropriate
        //
        
        if ( rdi.ViewInfo[0].HoldRoute != NULL ) {
        
            //
            // help down routes are always advertized with 
            // metric 16
            //

#if ROUTE_DBG
            TRACE2(
                ROUTE, "Holddown route %s/%d", szNetwork,
                rdi.DestAddress.NumBits
                );
#endif
            SETROUTEMETRIC(pRoute, IPRIP_INFINITE);
        }
        
        else if (pRoute-> RR_RoutingProtocol != PROTO_IP_RIP) {
        
            //
            // non-RIP routes are advertised with metric 2
            // TBD: This will need to be re-evaluated if/when we
            //      have a route redistribution policy
            //

            SETROUTEMETRIC(pRoute, 2);
        }
        
    } while ( FALSE );


    //
    // release handles as appropriate
    //
    
    if (bRelUcast) {
    
        DWORD dwErrTemp;
        
        dwErrTemp = RtmReleaseDests(ig.IG_RtmHandle, 1, &rdi);

        if (dwErrTemp != NO_ERROR) {
        
            TRACE3(
                ANY, "error %d releasing UCAST dest %s/%d", dwErrTemp,
                szNetwork, rdi.DestAddress.NumBits
                );
        }
    }
    

    if (bRelDest) {
    
        DWORD dwErrTemp;
        
        dwErrTemp = RtmReleaseDests(ig.IG_RtmHandle, 1, &rdiTemp);

        if (dwErrTemp != NO_ERROR) {
        
            TRACE3(
                ANY, "error %d releasing dest %s/%d", dwErrTemp,
                szNetwork, rdi.DestAddress.NumBits
                );
        }
    }

#if ROUTE_DBG

    if (dwErr == NO_ERROR) {
    
        TRACE4(
            ROUTE, "Enumerated route %s/%d via %s with metric %d",
            szNetwork, rdi.DestAddress.NumBits,
            szNextHop, GETROUTEMETRIC(pRoute)
            );
    }
#endif
    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    RtmGetRouteFinish
//
// terminates an enumeration of RTM routes
//----------------------------------------------------------------------------

DWORD
RtmGetRouteFinish(
    RTM_ENUM_HANDLE EnumHandle
    ) {

    DWORD dwErr;
    
    dwErr = RtmDeleteEnumHandle( ig.IG_RtmHandle, EnumHandle );

    if (dwErr != NO_ERROR) {

        TRACE1( ANY, "error %d closing enumeration handle", dwErr );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    ShutdownUpdateGetRouteNext
//
// continues an enumeration of RTM routes for a shutdown-update.
// same as RtmGetRouteNext, except that metrics are set to IPRIP_INFINITE - 1
//----------------------------------------------------------------------------

DWORD
ShutdownUpdateGetRouteNext(
    RTM_ENUM_HANDLE hEnumHandle,
    PRIP_IP_ROUTE pRoute
    ) {

    DWORD dwErr;


    //
    // during a shutdown, all non-infinite metrics are set to 15
    //

    dwErr = RtmGetRouteNext(hEnumHandle, pRoute);

    if (dwErr == NO_ERROR && GETROUTEMETRIC(pRoute) != IPRIP_INFINITE) {
        SETROUTEMETRIC(pRoute, IPRIP_INFINITE - 1);
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    TriggeredUpdateGetRouteStart
//
// starts an enumeration of routes from the send queue
// for a triggered update. nothing to do, since the caller
// of SendRoutes should have locked the send queue already
//----------------------------------------------------------------------------

DWORD
TriggeredUpdateGetRouteStart(
    PRTM_ENUM_HANDLE pEnumHandle
    ) {

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    TriggeredUpdateGetRouteNext
//
// continues an enumeration of routes from the send-queue
//----------------------------------------------------------------------------

DWORD
TriggeredUpdateGetRouteNext(
    RTM_ENUM_HANDLE EnumHandle,
    PRIP_IP_ROUTE pRoute
    ) {

    DWORD dwErr;


    dwErr = DequeueSendEntry(ig.IG_SendQueue, pRoute);

    if (dwErr == NO_ERROR && pRoute->RR_RoutingProtocol != PROTO_IP_RIP) {

        //
        // non-RIP routes are advertised with metric 2
        // TBD: This will need to be re-evaluated if/when we
        //      have a route redistribution policy
        //

        SETROUTEMETRIC(pRoute, 2);
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    TriggeredUpdateGetRouteFinish
//
// terminates an enumeration of routes from the send-queue
//----------------------------------------------------------------------------

DWORD
TriggeredUpdateGetRouteFinish(
    RTM_ENUM_HANDLE EnumHandle
    ) {

    return NO_ERROR;
}






//----------------------------------------------------------------------------
// Function:    SendRoutes
//
// This function sends triggered updates, full-updates, shutdown-updates, and
// responses to general requests; the processing for all such output is the
// same. The source of routing information is different, however, and this
// difference is abstracted away using the route enumeration function groups
// described above.
// In the case of sending a response to a general or specific request,
// the response should be sent on a single interface using a single IP address,
// using a particular type of RIP packet; the caller can specify which
// IP address to use by setting the argument dwAddrIndex to the index of the
// desired address in the interface's IP address table, and the caller can
// specify the type of packet to use by setting the argument dwAnnounceMode
// to the corresponding IPRIP_ANNOUNCE_* constant. These arguments are only
// used for responses to requests.
//
// assumes the interface table is locked
//----------------------------------------------------------------------------

DWORD
SendRoutes(
    PIF_TABLE_ENTRY pIfList[],
    DWORD dwIfCount,
    DWORD dwSendMode,
    DWORD dwDestination,
    DWORD dwAddrIndex
    ) {


    RTM_ENUM_HANDLE Enumerator;
    RIP_IP_ROUTE route;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    DWORD i, dwErr, dwBufCount;
    PDWORD pdwPeer, pdwPeerEnd;
    PIF_TABLE_ENTRY *ppite, *ppitend = NULL;
    PUPDATE_BUFFER pbuf, pbufend, pBufList;
    PROUTE_TABLE_ENTRY prte;
    ROUTE_TABLE summaryTable;
    PGETROUTE_START pfnGetRouteStart;
    PGETROUTE_NEXT pfnGetRouteNext;
    PGETROUTE_FINISH pfnGetRouteFinish;
    PLIST_ENTRY plstart, plend, phead, ple;


    //
    // if no interfaces, go no further
    //

    if (dwIfCount == 0) { return ERROR_NO_DATA; }


    //
    // initialize the route enumeration function table
    //

    dwErr = InitializeGetRoute(
                dwSendMode,
                &pfnGetRouteStart,
                &pfnGetRouteNext,
                &pfnGetRouteFinish
                );

    if (dwErr != NO_ERROR) { return ERROR_INVALID_PARAMETER; }


    dwErr = NO_ERROR;
    Enumerator = NULL;


    //
    // create table for summary routes
    //

    dwErr = CreateRouteTable(&summaryTable);

    if (dwErr != 0) {

        TRACE1(SEND, "error %d initializing summary table", dwErr);

        return dwErr;
    }



    dwErr = NO_ERROR;

    pBufList = NULL;


    do { // breakout loop


        //
        // the following discussion does not apply when sending routes
        // to specific destinations:
        // since unicast peers may be configured on some interfaces,
        // we need to allocate update buffers for those peers as well.
        //
        // also, we will not allocate update buffers for RIPv1 interfaces
        // on which broadcast is disabled (such interfaces should have
        // at least one unicast peer configured instead.)
        //
        // Thus, the number of update buffers may not be equal to
        // the number of interfaces, and in the worst case (i.e. where
        // all interfaces are RIPv1 and have broadcast disabled and have
        // no unicast peers configured) there may be no update buffers at all.
        //

        if (dwDestination != 0) {

            //
            // sending to a specific destination; this only happens when
            // there is a single interface in the list, for instance when
            // sending a response to a general request
            //

            dwBufCount = dwIfCount;
        }
        else {

            //
            // we are sending a full-update, triggered-update, or
            // a shutdown-update, and thus routes may be sent by
            // broadcast/multicast as well as to unicast peers
            //

            dwBufCount = 0;
            ppitend = pIfList + dwIfCount;

            for (ppite = pIfList; ppite < ppitend; ppite++) {

                pic = (*ppite)->ITE_Config;
                pib = (*ppite)->ITE_Binding;

                if (pic->IC_UnicastPeerMode != IPRIP_PEER_ONLY) {
                    dwBufCount += pib->IB_AddrCount;
                }

                if (pic->IC_UnicastPeerMode != IPRIP_PEER_DISABLED) {
                    dwBufCount += pic->IC_UnicastPeerCount;
                }
            }
        }


        if (dwBufCount == 0) { break; }


        //
        // allocate the update buffers for all interfaces
        //

        pBufList = RIP_ALLOC(dwBufCount * sizeof(UPDATE_BUFFER));

        if (pBufList == NULL) {

            dwErr = GetLastError();
            TRACE2(
                SEND, "error %d allocating %d bytes for update buffers",
                dwErr, dwBufCount * sizeof(UPDATE_BUFFER)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the update buffers allocated; in the case of
        // sending to a specific destination, initialize a buffer
        // for each interface; in the case of sending updates, also
        // initialize buffers for unicast peers.
        //

        pbuf = pBufList;
        pbufend = pBufList + dwBufCount;
        ppitend = pIfList + dwIfCount;


        ACQUIRE_BINDING_LOCK_SHARED();


        for (ppite = pIfList; ppite < ppitend; ppite++) {


            if (dwDestination != 0) {

                //
                // sending to a specific destination
                //

                InitializeUpdateBuffer(
                    *ppite, dwAddrIndex, pbuf, dwSendMode, dwDestination,
                    IPRIP_RESPONSE
                    );

                pbuf->UB_StartRoutine(pbuf);

                ++pbuf;
            }
            else {


                //
                // sending updates on multiple interfaces
                //

                pic = (*ppite)->ITE_Config;
                pib = (*ppite)->ITE_Binding;


                //
                // if broadcast or multicast is enabled on the interface,
                // and it is not configured to send only to listed peers,
                // initialize the broadcast/multicast update buffer
                //

                if (pic->IC_UnicastPeerMode != IPRIP_PEER_ONLY) {

                    for (i = 0; i < pib->IB_AddrCount; i++) {

                        InitializeUpdateBuffer(
                            *ppite, i, pbuf, dwSendMode, dwDestination,
                            IPRIP_RESPONSE
                            );

                        pbuf->UB_StartRoutine(pbuf);

                        ++pbuf;
                    }
                }



                if (pic->IC_UnicastPeerMode != IPRIP_PEER_DISABLED) {

                    //
                    // initialize update buffers for unicast peers, if any
                    //

                    pdwPeer = IPRIP_IF_UNICAST_PEER_TABLE(pic);
                    pdwPeerEnd = pdwPeer + pic->IC_UnicastPeerCount;


                    for ( ; pdwPeer < pdwPeerEnd; pdwPeer++) {

                        //
                        // Note: forcing peers to be on first address
                        //

                        InitializeUpdateBuffer(
                            *ppite, 0, pbuf, dwSendMode, *pdwPeer,
                            IPRIP_RESPONSE
                            );

                        pbuf->UB_StartRoutine(pbuf);

                        ++pbuf;
                    }
                }
            }
        }

        RELEASE_BINDING_LOCK_SHARED();


        //
        // start the route enumeration
        //

        if ( pfnGetRouteStart(&Enumerator) == NO_ERROR ) {
        
            //
            // enumerate and transmit the routes
            //

            while (pfnGetRouteNext(Enumerator, &route) == NO_ERROR) {

                //
                // for each route, send it on each update buffer,
                // subject to split-horizon/poison-reverse/subnet-summary
                // pass in the summary table pointer to store summarized routes
                //

                dwErr = SendRouteOnIfList(
                            pBufList, dwBufCount, dwSendMode, &summaryTable, &route
                            );
            }



            //
            // terminate the route enumeration
            //

            pfnGetRouteFinish(Enumerator);


            //
            // now send all routes which were summarized
            //

            plstart = summaryTable.RT_HashTableByNetwork;
            plend = plstart + ROUTE_HASHTABLE_SIZE;


            for (phead = plstart; phead < plend; phead++) {

                for (ple = phead->Flink; ple != phead; ple = ple->Flink) {


                    prte = CONTAINING_RECORD(ple, ROUTE_TABLE_ENTRY, RTE_Link);


                    //
                    // shouldn't summarize when sending summary table contents
                    // so we pass NULL instead of a summary table pointer
                    //

                    SendRouteOnIfList(
                        pBufList, dwBufCount, dwSendMode, NULL, &prte->RTE_Route
                        );

                }
            }

            //
            // finally, write the summarized routes to RTM
            //

            WriteSummaryRoutes(&summaryTable, ig.IG_RtmHandle);

        }
    } while(FALSE);



    //
    // free the allocated update buffers, if any
    //

    if (pBufList != NULL) {

        pbufend = pBufList + dwBufCount;


        for (pbuf = pBufList; pbuf < pbufend; pbuf++) {


            //
            // send whatever might remain in the update buffer
            //

            pbuf->UB_FinishRoutine(pbuf);
        }


        RIP_FREE(pBufList);
    }


    //
    // delete the summary table
    //

    DeleteRouteTable(&summaryTable);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    SendRouteOnIfList
//
// this function sends a single route on all interfaces in the given
// interface list, using the update buffers in the given update buffer list
//----------------------------------------------------------------------------

DWORD
SendRouteOnIfList(
    UPDATE_BUFFER pBufList[],
    DWORD dwBufCount,
    DWORD dwSendMode,
    PROUTE_TABLE pSummaryTable,
    PRIP_IP_ROUTE pRoute
    ) {


    RIP_IP_ROUTE route;
    DWORD dwFound, dwTTL;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PUPDATE_BUFFER pbuf, pbufend;
    DWORD dwDestNetwork, dwNexthopNetwork;
    DWORD dwDestNetclassAddr, dwDestNetclassMask;
    DWORD dwRouteNetclassAddr, dwRouteNetclassMask;
    DWORD dwRouteNetwork, dwRouteNetmask, dwRouteProtocol;

#if ROUTE_DBG
    CHAR szDest[32];
    CHAR szDestMask[32];
    CHAR szNexthop[32];
    CHAR szNexthopMask[32];
    CHAR szRoute[32];
    CHAR szRouteMask[32];


    //
    // set up variables used for error and information messages
    //

    lstrcpy(szRoute, INET_NTOA(pRoute->RR_Network.N_NetNumber));
    lstrcpy(szRouteMask, INET_NTOA(pRoute->RR_Network.N_NetMask));
    lstrcpy(szNexthop, INET_NTOA(pRoute->RR_NextHopAddress.N_NetNumber));
    lstrcpy(szNexthopMask, INET_NTOA(pRoute->RR_NextHopAddress.N_NetMask));

#endif


    //
    // we never send summary routes if they are read from RTM;
    // we only send them if they are generated in the process
    // of advertising actual routes on this iteration;
    // we can tell the difference by checking whether we are still
    // generating summary routes (i.e. if pSummaryTable is non-NULL);
    // if we aren't it is time to start sending summary routes
    //

    if (pSummaryTable != NULL && pRoute->RR_RoutingProtocol == PROTO_IP_RIP &&
        GETROUTEFLAG(pRoute) == ROUTEFLAG_SUMMARY) {

        return NO_ERROR;
    }


    //
    // get the route's network and netmask, and compute
    // the route's network class address and the network class mask;
    // to support supernetting, we double-check the class mask
    // and use the supernet mask if necessary
    //

    dwRouteProtocol = pRoute->RR_RoutingProtocol;
    dwRouteNetwork = pRoute->RR_Network.N_NetNumber;
    dwRouteNetmask = pRoute->RR_Network.N_NetMask;
    dwRouteNetclassMask = NETCLASS_MASK(dwRouteNetwork);

    if (dwRouteNetclassMask > dwRouteNetmask) {
        dwRouteNetclassMask = dwRouteNetmask;
    }

    dwRouteNetclassAddr = (dwRouteNetwork & dwRouteNetclassMask);


    //
    // go through each update buffer
    //

    pbufend = pBufList + dwBufCount;

    for (pbuf = pBufList; pbuf < pbufend; pbuf++) {


        pite = pbuf->UB_ITE;
        pic = pite->ITE_Config;


        //
        // if this is a broadcast route entry, skip it
        // The first condition uses the netmask information for this route, 
        // stored in route table, to determine if it is a broadcast route
        // The second condition uses the netmask which is computed based 
        // on the address class
        // The third condition checks if it is an all 1's broadcast
        //

        if ( IS_DIRECTED_BROADCAST_ADDR(dwRouteNetwork, dwRouteNetmask) ||
             IS_DIRECTED_BROADCAST_ADDR(dwRouteNetwork, dwRouteNetclassMask) ||
             IS_LOCAL_BROADCAST_ADDR(dwRouteNetwork) ) {

             continue;
        }


        //
        // if this is the multicast route entry, skip it
        //

        if ( CLASSD_ADDR( dwRouteNetwork ) || CLASSE_ADDR( dwRouteNetwork ) ) {
            continue;
        }


        //
        // If this is a loopback route, skip it.
        //

        if ( IS_LOOPBACK_ADDR( dwRouteNetwork ) ) {

            continue;
        }


        //
        // if this is the rotue to the outgoing interface's network,
        // (e.g. the route to 10.1.1.0 on interface 10.1.1.1/255.255.255.0)
        // don't include it in the update
        // (clearly, we shouldn't AND the default-route's netmask (0)
        // with anything and expect this to work
        //

        if (dwRouteNetmask &&
            dwRouteNetwork == (pbuf->UB_Address & dwRouteNetmask)) {
            continue;
        }


        //
        // if announcing host routes is disabled on the interface
        // and this is a host route, skip it
        //

        if (dwRouteNetmask == HOSTADDR_MASK &&
            IPRIP_FLAG_IS_DISABLED(pic, ANNOUNCE_HOST_ROUTES)) {

            continue;
        }


        //
        // if announcing default routes is disabled
        // and this is a default route, skip it
        //

        if (dwRouteNetwork == 0 &&
            IPRIP_FLAG_IS_DISABLED(pic, ANNOUNCE_DEFAULT_ROUTES)) {

            continue;
        }


        //
        // now put the route through the announce filters
        //

        if (pic->IC_AnnounceFilterMode != IPRIP_FILTER_DISABLED) {

            //
            // discard if we are including all routes and this route is listed
            // as an exception, or if we are excluding all routes and
            // this route is not listed as an exception
            //

            IS_ROUTE_IN_ANNOUNCE_FILTER(pic, dwRouteNetwork, dwFound);

            if ((pic->IC_AnnounceFilterMode == IPRIP_FILTER_INCLUDE &&
                    !dwFound) ||
                (pic->IC_AnnounceFilterMode == IPRIP_FILTER_EXCLUDE &&
                    dwFound)) {
                continue;
            }
        }



        //
        // SUBNET-SUMMARY PROCESSING:
        //
        // if the route is not on the network we are sending this to or
        // if the route's mask is longer than that of the network we are
        // sending to, or if the route is a network route, add it to the
        // summary table instead of sending it immediately.
        // default routes are excepted from summarization
        //


        route = *pRoute;


        if (pSummaryTable != NULL && dwRouteNetwork != 0) {


            //
            // get the destination address to which the update is being
            // sent for this interface; double-check the netclass mask
            // to accomodate supernets
            //

            dwDestNetclassAddr = pbuf->UB_DestAddress;
            dwDestNetclassMask = NETCLASS_MASK(dwDestNetclassAddr);

            if (dwDestNetclassMask > pbuf->UB_DestNetmask) {
                dwDestNetclassMask = pbuf->UB_DestNetmask;
            }

            dwDestNetclassAddr = (dwDestNetclassAddr & dwDestNetclassMask);


            if ((dwRouteNetwork == dwRouteNetclassAddr &&
                 dwRouteNetmask == dwRouteNetclassMask) ||
                dwDestNetclassAddr != dwRouteNetclassAddr) {

                if ((pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1) ||
                    !IPRIP_FLAG_IS_ENABLED(pic, NO_SUBNET_SUMMARY)) {

                    //
                    // either the route is a network route,
                    // or the update is going to a network different
                    // from that of the route
                    //

                    //
                    // create an entry in the summary table instead of sending;
                    //

                    route.RR_Network.N_NetNumber = dwRouteNetclassAddr;
                    route.RR_Network.N_NetMask = dwRouteNetclassMask;

                    if ((dwRouteNetwork != dwRouteNetclassAddr) ||
                        (dwRouteNetmask != dwRouteNetclassMask)) {
                        route.RR_RoutingProtocol = PROTO_IP_RIP;
                        SETROUTEFLAG(&route, ROUTEFLAG_SUMMARY);
                        SETROUTETAG(&route, pic->IC_RouteTag);
                    }


                    CreateRouteEntry(
                        pSummaryTable, &route, pic->IC_RouteExpirationInterval,
                        pic->IC_RouteRemovalInterval
                        );

                    continue;
                }
            }
            else
            if (pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1 &&
                dwRouteNetmask != HOSTADDR_MASK &&
                pbuf->UB_Netmask < dwRouteNetmask) {


                //
                // this is neither a host route nor a default route,
                // and the subnet-mask on the outgoing interface is shorter
                // than that of the route, so the route's network must be
                // truncated lest it be considered a host route by the routers
                // who will receive this update
                // only do this in RIP1 mode, since in RIP2 mode
                // we can include the netmask in the route entry
                //

                route.RR_Network.N_NetNumber &= pbuf->UB_Netmask;
                route.RR_Network.N_NetMask = pbuf->UB_Netmask;
                route.RR_RoutingProtocol = PROTO_IP_RIP;
                SETROUTEFLAG(&route, ROUTEFLAG_SUMMARY);
                SETROUTETAG(&route, pic->IC_RouteTag);

                CreateRouteEntry(
                    pSummaryTable, &route, pic->IC_RouteExpirationInterval,
                    pic->IC_RouteRemovalInterval
                    );

                continue;
            }
        }


        //
        // Summary route checks
        //
        //  Summary routes are to sent only on those interfaces that 
        //  require them i.e. Interfaces on which the annouce mode is
        //  RIP1 or on which summarization has been explicity turned on
        //

        if (pSummaryTable == NULL &&
            ((GETROUTEFLAG(&route) & ROUTEFLAG_SUMMARY) == ROUTEFLAG_SUMMARY) &&
            pic->IC_AnnounceMode != IPRIP_ANNOUNCE_RIP1 &&
            IPRIP_FLAG_IS_ENABLED(pic, NO_SUBNET_SUMMARY)) {

            //
            // This is a summary route, and the interface over which it is
            // to be sent does not require summary routes to be sent on it
            //

            continue;
        }

        
        //
        // SPLIT-HORIZON/POISON-REVERSE PROCESSING:
        //

        //
        // note that we only do split-horizon/poison-reverse on RIP routes
        //

        //
        // Modification : Split-horizon/poison-reverse done for all routes
        //
        // if (dwRouteProtocol != PROTO_IP_RIP ||
        //    IPRIP_FLAG_IS_DISABLED(pic, SPLIT_HORIZON))

        if (IPRIP_FLAG_IS_DISABLED(pic, SPLIT_HORIZON)) {
            //
            // add the entry as-is:
            // sender should use us as the nexthop to this destination
            //

            route.RR_NextHopAddress.N_NetNumber = 0;
            route.RR_NextHopAddress.N_NetMask = 0;

            pbuf->UB_AddRoutine(pbuf, &route);
        }
        else
        if (IPRIP_FLAG_IS_DISABLED(pic, POISON_REVERSE)) {


            //
            // if the route is being sent to the network from which
            // the route was learnt, exclude the route altogether
            //

            dwDestNetwork = (pbuf->UB_DestAddress & pbuf->UB_DestNetmask);
            dwNexthopNetwork = (route.RR_NextHopAddress.N_NetNumber &
                                route.RR_NextHopAddress.N_NetMask);

            //
            // Check if the route next hop is on the same network as the
            // socket from which this RIP response is being sent.
            // If so, do not include this route in the update.
            // Otherwise, we may still need to do poison-reverse
            // since the next-hop may be the other end of a point-to-point link
            // (endpoints of such links can be on different networks)
            // in which case the first test would succeed (different networks)
            // but we'd still be required to perform split-horizon.
            // Therefore if the outgoing interface is the one from which
            // the route was learnt, we do not include this route in the update.
            //

            if (dwNexthopNetwork == dwDestNetwork ||
                (pbuf->UB_ITE->ITE_Type == DEMAND_DIAL &&
                 route.RR_InterfaceID == pbuf->UB_ITE->ITE_Index)) {
                continue;
            }
            else {

                //
                // sending to a different network, so sender should use
                // us as the nexthop to this destination
                //

                route.RR_NextHopAddress.N_NetNumber = 0;
                route.RR_NextHopAddress.N_NetMask = 0;
            }

            pbuf->UB_AddRoutine(pbuf, &route);
        }
        else {


            //
            // if the route is being sent to the network from which
            // the route was learnt, include the route with infinite metric
            //


            dwDestNetwork = (pbuf->UB_DestAddress & pbuf->UB_DestNetmask);
            dwNexthopNetwork = (route.RR_NextHopAddress.N_NetNumber &
                                route.RR_NextHopAddress.N_NetMask);


            if (dwNexthopNetwork == dwDestNetwork ||
                (pbuf->UB_ITE->ITE_Type == DEMAND_DIAL &&
                 route.RR_InterfaceID == pbuf->UB_ITE->ITE_Index)) {

                //
                // if a route is advertised with infinite metric due to
                // poison-reverse and it would still be advertised with
                // infinite metric in a triggered update, save bandwidth
                // by excluding the route
                //

                if (dwSendMode == SENDMODE_TRIGGERED_UPDATE) {
                    continue;
                }
                else {
                    SETROUTEMETRIC(&route, IPRIP_INFINITE);
                }

            }
            else {

                //
                // sending to a different network, so sender should use
                // us as the nexthop to this destination
                //

                route.RR_NextHopAddress.N_NetNumber = 0;
                route.RR_NextHopAddress.N_NetMask = 0;
            }

            pbuf->UB_AddRoutine(pbuf, &route);
        }


        //
        // hold advertized destinations
        //

        if ((dwSendMode == SENDMODE_FULL_UPDATE) ||
            (dwSendMode == SENDMODE_GENERAL_RESPONSE1) ||
            (dwSendMode == SENDMODE_GENERAL_RESPONSE2)) {

            //
            // use the hold interval from the interface over which the
            // route is over.
            //

            if (pite->ITE_Index == route.RR_InterfaceID) {
            
                DWORD dwErr;
                
                dwErr = RtmHoldDestination(
                            ig.IG_RtmHandle, route.hDest, RTM_VIEW_MASK_UCAST,
                            pic-> IC_RouteRemovalInterval * 1000
                            );

                if (dwErr != NO_ERROR) {

                    TRACE1(ANY, "error %d holding dest", dwErr);
                }
            }
        }
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    SendGeneralRequest
//
// This function transmits RIP requests on interface to all neighbors in
// the interfaces neighbor list. A request is also sent via broadcast or
// multicast is the neighbor list is not used exclusively.
//----------------------------------------------------------------------------

DWORD
SendGeneralRequest(
    PIF_TABLE_ENTRY pite
    ) {

    DWORD i, dwErr;
    PIPRIP_ENTRY pie;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    PDWORD pdwPeer, pdwPeerEnd;


    pic = pite->ITE_Config;
    pib = pite->ITE_Binding;
    paddr = IPRIP_IF_ADDRESS_TABLE(pib);

    ACQUIRE_BINDING_LOCK_SHARED();


    do {    // error breakout loop


        //
        // broadcast/multicast a request if not using neighbor-list only
        //

        if (pic->IC_UnicastPeerMode != IPRIP_PEER_ONLY) {

            for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {

                UPDATE_BUFFER ub;

                //
                // initialize the update buffer
                //

                dwErr = InitializeUpdateBuffer(
                            pite, i, &ub, SENDMODE_GENERAL_REQUEST, 0,
                            IPRIP_REQUEST
                            );

                ub.UB_StartRoutine(&ub);


                //
                // set up the general request entry
                //

                pie = (PIPRIP_ENTRY)(ub.UB_Buffer + ub.UB_Length);

                pie->IE_AddrFamily = ADDRFAMILY_REQUEST;
                pie->IE_RouteTag = 0;
                pie->IE_Destination = 0;
                pie->IE_SubnetMask = 0;
                pie->IE_Nexthop = 0;
                pie->IE_Metric = htonl(IPRIP_INFINITE);

                ub.UB_Length += sizeof(IPRIP_ENTRY);


                //
                // send the buffer
                //

                ub.UB_FinishRoutine(&ub);
            }
        }


        //
        // if the list of peers is not in use, we are done
        //

        if (pic->IC_UnicastPeerMode == IPRIP_PEER_DISABLED) { break; }


        //
        // send requests to all the configured peers
        //

        pdwPeer = IPRIP_IF_UNICAST_PEER_TABLE(pic);
        pdwPeerEnd = pdwPeer + pic->IC_UnicastPeerCount;

        for ( ; pdwPeer < pdwPeerEnd; pdwPeer++) {

            UPDATE_BUFFER ub;

            //
            // initialize the update buffer
            // Note: we are forcing the peers onto the first address
            //

            dwErr = InitializeUpdateBuffer(
                        pite, 0, &ub, SENDMODE_GENERAL_REQUEST, *pdwPeer,
                        IPRIP_REQUEST
                        );

            ub.UB_StartRoutine(&ub);


            //
            // set up the general request entry
            //

            pie = (PIPRIP_ENTRY)(ub.UB_Buffer + ub.UB_Length);

            pie->IE_AddrFamily = ADDRFAMILY_REQUEST;
            pie->IE_RouteTag = 0;
            pie->IE_Destination = 0;
            pie->IE_SubnetMask = 0;
            pie->IE_Nexthop = 0;
            pie->IE_Metric = htonl(IPRIP_INFINITE);

            ub.UB_Length += sizeof(IPRIP_ENTRY);


            //
            // send the buffer
            //

            ub.UB_FinishRoutine(&ub);
        }

    } while(FALSE);


    RELEASE_BINDING_LOCK_SHARED();

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    AuthenticatePacket
//
// Given a RIP packet and an interface configuration block, this function
// accepts or rejects the packet based on the authentication settings
// of the interface and the authentication content of the packet.
//----------------------------------------------------------------------------

DWORD
AuthenticatePacket(
    PBYTE pbuf,
    PIPRIP_AUTHENT_ENTRY pae,
    PIPRIP_IF_CONFIG pic,
    PIPRIP_IF_STATS pis,
    PIPRIP_PEER_STATS pps,
    PIPRIP_ENTRY *ppie
    ) {

    DWORD dwErr;

    dwErr = NO_ERROR;

    if (pic->IC_AuthenticationType == IPRIP_AUTHTYPE_NONE) {

        //
        // interface is not configured for authentication,
        // so discard authenticated packets
        //

        if (pae->IAE_AddrFamily == htons(ADDRFAMILY_AUTHENT)) {

            if (pis != NULL) {
                InterlockedIncrement(&pis->IS_BadResponsePacketsReceived);
            }

            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }

            dwErr = ERROR_ACCESS_DENIED;
        }
    }
    else {

        //
        // interface is using authentication,
        // so discard unauthenticated packets
        // and packets using different authentication schemes
        //

        if (pae->IAE_AddrFamily != htons(ADDRFAMILY_AUTHENT) ||
            pae->IAE_AuthType != htons((WORD)pic->IC_AuthenticationType)) {

            if (pis != NULL) {
                InterlockedIncrement(&pis->IS_BadResponsePacketsReceived);
            }

            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }

            dwErr = ERROR_ACCESS_DENIED;
        }
        else {

            //
            // interface and packet are using the same authentication:
            // check that the packet passes validation
            //

            switch(pic->IC_AuthenticationType) {

                case IPRIP_AUTHTYPE_SIMPLE_PASSWORD:

                    //
                    // for simple passwords, just compare the keys
                    //

                    dwErr = (DWORD)memcmp(
                                pae->IAE_AuthKey, pic->IC_AuthenticationKey,
                                IPRIP_MAX_AUTHKEY_SIZE
                                );

                    if (dwErr != 0) { dwErr = ERROR_ACCESS_DENIED; }
                    break;

                case IPRIP_AUTHTYPE_MD5:

                    //
                    // TBD: unimplemented unless required.
                    //

                    break;
            }


            //
            // advance the "first entry" pointer
            //

            if (dwErr == NO_ERROR) { ++(*ppie); }
        }
    }

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    WorkerFunctionProcessInput
//
// This function is responsible for processing input.
// If any peer filters exist, it applies them to the routes received
// and passes the packets on to the processing functions.
//----------------------------------------------------------------------------

VOID
WorkerFunctionProcessInput(
    PVOID pContext
    ) {

    PINPUT_CONTEXT pwc;
    DWORD dwErr, dwCommand;
    PIPRIP_GLOBAL_CONFIG pigc;

    if (!ENTER_RIP_WORKER()) { return; }


    TRACE0(ENTER, "entering WorkerFunctionProcessInput");


    do {


        ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);
        dwErr = DequeueRecvEntry(ig.IG_RecvQueue, &dwCommand, (PBYTE *)&pwc);
        RELEASE_LIST_LOCK(ig.IG_RecvQueue);

        if (dwErr != NO_ERROR) {

            TRACE1(RECEIVE, "error %d dequeueing received packet", dwErr);
            break;
        }


        //
        // call the processing function for this type of packet
        //

        if (dwCommand == IPRIP_REQUEST) {
            ProcessRequest(pwc);
        }
        else
        if (dwCommand == IPRIP_RESPONSE) {

            DWORD dwSource, dwFound = 0;

            dwSource = pwc->IC_InputSource.sin_addr.s_addr;


            //
            // make sure the packet is from the RIP port
            //

            if (pwc->IC_InputSource.sin_port != htons(IPRIP_PORT)) {

                LPSTR lpszAddr = INET_NTOA(dwSource);
                TRACE2(
                    RECEIVE, "invalid port in RESPONSE from %s on interface %d",
                    lpszAddr, pwc->IC_InterfaceIndex
                    );
                LOGINFO1(INVALID_PORT, lpszAddr, NO_ERROR);

                RIP_FREE(pwc);
                break;
            }


            //
            // put the packet through the peer filters since it is a response
            //

            ACQUIRE_GLOBAL_LOCK_SHARED();

            pigc = ig.IG_Config;

            if (dwCommand == IPRIP_RESPONSE &&
                pigc->GC_PeerFilterMode != IPRIP_FILTER_DISABLED) {


                //
                // discard if this is not from a trusted peer:
                // this is so if we are including only listed peers and this peer
                // is not listed, or if we are excluding all listed peers
                // and this peer is listed
                //

                IS_PEER_IN_FILTER(pigc, dwSource, dwFound);


                if ((!dwFound &&
                     pigc->GC_PeerFilterMode == IPRIP_FILTER_INCLUDE) ||
                    (dwFound &&
                     pigc->GC_PeerFilterMode == IPRIP_FILTER_EXCLUDE)) {

                    LPSTR lpszAddr = INET_NTOA(dwSource);
                    TRACE2(
                        RECEIVE,
                        "FILTER: dropping RESPONSE from %s on interface %d",
                        lpszAddr, pwc->IC_InterfaceIndex
                        );
                    LOGINFO1(RESPONSE_FILTERED, lpszAddr, NO_ERROR);

                    RELEASE_GLOBAL_LOCK_SHARED();

                    RIP_FREE(pwc);
                    break;
                }
            }

            RELEASE_GLOBAL_LOCK_SHARED();


            ProcessResponse(pwc);
        }



    } while(FALSE);


    TRACE0(LEAVE, "leaving WorkerFunctionProcessInput");
    LEAVE_RIP_WORKER();

    return;
}




//----------------------------------------------------------------------------
// Function:    ProcessRequest
//
// This function handles the processing of an incoming request packet.
//----------------------------------------------------------------------------

VOID
ProcessRequest(
    PVOID pContext
    ) {

    PBYTE pbuf;
    DWORD dwSize;
    CHAR szSource[20];
    PIPRIP_IF_STATS pis;
    PIPRIP_ENTRY pie;
    PIPRIP_HEADER pih;
    PIPRIP_AUTHENT_ENTRY pae;
    PIF_TABLE pTable;
    PINPUT_CONTEXT pwc;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IP_ADDRESS paddr;
    PPEER_TABLE_ENTRY ppte;
    PIPRIP_PEER_STATS pps;


    TRACE0(ENTER, "entering ProcessRequest");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();



    do { // breakout loop


        //
        // retrieve the interface on which the request arrived
        //

        pwc = (PINPUT_CONTEXT)pContext;

        pite = GetIfByIndex(pTable, pwc->IC_InterfaceIndex);

        if (pite == NULL || IF_IS_INACTIVE(pite)) {

            TRACE1(
                REQUEST, "processing request: interface %d not found",
                pwc->IC_InterfaceIndex
                );

            break;
        }



        pic = pite->ITE_Config;
        paddr = IPRIP_IF_ADDRESS_TABLE(pite->ITE_Binding) + pwc->IC_AddrIndex;
        pbuf = pwc->IC_InputPacket.IP_Packet;
        pih = (PIPRIP_HEADER)pbuf;
        pie = (PIPRIP_ENTRY)(pbuf + sizeof(IPRIP_HEADER));
        pae = (PIPRIP_AUTHENT_ENTRY)pie;
        pis = NULL;
        pps = NULL;


        lstrcpy(szSource, INET_NTOA(pwc->IC_InputSource.sin_addr));


        //
        // make sure this is a packet we can respond to;
        // discard if this is a v1 packet and this interface is v2-only or
        // if this is a v2-packet and this interface is v1-only
        //

        if ((pih->IH_Version != 2 &&
             pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP2)) {

            CHAR szVersion[10];
            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
            TRACE2(
                REQUEST, "discarding non-v2 request on RIPv2 interface %d (%s)",
                pite->ITE_Index, lpszAddr
                );
            wsprintf(szVersion, "%d", pih->IH_Version);
            LOGINFO4(
                PACKET_VERSION_MISMATCH, szVersion, lpszAddr, szSource, "2", 0
                );

            break;
        }
        else
        if ((pih->IH_Version != 1 &&
             pic->IC_AnnounceMode == IPRIP_ANNOUNCE_RIP1)) {

            CHAR szVersion[10];
            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
            TRACE2(
                REQUEST, "discarding RIPv2 request on RIPv1 interface %d (%s)",
                pite->ITE_Index, lpszAddr
                );
            wsprintf(szVersion, "%d", pih->IH_Version);
            LOGINFO4(
                PACKET_VERSION_MISMATCH, szVersion, lpszAddr, szSource, "1", 0
                );

            break;
        }



        //
        // version 2 packets call for authentication processing;
        //

        if (pih->IH_Version == 2) {

            DWORD dwErr;

            dwErr = AuthenticatePacket(pbuf, pae, pic, pis, pps, &pie);

            if (dwErr == ERROR_ACCESS_DENIED) {

                LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
                TRACE3(
                    REQUEST, "dropping packet from %s on interface %d (%s): authentication failed",
                    szSource, pite->ITE_Index, lpszAddr
                    );
                LOGWARN2(AUTHENTICATION_FAILED, lpszAddr, szSource, NO_ERROR);

                break;
            }
        }



        //
        // find the total remaining size of the packet
        //

        dwSize = (DWORD)(((ULONG_PTR)pbuf + pwc->IC_InputLength) - (ULONG_PTR)pie);



        //
        // see which kind of request this is
        //

        if (pie->IE_AddrFamily == ADDRFAMILY_REQUEST &&
            pie->IE_Metric == htonl(IPRIP_INFINITE) &&
            dwSize == sizeof(IPRIP_ENTRY)) {


            //
            // GENERAL REQUEST:
            //
            // send all routes on the interface
            //


            if (pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED ||
                pwc->IC_InputSource.sin_port != htons(IPRIP_PORT)) {


                TRACE3(
                    REQUEST, "responding to GENERAL REQUEST from %s on interface %d (%s)",
                    szSource, pite->ITE_Index, INET_NTOA(paddr->IA_Address)
                    );


                //
                // send version 2 packets in response to version 2 requests
                // and send version 1 packets in response to all other requests
                //

                if (pih->IH_Version != 2) {

                    SendRoutes(
                        &pite, 1, SENDMODE_GENERAL_RESPONSE1,
                        pwc->IC_InputSource.sin_addr.s_addr, pwc->IC_AddrIndex
                        );
                }
                else {

                    SendRoutes(
                        &pite, 1, SENDMODE_GENERAL_RESPONSE2,
                        pwc->IC_InputSource.sin_addr.s_addr, pwc->IC_AddrIndex
                        );
                }

                InterlockedIncrement(&ig.IG_Stats.GS_TotalResponsesSent);
            }
        }
        else
        if (pic->IC_AnnounceMode == IPRIP_ANNOUNCE_DISABLED &&
            pwc->IC_InputSource.sin_port == htons(IPRIP_PORT)) {

            //
            // SPECIFIC REQUEST:
            // We are in silent mode and the request came from port 520,
            // so we are not allowed to respond.
            //

            TRACE3(
                REQUEST, "ignoring SPECIFIC REQUEST from %s on interface %d (%s)",
                szSource, pite->ITE_Index, INET_NTOA(paddr->IA_Address)
                );
        }
        else {

            IP_NETWORK net;
            UPDATE_BUFFER ub;
            RIP_IP_ROUTE route;
            PIPRIP_ENTRY piend;
            RTM_NET_ADDRESS rna;
            RTM_DEST_INFO rdi;
            DWORD dwErr;


            //
            // SPECIFIC REQUEST:
            // have to look up each destination in the packet
            // and fill in our metric for it if it exists in RTM
            //


            TRACE3(
                REQUEST, "responding to SPECIFIC REQUEST from %s on interface %d (%s)",
                szSource, pite->ITE_Index, INET_NTOA(paddr->IA_Address)
                );



            //
            // acquire the binding-table lock since InitializeUpdateBuffer
            // needs to call GuessSubnetMask to generate a broadcast address
            // to which the response will be sent
            //

            ACQUIRE_BINDING_LOCK_SHARED();

            if (pih->IH_Version != 2) {
                InitializeUpdateBuffer(
                    pite, pwc->IC_AddrIndex, &ub, SENDMODE_SPECIFIC_RESPONSE1,
                    pwc->IC_InputSource.sin_addr.s_addr, IPRIP_RESPONSE
                    );
            }
            else {
                InitializeUpdateBuffer(
                    pite, pwc->IC_AddrIndex, &ub, SENDMODE_SPECIFIC_RESPONSE2,
                    pwc->IC_InputSource.sin_addr.s_addr, IPRIP_RESPONSE
                    );
            }


            //
            // we must reply to the port from which the message was sent
            //

            ub.UB_Destination = pwc->IC_InputSource;


            //
            // start the update buffer
            //

            ub.UB_StartRoutine(&ub);


            //
            // query RTM for each route entry in packet
            //

            piend = (PIPRIP_ENTRY)(pbuf + pwc->IC_InputLength);
            for ( ; pie < piend; pie++) {


                //
                // ignore unrecognized address families
                //

                if (pie->IE_AddrFamily != htons(AF_INET)) {
                    continue;
                }


                net.N_NetNumber = pie->IE_Destination;

                if (pih->IH_Version == 2 && pie->IE_SubnetMask != 0) {
                    net.N_NetMask = pie->IE_SubnetMask;
                }
                else {
                    net.N_NetMask = GuessSubnetMask(net.N_NetNumber, NULL);
                }


                //
                // lookup best route to the requested destination
                // and get the metric
                //
                
                RTM_IPV4_SET_ADDR_AND_MASK(
                    &rna, net.N_NetNumber, net.N_NetMask
                    );
                
                dwErr = RtmGetExactMatchDestination(
                            ig.IG_RtmHandle, &rna, RTM_BEST_PROTOCOL,
                            RTM_VIEW_MASK_UCAST, &rdi
                            );

                if (dwErr != NO_ERROR) {
                    pie->IE_Metric = htonl(IPRIP_INFINITE);
                }
            
                else
                {
                    //
                    // if there is no best route to this destination
                    // metric is INFINITE
                    //
                    
                    if (rdi.ViewInfo[0].Route == NULL) {
                        pie->IE_Metric = htonl(IPRIP_INFINITE);
                    }

                    else {
                    
                        dwErr = GetRouteInfo(
                                    rdi.ViewInfo[0].Route, NULL, &rdi, &route
                                    );
                                    
                        if (dwErr != NO_ERROR) {
                            pie->IE_Metric = htonl(IPRIP_INFINITE);
                        }

                        else {
                            
                            //
                            // non-RIP routes are advertised with metric 2
                            //

                            pie->IE_Metric = (route.RR_RoutingProtocol == PROTO_IP_RIP ?
                                              htonl(GETROUTEMETRIC(&route)) : htonl(2));
                        }
                    }

                    
                    //
                    // release the dest info
                    //
                    
                    dwErr = RtmReleaseDestInfo(ig.IG_RtmHandle, &rdi);

                    if (dwErr != NO_ERROR)
                    {
                        char szNet[20], szMask[20];

                        lstrcpy(szNet, INET_NTOA(route.RR_Network.N_NetNumber));
                        lstrcpy(szMask, INET_NTOA(route.RR_Network.N_NetMask));

                        TRACE3(
                            ROUTE, "error %d releasing dest %s:%s", dwErr,
                            szNet, szMask
                            );
                    }
                }


                RTM_ROUTE_FROM_IPRIP_ENTRY(&route, pie);


                ub.UB_AddRoutine(&ub, &route);
            }

            RELEASE_BINDING_LOCK_SHARED();


            //
            // send the buffer now
            //

            ub.UB_FinishRoutine(&ub);

            InterlockedIncrement(&ig.IG_Stats.GS_TotalResponsesSent);
        }

    } while(FALSE);



    RELEASE_IF_LOCK_SHARED();

    RIP_FREE(pContext);



    TRACE0(LEAVE, "leaving ProcessRequest");

}





//----------------------------------------------------------------------------
// Function:    ProcessResponse
//
// this function process an incoming IPRIP response packet
//----------------------------------------------------------------------------

VOID
ProcessResponse(
    PVOID pContext
    ) {

    DWORD dwSource;
    PBYTE pPacket;
    PIPRIP_IF_STATS pis;
    PIF_TABLE pTable;
    PIPRIP_HEADER pih;
    BOOL bTriggerUpdate;
    PIPRIP_ENTRY pie, piend;
    PIPRIP_AUTHENT_ENTRY pae;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IP_ADDRESS paddr;
    PINPUT_CONTEXT pwc;
    PPEER_TABLE pPeers;
    PPEER_TABLE_ENTRY ppte;
    PIPRIP_PEER_STATS pps;
    CHAR szSource[20], szNetwork[20];
    LPSTR lpszTemp = NULL;


    TRACE0(ENTER, "entering ProcessResponse");



    bTriggerUpdate = FALSE;
    pTable = ig.IG_IfTable;
    pPeers = ig.IG_PeerTable;


    ACQUIRE_IF_LOCK_SHARED();


    do { // breakout loop


        pwc = (PINPUT_CONTEXT)pContext;



        //
        // get pointer to receiving interface
        //

        pite = GetIfByIndex(pTable, pwc->IC_InterfaceIndex);

        if (pite == NULL || IF_IS_INACTIVE(pite)) {

            TRACE1(
                RESPONSE, "processing response: interface %d not found",
                pwc->IC_InterfaceIndex
                );

            break;
        }


        ZeroMemory(szSource, sizeof(szSource));
        ZeroMemory(szNetwork, sizeof(szSource));

        dwSource = pwc->IC_InputSource.sin_addr.s_addr;
        lpszTemp = INET_NTOA(dwSource);
        if (lpszTemp != NULL) { lstrcpy(szSource, lpszTemp); }
        else { ZeroMemory(szSource, sizeof(szSource)); }
        

        //
        // get pointer to peer struct for sender
        //

        ACQUIRE_PEER_LOCK_SHARED();

        ppte = GetPeerByAddress(pPeers, dwSource, GETMODE_EXACT, NULL);

        if (ppte != NULL) { pps = &ppte->PTE_Stats; }
        else { pps = NULL; }

        RELEASE_PEER_LOCK_SHARED();


        pis = &pite->ITE_Stats;
        pic = pite->ITE_Config;
        paddr = IPRIP_IF_ADDRESS_TABLE(pite->ITE_Binding) + pwc->IC_AddrIndex;
        pPacket = pwc->IC_InputPacket.IP_Packet;
        pih = (PIPRIP_HEADER)pPacket;
        pie = (PIPRIP_ENTRY)(pPacket + sizeof(IPRIP_HEADER));
        pae = (PIPRIP_AUTHENT_ENTRY)pie;


        //
        // make sure our configuration allows us to handle this packet
        //

        if ((pih->IH_Version != 2 &&
             pic->IC_AcceptMode == IPRIP_ACCEPT_RIP2)) {

            CHAR szVersion[10];
            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);

            InterlockedIncrement(&pis->IS_BadResponsePacketsReceived);
            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }

            if (lpszAddr != NULL) {
                TRACE2(
                    RESPONSE, "dropping non-v2 packet on RIPv2 interface %d (%s)",
                    pite->ITE_Index, lpszAddr
                    );
                wsprintf(szVersion, "%d", pih->IH_Version);
                LOGWARN4(
                    PACKET_VERSION_MISMATCH, szVersion, lpszAddr, szSource, "2", 0
                    );
            }
            
            break;
        }
        else
        if ((pih->IH_Version != 1 &&
             pic->IC_AcceptMode == IPRIP_ACCEPT_RIP1)) {

            CHAR szVersion[10];
            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);

            InterlockedIncrement(&pis->IS_BadResponsePacketsReceived);
            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }

            if (lpszAddr != NULL) {
                TRACE2(
                    RESPONSE, "dropping RIPv2 packet on RIPv1 interface %d (%s)",
                    pite->ITE_Index, lpszAddr
                    );
                wsprintf(szVersion, "%d", pih->IH_Version);
                LOGWARN4(
                    PACKET_VERSION_MISMATCH, szVersion, lpszAddr, szSource, "1", 0
                    );
            }
            break;
        }



        //
        // version 2 packets call for authentication processing;
        //

        if (pih->IH_Version == 2) {

            DWORD dwErr;

            dwErr = AuthenticatePacket(pPacket, pae, pic, pis, pps, &pie);

            if (dwErr == ERROR_ACCESS_DENIED) {

                LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        RESPONSE, "dropping packet from %s on interface %d (%s): authentication failed",
                        szSource, pite->ITE_Index, lpszAddr
                        );
                    LOGWARN2(AUTHENTICATION_FAILED, lpszAddr, szSource, NO_ERROR);
                }
                break;
            }
        }



        //
        // need to lock the binding table since GuessSubnetMask will be called
        // inside ProcessResponseEntry
        // need to lock the global config since EnqueueSendEntry will be called
        // inside ProcessResponseEntry
        //

        ACQUIRE_BINDING_LOCK_SHARED();

        ACQUIRE_GLOBAL_LOCK_SHARED();


        //
        // process each entry; reserved fields must be checked for non-RIPv2
        //


        piend = (PIPRIP_ENTRY)(pPacket + pwc->IC_InputLength);

        if (pih->IH_Version == 1) {

            for ( ; pie < piend; pie++) {

                //
                // validate the route entry fields
                //

                if (pie->IE_AddrFamily != htons(AF_INET) ||
                    pie->IE_RouteTag != 0 || pie->IE_SubnetMask != 0 ||
                    pie->IE_Nexthop != 0) {

                    LPSTR lpszAddr;


                    //
                    // update stats on ignored entries
                    //

                    InterlockedIncrement(&pis->IS_BadResponseEntriesReceived);
                    if (pps != NULL) {
                        InterlockedIncrement(
                            &pps->PS_BadResponseEntriesFromPeer
                            );
                    }

                    lpszAddr = INET_NTOA(pie->IE_Destination);
                    if (lpszAddr != NULL) {
                        lstrcpy(szNetwork, lpszAddr);
                        lpszAddr = INET_NTOA(paddr->IA_Address);

                        if (lpszAddr != NULL) {
                            LOGINFO3(
                                ROUTE_ENTRY_IGNORED, lpszAddr, szNetwork, szSource, 0
                                );
                        }
                    }
                    continue;
                }


                //
                // entry is alright, process it
                //

                if (ProcessResponseEntry(
                        pite, pwc->IC_AddrIndex, dwSource, pie, pps
                        )) {
                    bTriggerUpdate = TRUE;
                }
            }
        }
        else
        if (pih->IH_Version == 2) {

            //
            // this is a RIPv2 packet, so the reserved fields in entries
            // may optionally contain information about the route;
            //


            for ( ; pie < piend; pie++) {


                //
                // validate the route entry fields
                //

                if (pie->IE_AddrFamily != htons(AF_INET)) {

                    LPSTR lpszAddr;


                    //
                    // update stats on ignored entries
                    //

                    InterlockedIncrement(&pis->IS_BadResponseEntriesReceived);
                    if (pps != NULL) {
                        InterlockedIncrement(
                            &pps->PS_BadResponseEntriesFromPeer
                            );
                    }

                    lpszAddr = INET_NTOA(pie->IE_Destination);
                    if (lpszAddr != NULL) {
                        lstrcpy(szNetwork, lpszAddr);
                        lpszAddr = INET_NTOA(paddr->IA_Address);

                        if (lpszAddr != NULL) {
                            LOGINFO3(
                                ROUTE_ENTRY_IGNORED, lpszAddr, szNetwork, szSource, 0
                                );
                        }
                    }

                    continue;
                }


                //
                // entry is alright, process it
                //

                if (ProcessResponseEntry(
                        pite, pwc->IC_AddrIndex, dwSource, pie, pps
                        )) {
                    bTriggerUpdate = TRUE;
                }
            }
        }
        else {

            //
            // this packet's version is greater than 2, so we ignore
            // the contents of the reserved fields
            //


            for ( ; pie < piend; pie++) {


                //
                // validate the route entry fields
                //

                if (pie->IE_AddrFamily != htons(AF_INET)) {

                    LPSTR lpszAddr;


                    //
                    // update stats on ignored entries
                    //

                    InterlockedIncrement(&pis->IS_BadResponseEntriesReceived);
                    if (pps != NULL) {
                        InterlockedIncrement(
                            &pps->PS_BadResponseEntriesFromPeer
                            );
                    }

                    lpszAddr = INET_NTOA(pie->IE_Destination);
                    if (lpszAddr != NULL) {
                        lstrcpy(szNetwork, lpszAddr);
                        lpszAddr = INET_NTOA(paddr->IA_Address);

                        if (lpszAddr != NULL) {
                            LOGINFO3(
                                ROUTE_ENTRY_IGNORED, lpszAddr, szNetwork, szSource, 0
                                );
                        }
                    }

                    continue;
                }


                //
                // entry is alright, clear reserved fields and process
                //

                pie->IE_Nexthop = 0;
                pie->IE_RouteTag = 0;
                pie->IE_SubnetMask = 0;

                if (ProcessResponseEntry(
                        pite, pwc->IC_AddrIndex, dwSource, pie, pps
                        )) {
                    bTriggerUpdate = TRUE;
                }
            }
        }

        RELEASE_GLOBAL_LOCK_SHARED();

        RELEASE_BINDING_LOCK_SHARED();


        //
        // generate a triggered update if necessary
        //

        if (bTriggerUpdate) {
            QueueRipWorker(WorkerFunctionStartTriggeredUpdate, NULL);
        }

    } while(FALSE);


    RELEASE_IF_LOCK_SHARED();


    RIP_FREE(pContext);


    TRACE0(LEAVE, "leaving ProcessResponse");
}




//----------------------------------------------------------------------------
// Function:    ProcessResponseEntry
//
// this function processes the given response packet entry, received
// on the given interface from the given source.
// If a triggered update is necessary, this function returns TRUE.
//----------------------------------------------------------------------------

BOOL
ProcessResponseEntry(
    PIF_TABLE_ENTRY pITE,
    DWORD dwAddrIndex,
    DWORD dwSource,
    PIPRIP_ENTRY pIE,
    PIPRIP_PEER_STATS pPS
    ) {

    IP_NETWORK in;
    PIPRIP_IF_STATS pis;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IP_ADDRESS paddr;
    CHAR szSource[32];
    CHAR szNetmask[32];
    CHAR szNexthop[32];
    CHAR szNetwork[32];
    BOOL bRouteExists, bRelRoute = FALSE;
    RIP_IP_ROUTE route;
    DWORD dwNetclassMask, dwNexthop, dwRipMetric;
    DWORD dwErr, dwFlags, dwFound, dwNetwork, dwNetmask;
    LPSTR lpszAddr;

    RTM_NET_ADDRESS rna;
    PRTM_ROUTE_INFO prri = NULL;
    RTM_ROUTE_HANDLE hRtmRoute;

    

//    TRACE0(ENTER, "entering ProcessResponseEntry");


    pis = &pITE->ITE_Stats;
    pic = pITE->ITE_Config;
    paddr = IPRIP_IF_ADDRESS_TABLE(pITE->ITE_Binding) + dwAddrIndex;


    //
    // read destination and figure out subnet mask
    // if mask is not given in the packet
    //

    dwNetwork = pIE->IE_Destination;
    if (pIE->IE_SubnetMask == 0) {

        dwNetmask = GuessSubnetMask(dwNetwork, &dwNetclassMask);
    }
    else {

        //
        // double-check the netclass mask, to accomodate supernets
        //

        dwNetmask = pIE->IE_SubnetMask;
        dwNetclassMask = NETCLASS_MASK(dwNetwork);

        if (dwNetclassMask > dwNetmask) {
            dwNetclassMask = dwNetmask;
        }
    }

#if 1
    dwNexthop = dwSource;
#else
    // BUG 205349: using the nexthop field results in flapping
    // when more than two routers are on the same network.
    // The full fix is to distinguish between the source of the route
    // and the nexthop of the route.
    //
    // read the next-hop field;
    // if it is zero or it is not on the same subnet
    // as the receiving interface, ignore it and use the address
    // of the source as the next-hop.
    // otherwise, use the address specified in the packet
    // as the next-hop.
    //

    if (!pIE->IE_Nexthop ||
        (pIE->IE_Nexthop & paddr->IA_Netmask) !=
        (paddr->IA_Address & paddr->IA_Netmask)) { dwNexthop = dwSource; }
    else { dwNexthop = pIE->IE_Nexthop; }
#endif


    //
    // set up variables used for error and information messages
    //

    lpszAddr = INET_NTOA(dwSource);
    if (lpszAddr != NULL) { lstrcpy(szSource, lpszAddr);}
    else { ZeroMemory(szSource, sizeof(szSource)); }
    
    lpszAddr = INET_NTOA(dwNetwork);
    if (lpszAddr != NULL) { lstrcpy(szNetwork, lpszAddr);}
    else { ZeroMemory(szSource, sizeof(szSource)); }

    lpszAddr = INET_NTOA(dwNetmask);
    if (lpszAddr != NULL) { lstrcpy(szNetmask, lpszAddr);}
    else { ZeroMemory(szSource, sizeof(szSource)); }

    lpszAddr = INET_NTOA(dwNexthop);
    if (lpszAddr != NULL) { lstrcpy(szNexthop, lpszAddr);}
    else { ZeroMemory(szSource, sizeof(szSource)); }

    if (pPS != NULL) {
        InterlockedExchange(
            &pPS->PS_LastPeerRouteTag, (DWORD)ntohs(pIE->IE_RouteTag)
            );
    }


    do { // breakout loop


        //
        // make sure metric is in rational range
        //

        dwRipMetric = ntohl(pIE->IE_Metric);
        if (dwRipMetric > IPRIP_INFINITE) {

            TRACE4(
                RESPONSE,
                "metric == %d, ignoring route to %s via %s advertised by %s",
                dwRipMetric, szNetwork, szNexthop, szSource
                );
            LOGWARN3(
                ROUTE_METRIC_INVALID,szNetwork, szNexthop, szSource, dwRipMetric
                );

            break;
        }


        //
        // make sure route is to valid address type
        //

        if (CLASSD_ADDR(dwNetwork) || CLASSE_ADDR(dwNetwork)) {

            TRACE3(
                RESPONSE,
                "invalid class, ignoring route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
                );
            LOGINFO3(
                ROUTE_CLASS_INVALID, szNetwork, szNexthop, szSource, NO_ERROR
                );

            break;
        }


        //
        // make sure route is not to loopback address
        //

        if (IS_LOOPBACK_ADDR(dwNetwork)) {

            TRACE3(
                RESPONSE,
                "ignoring loopback route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
                );
            LOGWARN3(
                LOOPBACK_ROUTE_INVALID, szNetwork, szNexthop, szSource, NO_ERROR
                );

            break;
        }


        //
        // make sure route it is not a broadcast route
        // The first condition uses the netmask information received in the
        // advertisement
        // The second condition uses the netmask which is computed based 
        // on the address class
        // The third condition checks for the all 1's broadcast
        //

        if ( IS_DIRECTED_BROADCAST_ADDR(dwNetwork, dwNetmask) ||
             IS_DIRECTED_BROADCAST_ADDR(dwNetwork, dwNetclassMask) ||
             IS_LOCAL_BROADCAST_ADDR(dwNetwork) ) {

            TRACE3(
                RESPONSE,
                "ignoring broadcast route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
                );
            LOGWARN3(
                BROADCAST_ROUTE_INVALID, szNetwork, szNexthop, szSource, 0
                );

            break;
        }


        //
        // discard host routes if the receiving interface
        // is not configured to accept host routes
        //

        //
        // At this stage the broadcast routes have already been weeded out.
        // So it is safe to assume that 
        // if Network address width is greater than the Netmask address 
        // width, then it is a host route.
        // Or, 
        // if the dwNetmask is 255.255.255.255 then it is a host route.
        //
        if ( ((dwNetwork & ~dwNetmask) != 0) || (dwNetmask == HOSTADDR_MASK) ) {

            //
            // This is a host-route; see whether we can accept it.
            //

            if (IPRIP_FLAG_IS_ENABLED(pic, ACCEPT_HOST_ROUTES)) {

                //
                // The host route can be accepted.
                // Set the mask to all-ones to ensure that
                // the route can be added to the stack.
                //

                dwNetmask = HOSTADDR_MASK;
            }
            else {

                //
                // The host-route must be rejected.
                //

                TRACE3(
                    RESPONSE,
                    "ignoring host route to %s via %s advertised by %s",
                    szNetwork, szNexthop, szSource
                    );
                LOGINFO3(
                    HOST_ROUTE_INVALID, szNetwork, szNexthop, szSource, NO_ERROR
                    );

                break;
            }
        }


        //
        // discard default routes if the receiving interface
        // is not configured to accept default routes
        //

        if (dwNetwork == 0 &&
            IPRIP_FLAG_IS_DISABLED(pic, ACCEPT_DEFAULT_ROUTES)) {

            TRACE3(
                RESPONSE,
                "ignoring default route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
                );
            LOGINFO3(
                DEFAULT_ROUTE_INVALID, szNetwork, szNexthop, szSource, NO_ERROR
                );

            break;
        }


        //
        // put the route through the accept filters
        //

        if (pic->IC_AcceptFilterMode != IPRIP_FILTER_DISABLED) {

            //
            // discard the route if the receiving interface is including
            // all routes but this route is listed as an exception, or if
            // the receiving interface is excluding all routes and this
            // route is not listed as an exception
            //

            IS_ROUTE_IN_ACCEPT_FILTER(pic, dwNetwork, dwFound);

            if ((pic->IC_AcceptFilterMode == IPRIP_FILTER_INCLUDE && !dwFound)||
                (pic->IC_AcceptFilterMode == IPRIP_FILTER_EXCLUDE && dwFound)) {

                TRACE3(
                    RESPONSE,
                    "ignoring filtered route to %s via %s advertised by %s",
                    szNetwork, szNexthop, szSource
                    );
                LOGINFO3(
                    ROUTE_FILTERED, szNetwork, szNexthop, szSource, NO_ERROR
                    );

                break;
            }
        }


        //
        // see if the route already exists in RTM's table
        //

        in.N_NetNumber = dwNetwork;
        in.N_NetMask = dwNetmask;
        RTM_IPV4_SET_ADDR_AND_MASK( &rna, dwNetwork, dwNetmask );

        prri = RIP_ALLOC( RTM_SIZE_OF_ROUTE_INFO( 
                            ig.IG_RtmProfile.MaxNextHopsInRoute
                            ) );

        if ( prri == NULL ) {
        
            dwErr = GetLastError();

            TRACE2(
                ANY, "ProcessResponseEntry: error %d while allocating %d bytes",
                dwErr, 
                RTM_SIZE_OF_ROUTE_INFO(ig.IG_RtmProfile.MaxNextHopsInRoute) 
                );

            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }
        
        prri-> RouteOwner = ig.IG_RtmHandle;
        
        dwErr = RtmGetExactMatchRoute(
                    ig.IG_RtmHandle, &rna, RTM_MATCH_OWNER, prri, 0,
                    RTM_VIEW_MASK_ANY, &hRtmRoute
                    );

        if ((dwErr != NO_ERROR) || (hRtmRoute == NULL)) {
            bRouteExists = FALSE;
        }

        else{
            bRelRoute = TRUE;
            
            dwErr = GetRouteInfo(
                        hRtmRoute, prri, NULL, &route
                        );
                        
            if (dwErr != NO_ERROR) {
                bRouteExists = FALSE;
                break;
            }

            else {
                bRouteExists = TRUE;
            }
        }


        //
        // add the cost of this interface to the metric
        //

        dwRipMetric = min(IPRIP_INFINITE, dwRipMetric + pic->IC_Metric);
        if (dwRipMetric >= IPRIP_INFINITE && !bRouteExists) {

            TRACE4(
                RESPONSE,
                "metric==%d, ignoring route to %s via %s advertised by %s",
                IPRIP_INFINITE, szNetwork, szNexthop, szSource
                );

            break;
        }


        //
        // ROUTE ADDITION/UPDATE/REMOVAL:
        //

        if (!bRouteExists) {

            //
            // NEW ROUTE:
            //
            // set up struct to pass to RTM
            //

            ZeroMemory(&route, sizeof(route));
            route.RR_RoutingProtocol = PROTO_IP_RIP;
            route.RR_Network = in;
            SETROUTEMETRIC(&route, dwRipMetric);
            route.RR_InterfaceID = pITE->ITE_Index;
            route.RR_NextHopAddress.N_NetNumber = dwNexthop;
            route.RR_NextHopAddress.N_NetMask = paddr->IA_Netmask;
            SETROUTETAG(&route, ntohs(pIE->IE_RouteTag));


            //
            // add route to RTM
            //

            COMPUTE_ROUTE_METRIC(&route);
#if ROUTE_DBG
            TRACE3(
                RESPONSE,
                "Adding route to %s via %s advertised by %s",
                szNetwork, szNexthop, szSource
            );
#endif

            dwErr = AddRtmRoute(
                        ig.IG_RtmHandle, &route, NULL,
                        pic->IC_RouteExpirationInterval, 
                        pic->IC_RouteRemovalInterval,
                        TRUE
                        );
            if (dwErr != NO_ERROR) {

                TRACE4(
                    RESPONSE,
                    "error %d adding route to %s via %s advertised by %s",
                    dwErr, szNetwork, szNexthop, szSource
                    );
                LOGINFO3(
                    ADD_ROUTE_FAILED_2, szNetwork, szNexthop, szSource, dwErr
                    );

                break;
            }

            InterlockedIncrement(&ig.IG_Stats.GS_SystemRouteChanges);
            LOGINFO3(
                NEW_ROUTE_LEARNT_1, szNetwork, szNexthop, szSource, NO_ERROR
                );
        }
        else {

            DWORD dwTimer = 0, dwChangeFlags = 0;
            BOOL bTriggerUpdate = FALSE, bActive = TRUE;


            //
            // EXISTING ROUTE:
            //
            // reset time-to-live, and mark route as expiring,
            // if this advertisement is from the same source
            // as the existing route, and the existing route's metric
            // is not already INFINITE; thus, if a route has been
            // advertised as unreachable, we don't reset its time-to-live
            // just because we hear an advertisement for the route
            //

            if (dwNexthop == route.RR_NextHopAddress.N_NetNumber &&
                GETROUTEMETRIC(&route) != IPRIP_INFINITE) {

                dwTimer = pic->IC_RouteExpirationInterval;

                //
                // if existing route was a summary route, make sure
                // set the validity flag before you mark it as a
                // non summary route. Fix for bug #81544
                //

                if ( GETROUTEFLAG( &route ) == ROUTEFLAG_SUMMARY ) {

                    CHAR szRouteNetwork[20], szRouteNetmask[20];
                    LPSTR lpszAddrTemp = INET_NTOA(route.RR_Network.N_NetNumber);

                    if (lpszAddrTemp != NULL) {
                        lstrcpy(szRouteNetwork, lpszAddrTemp);

                        lpszAddrTemp = INET_NTOA(route.RR_Network.N_NetMask);
                        if (lpszAddrTemp != NULL) {
                            lstrcpy(szRouteNetmask, lpszAddrTemp);

                            TRACE2(
                                RESPONSE,
                                "%s %s summary route to valid route",
                                szRouteNetwork, szRouteNetmask
                            );
                        }
                    }
                    
                    SETROUTEFLAG( &route, ~ROUTEFLAG_SUMMARY );
                }
            }


            //
            // we only need to do further processing if
            // (a) the advertised route is from the same source as
            //      the existing route and the metrics are different, or
            // (b) the advertised route has a better metric
            //

            if ((dwNexthop == route.RR_NextHopAddress.N_NetNumber &&
                 dwRipMetric != GETROUTEMETRIC(&route)) ||
                (dwRipMetric < GETROUTEMETRIC(&route))) {


                //
                // if the next-hop's differ, adopt the new next-hop
                //

                if (dwNexthop != route.RR_NextHopAddress.N_NetNumber) {

                    route.RR_NextHopAddress.N_NetNumber = dwNexthop;
                    route.RR_NextHopAddress.N_NetMask = paddr->IA_Netmask;

                    InterlockedIncrement(&ig.IG_Stats.GS_SystemRouteChanges);
                    LOGINFO2(
                        ROUTE_NEXTHOP_CHANGED, szNetwork, szNexthop, NO_ERROR
                        );
                }
                else {

                    CHAR szMetric[12];

                    wsprintf(szMetric, "%d", dwRipMetric);
                    LOGINFO3(
                        ROUTE_METRIC_CHANGED, szNetwork, szNexthop, szMetric, 0
                        );
                }


                //
                // check the metric to decide the new time-to-live
                //

                if (dwRipMetric == IPRIP_INFINITE) {

                    //
                    // Delete the route
                    //

#if ROUTE_DBG
                    TRACE2(
                        ROUTE, "Deleting route to %s:%s", szNetwork, szNetmask
                        );
#endif

                    dwTimer = 0;
                    
                    dwErr = RtmReferenceHandles(
                                ig.IG_RtmHandle, 1, &hRtmRoute
                                );

                    if (dwErr != NO_ERROR) {
                        TRACE3(
                            ANY, "error %d referencing route to %s:%s", dwErr,
                            szNetwork, szNetmask
                            );

                        break;
                    }
                    
                    dwErr = RtmDeleteRouteToDest(
                                ig.IG_RtmHandle, hRtmRoute,
                                &dwChangeFlags
                                );

                    if (dwErr != NO_ERROR) {
                        TRACE3(
                            ANY, "error %d deleting route to %s:%s", dwErr,
                            szNetwork, szNetmask
                            );
                    }

                    break;
                }
                
                else {

                    //
                    // set the expiration flag and use the expiration TTL
                    //

                    dwTimer = pic->IC_RouteExpirationInterval;
                }


                //
                // use the advertised metric, and set the interface ID,
                // adapter index, and route tag
                //

                SETROUTEMETRIC(&route, dwRipMetric);
                route.RR_InterfaceID = pITE->ITE_Index;
//                route.RR_FamilySpecificData.FSD_AdapterIndex =
//                                            pITE->ITE_Binding.AdapterIndex;
                SETROUTETAG(&route, ntohs(pIE->IE_RouteTag));


                //
                // always require a triggered update if we reach here
                //

                bTriggerUpdate = TRUE;
            }

            if (dwTimer != 0) {

                COMPUTE_ROUTE_METRIC(&route);

#if ROUTE_DBG

                TRACE4(
                    RESPONSE,
                    "Editing route to %s via %s advertised by %s, metric %d",
                    szNetwork, szNexthop, szSource, dwRipMetric
                );
#endif

                dwErr = AddRtmRoute(
                            ig.IG_RtmHandle, &route, NULL, dwTimer, 
                            pic-> IC_RouteRemovalInterval, TRUE
                            );

                if (dwErr != NO_ERROR) {

                    TRACE4(
                        RESPONSE,
                        "error %d adding route to %s via %s advertised by %s",
                        dwErr, szNetwork, szNexthop, szSource
                        );
                    LOGINFO3(
                        ADD_ROUTE_FAILED_2,szNetwork,szNexthop,szSource, dwErr
                        );
                }
            }
        }

    } while(FALSE);


    //
    // if some sort of error occured, increment stats appropriately
    //

    if (dwErr != NO_ERROR ) {
        InterlockedIncrement(&pis->IS_BadResponseEntriesReceived);
        if (pPS != NULL) {
            InterlockedIncrement(&pPS->PS_BadResponseEntriesFromPeer);
        }
    }


    //
    // Release the dest info structure
    //

    if (bRelRoute) {

        dwErr = RtmReleaseRouteInfo(ig.IG_RtmHandle, prri);
        if (dwErr != NO_ERROR) {
            TRACE2(
                ANY, "error %d releasing dest %s", dwErr, szNetwork
                );
        }
    }

    if ( prri ) {
        RIP_FREE(prri);
    }

    //
    // always return FALSE.  This way no RIP route add/delete/operations
    // will set of the triggered update mechanism.  This mech. is set of
    // by route change notifications recevied from RTMv2
    //
    
    return FALSE;
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionStartFullUpdate
//
// this function initiates a full-update. It checks to see if a full-update
// is already pending, and if not, it sets the full-update-pending flag and
// schedules the full-update work item. Then it sets a flag on its interface
// indicating a full-update should be generated on the interface.
//----------------------------------------------------------------------------

VOID
WorkerFunctionStartFullUpdate(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    DWORD dwIndex;
    PIF_TABLE pTable;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;


    if (!ENTER_RIP_API()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionStartFullUpdate");



    pTable = ig.IG_IfTable;


    ACQUIRE_IF_LOCK_SHARED();

    EnterCriticalSection(&pTable->IT_CS);


    do { // breakout loop


        //
        // retrieve the interface on which the full-update will be sent
        //

        dwIndex = PtrToUlong(pContext);

        pite = GetIfByIndex(pTable, dwIndex);
        if (pite == NULL) {

            TRACE1(
                SEND, "starting full-update: interface %d not found", dwIndex
                );

            break;
        }



        //
        // if the interface is no longer active, do nothing
        //

        if (IF_IS_INACTIVE(pite)) {

            pite->ITE_Flags &= ~ITEFLAG_FULL_UPDATE_INQUEUE;

            break;
        }



        //
        // do nothing if a full-update is already pending
        //

        if (IF_FULL_UPDATE_PENDING(pite)) { break; }


        //
        // only do full-updates on periodic-update interfaces
        // and don't do full-updates on interfaces configured to be silent;
        //

        if (pite->ITE_Config->IC_UpdateMode != IPRIP_UPDATE_PERIODIC ||
            pite->ITE_Config->IC_AnnounceMode == IPRIP_ANNOUNCE_DISABLED) {

            pite->ITE_Flags &= ~ITEFLAG_FULL_UPDATE_INQUEUE;

            break;
        }


        //
        // set the full update flags on the interface;
        //

        pite->ITE_Flags |= ITEFLAG_FULL_UPDATE_PENDING;



        //
        // if there is no full-update pending,
        // queue the full-update finishing function
        //

        if (!IPRIP_FULL_UPDATE_PENDING(pTable)) {

            DWORD dwRand;
            
            //
            // set the global full-update-pending flag
            //

            pTable->IT_Flags |= IPRIP_FLAG_FULL_UPDATE_PENDING;


            //
            // we need a random interval between 1 and 5 seconds
            //

            dwRand = GetTickCount();
            dwRand = RtlRandom(&dwRand);
            dwRand = 1000 + (DWORD)((double)dwRand / MAXLONG * (4.0 * 1000));

            //
            // Schedule a full update
            //

            if (!ChangeTimerQueueTimer(
                    ig.IG_TimerQueueHandle, pTable->IT_FinishFullUpdateTimer,
                    dwRand, 10000000)) {

                TRACE1(
                    SEND, "error %d setting finish full update timer",
                    GetLastError()
                    );
            }
        }

    } while(FALSE);

    LeaveCriticalSection(&pTable->IT_CS);

    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionStartFullUpdate");

    LEAVE_RIP_API();
}


//----------------------------------------------------------------------------
// Function:    EnqueueStartFullUpdate
//
// This function is called to enqueue the next start-full-update event
// for the given interface. The interface's state is updated as necessary.
// It assumes that the following locks have been acquired:
//  IT_RWL - shared
//  IT_CS - exclusive
//  TimerQueue lock - exclusive
//----------------------------------------------------------------------------

VOID
EnqueueStartFullUpdate(
    PIF_TABLE_ENTRY pite,
    LARGE_INTEGER qwLastFullUpdateTime
    ) {

    //
    // set last-full-update time
    //


    if (!ChangeTimerQueueTimer(
            ig.IG_TimerQueueHandle, pite->ITE_FullOrDemandUpdateTimer,
            RipSecsToMilliSecs(pite->ITE_Config->IC_FullUpdateInterval),
            10000000
            )) {

        TRACE1(
            SEND, "error %d updating start full update timer", 
            GetLastError()
            );
    
        pite->ITE_Flags &= ~ITEFLAG_FULL_UPDATE_INQUEUE;
    }
}


//----------------------------------------------------------------------------
// Function:    WorkerFunctionFinishFullUpdate
//
// This function sends a full-update on every interface which has the
// full-update pending flag set, and schedules the next full-update on each
// interface.
//----------------------------------------------------------------------------

VOID
WorkerFunctionFinishFullUpdate(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    PIF_TABLE pTable;
    PIPRIP_IF_CONFIG pic;
    PLIST_ENTRY ple, phead;
    DWORD dwErr, dwIndex, dwIfCount;
    LARGE_INTEGER qwCurrentTime;
    PIF_TABLE_ENTRY pite, *ppite, *ppitend, *pIfList;

    if (!ENTER_RIP_API()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionFinishFullUpdate");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();

    EnterCriticalSection(&pTable->IT_CS);


    pIfList = NULL;

    ppite = NULL;

    do {

        //
        // first count how many there are
        //

        dwIfCount = 0;
        phead = &pTable->IT_ListByAddress;
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            if (IF_IS_ACTIVE(pite) && IF_FULL_UPDATE_PENDING(pite)) {

                pic = pite->ITE_Config;

                if (pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                    pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {
                    ++dwIfCount;
                }
            }
        }


        if (dwIfCount == 0) {

            TRACE0(SEND, "finishing full-update: no interfaces");
            break;
        }


        //
        // then make memory for the interface pointers
        //

        pIfList = RIP_ALLOC(dwIfCount * sizeof(PIF_TABLE_ENTRY));

        if (pIfList == NULL) {

            dwErr = GetLastError();
            TRACE2(
                SEND, "error code %d allocating %d bytes for interface list",
                dwErr, dwIfCount * sizeof(PIF_TABLE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);
            //
            // enqueue the next full-update for each interface
            //
            RipQuerySystemTime(&qwCurrentTime);
            pTable->IT_LastUpdateTime = qwCurrentTime;
            for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
                pite=CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);
                if (IF_IS_ACTIVE(pite) && IF_FULL_UPDATE_PENDING(pite)) {
                    pic = pite->ITE_Config;
                    if (pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                        pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {
                        EnqueueStartFullUpdate(pite, qwCurrentTime);
                    }
                }
            }
            break;
        }


        //
        // and copy the interface pointers to the memory allocated
        //

        ppitend = pIfList + dwIfCount;
        for (ple = phead->Flink, ppite = pIfList;
             ple != phead && ppite < ppitend; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            if (IF_IS_ACTIVE(pite) && IF_FULL_UPDATE_PENDING(pite)) {

                pic = pite->ITE_Config;

                if (pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                    pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {
                    *ppite++ = pite;
                }
            }
        }



        //
        // send the updates
        //

        TRACE1(SEND, "sending full-updates on %d interfaces", dwIfCount);

        SendRoutes(pIfList, dwIfCount, SENDMODE_FULL_UPDATE, 0, 0);



        //
        // enqueue the next full-update for each interface
        //

        RipQuerySystemTime(&qwCurrentTime);
        pTable->IT_LastUpdateTime = qwCurrentTime;
        for (ppite = pIfList; ppite < ppitend; ppite++) {
            EnqueueStartFullUpdate(*ppite, qwCurrentTime);
        }


        //
        // free the memory allocated for the interface pointers
        //

        RIP_FREE(pIfList);

    } while(FALSE);


    //
    // clear the full-update pending flags
    //

    phead = &pTable->IT_ListByAddress;
    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

        pite->ITE_Flags &= ~ITEFLAG_FULL_UPDATE_PENDING;
    }

    pTable->IT_Flags &= ~IPRIP_FLAG_FULL_UPDATE_PENDING;

    LeaveCriticalSection(&pTable->IT_CS);

    RELEASE_IF_LOCK_SHARED();



    TRACE0(LEAVE, "leaving WorkerFunctionFinishFullUpdate");

    LEAVE_RIP_API();

}



//----------------------------------------------------------------------------
// Function:    FinishTriggeredUpdate
//
// This function is responsible for sending out a triggered update
// on all interfaces which have triggered updates enabled.
// No triggered updates are sent on interfaces which already have
// a full-update pending.
// Assumes interface table is locked for reading or writing,
// and update-lock (IT_CS) is held.
//----------------------------------------------------------------------------

VOID
FinishTriggeredUpdate(
    ) {

    PIF_TABLE pTable;
    PIPRIP_IF_STATS pis;
    DWORD dwErr, dwIfCount;
    PIPRIP_IF_CONFIG pic = NULL;
    PLIST_ENTRY ple, phead;
    LARGE_INTEGER qwCurrentTime;
    PIF_TABLE_ENTRY pite, *ppite, *ppitend, *pIfList;



    pTable = ig.IG_IfTable;

    //
    // we lock the send queue now so that no routes are added
    // until the existing ones are transmitted
    //

    ACQUIRE_LIST_LOCK(ig.IG_SendQueue);


    do { // breakout loop


        //
        // count the interfaces on which the triggered update will be sent
        //

        dwIfCount = 0;
        phead = &pTable->IT_ListByAddress;


        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            pic = pite->ITE_Config;

            if (IF_IS_ACTIVE(pite) && !IF_FULL_UPDATE_PENDING(pite) &&
                pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
                IPRIP_FLAG_IS_ENABLED(pic, TRIGGERED_UPDATES)) {

                ++dwIfCount;
            }
        }


        if (dwIfCount == 0) {
            TRACE0(SEND, "finishing triggered-update: no interfaces");
            break;
        }


        //
        // allocate memory to hold the interface pointers
        //

        pIfList = RIP_ALLOC(dwIfCount * sizeof(PIF_TABLE_ENTRY));
        if (pIfList == NULL) {

            dwErr = GetLastError();
            TRACE2(
                SEND, "error code %d allocating %d bytes for interface list",
                dwErr, dwIfCount * sizeof(PIF_TABLE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }



        //
        // copy the interface pointers to the allocated memory
        //

        ppitend = pIfList + dwIfCount;
        for (ple = phead->Flink, ppite = pIfList;
             ple != phead && ppite < ppitend; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            pic = pite->ITE_Config;

            if (IF_IS_ACTIVE(pite) && !IF_FULL_UPDATE_PENDING(pite) &&
                pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
                IPRIP_FLAG_IS_ENABLED(pic, TRIGGERED_UPDATES)) {

                *ppite++ = pite;
            }
        }


        //
        // send the triggered-update routes
        //

        TRACE1(SEND, "sending triggered-updates on %d interfaces", dwIfCount);

        SendRoutes(pIfList, dwIfCount, SENDMODE_TRIGGERED_UPDATE, 0, 0);



        //
        // update the statistics for each interface
        //

        for (ppite = pIfList; ppite < ppitend; ppite++) {
            pis = &(*ppite)->ITE_Stats;
            InterlockedIncrement(&pis->IS_TriggeredUpdatesSent);
        }


        //
        // update the last time at which an update was sent
        //

        RipQuerySystemTime(&pTable->IT_LastUpdateTime);


        //
        // free the memory allocated for the interfaces
        //

        RIP_FREE(pIfList);

    } while (FALSE);


    //
    // make sure send-queue is empty
    //

    FlushSendQueue(ig.IG_SendQueue);

    RELEASE_LIST_LOCK(ig.IG_SendQueue);

    pTable->IT_Flags &= ~IPRIP_FLAG_TRIGGERED_UPDATE_PENDING;

    return;
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionStartTriggeredUpdate
//
// This function checks to see if the minimum interval between triggered
// updates has elapsed, and if so, sends a triggered update. Otherwise,
// it schedules the triggered update to be sent, and sets flags to indicate
// that a triggered update is pending
//----------------------------------------------------------------------------

VOID
WorkerFunctionStartTriggeredUpdate(
    PVOID pContext
    ) {

    PIF_TABLE pTable;
    LARGE_INTEGER qwCurrentTime, qwSoonestTriggerTime;

    if (!ENTER_RIP_WORKER()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionStartTriggeredUpdate");



    pTable = ig.IG_IfTable;


    ACQUIRE_IF_LOCK_SHARED();

    EnterCriticalSection(&pTable->IT_CS);



    //
    // if triggered update is not pending, queue a triggered update
    //

    if (!IPRIP_TRIGGERED_UPDATE_PENDING(pTable)) {


        //
        // figure out when is the soonest time a triggered update
        // can be sent, based on the configured minimum interval
        // between triggered updates (in seconds) and the last time
        // a triggered update was generated (in 100-nanosecond units)
        //

        ACQUIRE_GLOBAL_LOCK_SHARED();

        qwSoonestTriggerTime.HighPart = 0;
        qwSoonestTriggerTime.LowPart =
                        ig.IG_Config->GC_MinTriggeredUpdateInterval;
        RipSecsToSystemTime(&qwSoonestTriggerTime);

        RELEASE_GLOBAL_LOCK_SHARED();


        qwSoonestTriggerTime = RtlLargeIntegerAdd(
                                    qwSoonestTriggerTime,
                                    pTable->IT_LastUpdateTime
                                    );

        RipQuerySystemTime(&qwCurrentTime);


        //
        // figure out if clock has been set backward, by comparing
        // the current time against the last update time
        //

        if (RtlLargeIntegerLessThan(
                qwCurrentTime, pTable->IT_LastUpdateTime
                )) {

            //
            // Send triggered update anyway, since there is no way
            // to figure out the if minimum time between updates has
            // elapsed
            //

            FinishTriggeredUpdate();
        }

        else if (RtlLargeIntegerLessThan(qwCurrentTime, qwSoonestTriggerTime)) {

            //
            // must defer the triggered update
            //
            qwSoonestTriggerTime = RtlLargeIntegerSubtract(
                                        qwSoonestTriggerTime, qwCurrentTime
                                        );

            RipSystemTimeToMillisecs(&qwSoonestTriggerTime);

            if (!ChangeTimerQueueTimer(
                    ig.IG_TimerQueueHandle,
                    pTable->IT_FinishTriggeredUpdateTimer,
                    qwSoonestTriggerTime.LowPart, 10000000
                    )) {

                TRACE1(
                    SEND, "error %d updating finish update timer",
                    GetLastError()
                    );
            }

            else {
                pTable->IT_Flags |= IPRIP_FLAG_TRIGGERED_UPDATE_PENDING;
            }
        }
        else {

            //
            // the minimum time between triggered updates has elapsed,
            // so send the triggered update now
            //

            FinishTriggeredUpdate();
        }
    }


    LeaveCriticalSection(&pTable->IT_CS);

    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionStartTriggeredUpdate");

    LEAVE_RIP_WORKER();
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionFinishTriggeredUpdate
//
// This function generates a triggered update on all interfaces which
// do not have triggered updates disabled.
//----------------------------------------------------------------------------

VOID
WorkerFunctionFinishTriggeredUpdate(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    PIF_TABLE pTable;

    if (!ENTER_RIP_API()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionFinishTriggeredUpdate");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();

    EnterCriticalSection(&pTable->IT_CS);


    FinishTriggeredUpdate();


    LeaveCriticalSection(&pTable->IT_CS);

    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionFinishTriggeredUpdate");

    LEAVE_RIP_API();
    return;
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionStartDemandUpdate
//
// This function initiates a demand-update on the speficied interface,
// sending a general request on the interface. It then schedules a work-item
// to report back to Router Manager when the update is done
//----------------------------------------------------------------------------

VOID
WorkerFunctionStartDemandUpdate(
    PVOID pContext
    ) {

    PIF_TABLE pTable;
    RIP_IP_ROUTE route;
    PUPDATE_CONTEXT pwc;
    PIF_TABLE_ENTRY pite;
    DWORD dwErr, dwIndex;

    if (!ENTER_RIP_WORKER()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionStartDemandUpdate");



    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();


    do { // breakout loop


        //
        // retrieve the interface on which to perform the demand update
        //

        dwIndex = PtrToUlong(pContext);

        pite = GetIfByIndex(pTable, dwIndex);
        if (pite == NULL) {

            TRACE1(SEND, "demand-update: interface %d not found", dwIndex);
            break;
        }


        //
        // make sure interface is active and has demand-updates enabled
        //

        if (IF_IS_INACTIVE(pite)) {
            TRACE1(SEND, "demand-update: interface %d not active", dwIndex);
            EnqueueDemandUpdateMessage(dwIndex, ERROR_CAN_NOT_COMPLETE);
            break;
        }
        else
        if (pite->ITE_Config->IC_UpdateMode != IPRIP_UPDATE_DEMAND) {
            TRACE1(SEND, "demand-updates disabled on interface %d ", dwIndex);
            EnqueueDemandUpdateMessage(dwIndex, ERROR_CAN_NOT_COMPLETE);
            break;
        }


        //
        // setup the update context
        //

        pwc = RIP_ALLOC(sizeof(UPDATE_CONTEXT));

        if (pwc == NULL) {

            dwErr = GetLastError();
            TRACE2(
                SEND, "error %d allocating %d bytes",
                dwErr, sizeof(UPDATE_CONTEXT)
                );
            EnqueueDemandUpdateMessage(dwIndex, dwErr);
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }

        pwc->UC_InterfaceIndex = dwIndex;
        pwc->UC_RetryCount = 1;
        pwc->UC_RouteCount = 0;


        //
        // Create a timer for the demand update checks
        //
        
        if (!CreateTimerQueueTimer(
                &pite->ITE_FullOrDemandUpdateTimer,
                ig.IG_TimerQueueHandle,
                WorkerFunctionFinishDemandUpdate, (PVOID)pwc,
                5000, 5000, 0
                )) {
            EnqueueDemandUpdateMessage(dwIndex, GetLastError());
        }

        
        //
        // request routing tables from neighbors
        //

        SendGeneralRequest(pite);

    } while (FALSE);


    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionStartDemandUpdate");

    LEAVE_RIP_WORKER();
}




//----------------------------------------------------------------------------
// Function:    WorkerFunctionFinishDemandUpdate
//
// This function queues a message informing the Router Manager that
// the demand-update requested is complete
//----------------------------------------------------------------------------

VOID
WorkerFunctionFinishDemandUpdate(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    PIF_TABLE pTable;
    PUPDATE_CONTEXT pwc;
    PIF_TABLE_ENTRY pite;
    DWORD dwErr, dwIndex, dwRouteCount;

    if (pContext == NULL) { return; }

    if (!ENTER_RIP_API()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionFinishDemandUpdate");


    //
    // get the update context
    //

    pwc = (PUPDATE_CONTEXT)pContext;
    dwIndex = pwc->UC_InterfaceIndex;

    pTable = ig.IG_IfTable;


    ACQUIRE_IF_LOCK_SHARED();


    do {

        //
        // retrieve the interface being updated
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite == NULL) {
            EnqueueDemandUpdateMessage(dwIndex, ERROR_CAN_NOT_COMPLETE);
            break;
        }


        //
        // report failure if the interface is no longer active
        //

        if (!IF_IS_ACTIVE(pite)) {
            EnqueueDemandUpdateMessage(dwIndex, ERROR_CAN_NOT_COMPLETE);
            break;
        }


        //
        // get a count of the routes now on the interface
        //

        dwRouteCount = CountInterfaceRoutes(dwIndex);



        //
        // if there are still no routes, send another request
        // unless we have sent the maximum number of requests
        //

        if (dwRouteCount == 0 && ++pwc->UC_RetryCount < MAX_UPDATE_REQUESTS) {

            SendGeneralRequest(pite);

            break;
        }



        //
        // if the number of routes has not changed in the last 5 seconds,
        // tell the router manager that the update is complete;
        // otherwise, update the route count and enqueue another check
        //

        if (pwc->UC_RouteCount == dwRouteCount) {

            EnqueueDemandUpdateMessage(dwIndex, NO_ERROR);
            RIP_FREE(pwc);
            
            if (!DeleteTimerQueueTimer(
                    ig.IG_TimerQueueHandle, pite->ITE_FullOrDemandUpdateTimer,
                    NULL)) {

                TRACE1(
                    SEND, "error %d deleting demand update timer", 
                    GetLastError()
                    );
            }

            pite->ITE_FullOrDemandUpdateTimer = NULL;
        }
        else {

            pwc->UC_RouteCount = dwRouteCount;
        }


    } while(FALSE);


    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionFinishDemandUpdate");

    LEAVE_RIP_API();
}



//----------------------------------------------------------------------------
// Function:    CountInterfaceRoutes
//
//  Returns a count of the RIP routes associated with the specified interface
//----------------------------------------------------------------------------

DWORD
CountInterfaceRoutes(
    DWORD dwInterfaceIndex
    ) {

    HANDLE          hRouteEnum;
    PHANDLE         phRoutes = NULL;
    DWORD           dwHandles, dwFlags, i, dwErr, dwCount = 0;


    dwErr = RtmCreateRouteEnum(
                    ig.IG_RtmHandle, NULL, RTM_VIEW_MASK_UCAST, 
                    RTM_ENUM_OWN_ROUTES, NULL, RTM_MATCH_INTERFACE, 
                    NULL, dwInterfaceIndex, &hRouteEnum
                    );

    if (dwErr != NO_ERROR) {
        TRACE1(
            ANY, "CountInterfaceRoutes : error %d creating enum handle",
            dwErr
            );
        
        return 0;
    }


    //
    // allocate handle array large enough to hold max handles in an
    // enum
    //
        
    phRoutes = RIP_ALLOC(ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE));

    if ( phRoutes == NULL ) {

        dwErr = GetLastError();

        TRACE2(
            ANY, "CountInterfaceRoutes: error %d while allocating %d bytes"
            " to hold max handles in an enum",
            dwErr, ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
            );

        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return 0;
    }


    do
    {
        dwHandles = ig.IG_RtmProfile.MaxHandlesInEnum;
        
        dwErr = RtmGetEnumRoutes(
                    ig.IG_RtmHandle, hRouteEnum, &dwHandles, phRoutes
                    );

        for ( i = 0; i < dwHandles; i++ )
        {
            //
            // Release all route handles
            //
            
            dwErr = RtmReleaseRoutes(ig.IG_RtmHandle, 1, &phRoutes[i]);

            if (dwErr != NO_ERROR) {
                TRACE1(
                    ANY, "CountInterfaceRoutes : error %d releasing routes",
                    dwErr
                    );
            }
        }

        dwCount += dwHandles;
        
    } while (dwErr == NO_ERROR);


    //
    // close enum handle
    //
    
    dwErr = RtmDeleteEnumHandle(ig.IG_RtmHandle, hRouteEnum);

    if (dwErr != NO_ERROR) {
        TRACE1(
            ANY, "CountInterfaceRoutes : error %d closing enum handle", dwErr
            );
    }

    if ( phRoutes ) {
        RIP_FREE(phRoutes);
    }

    return dwCount;
}




//----------------------------------------------------------------------------
// Function:    EnqueueDemandUpdateMessage
//
// This function posts a message to IPRIP's Router Manager event queue
// indicating the status of a demand update request.
//----------------------------------------------------------------------------

VOID
EnqueueDemandUpdateMessage(
    DWORD dwInterfaceIndex,
    DWORD dwError
    ) {

    MESSAGE msg;
    PUPDATE_COMPLETE_MESSAGE pmsg;


    //
    // set up an UPDATE_COMPLETE message
    //

    pmsg = &msg.UpdateCompleteMessage;
    pmsg->UpdateType = RF_DEMAND_UPDATE_ROUTES;
    pmsg->UpdateStatus = dwError;
    pmsg->InterfaceIndex = dwInterfaceIndex;

    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
    EnqueueEvent(ig.IG_EventQueue, UPDATE_COMPLETE, msg);
    SetEvent(ig.IG_EventEvent);
    RELEASE_LIST_LOCK(ig.IG_EventQueue);
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionProcessRtmMessage
//
// This function handles messages from RTM about new or expired routes.
//----------------------------------------------------------------------------

VOID
WorkerFunctionProcessRtmMessage(
    PVOID pContext
    ) {

    DWORD dwErr, dwFlags, dwNumDests, dwSize;
    PIF_TABLE pTable;
    BOOL bTriggerUpdate, bDone = FALSE;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;

    RIP_IP_ROUTE route;
    PRTM_DEST_INFO prdi;
    CHAR szNetwork[32], szNexthop[32];
    

    if (!ENTER_RIP_WORKER()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionProcessRtmMessage");


    pTable = ig.IG_IfTable;


    //
    // allocate a buffer for retrieving the dest info
    //
    
    dwSize = RTM_SIZE_OF_DEST_INFO( ig.IG_RtmProfile.NumberOfViews );

    prdi = (PRTM_DEST_INFO) RIP_ALLOC( dwSize );

    if ( prdi == NULL ) {
    
        dwErr = GetLastError();
        TRACE2(
            ROUTE, "error %d allocating %d bytes for dest info buffers",
            dwErr, dwSize
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);
        LEAVE_RIP_WORKER();
        return;
    }


    //
    // Acquire locks
    //
    
    ACQUIRE_IF_LOCK_SHARED();

    ACQUIRE_GLOBAL_LOCK_SHARED();

    ACQUIRE_LIST_LOCK(ig.IG_SendQueue);


    bTriggerUpdate = FALSE;


    //
    // loop dequeueing messages until RTM says there are no more left
    //

    while (!bDone) {

        //
        // Retrieve route changes
        //

        dwNumDests = 1;

        dwErr = RtmGetChangedDests(
                    ig.IG_RtmHandle, ig.IG_RtmNotifHandle, &dwNumDests, prdi
                    );

        if ((dwErr != NO_ERROR) && (dwErr != ERROR_NO_MORE_ITEMS)) {
        
            TRACE1(ROUTE, "error %d retrieving changed dests", dwErr);
            break;
        }


        //
        // check if there are any more changed dests
        //
        
        if (dwErr == ERROR_NO_MORE_ITEMS) { bDone = TRUE; }

        if (dwNumDests < 1) { break; }


        if ((prdi-> ViewInfo[0].HoldRoute != NULL) ||
            (prdi-> ViewInfo[0].Route != NULL)) {
            
            ZeroMemory(&route, sizeof(RIP_IP_ROUTE));

            //
            // For each route change check if you have a held down route.
            // if so get the info for the held down route since that is
            // the one to be advertized.
            //
            //  N.B. RIP summary routes are not advertized via the route
            //       change processing mechanism.
            //

            dwErr = GetRouteInfo(
                        (prdi-> ViewInfo[0].HoldRoute != NULL) ?
                        prdi-> ViewInfo[0].HoldRoute : prdi-> ViewInfo[0].Route,
                        NULL, prdi, &route
                        );
                        
            if (dwErr == NO_ERROR) {

                //
                // do not advertize RIP summary routes
                //

                if ((route.RR_RoutingProtocol != PROTO_IP_RIP) ||
                    (GETROUTEFLAG(&route) & ROUTEFLAG_SUMMARY) !=
                        ROUTEFLAG_SUMMARY) {
                        
                    //
                    // held down routes are advertized with INFINITE metric
                    //
                    
                    if (prdi-> ViewInfo[0].HoldRoute != NULL) {
                        SETROUTEMETRIC(&route, IPRIP_INFINITE);
                    }
                    
                    EnqueueSendEntry( ig.IG_SendQueue, &route );
                    bTriggerUpdate = TRUE;
                }
#if ROUTE_DBG
                else if (route.RR_RoutingProtocol == PROTO_IP_RIP) {

                    TRACE0(ROUTE, "Ignoring route change caused by RIP summary route");
                }
#endif
            }
        }

        //
        // release the destination info
        //

        dwErr = RtmReleaseChangedDests(
                    ig.IG_RtmHandle, ig.IG_RtmNotifHandle, 1, prdi
                    );

        if (dwErr != NO_ERROR) {
            TRACE1(ANY, "error %d releasing changed dests", dwErr);
        }
    }


    if (prdi) { RIP_FREE(prdi); }

    
    //
    // queue a triggered update now if necessary
    //

    if (bTriggerUpdate) {
        QueueRipWorker(WorkerFunctionStartTriggeredUpdate, NULL);
    }


    RELEASE_LIST_LOCK(ig.IG_SendQueue);

    RELEASE_GLOBAL_LOCK_SHARED();

    RELEASE_IF_LOCK_SHARED();



    TRACE0(LEAVE, "leaving WorkerFunctionProcessRtmMessage");

    LEAVE_RIP_WORKER();

}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionActivateInterface
//
// This function sends out the initial general request on an interface.
//----------------------------------------------------------------------------

VOID
WorkerFunctionActivateInterface(
    PVOID pContext
    ) {

    PIF_TABLE pTable;
    UPDATE_BUFFER ub;
    PIPRIP_ENTRY pEntry;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    SOCKADDR_IN sinDest;
    DWORD i, dwErr, dwIndex;
    LARGE_INTEGER qwCurrentTime;

    if (!ENTER_RIP_WORKER()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionActivateInterface");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();


    do { // breakout loop


        //
        // retrieve the interface to be activated
        //

        dwIndex = PtrToUlong(pContext);

        pite = GetIfByIndex(pTable, dwIndex);
        if (pite == NULL) {

            TRACE1(IF, "activating interface: interface %d not found", dwIndex);
            break;
        }

        pic = pite->ITE_Config;
        pib = pite->ITE_Binding;

        //
        // If binding is NULL, assume that interface has been
        // deativated.  This check has been introduced as a consequence
        // of WorkerFunctionDeactivateInterface being made synchronous.
        // As a result, by the time this function is invoked an interface
        // that was in the process of being activated could have been
        // deactivated.
        //
        // The change to synchronous deactivate was made
        // to accomadate demand dial interfaces that could get connected
        // and disconnected immeditately, causing the above behaviour
        //

        if ( pib == NULL ) {

            TRACE1( IF, "activating interface %d: Binding not found", dwIndex );
            break;
        }

        paddr = IPRIP_IF_ADDRESS_TABLE(pib);


        //
        // request input notification on the interface's sockets
        //

        if (pic->IC_AcceptMode != IPRIP_ACCEPT_DISABLED) {

            for (i = 0; i < pib->IB_AddrCount; i++) {

                dwErr = WSAEventSelect(
                            pite->ITE_Sockets[i], ig.IG_IpripInputEvent,
                            FD_READ
                            );

                if (dwErr != NO_ERROR) {

                    LPSTR lpszAddr = INET_NTOA(paddr[i].IA_Address);
                    if (lpszAddr != NULL) {
                        TRACE3(
                            IF, "WSAEventSelect returned %d for interface %d (%s)",
                            dwErr, dwIndex, lpszAddr
                            );
                        LOGERR1(EVENTSELECT_FAILED, lpszAddr, 0);
                    }
                }
            }
        }


        //
        // if interface is silent or interface does demand-udpates,
        // no initial request is sent on it
        //

        if (pic->IC_UpdateMode != IPRIP_UPDATE_PERIODIC ||
            pic->IC_AnnounceMode == IPRIP_ANNOUNCE_DISABLED) {

            //
            // configured to be silent, do nothing
            //

            break;
        }


        //
        // send general request to neighboring routers
        //

        SendGeneralRequest(pite);


        //
        // create timer for periodic updates, if required.
        //
        
        EnterCriticalSection(&pTable->IT_CS);
        
        if (pite->ITE_FullOrDemandUpdateTimer == NULL) { 

            if (!CreateTimerQueueTimer(
                        &pite->ITE_FullOrDemandUpdateTimer,
                        ig.IG_TimerQueueHandle, 
                        WorkerFunctionStartFullUpdate, pContext,
                        RipSecsToMilliSecs(pic->IC_FullUpdateInterval),
                        10000000, 0
                        )) {
                dwErr = GetLastError();
                TRACE1(IF, "error %d returned by CreateTimerQueueTimer", dwErr);
                break;
            }
            else {
                pite->ITE_Flags |= ITEFLAG_FULL_UPDATE_INQUEUE;
            }
        }
        else {
            RipQuerySystemTime(&qwCurrentTime);
            EnqueueStartFullUpdate(pite, qwCurrentTime);
        }

        LeaveCriticalSection(&pTable->IT_CS);
        
    } while(FALSE);

    RELEASE_IF_LOCK_SHARED();


    TRACE0(LEAVE, "leaving WorkerFunctionActivateInterface");

    LEAVE_RIP_WORKER();

}




//----------------------------------------------------------------------------
// Function:    WorkerFunctionDeactivateInterface
//
// This function generates shutdown update on the given interface, and
// removes from RTM all RIP-learnt routes associated with the interface.
// Assumes the interface table has already been exclusively locked
//----------------------------------------------------------------------------

VOID
WorkerFunctionDeactivateInterface(
    PVOID pContext
    ) {

    UPDATE_BUFFER ub;
    PIF_TABLE pTable;
    RIP_IP_ROUTE route;
    HANDLE hEnumerator;
    PHANDLE phRoutes = NULL;
    BOOL bTriggerUpdate;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    DWORD i, dwErr, dwFlags, dwIndex, dwHandles;


    TRACE0(ENTER, "entering WorkerFunctionDeactivateInterface");


    dwIndex = PtrToUlong(pContext);

    bTriggerUpdate = FALSE;
    pTable = ig.IG_IfTable;


    do { // breakout loop


        //
        // find the interface to be deactivated
        //

        pite = GetIfByIndex(pTable, dwIndex);

        if (pite == NULL) {

            TRACE1(
                IF, "de-activating interface: interface %d not found", dwIndex
                );

            break;
        }


        pib = pite->ITE_Binding;
        paddr = IPRIP_IF_ADDRESS_TABLE(pib);


        //
        // if graceful shutdown is on and demand-update is off,
        // send the graceful-shutdown update
        //

        if (pite->ITE_Config->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
            IPRIP_FLAG_IS_ENABLED(pite->ITE_Config, GRACEFUL_SHUTDOWN)) {

            //
            // transmit all RTM routes with non-infinite metrics set to 15
            //

            if (pite->ITE_Config->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {

                SendRoutes(&pite, 1, SENDMODE_SHUTDOWN_UPDATE, 0, 0);
            }
        }



        //
        // this function is called either because an interface
        // that was active (bound and enabled) is either no longer enabled
        // or is no longer bound. We complete the deactivation differently
        // depending on which of these is the case
        //

        if (!IF_IS_BOUND(pite) ) {

            //
            // the interface was bound, but isn't anymore.
            // close the socket for the interface
            //

            DeleteIfSocket(pite);

            ACQUIRE_BINDING_LOCK_EXCLUSIVE();

            dwErr = DeleteBindingEntry(ig.IG_BindingTable, pite->ITE_Binding);

            RELEASE_BINDING_LOCK_EXCLUSIVE();

            RIP_FREE(pite->ITE_Binding);
            pite->ITE_Binding = NULL;
        }
        else {

            //
            // the interface was enabled, but isn't anymore.
            // tell WinSock to stop notifying us of input
            //

            for (i = 0; i < pib->IB_AddrCount; i++) {
                WSAEventSelect(pite->ITE_Sockets[i], ig.IG_IpripInputEvent, 0);
            }
        }

        //
        // if full updates pending/queued on this interface, cancel them.
        //

        pite-> ITE_Flags &= ~ITEFLAG_FULL_UPDATE_PENDING;
        pite-> ITE_Flags &= ~ITEFLAG_FULL_UPDATE_INQUEUE;


        //
        // if we're announcing routes over this interface,
        // delete the periodic announcement timer
        //
        
        if (pite->ITE_Config->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
            pite->ITE_Config->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED) {

            if (!DeleteTimerQueueTimer(
                    ig.IG_TimerQueueHandle, 
                    pite->ITE_FullOrDemandUpdateTimer,
                    NULL)) {

                TRACE1(
                    ANY, "error %d deleting update timer", GetLastError()
                    );
            }

            pite->ITE_FullOrDemandUpdateTimer = NULL;
        }
        

        //
        // we're done if graceful shutdown is disabled
        // or if this is a demand-update interface
        //

        if (pite->ITE_Config->IC_UpdateMode != IPRIP_UPDATE_PERIODIC ||
            IPRIP_FLAG_IS_DISABLED(pite->ITE_Config, GRACEFUL_SHUTDOWN)) {
            break;
        }


        //
        // move the routes learnt on this interface to the send-queue
        // and set their metrics to 16
        //

        dwErr = RtmCreateRouteEnum(
                    ig.IG_RtmHandle, NULL, RTM_VIEW_MASK_ANY, 
                    RTM_ENUM_OWN_ROUTES, NULL, RTM_MATCH_INTERFACE, NULL, 
                    pite->ITE_Index, &hEnumerator
                    );

        if (dwErr != NO_ERROR) {
            TRACE1(
                ANY, "WorkerFunctionDeactivateInterface: error %d creating"
                " enum handle", dwErr
                );
            
            break;
        }


        //
        // allocate handle array large enough to hold max handles in an
        // enum
        //
        
        phRoutes = RIP_ALLOC(ig.IG_RtmProfile.MaxHandlesInEnum*sizeof(HANDLE));

        if ( phRoutes == NULL ) {

            dwErr = GetLastError();

            TRACE2(
                ANY, "WorkerFunctionDeactivateInterface: error %d "
                "while allocating %d bytes to hold max handles in an enum",
                dwErr, ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }

        //
        // find all RIP routes learnt on this interface
        //

        ACQUIRE_GLOBAL_LOCK_SHARED();

        ACQUIRE_LIST_LOCK(ig.IG_SendQueue);

        do {
        
            dwHandles = ig.IG_RtmProfile.MaxHandlesInEnum;
            
            dwErr = RtmGetEnumRoutes(
                        ig.IG_RtmHandle, hEnumerator, &dwHandles, phRoutes
                        );

            for ( i = 0; i < dwHandles; i++ ) {
            
                if (GetRouteInfo(
                        phRoutes[i], NULL, NULL, &route
                        ) == NO_ERROR) {
                    //
                    // set the route's metric to infinite
                    //

                    SETROUTEMETRIC(&route, IPRIP_INFINITE);


                    //
                    // add the route to the send-queue
                    //

                    EnqueueSendEntry(ig.IG_SendQueue, &route);
                    bTriggerUpdate = TRUE;
                }
                            

                if (RtmDeleteRouteToDest(
                        ig.IG_RtmHandle, phRoutes[i], &dwFlags
                        ) != NO_ERROR) {
                        
                    //
                    // If delete is successful, this is automatic
                    //
                    
                    if (RtmReleaseRoutes(
                            ig.IG_RtmHandle, 1, &phRoutes[i]
                            ) != NO_ERROR) {
                            
                        TRACE1(
                            ANY, "WorkerFunctionDeactivateInterface: "
                            "error %d releasing route handles", dwErr
                            );
                    }
                }
            }
            
        } while ( dwErr == NO_ERROR );


        //
        // close the enm handle
        //
        
        dwErr = RtmDeleteEnumHandle(ig.IG_RtmHandle, hEnumerator);

        if (dwErr != NO_ERROR) {
            TRACE1(
                ANY, "WorkerFunctionDeactivateInterface: error %d "
                "closing enum handle", dwErr
                );
        }


        RELEASE_LIST_LOCK(ig.IG_SendQueue);

        RELEASE_GLOBAL_LOCK_SHARED();


        //
        // queue a triggered-update work-item for the other active interfaces
        //

        if (bTriggerUpdate) {

            dwErr = QueueRipWorker(WorkerFunctionStartTriggeredUpdate, NULL);

            if (dwErr != NO_ERROR) {

                TRACE1(
                    IF, "error %d queueing triggered update work-item", dwErr
                    );
                LOGERR0(QUEUE_WORKER_FAILED, dwErr);
            }
        }

    } while(FALSE);


    if ( phRoutes ) {
        RIP_FREE(phRoutes);
    }

    TRACE0(LEAVE, "leaving WorkerFunctionDeactivateInterface");

}




//----------------------------------------------------------------------------
// Function:    WorkerFunctionFinishStopProtocol
//
// This function is called when IPRIP is stopping; it sends out shutdown
// updates on all interfaces and removes all RIP routes from RTM
//----------------------------------------------------------------------------
VOID
WorkerFunctionFinishStopProtocol(
    PVOID pContext
    ) {

    MESSAGE msg = {0, 0, 0};
    LONG lThreadCount;
    PIF_TABLE pTable;
    PIPRIP_IF_CONFIG pic;
    PLIST_ENTRY ple, phead;
    DWORD dwErr, dwIfCount;
    PIF_TABLE_ENTRY pite, *ppite, *ppitend, *pIfList;
    HANDLE WaitHandle;

    TRACE0(ENTER, "entering WorkerFunctionFinishStopProtocol");



    //
    // NOTE: since this is called while the router is stopping,
    // there is no need for it to use ENTER_RIP_WORKER()/LEAVE_RIP_WORKER()
    //

    lThreadCount = PtrToUlong(pContext);


    //
    // waits for input thread and timer thread to stop,
    // and also waits for API callers and worker functions to finish
    //

    while (lThreadCount-- > 0) {
        WaitForSingleObject(ig.IG_ActivitySemaphore, INFINITE);
    }



    //
    // deregister the events set with NtdllWait thread and delete the
    // timer queue registered with NtdllTimer thread.
    // These calls should not be inside IG_CS lock and must be done
    // after all the threads have stopped.
    //

    WaitHandle = InterlockedExchangePointer(&ig.IG_IpripInputEventHandle, NULL) ;
    if (WaitHandle) {
        UnregisterWaitEx( WaitHandle, INVALID_HANDLE_VALUE ) ;
    }

    
    if (ig.IG_TimerQueueHandle) {
        DeleteTimerQueueEx(ig.IG_TimerQueueHandle, INVALID_HANDLE_VALUE);
    }


    //
    // we enter the critical section and leave, just to be sure that
    // all threads have quit their calls to LeaveRipWorker()
    //

    EnterCriticalSection(&ig.IG_CS);
    LeaveCriticalSection(&ig.IG_CS);


    TRACE0(STOP, "all threads stopped, now performing graceful shutdown");


    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_EXCLUSIVE();


    //
    // send out graceful shutdown updates on all active interfaces
    //

    do {


        phead = &pTable->IT_ListByAddress;


        //
        // first count the interfaces on which graceful shutdown is enabled
        //

        dwIfCount = 0;
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            pic = pite->ITE_Config;

            if (IF_IS_ACTIVE(pite) &&
                pite->ITE_Binding &&
                pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
                IPRIP_FLAG_IS_ENABLED(pic, GRACEFUL_SHUTDOWN)) {

                ++dwIfCount;
            }
        }


        if (dwIfCount == 0) { break; }


        //
        // allocate space for the interface pointers
        //

        pIfList = RIP_ALLOC(dwIfCount * sizeof(PIF_TABLE_ENTRY));

        if (pIfList == NULL) {

            dwErr = GetLastError();
            TRACE2(
                STOP, "shutdown: error %d allocating %d bytes for interfaces",
                dwErr, dwIfCount * sizeof(PIF_TABLE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy the interface pointers into the space allocated
        //

        ppitend = pIfList + dwIfCount;
        for (ple = phead->Flink, ppite = pIfList;
             ple != phead && ppite < ppitend; ple = ple->Flink) {

            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

            pic = pite->ITE_Config;

            if (IF_IS_ACTIVE(pite) &&
                pite->ITE_Binding &&
                pic->IC_UpdateMode == IPRIP_UPDATE_PERIODIC &&
                pic->IC_AnnounceMode != IPRIP_ANNOUNCE_DISABLED &&
                IPRIP_FLAG_IS_ENABLED(pic, GRACEFUL_SHUTDOWN)) {

                *ppite++ = pite;
            }
        }


        //
        // pass the array of interfaces to SendRoutes
        //

        TRACE1(STOP, "sending shutdown updates on %d interfaces", dwIfCount);

        SendRoutes(pIfList, dwIfCount, SENDMODE_SHUTDOWN_UPDATE, 0, 0);



        //
        // free the array of interfaces
        //

        RIP_FREE(pIfList);

    } while(FALSE);


    RELEASE_IF_LOCK_EXCLUSIVE();


    //
    // delete all IPRIP routes from RTM
    //

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) 
    {
        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

        BlockDeleteRoutesOnInterface(
            ig.IG_RtmHandle, pite-> ITE_Index
            );
    }


    //
    // cleanup the global structures
    //

    TRACE0(STOP, "IPRIP is cleaning up resources");


    ProtocolCleanup(TRUE);

    LOGINFO0(IPRIP_STOPPED, NO_ERROR);


    //
    // let the Router Manager know that we are done
    //

    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
    EnqueueEvent(ig.IG_EventQueue, ROUTER_STOPPED, msg);
    SetEvent(ig.IG_EventEvent);
    RELEASE_LIST_LOCK(ig.IG_EventQueue);

    return;

}



VOID
PrintGlobalStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintIfStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintIfConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintIfBinding(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );
VOID
PrintPeerStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    );

#define ClearScreen(h) {                                                    \
    DWORD _dwin,_dwout;                                                     \
    COORD _c = {0, 0};                                                      \
    CONSOLE_SCREEN_BUFFER_INFO _csbi;                                       \
    GetConsoleScreenBufferInfo(h,&_csbi);                                   \
    _dwin = _csbi.dwSize.X * _csbi.dwSize.Y;                                \
    FillConsoleOutputCharacter(h,' ',_dwin,_c,&_dwout);                     \
}



VOID
WorkerFunctionMibDisplay(
    PVOID pContext,
    BOOLEAN bNotUsed
    ) {

    COORD c;
    HANDLE hConsole = NULL;
    DWORD dwErr, dwTraceID;
    DWORD dwExactSize, dwInSize, dwOutSize;
    IPRIP_MIB_GET_INPUT_DATA imgid;
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod;
    LARGE_INTEGER qwNextDisplay, qwCurrentTime;

    if (!ENTER_RIP_API()) { return; }


    TraceGetConsole(ig.IG_MibTraceID, &hConsole);


    if (hConsole == NULL) {
        LEAVE_RIP_WORKER();
        return;
    }



    ClearScreen(hConsole);

    c.X = c.Y = 0;


    dwInSize = sizeof(imgid);
    imgid.IMGID_TypeID = IPRIP_GLOBAL_STATS_ID;
    pimgod = NULL;


    //
    // get size of the first entry in the first table
    //

    dwErr = MibGetFirst(dwInSize, &imgid, &dwOutSize, pimgod);


    if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

        //
        // allocate a buffer, and set its size
        //

        pimgod = RIP_ALLOC(dwOutSize);


        //
        // perform the query again
        //

        dwErr = MibGetFirst(dwInSize, &imgid, &dwOutSize, pimgod);

    }



    //
    // now that we have the first element in the first table,
    // we can enumerate the elements in the remaining tables using GetNext
    //

    while (dwErr == NO_ERROR) {


        //
        // print the current element and set up the query
        // for the next element (the display functions  change imgid
        // so that it can be used to query the next element)
        //

        switch(pimgod->IMGOD_TypeID) {
            case IPRIP_GLOBAL_STATS_ID:
                PrintGlobalStats(hConsole, &c, &imgid, pimgod);
                break;

            case IPRIP_GLOBAL_CONFIG_ID:
                PrintGlobalConfig(hConsole,&c, &imgid, pimgod);
                break;

            case IPRIP_IF_CONFIG_ID:
                PrintIfConfig(hConsole, &c, &imgid, pimgod);
                break;

            case IPRIP_IF_BINDING_ID:
                PrintIfBinding(hConsole, &c, &imgid, pimgod);
                break;

            case IPRIP_IF_STATS_ID:
                PrintIfStats(hConsole, &c, &imgid, pimgod);
                break;

            case IPRIP_PEER_STATS_ID:
                PrintPeerStats(hConsole, &c, &imgid, pimgod);
                break;

            default:
                break;
        }


        RIP_FREE(pimgod);
        pimgod = NULL;
        dwOutSize = 0;


        //
        // move to the next line on the console
        //

        ++c.Y;


        //
        // query the next MIB element
        //

        dwErr = MibGetNext(dwInSize, &imgid, &dwOutSize, pimgod);



        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

            //
            // allocate a new buffer, and set its size
            //

            pimgod = RIP_ALLOC(dwOutSize);

            //
            // perform the query again
            //

            dwErr = MibGetNext(dwInSize, &imgid, &dwOutSize, pimgod);

        }
    }


    //
    // if memory was allocated, free it now
    //

    if (pimgod != NULL) { RIP_FREE(pimgod); }

    LEAVE_RIP_API();
}



#define WriteLine(h,c,fmt,arg) {                                            \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg);                                                 \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}



VOID
PrintGlobalStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_GLOBAL_STATS pgs;

    pgs = (PIPRIP_GLOBAL_STATS)pimgod->IMGOD_Buffer;

    WriteLine(
        hConsole, *pc, "System Route Changes:             %d",
        pgs->GS_SystemRouteChanges
        );
    WriteLine(
        hConsole, *pc, "Total Responses Sent:             %d",
        pgs->GS_TotalResponsesSent
        );

    pimgid->IMGID_TypeID = IPRIP_GLOBAL_STATS_ID;
}



VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_GLOBAL_CONFIG pgc;
    PDWORD pdwPeer, pdwPeerEnd;
    CHAR szFilter[32];
    LPSTR lpszAddr = NULL;

    pgc = (PIPRIP_GLOBAL_CONFIG)pimgod->IMGOD_Buffer;

    switch (pgc->GC_PeerFilterMode) {
        case IPRIP_FILTER_DISABLED:
            lstrcpy(szFilter, "disabled"); break;
        case IPRIP_FILTER_INCLUDE:
            lstrcpy(szFilter, "include all"); break;
        case IPRIP_FILTER_EXCLUDE:
            lstrcpy(szFilter, "exclude all"); break;
        default:
            lstrcpy(szFilter, "invalid"); break;
    }

    WriteLine(
        hConsole, *pc, "Logging Level:                    %d",
        pgc->GC_LoggingLevel
        );
    WriteLine(
        hConsole, *pc, "Max Receive Queue Size:           %d bytes",
        pgc->GC_MaxRecvQueueSize
        );
    WriteLine(
        hConsole, *pc, "Max Send Queue Size:              %d bytes",
        pgc->GC_MaxSendQueueSize
        );
    WriteLine(
        hConsole, *pc, "Min Triggered Update interval:    %d seconds",
        pgc->GC_MinTriggeredUpdateInterval
        );
    WriteLine(
        hConsole, *pc, "Peer Filter Mode:                 %s",
        szFilter
        );

    WriteLine(
        hConsole, *pc, "Peer Filter Count:                %d",
        pgc->GC_PeerFilterCount
        );

    pdwPeer = IPRIP_GLOBAL_PEER_FILTER_TABLE(pgc);
    pdwPeerEnd = pdwPeer + pgc->GC_PeerFilterCount;
    for ( ; pdwPeer < pdwPeerEnd; pdwPeer++) {
        lpszAddr = INET_NTOA(*pdwPeer);
        if (lpszAddr != NULL) {
            WriteLine(
                hConsole, *pc, "                                  %s",
                lpszAddr       
                );
        }
    }

    pimgid->IMGID_TypeID = IPRIP_GLOBAL_CONFIG_ID;
}



VOID
PrintIfStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_IF_STATS pis;

    pis = (PIPRIP_IF_STATS)pimgod->IMGOD_Buffer;

    WriteLine(
        hConsole, *pc, "Interface Index:                  %d",
        pimgod->IMGOD_IfIndex
        );
    WriteLine(
        hConsole, *pc, "Send Failures:                    %d",
        pis->IS_SendFailures
        );
    WriteLine(
        hConsole, *pc, "Receive  Failures:                %d",
        pis->IS_ReceiveFailures
        );
    WriteLine(
        hConsole, *pc, "Requests Sent:                    %d",
        pis->IS_RequestsSent
        );
    WriteLine(
        hConsole, *pc, "Requests Received:                %d",
        pis->IS_RequestsReceived
        );
    WriteLine(
        hConsole, *pc, "Responses Sent:                   %d",
        pis->IS_ResponsesSent
        );
    WriteLine(
        hConsole, *pc, "Responses Received:               %d",
        pis->IS_ResponsesReceived
        );
    WriteLine(
        hConsole, *pc, "Bad Response Packets Received:    %d",
        pis->IS_BadResponsePacketsReceived
        );
    WriteLine(
        hConsole, *pc, "Bad Response Entries Received:    %d",
        pis->IS_BadResponseEntriesReceived
        );
    WriteLine(
        hConsole, *pc, "Triggered Updates Sent:           %d",
        pis->IS_TriggeredUpdatesSent
        );

    pimgid->IMGID_TypeID = IPRIP_IF_STATS_ID;
    pimgid->IMGID_IfIndex = pimgod->IMGOD_IfIndex;
}



VOID
PrintIfConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_IF_CONFIG pic;
    PDWORD pdwPeer, pdwPeerEnd;
    PIPRIP_ROUTE_FILTER pfilt, pfiltend;
    CHAR szAuthType[24], szAuthKey[64];
    CHAR szPeer[20], szAccept[20], szAnnounce[20], szFilter[64];
    CHAR szUpdateMode[24], szAcceptMode[24], szAnnounceMode[24];
    LPSTR lpszAddr = NULL;

    pic = (PIPRIP_IF_CONFIG)pimgod->IMGOD_Buffer;

    switch (pic->IC_UpdateMode) {
        case IPRIP_UPDATE_PERIODIC:
            lstrcpy(szUpdateMode, "periodic");
            break;
        case IPRIP_UPDATE_DEMAND:
            lstrcpy(szUpdateMode, "demand");
            break;
        default:
            lstrcpy(szUpdateMode, "invalid");
            break;
    }

    switch (pic->IC_AcceptMode) {
        case IPRIP_ACCEPT_DISABLED:
            lstrcpy(szAcceptMode, "disabled");
            break;
        case IPRIP_ACCEPT_RIP1:
            lstrcpy(szAcceptMode, "RIP1");
            break;
        case IPRIP_ACCEPT_RIP1_COMPAT:
            lstrcpy(szAcceptMode, "RIP1 compatible");
            break;
        case IPRIP_ACCEPT_RIP2:
            lstrcpy(szAcceptMode, "RIP2");
            break;
        default:
            lstrcpy(szAcceptMode, "invalid");
            break;
    }

    switch(pic->IC_AnnounceMode) {
        case IPRIP_ANNOUNCE_DISABLED:
            lstrcpy(szAnnounceMode, "disabled");
            break;
        case IPRIP_ANNOUNCE_RIP1:
            lstrcpy(szAnnounceMode, "RIP1");
            break;
        case IPRIP_ANNOUNCE_RIP1_COMPAT:
            lstrcpy(szAnnounceMode, "RIP1 compatible");
            break;
        case IPRIP_ANNOUNCE_RIP2:
            lstrcpy(szAnnounceMode, "RIP2");
            break;
        default:
            lstrcpy(szAnnounceMode, "invalid");
            break;
    }

    switch (pic->IC_AuthenticationType) {
        case IPRIP_AUTHTYPE_NONE:
            lstrcpy(szAuthType, "none");
            break;
        case IPRIP_AUTHTYPE_SIMPLE_PASSWORD:
            lstrcpy(szAuthType, "simple password");
            break;
        case IPRIP_AUTHTYPE_MD5:
            lstrcpy(szAuthType, "MD5");
            break;
        default:
            lstrcpy(szAuthType, "invalid");
            break;
    }

    {
        PSTR psz;
        CHAR szDigits[] = "0123456789ABCDEF";
        PBYTE pb, pbend;

        psz = szAuthKey;
        pbend = pic->IC_AuthenticationKey + IPRIP_MAX_AUTHKEY_SIZE;
        for (pb = pic->IC_AuthenticationKey; pb < pbend; pb++) {
            *psz++ = szDigits[*pb / 16];
            *psz++ = szDigits[*pb % 16];
            *psz++ = '-';
        }

        *(--psz) = '\0';
    }

    switch (pic->IC_UnicastPeerMode) {
        case IPRIP_PEER_DISABLED:
            lstrcpy(szPeer, "disabled"); break;
        case IPRIP_PEER_ALSO:
            lstrcpy(szPeer, "also"); break;
        case IPRIP_PEER_ONLY:
            lstrcpy(szPeer, "only"); break;
        default:
            lstrcpy(szPeer, "invalid"); break;
    }

    switch (pic->IC_AcceptFilterMode) {
        case IPRIP_FILTER_DISABLED:
            lstrcpy(szAccept, "disabled"); break;
        case IPRIP_FILTER_INCLUDE:
            lstrcpy(szAccept, "include all"); break;
        case IPRIP_FILTER_EXCLUDE:
            lstrcpy(szAccept, "exclude all"); break;
        default:
            lstrcpy(szAccept, "invalid"); break;
    }

    switch (pic->IC_AnnounceFilterMode) {
        case IPRIP_FILTER_DISABLED:
            lstrcpy(szAnnounce, "disabled"); break;
        case IPRIP_FILTER_INCLUDE:
            lstrcpy(szAnnounce, "include all"); break;
        case IPRIP_FILTER_EXCLUDE:
            lstrcpy(szAnnounce, "exclude all"); break;
        default:
            lstrcpy(szAnnounce, "invalid"); break;
    }


    WriteLine(
        hConsole, *pc, "Interface Index:                  %d",
        pimgod->IMGOD_IfIndex
        );
    WriteLine(
        hConsole, *pc, "Metric:                           %d",
        pic->IC_Metric
        );
    WriteLine(
        hConsole, *pc, "Update Mode:                      %s",
        szUpdateMode
        );
    WriteLine(
        hConsole, *pc, "Accept Mode:                      %s",
        szAcceptMode
        );
    WriteLine(
        hConsole, *pc, "Announce Mode:                    %s",
        szAnnounceMode
        );
    WriteLine(
        hConsole, *pc, "Accept Host Routes:               %s",
        (IPRIP_FLAG_IS_ENABLED(pic, ACCEPT_HOST_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Announce Host Routes:             %s",
        (IPRIP_FLAG_IS_ENABLED(pic, ANNOUNCE_HOST_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Accept Default Routes:            %s",
        (IPRIP_FLAG_IS_ENABLED(pic, ACCEPT_DEFAULT_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Announce Default Routes:          %s",
        (IPRIP_FLAG_IS_ENABLED(pic, ANNOUNCE_DEFAULT_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Split Horizon:                    %s",
        (IPRIP_FLAG_IS_ENABLED(pic, SPLIT_HORIZON) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Poison Reverse:                   %s",
        (IPRIP_FLAG_IS_ENABLED(pic, POISON_REVERSE) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Graceful Shutdown:                %s",
        (IPRIP_FLAG_IS_ENABLED(pic, GRACEFUL_SHUTDOWN) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Triggered Updates:                %s",
        (IPRIP_FLAG_IS_ENABLED(pic, TRIGGERED_UPDATES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Overwrite Static Routes:          %s",
        (IPRIP_FLAG_IS_ENABLED(pic, OVERWRITE_STATIC_ROUTES) ? "enabled" : "disabled")
        );
    WriteLine(
        hConsole, *pc, "Route Expiration Interval:        %d seconds",
        pic->IC_RouteExpirationInterval
        );
    WriteLine(
        hConsole, *pc, "Route Removal Interval:           %d seconds",
        pic->IC_RouteRemovalInterval
        );
    WriteLine(
        hConsole, *pc, "Full Update Interval:             %d seconds",
        pic->IC_FullUpdateInterval
        );
    WriteLine(
        hConsole, *pc, "Authentication Type:              %s",
        szAuthType
        );
    WriteLine(
        hConsole, *pc, "Authentication Key:               %s",
        szAuthKey
        );
    WriteLine(
        hConsole, *pc, "Route Tag:                        %d",
        pic->IC_RouteTag
        );
    WriteLine(
        hConsole, *pc, "Unicast Peer Mode:                %s",
        szPeer
        );
    WriteLine(
        hConsole, *pc, "Accept Filter Mode:               %s",
        szAccept
        );
    WriteLine(
        hConsole, *pc, "Announce Filter Mode:             %s",
        szAnnounce
        );
    WriteLine(
        hConsole, *pc, "Unicast Peer Count:               %d",
        pic->IC_UnicastPeerCount
        );
    pdwPeer = IPRIP_IF_UNICAST_PEER_TABLE(pic);
    pdwPeerEnd = pdwPeer + pic->IC_UnicastPeerCount;
    for ( ; pdwPeer < pdwPeerEnd; pdwPeer++) {
        lpszAddr = INET_NTOA(*pdwPeer);
        if (lpszAddr != NULL) {
            WriteLine(
                hConsole, *pc, "                                  %s",
                lpszAddr
                );
        }
    }

    WriteLine(
        hConsole, *pc, "Accept Filter Count:              %d",
        pic->IC_AcceptFilterCount
        );
    pfilt = IPRIP_IF_ACCEPT_FILTER_TABLE(pic);
    pfiltend = pfilt + pic->IC_AcceptFilterCount;
    for ( ; pfilt < pfiltend; pfilt++) {
        lpszAddr = INET_NTOA(pfilt->RF_LoAddress);
        if (lpszAddr != NULL) {
            lstrcpy(szFilter, lpszAddr);
            strcat(szFilter, " - ");
            lpszAddr = INET_NTOA(pfilt->RF_HiAddress);
            if (lpszAddr != NULL) {
                strcat(szFilter, INET_NTOA(pfilt->RF_HiAddress));
                WriteLine(
                    hConsole, *pc, "                                  %s",
                    szFilter
                    );
            }
        }
    }

    WriteLine(
        hConsole, *pc, "Announce Filter Count:            %d",
        pic->IC_AnnounceFilterCount
        );
    pfilt = IPRIP_IF_ANNOUNCE_FILTER_TABLE(pic);
    pfiltend = pfilt + pic->IC_AnnounceFilterCount;
    for ( ; pfilt < pfiltend; pfilt++) {
        lpszAddr = INET_NTOA(pfilt->RF_LoAddress);
        if (lpszAddr != NULL) {
            lstrcpy(szFilter, lpszAddr);
            strcat(szFilter, " - ");
            lpszAddr = INET_NTOA(pfilt->RF_HiAddress);
            if (lpszAddr != NULL) {
                strcat(szFilter, INET_NTOA(pfilt->RF_HiAddress));
                WriteLine(
                    hConsole, *pc, "                                  %s",
                    szFilter
                    );
            }
        }
    }

    pimgid->IMGID_TypeID = IPRIP_IF_CONFIG_ID;
    pimgid->IMGID_IfIndex = pimgod->IMGOD_IfIndex;
}


VOID
PrintIfBinding(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    DWORD i;
    CHAR szAddr[64];
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    LPSTR lpszAddr = NULL;

    pib = (PIPRIP_IF_BINDING) pimgod->IMGOD_Buffer;
    paddr = IPRIP_IF_ADDRESS_TABLE(pib);

    WriteLine(
        hConsole, *pc, "Interface Index:                  %d",
        pimgod->IMGOD_IfIndex
        );
    WriteLine(
        hConsole, *pc, "Address Count:                    %d",
        pib->IB_AddrCount
        );
    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
        lpszAddr = INET_NTOA(paddr->IA_Address);

        if (lpszAddr != NULL) {
            lstrcpy(szAddr, lpszAddr);
            lstrcat(szAddr, " - ");

            lpszAddr = INET_NTOA(paddr->IA_Netmask);
            if (lpszAddr != NULL) {
                lstrcat(szAddr, lpszAddr);
                WriteLine(
                    hConsole, *pc, "Address Entry:                    %s",
                    szAddr
                    );
            }
        }
    }
    
    pimgid->IMGID_TypeID = IPRIP_IF_BINDING_ID;
    pimgid->IMGID_IfIndex = pimgod->IMGOD_IfIndex;
}


VOID
PrintPeerStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPRIP_PEER_STATS pps;
    LPSTR lpszAddr = INET_NTOA(pimgod->IMGOD_PeerAddress);


    pps = (PIPRIP_PEER_STATS)pimgod->IMGOD_Buffer;

    if (lpszAddr != NULL) {
        WriteLine(
            hConsole, *pc, "Peer Address:                     %s",
            lpszAddr
            );
    }
    else {
        WriteLine(
            hConsole, *pc, "Peer Address: Failed inet_ntoa conv ",
            lpszAddr
            );
    }
    
    WriteLine(
        hConsole, *pc, "Last Peer Route Tag:              %d",
        pps->PS_LastPeerRouteTag
        );
    WriteLine(
        hConsole, *pc, "Last Peer Update Tick-Count       %d ticks",
        pps->PS_LastPeerUpdateTickCount
        );
    WriteLine(
        hConsole, *pc, "Bad Response Packets From Peer:   %d",
        pps->PS_BadResponsePacketsFromPeer
        );
    WriteLine(
        hConsole, *pc, "Bad Response Entries From Peer:   %d",
        pps->PS_BadResponseEntriesFromPeer
        );

    pimgid->IMGID_TypeID = IPRIP_PEER_STATS_ID;
    pimgid->IMGID_PeerAddress = pimgod->IMGOD_PeerAddress;
}



//----------------------------------------------------------------------------
// Function:    CallbackFunctionNetworkEvents
//
// This function queues a worker function to process the input packets.
// It registers a ntdll wait event at the end so that only one thread can
// be processing the input packets.
//----------------------------------------------------------------------------

VOID
CallbackFunctionNetworkEvents (
    PVOID   pContext,
    BOOLEAN NotUsed
    ) {

    HANDLE WaitHandle;

    //
    // enter/leaveRipApi should be called to make sure that rip dll is around
    //

    if (!ENTER_RIP_API()) { return; }


    //
    // set the pointer to NULL, so that Unregister wont be called
    //

    WaitHandle = InterlockedExchangePointer(&ig.IG_IpripInputEventHandle, NULL);

    if (WaitHandle)
        UnregisterWaitEx( WaitHandle, NULL ) ;



    QueueRipWorker(WorkerFunctionNetworkEvents,pContext);


    LEAVE_RIP_API();
}


//----------------------------------------------------------------------------
// Function:    ProcessNetworkEvents
//
// This function enumerates the input events on each interface
// and processes any incoming input packets
//----------------------------------------------------------------------------

VOID
WorkerFunctionNetworkEvents (
    PVOID   pContext
    ) {

    DWORD i, dwErr;
    PIF_TABLE pTable;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, phead;
    WSANETWORKEVENTS wsane;
    PIPRIP_IP_ADDRESS paddr;
    LPSTR lpszAddr = NULL;


    if (!ENTER_RIP_WORKER()) { return; }

    pTable = ig.IG_IfTable;

    ACQUIRE_IF_LOCK_SHARED();

    //
    // go through the list of active interfaces
    // processing sockets which are read-ready
    //

    phead = &pTable->IT_ListByAddress;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

        pic = pite->ITE_Config;

        if (pic->IC_AcceptMode == IPRIP_ACCEPT_DISABLED) { continue; }

        pib = pite->ITE_Binding;
        paddr = IPRIP_IF_ADDRESS_TABLE(pib);

        for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {

            if (pite->ITE_Sockets[i] == INVALID_SOCKET) { continue; }


            //
            // enumerate network events to see whether
            // any packets have arrived on this interface
            //

            dwErr = WSAEnumNetworkEvents(pite->ITE_Sockets[i], NULL, &wsane);
            if (dwErr != NO_ERROR) {

                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        RECEIVE, "error %d checking for input on interface %d (%s)",
                        dwErr, pite->ITE_Index, lpszAddr
                        );
                    LOGWARN1(ENUM_NETWORK_EVENTS_FAILED, lpszAddr, dwErr);
                }
                continue;
            }


            //
            // see if the input bit is set
            //

            if (!(wsane.lNetworkEvents & FD_READ)) { continue; }


            //
            // the input flag is set, now see if there was an error
            //

            if (wsane.iErrorCode[FD_READ_BIT] != NO_ERROR) {

                lpszAddr = INET_NTOA(paddr->IA_Address);
                if (lpszAddr != NULL) {
                    TRACE3(
                        RECEIVE, "error %d in input record for interface %d (%s)",
                        wsane.iErrorCode[FD_READ_BIT], pite->ITE_Index, lpszAddr
                        );
                    LOGWARN1(INPUT_RECORD_ERROR, lpszAddr, dwErr);
                }
                continue;
            }


            //
            // there is no error, so process the socket
            //

            ProcessSocket(i, pite, pTable);

        }
    }

    RELEASE_IF_LOCK_SHARED();


    //
    // if dll is not stopping, register input event with NtdllWait thread again
    //
    if (ig.IG_Status != IPRIP_STATUS_STOPPING) {

        
        if (! RegisterWaitForSingleObject(
                  &ig.IG_IpripInputEventHandle,
                  ig.IG_IpripInputEvent,
                  CallbackFunctionNetworkEvents,
                  NULL,
                  INFINITE,
                  (WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE)
                  )) {

            dwErr = GetLastError();
            
            TRACE1(START,
                "error %d registering input event with NtdllWait thread",
                dwErr);
            LOGERR0(REGISTER_WAIT_FAILED, dwErr);
        }
    }


    LEAVE_RIP_WORKER();
}




//----------------------------------------------------------------------------
// Function:            ProcessSocket
//
// This function receives the message on the given socket and queues it
// for processing if the configuration on the receiving interface allows it.
//----------------------------------------------------------------------------

VOID
ProcessSocket(
    DWORD dwAddrIndex,
    PIF_TABLE_ENTRY pite,
    PIF_TABLE pTable
    ) {

    SOCKET sock;
    PPEER_TABLE pPeers;
    IPRIP_PACKET pkt;
    PBYTE pInputPacket;
    CHAR szSrcaddr[20];
    LPSTR lpszAddr = NULL;
    PIPRIP_HEADER pih;
    PINPUT_CONTEXT pwc;
    PIPRIP_IF_STATS pis;
    PIPRIP_IF_CONFIG pic;
    PIPRIP_IF_BINDING pib;
    PIPRIP_IP_ADDRESS paddr;
    PIPRIP_PEER_STATS pps;
    PPEER_TABLE_ENTRY ppte;
    DWORD dwErr, dwSrcaddr;
    SOCKADDR_IN sinInputSource;
    INT i, iInputLength, iAddrLength;


    pwc = NULL;
    pis = &pite->ITE_Stats;
    pic = pite->ITE_Config;
    sock = pite->ITE_Sockets[dwAddrIndex];
    pib = pite->ITE_Binding;
    paddr = IPRIP_IF_ADDRESS_TABLE(pib) + dwAddrIndex;
    pPeers = ig.IG_PeerTable;

    do {


        pInputPacket = pkt.IP_Packet;


        //
        // read the incoming packet
        //

        iAddrLength = sizeof(SOCKADDR_IN);

        iInputLength = recvfrom(
                          sock, pInputPacket, MAX_PACKET_SIZE, 0,
                          (PSOCKADDR)&sinInputSource, &iAddrLength
                          );

        if (iInputLength == 0 || iInputLength == SOCKET_ERROR) {

            dwErr = WSAGetLastError();
            lpszAddr = INET_NTOA(paddr->IA_Address);

            if (lpszAddr != NULL) {
            
                TRACE3(
                    RECEIVE, "error %d receiving packet on interface %d (%s)",
                    dwErr, pite->ITE_Index, lpszAddr
                    );
                LOGERR1(RECVFROM_FAILED, lpszAddr, dwErr);
            }
            
            InterlockedIncrement(&pis->IS_ReceiveFailures);

            break;
        }


        dwSrcaddr = sinInputSource.sin_addr.s_addr;


        //
        // ignore the packet if it is from a local address
        //

        if (GetIfByAddress(pTable, dwSrcaddr, GETMODE_EXACT, NULL) != NULL) {

            break;
        }



        lpszAddr = INET_NTOA(dwSrcaddr);

        if (lpszAddr != NULL) { lstrcpy(szSrcaddr, lpszAddr); }
        else { ZeroMemory(szSrcaddr, sizeof(szSrcaddr)); }

        lpszAddr = INET_NTOA(paddr->IA_Address);
        if (lpszAddr != NULL) {
            TRACE4(
                RECEIVE, "received %d-byte packet from %s on interface %d (%s)",
                iInputLength, szSrcaddr, pite->ITE_Index, lpszAddr
                );
        }


        //
        // the packet must contain at least one entry
        //

        if (iInputLength < MIN_PACKET_SIZE) {

            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE4(
                    RECEIVE,
                    "%d-byte packet from %s on interface %d (%s) is too small",
                    iInputLength, szSrcaddr, pite->ITE_Index, lpszAddr
                    );
                LOGWARN2(PACKET_TOO_SMALL, lpszAddr, szSrcaddr, NO_ERROR);
            }
            break;
        }


        //
        // find out which peer sent this, or create a new peer
        //

        ACQUIRE_PEER_LOCK_EXCLUSIVE();

        dwErr = CreatePeerEntry(pPeers, dwSrcaddr, &ppte);
        if (dwErr == NO_ERROR) {
            pps = &ppte->PTE_Stats;
        }
        else {

            pps = NULL;

            //
            // not a serious error, so go on
            //

            TRACE2(
                RECEIVE, "error %d creating peer statistics entry for %s",
                dwErr, szSrcaddr
                );
        }

        RELEASE_PEER_LOCK_EXCLUSIVE();


        ACQUIRE_PEER_LOCK_SHARED();



        //
        // place a template over the packet
        //

        pih = (PIPRIP_HEADER)pInputPacket;


        //
        // update the peer statistics
        //

        if (pps != NULL) {
            InterlockedExchange(
                &pps->PS_LastPeerUpdateTickCount, GetTickCount()
                );
            InterlockedExchange(
                &pps->PS_LastPeerUpdateVersion, (DWORD)pih->IH_Version
                );
        }


        //
        // discard if the version is invalid, or if the packet is
        // a RIPv1 packet and the reserved field in the header is non-zero
        //

        if (pih->IH_Version == 0) {

            lpszAddr = INET_NTOA(paddr->IA_Address);
            
            if (lpszAddr != NULL) {
                TRACE3(
                    RECEIVE, "invalid version packet from %s on interface %d (%s)",
                    szSrcaddr, pite->ITE_Index, lpszAddr
                    );
                LOGWARNDATA2(
                    PACKET_VERSION_INVALID, lpszAddr, szSrcaddr,
                    iInputLength, pInputPacket
                    );
            }
            
            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }


            RELEASE_PEER_LOCK_SHARED();

            break;
        }
        else
        if (pih->IH_Version == 1 && pih->IH_Reserved != 0) {

            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE3(
                    RECEIVE, "invalid packet header from %s on interface %d (%s)",
                    szSrcaddr, pite->ITE_Index, lpszAddr
                    );
                LOGWARNDATA2(
                    PACKET_HEADER_CORRUPT, lpszAddr, szSrcaddr,
                    iInputLength, pInputPacket
                    );
            }
            
            if (pps != NULL) {
                InterlockedIncrement(&pps->PS_BadResponsePacketsFromPeer);
            }


            RELEASE_PEER_LOCK_SHARED();

            break;
        }


        RELEASE_PEER_LOCK_SHARED();



        //
        // make sure command field is valid, and
        // update statistics on received packets
        //

        if (pih->IH_Command == IPRIP_REQUEST) {

            InterlockedIncrement(&pis->IS_RequestsReceived);
        }
        else
        if (pih->IH_Command == IPRIP_RESPONSE) {

            InterlockedIncrement(&pis->IS_ResponsesReceived);
        }
        else {

            break;
        }



        //
        // allocate and initialize a work-context to be queued
        // and update the receive queue size
        //

        pwc = RIP_ALLOC(sizeof(INPUT_CONTEXT));

        if (pwc == NULL) {

            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE4(
                    RECEIVE,
                    "error %d allocating %d bytes for packet on interface %d (%s)",
                    GetLastError(), sizeof(INPUT_CONTEXT), pite->ITE_Index,
                    lpszAddr
                    );
                LOGERR0(HEAP_ALLOC_FAILED, dwErr);
            }
            break;
        }


        pwc->IC_InterfaceIndex = pite->ITE_Index;
        pwc->IC_AddrIndex = dwAddrIndex;
        pwc->IC_InputSource = sinInputSource;
        pwc->IC_InputLength = iInputLength;
        pwc->IC_InputPacket = pkt;


        //
        // enqueue the packet and source-address as a recv-queue entry
        //

        ACQUIRE_GLOBAL_LOCK_SHARED();

        ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);

        dwErr = EnqueueRecvEntry(
                    ig.IG_RecvQueue, pih->IH_Command, (PBYTE)pwc
                    );

        RELEASE_LIST_LOCK(ig.IG_RecvQueue);

        RELEASE_GLOBAL_LOCK_SHARED();


        if (dwErr != NO_ERROR) {

            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE4(
                    RECEIVE,
                    "error %d queueing data for packet from %s on interface %d (%s)",
                    dwErr, szSrcaddr, pite->ITE_Index, lpszAddr
                    );
            }
            break;
        }


        //
        // enqueue the work-item to process the packet
        //

        dwErr = QueueRipWorker(WorkerFunctionProcessInput, NULL);

        if (dwErr != NO_ERROR) {

            PLIST_ENTRY phead;

            lpszAddr = INET_NTOA(paddr->IA_Address);
            if (lpszAddr != NULL) {
                TRACE4(
                    RECEIVE,
                    "error %d queueing work-item for packet from %s on interface %d (%s)",
                    dwErr, szSrcaddr, pite->ITE_Index, lpszAddr
                    );
                LOGERR0(QUEUE_WORKER_FAILED, dwErr);
            }


            //
            // remove the data that was queued for processing
            //

            ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);

            phead = &ig.IG_RecvQueue->LL_Head;
            RemoveTailList(phead);
            ig.IG_RecvQueueSize -= sizeof(RECV_QUEUE_ENTRY);

            RELEASE_LIST_LOCK(ig.IG_RecvQueue);

            break;
        }


        return;

    } while(FALSE);


    //
    // some cleanup is required if an error brought us here
    //

    if (pwc != NULL) { RIP_FREE(pwc); }

    return;
}

DWORD
ProcessRtmNotification(
    RTM_ENTITY_HANDLE    hRtmHandle,    // not used
    RTM_EVENT_TYPE       retEventType,
    PVOID                pvContext1,    // not used
    PVOID                pvContext2     // not used
    ) {


    DWORD dwErr;

    
    TRACE1(ROUTE, "ENTERED ProcessRtmNotification, event %d", retEventType );

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }


    //
    // only route change notifications are processed
    //
    
    if (retEventType == RTM_CHANGE_NOTIFICATION) {
    
        QueueRipWorker(WorkerFunctionProcessRtmMessage, (PVOID)retEventType);

        dwErr = NO_ERROR;
    }

    else { 
        dwErr = ERROR_NOT_SUPPORTED; 
    }
    
    LEAVE_RIP_API();
    
    TRACE1(ROUTE, "LEAVING ProcessRtmNotification %d", dwErr);
    
    return dwErr;
}



DWORD
BlockDeleteRoutesOnInterface (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex
    )
/*++

Routine Description :

    This routine deletes all the routes learnt by the protocol
    over the specified interface.


Parameters :

    hRtmHandle  - Entity registration handle

    dwIfIndex   - Interface over which routes are to be deleted


Return Value :

    
--*/
{
    HANDLE           hRtmEnum;
    PHANDLE          phRoutes = NULL;
    DWORD            dwHandles, dwFlags, i, dwErr;



    dwErr = RtmCreateRouteEnum(
                hRtmHandle, NULL, RTM_VIEW_MASK_ANY, RTM_ENUM_OWN_ROUTES,
                NULL, RTM_MATCH_INTERFACE, NULL, dwIfIndex, &hRtmEnum
                );

    if ( dwErr != NO_ERROR ) {
        TRACE1(
            ANY, "BlockDeleteRoutesOnInterface: Error %d creating handle",
            dwErr
            );
        
        return dwErr;
    }


    //
    // allocate handle array large enough to hold max handles in an
    // enum
    //
        
    phRoutes = RIP_ALLOC(ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE));

    if ( phRoutes == NULL ) {

        dwErr = GetLastError();

        TRACE2(
            ANY, "BlockDeleteRoutesOnInterface: error %d while "
            "allocating %d bytes to hold max handles in an enum",
            dwErr, ig.IG_RtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
            );

        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }


    do {
        dwHandles = ig.IG_RtmProfile.MaxHandlesInEnum;
        
        dwErr = RtmGetEnumRoutes(
                    hRtmHandle, hRtmEnum, &dwHandles, phRoutes
                    );

        for ( i = 0; i < dwHandles; i++ )
        {
            if ( RtmDeleteRouteToDest(
                    hRtmHandle, phRoutes[i], &dwFlags
                    ) != NO_ERROR ) {
                //
                // If delete is successful, this is automatic
                //

                TRACE2(
                    ANY, "BlockDeleteRoutesOnInterface : error %d deleting"
                    " routes on interface %d", dwErr, dwIfIndex
                    );

                dwErr = RtmReleaseRoutes(hRtmHandle, 1, &phRoutes[i]);

                if (dwErr != NO_ERROR) {
                    TRACE1(ANY, "error %d releasing route", dwErr);
                }
            }
        }
        
    } while (dwErr == NO_ERROR);


    //
    // close enum handles
    //
    
    dwErr = RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);

    if (dwErr != NO_ERROR) {
        TRACE1(
            ANY, "BlockDeleteRoutesOnInterface : error %d closing enum handle",
            dwErr
            );
    }

    if ( phRoutes ) {
        RIP_FREE(phRoutes);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\table.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: table.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
//      V Raman             Oct-3-1996  
//                          Added Deactivate Event to IF_TABLE_ENTRY
//
//      V Raman             Oct-27-1996
//                          Removed Deactivate Event in IF_TABLE_ENTRY
//                          and made interface deactivation synchronous
//
// Contains structures and macros used for table management.
//============================================================================

#ifndef _TABLE_H_
#define _TABLE_H_


#define GETMODE_EXACT   0
#define GETMODE_FIRST   1
#define GETMODE_NEXT    2


//
// TYPE DEFINITIONS FOR INTERFACE MANAGEMENT
//



//
// struct:      IF_TABLE_ENTRY
//
// declares the components of an interface table entry
//
//

typedef struct _IF_TABLE_ENTRY {

    LIST_ENTRY          ITE_LinkByAddress;
    LIST_ENTRY          ITE_LinkByIndex;
    LIST_ENTRY          ITE_HTLinkByIndex;
    NET_INTERFACE_TYPE  ITE_Type;
    DWORD               ITE_Index;
    DWORD               ITE_Flags;
    HANDLE              ITE_FullOrDemandUpdateTimer;
    IPRIP_IF_STATS      ITE_Stats;
    PIPRIP_IF_CONFIG    ITE_Config;
    PIPRIP_IF_BINDING   ITE_Binding;
    SOCKET             *ITE_Sockets;

} IF_TABLE_ENTRY, *PIF_TABLE_ENTRY;



#define ITEFLAG_ENABLED                 ((DWORD)0x00000001)
#define ITEFLAG_BOUND                   ((DWORD)0x00000002)
#define ITEFLAG_FULL_UPDATE_PENDING     ((DWORD)0x00000004)
#define ITEFLAG_FULL_UPDATE_INQUEUE     ((DWORD)0x00000008)

#define IF_IS_ENABLED(i)    \
            ((i)->ITE_Flags & ITEFLAG_ENABLED) 
#define IF_IS_BOUND(i)      \
            ((i)->ITE_Flags & ITEFLAG_BOUND)
#define IF_IS_ACTIVE(i)     \
            (IF_IS_BOUND(i) && IF_IS_ENABLED(i))

#define IF_IS_DISABLED(i)   !IF_IS_ENABLED(i)
#define IF_IS_UNBOUND(i)    !IF_IS_BOUND(i)
#define IF_IS_INACTIVE(i)   !IF_IS_ACTIVE(i)

#define IF_FULL_UPDATE_PENDING(i) \
            ((i)->ITE_Flags & ITEFLAG_FULL_UPDATE_PENDING)
#define IF_FULL_UPDATE_INQUEUE(i) \
            ((i)->ITE_Flags & ITEFLAG_FULL_UPDATE_INQUEUE)




//
// macros and definitions used by interface tables
//

#define IF_HASHTABLE_SIZE       29
#define IF_HASHVALUE(i)         ((i) % IF_HASHTABLE_SIZE)



//
// struct:      IF_TABLE
//
// declares the structure of an interface table. consists of a hash-table
// of IF_TABLE_ENTRY structures hashed on interface index, and a list
// of all activated interfaces ordered by IP address
//
// The IT_CS section is used to synchronize the generation of updates;
// it is acquired when updates are started and finished on interfaces
// in this table, and thus it protects the flags field.
//
// The IT_RWL section is used to synchronize modifications to the table;
// it must be acquired exclusively when entries are being added or deleted
// from the table, and when the states of entries are being changed.
// (e.g. binding, unbinding, enabling and disabling entries).
//
// IT_RWL must be acquired non-exclusively on all other acceses.
//
// When IT_RWL and IT_CS must both be acquired, IT_RWL must be acquired first.
//

typedef struct _IF_TABLE {

    DWORD               IT_Created;
    DWORD               IT_Flags;
    LARGE_INTEGER       IT_LastUpdateTime;
    HANDLE              IT_FinishTriggeredUpdateTimer;
    HANDLE              IT_FinishFullUpdateTimer;
    CRITICAL_SECTION    IT_CS;
    READ_WRITE_LOCK     IT_RWL;
    LIST_ENTRY          IT_ListByAddress;
    LIST_ENTRY          IT_ListByIndex;
    LIST_ENTRY          IT_HashTableByIndex[IF_HASHTABLE_SIZE];

} IF_TABLE, *PIF_TABLE;


//
// constants and macros used for the flags field
//

#define IPRIP_FLAG_FULL_UPDATE_PENDING          ((DWORD)0x00000001)
#define IPRIP_FLAG_TRIGGERED_UPDATE_PENDING     ((DWORD)0x00000002)

#define IPRIP_FULL_UPDATE_PENDING(t)            \
    ((t)->IT_Flags & IPRIP_FLAG_FULL_UPDATE_PENDING)

#define IPRIP_TRIGGERED_UPDATE_PENDING(t)       \
    ((t)->IT_Flags & IPRIP_FLAG_TRIGGERED_UPDATE_PENDING)


DWORD
CreateIfTable(
    PIF_TABLE pTable
    );

DWORD
DeleteIfTable(
    PIF_TABLE pTable
    );

DWORD
CreateIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    NET_INTERFACE_TYPE dwIfType,
    PIPRIP_IF_CONFIG pConfig,
    PIF_TABLE_ENTRY *ppEntry
    );

DWORD
DeleteIfEntry(
    PIF_TABLE pIfTable,
    DWORD dwIndex
    );

DWORD
ValidateIfConfig(
    PIPRIP_IF_CONFIG pic
    );

DWORD
CreateIfSocket(
    PIF_TABLE_ENTRY pITE
    );

DWORD
DeleteIfSocket(
    PIF_TABLE_ENTRY pITE
    );

DWORD
BindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    );

DWORD
UnBindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

DWORD
EnableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

DWORD
ConfigureIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIPRIP_IF_CONFIG pConfig
    );

DWORD
DisableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

PIF_TABLE_ENTRY
GetIfByIndex(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

PIF_TABLE_ENTRY
GetIfByAddress(
    PIF_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    );

PIF_TABLE_ENTRY
GetIfByListIndex(
    PIF_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    );


#define IF_TABLE_CREATED(pTable) ((pTable)->IT_Created == 0x12345678)



//
// TYPE DEFINITIONS FOR THE PEER STATISTICS HASH TABLE
//

//
// struct:      PEER_TABLE_ENTRY
//
// declares the structure of each entry in the peer table
//
typedef struct _PEER_TABLE_ENTRY {

    LIST_ENTRY          PTE_LinkByAddress;
    LIST_ENTRY          PTE_HTLinkByAddress;
    DWORD               PTE_Address;
    IPRIP_PEER_STATS    PTE_Stats;

} PEER_TABLE_ENTRY, *PPEER_TABLE_ENTRY;



//
// macros and definitions used by peer statistics tables
//

#define PEER_HASHTABLE_SIZE     29
#define PEER_HASHVALUE(a)                                                   \
            (((a) +                                                         \
             ((a) >> 8) +                                                   \
             ((a) >> 16) +                                                  \
             ((a) >> 24)) % PEER_HASHTABLE_SIZE)



//
// struct:      PEER_TABLE
//
// this table contains the entries for keeping statistics about each peer.
// it consists of a hash-table of peer stats (for fast direct access to
// a specific entry) and a list of peer stats entries ordered by address
// (for easy enumeration via MibGetNext)
//

typedef struct _PEER_TABLE {

    READ_WRITE_LOCK PT_RWL;
    DWORD           PT_Created;
    LIST_ENTRY      PT_ListByAddress;
    LIST_ENTRY      PT_HashTableByAddress[PEER_HASHTABLE_SIZE];

} PEER_TABLE, *PPEER_TABLE;


DWORD
CreatePeerTable(
    PPEER_TABLE pTable
    );

DWORD
DeletePeerTable(
    PPEER_TABLE pTable
    );

DWORD
CreatePeerEntry(
    PPEER_TABLE pTable,
    DWORD dwAddress,
    PPEER_TABLE_ENTRY *ppEntry
    );

DWORD
DeletePeerEntry(
    PPEER_TABLE pTable,
    DWORD dwAddress
    );

PPEER_TABLE_ENTRY
GetPeerByAddress(
    PPEER_TABLE pTable,
    DWORD dwAddress,
    DWORD dwGetMode,
    PDWORD pdwErr
    );


#define  PEER_TABLE_CREATED(pTable)  ((pTable)->PT_Created == 0x12345678)



//
// TYPE DEFINITIONS FOR THE ROUTE TABLE USED FOR NETWORK SUMMARY
//

//
// struct:      ROUTE_TABLE_ENTRY
//
// declares the structure of each entry in the route table
//
typedef struct _ROUTE_TABLE_ENTRY {

    LIST_ENTRY      RTE_Link;
    DWORD           RTE_TTL;
    DWORD           RTE_HoldTTL;
    RIP_IP_ROUTE    RTE_Route;

} ROUTE_TABLE_ENTRY, *PROUTE_TABLE_ENTRY;

//
// declares the structure of the protocol specific data
//

//
// macros and definitions used by the route table
//

//
// These flags are used in the ProtocolSpecificData array
// to distinguish routes pending expiration from routes pending removal,
// and to store the route tag for each route.
// The first DWORD in the PSD_Data array is treated here as a byte-array;
// the first two bytes are used to store the route tag;
// the third byte is used to store the route flag
//

#define PSD(route)                  (route)->RR_ProtocolSpecificData.PSD_Data
#define PSD_TAG0                    0
#define PSD_TAG1                    1
#define PSD_FLAG                    2

#define ROUTEFLAG_SUMMARY           ((BYTE)0x03)


#define SETROUTEFLAG(route, flag)   (((PBYTE)&PSD(route))[PSD_FLAG] = (flag))

#define GETROUTEFLAG(route)         ((PBYTE)&PSD(route))[PSD_FLAG]


#define SETROUTETAG(route, tag) \
        ((PBYTE)&PSD(route))[PSD_TAG0] = LOBYTE(tag), \
        ((PBYTE)&PSD(route))[PSD_TAG1] = HIBYTE(tag)

#define GETROUTETAG(route) \
        MAKEWORD(((PBYTE)&PSD(route))[PSD_TAG0],((PBYTE)&PSD(route))[PSD_TAG1])


#define SETROUTEMETRIC(route, metric)   \
        (route)->RR_FamilySpecificData.FSD_Metric1 = (metric)

#define GETROUTEMETRIC(route)   \
        (route)->RR_FamilySpecificData.FSD_Metric1


#define COMPUTE_ROUTE_METRIC(route) \
        (route)->RR_FamilySpecificData.FSD_Metric = \
        (route)->RR_FamilySpecificData.FSD_Metric1



//
// Macros to manipulate entity specific info in RTMv2 routes
//

#define ESD(route)                  (route)->EntitySpecificInfo
#define ESD_TAG0                    0
#define ESD_TAG1                    1
#define ESD_FLAG                    2

#define SETRIPFLAG(route, flag)     (((PBYTE)&ESD(route))[ESD_FLAG] = (flag))
    
#define GETRIPFLAG(route)           ((PBYTE)&ESD(route))[ESD_FLAG]

#define SETRIPTAG(route, tag)   \
        ((PBYTE)&ESD(route))[ESD_TAG0] = LOBYTE(tag), \
        ((PBYTE)&ESD(route))[ESD_TAG1] = HIBYTE(tag)

#define GETRIPTAG(route) \
        MAKEWORD(((PBYTE)&ESD(route))[ESD_TAG0],((PBYTE)&ESD(route))[ESD_TAG1])



#define ROUTE_HASHTABLE_SIZE  29
#define ROUTE_HASHVALUE(a)                                                  \
            (((a) +                                                         \
             ((a) >> 8) +                                                   \
             ((a) >> 16) +                                                  \
             ((a) >> 24)) % ROUTE_HASHTABLE_SIZE)


//
// struct:      ROUTE_TABLE
//
// declares the structure of a route table, which consists of a hash-table
// of routes hashed on the destination network. Note that no synchronization
// is included since this structure is only used during full-updates, to
// store summary routes, and at most one thread may be sending a full-update
// at any given time.
//

typedef struct _ROUTE_TABLE {

    DWORD       RT_Created;
    LIST_ENTRY  RT_HashTableByNetwork[ROUTE_HASHTABLE_SIZE];

} ROUTE_TABLE, *PROUTE_TABLE;


DWORD
CreateRouteTable(
    PROUTE_TABLE pTable
    );

DWORD
DeleteRouteTable(
    PROUTE_TABLE pTable
    );

DWORD
WriteSummaryRoutes(
    PROUTE_TABLE pTable,
    HANDLE hRtmHandle
    );

DWORD
CreateRouteEntry(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute,
    DWORD dwTTL,
    DWORD dwHoldTTL
    );

DWORD
DeleteRouteEntry(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute
    );

PROUTE_TABLE_ENTRY
GetRouteByRoute(
    PROUTE_TABLE pTable,
    PRIP_IP_ROUTE pRoute
    );

#define ROUTE_TABLE_CREATED(pTable)     ((pTable)->RT_Created == 0x12345678)



//
// TYPE DEFINITIONS FOR BINDING TABLE
//


//
// struct:      BINDING_TABLE_ENTRY
//
// this entry contains a single binding.
// a binding entry consists of an IP address, a network number (found
// using the network class mask, not the subnet mask),
// and a subnet mask.
// All of the above are available when an interface is bound.
// When a route arrives and its mask is to be guessed, its network number
// can be computed (using the routes network class mask); we then search
// the binding table for matching networks, and for each one we compare 
//     (stored subnet mask) AND (interface IP address)
// to
//     (stored subnet mask) AND (incoming route IP address).
// When we find a match, (stored subnet mask) is our guess.
//

typedef struct _BINDING_TABLE_ENTRY {

    DWORD       BTE_Address;
    DWORD       BTE_Network;
    DWORD       BTE_Netmask;
    LIST_ENTRY  BTE_Link;

} BINDING_TABLE_ENTRY, *PBINDING_TABLE_ENTRY;



#define BINDING_HASHTABLE_SIZE  29
#define BINDING_HASHVALUE(a)                                                \
            (((a) +                                                         \
             ((a) >> 8) +                                                   \
             ((a) >> 16) +                                                  \
             ((a) >> 24)) % BINDING_HASHTABLE_SIZE)


//
// struct:      BINDING_TABLE
// 
// this table is used to store binding information that is used to guess
// the subnet masks of incoming routes. it contains the bindings of all
// interfaces which have been added to IPRIP, in an array to speed up access
//

typedef struct _BINDING_TABLE {

    READ_WRITE_LOCK     BT_RWL;
    DWORD               BT_Created;
    LIST_ENTRY          BT_HashTableByNetwork[BINDING_HASHTABLE_SIZE];

} BINDING_TABLE, *PBINDING_TABLE;


#define BINDING_TABLE_CREATED(b)    ((b)->BT_Created == 0x12345678)

DWORD
CreateBindingTable(
    PBINDING_TABLE pTable
    );

DWORD
DeleteBindingTable(
    PBINDING_TABLE pTable
    );

DWORD
CreateBindingEntry(
    PBINDING_TABLE pTable,
    PIPRIP_IF_BINDING pib
    );

DWORD
DeleteBindingEntry(
    PBINDING_TABLE pTable,
    PIPRIP_IF_BINDING pib
    );

DWORD
GuessSubnetMask(
    DWORD dwAddress,
    PDWORD pdwNetclassMask
    );

DWORD
AddRtmRoute(
    RTM_ENTITY_HANDLE   hRtmHandle,
    PRIP_IP_ROUTE       prir,
    RTM_NEXTHOP_HANDLE  hNextHop            OPTIONAL,
    DWORD               dwTimeOut,
    DWORD               dwHoldTime,
    BOOL                bActive
    );

DWORD
GetRouteInfo(
    IN  RTM_ROUTE_HANDLE    hRoute,
    IN  PRTM_ROUTE_INFO     pInRouteInfo    OPTIONAL,
    IN  PRTM_DEST_INFO      pInDestInfo     OPTIONAL,
    OUT PRIP_IP_ROUTE       pRoute
    );

#endif // _TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ripagnt\mibentry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibentry.h

Abstract:

    Sample subagent mib structures.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#ifndef _MIBENTRY_H_
#define _MIBENTRY_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry indices                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define mi_global                               0
#define mi_globalSystemRouteChanges             mi_global+1                           
#define mi_globalTotalResponseSends             mi_globalSystemRouteChanges+1
#define mi_globalLoggingLevel                   mi_globalTotalResponseSends+1
#define mi_globalMaxRecQueueSize                mi_globalLoggingLevel+1
#define mi_globalMaxSendQueueSize               mi_globalMaxRecQueueSize+1
#define mi_globalMinTriggeredUpdateInterval     mi_globalMaxSendQueueSize+1
#define mi_globalPeerFilterMode                 mi_globalMinTriggeredUpdateInterval+1
#define mi_globalPeerFilterCount                mi_globalPeerFilterMode+1
#define mi_globalPeerFilterTable                mi_globalPeerFilterCount+1
#define mi_globalPeerFilterEntry                mi_globalPeerFilterTable+1
#define mi_globalPFAddr                         mi_globalPeerFilterEntry+1
#define mi_globalPFTag                          mi_globalPFAddr+1
#define mi_interface                            mi_globalPFTag+1
#define mi_ifStatsTable                         mi_interface+1
#define mi_ifStatsEntry                         mi_ifStatsTable+1 
#define mi_ifSEIndex                            mi_ifStatsEntry+1
#define mi_ifSEState                            mi_ifSEIndex+1 
#define mi_ifSESendFailures                     mi_ifSEState+1
#define mi_ifSEReceiveFailures                  mi_ifSESendFailures+1
#define mi_ifSERequestSends                     mi_ifSEReceiveFailures+1
#define mi_ifSERequestReceiveds                 mi_ifSERequestSends+1 
#define mi_ifSEResponseSends                    mi_ifSERequestReceiveds+1
#define mi_ifSEResponseReceiveds                mi_ifSEResponseSends+1
#define mi_ifSEBadResponsePacketReceiveds       mi_ifSEResponseReceiveds+1
#define mi_ifSEBadResponseEntriesReceiveds      mi_ifSEBadResponsePacketReceiveds+1
#define mi_ifSETriggeredUpdateSends             mi_ifSEBadResponseEntriesReceiveds+1
#define mi_ifConfigTable                        mi_ifSETriggeredUpdateSends+1
#define mi_ifConfigEntry                        mi_ifConfigTable+1
#define mi_ifCEIndex                            mi_ifConfigEntry+1
#define mi_ifCEState                            mi_ifCEIndex+1
#define mi_ifCEMetric                           mi_ifCEState+1
#define mi_ifCEUpdateMode                       mi_ifCEMetric+1
#define mi_ifCEAcceptMode                       mi_ifCEUpdateMode+1
#define mi_ifCEAnnounceMode                     mi_ifCEAcceptMode+1 
#define mi_ifCEProtocolFlags                    mi_ifCEAnnounceMode+1
#define mi_ifCERouteExpirationInterval          mi_ifCEProtocolFlags+1
#define mi_ifCERouteRemovalInterval             mi_ifCERouteExpirationInterval+1
#define mi_ifCEFullUpdateInterval               mi_ifCERouteRemovalInterval+1
#define mi_ifCEAuthenticationType               mi_ifCEFullUpdateInterval+1
#define mi_ifCEAuthenticationKey                mi_ifCEAuthenticationType+1
#define mi_ifCERouteTag                         mi_ifCEAuthenticationKey+1
#define mi_ifCEUnicastPeerMode                  mi_ifCERouteTag+1
#define mi_ifCEAcceptFilterMode                 mi_ifCEUnicastPeerMode+1
#define mi_ifCEAnnounceFilterMode               mi_ifCEAcceptFilterMode+1
#define mi_ifCEUnicastPeerCount                 mi_ifCEAnnounceFilterMode+1
#define mi_ifCEAcceptFilterCount                mi_ifCEUnicastPeerCount+1 
#define mi_ifCEAnnounceFilterCount              mi_ifCEAcceptFilterCount+1 
#define mi_ifUnicastPeersTable                  mi_ifCEAnnounceFilterCount+1 
#define mi_ifUnicastPeersEntry                  mi_ifUnicastPeersTable+1
#define mi_ifUPIfIndex                          mi_ifUnicastPeersEntry+1
#define mi_ifUPAddress                          mi_ifUPIfIndex+1
#define mi_ifUPTag                              mi_ifUPAddress+1
#define mi_ifAcceptRouteFilterTable             mi_ifUPTag+1
#define mi_ifAcceptRouteFilterEntry             mi_ifAcceptRouteFilterTable+1
#define mi_ifAcceptRFIfIndex                    mi_ifAcceptRouteFilterEntry+1
#define mi_ifAcceptRFLoAddress                  mi_ifAcceptRFIfIndex+1
#define mi_ifAcceptRFHiAddress                  mi_ifAcceptRFLoAddress+1
#define mi_ifAcceptRFTag                        mi_ifAcceptRFHiAddress+1
#define mi_ifAnnounceRouteFilterTable           mi_ifAcceptRFTag+1
#define mi_ifAnnounceRouteFilterEntry           mi_ifAnnounceRouteFilterTable+1
#define mi_ifAnnounceRFIfIndex                   mi_ifAnnounceRouteFilterEntry+1 
#define mi_ifAnnounceRFLoAddress                mi_ifAnnounceRFIfIndex+1 
#define mi_ifAnnounceRFHiAddress                mi_ifAnnounceRFLoAddress+1
#define mi_ifAnnounceRFTag                      mi_ifAnnounceRFHiAddress+1
#define mi_ifBindingTable                       mi_ifAnnounceRFTag+1 
#define mi_ifBindingEntry                       mi_ifBindingTable+1
#define mi_ifBindingIndex                       mi_ifBindingEntry+1
#define mi_ifBindingState                       mi_ifBindingIndex+1
#define mi_ifBindingCounts                      mi_ifBindingState+1 
#define mi_ifAddressTable                       mi_ifBindingCounts+1
#define mi_ifAddressEntry                       mi_ifAddressTable+1
#define mi_ifAEIfIndex                          mi_ifAddressEntry+1 
#define mi_ifAEAddress                          mi_ifAEIfIndex+1
#define mi_ifAEMask                             mi_ifAEAddress+1
#define mi_peer                                 mi_ifAEMask+1
#define mi_ifPeerStatsTable                     mi_peer+1
#define mi_ifPeerStatsEntry                     mi_ifPeerStatsTable+1
#define mi_ifPSAddress                          mi_ifPeerStatsEntry+1
#define mi_ifPSLastPeerRouteTag                 mi_ifPSAddress+1
#define mi_ifPSLastPeerUpdateTickCount          mi_ifPSLastPeerRouteTag+1
#define mi_ifPSLastPeerUpdateVersion            mi_ifPSLastPeerUpdateTickCount+1
#define mi_ifPSPeerBadResponsePackets           mi_ifPSLastPeerUpdateVersion+1
#define mi_ifPSPeerBadResponseEntries           mi_ifPSPeerBadResponsePackets+1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalPeerFilterEntry table (1.3.6.1.4.1.311.1.11.1.9.1)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_globalPeerFilterEntry                2
#define ni_globalPeerFilterEntry                1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.11.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifStatsEntry                         11
#define ni_ifStatsEntry                         1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.11.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifConfigEntry                        19
#define ni_ifConfigEntry                        1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifUnicastPeersEntry table (1.3.6.1.4.1.311.1.11.2.3.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifUnicastPeersEntry                  3
#define ni_ifUnicastPeersEntry                  2

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAcceptRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.4.1)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifAcceptRouteFilterEntry             4
#define ni_ifAcceptRouteFilterEntry             3

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAnnounceRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.5.1)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifAnnounceRouteFilterEntry           4
#define ni_ifAnnounceRouteFilterEntry           3

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.11.2.6.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifBindingEntry                       3
#define ni_ifBindingEntry                       1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.11.2.7.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifAddressEntry                       3
#define ni_ifAddressEntry                       3

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifPeerStatsEntry table (1.3.6.1.4.1.311.1.11.3.1.1)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifPeerStatsEntry                     6
#define ni_ifPeerStatsEntry                     1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Other definitions                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
                             
#define d_globalLoggingLevel_none                   1
#define d_globalLoggingLevel_error                  2
#define d_globalLoggingLevel_warning                3
#define d_globalLoggingLevel_information            4
#define d_globalPeerFilterMode_disable              1
#define d_globalPeerFilterMode_include              2
#define d_globalPeerFilterMode_exclude              3
#define d_ifSEState_enabled                         1
#define d_ifSEState_bound                           2
#define d_ifCEState_enabled                         1
#define d_ifCEState_bound                           2
#define d_ifCEUpdateMode_periodic                   1
#define d_ifCEUpdateMode_demand                     2
#define d_ifCEAcceptMode_disable                    1
#define d_ifCEAcceptMode_rip1                       2
#define d_ifCEAcceptMode_rip1Compat                 3
#define d_ifCEAcceptMode_rip2                       4
#define d_ifCEAnnounceMode_disable                  1
#define d_ifCEAnnounceMode_rip1                     2
#define d_ifCEAnnounceMode_rip1Compat               3
#define d_ifCEAnnounceMode_rip2                     4
#define d_ifCEAuthenticationType_noAuthentication   1
#define d_ifCEAuthenticationType_simplePassword     2
#define d_ifCEAuthenticationType_md5                3
#define d_ifCEUnicastPeerMode_disable               1
#define d_ifCEUnicastPeerMode_peerAlso              2
#define d_ifCEUnicastPeerMode_peerOnly              3
#define d_ifCEAcceptFilterMode_disable              1
#define d_ifCEAcceptFilterMode_include              2
#define d_ifCEAcceptFilterMode_exclude              3
#define d_ifCEAnnounceFilterMode_disable            1
#define d_ifCEAnnounceFilterMode_include            2
#define d_ifCEAnnounceFilterMode_exclude            3
#define d_ifBindingState_enabled                    1
#define d_ifBindingState_bound                      2

#define d_Tag_create                                1
#define d_Tag_delete                                2

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Declaration of supported view                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern SnmpMibView v_msiprip2; 

#endif // _MIBENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ripagnt\mibentry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibentry.c

Abstract:

    Sample subagent mib structures.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#include "precomp.h"
#pragma hdrstop


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_msiprip2[]                          = {1,3,6,1,4,1,311,1,11};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group (1.3.6.1.4.1.311.1.11.1)                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_global[]                              = {1,0};
static UINT ids_globalSystemRouteChanges[]            = {1,1,0};
static UINT ids_globalTotalResponseSends[]            = {1,2,0};
static UINT ids_globalLoggingLevel[]                  = {1,3,0};
static UINT ids_globalMaxRecQueueSize[]               = {1,4,0};
static UINT ids_globalMaxSendQueueSize[]              = {1,5,0};
static UINT ids_globalMinTriggeredUpdateInterval[]    = {1,6,0};
static UINT ids_globalPeerFilterMode[]                = {1,7,0};
static UINT ids_globalPeerFilterCount[]               = {1,8,0};
static UINT ids_globalPeerFilterTable[]               = {1,9,0};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalPeerFilterEntry table (1.3.6.1.4.1.311.1.11.1.9.1)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_globalPeerFilterEntry[]               = {1,9,1};
static UINT ids_globalPFAddr[]                        = {1,9,1,1};
static UINT ids_globalPFTag[]                         = {1,9,1,2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// interface group (1.3.6.1.4.1.311.1.11.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_interface[]                           = {2,0};
static UINT ids_ifStatsTable[]                        = {2,1,0};
static UINT ids_ifConfigTable[]                       = {2,2,0};
static UINT ids_ifUnicastPeersTable[]                 = {2,3,0};
static UINT ids_ifAcceptRouteFilterTable[]            = {2,4,0};
static UINT ids_ifAnnounceRouteFilterTable[]          = {2,5,0};
static UINT ids_ifBindingTable[]                      = {2,6,0};
static UINT ids_ifAddressTable[]                      = {2,7,0};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.11.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifStatsEntry[]                        = {2,1,1};
static UINT ids_ifSEIndex[]                           = {2,1,1,1};
static UINT ids_ifSEState[]                           = {2,1,1,2};
static UINT ids_ifSESendFailures[]                    = {2,1,1,3};
static UINT ids_ifSEReceiveFailures[]                 = {2,1,1,4};
static UINT ids_ifSERequestSends[]                    = {2,1,1,5};
static UINT ids_ifSERequestReceiveds[]                = {2,1,1,6};
static UINT ids_ifSEResponseSends[]                   = {2,1,1,7};
static UINT ids_ifSEResponseReceiveds[]               = {2,1,1,8};
static UINT ids_ifSEBadResponsePacketReceiveds[]      = {2,1,1,9};
static UINT ids_ifSEBadResponseEntriesReceiveds[]     = {2,1,1,10};
static UINT ids_ifSETriggeredUpdateSends[]            = {2,1,1,11};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.11.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifConfigEntry[]                       = {2,2,1};
static UINT ids_ifCEIndex[]                           = {2,2,1,1};
static UINT ids_ifCEState[]                           = {2,2,1,2};
static UINT ids_ifCEMetric[]                          = {2,2,1,3};
static UINT ids_ifCEUpdateMode[]                      = {2,2,1,4};
static UINT ids_ifCEAcceptMode[]                      = {2,2,1,5};
static UINT ids_ifCEAnnounceMode[]                    = {2,2,1,6};
static UINT ids_ifCEProtocolFlags[]                   = {2,2,1,7};
static UINT ids_ifCERouteExpirationInterval[]         = {2,2,1,8};
static UINT ids_ifCERouteRemovalInterval[]            = {2,2,1,9};
static UINT ids_ifCEFullUpdateInterval[]              = {2,2,1,10};
static UINT ids_ifCEAuthenticationType[]              = {2,2,1,11};
static UINT ids_ifCEAuthenticationKey[]               = {2,2,1,12};
static UINT ids_ifCERouteTag[]                        = {2,2,1,13};
static UINT ids_ifCEUnicastPeerMode[]                 = {2,2,1,14};
static UINT ids_ifCEAcceptFilterMode[]                = {2,2,1,15};
static UINT ids_ifCEAnnounceFilterMode[]              = {2,2,1,16};
static UINT ids_ifCEUnicastPeerCount[]                = {2,2,1,17};
static UINT ids_ifCEAcceptFilterCount[]               = {2,2,1,18};
static UINT ids_ifCEAnnounceFilterCount[]             = {2,2,1,19};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifUnicastPeersEntry table (1.3.6.1.4.1.311.1.11.2.3.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifUnicastPeersEntry[]                 = {2,3,1};
static UINT ids_ifUPIfIndex[]                         = {2,3,1,1};
static UINT ids_ifUPAddress[]                         = {2,3,1,2};
static UINT ids_ifUPTag[]                             = {2,3,1,3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAcceptRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.4.1)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifAcceptRouteFilterEntry[]            = {2,4,1};
static UINT ids_ifAcceptRFIfIndex[]                   = {2,4,1,1};
static UINT ids_ifAcceptRFLoAddress[]                 = {2,4,1,2};
static UINT ids_ifAcceptRFHiAddress[]                 = {2,4,1,3};
static UINT ids_ifAcceptRFTag[]                       = {2,4,1,4};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAnnounceRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.5.1)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifAnnounceRouteFilterEntry[]          = {2,5,1};
static UINT ids_ifAnnounceRFIfIndex[]                  = {2,5,1,1};
static UINT ids_ifAnnounceRFLoAddress[]               = {2,5,1,2};
static UINT ids_ifAnnounceRFHiAddress[]               = {2,5,1,3};
static UINT ids_ifAnnounceRFTag[]                     = {2,5,1,4};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.11.2.6.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifBindingEntry[]                      = {2,6,1};
static UINT ids_ifBindingIndex[]                      = {2,6,1,1};
static UINT ids_ifBindingState[]                      = {2,6,1,2};
static UINT ids_ifBindingCounts[]                     = {2,6,1,3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.11.2.7.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifAddressEntry[]                      = {2,7,1};
static UINT ids_ifAEIfIndex[]                         = {2,7,1,1};
static UINT ids_ifAEAddress[]                         = {2,7,1,2};
static UINT ids_ifAEMask[]                            = {2,7,1,3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// peer group (1.3.6.1.4.1.311.1.11.3)                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_peer[]                                = {3,0};    
static UINT ids_ifPeerStatsTable[]                    = {3,1,0};    

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifPeerStatsEntry table (1.3.6.1.4.1.311.1.11.3.1.1)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifPeerStatsEntry[]                    = {3,1,1};    
static UINT ids_ifPSAddress[]                         = {3,1,1,1};    
static UINT ids_ifPSLastPeerRouteTag[]                = {3,1,1,2};    
static UINT ids_ifPSLastPeerUpdateTickCount[]         = {3,1,1,3};    
static UINT ids_ifPSLastPeerUpdateVersion[]           = {3,1,1,4};    
static UINT ids_ifPSPeerBadResponsePackets[]          = {3,1,1,5};    
static UINT ids_ifPSPeerBadResponseEntries[]          = {3,1,1,6};    

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_msiprip2[] = {
    MIB_GROUP(global),
        MIB_COUNTER(globalSystemRouteChanges),
        MIB_COUNTER(globalTotalResponseSends),
        MIB_INTEGER_RW(globalLoggingLevel),
        MIB_INTEGER_RW(globalMaxRecQueueSize),
        MIB_INTEGER_RW(globalMaxSendQueueSize),
        MIB_TIMETICKS_RW(globalMinTriggeredUpdateInterval),
        MIB_INTEGER_RW(globalPeerFilterMode),
        MIB_INTEGER(globalPeerFilterCount),
        MIB_TABLE_ROOT(globalPeerFilterTable),
            MIB_TABLE_ENTRY(globalPeerFilterEntry),
                MIB_IPADDRESS_RW(globalPFAddr),
                MIB_INTEGER(globalPFTag),
    MIB_GROUP(interface),
        MIB_TABLE_ROOT(ifStatsTable), 
            MIB_TABLE_ENTRY(ifStatsEntry),
                MIB_INTEGER(ifSEIndex), 
                MIB_INTEGER(ifSEState),
                MIB_COUNTER(ifSESendFailures),
                MIB_COUNTER(ifSEReceiveFailures),
                MIB_COUNTER(ifSERequestSends), 
                MIB_COUNTER(ifSERequestReceiveds),
                MIB_COUNTER(ifSEResponseSends),
                MIB_COUNTER(ifSEResponseReceiveds),
                MIB_COUNTER(ifSEBadResponsePacketReceiveds),
                MIB_COUNTER(ifSEBadResponseEntriesReceiveds),
                MIB_COUNTER(ifSETriggeredUpdateSends),
        MIB_TABLE_ROOT(ifConfigTable),
            MIB_TABLE_ENTRY(ifConfigEntry),
                MIB_INTEGER(ifCEIndex),
                MIB_INTEGER(ifCEState),
                MIB_INTEGER_RW(ifCEMetric),
                MIB_INTEGER_RW(ifCEUpdateMode),
                MIB_INTEGER_RW(ifCEAcceptMode), 
                MIB_INTEGER_RW(ifCEAnnounceMode),
                MIB_INTEGER_RW(ifCEProtocolFlags),
                MIB_TIMETICKS_RW(ifCERouteExpirationInterval),
                MIB_TIMETICKS_RW(ifCERouteRemovalInterval),
                MIB_TIMETICKS_RW(ifCEFullUpdateInterval),
                MIB_INTEGER_RW(ifCEAuthenticationType),
                MIB_OCTETSTRING_RW_L(ifCEAuthenticationKey,0,16), 
                MIB_INTEGER_RW(ifCERouteTag),
                MIB_INTEGER_RW(ifCEUnicastPeerMode),
                MIB_INTEGER_RW(ifCEAcceptFilterMode),
                MIB_INTEGER_RW(ifCEAnnounceFilterMode),
                MIB_INTEGER(ifCEUnicastPeerCount), 
                MIB_INTEGER(ifCEAcceptFilterCount), 
                MIB_INTEGER(ifCEAnnounceFilterCount), 
        MIB_TABLE_ROOT(ifUnicastPeersTable),
            MIB_TABLE_ENTRY(ifUnicastPeersEntry),
                MIB_INTEGER(ifUPIfIndex),
                MIB_IPADDRESS_RW(ifUPAddress),
                MIB_INTEGER(ifUPTag),
        MIB_TABLE_ROOT(ifAcceptRouteFilterTable), 
            MIB_TABLE_ENTRY(ifAcceptRouteFilterEntry),
                MIB_INTEGER(ifAcceptRFIfIndex),
                MIB_IPADDRESS_RW(ifAcceptRFLoAddress),
                MIB_IPADDRESS_RW(ifAcceptRFHiAddress),
                MIB_INTEGER(ifAcceptRFTag),
        MIB_TABLE_ROOT(ifAnnounceRouteFilterTable),
            MIB_TABLE_ENTRY(ifAnnounceRouteFilterEntry), 
                MIB_INTEGER(ifAnnounceRFIfIndex), 
                MIB_IPADDRESS_RW(ifAnnounceRFLoAddress),
                MIB_IPADDRESS_RW(ifAnnounceRFHiAddress),
                MIB_INTEGER(ifAnnounceRFTag),
        MIB_TABLE_ROOT(ifBindingTable),
            MIB_TABLE_ENTRY(ifBindingEntry),
                MIB_INTEGER(ifBindingIndex),
                MIB_INTEGER(ifBindingState), 
                MIB_COUNTER(ifBindingCounts),
        MIB_TABLE_ROOT(ifAddressTable),
            MIB_TABLE_ENTRY(ifAddressEntry), 
                MIB_INTEGER(ifAEIfIndex),
                MIB_IPADDRESS(ifAEAddress),
                MIB_IPADDRESS(ifAEMask),
    MIB_GROUP(peer),
        MIB_TABLE_ROOT(ifPeerStatsTable),
            MIB_TABLE_ENTRY(ifPeerStatsEntry),
                MIB_IPADDRESS(ifPSAddress),
                MIB_INTEGER(ifPSLastPeerRouteTag),
                MIB_TIMETICKS(ifPSLastPeerUpdateTickCount),
                MIB_INTEGER_L(ifPSLastPeerUpdateVersion,0,255),
                MIB_COUNTER(ifPSPeerBadResponsePackets),
                MIB_COUNTER(ifPSPeerBadResponseEntries),
    MIB_END()
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_msiprip2[] = {
    MIB_TABLE(msiprip2,globalPeerFilterEntry,NULL),
    MIB_TABLE(msiprip2,ifStatsEntry,NULL),
    MIB_TABLE(msiprip2,ifConfigEntry,NULL),
    MIB_TABLE(msiprip2,ifUnicastPeersEntry,NULL),
    MIB_TABLE(msiprip2,ifAcceptRouteFilterEntry,NULL),
    MIB_TABLE(msiprip2,ifAnnounceRouteFilterEntry,NULL),
    MIB_TABLE(msiprip2,ifBindingEntry,NULL),
    MIB_TABLE(msiprip2,ifAddressEntry,NULL),
    MIB_TABLE(msiprip2,ifPeerStatsEntry,NULL)
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib view                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibView v_msiprip2 = MIB_VIEW(msiprip2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ripagnt\load.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    testdll.c

Abstract:

    Sample SNMP subagent.

--*/

#include "precomp.h"
#pragma hdrstop


#if defined( MIB_DEBUG )

DWORD               g_dwTraceId     = INVALID_TRACEID;

#endif

MIB_SERVER_HANDLE   g_hMIBServer    = ( MIB_SERVER_HANDLE) NULL;

//
// Critical section to protect MIB server handle
//

CRITICAL_SECTION    g_CS;

//
// Extension Agent DLLs need access to elapsed time agent has been active.
// This is implemented by initializing the Extension Agent with a time zero
// reference, and allowing the agent to compute elapsed time by subtracting
// the time zero reference from the current system time.  
//

DWORD g_uptimeReference = 0;

//
// Handle to Subagent Framework 
//

SnmpTfxHandle g_tfxHandle;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Subagent entry points                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL 
SnmpExtensionInit(
    IN     DWORD                 uptimeReference,
       OUT HANDLE *              lpPollForTrapEvent,
       OUT AsnObjectIdentifier * lpFirstSupportedView
    )
{
    DWORD       dwRes   = (DWORD) -1;

#if defined( MIB_DEBUG )

    //
    // tracing for DEBUG
    //
    
    g_dwTraceId = TraceRegister( "IPRIPMIB" );
#endif

    g_hMIBServer = (MIB_SERVER_HANDLE) NULL;
    
    //
    // Verify router service is running
    //

    if ( !MprAdminIsServiceRunning( NULL ) )
    {
        TRACE0( "Router Service not running" );
    }

    else {
        //
        // Connect to router.  In case of error, set
        // connection handle to NULL.  Connection can
        // be established later.
        //
        
        dwRes = MprAdminMIBServerConnect(
                    NULL,
                    &g_hMIBServer
                );

        if ( dwRes != NO_ERROR )
        {
            g_hMIBServer = (MIB_SERVER_HANDLE) NULL;
            
            TRACE1( 
                "Error %d setting up DIM connection to MIB Server\n", dwRes
            );
            return FALSE;
        }    
    }

    // save uptime reference
    g_uptimeReference = uptimeReference;

    // obtain handle to subagent framework
    g_tfxHandle = SnmpTfxOpen(1,&v_msiprip2);

    // validate handle
    if (g_tfxHandle == NULL) {
        return FALSE;
    }

    // pass back first view identifier to master
    *lpFirstSupportedView = v_msiprip2.viewOid;

    // traps not supported yet
    *lpPollForTrapEvent = NULL;

    return TRUE;    
}


BOOL 
SnmpExtensionQuery(
    IN     BYTE                 requestType,
    IN OUT RFC1157VarBindList * variableBindings,
       OUT AsnInteger *         errorStatus,
       OUT AsnInteger *         errorIndex
    )
{
    // forward to framework
    return SnmpTfxQuery(
                g_tfxHandle,
                requestType,
                variableBindings,
                errorStatus,
                errorIndex
                );
}


BOOL 
SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger *genericTrap,
    OUT AsnInteger *specificTrap,
    OUT AsnTimeticks *timeStamp,
    OUT RFC1157VarBindList *variableBindings
    )
{
    // no traps
    return FALSE;
}


BOOL WINAPI
DllMain(
    HINSTANCE       hInstDLL,
    DWORD           fdwReason,
    LPVOID          pReserved
)
{
    
    BOOL bRetVal = TRUE;

    switch ( fdwReason )
    {
        case DLL_PROCESS_ATTACH :
        {
            DisableThreadLibraryCalls( hInstDLL );


            try {
                InitializeCriticalSection( &g_CS );
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                bRetVal = FALSE;
                break;
            }

            break;
        }
        
        case DLL_PROCESS_DETACH :
        {
            //
            // Disconnect from router
            //

            if ( g_hMIBServer )
            {
                MprAdminMIBServerDisconnect( g_hMIBServer );
            }

            DeleteCriticalSection( &g_CS );
            
#if defined( MIB_DEBUG )

            if ( g_dwTraceId != INVALID_TRACEID )
            {
                TraceDeregister( g_dwTraceId );
            }
#endif              
            break;
         }
         
         default :
         {
            break;
         }
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ripagnt\mibfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibfuncs.c

Abstract:

    Sample subagent instrumentation callbacks.

--*/

#include    "precomp.h"
#pragma     hdrstop

DWORD
ConnectToRouter();

DWORD
GetGlobalConfigInfo(
    OUT PIPRIP_MIB_GET_OUTPUT_DATA *    ppimgod,
    OUT PDWORD                          pdwSize
);

DWORD
SetGlobalInfo(
    IN  AsnAny *                        objectArray
);

DWORD
UpdatePeerFilterTable(
    IN  AsnAny *                        objectArray,
    IN  DWORD                           dwOp
);

DWORD
AddPeerFilterEntry(
    IN  DWORD                           dwPeerAddr,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);

DWORD
DeletePeerFilterEntry(
    IN  DWORD                           dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);


DWORD
GetInterfaceInfo( 
    IN  UINT                            actionId,
    IN  PIPRIP_MIB_GET_INPUT_DATA       pimgidInData,
    OUT PIPRIP_MIB_GET_OUTPUT_DATA*     ppimgod,
    OUT PDWORD                          pdwOutSize
);

DWORD
ValidateInterfaceConfig(
    IN  AsnAny *                        objectArray
);

DWORD
SetInterfaceConfig(
    IN  AsnAny *                        objectArray
);

DWORD
UpdateUnicastPeerEntry(
    IN  AsnAny *                        objectArray,
    IN  DWORD                           dwOp
);

DWORD
AddUnicastPeerEntry(
    IN  DWORD                           dwPeer,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);

DWORD
DeleteUnicastPeerEntry(
    IN  DWORD                           dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);

DWORD
UpdateFilterTable(
    IN  DWORD                           dwOp,
    IN  DWORD                           dwIfIndex,
    IN  DWORD                           dwFiltType,
    IN  PIPRIP_ROUTE_FILTER             pirfFilt
);



DWORD
AddFilterEntry(
    IN  DWORD                           dwFiltType,
    IN  PIPRIP_ROUTE_FILTER             pirfFilt,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);


DWORD
DeleteFilterEntry(
    IN  DWORD                           dwFiltType,
    IN  DWORD                           dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
);


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group (1.3.6.1.4.1.311.1.11.1)                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes               = (DWORD) -1,
                                    dwStatSize          = 0,
                                    dwConfigSize        = 0;
    
    buf_global*                     pbgBuffer           = NULL;

    PIPRIP_GLOBAL_STATS             pigsGlbStats        = NULL;
    PIPRIP_GLOBAL_CONFIG            pigcGlbConfig       = NULL;
    
    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodStatData      = NULL;
    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodConfigData    = NULL;

    IPRIP_MIB_GET_INPUT_DATA        imgidInData;
    
    
    
    TraceEnter( "get_global" );

    switch ( actionId )
    {
    case MIB_ACTION_GET:
    case MIB_ACTION_GETFIRST:

        //
        // Retrieve global information in 2 parts.
        //
        //
        // First get global stats
        //
        imgidInData.IMGID_TypeID = IPRIP_GLOBAL_STATS_ID;
        
        RIP_MIB_GET(
            &imgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodStatData,
            &dwStatSize,
            dwRes
        );
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }
        
        //
        // Next get global config
        //
        
        imgidInData.IMGID_TypeID = IPRIP_GLOBAL_CONFIG_ID;
        
        RIP_MIB_GET(
            &imgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodConfigData,
            &dwConfigSize,
            dwRes
        );
        
                
        break;
    
    case MIB_ACTION_GETNEXT:
    default:
            TRACE1( "Wrong Action", actionId );
            return MIB_S_INVALID_PARAMETER;
    }

    //
    // if error print error message and free allocations
    //

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );

        if ( pimgodStatData ) { MprAdminMIBBufferFree ( pimgodStatData ); }

        if ( pimgodConfigData ) { MprAdminMIBBufferFree ( pimgodConfigData ); }

        return dwRes;
    }

    
    //
    // Set the return data.
    //

    //
    // Global Stats Data
    //
    
    pbgBuffer       = (buf_global*) objectArray;

    pigsGlbStats    = (PIPRIP_GLOBAL_STATS) pimgodStatData-> IMGOD_Buffer;
    
    SetAsnCounter( 
        &(pbgBuffer-> globalSystemRouteChanges), 
        pigsGlbStats-> GS_SystemRouteChanges 
    );

    SetAsnCounter(
        &(pbgBuffer-> globalTotalResponseSends),
        pigsGlbStats-> GS_TotalResponsesSent
    );

    //
    // Global config Data
    //
    
    pigcGlbConfig   = (PIPRIP_GLOBAL_CONFIG) pimgodConfigData-> IMGOD_Buffer;
    
    SetAsnInteger(
        &( pbgBuffer-> globalMaxRecQueueSize ),
        pigcGlbConfig-> GC_MaxRecvQueueSize 
    );

    SetAsnInteger(
        &( pbgBuffer-> globalMaxSendQueueSize ),
        pigcGlbConfig-> GC_MaxSendQueueSize
    );

    SetAsnTimeTicks(
        &( pbgBuffer-> globalMinTriggeredUpdateInterval ),
        pigcGlbConfig-> GC_MinTriggeredUpdateInterval
    );

    SetAsnInteger(
        &( pbgBuffer-> globalPeerFilterCount ),
        pigcGlbConfig-> GC_PeerFilterCount 
    );
    
    //
    // +1 added to adjust value to enumeration values in asn.
    // Enumeration in asn cannot have a value of 0. Causes a warning
    // to be generated by the asn compiler.
    //
    
    SetAsnInteger( 
        &(pbgBuffer-> globalLoggingLevel),
        pigcGlbConfig-> GC_LoggingLevel + 1
    );

    SetAsnInteger(
        &( pbgBuffer-> globalPeerFilterMode ),
        pigcGlbConfig-> GC_PeerFilterMode + 1
    );
    

    if ( pimgodStatData ) { MprAdminMIBBufferFree ( pimgodStatData ); }

    if ( pimgodConfigData ) { MprAdminMIBBufferFree ( pimgodConfigData ); }

    TraceLeave( "get_global" );

    return MIB_S_SUCCESS;
}



UINT
set_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes           = MIB_S_SUCCESS,
                                    dwLogLevel      = 0,
                                    dwFiltMode      = 0;
    
    sav_global*                     psgBuffer       = (sav_global*) objectArray;
    
    
    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :
        TraceEnter( " set_global - validate " );
    
        //
        // Verify logging level
        //
        
        dwLogLevel = GetAsnInteger( 
                        &( psgBuffer-> globalLoggingLevel ),
                        0
                     );

        if ( dwLogLevel < d_globalLoggingLevel_none ||
             dwLogLevel > d_globalLoggingLevel_information )
        {
            dwRes = MIB_S_INVALID_PARAMETER;            
            TRACE1( "Invalid Logging level : %d\n", dwLogLevel );
        }

        //
        // Verify Peer Filter Mode 
        //

        dwFiltMode = GetAsnInteger(
                        &( psgBuffer-> globalPeerFilterMode ),
                        0,
                     );

        if ( dwFiltMode < d_globalPeerFilterMode_disable ||
             dwFiltMode > d_globalPeerFilterMode_exclude )
        {
            dwRes = MIB_S_INVALID_PARAMETER;            
            TRACE1( "Invalid Peer Filter Mode level : %d\n", dwFiltMode );
        }

        TraceLeave( " set_global - validate " );
       
        break;


    case MIB_ACTION_SET :
    
        TraceEnter( " set_global - set " );
        
        dwRes = SetGlobalInfo( objectArray );

        TraceLeave( " set_global - set " );

        break;


    case MIB_ACTION_CLEANUP :

        TraceEnter( " set_global - cleanup " );

        TraceLeave( " set_global - cleanup " );
        
        break;


    default :
        TraceEnter( " set_global - Wrong action " );

        TraceLeave( " set_global - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;

        break;
    }


    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalPeerFilterEntry table (1.3.6.1.4.1.311.1.11.1.9.1)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_globalPeerFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwCurrentAddr = INADDR_NONE,
                                    dwInd       = 0,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    PDWORD                          pdwAddrTable= NULL;
    
    buf_globalPeerFilterEntry*      pbgpfe      = NULL;

    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA       pimsidInData= NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;


    
    TraceEnter( "get_globalPeerFilterEntry" );
    
    pbgpfe = (buf_globalPeerFilterEntry*) objectArray;
    
    
    //
    // retrive the peer filter table
    //

    imgidInData.IMGID_TypeID = IPRIP_GLOBAL_CONFIG_ID;
    
    RIP_MIB_GET(
        &imgidInData,
        sizeof( IPRIP_MIB_GET_INPUT_DATA ),
        &pimgodOutData,
        &dwGetSize,
        dwRes
    );
    

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    pigc = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

    if ( !pigc-> GC_PeerFilterCount )
    {
        TRACE0( "No Peer Entries" );
        MprAdminMIBBufferFree( pimgodOutData );
        return MIB_S_NO_MORE_ENTRIES;
    }
    
    pdwAddrTable = IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );

    
    //
    // Locate current entry in Peer filter table
    //

    dwCurrentAddr = GetAsnIPAddress( &( pbgpfe-> globalPFAddr ), 0 );

    FIND_PEER_ENTRY( 
        dwCurrentAddr, 
        pigc-> GC_PeerFilterCount, 
        pdwAddrTable,
        dwInd
    );
    

    //
    // get requested entry
    //
    
    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    
    case MIB_ACTION_GET :

        //
        // This is an idempotent case, since retieving a peer address
        // requires the peer address as index.
        // It is only useful to verify the presence of a particular peer.
        // 
        
        if ( dwInd >= pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0(  "Peer Entry not found" );
        }

        break;

    case MIB_ACTION_GETFIRST :

        //
        // get entry at index 0 (if available )
        //
        
        dwInd = 0;
        
        if ( !pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Peer filter entry not found" );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        //
        // check if entry was found
        //
        
        if ( dwInd >= pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Peer Entry not found " );
            break;
        }
        
        //
        // try and get next
        //
        
        dwInd++;

        if ( dwInd >= pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;
            TRACE0( "No more Peer Entries" );
            break;
        }

        break;

    default :

        TRACE0( " get_globalPeerFilterEntry - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;

        break;
    }


    //
    // set index for next retrieval
    //
    
    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnIPAddress( 
            &( pbgpfe-> globalPFAddr ),
            &( pbgpfe-> dwPeerFilterAddr ),
            pdwAddrTable[ dwInd ]
        );
    }
    
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( "get_globalPeerFilterEntry" );

    return dwRes;

}


UINT
set_globalPeerFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes   = MIB_S_SUCCESS,
                                    dwAddr  = INADDR_NONE,
                                    dwOp    = 0;
    
    sav_globalPeerFilterEntry*      psgpfe  = NULL;


    TraceEnter( " set_globalPeerFilterEntry " );

    psgpfe = (sav_globalPeerFilterEntry*) objectArray;
    

    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :
    
        //
        // Verify if the specified IP address is valid.
        //

        dwAddr = GetAsnIPAddress( &( psgpfe-> globalPFAddr ), INADDR_NONE );

        if ( !dwAddr || dwAddr == INADDR_NONE )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Peer address specified" );
        }

        //
        // Verify operation tag
        //

        dwRes = GetAsnInteger( &( psgpfe-> globalPFTag ), 0 );

        if ( dwRes != d_Tag_create && dwRes != d_Tag_delete )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Operation specified" );
        }
        
        break;

        
    case MIB_ACTION_SET :

        dwOp = GetAsnInteger( &( psgpfe-> globalPFTag ), 0 );

        dwRes = UpdatePeerFilterTable( objectArray, dwOp );
        
        break;


    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :
        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( " set_globalPeerFilterEntry - Wrong Action " );
        
        break;
    }

    TraceLeave( " set_globalPeerFilterEntry " );
    
    return dwRes;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// interface group (1.3.6.1.4.1.311.1.11.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.11.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    buf_ifStatsEntry *              pbifse      = NULL;

    PIPRIP_IF_STATS                 piis        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;


    TraceEnter( "get_ifStatsEntry" );
    
    //
    // Retrieve Specified interface info.
    //

    pbifse                      = (buf_ifStatsEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_STATS_ID;

    imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                    &( pbifse-> ifSEIndex ), 
                                    0
                                  );

    //
    // When walking the mib using a sequence of getnext operations
    // the first getnext operation is translated into a getfirst
    // operation.
    //
 
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
   dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );
            
    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }


    //
    // Set interface stats in return buffer
    //

    piis = (PIPRIP_IF_STATS) (pimgodOutData-> IMGOD_Buffer);

    SetAsnInteger( &( pbifse-> ifSEState ), piis-> IS_State );

    SetAsnCounter( &( pbifse-> ifSESendFailures ), piis-> IS_SendFailures );
    
    SetAsnCounter( &( pbifse-> ifSEReceiveFailures ), piis-> IS_ReceiveFailures );

    SetAsnCounter( &( pbifse-> ifSERequestSends ), piis-> IS_RequestsSent );

    SetAsnCounter( &( pbifse-> ifSEResponseSends ), piis-> IS_ResponsesSent );

    SetAsnCounter( 
        &( pbifse-> ifSEResponseReceiveds ), 
        piis-> IS_ResponsesReceived 
    );

    SetAsnCounter( 
        &( pbifse-> ifSEBadResponsePacketReceiveds ), 
        piis-> IS_BadResponsePacketsReceived
    );

    SetAsnCounter( 
        &( pbifse-> ifSEBadResponseEntriesReceiveds ), 
        piis-> IS_BadResponseEntriesReceived
    );
    
    SetAsnCounter( 
        &( pbifse-> ifSETriggeredUpdateSends ), 
        piis-> IS_TriggeredUpdatesSent
    );

    //
    // set index for following getnext operation, (if any)
    //
    
    ForceSetAsnInteger( 
        &( pbifse-> ifSEIndex ), 
        pimgodOutData-> IMGOD_IfIndex
    );
    

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    TraceLeave( "get_ifStatsEntry" );
    
    return MIB_S_SUCCESS ;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.11.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifConfigEntry*              pbifce      = NULL;

    PIPRIP_IF_CONFIG                piic        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    BYTE                            pbAuthKey[ IPRIP_MAX_AUTHKEY_SIZE ];
    

    TraceEnter( " get_ifConfigEntry " );

    //
    // retrieve interface config.
    //
    
    pbifce                      = (buf_ifConfigEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( &( pbifce-> ifCEIndex ), 0 );
                                    
    //
    // When walking the mib using a sequence of getnext operations
    // the first getnext operation is translated into a getfirst
    // operation.
    //
 
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // set requiste fields
    //
    
    piic = (PIPRIP_IF_CONFIG) (pimgodOutData-> IMGOD_Buffer);
    
    SetAsnInteger( &( pbifce-> ifCEState ), piic-> IC_State );

    SetAsnInteger( &( pbifce-> ifCEMetric ), piic-> IC_Metric );

    SetAsnInteger( &( pbifce-> ifCEUpdateMode ), piic-> IC_UpdateMode + 1 );

    SetAsnInteger( &( pbifce-> ifCEAcceptMode ), piic-> IC_AcceptMode + 1 );

    SetAsnInteger( &( pbifce-> ifCEAnnounceMode ), piic-> IC_AnnounceMode + 1 );

    SetAsnInteger( &( pbifce-> ifCEProtocolFlags ), piic-> IC_ProtocolFlags );

    SetAsnTimeTicks( 
        &( pbifce-> ifCERouteExpirationInterval ), 
        piic-> IC_RouteExpirationInterval
    );

    SetAsnTimeTicks( 
        &( pbifce-> ifCERouteRemovalInterval ), 
        piic-> IC_RouteRemovalInterval 
    );

    SetAsnTimeTicks( 
        &( pbifce-> ifCEFullUpdateInterval ), 
        piic-> IC_FullUpdateInterval 
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAuthenticationType ), 
        piic-> IC_AuthenticationType
    );

    SetAsnInteger( &( pbifce-> ifCERouteTag ), piic-> IC_RouteTag );

    SetAsnInteger( 
        &( pbifce-> ifCEUnicastPeerMode ), 
        piic-> IC_UnicastPeerMode + 1 
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAcceptFilterMode ), 
        piic-> IC_AcceptFilterMode  + 1
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAnnounceFilterMode ), 
        piic-> IC_AnnounceFilterMode + 1
    );

    SetAsnInteger( 
        &( pbifce-> ifCEUnicastPeerCount ), 
        piic-> IC_UnicastPeerCount + 1
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAcceptFilterCount ), 
        piic-> IC_AcceptFilterCount
    );

    SetAsnInteger( 
        &( pbifce-> ifCEAnnounceFilterCount ), 
        piic-> IC_AnnounceFilterCount
    );

    //
    // As per RFC 1724, this field is a write only field.
    // Authentication may not be bypassed by reading the key.
    // The default value to be returned is a null string.
    //
    
    ZeroMemory( pbAuthKey, IPRIP_MAX_AUTHKEY_SIZE );

    SetAsnOctetString(
        &( pbifce-> ifCEAuthenticationKey ),
        pbifce-> pbAuthKey,
        pbAuthKey,
        IPRIP_MAX_AUTHKEY_SIZE
    );
        
    //
    // set index for following getnext operation, (if any)
    //
    
    ForceSetAsnInteger( 
        &( pbifce-> ifCEIndex ), 
        pimgodOutData-> IMGOD_IfIndex
    );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifConfigEntry " );

    return MIB_S_SUCCESS;
}


UINT
set_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1;

    TraceEnter( " set_ifConfigEntry " );

    switch ( actionId )
    {
    
    case MIB_ACTION_VALIDATE :
    
        dwRes = ValidateInterfaceConfig( objectArray );
        
        break;


    case MIB_ACTION_SET :

        dwRes = SetInterfaceConfig( objectArray );
        
        break;


    case MIB_ACTION_CLEANUP :
    
        dwRes = MIB_S_SUCCESS;
        
        break;


    default :
    
        TRACE0( " set_ifConfigEntry - wrong action " );

        dwRes = MIB_S_INVALID_PARAMETER;

        break;
    }

    
    TraceLeave( "set_ifConfigEntry" );

    return dwRes ;

}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifUnicastPeersEntry table (1.3.6.1.4.1.311.1.11.2.3.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifUnicastPeersEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwPeer      = INADDR_NONE,
                                    dwInd       = (DWORD) -1;

    PDWORD                          pdwAddrTable= NULL;
    
    buf_ifUnicastPeersEntry*        pbifupe     = NULL;

    PIPRIP_IF_CONFIG                piic        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;

    IPRIP_MIB_GET_INPUT_DATA        imgidInData;



    TraceEnter( " get_ifUnicastPeerEntry " );

    //
    // retrieve interface config.
    //
    
    pbifupe                     = (buf_ifUnicastPeersEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( &( pbifupe-> ifUPIfIndex ), 0 );
                                    
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // Locate peer entry
    //

    dwPeer = GetAsnIPAddress( &( pbifupe-> ifUPAddress ), 0 );
    
    piic = (PIPRIP_IF_CONFIG) ( pimgodOutData-> IMGOD_Buffer );

    pdwAddrTable = IPRIP_IF_UNICAST_PEER_TABLE( piic );

    FIND_PEER_ENTRY(
        dwPeer,
        piic-> IC_UnicastPeerCount,
        pdwAddrTable,
        dwInd
    );
    
    
    //
    // return requested peer entry
    //

    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    case MIB_ACTION_GET :

        //
        // idempotent case.  Only possible use is to verify 
        // specific peer present.
        //

        if ( dwInd >= piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Unicast Peer entry not found" );
        }
        
        break;


    case MIB_ACTION_GETFIRST :

        //
        // get entry at index 0 if available
        //

        dwInd = 0;
        
        if ( !piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more Peer Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        //
        // check if entry was found
        //
        
        if ( dwInd >= piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Unicast Peer Entry not found " );
            break;
        }
        
        //
        // try and get next
        //
        
        dwInd++;

        if ( dwInd >= piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more Peer Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );

            break;
        }

        break;
        
    default :
    
        TRACE0( " get_globalPeerFilterEntry - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    }

    //
    // set index value for next retrieval.
    //
    
    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnInteger(
            &( pbifupe-> ifUPIfIndex ),
            pimgodOutData-> IMGOD_IfIndex
        );

        ForceSetAsnIPAddress( 
            &( pbifupe-> ifUPAddress ),
            &( pbifupe-> dwUnicastPeerAddr ),
            pdwAddrTable[ dwInd ]
        );

    }        
        
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    TraceLeave( "get_ifUnicastPeersEntry " );
    
    return dwRes;
}


UINT
set_ifUnicastPeersEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes   = (DWORD) -1,
                                    dwOp    = 0,
                                    dwAddr  = INADDR_NONE;
    
    sav_ifUnicastPeersEntry*        psifupe = NULL;



    TraceEnter( " set_ifUnicastPeersEntry " );

    psifupe = (sav_ifUnicastPeersEntry*) objectArray;
    

    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :
    
        //
        // Verify if the specified IP address is valid.
        //

        dwAddr = GetAsnIPAddress( &( psifupe-> ifUPAddress ), INADDR_NONE );

        if ( !dwAddr || dwAddr == INADDR_NONE )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Peer address specified" );
            break;
        }

        //
        // Verify operation tag
        //

        dwRes = GetAsnInteger( &( psifupe-> ifUPTag ), 0 );

        if ( dwRes != d_Tag_create && dwRes != d_Tag_delete )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Operation specified" );
            break;
        }
        
        dwRes = MIB_S_SUCCESS;
        
        break;

        
    case MIB_ACTION_SET :

        dwOp = GetAsnInteger( &( psifupe-> ifUPTag ), 0 );

        dwRes = UpdateUnicastPeerEntry( objectArray, dwOp );
        
        break;


    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :
        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( " set_ifUnicastPeersEntry - Wrong Action " );
        
        break;
    }

    TraceLeave( " set_ifUnicastPeersEntry " );
    
    return dwRes;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAcceptRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.4.1)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAcceptRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes           = (DWORD) -1,
                                    dwIndex         = 0,
                                    dwGetSize       = 0;
                                
    PIPRIP_IF_CONFIG                piic            = NULL;

    PIPRIP_ROUTE_FILTER             pFiltTable      = NULL;
    
    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData   = NULL;

    buf_ifAcceptRouteFilterEntry *  pgifRF    = NULL;

    IPRIP_ROUTE_FILTER              irf;

    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    

    TraceEnter( "get_ifAcceptRouteFilterEntry" );

    //
    // retrieve interface Info
    //

    pgifRF = (buf_ifAcceptRouteFilterEntry*) objectArray;

    imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;

    imgidInData.IMGID_IfIndex   = GetAsnInteger(
                                    &( pgifRF-> ifAcceptRFIfIndex ),
                                    0
                                  );

    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );
    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }
    

    //
    // Find accept filter
    //
    
    irf.RF_LoAddress = GetAsnIPAddress( 
                            &( pgifRF-> ifAcceptRFLoAddress ),
                            INADDR_NONE
                        );

    irf.RF_HiAddress = GetAsnIPAddress(                 
                            &( pgifRF-> ifAcceptRFHiAddress ),
                            INADDR_NONE
                        );

    piic            = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

    pFiltTable      = IPRIP_IF_ACCEPT_FILTER_TABLE( piic );
            
    FIND_FILTER(
        &irf,
        piic-> IC_AcceptFilterCount,
        pFiltTable,
        dwIndex
    );
    

    //
    // retrieve requested entry
    //
    
    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    case MIB_ACTION_GET :   

        //
        // Idempotent case 
        //

        if ( dwIndex >= piic-> IC_AcceptFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Accept filter not found" );
        }
        
        break;

    case MIB_ACTION_GETFIRST :

        dwIndex = 0;
        
        if ( !piic-> IC_AcceptFilterCount ) 
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "No Accept filters present " );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        if ( dwIndex >= piic-> IC_AcceptFilterCount ) 
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "No Accept filters present " );
        }

        dwIndex++;

        if ( dwIndex >= piic-> IC_AcceptFilterCount ) 
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;
            TRACE0( "No More Accept filters present " );
        }
        
        break;
        
    default :
        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( "get_ifAcceptRouteFilterEntry - Wrong Action " );
        
        break;
        
    }

    //
    // set index for next retrieveal
    //
    
    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnInteger( 
            &( pgifRF-> ifAcceptRFIfIndex ),
            pimgodOutData-> IMGOD_IfIndex 
        );

        ForceSetAsnIPAddress( 
            &( pgifRF-> ifAcceptRFLoAddress ), 
            &( pgifRF-> dwFilterLoAddr ),
            pFiltTable[ dwIndex ].RF_LoAddress
        );
        
        ForceSetAsnIPAddress( 
            &( pgifRF-> ifAcceptRFHiAddress ),
            &( pgifRF-> dwFilterHiAddr ),
            pFiltTable[ dwIndex ].RF_HiAddress
        );
    }
    
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( "get_ifAcceptRouteFilterEntry" );

    return dwRes;
}


UINT
set_ifAcceptRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                       dwRes   = (DWORD) -1,
                                dwIndex = 0,
                                dwTag   = 0;

    sav_ifAcceptRouteFilterEntry* psifRF  = NULL;

    IPRIP_ROUTE_FILTER          irf;

    
    
    TraceEnter( "set_ifAcceptRouteFilterEntry" );

    psifRF = (sav_ifAcceptRouteFilterEntry*) objectArray;

    dwIndex = GetAsnInteger(
                &( psifRF-> ifAcceptRFIfIndex ),
                0
              );
              
    irf.RF_LoAddress = GetAsnIPAddress( 
                            &( psifRF-> ifAcceptRFLoAddress ),
                            INADDR_NONE
                        );

    irf.RF_HiAddress = GetAsnIPAddress(                 
                            &( psifRF-> ifAcceptRFHiAddress ),
                            INADDR_NONE
                        );

    dwTag = GetAsnInteger(
                &( psifRF-> ifAcceptRFTag ),
                0
            );

            
    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :

        //
        // Check filter ranges are valid address
        //

        if ( !irf.RF_LoAddress || irf.RF_LoAddress == INADDR_NONE ||
             !irf.RF_HiAddress || irf.RF_HiAddress == INADDR_NONE ||
             ( dwTag != d_Tag_create && dwTag != d_Tag_delete ) )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( "Invalid parameter value " );
        }
        break;

    case MIB_ACTION_SET :

        dwRes = UpdateFilterTable(
                    dwTag,
                    dwIndex,
                    RIP_MIB_ACCEPT_FILTER,
                    &irf
                );
        break;

    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( " set_ifAcceptRouteFilterEntry - Wrong Action " );
        
        break;
    }

    TraceLeave( "set_ifAcceptRouteFilterEntry" );

    return dwRes;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAnnounceRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.5.1)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAnnounceRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                               dwRes           = (DWORD) -1,
                                        dwIndex         = 0,
                                        dwGetSize       = 0;
                                        
    IPRIP_ROUTE_FILTER                  irf;

    IPRIP_MIB_GET_INPUT_DATA            imgidInData;

    PIPRIP_IF_CONFIG                    piic            = NULL;

    PIPRIP_ROUTE_FILTER                 pFiltTable      = NULL;
    
    PIPRIP_MIB_GET_OUTPUT_DATA          pimgodOutData   = NULL;

    buf_ifAnnounceRouteFilterEntry *    pgifRF    = NULL;

    
    
    TraceEnter( "get_ifAnnounceRouteFilterEntry" );

    //
    // retrieve interface Info
    //

    pgifRF = (buf_ifAnnounceRouteFilterEntry*) objectArray;

    imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;

    imgidInData.IMGID_IfIndex   = GetAsnInteger(
                                    &( pgifRF-> ifAnnounceRFIfIndex ),
                                    0
                                  );

    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );
    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }
    
    //
    // find specfied filter
    //
    
    irf.RF_LoAddress = GetAsnIPAddress( 
                            &( pgifRF-> ifAnnounceRFLoAddress ),
                            INADDR_NONE
                        );

    irf.RF_HiAddress = GetAsnIPAddress(                 
                            &( pgifRF-> ifAnnounceRFHiAddress ),
                            INADDR_NONE
                        );

    piic            = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

    pFiltTable      = IPRIP_IF_ACCEPT_FILTER_TABLE( piic );
            
    FIND_FILTER(
        &irf,
        piic-> IC_AnnounceFilterCount,
        pFiltTable,
        dwIndex
    );
    
    //
    // get filter info.
    //

    dwRes = MIB_S_SUCCESS;
            
    switch ( actionId )
    {
    case MIB_ACTION_GET :   

        //
        // Idempotent case 
        //

        if ( dwIndex >= piic-> IC_AnnounceFilterCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "Announce filter not found" );
        }
        
        break;

    case MIB_ACTION_GETFIRST :

        dwIndex = 0;
        
        if ( !piic-> IC_AnnounceFilterCount ) 
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "No Announce filters present " );
        }

        break;

    case MIB_ACTION_GETNEXT :

        if ( dwIndex >= piic-> IC_AnnounceFilterCount ) 
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "No Announce filters present " );
        }

        dwIndex++;

        if ( dwIndex >= piic-> IC_AnnounceFilterCount ) 
        {
            dwRes = ERROR_NO_MORE_ITEMS;
            TRACE0( "No More Announce filters present " );
        }
        
        dwRes = MIB_S_SUCCESS;

        break;
        
    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( "get_ifAnnounceRouteFilterEntry - Wrong Action " );
        
        break;
        
    }

    //
    // set up the indices for next retrieval
    //
    
    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnInteger(
            &( pgifRF-> ifAnnounceRFIfIndex ),
            pimgodOutData-> IMGOD_IfIndex
        );
        
        ForceSetAsnIPAddress( 
            &( pgifRF-> ifAnnounceRFLoAddress ),
            &( pgifRF-> dwFilterLoAddr ),
            pFiltTable[ dwIndex ].RF_LoAddress
        );
        
        ForceSetAsnIPAddress( 
            &( pgifRF-> ifAnnounceRFHiAddress ),
            &( pgifRF-> dwFilterHiAddr ),
            pFiltTable[ dwIndex ].RF_HiAddress
        );
    }

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( "get_ifAnnounceRouteFilterEntry" );

    return dwRes;
    
}    


UINT
set_ifAnnounceRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                       dwRes   = (DWORD) -1,
                                dwIndex = 0,
                                dwTag   = 0;

    sav_ifAnnounceRouteFilterEntry*    psifRF  = NULL;

    IPRIP_ROUTE_FILTER          irf;

    
    
    TraceEnter( "set_ifAnnounceRouteFilterEntry" );

    psifRF = (sav_ifAnnounceRouteFilterEntry*) objectArray;

    dwIndex = GetAsnInteger(
                &( psifRF-> ifAnnounceRFLoAddress ),
                0
              );
              
    irf.RF_LoAddress = GetAsnIPAddress( 
                            &( psifRF-> ifAnnounceRFLoAddress ),
                            INADDR_NONE
                        );

    irf.RF_HiAddress = GetAsnIPAddress(                 
                            &( psifRF-> ifAnnounceRFHiAddress ),
                            INADDR_NONE
                        );

    dwTag = GetAsnInteger(
                &( psifRF-> ifAnnounceRFTag ),
                0
            );

            
    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :

        //
        // Check filter ranges are valid address
        //

        if ( !irf.RF_LoAddress || irf.RF_LoAddress == INADDR_NONE ||
             !irf.RF_HiAddress || irf.RF_HiAddress == INADDR_NONE ||
             ( dwTag != d_Tag_create && dwTag != d_Tag_delete ) )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( "Invalid parameter value " );
        }
        break;

    case MIB_ACTION_SET :

        dwRes = UpdateFilterTable(
                    dwTag,
                    dwIndex,
                    RIP_MIB_ANNOUNCE_FILTER,
                    &irf
                );
        break;

    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( " set_ifAnnounceRouteFilterEntry - Wrong Action " );
        
        break;
    }

    TraceLeave( "set_ifAnnounceRouteFilterEntry" );

    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.11.2.6.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifBindingEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifBindingEntry*             pbifb       = NULL;

    PIPRIP_IF_BINDING               piib        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    

    TraceEnter( " get_ifBindingEntry " );

    //
    // retrieve interface binding info.
    //
    
    pbifb                       = (buf_ifBindingEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_BINDING_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                    &( pbifb-> ifBindingIndex ), 
                                    0 
                                  );
                                    
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // set requiste fields
    //
    
    piib = (PIPRIP_IF_BINDING) (pimgodOutData-> IMGOD_Buffer);
    
    SetAsnInteger( &( pbifb-> ifBindingState ), piib-> IB_State + 1 );

    SetAsnCounter( &( pbifb-> ifBindingCounts ), piib-> IB_AddrCount );

    ForceSetAsnInteger(
        &( pbifb-> ifBindingIndex ),
        pimgodOutData-> IMGOD_IfIndex
    );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifBindingEntry " );

    return MIB_S_SUCCESS ;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.11.2.7.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAddressEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwIndex     = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifAddressEntry *            pbifae      = NULL;

    PIPRIP_IF_BINDING               piib        = NULL;

    PIPRIP_IP_ADDRESS               pia         = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;

    IPRIP_IP_ADDRESS                ipa;
    
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    

    TraceEnter( " get_ifAddressEntry " );

    //
    // retrieve interface binding info.
    //
    
    pbifae                      = (buf_ifAddressEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPRIP_IF_BINDING_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                    &( pbifae-> ifAEIfIndex ), 
                                    0 
                                  );
                                    
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // retrieve IPAddress from IP Address table
    //

    ipa.IA_Address  = GetAsnIPAddress(
                        &( pbifae-> ifAEAddress),
                        INADDR_NONE
                      );

    ipa.IA_Netmask  = GetAsnIPAddress(
                        &( pbifae-> ifAEMask),
                        INADDR_NONE
                      );
                      
    piib            = (PIPRIP_IF_BINDING) pimgodOutData-> IMGOD_Buffer;

    pia             = (PIPRIP_IP_ADDRESS) IPRIP_IF_ADDRESS_TABLE( piib );

    FIND_IP_ADDRESS(
        ipa,
        piib-> IB_AddrCount,
        pia,
        dwIndex
    );


    //
    // set appr fields
    //

    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    case MIB_ACTION_GET :

        //
        // idempotent case.  Only possible use is to verify 
        // specific peer present.
        //

        if ( dwIndex >= piib-> IB_AddrCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "IP address entry not found" );
        }
        
        break;


    case MIB_ACTION_GETFIRST :

        //
        // get entry at index 0 if available
        //

        dwIndex = 0;
        
        if ( !piib-> IB_AddrCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more IP address Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        //
        // check if entry was found
        //
        
        if ( dwIndex >= piib-> IB_AddrCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "IP address Entry not found " );
            break;
        }
        
        //
        // try and get next
        //
        
        dwIndex++;

        if ( dwIndex >= piib-> IB_AddrCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more IP address Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );

            break;
        }

        dwRes = MIB_S_SUCCESS;
        
        break;
        
    default :
    
        TRACE0( " get_globalPeerFilterEntry - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    }

    //
    // set index for next retieval
    //

    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnInteger(
            &( pbifae-> ifAEIfIndex ),
            pimgodOutData-> IMGOD_IfIndex
        );

        ForceSetAsnIPAddress(
            &( pbifae-> ifAEAddress ),
            &( pbifae-> dwAddress ),
            pia[ dwIndex ].IA_Address
        );

        ForceSetAsnIPAddress(
            &( pbifae-> ifAEMask ),
            &( pbifae-> dwMask ),
            pia[ dwIndex ].IA_Netmask
        );
    }
    
    if ( pimgodOutData )  { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifAddressEntry " );

    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// peer group (1.3.6.1.4.1.311.1.11.3)                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifPeerStatsEntry table (1.3.6.1.4.1.311.1.11.3.1.1)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifPeerStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifPeerStatsEntry*           pbifpse     = NULL;

    PIPRIP_PEER_STATS               pips        = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;

    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    

    TraceEnter( "get_ifPeerStatsEntry" );

    //
    // retrieve interface config.
    //
    
    pbifpse                         = (buf_ifPeerStatsEntry*) objectArray;
    
    imgidInData.IMGID_TypeID        = IPRIP_PEER_STATS_ID;
    
    imgidInData.IMGID_PeerAddress   = (DWORD) GetAsnIPAddress(
                                                &( pbifpse-> ifPSAddress ),
                                                0
                                              );

    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_PeerAddress )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetPeerStatsInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // set requiste fields
    //
    
    pips = (PIPRIP_PEER_STATS) (pimgodOutData-> IMGOD_Buffer);
    
    SetAsnInteger( 
        &( pbifpse-> ifPSLastPeerRouteTag ), 
        pips-> PS_LastPeerUpdateTickCount 
    );

    SetAsnTimeTicks( 
        &( pbifpse-> ifPSLastPeerUpdateTickCount ), 
        pips-> PS_LastPeerUpdateTickCount 
    );

    SetAsnInteger( 
        &( pbifpse-> ifPSLastPeerUpdateVersion ), 
        pips-> PS_LastPeerUpdateVersion 
    );
    
    SetAsnCounter( 
        &( pbifpse-> ifPSPeerBadResponsePackets ), 
        pips-> PS_BadResponsePacketsFromPeer 
    );
    
    SetAsnCounter( 
        &( pbifpse-> ifPSPeerBadResponseEntries ), 
        pips-> PS_BadResponseEntriesFromPeer 
    );

    //
    // Set index for next retrieval
    //
    
    ForceSetAsnIPAddress(
        &( pbifpse-> ifPSAddress ),
        &( pbifpse-> dwPeerAddr ),
        pimgodOutData-> IMGOD_PeerAddress
    );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifPeerStatsEntry " );

    return MIB_S_SUCCESS ;
}


DWORD
GetGlobalConfigInfo(
    OUT PIPRIP_MIB_GET_OUTPUT_DATA *    ppimgod,
    OUT PDWORD                          pdwSize
)
{

    DWORD                           dwRes           = (DWORD) -1;
    
    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData   = NULL;
    
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;

    
    do
    {
        //
        // retrieve global config 
        //

        imgidInData.IMGID_TypeID    = IPRIP_GLOBAL_CONFIG_ID;
        
        RIP_MIB_GET(
            &imgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwSize,
            dwRes
        );
        

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        *ppimgod = pimgodOutData;
        
    } while ( FALSE );

    return dwRes;
}

//
// SetGlobalInfo
//
//
//  Sets the global RIP info.
//

DWORD
SetGlobalInfo(
    IN  AsnAny *    objectArray
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    sav_global*                     psg         = NULL;

    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;
    PIPRIP_MIB_SET_INPUT_DATA       pimsidInData= NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;


    do
    {
        //
        // Retrieve the global config Data first
        //

        dwRes = GetGlobalConfigInfo( 
                    &pimgodOutData,
                    &dwGetSize
                );
                
        if ( dwRes != NO_ERROR )
        {
            break;
        }

        pigc    = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;
    

        psg     = (sav_global*) objectArray;
        
        //
        // Allocate set info buffer
        //
        
        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                    IPRIP_GLOBAL_CONFIG_SIZE( pigc );

        pimsidInData = 
            (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );
        
        if ( pimsidInData == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "SetGlobalData - Mem. alloc failed" );
            break;
        }
        
        //
        // Set config info fields.
        // if the variable is not specified, we
        // set the field to its previous value i.e. an empty assignment.
        //

        pimsidInData-> IMSID_TypeID     = IPRIP_GLOBAL_CONFIG_ID;
        pimsidInData-> IMSID_IfIndex    = (DWORD) -1;

        pimsidInData-> IMSID_BufferSize = IPRIP_GLOBAL_CONFIG_SIZE( pigc );

        pigc-> GC_MaxRecvQueueSize      = GetAsnInteger(
                                            &( psg-> globalMaxRecQueueSize ),
                                            pigc-> GC_MaxRecvQueueSize
                                          );

        pigc-> GC_MaxSendQueueSize      = GetAsnInteger(
                                            &( psg-> globalMaxSendQueueSize ),
                                            pigc-> GC_MaxSendQueueSize
                                          );

        pigc-> GC_MinTriggeredUpdateInterval = GetAsnTimeTicks(
                                    &( psg-> globalMinTriggeredUpdateInterval ),
                                    pigc-> GC_MinTriggeredUpdateInterval
                                 );

        //
        // -1 is subtracted from the enumerated fields to adjust
        // the ASN enumeration values to the actual values.
        // This is required since the enumeration cannot have 
        // a zero value as per the ASN compiler, but one of the
        // actual values for the field in the config is a zero.
        //
        // as a caveat, if the enumerated field is not specified in 
        // this set operation, to preserve the value of the field
        // in the config, we first increment it.  This way on the 
        // -1 operation the value is restored.  
        //
        pigc-> GC_LoggingLevel++;
        pigc-> GC_LoggingLevel          = GetAsnInteger( 
                                            &( psg-> globalLoggingLevel ), 
                                            pigc-> GC_LoggingLevel
                                          ) - 1;

        pigc-> GC_PeerFilterMode++;
        pigc-> GC_PeerFilterMode        = GetAsnInteger(
                                            &( psg-> globalPeerFilterMode ),
                                            pigc-> GC_PeerFilterMode
                                          ) - 1;

        CopyMemory( 
            (PVOID) pimsidInData-> IMSID_Buffer, 
            (PVOID*) pigc, 
            IPRIP_GLOBAL_CONFIG_SIZE( pigc ) 
        );

        //
        // Save the info. in the MIB
        //
        
        RIP_MIB_SET(
            pimsidInData,
            dwSetSize,
            dwRes
        );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        dwRes = MIB_S_SUCCESS;
        
    } while ( FALSE );

    //
    // Free allocations
    //
    
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    if ( pimsidInData ) { RIP_MIB_FREE( pimsidInData ); }
    
    return dwRes;
}


DWORD
UpdatePeerFilterTable(
    IN  AsnAny *        objectArray,
    IN  DWORD           dwOp
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwInd       = 0,
                                    dwPeerAddr  = INADDR_NONE,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    PDWORD                          pdwAddrTable= 0;                                    

    sav_globalPeerFilterEntry*      psgpfe      = NULL;

    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;
    PIPRIP_MIB_SET_INPUT_DATA       pimsid      = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;


    do
    {
        //
        // Get global info
        //

        dwRes = GetGlobalConfigInfo( 
                    &pimgodOutData,
                    &dwGetSize
                );
                
        if ( dwRes != NO_ERROR )
        {
            break;
        }

                
        //
        // Find filter entry
        //

        psgpfe      = (sav_globalPeerFilterEntry*) objectArray;

        dwPeerAddr  = GetAsnIPAddress( 
                        &( psgpfe-> globalPFAddr ), 
                        0 
                      );
        

        pigc        = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

        pdwAddrTable= IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );

        FIND_PEER_ENTRY(
            dwPeerAddr,
            pigc-> GC_PeerFilterCount,
            pdwAddrTable,
            dwInd
        );

        //
        // if operation is filter add
        //
        
        if ( dwOp == d_Tag_create )
        {
            //
            // if peer already present, quit
            //
            
            if ( pigc-> GC_PeerFilterCount &&
                 dwInd < pigc-> GC_PeerFilterCount )
            {
                dwRes = MIB_S_SUCCESS;
                break;
            }

            else
            {
                dwRes = AddPeerFilterEntry( 
                            dwPeerAddr, 
                            pimgodOutData
                        );
            }

            break;
        }

        //
        // operation is filter delete
        //

        //
        // if peer is not present quit.
        //
        
        if ( !pigc-> GC_PeerFilterCount ||
             dwInd >= pigc-> GC_PeerFilterCount )
        {
            dwRes = MIB_S_SUCCESS;
            break;
        }

        dwRes = DeletePeerFilterEntry(
                    dwInd,
                    pimgodOutData
                );
                
    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    return dwRes;
    
}


DWORD
AddPeerFilterEntry(
    IN  DWORD                       dwPeerAddr,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{


    DWORD                           dwRes       = (DWORD) -1,
                                    dwSetSize   = 0;

    PDWORD                          pdwAddrTable= NULL;
    
    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;

    PIPRIP_MIB_SET_INPUT_DATA       pimsid      = NULL;


    
    do
    {
        //
        // Peer needs to be added.
        //
        
        //
        // compute buffer size required
        //
        
        pigc        = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize   = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                      IPRIP_GLOBAL_CONFIG_SIZE( pigc ) + sizeof( DWORD );

        pimsid      = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( !pimsid )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "AddPeerFilterEntry - out of memory" );
            break;
        }

        //
        // Add filter
        //

        pimsid-> IMSID_TypeID       = IPRIP_GLOBAL_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = (DWORD) -1;

        pimsid-> IMSID_BufferSize   = IPRIP_GLOBAL_CONFIG_SIZE( pigc ) +
                                      sizeof( DWORD );
    
        CopyMemory( 
            (PVOID) &( pimsid-> IMSID_Buffer ), 
            (VOID *) pigc, 
            IPRIP_GLOBAL_CONFIG_SIZE( pigc )
        );

        pigc = (PIPRIP_GLOBAL_CONFIG) pimsid-> IMSID_Buffer;

        pdwAddrTable = IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );        

        pdwAddrTable[ pigc-> GC_PeerFilterCount ] = dwPeerAddr;

        pigc-> GC_PeerFilterCount++;

        //
        // Update MIB
        //
        
        RIP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );
        
    } while ( FALSE );     

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }
    
    return dwRes;
}


DWORD
DeletePeerFilterEntry(
    IN  DWORD                           dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData
)
{


    DWORD                           dwRes       = (DWORD) -1,
                                    dwSetSize   = 0,
                                    dwSrc       = 0,
                                    dwDst       = 0;

    PDWORD                          pdwSrcTable = NULL,
                                    pdwDstTable = NULL;
    
    PIPRIP_GLOBAL_CONFIG            pigc        = NULL;

    PIPRIP_MIB_SET_INPUT_DATA       pimsid      = NULL;


    
    do
    {
        //
        // Peer needs to be added.
        //
        
        //
        // compute buffer size required
        //
        
        pigc        = (PIPRIP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize   = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                      IPRIP_GLOBAL_CONFIG_SIZE( pigc ) - sizeof( DWORD );

        pimsid      = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( !pimsid )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "AddPeerFilterEntry - out of memory" );
            break;
        }

        //
        // Delete filter
        //

        //
        // Copy base global config structure
        //
        
        pimsid-> IMSID_TypeID       = IPRIP_GLOBAL_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = (DWORD) -1;

        pimsid-> IMSID_BufferSize   = IPRIP_GLOBAL_CONFIG_SIZE( pigc ) -
                                      sizeof( DWORD );
    
        CopyMemory( 
            (PVOID) &( pimsid-> IMSID_Buffer ), 
            (VOID *) pigc, 
            sizeof( IPRIP_GLOBAL_CONFIG )
        );

        //
        // Copy peer table. Skip entry to be deleted
        //
        
        pdwSrcTable = IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );

        pigc        = ( PIPRIP_GLOBAL_CONFIG ) pimsid-> IMSID_Buffer;

        pdwDstTable = IPRIP_GLOBAL_PEER_FILTER_TABLE( pigc );

        DELETE_PEER_ENTRY(
            dwIndex,
            pigc-> GC_PeerFilterCount,
            pdwSrcTable,
            pdwDstTable
        );
        
        
        pigc-> GC_PeerFilterCount--;

        //
        // Update MIB
        //
        
        RIP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );
        
    } while ( FALSE );     

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }
    
    return dwRes;
}


DWORD
GetInterfaceInfo( 
    IN  UINT                        actionId,
    IN  PIPRIP_MIB_GET_INPUT_DATA   pimgidInData,
    OUT PIPRIP_MIB_GET_OUTPUT_DATA* ppimgod,
    OUT PDWORD                      pdwOutSize
)
{

    DWORD                       dwRes           = (DWORD) -1;
    
    PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData   = NULL;

    
    *ppimgod = NULL;
    

    switch ( actionId )
    {
    case MIB_ACTION_GET :

        RIP_MIB_GET(
            pimgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
        
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if (( dwRes == ERROR_INVALID_PARAMETER ) || 
            ( dwRes == ERROR_NOT_FOUND ))
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
        }

        break;

    case MIB_ACTION_GETFIRST :

        RIP_MIB_GETFIRST(
            pimgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
        
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;
        }

        break;

    case MIB_ACTION_GETNEXT :
    
        RIP_MIB_GETNEXT(
            pimgidInData,
            sizeof( IPRIP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
        
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER || pimgodOutData==NULL)
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            break;
        }

        //
        // Get Next wraps to the next table at the end of the
        // entries in the current table.  To flag the end of a table,
        // check the end of the table.
        //
    
        if ( pimgidInData-> IMGID_TypeID != pimgodOutData-> IMGOD_TypeID )
        {
            MprAdminMIBBufferFree( pimgodOutData );
        
            dwRes = MIB_S_NO_MORE_ENTRIES;
        }

        break;

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    
    }

    if ( dwRes == NO_ERROR )
    {
        *ppimgod = pimgodOutData;
    }

    return dwRes;
}


DWORD
ValidateInterfaceConfig(
    IN  AsnAny *        objectArray
)
{
    DWORD                   dwRes       = MIB_S_INVALID_PARAMETER,
                            dwMetric    = (DWORD) -1,
                            dwMode      = (DWORD) -1;
    
    sav_ifConfigEntry*      psifce      = (sav_ifConfigEntry*) objectArray;

    
    do
    {
        //
        // verify metric is in [0..16]
        //

        dwMetric = GetAsnInteger( &( psifce-> ifCEMetric ), (DWORD) -1 );

        if ( dwMetric > 16 )
        {
            TRACE1( " Invalid metric (%d) specified ", dwMetric );
            break;            
        }


        //
        // verify update, annouce, accept modes
        //

        dwMode = GetAsnInteger( &( psifce-> ifCEUpdateMode ), (DWORD) -1 );

        if ( dwMode != d_ifCEUpdateMode_periodic &&
             dwMode != d_ifCEUpdateMode_demand )
        {
            TRACE1( " Invalid update mode (%d) specified ", dwMode );
            break;
        }

        dwMode = GetAsnInteger( &( psifce-> ifCEAcceptMode ), (DWORD) -1 );

        if ( dwMode < d_ifCEAcceptMode_disable ||
             dwMode > d_ifCEAcceptMode_rip2 )
        {
            TRACE1( " Invalid Accept mode (%d) specified ", dwMode );
            break;
        }
        
        dwMode = GetAsnInteger( &( psifce-> ifCEAnnounceMode ), (DWORD) -1 );

        if ( dwMode < d_ifCEAnnounceMode_disable ||
             dwMode > d_ifCEAnnounceMode_rip2 )
        {
            TRACE1( " Invalid Announce mode (%d) specified ", dwMode );
            break;
        }

        //
        // Verify protcol flags, authentication type
        //

        dwMode = GetAsnInteger( &( psifce-> ifCEProtocolFlags ), (DWORD) -1 );

        if ( dwMode > MAX_PROTOCOL_FLAG_VALUE )
        {
            TRACE1( " Invalid protocol flags (%d) specified ", dwMode );
            break;
        }
        
        dwMode = GetAsnInteger( 
                    &( psifce-> ifCEAuthenticationType ), 
                    (DWORD) -1
                 );

        if ( dwMode < d_ifCEAuthenticationType_noAuthentication ||
             dwMode > d_ifCEAuthenticationType_md5 )
        {
            TRACE1( " Invalid authentication type (%d) specified ", dwMode );
            break;
        }
        
        //
        // Verify Unicast peer, Announce/Accept filter modes
        //
        
        dwMode = GetAsnInteger( &( psifce-> ifCEUnicastPeerMode ), (DWORD) -1 );

        if ( dwMode < d_ifCEUnicastPeerMode_disable ||
             dwMode > d_ifCEUnicastPeerMode_peerOnly )
        {
            TRACE1( " Invalid Unicast Peer mode (%d) specified ", dwMode );
            break;
        }

        dwMode = GetAsnInteger( 
                    &( psifce-> ifCEAcceptFilterMode ), 
                    (DWORD) -1 
                 );

        if ( dwMode < d_ifCEAcceptFilterMode_disable ||
             dwMode > d_ifCEAcceptFilterMode_exclude )
        {
            TRACE1( " Invalid Accept Filter mode (%d) specified ", dwMode );
            break;
        }

        
        dwMode = GetAsnInteger( 
                    &( psifce-> ifCEAnnounceFilterMode ), 
                    (DWORD) -1 
                 );

        if ( dwMode < d_ifCEAnnounceFilterMode_disable ||
             dwMode > d_ifCEAnnounceFilterMode_exclude )
        {
            TRACE1( " Invalid Announce Filter mode (%d) specified ", dwMode );
            break;
        }

        dwRes = MIB_S_SUCCESS;
        
    } while ( FALSE );

    return dwRes;
}


DWORD
SetInterfaceConfig(
    IN  AsnAny *    objectArray
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    sav_ifConfigEntry*              psifce      = NULL;

    PIPRIP_IF_CONFIG                piic        = NULL;
    PIPRIP_MIB_SET_INPUT_DATA       pimsidInData= NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA      pimgodOutData = NULL;
    IPRIP_MIB_GET_INPUT_DATA        imgidInData;


    do
    {
        //
        // Retrieve existing interface config
        //

        psifce                      = (sav_ifConfigEntry*) objectArray;

        imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;

        imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                        &( psifce-> ifCEIndex ),
                                        (DWORD) -1
                                      );

        dwRes = GetInterfaceInfo(
                    MIB_ACTION_GET,
                    &imgidInData,
                    &pimgodOutData,
                    &dwGetSize
                );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        //
        // Update fields
        //

        piic = (PIPRIP_IF_CONFIG) (pimgodOutData-> IMGOD_Buffer);

        piic-> IC_Metric = GetAsnInteger( 
                                &( psifce-> ifCEMetric ),
                                piic-> IC_Metric
                            );

                                   
        piic-> IC_UpdateMode = GetAsnInteger( 
                                    &( psifce-> ifCEUpdateMode ),
                                    piic-> IC_UpdateMode
                                );

        piic-> IC_AcceptMode = GetAsnInteger(
                                    &( psifce-> ifCEAcceptMode ),
                                    piic-> IC_AcceptMode
                                );

        piic-> IC_AnnounceMode = GetAsnInteger(
                                    &( psifce-> ifCEAnnounceMode ),
                                    piic-> IC_AnnounceMode
                                );

        piic-> IC_ProtocolFlags = GetAsnInteger(
                                    &( psifce-> ifCEProtocolFlags ),
                                    piic-> IC_ProtocolFlags
                                  );
                                
        piic-> IC_RouteExpirationInterval = GetAsnTimeTicks(
                                    &( psifce-> ifCERouteExpirationInterval ),
                                    piic-> IC_RouteExpirationInterval
                                );
                               
        piic-> IC_RouteRemovalInterval = GetAsnTimeTicks(
                                    &( psifce-> ifCERouteRemovalInterval ),
                                    piic-> IC_RouteRemovalInterval
                               );

        piic-> IC_FullUpdateInterval = GetAsnTimeTicks(
                                    &( psifce-> ifCEFullUpdateInterval ),
                                    piic-> IC_FullUpdateInterval
                               );

        piic-> IC_AuthenticationType = GetAsnInteger(
                                    &( psifce-> ifCEAuthenticationType ),
                                    piic-> IC_AuthenticationType
                                  );

        GetAsnOctetString(
            piic-> IC_AuthenticationKey,
            &( psifce-> ifCEAuthenticationKey )
        );

        piic-> IC_RouteTag = (USHORT) GetAsnInteger(
                                    &( psifce-> ifCERouteTag ),
                                    piic-> IC_RouteTag
                                  );
        
        piic-> IC_UnicastPeerMode = GetAsnInteger(
                                    &( psifce-> ifCEUnicastPeerMode ),
                                    piic-> IC_UnicastPeerMode
                                  );

        piic-> IC_AcceptFilterMode = GetAsnInteger(
                                    &( psifce-> ifCEAcceptFilterMode ),
                                    piic-> IC_AcceptFilterMode
                                  );

        piic-> IC_AnnounceFilterMode = GetAsnInteger(
                                    &( psifce-> ifCEAnnounceFilterMode ),
                                    piic-> IC_AnnounceFilterMode
                                  );

        //
        // Save inteface config
        //

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA) - 1 +
                    IPRIP_IF_CONFIG_SIZE( piic );

        pimsidInData = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( !pimsidInData )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( " Not enough memory " );
            break;
        }

        pimsidInData-> IMSID_TypeID     = IPRIP_IF_CONFIG_ID;
        
        pimsidInData-> IMSID_IfIndex    = imgidInData.IMGID_IfIndex;

        pimsidInData-> IMSID_BufferSize = IPRIP_IF_CONFIG_SIZE( piic );

        CopyMemory( 
            pimsidInData-> IMSID_Buffer,
            piic,
            pimsidInData-> IMSID_BufferSize
        );

        RIP_MIB_SET(
            pimsidInData,
            dwSetSize,
            dwRes
        );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        dwRes = MIB_S_SUCCESS;
        
    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    if ( pimsidInData ) { RIP_MIB_FREE( pimsidInData ); }

    return dwRes;
}


DWORD
UpdateUnicastPeerEntry(
    IN  AsnAny *        objectArray,
    IN  DWORD           dwOp
)
{
    DWORD                       dwRes       = (DWORD) -1,
                                dwInd       = 0,
                                dwPeerAddr  = INADDR_NONE,
                                dwGetSize   = 0,
                                dwSetSize   = 0;

    PDWORD                      pdwAddrTable= 0;                                    

    sav_ifUnicastPeersEntry *   psifupe     = NULL;

    PIPRIP_IF_CONFIG            piic        = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid      = NULL;

    PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData = NULL;
    
    IPRIP_MIB_GET_INPUT_DATA    imgidInData;


    do
    {
        //
        // Get interface config info
        //
    
        psifupe = (sav_ifUnicastPeersEntry*) objectArray;
        
        imgidInData.IMGID_TypeID    = IPRIP_IF_CONFIG_ID;
        imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                        &( psifupe-> ifUPIfIndex ),
                                        0
                                      );
        
        dwRes = GetInterfaceInfo(
                    MIB_ACTION_GET,
                    &imgidInData,
                    &pimgodOutData,
                    &dwGetSize
                );
                
        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        //
        // Find Peer entry
        //
        
        dwPeerAddr  = GetAsnIPAddress( &( psifupe-> ifUPAddress ), 0 );

        piic        = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        pdwAddrTable= IPRIP_IF_UNICAST_PEER_TABLE( piic );

        FIND_PEER_ENTRY(
            dwPeerAddr,
            piic-> IC_UnicastPeerCount,
            pdwAddrTable,
            dwInd
        );

        //
        // if operation is filter add
        //
        
        if ( dwOp == d_Tag_create )
        {
            //
            // if peer already present, quit
            //
            
            if ( piic-> IC_UnicastPeerCount &&
                 dwInd < piic-> IC_UnicastPeerCount )
            {
                dwRes = MIB_S_SUCCESS;
                break;
            }

            else
            {
                dwRes = AddUnicastPeerEntry( 
                            dwPeerAddr, 
                            pimgodOutData
                        );
            }

            break;
        }

        //
        // operation is filter delete
        //

        //
        // if peer is not present quit.
        //
        
        if ( !piic-> IC_UnicastPeerCount ||
             dwInd >= piic-> IC_UnicastPeerCount )
        {
            dwRes = MIB_S_SUCCESS;
            break;
        }

        dwRes = DeleteUnicastPeerEntry(
                    dwInd,
                    pimgodOutData
                );
                
    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    return dwRes;
    
}


DWORD
AddUnicastPeerEntry(
    IN  DWORD                       dwPeer,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{

    DWORD                       dwRes           = (DWORD) -1,
                                dwSetSize       = 0;

    PDWORD                      pdwAddrTable    = NULL;

    PIPRIP_IF_CONFIG            piicOld         = NULL,
                                piicNew         = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid          = NULL;
    
    do
    {
        //
        // Allocate new info block
        //

        piicOld = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                    IPRIP_IF_CONFIG_SIZE( piicOld ) + sizeof( DWORD );

        pimsid = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( pimsid == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 ( "Memory allocation failed" );
            break;
        }

        //
        // Add unicast peer
        //

        pimsid-> IMSID_TypeID       = IPRIP_IF_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = pimgodOutData-> IMGOD_IfIndex;

        pimsid-> IMSID_BufferSize   = IPRIP_IF_CONFIG_SIZE( piicOld ) + 
                                      sizeof( DWORD );

        piicNew                     = (PIPRIP_IF_CONFIG) pimsid-> IMSID_Buffer;

        
        CopyMemory(
            (PVOID) piicNew,
            (VOID *) piicOld,
            sizeof( IPRIP_IF_CONFIG ) +
            piicOld-> IC_UnicastPeerCount * sizeof( DWORD )
        );

        pdwAddrTable = IPRIP_IF_UNICAST_PEER_TABLE( piicNew );

        pdwAddrTable[ piicNew-> IC_UnicastPeerCount ] = dwPeer;

        piicNew-> IC_UnicastPeerCount++;

        //
        // Copy Filters
        //

        CopyMemory(
            (PVOID) IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew ),
            (VOID *) IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld ),
            piicOld-> IC_AcceptFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );

        CopyMemory(
            (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
            (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
            piicOld-> IC_AnnounceFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );
        
        //
        // Set info. in MIB
        //

        RIP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );

    } while ( FALSE );

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }

    return dwRes;
}

DWORD
DeleteUnicastPeerEntry(
    IN  DWORD                       dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{

    DWORD                       dwRes           = (DWORD) -1,
                                dwSetSize       = 0;

    PDWORD                      pdwSrc          = NULL,
                                pdwDst          = NULL;

    PIPRIP_IF_CONFIG            piicOld         = NULL,
                                piicNew         = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid          = NULL;


    do
    {
        // 
        // Compute size of new interface config
        // 

        piicOld = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 + 
                    IPRIP_IF_CONFIG_SIZE( piicOld ) - sizeof ( DWORD );

        pimsid = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( pimsid == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "Memory Allocation Failed" );
            break;
        }

        pimsid-> IMSID_TypeID       = IPRIP_GLOBAL_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = pimgodOutData-> IMGOD_IfIndex;

        pimsid-> IMSID_BufferSize   = IPRIP_IF_CONFIG_SIZE( piicOld ) -
                                      sizeof( DWORD );

        piicNew = (PIPRIP_IF_CONFIG) pimsid-> IMSID_Buffer;
        
        //
        // Copy base config info.
        //

        CopyMemory(
            (PVOID) piicNew,
            (VOID *) piicOld,
            sizeof( IPRIP_IF_CONFIG )
        );


        //
        // Delete specified peer 
        //
        
        pdwSrc = IPRIP_IF_UNICAST_PEER_TABLE( piicOld );

        pdwDst = IPRIP_IF_UNICAST_PEER_TABLE( piicNew );

        DELETE_PEER_ENTRY(
            dwIndex,
            piicOld-> IC_UnicastPeerCount,
            pdwSrc,
            pdwDst
        );

        piicNew-> IC_UnicastPeerCount--;

        //
        // Copy filters
        //
        
        CopyMemory(
            (PVOID) IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew ),
            (VOID *) IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld ),
            piicOld-> IC_AcceptFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );

        CopyMemory(
            (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
            (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
            piicOld-> IC_AnnounceFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );
        
        //
        // Set info. in MIB
        //

        RIP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );

    } while ( FALSE );

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }

    return dwRes;
}


DWORD
UpdateFilterTable(
    IN  DWORD                   dwOp,
    IN  DWORD                   dwIfIndex,
    IN  DWORD                   dwFiltType,
    IN  PIPRIP_ROUTE_FILTER     pirfFilt
)
{

    DWORD                       dwRes           = (DWORD) -1,
                                dwGetSize       = 0,
                                dwIndex         = (DWORD) -1,
                                dwCount         = 0;

    PIPRIP_IF_CONFIG            piic            = NULL;

    PIPRIP_ROUTE_FILTER         pirfLst         = NULL;
    
    PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData   = NULL;

    IPRIP_MIB_GET_INPUT_DATA    imgidInData;


    do
    {
        
        imgidInData.IMGID_TypeID    = IPRIP_GLOBAL_CONFIG_ID;

        imgidInData.IMGID_IfIndex   = dwIfIndex;
        
        dwRes = GetInterfaceInfo(
                    MIB_ACTION_GET,
                    &imgidInData,
                    &pimgodOutData,
                    &dwGetSize
                );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        //
        // find filter
        //

        piic = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        if ( dwFiltType == RIP_MIB_ACCEPT_FILTER )
        {
            dwCount = piic-> IC_AcceptFilterCount;
            
            pirfLst = IPRIP_IF_ACCEPT_FILTER_TABLE( piic );
        }

        else
        {
            dwCount = piic-> IC_AnnounceFilterCount;
            
            pirfLst = IPRIP_IF_ANNOUNCE_FILTER_TABLE( piic );
        }

        FIND_FILTER( 
            pirfFilt,
            dwCount,
            pirfLst,
            dwIndex
        );

        if ( dwOp == d_Tag_create )
        {
            //
            // check if filter is already present
            //
            
            if ( dwCount && dwIndex < dwCount )
            {
                dwRes = MIB_S_SUCCESS;
                break;
            }

            dwRes = AddFilterEntry(
                        dwFiltType,
                        pirfFilt,
                        pimgodOutData
                    );

            break;                    
        }

        //
        // Must be a delete operation
        //

        if ( !dwCount || dwIndex >= dwCount )
        {
            dwRes = MIB_S_SUCCESS;
            break;
        }

        dwRes = DeleteFilterEntry(
                    dwFiltType,
                    dwIndex,
                    pimgodOutData
                );

    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    return dwRes;
}


DWORD
AddFilterEntry(
    IN  DWORD                       dwFiltType,
    IN  PIPRIP_ROUTE_FILTER         pirfFilt,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{
    DWORD                       dwRes           = (DWORD) -1,
                                dwSetSize       = 0,
                                dwIndex         = (DWORD) -1,
                                dwCount         = 0;

    PIPRIP_IF_CONFIG            piicOld         = NULL,
                                piicNew         = NULL;

    PIPRIP_ROUTE_FILTER         pirfLst         = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid          = NULL;

    do
    {
        //
        // Compute size of new config and allocate block for it.
        // 

        piicOld = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                    IPRIP_IF_CONFIG_SIZE( piicOld) + 
                    sizeof( IPRIP_ROUTE_FILTER );

        pimsid = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( pimsid == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "Memory Allocation Failed" );
            break;
        }

        //
        // set up the new config block.
        //

        pimsid-> IMSID_TypeID       = IPRIP_IF_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = pimgodOutData-> IMGOD_IfIndex;

        pimsid-> IMSID_BufferSize   = IPRIP_IF_CONFIG_SIZE( piicOld ) + 
                                      sizeof( DWORD );

        piicNew                     = (PIPRIP_IF_CONFIG) pimsid-> IMSID_Buffer;

        CopyMemory(
            (PVOID) piicNew,
            (VOID *) piicOld,
            sizeof( IPRIP_IF_CONFIG ) + 
            piicOld-> IC_UnicastPeerCount * sizeof( DWORD ) +
            piicOld-> IC_AcceptFilterCount * sizeof ( IPRIP_ROUTE_FILTER )
        );

        //
        // if accept filter is being added, added to end of
        // accept fitler table, and copy the annouce filters
        //
        
        if ( dwFiltType == RIP_MIB_ACCEPT_FILTER )
        {
            pirfLst = IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew );

            pirfLst[ piicNew-> IC_AcceptFilterCount++ ] = *pirfFilt;

            CopyMemory(
                (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
                (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
                piicNew-> IC_AnnounceFilterCount * sizeof( IPRIP_ROUTE_FILTER )
            );
        }

        else
        {
            CopyMemory(
                (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
                (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
                piicNew-> IC_AnnounceFilterCount * sizeof( IPRIP_ROUTE_FILTER )
            );
            
            pirfLst = IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew );

            pirfLst[ piicNew-> IC_AnnounceFilterCount++ ] = *pirfFilt;
        }

        //
        // Update the MIB with the new config
        //
        
        RIP_MIB_SET( pimsid, dwSetSize, dwRes );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
        }
        
    } while ( FALSE );

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }

    return dwRes;
}



DWORD
DeleteFilterEntry(
    IN  DWORD                       dwFiltType,
    IN  DWORD                       dwIndex,
    IN  PIPRIP_MIB_GET_OUTPUT_DATA  pimgodOutData
)
{
    DWORD                       dwRes           = (DWORD) -1,
                                dwSetSize       = 0,
                                dwCount         = 0;

    PIPRIP_IF_CONFIG            piicOld         = NULL,
                                piicNew         = NULL;

    PIPRIP_ROUTE_FILTER         pirfSrc         = NULL,
                                pirfDst         = NULL;
    
    PIPRIP_MIB_SET_INPUT_DATA   pimsid          = NULL;


    do
    {
        //
        // Compute size of new config and allocate block for it.
        // 

        piicOld = (PIPRIP_IF_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize = sizeof( IPRIP_MIB_SET_INPUT_DATA ) - 1 +
                    IPRIP_IF_CONFIG_SIZE( piicOld ) - 
                    sizeof( IPRIP_ROUTE_FILTER );

        pimsid = (PIPRIP_MIB_SET_INPUT_DATA) RIP_MIB_ALLOC( dwSetSize );

        if ( pimsid == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "Memory Allocation Failed" );
            break;
        }

        //
        // set up the new config block.
        //

        pimsid-> IMSID_TypeID       = IPRIP_IF_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = pimgodOutData-> IMGOD_IfIndex;

        pimsid-> IMSID_BufferSize   = IPRIP_IF_CONFIG_SIZE( piicOld ) + 
                                      sizeof( DWORD );

        piicNew                     = (PIPRIP_IF_CONFIG) pimsid-> IMSID_Buffer;

        CopyMemory(
            (PVOID) piicNew,
            (VOID *) piicOld,
            sizeof( IPRIP_IF_CONFIG ) + 
            piicOld-> IC_UnicastPeerCount * sizeof( DWORD )
        );

        if ( dwFiltType == RIP_MIB_ACCEPT_FILTER )
        {
            pirfSrc = IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld );

            pirfDst = IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew );

            DELETE_FILTER( 
                dwIndex, 
                piicOld-> IC_AcceptFilterCount,
                pirfSrc,
                pirfDst
            );
            
            piicNew-> IC_AcceptFilterCount--;

            CopyMemory(
                (PVOID) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicNew ),
                (VOID *) IPRIP_IF_ANNOUNCE_FILTER_TABLE( piicOld ),
                piicNew-> IC_AnnounceFilterCount * sizeof( IPRIP_ROUTE_FILTER )
            );
        }

        else
        {
            CopyMemory(
                (PVOID) IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew ),
                (VOID *) IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld ),
                piicNew-> IC_AcceptFilterCount * sizeof( IPRIP_ROUTE_FILTER )
            );
            
            pirfSrc = IPRIP_IF_ACCEPT_FILTER_TABLE( piicOld );

            pirfDst = IPRIP_IF_ACCEPT_FILTER_TABLE( piicNew );

            DELETE_FILTER( 
                dwIndex, 
                piicOld-> IC_AnnounceFilterCount,
                pirfSrc,
                pirfDst
            );
            
            piicNew-> IC_AnnounceFilterCount--;
        }

        RIP_MIB_SET( pimsid, dwSetSize, dwRes );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
        }
        
    } while ( FALSE );

    if ( pimsid ) { RIP_MIB_FREE( pimsid ); }

    return dwRes;
}


DWORD
ConnectToRouter()
{
    DWORD       dwRes = (DWORD) -1;
    

    EnterCriticalSection( &g_CS );

    do
    {
        MPR_SERVER_HANDLE hTmp;

        if ( g_hMIBServer )
        {
            dwRes = NO_ERROR;
            break;
        }

        dwRes = MprAdminMIBServerConnect( NULL, &hTmp );

        if ( dwRes == NO_ERROR )
        {
            InterlockedExchangePointer(&g_hMIBServer, hTmp );
        }
        else
        {
            TRACE1( 
                "Error %d setting up DIM connection to MIB Server\n", 
                dwRes
            );
        }
        
    } while ( FALSE );

    LeaveCriticalSection( &g_CS );

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ripagnt\mibfuncs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibfuncs.h

Abstract:

    Sample subagent instrumentation callbacks.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#ifndef _MIBFUNCS_H_
#define _MIBFUNCS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group (1.3.6.1.4.1.311.1.11.1)                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_global {
    AsnAny globalSystemRouteChanges;        
    AsnAny globalTotalResponseSends;        
    AsnAny globalLoggingLevel;              
    AsnAny globalMaxRecQueueSize;           
    AsnAny globalMaxSendQueueSize;
    AsnAny globalMinTriggeredUpdateInterval;
    AsnAny globalPeerFilterMode;            
    AsnAny globalPeerFilterCount;           
 } buf_global;

typedef struct _sav_global {
    AsnAny globalLoggingLevel;              
    AsnAny globalMaxRecQueueSize;           
    AsnAny globalMaxSendQueueSize;          
    AsnAny globalMinTriggeredUpdateInterval;
    AsnAny globalPeerFilterMode;            
} sav_global;

#define gf_globalSystemRouteChanges                 get_global
#define gf_globalTotalResponseSends                 get_global
#define gf_globalLoggingLevel                       get_global
#define gf_globalMaxRecQueueSize                    get_global
#define gf_globalMaxSendQueueSize                   get_global
#define gf_globalMinTriggeredUpdateInterval         get_global
#define gf_globalPeerFilterMode                     get_global
#define gf_globalPeerFilterCount                    get_global

#define gb_globalSystemRouteChanges                 buf_global
#define gb_globalTotalResponseSends                 buf_global
#define gb_globalLoggingLevel                       buf_global
#define gb_globalMaxRecQueueSize                    buf_global
#define gb_globalMaxSendQueueSize                   buf_global
#define gb_globalMinTriggeredUpdateInterval         buf_global
#define gb_globalPeerFilterMode                     buf_global
#define gb_globalPeerFilterCount                    buf_global

#define sf_globalLoggingLevel                       set_global
#define sf_globalMaxRecQueueSize                    set_global
#define sf_globalMaxSendQueueSize                   set_global
#define sf_globalMinTriggeredUpdateInterval         set_global
#define sf_globalPeerFilterMode                     set_global

#define sb_globalLoggingLevel                       sav_global
#define sb_globalMaxRecQueueSize                    sav_global
#define sb_globalMaxSendQueueSize                   sav_global
#define sb_globalMinTriggeredUpdateInterval         sav_global
#define sb_globalPeerFilterMode                     sav_global

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalPeerFilterEntry table (1.3.6.1.4.1.311.1.11.1.9.1)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_globalPeerFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_globalPeerFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_globalPeerFilterEntry {
    AsnAny globalPFAddr;
    AsnAny globalPFTag;
    DWORD  dwPeerFilterAddr;
} buf_globalPeerFilterEntry;

typedef struct _sav_globalPeerFilterEntry {
    AsnAny globalPFAddr;
    AsnAny globalPFTag;
} sav_globalPeerFilterEntry;

#define gf_globalPFAddr                    get_globalPeerFilterEntry
#define gf_globalPFTag                     get_globalPeerFilterEntry

#define gb_globalPFAddr                    buf_globalPeerFilterEntry
#define gb_globalPFTag                     buf_globalPeerFilterEntry

#define sf_globalPFAddr                    set_globalPeerFilterEntry
#define sf_globalPFTag                     set_globalPeerFilterEntry

#define sb_globalPFAddr                    sav_globalPeerFilterEntry
#define sb_globalPFTag                     sav_globalPeerFilterEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// interface group (1.3.6.1.4.1.311.1.11.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.11.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifStatsEntry {
    AsnAny ifSEIndex;                         
    AsnAny ifSEState;                         
    AsnAny ifSESendFailures;                  
    AsnAny ifSEReceiveFailures;               
    AsnAny ifSERequestSends;                  
    AsnAny ifSERequestReceiveds;              
    AsnAny ifSEResponseSends;                 
    AsnAny ifSEResponseReceiveds;             
    AsnAny ifSEBadResponsePacketReceiveds;    
    AsnAny ifSEBadResponseEntriesReceiveds;   
    AsnAny ifSETriggeredUpdateSends;          
    DWORD  dwIfIndex;
} buf_ifStatsEntry;

#define gf_ifSEIndex                                get_ifStatsEntry
#define gf_ifSEState                                get_ifStatsEntry
#define gf_ifSESendFailures                         get_ifStatsEntry
#define gf_ifSEReceiveFailures                      get_ifStatsEntry
#define gf_ifSERequestSends                         get_ifStatsEntry
#define gf_ifSERequestReceiveds                     get_ifStatsEntry
#define gf_ifSEResponseSends                        get_ifStatsEntry
#define gf_ifSEResponseReceiveds                    get_ifStatsEntry
#define gf_ifSEBadResponsePacketReceiveds           get_ifStatsEntry
#define gf_ifSEBadResponseEntriesReceiveds          get_ifStatsEntry
#define gf_ifSETriggeredUpdateSends                 get_ifStatsEntry

#define gb_ifSEIndex                                buf_ifStatsEntry
#define gb_ifSEState                                buf_ifStatsEntry
#define gb_ifSESendFailures                         buf_ifStatsEntry
#define gb_ifSEReceiveFailures                      buf_ifStatsEntry
#define gb_ifSERequestSends                         buf_ifStatsEntry
#define gb_ifSERequestReceiveds                     buf_ifStatsEntry
#define gb_ifSEResponseSends                        buf_ifStatsEntry
#define gb_ifSEResponseReceiveds                    buf_ifStatsEntry
#define gb_ifSEBadResponsePacketReceiveds           buf_ifStatsEntry
#define gb_ifSEBadResponseEntriesReceiveds          buf_ifStatsEntry
#define gb_ifSETriggeredUpdateSends                 buf_ifStatsEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.11.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifConfigEntry {
    AsnAny ifCEIndex;                  
    AsnAny ifCEState;                  
    AsnAny ifCEMetric;                 
    AsnAny ifCEUpdateMode;             
    AsnAny ifCEAcceptMode;             
    AsnAny ifCEAnnounceMode;           
    AsnAny ifCEProtocolFlags;         
    AsnAny ifCERouteExpirationInterval;
    AsnAny ifCERouteRemovalInterval;   
    AsnAny ifCEFullUpdateInterval;     
    AsnAny ifCEAuthenticationType;     
    AsnAny ifCEAuthenticationKey;      
    AsnAny ifCERouteTag;               
    AsnAny ifCEUnicastPeerMode;        
    AsnAny ifCEAcceptFilterMode;      
    AsnAny ifCEAnnounceFilterMode;     
    AsnAny ifCEUnicastPeerCount;       
    AsnAny ifCEAcceptFilterCount;      
    AsnAny ifCEAnnounceFilterCount;    
    DWORD  dwifIndex;
    BYTE   pbAuthKey[IPRIP_MAX_AUTHKEY_SIZE];
} buf_ifConfigEntry;

typedef struct _sav_ifConfigEntry {
    AsnAny ifCEIndex;                  
//    AsnAny ifCEState;                  
    AsnAny ifCEMetric;                 
    AsnAny ifCEUpdateMode;             
    AsnAny ifCEAcceptMode;             
    AsnAny ifCEAnnounceMode;           
    AsnAny ifCEProtocolFlags;         
    AsnAny ifCERouteExpirationInterval;
    AsnAny ifCERouteRemovalInterval;   
    AsnAny ifCEFullUpdateInterval;     
    AsnAny ifCEAuthenticationType;     
    AsnAny ifCEAuthenticationKey;      
    AsnAny ifCERouteTag;               
    AsnAny ifCEUnicastPeerMode;        
    AsnAny ifCEAcceptFilterMode;      
    AsnAny ifCEAnnounceFilterMode;     
} sav_ifConfigEntry;

#define gf_ifCEIndex                            get_ifConfigEntry
#define gf_ifCEState                            get_ifConfigEntry
#define gf_ifCEMetric                           get_ifConfigEntry
#define gf_ifCEUpdateMode                       get_ifConfigEntry
#define gf_ifCEAcceptMode                       get_ifConfigEntry
#define gf_ifCEAnnounceMode                     get_ifConfigEntry
#define gf_ifCEProtocolFlags                    get_ifConfigEntry
#define gf_ifCERouteExpirationInterval          get_ifConfigEntry
#define gf_ifCERouteRemovalInterval             get_ifConfigEntry
#define gf_ifCEFullUpdateInterval               get_ifConfigEntry
#define gf_ifCEAuthenticationType               get_ifConfigEntry
#define gf_ifCEAuthenticationKey                get_ifConfigEntry
#define gf_ifCERouteTag                         get_ifConfigEntry
#define gf_ifCEUnicastPeerMode                  get_ifConfigEntry
#define gf_ifCEAcceptFilterMode                 get_ifConfigEntry
#define gf_ifCEAnnounceFilterMode               get_ifConfigEntry
#define gf_ifCEUnicastPeerCount                 get_ifConfigEntry
#define gf_ifCEAcceptFilterCount                get_ifConfigEntry
#define gf_ifCEAnnounceFilterCount              get_ifConfigEntry

#define gb_ifCEIndex                            buf_ifConfigEntry
#define gb_ifCEState                            buf_ifConfigEntry
#define gb_ifCEMetric                           buf_ifConfigEntry
#define gb_ifCEUpdateMode                       buf_ifConfigEntry
#define gb_ifCEAcceptMode                       buf_ifConfigEntry
#define gb_ifCEAnnounceMode                     buf_ifConfigEntry
#define gb_ifCEProtocolFlags                    buf_ifConfigEntry
#define gb_ifCERouteExpirationInterval          buf_ifConfigEntry
#define gb_ifCERouteRemovalInterval             buf_ifConfigEntry
#define gb_ifCEFullUpdateInterval               buf_ifConfigEntry
#define gb_ifCEAuthenticationType               buf_ifConfigEntry
#define gb_ifCEAuthenticationKey                buf_ifConfigEntry
#define gb_ifCERouteTag                         buf_ifConfigEntry
#define gb_ifCEUnicastPeerMode                  buf_ifConfigEntry
#define gb_ifCEAcceptFilterMode                 buf_ifConfigEntry
#define gb_ifCEAnnounceFilterMode               buf_ifConfigEntry
#define gb_ifCEUnicastPeerCount                 buf_ifConfigEntry
#define gb_ifCEAcceptFilterCount                buf_ifConfigEntry
#define gb_ifCEAnnounceFilterCount              buf_ifConfigEntry

#define sf_ifCEIndex                            set_ifConfigEntry
//#define sf_ifCEState                            set_ifConfigEntry
#define sf_ifCEMetric                           set_ifConfigEntry
#define sf_ifCEUpdateMode                       set_ifConfigEntry
#define sf_ifCEAcceptMode                       set_ifConfigEntry
#define sf_ifCEAnnounceMode                     set_ifConfigEntry
#define sf_ifCEProtocolFlags                    set_ifConfigEntry
#define sf_ifCERouteExpirationInterval          set_ifConfigEntry
#define sf_ifCERouteRemovalInterval             set_ifConfigEntry
#define sf_ifCEFullUpdateInterval               set_ifConfigEntry
#define sf_ifCEAuthenticationType               set_ifConfigEntry
#define sf_ifCEAuthenticationKey                set_ifConfigEntry
#define sf_ifCERouteTag                         set_ifConfigEntry
#define sf_ifCEUnicastPeerMode                  set_ifConfigEntry
#define sf_ifCEAcceptFilterMode                 set_ifConfigEntry
#define sf_ifCEAnnounceFilterMode               set_ifConfigEntry

#define sb_ifCEIndex                            sav_ifConfigEntry     
//#define sb_ifCEState                            sav_ifConfigEntry
#define sb_ifCEMetric                           sav_ifConfigEntry
#define sb_ifCEUpdateMode                       sav_ifConfigEntry
#define sb_ifCEAcceptMode                       sav_ifConfigEntry
#define sb_ifCEAnnounceMode                     sav_ifConfigEntry
#define sb_ifCEProtocolFlags                    sav_ifConfigEntry
#define sb_ifCERouteExpirationInterval          sav_ifConfigEntry
#define sb_ifCERouteRemovalInterval             sav_ifConfigEntry
#define sb_ifCEFullUpdateInterval               sav_ifConfigEntry
#define sb_ifCEAuthenticationType               sav_ifConfigEntry
#define sb_ifCEAuthenticationKey                sav_ifConfigEntry
#define sb_ifCERouteTag                         sav_ifConfigEntry
#define sb_ifCEUnicastPeerMode                  sav_ifConfigEntry
#define sb_ifCEAcceptFilterMode                 sav_ifConfigEntry
#define sb_ifCEAnnounceFilterMode               sav_ifConfigEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifUnicastPeersEntry table (1.3.6.1.4.1.311.1.11.2.3.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifUnicastPeersEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ifUnicastPeersEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifUnicastPeersEntry {
    AsnAny ifUPIfIndex;
    AsnAny ifUPAddress;
    AsnAny ifUPTag;
    DWORD  dwIfIndex;
    DWORD  dwUnicastPeerAddr;
} buf_ifUnicastPeersEntry;

typedef struct _sav_ifUnicastPeersEntry {
    AsnAny ifUPIfIndex;
    AsnAny ifUPAddress;
    AsnAny ifUPTag;
} sav_ifUnicastPeersEntry;
                        
#define gf_ifUPIfIndex                      get_ifUnicastPeersEntry
#define gf_ifUPAddress                      get_ifUnicastPeersEntry
#define gf_ifUPTag                          get_ifUnicastPeersEntry

#define gb_ifUPIfIndex                      buf_ifUnicastPeersEntry
#define gb_ifUPAddress                      buf_ifUnicastPeersEntry
#define gb_ifUPTag                          buf_ifUnicastPeersEntry

#define sf_ifUPIfIndex                      set_ifUnicastPeersEntry
#define sf_ifUPAddress                      set_ifUnicastPeersEntry
#define sf_ifUPTag                          set_ifUnicastPeersEntry

#define sb_ifUPIfIndex                      sav_ifUnicastPeersEntry
#define sb_ifUPAddress                      sav_ifUnicastPeersEntry
#define sb_ifUPTag                          sav_ifUnicastPeersEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAcceptRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.4.1)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAcceptRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ifAcceptRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifAcceptRouteFilterEntry {
    AsnAny ifAcceptRFIfIndex;    
    AsnAny ifAcceptRFLoAddress;  
    AsnAny ifAcceptRFHiAddress;
    AsnAny ifAcceptRFTag;
    DWORD  dwIfIndex;
    DWORD  dwFilterLoAddr;
    DWORD  dwFilterHiAddr;
} buf_ifAcceptRouteFilterEntry;

typedef struct _sav_ifAcceptRouteFilterEntry {
    AsnAny ifAcceptRFIfIndex;    
    AsnAny ifAcceptRFLoAddress;  
    AsnAny ifAcceptRFHiAddress;  
    AsnAny ifAcceptRFTag;
} sav_ifAcceptRouteFilterEntry;

#define gf_ifAcceptRFIfIndex                    get_ifAcceptRouteFilterEntry
#define gf_ifAcceptRFLoAddress                  get_ifAcceptRouteFilterEntry
#define gf_ifAcceptRFHiAddress                  get_ifAcceptRouteFilterEntry
#define gf_ifAcceptRFTag                        get_ifAcceptRouteFilterEntry

#define gb_ifAcceptRFIfIndex                    buf_ifAcceptRouteFilterEntry
#define gb_ifAcceptRFLoAddress                  buf_ifAcceptRouteFilterEntry
#define gb_ifAcceptRFHiAddress                  buf_ifAcceptRouteFilterEntry
#define gb_ifAcceptRFTag                        buf_ifAcceptRouteFilterEntry

#define sf_ifAcceptRFIfIndex                    set_ifAcceptRouteFilterEntry
#define sf_ifAcceptRFLoAddress                  set_ifAcceptRouteFilterEntry
#define sf_ifAcceptRFHiAddress                  set_ifAcceptRouteFilterEntry
#define sf_ifAcceptRFTag                        set_ifAcceptRouteFilterEntry

#define sb_ifAcceptRFIfIndex                    sav_ifAcceptRouteFilterEntry
#define sb_ifAcceptRFLoAddress                  sav_ifAcceptRouteFilterEntry
#define sb_ifAcceptRFHiAddress                  sav_ifAcceptRouteFilterEntry
#define sb_ifAcceptRFTag                        sav_ifAcceptRouteFilterEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAnnounceRouteFilterEntry table (1.3.6.1.4.1.311.1.11.2.5.1)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAnnounceRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ifAnnounceRouteFilterEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifAnnounceRouteFilterEntry {
    AsnAny ifAnnounceRFIfIndex;   
    AsnAny ifAnnounceRFLoAddress;
    AsnAny ifAnnounceRFHiAddress;
    AsnAny ifAnnounceRFTag;
    DWORD  dwIfIndex;
    DWORD  dwFilterLoAddr;
    DWORD  dwFilterHiAddr;
} buf_ifAnnounceRouteFilterEntry;

typedef struct _sav_ifAnnounceRouteFilterEntry {
    AsnAny ifAnnounceRFIfIndex;   
    AsnAny ifAnnounceRFLoAddress;
    AsnAny ifAnnounceRFHiAddress;
    AsnAny ifAnnounceRFTag;
} sav_ifAnnounceRouteFilterEntry;

#define gf_ifAnnounceRFIfIndex                   get_ifAnnounceRouteFilterEntry
#define gf_ifAnnounceRFLoAddress                get_ifAnnounceRouteFilterEntry
#define gf_ifAnnounceRFHiAddress                get_ifAnnounceRouteFilterEntry
#define gf_ifAnnounceRFTag                      get_ifAnnounceRouteFilterEntry

#define gb_ifAnnounceRFIfIndex                   buf_ifAnnounceRouteFilterEntry
#define gb_ifAnnounceRFLoAddress                buf_ifAnnounceRouteFilterEntry
#define gb_ifAnnounceRFHiAddress                buf_ifAnnounceRouteFilterEntry
#define gb_ifAnnounceRFTag                      buf_ifAnnounceRouteFilterEntry

#define sf_ifAnnounceRFIfIndex                   set_ifAnnounceRouteFilterEntry
#define sf_ifAnnounceRFLoAddress                set_ifAnnounceRouteFilterEntry
#define sf_ifAnnounceRFHiAddress                set_ifAnnounceRouteFilterEntry
#define sf_ifAnnounceRFTag                      set_ifAnnounceRouteFilterEntry

#define sb_ifAnnounceRFIfIndex                   sav_ifAnnounceRouteFilterEntry
#define sb_ifAnnounceRFLoAddress                sav_ifAnnounceRouteFilterEntry
#define sb_ifAnnounceRFHiAddress                sav_ifAnnounceRouteFilterEntry
#define sb_ifAnnounceRFTag                      sav_ifAnnounceRouteFilterEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.11.2.6.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifBindingEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifBindingEntry {
    AsnAny ifBindingIndex; 
    AsnAny ifBindingState; 
    AsnAny ifBindingCounts;
    DWORD  dwIfIndex;
} buf_ifBindingEntry;


#define gf_ifBindingIndex                   get_ifBindingEntry
#define gf_ifBindingState                   get_ifBindingEntry
#define gf_ifBindingCounts                  get_ifBindingEntry

#define gb_ifBindingIndex                   buf_ifBindingEntry
#define gb_ifBindingState                   buf_ifBindingEntry
#define gb_ifBindingCounts                  buf_ifBindingEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.11.2.7.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifAddressEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifAddressEntry {
    AsnAny ifAEIfIndex; 
    AsnAny ifAEAddress; 
    AsnAny ifAEMask; 
    DWORD  dwIfIndex;
    DWORD  dwAddress;
    DWORD  dwMask;
    
} buf_ifAddressEntry;

#define gf_ifAEIfIndex                      get_ifAddressEntry
#define gf_ifAEAddress                      get_ifAddressEntry
#define gf_ifAEMask                         get_ifAddressEntry

#define gb_ifAEIfIndex                      buf_ifAddressEntry
#define gb_ifAEAddress                      buf_ifAddressEntry
#define gb_ifAEMask                         buf_ifAddressEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// peer group (1.3.6.1.4.1.311.1.11.3)                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifPeerStatsEntry table (1.3.6.1.4.1.311.1.11.3.1.1)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifPeerStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifPeerStatsEntry {
    AsnAny ifPSAddress;                
    AsnAny ifPSLastPeerRouteTag;       
    AsnAny ifPSLastPeerUpdateTickCount;
    AsnAny ifPSLastPeerUpdateVersion;  
    AsnAny ifPSPeerBadResponsePackets; 
    AsnAny ifPSPeerBadResponseEntries; 
    DWORD  dwPeerAddr;

} buf_ifPeerStatsEntry;

#define gf_ifPSAddress                          get_ifPeerStatsEntry  
#define gf_ifPSLastPeerRouteTag                 get_ifPeerStatsEntry
#define gf_ifPSLastPeerUpdateTickCount          get_ifPeerStatsEntry
#define gf_ifPSLastPeerUpdateVersion            get_ifPeerStatsEntry
#define gf_ifPSPeerBadResponsePackets           get_ifPeerStatsEntry
#define gf_ifPSPeerBadResponseEntries           get_ifPeerStatsEntry

#define gb_ifPSAddress                          buf_ifPeerStatsEntry
#define gb_ifPSLastPeerRouteTag                 buf_ifPeerStatsEntry
#define gb_ifPSLastPeerUpdateTickCount          buf_ifPeerStatsEntry
#define gb_ifPSLastPeerUpdateVersion            buf_ifPeerStatsEntry
#define gb_ifPSPeerBadResponsePackets           buf_ifPeerStatsEntry
#define gb_ifPSPeerBadResponseEntries           buf_ifPeerStatsEntry

#endif // _MIBFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\work.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: work.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and functions for IPRIP's work items.
//============================================================================

#ifndef _WORK_H_
#define _WORK_H_


//
// type definition of an input context
//

typedef struct _INPUT_CONTEXT {

    DWORD           IC_InterfaceIndex;
    DWORD           IC_AddrIndex;
    SOCKADDR_IN     IC_InputSource;
    DWORD           IC_InputLength;
    IPRIP_PACKET    IC_InputPacket;

} INPUT_CONTEXT, *PINPUT_CONTEXT;


//
// type definition of a demand-update context
//

typedef struct _UPDATE_CONTEXT {

    DWORD           UC_InterfaceIndex;
    DWORD           UC_RetryCount;
    DWORD           UC_RouteCount;

} UPDATE_CONTEXT, *PUPDATE_CONTEXT;



//
// these are the type definitions of the three functions 
// that are in each update buffer's function table
//

typedef DWORD (*PSTART_BUFFER_ROUTINE)(PVOID);
typedef DWORD (*PADD_ENTRY_ROUTINE)(PVOID, PRIP_IP_ROUTE);
typedef DWORD (*PFINISH_BUFFER_ROUTINE)(PVOID);


//
// this is the definition of an update buffer. It includes the command
// to be put in the IPRIP packet header, the destination for the buffer,
// and the three update-buffer functions
//

typedef struct _UPDATE_BUFFER {
    PIF_TABLE_ENTRY         UB_ITE;
    DWORD                   UB_AddrIndex;
    DWORD                   UB_Address;
    DWORD                   UB_Netmask;
    SOCKET                  UB_Socket;
    DWORD                   UB_Command;
    DWORD                   UB_Length;
    BYTE                    UB_Buffer[MAX_PACKET_SIZE];
    SOCKADDR_IN             UB_Destination;
    DWORD                   UB_DestAddress;
    DWORD                   UB_DestNetmask;
    PADD_ENTRY_ROUTINE      UB_AddRoutine;
    PSTART_BUFFER_ROUTINE   UB_StartRoutine;
    PFINISH_BUFFER_ROUTINE  UB_FinishRoutine;
} UPDATE_BUFFER, *PUPDATE_BUFFER;


VOID WorkerFunctionNetworkEvents(PVOID pContext);
VOID WorkerFunctionProcessTimer(PVOID pContext);
VOID WorkerFunctionProcessInput(PVOID pContext);
VOID WorkerFunctionStartFullUpdate(PVOID pContext, BOOLEAN bNotUsed);
VOID WorkerFunctionFinishFullUpdate(PVOID pContext, BOOLEAN bNotUsed);
VOID WorkerFunctionStartTriggeredUpdate(PVOID pContext);
VOID WorkerFunctionFinishTriggeredUpdate(PVOID pContext, BOOLEAN bNotUsed);
VOID WorkerFunctionStartDemandUpdate(PVOID pContext);
VOID WorkerFunctionFinishDemandUpdate(PVOID pContext, BOOLEAN bNotUsed);
VOID WorkerFunctionProcessRtmMessage(PVOID pContext);
VOID WorkerFunctionActivateInterface(PVOID pContext);
VOID WorkerFunctionDeactivateInterface(PVOID pContext);
VOID WorkerFunctionFinishStopProtocol(PVOID pContext);
VOID WorkerFunctionMibDisplay(PVOID pContext, BOOLEAN bNotUsed);


DWORD
SendRoutes(
    PIF_TABLE_ENTRY pIfList[],
    DWORD dwIfCount,
    DWORD dwSendMode,
    DWORD dwDestination,
    DWORD dwAddrIndex
    );


VOID
ProcessRequest(
    PVOID pContext
    );


VOID
ProcessResponse(
    PVOID pContext
    );

DWORD
ProcessRtmNotification(
    RTM_ENTITY_HANDLE    hRtmHandle,    // not used
    RTM_EVENT_TYPE       retEventType,
    PVOID                pvContext1,    // not used
    PVOID                pvContext2     // not used
    );

VOID
CallbackFunctionProcessRtmMessage (
    PVOID   pContext, // not used
    BOOLEAN NotUsed
    );
    
VOID
CallbackFunctionProcessTimer (
    PVOID   pContext, // not used
    BOOLEAN NotUsed
    );
    
VOID
CallbackFunctionNetworkEvents (
    PVOID   pContext,
    BOOLEAN NotUsed
    );

DWORD
BlockDeleteRoutesOnInterface (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex
    );
    
#endif // _WORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ripagnt\precomp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
        precomp.h

Abstract:
        Precompiled header for the RIP-2 subagent 

Author:
        V Raman ( vraman )

Revision History:

        V Raman Aug-1-1996  Created

--*/

#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <TCHAR.H>
#include <winsock.h>
#include <snmp.h>
#include <snmpexts.h>
#include <mprapi.h>
#include <routprot.h>
#include <ipriprm.h>

#if defined( MIB_DEBUG )

#include <rtutils.h>
extern DWORD   g_dwTraceId;

#endif

#include "mibentry.h"
#include "mibfuncs.h"
#include "defs.h"

extern      MIB_SERVER_HANDLE       g_hMIBServer;
extern      CRITICAL_SECTION        g_CS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\allinc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation


Module Name:

    routing\ip\rtrmgr\allinc.h

Abstract:

    IP Router Manager header for all includes

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#ifndef __RTRMGR_ALLINC_H__
#define __RTRMGR_ALLINC_H__

#pragma warning(disable:4201)
#pragma warning(disable:4115)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <TCHAR.H>

#include <ntverp.h>

#pragma warning(default:4115)
#pragma warning(default:4201)

#include <ipexport.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <tcpinfo.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include <ntddip.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <mstcpip.h>


#include <rtmv2.h>
#include <rtutils.h>
#include <dim.h>
#include <routprot.h>
#include <mprerror.h>
#include <raserror.h>

#include <rtmmgmt.h>

#include <iprtrmib.h>

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#include <ipfltinf.h>
#include <ddipinip.h>
#include <ddipmcst.h>
#include <ddwanarp.h>

#include <iphlpstk.h>

#include <mprlog.h>
#include <iputils.h>
#include <fltdefs.h>
#include <rtinfo.h>
#include <ipinfoid.h>

#include <iprtinfo.h>
#include <iprtprio.h>
#include <priopriv.h>
#include <rmmgm.h>
#include <mgm.h>
#include <ipnat.h>

#include <rasman.h>
#include <rasppp.h>
#include <nbtioctl.h>

#include "defs.h"
#include "iprtrmib.h"
#include "rtrdisc.h"
#include "mhrtbt.h"
#include "iprtrmgr.h"
#include "proto.h"
#include "asyncwrk.h"
#include "info.h"
#include "filter.h"
#include "demand.h"
#include "if.h"
#include "map.h"
#include "mcastif.h"
#include "access.h"
#include "locate.h"
#include "ipipcfg.h"
#include "route.h"
#include "globals.h"
#include "mcmisc.h"
#include "mbound.h"

#define HAVE_RTMV2 1

#endif // __RTRMGR_ALLINC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\access.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\access.c

Abstract:

    All the "access" functions take similar arguments:

    dwQueryType     This is the type of the query and can be
                    ACCESS_GET
                    ACCESS_GET_FIRST,
                    ACCESS_GET_NEXT,
                    ACCESS_SET,
                    ACCESS_CREATE_ENTRY,
                    ACCESS_DELETE_ENTRY
                    
    dwInEntrySize   Size of the input buffer.  The information
                    in the input buffer is dependent on the query type and
                    the information being queried. The input buffer stores
                    the QueryInfo which is a variable sized structure taking
                    an array of instance ids. The dwInEntrySize is used to
                    figure out how many instance ids are in the array (since
                    and explicit count is not given)

    pInEntry        Pointer to the input buffer. This is a MIB_OPAQUE_QUERY
                    structure which contains an integer (dwType) which
                    indicates the object being queried (which is not used
                    since the demuxing based on that has already been done)
                    and a variable length array of integer instance ids
                    The instance id must be completely specified in case of
                    ACCESS_GET,
                    ACCESS_SET,
                    ACCESS_CREATE_ENTRY,
                    ACCESS_DELETE_ENTRY
                    but for the rest only the first 'n' components of
                    the instance id may be specified.
    
    pOutEntrySize   Pointer to the size of the output buffer. If this is 0
                    the caller is querying us for the size of buffer needed
                    If the supplied buffer size is too small, we set this
                    to the minimum required size and return
                    ERROR_INSUFFICIENT_BUFFER;
                    
    pOutEntry       The output buffer which is a MIB_OPAQUE_INFO structure.
                    The function fills in the dwTyoe to indicate the object
                    being returned. That type is used to cast the opaque
                    variable sized buffer following the type
    
    pbCache         Pointer to BOOL which is set to TRUE if the corresponding
                    cache was updated. This is not used currently, but may
                    be used later for optimizations

Revision History:

    Amritansh Raghav          7/8/95  Created

--*/

#include "allinc.h"

DWORD
SetIpForwardRow(
    PMIB_IPFORWARDROW pOldIpForw,
    PMIB_IPFORWARDROW pNewIpForw
    );

DWORD
DeleteIpForwardRow(
    PMIB_IPFORWARDROW pIpForw
    );


DWORD
AccessMcastMfeStatsInternal(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache,
    DWORD               dwStatsFlag
    );

DWORD 
AccessIfNumber(
    DWORD                dwQueryType, 
    DWORD                dwInEntrySize, 
    PMIB_OPAQUE_QUERY    pInEntry, 
    PDWORD               pOutEntrySize, 
    PMIB_OPAQUE_INFO     pOutEntry,
    PBOOL                pbCache
    )

/*++

Routine Description

    Retrieves the number of interfaces

Locks

    None since g_IfInfo.dwNumberOfInterfaces is InterlockXxx()ed

Arguments

    dwQueryType     ACCESS_GET
    dwInEntrySize   Dont care
    pInEntry        Dont care
    pOutEntrySize   Minimum: MAX_MIB_OFFSET + sizeof(MIB_IFNUMBER)

Return Value

    NO_ERROR

--*/

{
    PMIB_IFNUMBER   pIfNumber;
    DWORD           dwNumInterfaces;

    TraceEnter("AccessIfNumber");

    pIfNumber = (PMIB_IFNUMBER)(pOutEntry->rgbyData);

    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIfNumber");
        
        return ERROR_INVALID_PARAMETER;
    }

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IFNUMBER))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFNUMBER);

        TraceLeave("AccessIfNumber");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFNUMBER);
   
    //
    // The variable is only inc/dec using interlocked ops
    // so we dont need to take a lock here
    //
 
    pIfNumber->dwValue  = g_ulNumInterfaces;

    pOutEntry->dwId     = IF_NUMBER; 

    *pbCache = TRUE;

    TraceLeave("AccessIfNumber");
        
    return NO_ERROR;
}


DWORD 
AccessIfTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    Retrieves the Interface table

Locks

    Takes ICB list lock as READER

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IFTABLE)

Return Value

    NO_ERROR

--*/

{
    PMIB_IFTABLE    pIfTable;
    DWORD           count;
    PLIST_ENTRY     currentList;
    PICB            picb;
    DWORD           dwNumInterfaces, dwResult;
   
    TraceEnter("AccessIfTable");

    pIfTable = (PMIB_IFTABLE)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIfTable");
        
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        ENTER_READER(ICB_LIST);
        
        dwNumInterfaces = g_ulNumNonClientInterfaces;
        
        if(dwNumInterfaces is 0)
        {
            Trace0(MIB,"AccessIfTable: No valid entries found"); 

            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IFTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pIfTable->dwNumEntries  = 0;

                pOutEntry->dwId         = IF_TABLE;
                
                dwResult                = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFTABLE);
            
            break;
        }
        
        if(*pOutEntrySize < MAX_MIB_OFFSET + SIZEOF_IFTABLE(dwNumInterfaces))
        {
            *pOutEntrySize  = MAX_MIB_OFFSET + SIZEOF_IFTABLE(dwNumInterfaces);

            dwResult        = ERROR_INSUFFICIENT_BUFFER;

            break;
        }
        
        pOutEntry->dwId = IF_TABLE;
    
        *pOutEntrySize  = MAX_MIB_OFFSET + SIZEOF_IFTABLE(dwNumInterfaces);
        
        for(currentList = ICBList.Flink, count = 0 ; 
            currentList isnot &ICBList;
            currentList = currentList->Flink)
        {
            picb = CONTAINING_RECORD (currentList, ICB, leIfLink) ;
           
            //
            // NOTE WE DO NOT RETURN ANY CLIENT INTERFACES
            //
            
            if((picb->ritType is ROUTER_IF_TYPE_CLIENT) or
               ((picb->ritType is ROUTER_IF_TYPE_INTERNAL) and
                (picb->bBound is FALSE)))
            {
                continue;
            }

            dwResult = GetInterfaceStatistics(picb,
                                              pIfTable->table + count);

            if(dwResult is NO_ERROR)
            {
                count++;
            }
            else
            {
                Trace2(ERR,
                       "AccessIfTable: Error %d getting statistics for %S",
                       dwResult,
                       picb->pwszName);
            }
        }

        pIfTable->dwNumEntries = count;

        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(ICB_LIST);
        
    *pbCache = TRUE;
    
    TraceLeave("AccessIfTable");
    
    return dwResult;

}


DWORD 
AccessIfRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to set or retrieve an IFRow

Locks

    ICB List lock are READER in caces of queries, WRITER in case of SETs
    
Arguments

    dwQueryType     Can be anything other than ACCESS_DELETE_ENTRY or
                    ACCESS_CREATE_ENTRY. The only field that can be Set is
                    the adminStatus
    pInEntry        Interface index in the rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IFROW)
                    For sets, the OutEntry contains the row to set

Return Value:         

    NO_ERROR

--*/

{
    PICB        picb;
    PMIB_IFROW  pIfRow;
    DWORD       dwNumIndices, dwResult;

    TraceEnter("AccessIfRow");

    pIfRow = (PMIB_IFROW)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IFROW))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFROW);
        
        TraceLeave("AccessIfRow");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFROW);
        
    pOutEntry->dwId = IF_ROW;
    
    do
    {
        if(dwQueryType is ACCESS_SET)
        {
            ENTER_WRITER(ICB_LIST);
        }
        else
        {
            ENTER_READER(ICB_LIST);
        }
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIfRow(dwQueryType,
                               dwNumIndices,
                               pInEntry->rgdwVarIndex,
                               &picb,
                               FALSE);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
                    dwResult = GetInterfaceStatistics(picb,pIfRow);
                    
                    break;
                }
                
                case ACCESS_SET:
                {
                    dwResult = SetInterfaceStatistics(picb,pIfRow);
                    
                    break;
                }
                
                default:
                {
                    Trace1(MIB,
                           "AccessIfRow: Wrong query type %d",dwQueryType);
                    
                    dwResult = ERROR_INVALID_PARAMETER;
                    
                    break;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(ICB_LIST);
        
    *pbCache = TRUE;
    
    TraceLeave("AccessIfRow");
    
    return dwResult;
    
}

DWORD 
AccessIcmpStats(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get ICMP statistics

Locks

    None, since the stats are not cached
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_ICMP)

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_ICMP   pIcmp;
    DWORD       dwResult;

    TraceEnter("AccessIcmpStats");

    pIcmp    = (PMIB_ICMP)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIcmpStats");
        
        return ERROR_INVALID_PARAMETER;
    }

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_ICMP))
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        pOutEntry->dwId = ICMP_STATS;
        
        dwResult = GetIcmpStatsFromStack(pIcmp);
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_ICMP);

    *pbCache = TRUE;

    TraceLeave("AccessIcmpStats");
    
    return dwResult;
}

DWORD 
AccessUdpStats(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get UDP statistics

Locks

    None, since the stats are not cached
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_UDPSTATS)

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_UDPSTATS   pUdpStats;
    DWORD           dwResult;

    TraceEnter("AccessUdpStats");

    pUdpStats = (PMIB_UDPSTATS)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessUdpStats");
    
        return ERROR_INVALID_PARAMETER;
    }
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_UDPSTATS))
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        pOutEntry->dwId = UDP_STATS;
    
        *pbCache = TRUE;

        dwResult = GetUdpStatsFromStack(pUdpStats);
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_UDPSTATS);

    TraceLeave("AccessUdpStats");
    
    return dwResult;
}

DWORD 
AccessUdpTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get UDP Table

Locks

    UDP Cache lock as READER
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + SIZEOF_UDPTABLE(NumUdpEntries)

Return Value:         

    NO_ERROR

--*/

{
    PMIB_UDPTABLE   pUdpTable = (PMIB_UDPTABLE)(pOutEntry->rgbyData);
    DWORD           i,dwResult;

    TraceEnter("AccessUdpTable");
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessUdpTable");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    dwResult = UpdateCache(UDPCACHE,pbCache);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessUdpTable: Couldnt update Udp Cache. Error %d",dwResult);

        TraceLeave("AccessUdpTable");

        return dwResult;
    }
    
    do
    {
        ENTER_READER(UDPCACHE);
        
        if((g_UdpInfo.pUdpTable is NULL) or 
           (g_UdpInfo.pUdpTable->dwNumEntries is 0))
        {
            Trace0(MIB,"AccessUdpTable: No valid entries found");

            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_UDPTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = UDP_TABLE;

                pUdpTable->dwNumEntries = 0;

                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_UDPTABLE);

            break;
        }
        
        if(*pOutEntrySize <
           MAX_MIB_OFFSET + SIZEOF_UDPTABLE(g_UdpInfo.pUdpTable->dwNumEntries))
        {
            *pOutEntrySize =
                MAX_MIB_OFFSET + SIZEOF_UDPTABLE(g_UdpInfo.pUdpTable->dwNumEntries);
            
            dwResult = ERROR_INSUFFICIENT_BUFFER;

            break;
        }
        
        *pOutEntrySize =
            MAX_MIB_OFFSET + SIZEOF_UDPTABLE(g_UdpInfo.pUdpTable->dwNumEntries);
        
        pOutEntry->dwId = UDP_TABLE;
        
        for(i = 0; i < g_UdpInfo.pUdpTable->dwNumEntries; i++)
        {
            pUdpTable->table[i] = g_UdpInfo.pUdpTable->table[i];
        }
        
        pUdpTable->dwNumEntries = g_UdpInfo.pUdpTable->dwNumEntries;
        
        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(UDPCACHE);
    
    TraceLeave("AccessUdpTable");
    
    return dwResult;

}

DWORD 
AccessUdpRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve a UDP Row

Locks

    Takes the UDP Cache lock as READER
    
Arguments

    dwQueryType     Can be ACCESS_GET, ACCESS_GET_NEXT or ACCESS_GET_FIRST
    pInEntry        LocalAddr & LocalPort for the row filled in the
                    rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_UDPROW);

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/ 
{
    PMIB_UDPROW pUdpRow;
    DWORD       dwResult, dwIndex, dwNumIndices;

    TraceEnter("AccessUdpRow");

    pUdpRow = (PMIB_UDPROW)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_UDPROW))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_UDPROW);

        TraceLeave("AccessUdpRow");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_UDPROW);
    
    pOutEntry->dwId = UDP_ROW;
    
    if((dwResult = UpdateCache(UDPCACHE,pbCache)) isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessUdpRow: Couldnt update Udp Cache. Error %d", dwResult);

        TraceLeave("AccessUdpRow");
        
        return dwResult;
    }
    
    do
    {
        ENTER_READER(UDPCACHE);
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
               
        dwResult = LocateUdpRow(dwQueryType,
                                dwNumIndices,
                                pInEntry->rgdwVarIndex,
                                &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            *pUdpRow = g_UdpInfo.pUdpTable->table[dwIndex];
            
            dwResult = NO_ERROR;
        }
        
    }while(FALSE);

    EXIT_LOCK(UDPCACHE);
    
    TraceLeave("AccessUdpRow");
    
    return dwResult;

}

DWORD 
AccessTcpStats(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get TCP statistics

Locks

    None, since the stats are not cached

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_TCPSTATS)

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_TCPSTATS   pTcpStats;
    DWORD           dwResult;
    
    TraceEnter("AccessTcpStats");

    pTcpStats = (PMIB_TCPSTATS)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessTcpStats");
        
        return ERROR_INVALID_PARAMETER;
    }

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_TCPSTATS))
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        pOutEntry->dwId = TCP_STATS;

        *pbCache = TRUE;

        dwResult = GetTcpStatsFromStack(pTcpStats);
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_TCPSTATS);

    TraceLeave("AccessTcpStats");

    return dwResult;
}

DWORD 
AccessTcpTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get TCP Table

Locks

    TCP Cache lock as READER
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + SIZEOF_TCPTABLE(NumTcpEntries)

Return Value:         

    NO_ERROR

--*/

{

    PMIB_TCPTABLE   pTcpTable;
    DWORD           i, dwResult;

    TraceEnter("AccessTcpTable");

    pTcpTable = (PMIB_TCPTABLE)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if((dwResult = UpdateCache(TCPCACHE,pbCache)) isnot NO_ERROR)
    {
        
        Trace1(MIB,
               "AccessTcpTable: Couldnt update Tcp Cache. Error %d",
               dwResult);

        TraceLeave("AccessTcpTable");
        
        return dwResult;
    }
    
    do
    {
        ENTER_READER(TCPCACHE);
        
        if((g_TcpInfo.pTcpTable is NULL) or
           (g_TcpInfo.pTcpTable->dwNumEntries is 0))
        {
            Trace0(MIB,"AccessTcpTable: No valid entries found");
            
            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_TCPTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = TCP_TABLE;

                pTcpTable->dwNumEntries = 0;
                
                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_TCPTABLE);
            
            break;
        }
        
        if(*pOutEntrySize <
           MAX_MIB_OFFSET + SIZEOF_TCPTABLE(g_TcpInfo.pTcpTable->dwNumEntries))
        {
            *pOutEntrySize =
                MAX_MIB_OFFSET + SIZEOF_TCPTABLE(g_TcpInfo.pTcpTable->dwNumEntries);

            dwResult = ERROR_INSUFFICIENT_BUFFER;

            break;
        }
        
        pOutEntry->dwId = TCP_TABLE;
        
        *pOutEntrySize =
            MAX_MIB_OFFSET + SIZEOF_TCPTABLE(g_TcpInfo.pTcpTable->dwNumEntries);
        
        for(i = 0; i < g_TcpInfo.pTcpTable->dwNumEntries; i++)
        {
            pTcpTable->table[i] = g_TcpInfo.pTcpTable->table[i];
        }
        
        pTcpTable->dwNumEntries = g_TcpInfo.pTcpTable->dwNumEntries;
        
        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(TCPCACHE);
    
    TraceLeave("AccessTcpTable");
    
    return dwResult;
}

DWORD 
AccessTcpRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve or set a TCP Row

Locks

    Takes the TCP Cache lock as READER for queries and as a WRITER for
    Sets
    
Arguments

    dwQueryType     Can be anything except ACCESS_DELETE_ENTRY and
                    ACCESS_CREATE_ENTRY.
                    For ACCESS_SET, the state is the only thing that can
                    be set and it can only be set to TCP_DELETE_TCB
    pInEntry        LocalAddr, LocalPort, RemoteAddr, RemotePort for the
                    row filled in the rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_TCPROW);
                    For Sets, the OutEntry contains the row to set

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/ 
{
    DWORD       dwResult, dwNumIndices, dwIndex;
    PMIB_TCPROW pTcpRow;

    TraceEnter("AccessTcpRow");

    pTcpRow = (PMIB_TCPROW)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_DELETE_ENTRY)
    {
        if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_TCPROW))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_TCPROW);

            TraceLeave("AccessTcpRow");
        
            return ERROR_INSUFFICIENT_BUFFER;
        }
    
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_TCPROW);
    
        pOutEntry->dwId = TCP_ROW;
    }
    
    if((dwResult = UpdateCache(TCPCACHE,pbCache)) isnot NO_ERROR)
    {   
        Trace1(MIB,
               "AccessTcpRow: Couldnt update Tcp Cache. Error %d",
               dwResult);

        TraceLeave("AccessTcpRow");
        
        return dwResult;
    }
    

    do
    {
        if(dwQueryType is ACCESS_SET)
        {
            ENTER_WRITER(TCPCACHE);
        }
        else
        {
            ENTER_READER(TCPCACHE);
        }
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateTcpRow(dwQueryType,
                                dwNumIndices,
                                pInEntry->rgdwVarIndex,
                                &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
                    *pTcpRow = g_TcpInfo.pTcpTable->table[dwIndex];

                    dwResult = NO_ERROR;

                    break;
                }
                case ACCESS_SET:
                {
                    //
                    // The only thing you can do is set it to a state and that 
                    // too only to TCP_DELETE_TCB
                    //
                    
                    if(pTcpRow->dwState isnot TCP_DELETE_TCB)
                    {
                        Trace1(ERR,
                               "AccessTcpRow: TCP State can only be set to delete. Tried to set to %d",
                               pTcpRow->dwState);
                        
                        dwResult = ERROR_INVALID_DATA;

                        break;
                    }
                    
                    dwResult = SetTcpEntryToStack(pTcpRow);
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_TcpInfo.pTcpTable->table[dwIndex].dwState = 
                            pTcpRow->dwState;
                    }
                    
                    break;
                }
                default:
                {
                    Trace1(ERR,
                           "AccessTcpRow: Query type %d is wrong",
                           dwQueryType);
                    
                    dwResult = ERROR_INVALID_PARAMETER;

                    break;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(TCPCACHE);
        
    TraceLeave("AccessTcpRow");
        
    return dwResult;
}

DWORD  
AccessIpStats(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO     pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get IP statistics

Locks

    None, since the stats are not cached

Arguments

    dwQueryType     ACCESS_GET or ACCESS_SET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPSTATS)

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_IPSTATS    pIpStats;
    DWORD           dwResult;
    
    TraceEnter("AccessIpStats");

    pIpStats = (PMIB_IPSTATS)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPSTATS))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPSTATS);

        TraceLeave("AccessIpStats");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPSTATS);
    
    pOutEntry->dwId = IP_STATS;
    
    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // Since we need to write the number of routes addresses etc
            // Update the two caches
            //

            UpdateCache(IPADDRCACHE,pbCache);
            UpdateCache(IPFORWARDCACHE,pbCache);

            dwResult = GetIpStatsFromStack(pIpStats);
  
            pIpStats->dwNumIf = g_ulNumInterfaces;
            
            pIpStats->dwNumRoutes = 0;

            if(g_IpInfo.pForwardTable)
            {
                pIpStats->dwNumRoutes = g_IpInfo.pForwardTable->dwNumEntries;
            }

            pIpStats->dwNumAddr = 0;

            if(g_IpInfo.pAddrTable)
            {
                pIpStats->dwNumAddr = g_IpInfo.pAddrTable->dwNumEntries;
            }
 
            TraceLeave("AccessIpStats");
          
            return dwResult;
        }
        
        case ACCESS_SET:
        {
            MIB_IPSTATS CurrentIpStats;
            DWORD       dwErr;
          
            dwErr = GetIpStatsFromStack(&CurrentIpStats);
          
            if(dwErr isnot NO_ERROR)
            {
                Trace1(ERR,
                       "AccessIpStats: Couldnt get IPSNMP info from stack to initiate set. Error %d",
                       dwErr);
              
                return dwErr;
            }
          
            //
            // See what the current forwarding status is. We allow one to go
            // Forward -> notForward but not the other way.
            //
          
            if(pIpStats->dwDefaultTTL isnot MIB_USE_CURRENT_TTL)
            {
                if(pIpStats->dwDefaultTTL > 255)
                {
                    Trace0(ERR,"AccessIpStats: Cant set TTL > 255");
                  
                    TraceLeave("AccessIpStats");
                  
                    return ERROR_INVALID_DATA;
                }


                dwErr = SetIpStatsToStack(pIpStats);

                if(dwErr isnot NO_ERROR)
                {
                    Trace1(ERR,
                           "AccessIpStats: Error %d setting TTL in stack",
                           dwErr);
                }
            }

            if(pIpStats->dwForwarding isnot MIB_USE_CURRENT_FORWARDING)
            {
                if((pIpStats->dwForwarding isnot MIB_IP_FORWARDING) and
                   (pIpStats->dwForwarding isnot MIB_IP_NOT_FORWARDING))
                {
                    Trace1(ERR,
                           "AccessIpStats: Fwding state %d is invalid",
                           pIpStats->dwForwarding);

                    return ERROR_INVALID_DATA;
                }

                //
                // See if its to switch off forwarding
                //
             
                EnterCriticalSection(&g_csFwdState);
 
                g_bEnableFwdRequest = (pIpStats->dwForwarding is MIB_IP_FORWARDING);

                Trace1(GLOBAL,
                       "AccessIpStats: Signalling worker to %s forwarding",
                       g_bEnableFwdRequest ? "enable" : "disable");

                SetEvent(g_hSetForwardingEvent);

                LeaveCriticalSection(&g_csFwdState);
            }

            TraceLeave("AccessIpStats");
                  
            return dwErr;
        }
        
        default:
        {
            Trace1(ERR,
                   "AccessIpStats: Query type %d is wrong",
                   dwQueryType);

            return ERROR_INVALID_PARAMETER;
        }
    }
}


DWORD  
AccessIpAddrTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get IP Address Table

Locks

    IP Address Cache lock as READER
    
Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + SIZEOF_IPADDRTABLE(NumIpAddrEntries)

Return Value:  

    NO_ERROR

--*/

{
    PMIB_IPADDRTABLE    pIpAddrTable;
    DWORD               dwResult, i;

    TraceEnter("AccessIpAddrTable");

    pIpAddrTable = (PMIB_IPADDRTABLE)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIpAddrTable");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    if((dwResult = UpdateCache(IPADDRCACHE,pbCache)) isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessIpAddrTable: Error %d updating IpAddr Cache",
               dwResult);

        TraceLeave("AccessIpAddrTable");
        
        return dwResult;
    }
    
    do
    {
        ENTER_READER(IPADDRCACHE);
   
        if((g_IpInfo.pAddrTable is NULL) or
           (g_IpInfo.pAddrTable->dwNumEntries is 0)) 
        {
            Trace0(MIB,"No valid entries found");
            
            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPADDRTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = IP_ADDRTABLE;
                
                pIpAddrTable->dwNumEntries = 0;
                
                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPADDRTABLE);

            break;
        }
        
        if(*pOutEntrySize <
           MAX_MIB_OFFSET + SIZEOF_IPADDRTABLE(g_IpInfo.pAddrTable->dwNumEntries))
        {
            *pOutEntrySize = MAX_MIB_OFFSET +
                             SIZEOF_IPADDRTABLE(g_IpInfo.pAddrTable->dwNumEntries);
            
            dwResult = ERROR_INSUFFICIENT_BUFFER;
            
            break;
        }
        
        pOutEntry->dwId = IP_ADDRTABLE;
        
        *pOutEntrySize = MAX_MIB_OFFSET +
                         SIZEOF_IPADDRTABLE(g_IpInfo.pAddrTable->dwNumEntries);
        
        for(i = 0; i < g_IpInfo.pAddrTable->dwNumEntries; i ++)
        {
            pIpAddrTable->table[i] = g_IpInfo.pAddrTable->table[i];
        }
        
        pIpAddrTable->dwNumEntries = g_IpInfo.pAddrTable->dwNumEntries;
        
        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(IPADDRCACHE);

    TraceLeave("AccessIpAddrTable");
    
    return dwResult;

}

DWORD  
AccessIpForwardNumber(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPFORWARDNUMBER pNum;
    DWORD   dwResult;

    TraceEnter("AccessIpForwardNumber");
    
    pNum = (PMIB_IPFORWARDNUMBER)pOutEntry;

    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIpForwardNumber");
    
        return ERROR_INVALID_PARAMETER;
    }

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDNUMBER))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDNUMBER);

        TraceLeave("AccessIpForwardNumber");

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDNUMBER);
    
    if((dwResult = UpdateCache(IPFORWARDCACHE,pbCache)) isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessIpForwardNumber: Couldnt update IpForward Cache. Error %d", 
               dwResult);

        TraceLeave("AccessIpForwardNumber");

        return dwResult;
    }

    ENTER_READER(IPFORWARDCACHE);

    pNum->dwValue = 0;

    if(g_IpInfo.pForwardTable)
    {
        pNum->dwValue = g_IpInfo.pForwardTable->dwNumEntries;
    }

    pOutEntry->dwId = IP_FORWARDNUMBER;

    *pbCache = TRUE;

    EXIT_LOCK(IPFORWARDCACHE);

    TraceLeave("AccessIpForwardNumber");
    
    return NO_ERROR;
}


DWORD  
AccessIpForwardTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

      Function used to get IFTable

Arguments
    dwQueryType     Can only be ACCESS_GET
    dwInEntrySize   Size of pInEntry in bytes
    pInEntry       Nothing important since the whole table is retrieved
    pOutEntrySize  IN: Size of pOutEntry in bytes
                      OUT:Size of information filled in OR size of memory needed 
    pOutEntry      Points to information filled into an MIB_IFTABLE structure
    pbCache        Unused

Return Value:         

    NO_ERROR or some error code defined in iprtrmib

--*/ 
{         
    PMIB_IPFORWARDTABLE pIpForwardTable;
    DWORD               i,dwResult;

    TraceEnter("AccessIpForwardTable");
    
    pIpForwardTable = (PMIB_IPFORWARDTABLE)(pOutEntry->rgbyData);

    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessIpForwardTable");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    if((dwResult = UpdateCache(IPFORWARDCACHE,pbCache)) isnot NO_ERROR)
    {
        Trace1(MIB,
               "AccessIpForwardTable: Couldnt update IpForward Cache. Error %d",
               dwResult);

        TraceLeave("AccessIpForwardTable");
        
        return dwResult;
    }
    
    do
    {
        ENTER_READER(IPFORWARDCACHE);
   
        if((g_IpInfo.pForwardTable is NULL) or
           (g_IpInfo.pForwardTable->dwNumEntries is 0))
        {
            Trace0(MIB,"No valid entries found");

            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = IP_FORWARDTABLE;

                pIpForwardTable->dwNumEntries = 0;

                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDTABLE);

            break;
        }
        
        if(*pOutEntrySize < MAX_MIB_OFFSET + SIZEOF_IPFORWARDTABLE(g_IpInfo.pForwardTable->dwNumEntries))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + SIZEOF_IPFORWARDTABLE(g_IpInfo.pForwardTable->dwNumEntries);
                                                                                        
            dwResult = ERROR_INSUFFICIENT_BUFFER;
            
            break;
        }
        
        pOutEntry->dwId = IP_FORWARDTABLE;
        
        *pOutEntrySize = MAX_MIB_OFFSET + SIZEOF_IPFORWARDTABLE(g_IpInfo.pForwardTable->dwNumEntries);
        
        for(i = 0; i < g_IpInfo.pForwardTable->dwNumEntries; i ++)
        {
            pIpForwardTable->table[i] = g_IpInfo.pForwardTable->table[i];
        }
        
        pIpForwardTable->dwNumEntries = g_IpInfo.pForwardTable->dwNumEntries;
        
        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(IPFORWARDCACHE);

    TraceLeave("AccessIpForwardTable");
        
    return dwResult;
}


DWORD  
AccessIpNetTable(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to get ARP Table

Locks

    IP Net Cache lock as READER
    
Arguments

    dwQueryType     ACCESS_GET or ACCESS_DELETE_ENTRY
    dwInEntrySize   (only for delete)
    pOutEntrySize   MAX_MIB_OFFSET + SIZEOF_IPNETTABLE(NumArpEntries)

Return Value:  

    NO_ERROR

--*/

{
    PMIB_IPNETTABLE pIpNetTable;
    DWORD           i,dwResult;

    TraceEnter("AccessIpNetTable");

    pIpNetTable = (PMIB_IPNETTABLE)(pOutEntry->rgbyData);
    
    if((dwQueryType isnot ACCESS_GET) and
       (dwQueryType isnot ACCESS_DELETE_ENTRY))
    {
        TraceLeave("AccessIpNetTable");
        
        return ERROR_INVALID_PARAMETER;
    }

    if(dwQueryType is ACCESS_GET)
    { 
        dwResult = UpdateCache(IPNETCACHE,pbCache);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(MIB,
                   "AccessIpNetTable: Couldnt update IpNet Cache. Error %d",
                   dwResult);

            TraceLeave("AccessIpNetTable");
        
            return dwResult;
        }
    }
    else
    {
        DWORD   dwIfIndex;
        PICB    pIcb;

        if(dwInEntrySize < sizeof(MIB_OPAQUE_QUERY))
        {
            TraceLeave("AccessIpNetTable");

            return ERROR_INVALID_PARAMETER;
        
        }

        dwIfIndex = pInEntry->rgdwVarIndex[0];

        ENTER_READER(ICB_LIST);

        pIcb = InterfaceLookupByIfIndex(dwIfIndex);

        if((pIcb is NULL) or
           (pIcb->bBound is FALSE))
        {
            EXIT_LOCK(ICB_LIST);

            TraceLeave("AccessIpNetTable");
        
            return ERROR_INVALID_INDEX;
        }

        dwIfIndex = pIcb->dwIfIndex;

        EXIT_LOCK(ICB_LIST);

        dwResult = FlushIpNetTableFromStack(dwIfIndex);

        TraceLeave("AccessIpNetTable");

        return dwResult;
    }
        
    
    do
    {
        ENTER_READER(IPNETCACHE);
        
        if((g_IpInfo.pNetTable is NULL) or
           (g_IpInfo.pNetTable->dwNumEntries is 0))
        {
            Trace0(MIB,"No valid entries found");

            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPNETTABLE))
            {
                dwResult = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                pOutEntry->dwId = IP_NETTABLE;

                pIpNetTable->dwNumEntries = 0;

                dwResult = NO_ERROR;
            }

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPNETTABLE);

            break;
        }
        
        if(*pOutEntrySize <
           MAX_MIB_OFFSET + SIZEOF_IPNETTABLE(g_IpInfo.pNetTable->dwNumEntries))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + 
                             SIZEOF_IPNETTABLE(g_IpInfo.pNetTable->dwNumEntries);
            
            dwResult = ERROR_INSUFFICIENT_BUFFER;
            
            break;
        }
        
        pOutEntry->dwId = IP_NETTABLE;

        *pOutEntrySize =
            MAX_MIB_OFFSET + SIZEOF_IPNETTABLE(g_IpInfo.pNetTable->dwNumEntries);
    
        for(i = 0; i < g_IpInfo.pNetTable->dwNumEntries; i ++)
        {
            pIpNetTable->table[i] = g_IpInfo.pNetTable->table[i];
        }
        
        pIpNetTable->dwNumEntries = g_IpInfo.pNetTable->dwNumEntries;

        dwResult = NO_ERROR;
        
    }while(FALSE);

    EXIT_LOCK(IPNETCACHE);

    TraceLeave("AccessIpNetTable");
    
    return dwResult;
}


DWORD 
AccessIpAddrRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve a IP Address Row

Locks

    Takes the IP Address Cache lock as READER
    
Arguments

    dwQueryType     Can be ACCESS_GET, ACCESS_GET_NEXT or ACCESS_GET_FIRST
    pInEntry        Address for the row filled in the rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPADDRROW)

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/ 
{
    DWORD           dwResult, dwNumIndices, dwIndex;
    PMIB_IPADDRROW  pIpAddrRow;

    TraceEnter("AccessIpAddrRow");

    pIpAddrRow = (PMIB_IPADDRROW)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPADDRROW))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPADDRROW);

        TraceLeave("AccessIpAddrRow");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPADDRROW);
    
    pOutEntry->dwId = IP_ADDRROW;
    
    if((dwResult = UpdateCache(IPADDRCACHE,pbCache)) isnot NO_ERROR)
    {   
        Trace1(MIB,
               "AccessIpAddrRow: Couldnt update Ip Addr Cache. Error %d",
               dwResult);

        TraceLeave("AccessIpAddrRow");
        
        return dwResult;
    }
    
    
    do
    {
        ENTER_READER(IPADDRCACHE);

        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIpAddrRow(dwQueryType,
                                   dwNumIndices,
                                   pInEntry->rgdwVarIndex,
                                   &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            *pIpAddrRow = g_IpInfo.pAddrTable->table[dwIndex];
            
            dwResult = NO_ERROR;
        }
        
    }while(FALSE);

    EXIT_LOCK(IPADDRCACHE);
    
    TraceLeave("AccessIpAddrRow");
    
    return dwResult;
    
}


DWORD 
AccessIpForwardRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve or set a route (IP Forward Row)

Locks

    Takes the IP Forward Cache lock as READER for queries, WRITER for sets
    
Arguments

    dwQueryType     All permitted
    pInEntry        Dest, Proto, Policy and NextHop for the row filled in the
                    rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDROW). For Sets the
                    OutBuffer has the row to set

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/

{
    DWORD               dwResult,dwNumIndices,dwIndex;
    PMIB_IPFORWARDROW   pIpForwardRow;

    TraceEnter("AccessIpForwardRow");

    pIpForwardRow = (PMIB_IPFORWARDROW)(pOutEntry->rgbyData);

    if(dwQueryType isnot ACCESS_DELETE_ENTRY)
    {
        if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDROW))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDROW);

            TraceLeave("AccessIpForwardRow");
        
            return ERROR_INSUFFICIENT_BUFFER;
        }
    
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPFORWARDROW);
    
        pOutEntry->dwId = IP_FORWARDROW;
    }
    
    if((dwResult = UpdateCache(IPFORWARDCACHE,pbCache)) isnot NO_ERROR)
    {   
        Trace1(MIB,
               "AccessIpForwardRow: Error %d updating IpForward Cache",
               dwResult);

        TraceLeave("AccessIpForwardRow");
        
        return dwResult;
    }

    
    do
    {
        if(dwQueryType > ACCESS_GET_NEXT)
        {
            ENTER_WRITER(IPFORWARDCACHE);
        }
        else
        {
            ENTER_READER(IPFORWARDCACHE);
        }

        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIpForwardRow(dwQueryType,
                                      dwNumIndices,
                                      pInEntry->rgdwVarIndex,
                                      &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
                    *pIpForwardRow = g_IpInfo.pForwardTable->table[dwIndex];
                    
                    break;
                }
                case ACCESS_SET:
                {
                    dwResult =
                        SetIpForwardRow(&(g_IpInfo.pForwardTable->table[dwIndex]),
                                        pIpForwardRow);
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_IpInfo.pForwardTable->table[dwIndex] = *pIpForwardRow;
                    }
                    
                    break;
                }
                case ACCESS_DELETE_ENTRY:
                {
                    dwResult =
                        DeleteIpForwardRow(&(g_IpInfo.pForwardTable->table[dwIndex]));
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_LastUpdateTable[IPFORWARDCACHE] = 0;
                    }
                    
                    break;
                }
                case ACCESS_CREATE_ENTRY:
                {
                    // 
                    // 
                    // This is the case where you have tried to create a
                    // route which matches an existing entry
                    //

                    dwResult = ERROR_ALREADY_EXISTS;

                    break;
                }
            }
        }
        else
        {
            if((dwQueryType is ACCESS_CREATE_ENTRY) or
               (dwQueryType is ACCESS_SET))
            {
                // 
                // Cannot set PROTO_IP_LOCAL routes (other protos will
                // be weeded out when we search for the RTM handle)
                //
                
                if(pIpForwardRow->dwForwardProto is PROTO_IP_LOCAL)
                {
                    dwResult = ERROR_INVALID_PARAMETER;
                    
                    break;
                }

                dwResult = SetIpForwardRow(NULL,
                                           pIpForwardRow);
                
                //
                // Since its too much hassle to create, malloc (possibly)
                // sorted insert we make just invalidate the route cache
                //
                
                if(dwResult is NO_ERROR)
                {
                    g_LastUpdateTable[IPFORWARDCACHE] = 0;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(IPFORWARDCACHE);

    TraceLeave("AccessIpForwardRow");
        
    return dwResult;

}


DWORD 
AccessIpNetRow(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to retrieve or set an ARP entry (IP Net Row)

Locks

    Takes the IP Net Cache lock as READER for queries, as WRITER for sets
    
Arguments

    dwQueryType     All permitted
    pInEntry        IfIndex and IPAddress for the row filled in the
                    rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPNETROW);
                    For Sets, the OutEntry contains the row to set

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/ 
{
    DWORD           dwResult, dwNumIndices, dwIndex;
    PMIB_IPNETROW   pIpNetRow;
    PICB            pIcb;

    TraceEnter("AccessIpNetRow");

    pIpNetRow = (PMIB_IPNETROW)(pOutEntry->rgbyData);
    
    if(dwQueryType isnot ACCESS_DELETE_ENTRY)
    {
        if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPNETROW))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPNETROW);

            TraceLeave("AccessIpNetRow");
        
            return ERROR_INSUFFICIENT_BUFFER;
        }
    
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPNETROW);
    
        pOutEntry->dwId = IP_NETROW;
    }
    
    if((dwResult = UpdateCache(IPNETCACHE,pbCache)) isnot NO_ERROR)
    {   
        Trace1(MIB,
               "AccessIpNetRow: Couldnt update Ip Addr Cache. Error %d", 
               dwResult);

        TraceLeave("AccessIpNetRow");
        
        return dwResult;
    }


    do
    {
        if(dwQueryType > ACCESS_GET_NEXT)
        {
            ENTER_WRITER(IPNETCACHE);
        }
        else
        {
            ENTER_READER(IPNETCACHE);
        }
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIpNetRow(dwQueryType,
                                  dwNumIndices,
                                  pInEntry->rgdwVarIndex,
                                  &dwIndex);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
          
                    *pIpNetRow = g_IpInfo.pNetTable->table[dwIndex];
                    
                    break;
                }

                case ACCESS_SET:
                {
                    if((pIpNetRow->dwType isnot MIB_IPNET_TYPE_DYNAMIC) and
                       (pIpNetRow->dwType isnot MIB_IPNET_TYPE_STATIC))
                    {
                        dwResult = ERROR_INVALID_DATA;

                        break;
                    }

                    //
                    // Need to map the interface index to the adapter index
                    //

                    ENTER_READER(ICB_LIST);
                   
                    pIcb = InterfaceLookupByIfIndex(pIpNetRow->dwIndex);

                    if((pIcb is NULL) or
                       (!pIcb->bBound))
                    {
                        //
                        // Could not find interface
                        //

                        dwResult = ERROR_INVALID_INDEX;

                        EXIT_LOCK(ICB_LIST);

                        break;
                    }
                    
                    EXIT_LOCK(ICB_LIST);

                    //
                    // No need to force cache updates
                    //
                    
                    dwResult = SetIpNetEntryToStack(pIpNetRow, FALSE);
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_IpInfo.pNetTable->table[dwIndex] = *pIpNetRow;
                    }
                    
                    break;
                }
                
                case ACCESS_DELETE_ENTRY:
                {
                    MIB_IPNETROW    tempRow;

                    g_IpInfo.pNetTable->table[dwIndex].dwType =
                        MIB_IPNET_TYPE_INVALID;

                    tempRow = g_IpInfo.pNetTable->table[dwIndex];

                    dwResult = SetIpNetEntryToStack(&tempRow,
                                                    FALSE);
                    
                    if(dwResult is NO_ERROR)
                    {
                        g_LastUpdateTable[IPNETCACHE] = 0;
                    }
                    
                    break;
                }

                case ACCESS_CREATE_ENTRY:
                {
                    dwResult = ERROR_ALREADY_EXISTS;
            
                    break;
                }
            }
        }
        else
        {
            if((dwQueryType is ACCESS_CREATE_ENTRY) or
               (dwQueryType is ACCESS_SET))
            {
                ENTER_READER(ICB_LIST);
                   
                pIcb = InterfaceLookupByIfIndex(pIpNetRow->dwIndex);

                if((pIcb is NULL) or
                   (!pIcb->bBound))
                {
                    //
                    // Could not find interface
                    //

                    dwResult = ERROR_INVALID_INDEX;

                    EXIT_LOCK(ICB_LIST);

                    break;
                }

                EXIT_LOCK(ICB_LIST);
                    
                dwResult = SetIpNetEntryToStack(pIpNetRow,
                                                FALSE);
                
                if(dwResult is NO_ERROR)
                {
                    g_LastUpdateTable[IPNETCACHE] = 0;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(IPNETCACHE);

    TraceLeave("AccessIpNetRow");
    
    return dwResult;

}

//
// The ACCESS_SETs and ACCESS_CREATEs require a bit more work in that the
// values have to be written back to the stack. The actual code for setting
// to stack (or RTM) is elsewhere, the following functions are merely
// wrappers around the actual calls
//

DWORD 
SetIpForwardRow(
    PMIB_IPFORWARDROW pOldIpForw,
    PMIB_IPFORWARDROW pNewIpForw
    )
{
    DWORD           i, dwResult, dwMask;
    HANDLE          hRtmHandle;
    PICB            pIcb;

    TraceEnter("SetIpForwardRow");

    hRtmHandle = NULL;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(pNewIpForw->dwForwardProto is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }


    if(hRtmHandle is NULL)
    {
        Trace1(ERR,
               "SetIpForwardRow: Protocol %d not valid",
               pNewIpForw->dwForwardProto);
               
        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }

    if((pNewIpForw->dwForwardDest & pNewIpForw->dwForwardMask) isnot pNewIpForw->dwForwardDest)
    {
        Trace2(ERR,
               "SetIpForwardRow: Dest %d.%d.%d.%d and Mask %d.%d.%d.%d wrong",
               PRINT_IPADDR(pNewIpForw->dwForwardDest),
               PRINT_IPADDR(pNewIpForw->dwForwardMask));

        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }

    if(((DWORD)(pNewIpForw->dwForwardDest & 0x000000FF)) >= (DWORD)0x000000E0)
    {
        //
        // This will catch the CLASS D/E and all 1's bcast
        //

        Trace1(ERR,
               "SetIpForwardRow: Dest %d.%d.%d.%d is invalid",
               PRINT_IPADDR(pNewIpForw->dwForwardDest));

        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }

#if 0
    // Removed this since metric=0 is legal for routes to the loopback
    // interface.
    if(pNewIpForw->dwForwardMetric1 is 0)
    {
        Trace0(ERR,
               "SetIpForwardRow: Metric1 cant be 0");

        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }
#endif

    //
    // If we are changing values, we need to blow the old row away.
    // Just a quirk of how
    // RTM and our stack works
    //
    
    if(pOldIpForw isnot NULL)
    {
        dwResult = DeleteIpForwardRow(pOldIpForw);
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(MIB,
                   "SetIpForwardRow: Unable to delete route from RTM. Error %d",
                   dwResult);
    
            TraceLeave("SetIpForwardRow");

            return ERROR_CAN_NOT_COMPLETE;
        }

        UpdateStackRoutesToRestoreList(pOldIpForw, IRNO_FLAG_DELETE);
    }

    if(pNewIpForw->dwForwardProto isnot PROTO_IP_NETMGMT)
    {
        pNewIpForw->dwForwardAge = INFINITE;
    }

    //
    // Add the RTM route from the ip forward entry
    //

    ENTER_READER(ICB_LIST);
    
    dwMask = GetBestNextHopMaskGivenIndex(pNewIpForw->dwForwardIfIndex,
                                          pNewIpForw->dwForwardNextHop);
   
    pIcb = InterfaceLookupByIfIndex(pNewIpForw->dwForwardIfIndex);

    if(pIcb is NULL)
    {
        EXIT_LOCK(ICB_LIST);

        Trace1(ERR,
               "SetIpForwardRow: I/f 0x%x doesnt exist", 
               pNewIpForw->dwForwardIfIndex);

        TraceLeave("SetIpForwardRow");

        return ERROR_INVALID_PARAMETER;
    }

    if(IsIfP2P(pIcb->ritType))
    {
        pNewIpForw->dwForwardNextHop = 0;
    }

    EXIT_LOCK(ICB_LIST);

    dwResult = AddRtmRoute(hRtmHandle,
                           ConvertMibRouteToRouteInfo(pNewIpForw),
                           IP_VALID_ROUTE | IP_STACK_ROUTE,
                           dwMask,
                           pNewIpForw->dwForwardAge,
                           NULL);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(MIB,
               "SetIpForwardRow: Could not set route to RTM: Dest %x\n",
               pNewIpForw->dwForwardDest) ;
    }

    else
    {
        UpdateStackRoutesToRestoreList(pNewIpForw, IRNO_FLAG_ADD);
    }
    
    TraceLeave("SetIpForwardRow");

    return dwResult;
}

DWORD 
DeleteIpForwardRow(
    PMIB_IPFORWARDROW pIpForw
    )
{
    DWORD            i, dwResult;
    HANDLE           hRtmHandle;

    hRtmHandle = NULL;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(pIpForw->dwForwardProto is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }


    if(hRtmHandle is NULL)
    {
        Trace1(ERR,
               "DeleteIpForwardRow: Protocol %d not valid",
               pIpForw->dwForwardProto);

        return ERROR_INVALID_PARAMETER;
    } 
    
    //
    // Delete the RTM route corr. to the ip forward entry
    //
    
    dwResult = DeleteRtmRoute(hRtmHandle, 
                              ConvertMibRouteToRouteInfo(pIpForw));
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(MIB,
               "DeleteIpForwardRow: RtmDeleteRoute returned %d", dwResult);
    }
    else
    {
        UpdateStackRoutesToRestoreList(pIpForw, IRNO_FLAG_DELETE);
    }
    
    return dwResult;
}

DWORD
AccessMcastMfe(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD           dwResult,dwNumIndices,dwIndex;
    DWORD           dwOutBufferSize, dwNumMfes;
    MIB_IPMCAST_MFE mimInMfe;

    TraceEnter("AccessMcastMfe");

#if 1
     
    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // The in index better be a good size
            // The user must specify Group, Source and SrcMask. The
            // SrcMask is not used and MUST be 0xFFFFFFFF
            //

            if(dwNumIndices < 3)
            {
                TraceLeave("AccessMcastMfe");

                return ERROR_INVALID_INDEX;
            }

            ZeroMemory(&mimInMfe, sizeof(mimInMfe));

            mimInMfe.dwGroup      = pInEntry->rgdwVarIndex[0];
            mimInMfe.dwSource     = pInEntry->rgdwVarIndex[1];

            //
            // NOTE: Change when doing source aggregation
            //

            mimInMfe.dwSrcMask = 0xFFFFFFFF;

            dwOutBufferSize = 
                (*pOutEntrySize < MAX_MIB_OFFSET)? 0 : (*pOutEntrySize - MAX_MIB_OFFSET);

            dwResult = MgmGetMfe(
                        &mimInMfe, &dwOutBufferSize, pOutEntry->rgbyData
                        );

            break;
        }

        case ACCESS_GET_FIRST:
        {
            PMIB_MFE_TABLE      pMfeTable;

            //
            // We always gets chunks of 1KB
            //

            if(*pOutEntrySize < MIB_MFE_BUFFER_SIZE)
            {
                *pOutEntrySize = MIB_MFE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

            //
            // MGM wants a flat buffer for MFEs. We however return a 
            // MIB_MFE_TABLE to the user that starts (in the worst case) after
            // MAX_MIB_OFFSET bytes of the input buffer
            //

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_MFE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pMfeTable = (PMIB_MFE_TABLE)pOutEntry->rgbyData;

            pMfeTable->dwNumEntries = 0;

            // pMfe = (PMIB_IPMCAST_MFE)(pMfeTable->table);

            dwNumMfes = 0;

            dwResult = MgmGetFirstMfe(
                        &dwOutBufferSize, (PBYTE)pMfeTable->table,
                        &dwNumMfes
                        );

           
            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);
 
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pMfeTable->dwNumEntries = dwNumMfes;

                dwResult = NO_ERROR;
            }

            break;
        }

        case ACCESS_GET_NEXT:
        {
            PMIB_MFE_TABLE      pMfeTable;

            //
            // For this, too we always get chunks of 1K pages
            //

            if(*pOutEntrySize < MIB_MFE_BUFFER_SIZE)
            {
                *pOutEntrySize = MIB_MFE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_MFE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pMfeTable = (PMIB_MFE_TABLE)pOutEntry->rgbyData;

            pMfeTable->dwNumEntries = 0;

            // pMfe = (PMIB_IPMCAST_MFE)(pMfeTable->table);

            dwNumMfes = 0;

            //
            // Set up the "first" mfe
            //

            ZeroMemory(&mimInMfe, sizeof(mimInMfe));

            //
            // NOTE: Change when doing source aggregation
            //

            mimInMfe.dwSrcMask = 0xFFFFFFFF;        

            switch(dwNumIndices)
            {
                case 0:
                {
                    break;
                }

                case 1:
                {
                    mimInMfe.dwGroup    = pInEntry->rgdwVarIndex[0];

                    break;
                }

                default:
                {
                    //
                    // 2 or more indices
                    //

                    mimInMfe.dwGroup    = pInEntry->rgdwVarIndex[0];
                    mimInMfe.dwSource   = pInEntry->rgdwVarIndex[1];

                    break;
                }
            }

            dwResult = MgmGetNextMfe(
                        &mimInMfe, &dwOutBufferSize, (PBYTE)pMfeTable->table, 
                        &dwNumMfes
                        );


            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);

            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pMfeTable->dwNumEntries = dwNumMfes;

                dwResult = NO_ERROR;
            }

            break;
        }
        
        case ACCESS_SET:
        {
            //
            // Validate the MFE size
            //

            if(dwInEntrySize < SIZEOF_BASIC_MFE)
            {
            }

            //dwResult = SetMfe(pMfe);
            
            break;
        }

        case ACCESS_DELETE_ENTRY:
        {
            
            break;
        }
        case ACCESS_CREATE_ENTRY:
        {
            // 
            // 
            // This is the case where you have tried to create a route which 
            // matches an existing entry
            //

            dwResult = ERROR_ALREADY_EXISTS;

            break;
        }
    }

#endif

    TraceLeave("AccessMcastMfe");
        
    //return dwResult;

    return NO_ERROR;
    
}


DWORD
AccessMcastMfeStats(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    return AccessMcastMfeStatsInternal(
                dwQueryType,
                dwInEntrySize,
                pInEntry,
                pOutEntrySize,
                pOutEntry,
                pbCache,
                MGM_MFE_STATS_0
                );
}


DWORD
AccessMcastMfeStatsEx(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    return AccessMcastMfeStatsInternal(
                dwQueryType,
                dwInEntrySize,
                pInEntry,
                pOutEntrySize,
                pOutEntry,
                pbCache,
                MGM_MFE_STATS_1
                );
}


DWORD
AccessMcastMfeStatsInternal(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache,
    DWORD               dwStatsFlag
    )

/*++

Routine Description

    This

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD           dwResult = NO_ERROR,dwNumIndices,dwIndex;
    DWORD           dwOutBufferSize, dwNumMfes;
    MIB_IPMCAST_MFE mimInMfe;


    TraceEnter("AccessMcastMfeStatsInternal");
#if 1

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // The in index better be a good size
            // The user must specify Group, Source and SrcMask. The
            // SrcMask is not used and MUST be 0xFFFFFFFF
            //

            if(dwNumIndices < 3)
            {
                TraceLeave("AccessMcastMfeStatsInternal");

                return ERROR_INVALID_INDEX;
            }

            ZeroMemory(&mimInMfe, sizeof(mimInMfe));

            mimInMfe.dwGroup      = pInEntry->rgdwVarIndex[0];
            mimInMfe.dwSource     = pInEntry->rgdwVarIndex[1];

            //
            // NOTE: Change when doing source aggregation
            //

            mimInMfe.dwSrcMask = 0xFFFFFFFF;

            dwOutBufferSize = 
                (*pOutEntrySize < MAX_MIB_OFFSET)? 0 : (*pOutEntrySize - MAX_MIB_OFFSET);


            dwResult = MgmGetMfeStats(
                            &mimInMfe, &dwOutBufferSize, 
                            pOutEntry->rgbyData, dwStatsFlag
                            ); 

            break;
        }

        case ACCESS_GET_FIRST:
        {
            PMIB_MFE_STATS_TABLE  pMfeStatsTable;

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_MFE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_MFE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

            //
            // MGM wants a flat buffer for MFEs. We however return a 
            // MIB_MFE_TABLE to the user that starts (in the worst case) after
            // MAX_MIB_OFFSET bytes of the input buffer
            //

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_MFE_STATS_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pMfeStatsTable = (PMIB_MFE_STATS_TABLE)pOutEntry->rgbyData;

            pMfeStatsTable->dwNumEntries = 0;

            // pMfeStats = (PMIB_IPMCAST_MFE_STATS)(pMfeStatsTable->table);

            dwNumMfes = 0;

            dwResult = MgmGetFirstMfeStats(
                            &dwOutBufferSize, (PBYTE)pMfeStatsTable->table,
                            &dwNumMfes, dwStatsFlag
                            );
           
            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);
 
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pMfeStatsTable->dwNumEntries = dwNumMfes;

                dwResult = NO_ERROR;
            }

            break;
        }

        case ACCESS_GET_NEXT:
        {
            PMIB_MFE_STATS_TABLE  pMfeStatsTable;

            //
            // For this, too we always get chunks of 1K pages
            //

            if (*pOutEntrySize < MIB_MFE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_MFE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_MFE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pMfeStatsTable = (PMIB_MFE_STATS_TABLE)pOutEntry->rgbyData;

            pMfeStatsTable->dwNumEntries = 0;

            //pMfeStats = (PIPMCAST_MFE_STATS)(pMfeStatsTable->table);

            dwNumMfes = 0;

            //
            // Set up the "first" mfe
            //

            ZeroMemory(&mimInMfe, sizeof(mimInMfe));

            //
            // NOTE: Change when doing source aggregation
            //

            mimInMfe.dwSrcMask = 0xFFFFFFFF;        

            switch(dwNumIndices)
            {
                case 0:
                {
                    break;
                }

                case 1:
                {
                    mimInMfe.dwGroup      = pInEntry->rgdwVarIndex[0];

                    break;
                }

                default:
                {
                    //
                    // 2 or more indices
                    //

                    mimInMfe.dwGroup      = pInEntry->rgdwVarIndex[0];
                    mimInMfe.dwSource     = pInEntry->rgdwVarIndex[1];

                    break;
                }
            }

            dwResult = MgmGetNextMfeStats(
                            &mimInMfe, &dwOutBufferSize,
                            (PBYTE)pMfeStatsTable->table, &dwNumMfes, 
                            dwStatsFlag
                            );

            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);

            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pMfeStatsTable->dwNumEntries = dwNumMfes;

                dwResult = NO_ERROR;
            }

            break;
        }
        
        case ACCESS_SET:
        {
            //
            // Validate the MFE size
            //

            if(dwInEntrySize < SIZEOF_BASIC_MFE)
            {
            }

            //dwResult = SetMfe(pMfe);
            
            break;
        }

        case ACCESS_DELETE_ENTRY:
        {
            
            break;
        }
        case ACCESS_CREATE_ENTRY:
        {
            // 
            // 
            // This is the case where you have tried to create a route which 
            // matches an existing entry
            //

            dwResult = ERROR_ALREADY_EXISTS;

            break;
        }
    }

#endif

    TraceLeave("AccessMcastMfeStatsInternal");
    return dwResult;
}

DWORD
AccessMcastIfStats(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    Retrieves the IP Multicast Interface table

Locks

    Takes ICB list lock as READER

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IFTABLE)

Return Value

    None    

--*/
{
    PICB        picb;
    PMIB_IPMCAST_IF_ENTRY pIfRow;
    DWORD       dwNumIndices, dwResult;

    TraceEnter("AccessMcastIfTable");

    pIfRow = (PMIB_IPMCAST_IF_ENTRY)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_IF_ENTRY))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_IF_ENTRY);
        TraceLeave("AccessMcastIfTable");
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_IF_ENTRY);
        
    pOutEntry->dwId = MCAST_IF_ENTRY;
    
    do
    {
        if(dwQueryType is ACCESS_SET)
        {
            ENTER_WRITER(ICB_LIST);
        }
        else
        {
            ENTER_READER(ICB_LIST);
        }
        
        dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;
        
        dwResult = LocateIfRow(dwQueryType,
                               dwNumIndices,
                               pInEntry->rgdwVarIndex,
                               &picb,
                               FALSE);
        
        if(dwResult is NO_ERROR)
        {
            switch(dwQueryType)
            {
                case ACCESS_GET:
                case ACCESS_GET_NEXT:
                case ACCESS_GET_FIRST:
                {
                    dwResult = GetInterfaceMcastStatistics(picb,pIfRow);
                    
                    break;
                }
                
                case ACCESS_SET:
                {
                    dwResult = SetInterfaceMcastStatistics(picb,pIfRow);
                    
                    break;
                }
                
                default:
                {
                    Trace1(MIB,
                           "AccessIfRow: Wrong query type %d",dwQueryType);
                    
                    dwResult = ERROR_INVALID_PARAMETER;
                    
                    break;
                }
            }
        }
        
    }while(FALSE);

    EXIT_LOCK(ICB_LIST);
        
    *pbCache = TRUE;
    
    TraceLeave("AccessMcastIfTable");
    
    return dwResult;
}

DWORD
AccessMcastStats(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
/*++

Routine Description

    Retrieves the IP Multicast scalar information

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_GLOBAL)

Return Value

    None    

--*/
{
    PMIB_IPMCAST_GLOBAL pMcastStats;
    DWORD           dwResult;
    
    TraceEnter("AccessMcastStats");

    if (dwQueryType isnot ACCESS_GET) {
        TraceLeave("AccessMcastStats");
        return ERROR_INVALID_PARAMETER;
    }

    pMcastStats = (PMIB_IPMCAST_GLOBAL)(pOutEntry->rgbyData);
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_GLOBAL))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_GLOBAL);

        TraceLeave("AccessMcastStats");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_GLOBAL);
    
    pOutEntry->dwId = MCAST_GLOBAL;
    
    dwResult = NO_ERROR;

    // Retrieve statistics
    pMcastStats->dwEnable = (g_hMcastDevice isnot NULL)? 1 : 2;

    return dwResult;
}

DWORD
AccessMcastBoundary(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
/*++

Routine Description

    Retrieves multicast boundary information

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_BOUNDARY)

Return Value

    None    

--*/
{
    DWORD            dwResult = NO_ERROR,dwNumIndices,dwIndex;
    DWORD            dwOutBufferSize, dwNumBoundaries;
    MIB_IPMCAST_BOUNDARY imInBoundary;

    TraceEnter("AccessMcastBoundary");

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // The in index better be a good size
            // The user must specify IfIndex, Group, GrpMask.
            //

            if(dwNumIndices < 3)
            {
                TraceLeave("AccessMcastBoundary");

                return ERROR_INVALID_INDEX;
            }

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_BOUNDARY_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_BOUNDARY_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

            ZeroMemory(&imInBoundary, sizeof(imInBoundary));

            imInBoundary.dwIfIndex      = pInEntry->rgdwVarIndex[0];
            imInBoundary.dwGroupAddress = pInEntry->rgdwVarIndex[1];
            imInBoundary.dwGroupMask    = pInEntry->rgdwVarIndex[2];

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);

            dwResult = RmGetBoundary(&imInBoundary,
                                 &dwOutBufferSize,
                                 pOutEntry->rgbyData);

            break;
        }

        case ACCESS_GET_FIRST:
        {
#ifdef USE_BOUNDARY_TABLE
            PMIB_IPMCAST_BOUNDARY_TABLE pBoundaryTable;
#endif
            PMIB_IPMCAST_BOUNDARY       pBoundary;

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_BOUNDARY_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_BOUNDARY_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#ifdef USE_BOUNDARY_TABLE
            //
            // RM wants a flat buffer for boundaries. We however return a 
            // MIB_IPMCAST_BOUNDARY_TABLE to the user that starts (in the worst case) 
            // after MAX_MIB_OFFSET bytes of the input buffer
            //

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_IPMCAST_BOUNDARY_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pBoundaryTable = (PMIB_IPMCAST_BOUNDARY_TABLE)pOutEntry->rgbyData;

            pBoundaryTable->dwNumEntries = 0;

            pBoundary = (PMIB_IPMCAST_BOUNDARY)(pBoundaryTable->table);
#else
            pBoundary = (PMIB_IPMCAST_BOUNDARY)pOutEntry->rgbyData;

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);
#endif

            dwNumBoundaries = 1; // get one

            dwResult = RmGetFirstBoundary(&dwOutBufferSize,
                                      (PBYTE)pBoundary,
                                      &dwNumBoundaries);

           
            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);
 
#ifdef USE_BOUNDARY_TABLE
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pBoundaryTable->dwNumEntries = dwNumBoundaries;

                dwResult = NO_ERROR;
            }
#endif

            break;
        }

        case ACCESS_GET_NEXT:
        {
            PMIB_IPMCAST_BOUNDARY    pBoundary;
#ifdef USE_BOUNDARY_TABLE
            PMIB_IPMCAST_BOUNDARY_TABLE  pBoundaryTable;
#endif

            //
            // For this, too we always get chunks of 1K pages
            //

            if (*pOutEntrySize < MIB_BOUNDARY_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_BOUNDARY_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#ifdef USE_BOUNDARY_TABLE
#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_IPMCAST_BOUNDARY_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pBoundaryTable = (PMIB_IPMCAST_BOUNDARY_TABLE)pOutEntry->rgbyData;

            pBoundaryTable->dwNumEntries = 0;

            pBoundary = (PMIB_IPMCAST_BOUNDARY)(pBoundaryTable->table);
#else
            pBoundary = (PMIB_IPMCAST_BOUNDARY)pOutEntry->rgbyData;

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);
#endif

            dwNumBoundaries = 1; // get one

            //
            // Set up the "first" boundary
            //

            ZeroMemory(&imInBoundary, sizeof(imInBoundary));

            switch(dwNumIndices)
            {
                case 0:
                {
                    break;
                }

                case 1:
                {
                    imInBoundary.dwIfIndex = pInEntry->rgdwVarIndex[0];

                    break;
                }

                case 2:
                {
                    imInBoundary.dwIfIndex      = pInEntry->rgdwVarIndex[0];
                    imInBoundary.dwGroupAddress = pInEntry->rgdwVarIndex[1];

                    break;
                }

                default:
                {
                    //
                    // 3 or more indices
                    //

                    imInBoundary.dwIfIndex      = pInEntry->rgdwVarIndex[0];
                    imInBoundary.dwGroupAddress = pInEntry->rgdwVarIndex[1];
                    imInBoundary.dwGroupMask    = pInEntry->rgdwVarIndex[2];

                    break;
                }
            }

            dwResult = RmGetNextBoundary(&imInBoundary,
                                     &dwOutBufferSize,
                                     (PBYTE)pBoundary,
                                     &dwNumBoundaries);

            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);

#ifdef USE_BOUNDARY_TABLE
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pBoundaryTable->dwNumEntries = dwNumBoundaries;

                dwResult = NO_ERROR;
            }
#endif

            break;
        }
        
        case ACCESS_SET:
        {
            PMIB_IPMCAST_BOUNDARY pBound;
            PICB picb;

            //
            // Validate the buffer size
            //

            if (*pOutEntrySize < sizeof(MIB_IPMCAST_BOUNDARY)) {
                return ERROR_INVALID_INDEX;
            }

            //
            // Make sure the ifIndex is a valid one
            //

            dwResult = LocateIfRow(dwQueryType,
                                   1,
                                   (PDWORD)pOutEntry->rgbyData,
                                   &picb,
                                   FALSE);

            if (dwResult isnot NO_ERROR)
                return dwResult;

            pBound = (PMIB_IPMCAST_BOUNDARY)(pOutEntry->rgbyData);
            if (pBound->dwStatus == ROWSTATUS_CREATEANDGO) {
               dwResult = SNMPAddBoundaryToInterface(pBound->dwIfIndex,
                pBound->dwGroupAddress, pBound->dwGroupMask);
            } else if (pBound->dwStatus == ROWSTATUS_DESTROY) {
               dwResult =SNMPDeleteBoundaryFromInterface(pBound->dwIfIndex,
                pBound->dwGroupAddress, pBound->dwGroupMask);
            } 

            break;
        }

        case ACCESS_DELETE_ENTRY:
        {
            break;
        }
        case ACCESS_CREATE_ENTRY:
        {
            // 
            // 
            // This is the case where you have tried to create a boundary which 
            // matches an existing entry
            //

            dwResult = ERROR_ALREADY_EXISTS;

            break;
        }

        default:
        {
            dwResult = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    TraceLeave("AccessMcastBoundary");
    return dwResult;
}

DWORD
AccessMcastScope(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
/*++

Routine Description

    Retrieves multicast scope information

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPMCAST_SCOPE)

Return Value

    None    

--*/
{
    DWORD            dwResult = NO_ERROR,
                     dwNumIndices,dwIndex;
    DWORD            dwOutBufferSize, dwNumScopes;
    MIB_IPMCAST_SCOPE imInScope;

    TraceEnter("AccessMcastScope");

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    switch(dwQueryType)
    {
        case ACCESS_GET:
        {
            //
            // The in index better be a good size
            // The user must specify Group, GrpMask.
            //

            if(dwNumIndices < 2)
            {
                TraceLeave("AccessMcastScope");

                return ERROR_INVALID_INDEX;
            }

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_SCOPE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_SCOPE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

            ZeroMemory(&imInScope, sizeof(imInScope));

            imInScope.dwGroupAddress = pInEntry->rgdwVarIndex[0];
            imInScope.dwGroupMask    = pInEntry->rgdwVarIndex[1];

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);

            dwResult = RmGetScope(&imInScope,
                                  &dwOutBufferSize,
                                  pOutEntry->rgbyData);

            break;
        }

        case ACCESS_GET_FIRST:
        {
#ifdef USE_SCOPE_TABLE
            PMIB_IPMCAST_SCOPE_TABLE pScopeTable;
#endif
            PMIB_IPMCAST_SCOPE       pScope;

            //
            // We always get chunks of 1KB
            //

            if (*pOutEntrySize < MIB_SCOPE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_SCOPE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#ifdef USE_SCOPE_TABLE
            //
            // RM wants a flat buffer for scopes. We however return a 
            // MIB_IPMCAST_SCOPE_TABLE to the user that starts (in the worst case) 
            // after MAX_MIB_OFFSET bytes of the input buffer
            //

#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_IPMCAST_SCOPE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pScopeTable = (PMIB_IPMCAST_SCOPE_TABLE)pOutEntry->rgbyData;

            pScopeTable->dwNumEntries = 0;

            pScope = (PMIB_IPMCAST_SCOPE)(pScopeTable->table);
#else
            pScope = (PMIB_IPMCAST_SCOPE)pOutEntry->rgbyData;

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);
#endif

            dwNumScopes = 1; // get one

            dwResult = RmGetFirstScope(&dwOutBufferSize,
                                      (PBYTE)pScope,
                                      &dwNumScopes);

           
            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);
 
#ifdef USE_SCOPE_TABLE
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pScopeTable->dwNumEntries = dwNumScopes;

                dwResult = NO_ERROR;
            }
#endif

            break;
        }

        case ACCESS_GET_NEXT:
        {
            PMIB_IPMCAST_SCOPE    pScope;
#ifdef USE_SCOPE_TABLE
            PMIB_IPMCAST_SCOPE_TABLE  pScopeTable;
#endif

            //
            // For this, too we always get chunks of 1K pages
            //

            if (*pOutEntrySize < MIB_SCOPE_BUFFER_SIZE) 
            {
                *pOutEntrySize = MIB_SCOPE_BUFFER_SIZE;

                return ERROR_INSUFFICIENT_BUFFER;
            }

#ifdef USE_SCOPE_TABLE
#define _MIN_SIZE  \
    (MAX_MIB_OFFSET + FIELD_OFFSET(MIB_IPMCAST_SCOPE_TABLE,table[0]))

            dwOutBufferSize =  *pOutEntrySize - _MIN_SIZE;

#undef _MIN_SIZE

            pScopeTable = (PMIB_IPMCAST_Scope_TABLE)pOutEntry->rgbyData;

            pScopeTable->dwNumEntries = 0;

            pScope = (PMIB_IPMCAST_SCOPE)(pScopeTable->table);
#else
            pScope = (PMIB_IPMCAST_SCOPE)pOutEntry->rgbyData;

            dwOutBufferSize = (*pOutEntrySize < MAX_MIB_OFFSET)
                ? 0 
                : (*pOutEntrySize - MAX_MIB_OFFSET);
#endif

            dwNumScopes = 1; // get one

            //
            // Set up the "first" scope
            //

            ZeroMemory(&imInScope, sizeof(imInScope));

            switch(dwNumIndices)
            {
                case 0:
                {
                    break;
                }

                case 1:
                {
                    imInScope.dwGroupAddress = pInEntry->rgdwVarIndex[0];

                    break;
                }

                default:
                {
                    //
                    // 2 or more indices
                    //

                    imInScope.dwGroupAddress = pInEntry->rgdwVarIndex[0];
                    imInScope.dwGroupMask    = pInEntry->rgdwVarIndex[1];

                    break;
                }
            }

            dwResult = RmGetNextScope(&imInScope,
                                      &dwOutBufferSize,
                                      (PBYTE)pScope,
                                      &dwNumScopes);

            //
            // We should NEVER get back ERROR_INSUFFICIENT_BUFFER
            //

            IpRtAssert(dwResult isnot ERROR_INSUFFICIENT_BUFFER);

#ifdef USE_SCOPE_TABLE
            if((dwResult is ERROR_MORE_DATA) or
               (dwResult is ERROR_NO_MORE_ITEMS))
            {
                pScopeTable->dwNumEntries = dwNumScopes;

                dwResult = NO_ERROR;
            }
#endif

            break;
        }
        
        case ACCESS_SET:
        {
            PMIB_IPMCAST_SCOPE pScope;

            //
            // Validate the buffer size
            //

            if (*pOutEntrySize < sizeof(MIB_IPMCAST_SCOPE)) {
                return ERROR_INVALID_INDEX;
            }

            pScope = (PMIB_IPMCAST_SCOPE)(pOutEntry->rgbyData);
            if ( !pScope->dwStatus )
            {
               dwResult = SNMPSetScope( pScope->dwGroupAddress, 
                                        pScope->dwGroupMask,
                                        pScope->snNameBuffer 
                                      );
            } else if (pScope->dwStatus == ROWSTATUS_CREATEANDGO) 
            {
               PSCOPE_ENTRY pNew;

               dwResult = SNMPAddScope( pScope->dwGroupAddress, 
                                        pScope->dwGroupMask,
                                        pScope->snNameBuffer,
                                        &pNew
                                      );
            } 
            else if (pScope->dwStatus == ROWSTATUS_DESTROY) 
            {
               dwResult = SNMPDeleteScope( pScope->dwGroupAddress, 
                                           pScope->dwGroupMask
                                         );
            }
            else
            {
                return ERROR_INVALID_PARAMETER;
            }

            break;
        }

        case ACCESS_DELETE_ENTRY:
        {
            
            break;
        }
        case ACCESS_CREATE_ENTRY:
        {
            // 
            // 
            // This is the case where you have tried to create a scope which 
            // matches an existing entry
            //

            dwResult = ERROR_ALREADY_EXISTS;

            break;
        }
    }

    TraceLeave("AccessMcastScope");
    return dwResult;
}


DWORD
AccessBestIf(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services the BEST_IF var id

Locks

    Takes the ICB_LIST as READER to map from adapter to interface index

Arguments

    dwQueryType     Can only be ACCESS_GET
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_BEST_IF)

Return Value

    None

--*/

{
    DWORD   dwNumIndices, dwResult;
    DWORD   dwIfIndex;
    PICB    pIcb;

    PMIB_BEST_IF  pBestIf;

    TraceEnter("AccessBestIf");
    
    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_BEST_IF))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_BEST_IF);

        TraceLeave("AccessBestIf");

        return ERROR_INSUFFICIENT_BUFFER;
    }


    if((dwNumIndices < 1) or
       (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessBestIf");
        
        return ERROR_INVALID_PARAMETER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_BEST_IF);
        
    dwResult = GetBestInterfaceFromStack(pInEntry->rgdwVarIndex[0],
                                         &dwIfIndex);

    if(dwResult is NO_ERROR)
    {

#if DBG
       
        ENTER_READER(ICB_LIST);

        pIcb = InterfaceLookupByIfIndex(dwIfIndex);
 
        if(pIcb is NULL)
        {
            Trace2(ERR,
                   "AccessBestIf: Couldnt find i/f for Index %d for dest %d.%d.%d.%d\n",
                   dwIfIndex,
                   PRINT_IPADDR(pInEntry->rgdwVarIndex[0]));

        }

        EXIT_LOCK(ICB_LIST);

#endif

        pBestIf = (PMIB_BEST_IF)(pOutEntry->rgbyData);

        pOutEntry->dwId = BEST_IF;

        pBestIf->dwDestAddr = pInEntry->rgdwVarIndex[0];
        pBestIf->dwIfIndex  = dwIfIndex;

    }

    TraceLeave("AccessBestIf");
        
    return dwResult;
}

DWORD
AccessBestRoute(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services the BEST_IF var id

Locks

    Takes the ICB_LIST as READER to map from adapter to interface index

Arguments

    dwQueryType     Can only be ACCESS_GET
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_BEST_IF)

Return Value

    None

--*/

{
    DWORD             dwNumIndices, dwResult;
    PICB              pIcb;
    RTM_NET_ADDRESS   rnaDest;
    RTM_DEST_INFO     rdiInfo;
    PRTM_ROUTE_INFO   prriInfo;
    RTM_NEXTHOP_INFO  rniInfo;
    RTM_ENTITY_INFO   reiInfo;
    PINTERFACE_ROUTE_INFO pRoute;

    TraceEnter("AccessBestRoute");
    
    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(INTERFACE_ROUTE_INFO))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(INTERFACE_ROUTE_INFO);

        TraceLeave("AccessBestRoute");

        return ERROR_INSUFFICIENT_BUFFER;
    }


    if((dwNumIndices < 2) or
       (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessBestRoute");
        
        return ERROR_INVALID_PARAMETER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(INTERFACE_ROUTE_INFO);

    pRoute = (PINTERFACE_ROUTE_INFO)(pOutEntry->rgbyData);

    // Get the best route from RTM instead of the stack (chaitk)

    // dwResult = GetBestRouteFromStack(pInEntry->rgdwVarIndex[0],
    //                                  pInEntry->rgdwVarIndex[0],
    //                                  pRoute);

    RTM_IPV4_MAKE_NET_ADDRESS(&rnaDest, pInEntry->rgdwVarIndex[0], 32);

    dwResult = RtmGetMostSpecificDestination(g_hLocalRoute,
                                             &rnaDest,
                                             RTM_BEST_PROTOCOL,
                                             RTM_VIEW_MASK_UCAST,
                                             &rdiInfo);

    if(dwResult is NO_ERROR)
    {
        ASSERT(rdiInfo.ViewInfo[0].ViewId is RTM_VIEW_ID_UCAST);

        prriInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );

        if ( prriInfo != NULL)
        {
            dwResult = RtmGetRouteInfo(g_hLocalRoute,
                                       rdiInfo.ViewInfo[0].Route,
                                       prriInfo,
                                       NULL);

            if (dwResult is NO_ERROR)
            {
                dwResult = RtmGetEntityInfo(g_hLocalRoute,
                                            prriInfo->RouteOwner,
                                            &reiInfo);

                if (dwResult is NO_ERROR)
                {
                    // We are working on the first nexthop only
                    
                    ASSERT(prriInfo->NextHopsList.NumNextHops > 0);
                    
                    dwResult = RtmGetNextHopInfo(g_hLocalRoute,
                                                 prriInfo->NextHopsList.NextHops[0],
                                                 &rniInfo);

                    if (dwResult is NO_ERROR)
                    {
                        ConvertRtmToRouteInfo(reiInfo.EntityId.EntityProtocolId,
                                                 &rdiInfo.DestAddress,
                                                 prriInfo,
                                                 &rniInfo,
                                                 pRoute);

                        RtmReleaseNextHopInfo(g_hLocalRoute, &rniInfo);
                    }
                }

                RtmReleaseRouteInfo(g_hLocalRoute, prriInfo);
            }

            HeapFree(IPRouterHeap, 0, prriInfo);
        }

        else
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        
        RtmReleaseDestInfo(g_hLocalRoute, &rdiInfo);
    }

    if(dwResult is NO_ERROR)
    {

#if DBG

        ENTER_READER(ICB_LIST);

        pIcb = InterfaceLookupByIfIndex(pRoute->dwRtInfoIfIndex);

        if(pIcb is NULL)
        {
            Trace2(ERR,
                   "AccessBestRoute: Couldnt find i/f for index %d for dest %d.%d.%d.%d\n",
                   pRoute->dwRtInfoIfIndex,
                   PRINT_IPADDR(pInEntry->rgdwVarIndex[0]));
        }

        EXIT_LOCK(ICB_LIST);

#endif // DBG

        //
        // Not need to map since the indices are the same
        //

        // pRoute->dwRtInfoIfIndex = dwIfIndex;
    }

    TraceLeave("AccessBestRoute");
        
    return dwResult;
}

DWORD
AccessProxyArp(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services the PROXY_ARP id

Locks

    Takes the ICB_LIST as READER to map from interface to adapter index

Arguments

    dwQueryType     Can only be ACCESS_CREATE_ENTRY or ACCESS_DELETE_ENTRY
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_BEST_IF)

Return Value

    None

--*/
{
    MIB_PROXYARP    mpEntry;
    PMIB_PROXYARP   pProxyEntry;
    PADAPTER_INFO   pBinding;
    BOOL            bAdd;
    DWORD           dwResult;
    
    TraceEnter("AccessProxyArp");


    if(dwQueryType is ACCESS_DELETE_ENTRY)
    {
        mpEntry.dwAddress  = pInEntry->rgdwVarIndex[0];
        mpEntry.dwMask     = pInEntry->rgdwVarIndex[1];
        mpEntry.dwIfIndex  = pInEntry->rgdwVarIndex[2];

        pProxyEntry = &mpEntry;

        bAdd = FALSE;
    }
    else
    {
        if(dwQueryType is ACCESS_CREATE_ENTRY)
        {
            if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_PROXYARP))
            {
                *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_PROXYARP);

                TraceLeave("AccessProxyArp");
        
                return ERROR_INSUFFICIENT_BUFFER;
            }

            pProxyEntry = (PMIB_PROXYARP)(pOutEntry->rgbyData);
            
            bAdd = TRUE;

            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_PROXYARP);
    
            pOutEntry->dwId = PROXY_ARP;
        }
        else
        {
            TraceLeave("AccessProxyArp");
        
            return ERROR_INVALID_PARAMETER;
        }
    }

    ENTER_READER(BINDING_LIST);

    pBinding = GetInterfaceBinding(pProxyEntry->dwIfIndex);
    
    if(pBinding is NULL)
    {
        Trace1(ERR,
               "AccessProxyArp: Cant find binding for i/f %d",
               pProxyEntry->dwIfIndex);

        EXIT_LOCK(BINDING_LIST);

        TraceLeave("AccessProxyArp");
        
        return ERROR_INVALID_INDEX;
    }

    if(!pBinding->bBound)
    {
        Trace1(ERR,
               "AccessProxyArp: I/f %d is not bound",
               pProxyEntry->dwIfIndex);
        
        EXIT_LOCK(BINDING_LIST);
        
        TraceLeave("AccessProxyArp");
        
        return ERROR_NOT_READY;
    }

    EXIT_LOCK(BINDING_LIST);

    dwResult = SetProxyArpEntryToStack(pProxyEntry->dwAddress,
                                       pProxyEntry->dwMask,
                                       pProxyEntry->dwIfIndex,
                                       bAdd,
                                       TRUE);

    TraceLeave("AccessProxyArp");

    return dwResult;
}

DWORD
AccessIfStatus(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services the BEST_IF var id

Locks

    Takes the ICB_LIST as READER to map from adapter to interface index

Arguments

    dwQueryType     Can be ACCESS_GET, ACCESS_GET_FIRST or ACCESS_GET_NEXT
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_BEST_IF)

Return Value

    None

--*/

{
    DWORD   dwNumIndices, dwResult;
    DWORD   dwIfIndex;
    PICB    picb;
    
    PMIB_IFSTATUS   pIfStatus;
    SYSTEMTIME      stSysTime;
    ULARGE_INTEGER  uliTime;

    
    TraceEnter("AccessIfStatus");

    if(dwQueryType > ACCESS_GET_NEXT)
    {
        TraceLeave("AccessIfStatus");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IFSTATUS))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFSTATUS);

        TraceLeave("AccessIfStatus");

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IFSTATUS);

    pIfStatus = (PMIB_IFSTATUS)(pOutEntry->rgbyData);

    ENTER_READER(ICB_LIST);

    dwResult = LocateIfRow(dwQueryType,
                           dwNumIndices,
                           pInEntry->rgdwVarIndex,
                           &picb,
                           FALSE);


    if(dwResult is NO_ERROR)
    {
        pIfStatus->dwIfIndex            = picb->dwIfIndex;
        pIfStatus->dwAdminStatus        = picb->dwAdminState;
        pIfStatus->dwOperationalStatus  = picb->dwOperationalState;
        
        pIfStatus->bMHbeatActive    = picb->mhcHeartbeatInfo.bActive;

        
        if(pIfStatus->bMHbeatActive)
        {
               GetSystemTime(&stSysTime);

               SystemTimeToFileTime(&stSysTime,
                                    (PFILETIME)&uliTime);

               //
               // Its alive if the currenttime - lastheard < deadinterval
               //
               
               pIfStatus->bMHbeatAlive =
                   (uliTime.QuadPart - picb->mhcHeartbeatInfo.ullLastHeard < picb->mhcHeartbeatInfo.ullDeadInterval);
        }

        EXIT_LOCK(ICB_LIST);
    }

    TraceLeave("AccessIfStatus");
        
    return dwResult;
}


DWORD
AccessSetRouteState(
    DWORD               dwQueryType,
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry,
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    This function services ROUTE_STATE id

Locks

    Takes the g_csFwdState lock

Arguments

    dwQueryType     Can be ACCESS_GET only
    pInEntry        Destination address filled in the rgdwVarIndex field.
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_ROUTESTATE)

Return Value

    None

--*/

{
    DWORD   dwResult;
    
    PMIB_ROUTESTATE pState;
    
    if(dwQueryType isnot ACCESS_GET)
    {
        TraceLeave("AccessSetRouteState");
        
        return ERROR_INVALID_PARAMETER;
    }
    
    if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_ROUTESTATE))
    {
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_ROUTESTATE);

        TraceLeave("AccessSetRouteState");

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_ROUTESTATE);

    pOutEntry->dwId = ROUTE_STATE;
    
    pState = (PMIB_ROUTESTATE)(pOutEntry->rgbyData);

    EnterCriticalSection(&g_csFwdState);

    pState->bRoutesSetToStack = g_bSetRoutesToStack;

    LeaveCriticalSection(&g_csFwdState);
    
    TraceLeave("AccessSetRouteState");
    
    return NO_ERROR;
}

DWORD
AddDestinationRows( 
    IN  PRTM_DEST_INFO      pRdi,
    IN  RTM_VIEW_SET        dwViews,
    OUT DWORD              *pdwCount,
    IN  DWORD               dwSpaceCount,
    OUT PMIB_IPDESTTABLE    pDestTable 
    )
{
    DWORD               dwFinalResult, dwResult, i, j, k;
    PRTM_ROUTE_INFO     pri;
    RTM_NEXTHOP_INFO    nhi;
    PMIB_IPDESTROW      pRow;

    pri = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if ( pri == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // XXX how do I walk all next hops which get added to the stack???
    // For now, let's assume only one route per view.

    dwFinalResult = NO_ERROR;

    for (i = 0; i < pRdi->NumberOfViews; i++)
    {
        if (pRdi->ViewInfo[i].Route == NULL)
        {
            continue;
        }

        // Skip if we have seen this route already

        for (k = 0; k < i; k++)
        {
            if (pRdi->ViewInfo[k].Route == pRdi->ViewInfo[i].Route)
            {
                break;
            }
        }

        if (k < i)
        {
            continue;
        }

        dwResult = RtmGetRouteInfo( g_hLocalRoute,
                                    pRdi->ViewInfo[i].Route,
                                    pri,
                                    NULL );
        
        if (dwResult isnot NO_ERROR)
        {
            dwFinalResult = dwResult;
            continue;
        }

        *pdwCount += pri->NextHopsList.NumNextHops;

        if (dwSpaceCount >= *pdwCount)
        {
            ULARGE_INTEGER      now, then;
            ULONG               age;
            RTM_ENTITY_INFO     rei;

            RtmGetEntityInfo( g_hLocalRoute,
                              pri->RouteOwner,
                              &rei );

            GetSystemTimeAsFileTime( (LPFILETIME)&now );

            //
            // Explicit copy reqd as '&pRdi->LastChanged' 
            // might not be 64-bit aligned (its FILETIME)
            //
            (*(FILETIME *)&then) = *(&pRdi->LastChanged);

            age = (ULONG)((now.QuadPart - then.QuadPart) / 10000000);
    
            for (j=0; j<pri->NextHopsList.NumNextHops; j++)
            {
                if (RtmGetNextHopInfo( g_hLocalRoute,
                                       pri->NextHopsList.NextHops[j],
                                       &nhi )  is NO_ERROR )
                {
                    pRow = &pDestTable->table[pDestTable->dwNumEntries++];

                    RTM_IPV4_GET_ADDR_AND_MASK( pRow->dwForwardDest,
                                                pRow->dwForwardMask,
                                                (&pRdi->DestAddress) );

                    pRow->dwForwardPolicy = 0;
                    pRow->dwForwardNextHop 
                        = *((ULONG*)nhi.NextHopAddress.AddrBits);

                    pRow->dwForwardIfIndex  = nhi.InterfaceIndex;
                    pRow->dwForwardType  
                        = (pri->RouteOwner == g_hLocalRoute)?3:4;

                    pRow->dwForwardProto 
                        = PROTO_FROM_PROTO_ID(rei.EntityId.EntityProtocolId);

                    pRow->dwForwardAge = age;

                    pRow->dwForwardNextHopAS= 0; // XXX
                    pRow->dwForwardPreference = pri->PrefInfo.Preference;
                    pRow->dwForwardMetric1  = pri->PrefInfo.Metric;
                    pRow->dwForwardMetric2  = 0;
                    pRow->dwForwardMetric3  = 0;
                    pRow->dwForwardMetric4  = 0;
                    pRow->dwForwardMetric5  = 0;

                    pRow->dwForwardViewSet  = pri->BelongsToViews;

                    RtmReleaseNextHopInfo( g_hLocalRoute, &nhi );
                }
            }
        }

        RtmReleaseRouteInfo( g_hLocalRoute, pri );
    }

    HeapFree(IPRouterHeap, 0, pri);
    
    return dwFinalResult;
}

DWORD 
AccessDestMatching(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++

Routine Description

    Retrieves all destinations matching a given criteria

Locks

    XXX

Arguments

    dwQueryType     ACCESS_GET
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPDESTTABLE)

Return Value

    NO_ERROR

--*/

{
    PMIB_IPDESTTABLE    pDestTable;
    DWORD               count, i;
    DWORD               dwNumDests, dwResult, dwNumIndices, dwSpaceCount;
    RTM_NET_ADDRESS     naDest;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    PRTM_DEST_INFO      prdi;
   
    TraceEnter("AccessDestMatching");

    count = dwSpaceCount = 0;

    pDestTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pDestTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pDestTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessDestMatching");
        
        return ERROR_INVALID_PARAMETER;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask
    prdi = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if (prdi != NULL)
    {
        dwResult = RtmGetExactMatchDestination( g_hLocalRoute,
                                                &naDest,
                                                pInEntry->rgdwVarIndex[3], // Proto
                                                pInEntry->rgdwVarIndex[2], // Views
                                                prdi );
        if (dwResult is ERROR_NOT_FOUND)
        {
            dwResult = NO_ERROR;
        }
        else
        if (dwResult is NO_ERROR)
        {
            AddDestinationRows( prdi,
                                pInEntry->rgdwVarIndex[2],
                                &count,
                                dwSpaceCount,
                                pDestTable );

            RtmReleaseDestInfo( g_hLocalRoute, prdi );
        }

        *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

        if (dwSpaceCount < count)
        {
            dwResult = ERROR_INSUFFICIENT_BUFFER;
        }

        HeapFree(IPRouterHeap, 0, prdi);
    }

    else
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    TraceLeave("AccessDestMatching");

    return dwResult;
}

DWORD
AccessDestShorter(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pDestTable;
    DWORD               count, i;
    DWORD               dwNumDests, dwResult, dwNumIndices, dwSpaceCount;
    RTM_NET_ADDRESS     naDest;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    PRTM_DEST_INFO      prdi1, prdi2;
   
    TraceEnter("AccessDestShorter");

    count = dwSpaceCount = 0;

    pDestTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pDestTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pDestTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessDestShorter");
        
        return ERROR_INVALID_PARAMETER;
    }

    prdi1 = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if ( prdi1 == NULL)
    {
        TraceLeave("AccessDestShorter");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    prdi2 = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if ( prdi2 == NULL)
    {
        TraceLeave("AccessDestShorter");

        HeapFree(IPRouterHeap, 0, prdi1);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmGetMostSpecificDestination( g_hLocalRoute,
                                              &naDest,
                                              pInEntry->rgdwVarIndex[3],//Proto
                                              pInEntry->rgdwVarIndex[2],//Views
                                              prdi1 );
    while (dwResult is NO_ERROR)
    {
        AddDestinationRows( prdi1,
                            pInEntry->rgdwVarIndex[2],
                            &count,
                            dwSpaceCount,
                            pDestTable );

        dwResult = RtmGetLessSpecificDestination( g_hLocalRoute,
                                                  prdi1->DestHandle,
                                                  pInEntry->rgdwVarIndex[3],
                                                  pInEntry->rgdwVarIndex[2],
                                                  prdi2);

        RtmReleaseDestInfo( g_hLocalRoute, prdi1 );

        if (dwResult != NO_ERROR)
        {
            break;
        }

        AddDestinationRows( prdi2,
                            pInEntry->rgdwVarIndex[2],
                            &count,
                            dwSpaceCount,
                            pDestTable );

        dwResult = RtmGetLessSpecificDestination( g_hLocalRoute,
                                                  prdi2->DestHandle,
                                                  pInEntry->rgdwVarIndex[3],
                                                  pInEntry->rgdwVarIndex[2],
                                                  prdi1);

        RtmReleaseDestInfo( g_hLocalRoute, prdi2 );

        if (dwResult != NO_ERROR)
        {
            break;
        }
    }

    if (dwResult is ERROR_NOT_FOUND)
    {
        dwResult = NO_ERROR;
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    HeapFree(IPRouterHeap, 0, prdi1);
    
    HeapFree(IPRouterHeap, 0, prdi2);
    
    TraceLeave("AccessDestShorter");

    return dwResult;
}

DWORD
AccessDestLonger(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pDestTable;
    DWORD               count, i;
    DWORD               dwNumDests, dwResult, dwNumIndices, dwSpaceCount;
    DWORD               dwViews;
    RTM_NET_ADDRESS     naDest;
    ULONG               ulNumViews, ulNumInfos, ulDestInfoSize;
    RTM_DEST_HANDLE     hDest;
    RTM_ENUM_HANDLE     hEnum;
    PRTM_DEST_INFO      pDestInfos, pRdi;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
   
    TraceEnter("AccessDestLonger");

    count = dwSpaceCount = 0;

    pDestTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pDestTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pDestTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessDestLonger");
        
        return ERROR_INVALID_PARAMETER;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmCreateDestEnum( g_hLocalRoute,
                                  pInEntry->rgdwVarIndex[2], // Views
                                  RTM_ENUM_RANGE,
                                  &naDest,
                                  pInEntry->rgdwVarIndex[3], // Proto
                                  &hEnum );

    if (dwResult is NO_ERROR)
    {
        //
        // Count the number of views as we have list of dests in buffer
        //

        dwViews = pInEntry->rgdwVarIndex[2];
        ulNumViews = 0;
        while (dwViews)
        {
            dwViews &= (dwViews - 1);
            ulNumViews++;
        }

        ulDestInfoSize = RTM_SIZE_OF_DEST_INFO(ulNumViews);

        pDestInfos = (PRTM_DEST_INFO) HeapAlloc(
                        IPRouterHeap,
                        0,
                        ulDestInfoSize * 
                            g_rtmProfile.MaxHandlesInEnum
                        );

        if ( pDestInfos != NULL)
        {
            do 
            {
                ulNumInfos = g_rtmProfile.MaxHandlesInEnum;

                dwResult = RtmGetEnumDests( g_hLocalRoute,
                                            hEnum,
                                            &ulNumInfos,
                                            pDestInfos );

                for (i=0; i<ulNumInfos; i++)
                {
                    pRdi=(PRTM_DEST_INFO)(((PUCHAR)pDestInfos)+(i*ulDestInfoSize));

                    AddDestinationRows( pRdi,
                                        pInEntry->rgdwVarIndex[2],
                                        &count,
                                        dwSpaceCount,
                                        pDestTable );
                }

                RtmReleaseDests( g_hLocalRoute,
                                 ulNumInfos,
                                 pDestInfos );

            } while (dwResult is NO_ERROR);

            HeapFree(IPRouterHeap, 0, pDestInfos);
        }

        else
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        
        RtmDeleteEnumHandle( g_hLocalRoute, hEnum );
    }

    if (dwResult is ERROR_NO_MORE_ITEMS)
    {
        dwResult = NO_ERROR;
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    TraceLeave("AccessDestLonger");

    return dwResult;
}

DWORD
AddRouteRows( 
    IN  PRTM_ROUTE_HANDLE   hRoute,
    IN  DWORD               dwProtocolId,
    OUT DWORD              *pdwCount,
    IN  DWORD               dwSpaceCount,
    OUT PMIB_IPDESTTABLE    pRouteTable 
    )
{
    DWORD               dwResult, dwRouteProto, j;
    PRTM_ROUTE_INFO     pri;
    RTM_NEXTHOP_INFO    nhi;
    PMIB_IPDESTROW      pRow;
    RTM_NET_ADDRESS     naDest;
    RTM_ENTITY_INFO     rei;

    pri = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if ( pri == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwResult = RtmGetRouteInfo( g_hLocalRoute,
                                hRoute,
                                pri,
                                &naDest );

    if (dwResult is NO_ERROR)
    {
        RtmGetEntityInfo( g_hLocalRoute,
                          pri->RouteOwner,
                          &rei );

        dwRouteProto = PROTO_FROM_PROTO_ID(rei.EntityId.EntityProtocolId);

        if ((dwProtocolId is 0) 
         || (dwRouteProto is dwProtocolId))
        {
            *pdwCount += pri->NextHopsList.NumNextHops;

            if (dwSpaceCount >= *pdwCount)
            {
                for (j=0; j<pri->NextHopsList.NumNextHops; j++)
                {
                    if (RtmGetNextHopInfo( g_hLocalRoute,
                                           pri->NextHopsList.NextHops[j],
                                           &nhi )  is NO_ERROR )
                    {
                        pRow= &pRouteTable->table[pRouteTable->dwNumEntries++];
    
                        RTM_IPV4_GET_ADDR_AND_MASK( pRow->dwForwardDest,
                                                    pRow->dwForwardMask,
                                                    &naDest );
    
                        pRow->dwForwardPolicy   = 0;
                        pRow->dwForwardNextHop  
                            = *((ULONG*)nhi.NextHopAddress.AddrBits);

                        pRow->dwForwardIfIndex  = nhi.InterfaceIndex;
                        pRow->dwForwardType     
                            = (pri->RouteOwner == g_hLocalRoute)?3:4;

                        pRow->dwForwardProto    = dwRouteProto;
                        pRow->dwForwardAge      = 0;
                        pRow->dwForwardNextHopAS= 0; // XXX
                        pRow->dwForwardPreference = pri->PrefInfo.Preference;
                        pRow->dwForwardMetric1  = pri->PrefInfo.Metric;
                        pRow->dwForwardMetric2  = 0;
                        pRow->dwForwardMetric3  = 0;
                        pRow->dwForwardMetric4  = 0;
                        pRow->dwForwardMetric5  = 0;
                        pRow->dwForwardViewSet  = pri->BelongsToViews;

                        RtmReleaseNextHopInfo( g_hLocalRoute, &nhi );
                    }
                }
            }
        }

        RtmReleaseRouteInfo( g_hLocalRoute, pri );
    }

    HeapFree(IPRouterHeap, 0, pri);
    
    return dwResult;
}

DWORD
AddRouteRowsOnDest( 
    IN  PRTM_DEST_INFO      prdi,
    IN  PMIB_OPAQUE_QUERY   pInEntry, 
    OUT DWORD              *pdwCount,
    IN  DWORD               dwSpaceCount,
    OUT PMIB_IPDESTTABLE    pRouteTable 
    )
{
    DWORD               count, i;
    PHANDLE             RouteHandles;
    ULONG               ulNumHandles;
    RTM_ENUM_HANDLE     hEnum;
    DWORD               dwResult;

    RouteHandles = HeapAlloc(
                    IPRouterHeap,
                    0,
                    g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                    );

    if ( RouteHandles == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwResult = RtmCreateRouteEnum( g_hLocalRoute,
                                   prdi->DestHandle,
                                   pInEntry->rgdwVarIndex[2], // Views
                                   RTM_ENUM_ALL_ROUTES,
                                   NULL,
                                   RTM_MATCH_NONE,
                                   NULL,
                                   0,
                                   &hEnum );

    if (dwResult is NO_ERROR)
    {      
        do 
        {
            ulNumHandles = g_rtmProfile.MaxHandlesInEnum;

            dwResult = RtmGetEnumRoutes( g_hLocalRoute,
                                         hEnum,
                                         &ulNumHandles,
                                         RouteHandles );

            for (i=0; i<ulNumHandles; i++)
            {
                AddRouteRows( RouteHandles[i],
                              pInEntry->rgdwVarIndex[3],//Proto
                              pdwCount,
                              dwSpaceCount,
                              pRouteTable );
            }
    
            RtmReleaseRoutes( g_hLocalRoute,
                              ulNumHandles,
                              RouteHandles );
    
        } while (dwResult is NO_ERROR);

        if (dwResult is ERROR_NO_MORE_ITEMS)
        {
            dwResult = NO_ERROR;
        }

        RtmDeleteEnumHandle( g_hLocalRoute, hEnum );
    }

    HeapFree(IPRouterHeap, 0, RouteHandles);
    
    return dwResult;
}

DWORD
AccessRouteMatching(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pRouteTable;
    DWORD               dwResult, dwNumIndices, dwSpaceCount;
    DWORD               count;
    RTM_NET_ADDRESS     naDest;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    PRTM_DEST_INFO      prdi;
    
    TraceEnter("AccessRouteMatching");

    count = dwSpaceCount = 0;

    pRouteTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pRouteTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pRouteTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessRouteMatching");
        
        return ERROR_INVALID_PARAMETER;
    }

    prdi = HeapAlloc(
            IPRouterHeap,
            0,
            RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
            );

    if ( prdi == NULL)
    {
        TraceLeave("AccessRouteMatching");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmGetExactMatchDestination( g_hLocalRoute,
                                            &naDest,
                                            pInEntry->rgdwVarIndex[3],
                                            pInEntry->rgdwVarIndex[2],
                                            prdi );

    if (dwResult is ERROR_NOT_FOUND)
    {
        dwResult = NO_ERROR;
    }
    else
    if (dwResult is NO_ERROR)
    {
        dwResult = AddRouteRowsOnDest( prdi,
                                       pInEntry,
                                       &count,
                                       dwSpaceCount,
                                       pRouteTable );
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    HeapFree(IPRouterHeap, 0, prdi);
    
    TraceLeave("AccessRouteMatching");

    return dwResult;
}

DWORD
AccessRouteShorter(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pRouteTable;
    DWORD               dwResult, dwNumIndices, dwSpaceCount;
    DWORD               count;
    RTM_NET_ADDRESS     naDest;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    PRTM_DEST_INFO      prdi1, prdi2;
   
    TraceEnter("AccessRouteShorter");

    count = dwSpaceCount = 0;

    pRouteTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pRouteTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pRouteTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessRouteShorter");
        
        return ERROR_INVALID_PARAMETER;
    }

    prdi1 = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if ( prdi1 == NULL)
    {
        TraceLeave("AccessRouteShorter");
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prdi2 = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                );

    if ( prdi2 == NULL)
    {
        TraceLeave("AccessRouteShorter");
        
        HeapFree(IPRouterHeap, 0, prdi1);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmGetMostSpecificDestination( g_hLocalRoute,
                                              &naDest,
                                              pInEntry->rgdwVarIndex[3],//Proto
                                              pInEntry->rgdwVarIndex[2],//Views
                                              prdi1 );
    while (dwResult is NO_ERROR)
    {
        AddRouteRowsOnDest( prdi1,
                            pInEntry,
                            &count,
                            dwSpaceCount,
                            pRouteTable );

        dwResult = RtmGetLessSpecificDestination( g_hLocalRoute,
                                                  prdi1->DestHandle,
                                                  pInEntry->rgdwVarIndex[3],
                                                  pInEntry->rgdwVarIndex[2],
                                                  prdi2);

        RtmReleaseDestInfo( g_hLocalRoute, prdi1 );

        if (dwResult != NO_ERROR)
        {
            break;
        }

        AddRouteRowsOnDest( prdi2,
                            pInEntry,
                            &count,
                            dwSpaceCount,
                            pRouteTable );

        dwResult = RtmGetLessSpecificDestination( g_hLocalRoute,
                                                  prdi2->DestHandle,
                                                  pInEntry->rgdwVarIndex[3],
                                                  pInEntry->rgdwVarIndex[2],
                                                  prdi1);

        RtmReleaseDestInfo( g_hLocalRoute, prdi2 );

        if (dwResult != NO_ERROR)
        {
            break;
        }
    }

    if (dwResult is ERROR_NOT_FOUND)
    {
        dwResult = NO_ERROR;
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    HeapFree(IPRouterHeap, 0, prdi1);
    HeapFree(IPRouterHeap, 0, prdi2);

    TraceLeave("AccessRouteShorter");

    return dwResult;
}

DWORD
AccessRouteLonger(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )
{
    PMIB_IPDESTTABLE    pRouteTable;
    DWORD               count, i;
    DWORD               dwResult, dwNumIndices, dwSpaceCount;
    RTM_NET_ADDRESS     naDest;
    ULONG               ulNumHandles;
    RTM_ENUM_HANDLE     hEnum;
    PHANDLE             RouteHandles;
    DWORD               dwOffset = MAX_MIB_OFFSET + sizeof(DWORD);
    
    TraceEnter("AccessRouteLonger");

    count = dwSpaceCount = 0;

    pRouteTable = NULL;

    if (*pOutEntrySize > dwOffset)
    {
        dwSpaceCount = (*pOutEntrySize - dwOffset) 
                         / sizeof(MIB_IPDESTROW);

        pRouteTable = (PMIB_IPDESTTABLE)(pOutEntry->rgbyData);

        pRouteTable->dwNumEntries = 0;
    }

    dwNumIndices = dwInEntrySize/sizeof(DWORD) - 1;

    if ((dwNumIndices < 4) or
        (dwQueryType isnot ACCESS_GET))
    {
        TraceLeave("AccessRouteLonger");
        
        return ERROR_INVALID_PARAMETER;
    }

    RouteHandles = HeapAlloc(
                    IPRouterHeap,
                    0,
                    g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                    );

    if ( RouteHandles == NULL)
    {
        TraceLeave("AccessRouteLonger");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RTM_IPV4_SET_ADDR_AND_MASK(&naDest,
                               pInEntry->rgdwVarIndex[0],  // Addr
                               pInEntry->rgdwVarIndex[1]); // Mask

    dwResult = RtmCreateRouteEnum( g_hLocalRoute,
                                   NULL,
                                   pInEntry->rgdwVarIndex[2], // Views
                                   RTM_ENUM_RANGE,
                                   &naDest,
                                   RTM_MATCH_NONE,
                                   NULL,
                                   0,
                                   &hEnum );

    if (dwResult is NO_ERROR)
    {
        do 
        {
            ulNumHandles = g_rtmProfile.MaxHandlesInEnum;

            dwResult = RtmGetEnumRoutes( g_hLocalRoute,
                                         hEnum,
                                         &ulNumHandles,
                                         RouteHandles );

            for (i=0; i<ulNumHandles; i++)
            {
                AddRouteRows( RouteHandles[i],
                              pInEntry->rgdwVarIndex[3], // Proto
                              &count,
                              dwSpaceCount,
                              pRouteTable );
            }

            RtmReleaseRoutes( g_hLocalRoute,
                              ulNumHandles,
                              RouteHandles );

        } while (dwResult is NO_ERROR);

        RtmDeleteEnumHandle( g_hLocalRoute, hEnum );
    }

    if (dwResult is ERROR_NO_MORE_ITEMS)
    {
        dwResult = NO_ERROR;
    }

    *pOutEntrySize = dwOffset + count * sizeof(MIB_IPDESTROW);

    if (dwSpaceCount < count)
    {
        dwResult = ERROR_INSUFFICIENT_BUFFER;
    }

    HeapFree(IPRouterHeap, 0, RouteHandles);
    
    TraceLeave("AccessRouteLonger");

    return dwResult;
}

PINTERFACE_ROUTE_INFO
ConvertDestRowToRouteInfo(
    IN  PMIB_IPDESTROW pMibRow
    )
{
    PINTERFACE_ROUTE_INFO pRouteInfo = (PINTERFACE_ROUTE_INFO)pMibRow;

    //
    // Note that it is important to note that here
    // the source and dest buffers are the same
    //

    pRouteInfo->dwRtInfoPreference = pMibRow->dwForwardPreference;
    pRouteInfo->dwRtInfoViewSet = pMibRow->dwForwardViewSet;

#if 0
    // Removed this since metric=0 is legal for routes to the loopback
    // interface.

    // Make sure Metric1 isn't 0

    if (pRouteInfo->dwForwardMetric1 is 0)
    {
        pRouteInfo->dwForwardMetric1 = 1;
    }

#endif

    return pRouteInfo;
}

DWORD 
AccessIpMatchingRoute(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize, 
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize, 
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    )

/*++
  
Routine Description:

    Function used to add, delete or set a route (IP Dest Row)

Arguments

    dwQueryType     Create, Set, Delete permitted
    pInEntry        Dest, Mask, IfIndex, and NextHop for the row filled in the
                    rgdwVarIndex field. 
    pOutEntrySize   MAX_MIB_OFFSET + sizeof(MIB_IPDESTROW). For Sets the
                    OutBuffer has the row to set

Return Value:
  
    NO_ERROR or some error code defined in iprtrmib

--*/

{
    PMIB_IPDESTROW   pIpRouteRow;
    DWORD            dwMask, i;
    DWORD            dwResult;
    HANDLE           hRtmHandle;

    TraceEnter("AccessIpMatchingRoute");

    pIpRouteRow = (PMIB_IPDESTROW)(pOutEntry->rgbyData);

    if (dwQueryType != ACCESS_DELETE_ENTRY)
    {
        // Make sure we have a buffer of the right size

        if(*pOutEntrySize < MAX_MIB_OFFSET + sizeof(MIB_IPDESTROW))
        {
            *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPDESTROW);

            TraceLeave("AccessIpMatchingRoute");
        
            return ERROR_INSUFFICIENT_BUFFER;
        }
    
        *pOutEntrySize = MAX_MIB_OFFSET + sizeof(MIB_IPDESTROW);
    
        pOutEntry->dwId = ROUTE_MATCHING;
    }
    else
    {
        MIB_IPDESTROW  IpRouteRow;
        
        pIpRouteRow = &IpRouteRow;

        // Do you need to check the input buffer size here ?

        pIpRouteRow->dwForwardDest    = pInEntry->rgdwVarIndex[0];
        pIpRouteRow->dwForwardMask    = pInEntry->rgdwVarIndex[1];
        pIpRouteRow->dwForwardIfIndex = pInEntry->rgdwVarIndex[2];
        pIpRouteRow->dwForwardNextHop = pInEntry->rgdwVarIndex[3];
        pIpRouteRow->dwForwardProto   = pInEntry->rgdwVarIndex[4];
    }

    //
    // Do validation before adding or deleting the route
    //

    if((pIpRouteRow->dwForwardDest & pIpRouteRow->dwForwardMask) isnot 
        pIpRouteRow->dwForwardDest)
    {
        Trace2(ERR,
          "AccessIpMatchingRoute: Dest %d.%d.%d.%d and Mask %d.%d.%d.%d wrong",
           PRINT_IPADDR(pIpRouteRow->dwForwardDest),
           PRINT_IPADDR(pIpRouteRow->dwForwardMask));

        TraceLeave("AccessIpMatchingRoute");

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the RTM handle used to add or delete the route
    //

    hRtmHandle = NULL;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(pIpRouteRow->dwForwardProto is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }

    if(hRtmHandle is NULL)
    {
        Trace1(ERR,
               "AccessIpMatchingRoute: Protocol %d not valid",
               pIpRouteRow->dwForwardProto);
               
        return ERROR_INVALID_PARAMETER;
    }

    switch (dwQueryType)
    {
    case ACCESS_CREATE_ENTRY:
    case ACCESS_SET:

        //
        // Add the RTM route from the ip row entry
        //

        ENTER_READER(ICB_LIST);
    
        dwMask = GetBestNextHopMaskGivenIndex(pIpRouteRow->dwForwardIfIndex,
                                              pIpRouteRow->dwForwardNextHop);
    
        EXIT_LOCK(ICB_LIST);

        //
        // Convert input to INTERFACE_ROUTE_INFO and add
        //

        dwResult = AddRtmRoute(hRtmHandle,
                               ConvertDestRowToRouteInfo(pIpRouteRow),
                               IP_VALID_ROUTE | IP_STACK_ROUTE,
                               dwMask,
                               pIpRouteRow->dwForwardAge,
                               NULL);
    
        if(dwResult isnot NO_ERROR)
        {
            Trace1(MIB,
                "AccessIpMatchingRoute: Could not set route to RTM: Dest %x\n",
                pIpRouteRow->dwForwardDest);
        }

        break;

    case ACCESS_DELETE_ENTRY:

        dwResult = DeleteRtmRoute(hRtmHandle,
                                  ConvertDestRowToRouteInfo(pIpRouteRow));
        break;

    default:

        dwResult = ERROR_INVALID_FUNCTION;
    }

    TraceLeave("AccessIpMatchingRoute");

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\access.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\access.h

Abstract:

    Header for access.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

typedef 
DWORD
(ACCESS_FN)(
    DWORD                dwQueryType,
    DWORD                dwInEntrySize,
    PMIB_OPAQUE_QUERY    pInEntry,
    PDWORD               pOutEntrySize,
    PMIB_OPAQUE_INFO     pOutEntry,
    PBOOL                pbCache
    );

ACCESS_FN AccessIfNumber;
ACCESS_FN AccessIfTable;
ACCESS_FN AccessIfRow;
ACCESS_FN AccessIcmpStats;
ACCESS_FN AccessUdpStats;
ACCESS_FN AccessUdpTable;
ACCESS_FN AccessUdpRow;
ACCESS_FN AccessTcpStats;
ACCESS_FN AccessTcpTable;
ACCESS_FN AccessTcpRow;
ACCESS_FN AccessIpStats;
ACCESS_FN AccessIpAddrTable;
ACCESS_FN AccessIpForwardNumber;
ACCESS_FN AccessIpForwardTable;
ACCESS_FN AccessIpNetTable;
ACCESS_FN AccessIpAddrRow;
ACCESS_FN AccessIpForwardRow;
ACCESS_FN AccessIpNetRow;
ACCESS_FN AccessMcastMfe;
ACCESS_FN AccessMcastMfeStats;
ACCESS_FN AccessMcastMfeStatsEx;
ACCESS_FN AccessProxyArp;
ACCESS_FN AccessBestIf;
ACCESS_FN AccessBestRoute;
ACCESS_FN AccessMcastIfStats;
ACCESS_FN AccessMcastStats;
ACCESS_FN AccessMcastBoundary;
ACCESS_FN AccessMcastScope;
ACCESS_FN AccessIfStatus;
ACCESS_FN AccessDestMatching;
ACCESS_FN AccessDestLonger;
ACCESS_FN AccessDestShorter;
ACCESS_FN AccessRouteMatching;
ACCESS_FN AccessRouteLonger;
ACCESS_FN AccessRouteShorter;
ACCESS_FN AccessIpMatchingRoute;
ACCESS_FN AccessSetRouteState;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\asyncwrk.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\asyncwrk.c

Abstract:

    All functions called spooled to a worker function

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

#include "allinc.h"

DWORD
QueueAsyncFunction(
    WORKERFUNCTION   pfnFunction,
    PVOID            pvContext,
    BOOL             bAlertable
    )

/*++

Routine Description


Locks


Arguments


Return Value


--*/

{
    DWORD   dwResult = NO_ERROR;
    BOOL    bRetval;

    
    EnterCriticalSection(&RouterStateLock);
    
    if (RouterState.IRS_State is RTR_STATE_RUNNING)
    {
        RouterState.IRS_RefCount++;

        LeaveCriticalSection(&RouterStateLock);
    }
    else
    {                                    
        LeaveCriticalSection(&RouterStateLock) ;
        
        return ERROR_ROUTER_STOPPED ;
    }                  

   
    bRetval = QueueUserWorkItem(
                             (LPTHREAD_START_ROUTINE)pfnFunction,
                             pvContext,
                             bAlertable ? WT_EXECUTEINIOTHREAD : 0);

    //
    // If we successfully queued the item, dont decrement the count
    //
    
    if(bRetval isnot TRUE)
    {
        dwResult = GetLastError();
        
        Trace1(GLOBAL,
               "QueueAsyncWorker %x",
               pfnFunction);

        EnterCriticalSection(&RouterStateLock);
    
        RouterState.IRS_RefCount--;
        
        LeaveCriticalSection(&RouterStateLock);
    }
        
    return dwResult;
}
    
    
VOID
RestoreStaticRoutes(
    PVOID   pvContext
    )

/*++

Routine Description


Locks


Arguments


Return Value

--*/

{
    PICB                    pIfToRestore, pOldIf;
    PRESTORE_INFO_CONTEXT   pricInfo;
    DWORD                   dwResult, dwSize, dwIndex, dwSeq, i;
    PRTR_INFO_BLOCK_HEADER  pribhIfInfo;
    HANDLE                  hDIM;
    
    TraceEnter("RestoreStaticRoutes");
    
    ENTER_READER(ICB_LIST);

    pricInfo        = (PRESTORE_INFO_CONTEXT)pvContext;

    dwIndex         = pricInfo->dwIfIndex;
    pIfToRestore    = InterfaceLookupByIfIndex(dwIndex);

    HeapFree(IPRouterHeap,
             0,
             pvContext);

    if(pIfToRestore is NULL)
    {
        Trace0(ERR,
               "RestoreStaticRoutes: Could not find ICB");

        TraceLeave("RestoreStaticRoutes");

        EXIT_LOCK(ICB_LIST);

        ExitRouterApi();
        
        return;
    }

    if(pIfToRestore->ritType is ROUTER_IF_TYPE_DEDICATED)
    {
        //
        // Now pick up the routes the stack may have added
        //

        AddAllStackRoutes(pIfToRestore);

        for ( i = 0; i < pIfToRestore->dwNumAddresses; i++)
        {
            AddLoopbackRoute(
                pIfToRestore->pibBindings[i].dwAddress,
                pIfToRestore->pibBindings[i].dwMask
                );
        }
    }

    pOldIf  = pIfToRestore;
    hDIM    = pIfToRestore->hDIMHandle;
    dwSeq   = pIfToRestore->dwSeqNumber;
    
    EXIT_LOCK(ICB_LIST);
        
       
    Trace1(IF,
           "RestoreStaticRoutes: restoring for %S\n",
           pIfToRestore->pwszName);
 
    dwSize = 0;

    dwResult = RestoreInterfaceInfo(hDIM,
                                    PID_IP,
                                    NULL,
                                    &dwSize);

    if(dwResult isnot ERROR_BUFFER_TOO_SMALL)
    {
        //
        // This is the only error code which will give us a good info size
        //

        Trace2(ERR,
               "RestoreStaticRoutes: Error %d trying to get info size from DIM for i/f %d",
               dwResult,
               dwIndex);

        TraceLeave("RestoreStaticRoutes");
    
        ExitRouterApi();

        return;
    }
                        
    //
    // So now we have the memory size we use double to 
    // avoid any problem
    //
        
    dwSize      = 2 * dwSize;
        
    pribhIfInfo = HeapAlloc(IPRouterHeap,
                            HEAP_ZERO_MEMORY,
                            dwSize);
        
    if(pribhIfInfo is NULL)
    {
        Trace2(ERR,
               "RestoreStaticRoutes: Error allocating %d bytes for info for i/f %d",
               dwSize,
               dwIndex);

        TraceLeave("RestoreStaticRoutes");
    
        ExitRouterApi();

        return;
    }
        
    dwResult = RestoreInterfaceInfo(hDIM,
                                    PID_IP,
                                    (PVOID)pribhIfInfo,
                                    &dwSize);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "RestoreStaticRoutes: Error %d getting info for i/f %d",
               dwResult,
               dwIndex);

        TraceLeave("RestoreStaticRoutes");
    
        ExitRouterApi();

        return;
    }

    ENTER_READER(ICB_LIST);

    pIfToRestore = InterfaceLookupByIfIndex(dwIndex);

    if(pIfToRestore is NULL)
    {
        EXIT_LOCK(ICB_LIST);

        HeapFree(IPRouterHeap,
                 0,
                 pribhIfInfo);

        ExitRouterApi();

        return;
    }

    if((pIfToRestore->dwOperationalState <= IF_OPER_STATUS_UNREACHABLE) or
       (pIfToRestore->dwAdminState isnot IF_ADMIN_STATUS_UP))
    {
        Trace3(IF,
               "RestoreStaticRoutes: Not restoring routes on %S because states are %d %d",
               pIfToRestore->pwszName,
               pIfToRestore->dwOperationalState,
               pIfToRestore->dwAdminState);

        EXIT_LOCK(ICB_LIST);
        
        HeapFree(IPRouterHeap,
                 0,
                 pribhIfInfo);

        ExitRouterApi();

        return;
    }

    IpRtAssert(pIfToRestore->dwSeqNumber is dwSeq);
    IpRtAssert(pIfToRestore is pOldIf);
    
    dwResult = SetRouteInfo(pIfToRestore,
                            pribhIfInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "RestoreStaticRoutes. Error %d setting routes for %S",
               dwResult,
               pIfToRestore->pwszName);
    }
    else
    {
        Trace1(IF,
               "RestoreStaticRoutes: Successfully set routes for %S",
               pIfToRestore->pwszName);
    }

    pIfToRestore->bRestoringRoutes = FALSE;

    EXIT_LOCK(ICB_LIST);
    
    HeapFree(IPRouterHeap,
             0,
             pribhIfInfo);

    TraceLeave("RestoreStaticRoutes");
    
    ExitRouterApi();

    return;
}

VOID
ResolveHbeatName(
    PVOID pvContext
    )
{
    PHEARTBEAT_CONTEXT  pInfo;
    HOSTENT             *pHostEntry;
    CHAR                pszGroup[MAX_GROUP_LEN];
    PMCAST_HBEAT_CB     pHbeatCb;
    PICB                picb;
    DWORD               dwResult;

    pInfo = (PHEARTBEAT_CONTEXT) pvContext;
 
    WideCharToMultiByte(CP_ACP,
                        0,
                        pInfo->pwszGroup,
                        -1,
                        pszGroup,
                        MAX_GROUP_LEN,
                        NULL,
                        NULL);

    pHostEntry = gethostbyname(pszGroup);

    if(pHostEntry is NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pvContext);

        Trace2(ERR,
               "ResolveHbeatName: Error %d resolving %S",
               GetLastError(),
               pInfo->pwszGroup);

        ExitRouterApi();

        return;
    }
   
    ENTER_WRITER(ICB_LIST);

    picb = InterfaceLookupByIfIndex(pInfo->dwIfIndex);

    if(picb is NULL)
    {
        EXIT_LOCK(ICB_LIST);

        HeapFree(IPRouterHeap,
                 0,
                 pvContext);

        ExitRouterApi();

        return;
    }

    if(picb isnot pInfo->picb)
    {
        EXIT_LOCK(ICB_LIST);

        HeapFree(IPRouterHeap,
                 0,
                 pvContext);

        ExitRouterApi();

        return;
    }

    pHbeatCb = &picb->mhcHeartbeatInfo;

    pHbeatCb->dwGroup = *((PDWORD)(pHostEntry->h_addr_list[0]));

    HeapFree(IPRouterHeap,
             0,
             pvContext); 

    dwResult = StartMHeartbeat(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "ResolveHbeatName: Error %d starting hbeat for %S",
               dwResult,
               picb->pwszName);
    }

    EXIT_LOCK(ICB_LIST);

    ExitRouterApi();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\close.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\close.c

Abstract:

    Function related to shutdown

Revision History:

    Gurdeep Singh Pall          6/14/95  Created

--*/

#include "allinc.h"

VOID
ReinstallOldRoutes(
    );


VOID
RouterManagerCleanup(
    VOID
    )
/*++

Routine Description

    The main cleanup function

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    HANDLE hRtmHandle;
    DWORD  i;

    TraceEnter("RouterManagerCleanup");

    DeleteAllInterfaces();
    
    UnloadRoutingProtocols();
    
    UnInitHashTables();

    CloseIPDriver();

    CloseMcastDriver();

    MIBCleanup();

    CloseIpIpKey();
    
    if (!RouterRoleLanOnly) 
    {
        //
        // WAN related cleanups
        //
        
        CloseWanArp() ;

        if (g_bEnableNetbtBcastFrowarding)
        {
            RestoreNetbtBcastForwardingMode();
        }
    }
  
    if(g_hMprConfig isnot NULL)
    {
        MprConfigServerDisconnect(g_hMprConfig);
    }
 
    MgmDeInitialize ();

    if (g_hNotification isnot NULL)
    {
        RtmDeregisterFromChangeNotification(g_hLocalRoute,
                                            g_hNotification);

        g_hNotification = NULL;
    }


    if (g_hDefaultRouteNotification isnot NULL)
    {
        RtmDeregisterFromChangeNotification(g_hNetMgmtRoute,
                                            g_hDefaultRouteNotification);

        g_hDefaultRouteNotification = NULL;
    }

    // Cleanup and deregister all RTM registrations
    
    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

        if (hRtmHandle isnot NULL)
        {
            // Delete all routes added by this regn
            DeleteRtmRoutes(hRtmHandle, 0, TRUE);
        
            // Delete all nexthops added by this regn
            DeleteRtmNexthops(hRtmHandle, 0, TRUE);

            // Deregister this registration from RTM
            RtmDeregisterEntity(hRtmHandle);

            g_rgRtmHandles[i].dwProtoId    = 0;
            g_rgRtmHandles[i].hRouteHandle = NULL;
        }
    }

    // Null out the aliases to the above regn handles
    
    g_hLocalRoute       = NULL;
    g_hAutoStaticRoute  = NULL;
    g_hStaticRoute      = NULL;
    g_hNonDodRoute      = NULL;
    g_hNetMgmtRoute     = NULL;

    //
    // When last entity deregisters, the route table is automatically deleted
    //

    //
    // Before closing the handle to the TCP driver, reinstall all the routes 
    // that existed before we started. The memory was from route heap so will 
    // get freed
    //

    if(!IsListEmpty(&g_leStackRoutesToRestore))
    {
        ReinstallOldRoutes();
    }

    //
    // Close handles used for notification
    //
    
    if(g_hDemandDialEvent isnot NULL)
    {
        CloseHandle(g_hDemandDialEvent) ;
        g_hDemandDialEvent = NULL;
    }

    if(g_hIpInIpEvent isnot NULL)
    {
        CloseHandle(g_hIpInIpEvent);
        g_hIpInIpEvent = NULL;
    }

    if(g_hSetForwardingEvent isnot NULL)
    {
        CloseHandle(g_hSetForwardingEvent);
        g_hSetForwardingEvent = NULL;
    }

    if(g_hForwardingChangeEvent isnot NULL)
    {
        CloseHandle(g_hForwardingChangeEvent);

        g_hForwardingChangeEvent = NULL;
    }

    if(g_hStackChangeEvent isnot NULL)
    {
        CloseHandle(g_hStackChangeEvent);
        g_hStackChangeEvent = NULL;
    }

    if(g_hRoutingProtocolEvent isnot NULL)
    {
        CloseHandle(g_hRoutingProtocolEvent) ;
        g_hRoutingProtocolEvent = NULL;
    }
    
    if(g_hStopRouterEvent isnot NULL)
    {
        CloseHandle(g_hStopRouterEvent) ;
        g_hStopRouterEvent = NULL;
    }
   
    if(g_hRtrDiscSocketEvent isnot NULL)
    {
        CloseHandle(g_hRtrDiscSocketEvent);
        g_hRtrDiscSocketEvent = NULL;
    }

    if(g_hMcMiscSocketEvent isnot NULL)
    {
        CloseHandle(g_hMcMiscSocketEvent);
        g_hMcMiscSocketEvent = NULL;
    }

    if(g_hRtrDiscTimer isnot NULL)
    {
        CloseHandle(g_hRtrDiscTimer);
        g_hRtrDiscTimer = NULL;
    }

    for(i = 0; i < NUM_MCAST_IRPS; i++)
    {
        if(g_hMcastEvents[i] isnot NULL)
        {
            CloseHandle(g_hMcastEvents[i]);

            g_hMcastEvents[i] = NULL;
        }
    }
 
    for(i = 0; i < NUM_ROUTE_CHANGE_IRPS; i++)
    {
        if(g_hRouteChangeEvents[i] isnot NULL)
        {
            CloseHandle(g_hRouteChangeEvents[i]);

            g_hRouteChangeEvents[i] = NULL;
        }
    }


    if(WSACleanup() isnot NO_ERROR)
    {
        Trace1(ERR,
               "RouterManagerCleanup: WSACleanup returned %d",
               WSAGetLastError());
    }
    
    for(i = 0; i < NUM_LOCKS; i++)
    {
        RtlDeleteResource(&g_LockTable[i]);
    }

    //
    // This cleans out the interface structures, since they are all
    // allocated from this heap
    //
    
    if(IPRouterHeap isnot NULL)
    {
        HeapDestroy (IPRouterHeap) ;
        IPRouterHeap = NULL;
    }
    
    Trace0(GLOBAL, "IP Router Manager cleanup done");

    TraceLeave("RouterManagerCleanup");
    
    TraceDeregister (TraceHandle) ;
}

VOID
ReinstallOldRoutes(
    )
{
    DWORD               dwResult;
    PROUTE_LIST_ENTRY   prl;
    
    TraceEnter("ReinstallOldRoutes");
    
    while (!IsListEmpty(&g_leStackRoutesToRestore))
    {
        prl = (PROUTE_LIST_ENTRY) RemoveHeadList(
                &g_leStackRoutesToRestore
                );

        TraceRoute2(
            ROUTE, "%d.%d.%d.%d/%d.%d.%d.%d",
            PRINT_IPADDR( prl->mibRoute.dwForwardDest ),
            PRINT_IPADDR( prl->mibRoute.dwForwardMask )
            );
                
        dwResult = SetIpForwardEntryToStack(&(prl->mibRoute));
        
        if (dwResult isnot NO_ERROR) 
        {
            Trace2(ERR,
                   "ReinstallOldRoutes: Failed to add route to %x from "
                   " init table. Error %x",
                   prl->mibRoute.dwForwardDest,
                   dwResult);
        }
    }

    TraceLeave("ReinstallOldRoutes");
}


VOID
MIBCleanup(
    VOID
    )
{
    TraceEnter("MIBCleanup");
    
    if(g_hIfHeap isnot NULL)
    {
        HeapDestroy(g_hIfHeap);
        g_hIfHeap = NULL;
    }
    
    if(g_hUdpHeap isnot NULL)
    {
        HeapDestroy(g_hUdpHeap);
        g_hUdpHeap = NULL;
    }
    
    if(g_hIpAddrHeap isnot NULL)
    {
        HeapDestroy(g_hIpAddrHeap);
        g_hIpAddrHeap = NULL;
    }
    
    if(g_hIpForwardHeap isnot NULL)
    {
        HeapDestroy(g_hIpForwardHeap);
        g_hIpForwardHeap = NULL;
    }
    
    if(g_hIpNetHeap isnot NULL)
    {
        HeapDestroy(g_hIpNetHeap);
        g_hIpNetHeap = NULL;
    }

    TraceLeave("MIBCleanup");
}

//* UnloadRoutingProtocols()
//
//  Function: 1. Calls stopprotocol for each routing protocol
//            2. Waits for protocols to stop
//            3. Unloads the routing protocol dlls.
//
//  Returns:  Nothing.
//*
VOID
UnloadRoutingProtocols()
{
    PLIST_ENTRY currentlist ;
    PPROTO_CB protptr ;

    TraceEnter("UnloadRoutingProtocols");

    while (!IsListEmpty(&g_leProtoCbList)) 
    {
        
        currentlist = RemoveHeadList(&g_leProtoCbList);

        protptr = CONTAINING_RECORD (currentlist, PROTO_CB, leList) ;

        //
        // relenquish CPU to enable DLL threads to finish
        //
        Sleep(0);
        
        FreeLibrary (protptr->hiHInstance) ;       // unload dll
        
        HeapFree (IPRouterHeap, 0, protptr) ;       // free cb
        
    }

    TraceLeave("UnloadRoutingProtocols");
}


VOID
CloseIPDriver(
    VOID
    )
{
    TraceEnter("CloseIPDriver");
    
    if(g_hIpDevice isnot NULL)
    {
        CloseHandle(g_hIpDevice) ;
    }

    if (g_hIpRouteChangeDevice isnot NULL)
    {
        CloseHandle(g_hIpRouteChangeDevice);
    }

    TraceLeave("CloseIPDriver");
    
}

VOID
CloseMcastDriver(
    VOID
    )
{
    TraceEnter("CloseMcastDriver");

    if(g_hMcastDevice isnot NULL)
    {
        CloseHandle(g_hMcastDevice);
    }

    TraceLeave("CloseMcastDriver");

}


DWORD
StopDriverAndCloseHandle(
    PCHAR   pszServiceName,
    HANDLE  hDevice
    )
{
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    SC_HANDLE           schSCManager, schService;
    DWORD               dwErr;
    SERVICE_STATUS      ssStatus;

    TraceEnter("StopDriverAndCloseHandle");
    
    if(hDevice isnot NULL)
    {
        CloseHandle(hDevice);
    }
    
    schSCManager = OpenSCManager(NULL, 
                                 NULL, 
                                 SC_MANAGER_ALL_ACCESS);
        
    if(schSCManager is NULL)
    {
        dwErr = GetLastError();
        
        Trace2(ERR,
               "StopDriver: Error %d opening service controller for %s", 
               dwErr,
               pszServiceName);

        TraceLeave("StopDriver");
        
        return dwErr;
    }
    
    schService = OpenService(schSCManager,
                             pszServiceName,
                             SERVICE_ALL_ACCESS);
    
    if(schService is NULL)
    {
        dwErr = GetLastError();
        
        Trace2(ERR,
               "StopDriver: Error %d opening %s",
               dwErr,
               pszServiceName);
        
        CloseServiceHandle(schSCManager);

        TraceLeave("StopDriver");
        
        return dwErr;
    }
    
    if(!ControlService(schService,
                       SERVICE_CONTROL_STOP,
                       &ssStatus))
    {
        dwErr = GetLastError();
        
        Trace2(ERR,
               "StopDriver: Error %d stopping %s",
               dwErr,
               pszServiceName);

        TraceLeave("StopDriver");
        
        return dwErr;
    }

    TraceLeave("StopDriver");
    
    return NO_ERROR ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\asyncwrk.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\asyncwrk.h

Abstract:

    All functions called spooled to a worker function

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

typedef struct _RESTORE_INFO_CONTEXT
{
    DWORD   dwIfIndex;
}RESTORE_INFO_CONTEXT, *PRESTORE_INFO_CONTEXT;


VOID 
RestoreStaticRoutes(
    PVOID pvContext
    );

VOID
ResolveHbeatName(
    PVOID pvContext
    );

DWORD
QueueAsyncFunction(
    WORKERFUNCTION   pfnFunction,
    PVOID            pvContext,
    BOOL             bAlertable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\compare.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\compare.c

Abstract:
         File contains the following functions
	      PortCmp
	      Cmp
	      InetCmp
	      UdpCmp
	      TcpCmp
	      IpNetCmp
	
	All these functions behave like strcmp. They return >0 if first argument is greater
	than the second, <0 if the second is greater than the first and 0 if they are equal
	
	These functions should be revised to make them more effecient

Revision History:

    Amritansh Raghav          6/8/95  Created
    Amritansh Raghav          10/18/95 The functions now return >0,0,<0 instead of +1,0,-1

--*/

#include "allinc.h"
#include "winsock2.h"

LONG 
UdpCmp(
       DWORD dwAddr1, 
       DWORD dwPort1, 
       DWORD dwAddr2, 
       DWORD dwPort2
       )
{
    LONG lResult;
    
    if(InetCmp(dwAddr1,dwAddr2,lResult))
    {
        return lResult;
    }
    else
    {
        return PortCmp(dwPort1,dwPort2,lResult);
    }
}

LONG 
TcpCmp(
       DWORD dwLocalAddr1, 
       DWORD dwLocalPort1, 
       DWORD dwRemAddr1, 
       DWORD dwRemPort1,
       DWORD dwLocalAddr2, 
       DWORD dwLocalPort2, 
       DWORD dwRemAddr2, 
       DWORD dwRemPort2
       )
{
    LONG lResult;
    
    if(InetCmp(dwLocalAddr1,dwLocalAddr2,lResult) isnot 0)
    {
        return lResult;
    }
    else
    {
        if(PortCmp(dwLocalPort1,dwLocalPort2,lResult) isnot 0)
        {
            return lResult;
        }
        else
        {
            if(InetCmp(dwRemAddr1,dwRemAddr2,lResult) isnot 0)
            {
                return lResult;
            }
            else
            {
                return PortCmp(dwRemPort1,dwRemPort2,lResult);
            }
        }
    }
}

LONG 
IpNetCmp(
         DWORD dwIfIndex1, 
         DWORD dwAddr1, 
         DWORD dwIfIndex2, 
         DWORD dwAddr2
         )
{
    LONG lResult;
    
    //
    // Index is a simple DWORD, not a port
    //

    if(dwIfIndex1 != dwIfIndex2)
    {
        if(dwIfIndex1 < dwIfIndex2)
        {
            return -1;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        return InetCmp(dwAddr1,dwAddr2,lResult);
    }
}

LONG
IpForwardCmp(
             DWORD dwIpDest1, 
             DWORD dwProto1, 
             DWORD dwPolicy1, 
             DWORD dwIpNextHop1,
             DWORD dwIpDest2, 
             DWORD dwProto2, 
             DWORD dwPolicy2, 
             DWORD dwIpNextHop2
             )
{
    LONG lResult;
    
    if(InetCmp(dwIpDest1,dwIpDest2,lResult) isnot 0)
    {
        return lResult;
    }
    else
    {
        if(Cmp(dwProto1,dwProto2,lResult) isnot 0)
        {
            return lResult;
        }
        else
        {
            if(Cmp(dwPolicy1,dwPolicy2,lResult) isnot 0)
            {
                return lResult;
            }
            else
            {
                return InetCmp(dwIpNextHop1,dwIpNextHop2,lResult);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\cache.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:
         File contains the following functions
	      ActionCache
	      CacheToA

Revision History:

    Amritansh Raghav          6/8/95  Created

--*/


//
// Include files
//

#include "allinc.h"

DWORD
UpdateCache(
    DWORD dwCache,
    BOOL *fUpdate
    )

/*++

Routine Description

    Function used to update a cache. It checks to see if the last time
    the cache was updated is greater than the time out (A value of 0
    for the last time of update means the cache is invalid), calls the
    function that loads the cache and then sets the last update time

Locks



Arguments

    dwCache     This is one of the Cache Ids defined in rtrmgr/defs.h. It
                is used to index into the table of locks protecting the caches,
                the table  of function pointers that holds a pointer to a
                function that loads the cache andthe table of last update times

    fUpdate     Is Set to true if the cache is updated

Return Value

    None

--*/

{
    DWORD  dwResult = NO_ERROR;
    LONG   dwNeed;
    LONG   dwSpace;


    //
    // BUG put in a bounds check here otherwise effects can be disastrous
    //

    // Trace1(MIB,"Trying to update %s cache", CacheToA(dwCache));

    __try
    {
        ENTER_READER(dwCache);

        if((g_LastUpdateTable[dwCache] isnot 0) and
           ((GetCurrentTime() - g_LastUpdateTable[dwCache]) < g_TimeoutTable[dwCache]))
        {
            *fUpdate = FALSE;
            dwResult = NO_ERROR;
            __leave;
        }

        READER_TO_WRITER(dwCache);

        // Trace0(MIB,"Cache out of date");

        dwResult = (*g_LoadFunctionTable[dwCache])();

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,"Error %d loading %s cache",
                   dwResult,
                   CacheToA(dwCache));

            g_LastUpdateTable[dwCache] = 0;

            __leave;
        }

        g_LastUpdateTable[dwCache] = GetCurrentTime();

        dwResult = NO_ERROR;
    }
    __finally
    {
        EXIT_LOCK(dwCache);
    }

    return dwResult; //to keep compiler happy
}


PSZ
CacheToA(
         DWORD dwCache
         )
{
    static PSZ cacheName[] = {"Ip Address Table",
                              "Ip Forward Table",
                              "Ip Net To Media table",
                              "Tcp Table",
                              "Udp Table",
                              "Arp Entity Table",
                              "Illegal Cache Number - ABORT!!!!"};

    return( (dwCache >= NUM_CACHE - 1)?
           cacheName[NUM_CACHE-1] : cacheName[dwCache]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\defs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\defs.c

Abstract:

    IP Router Manager defines

Revision History:

    Gurdeep Singh Pall          6/16/95  Created

--*/

#ifndef __DEFS_H__
#define __DEFS_H__

#include "logtrdef.h"

//
// Neat macros to avoid errors
//

#define is      ==
#define isnot   !=
#define and     &&
#define or      ||

#define INVALID_INDEX_OR_INSTANCE   0xffffffff

#define INVALID_ADAPTER_ID          INVALID_INDEX_OR_INSTANCE
#define INVALID_IF_INSTANCE         INVALID_INDEX_OR_INSTANCE
#define INVALID_AT_INSTANCE         INVALID_INDEX_OR_INSTANCE
#define INVALID_IF_INDEX            INVALID_INDEX_OR_INSTANCE

#define INVALID_IP_ADDRESS          0x00000000

#define HOST_ROUTE_MASK             0xFFFFFFFF
#define IP_LOOPBACK_ADDRESS         0x0100007F
#define ALL_ONES_BROADCAST          0xFFFFFFFF
#define ALL_ONES_MASK               0xFFFFFFFF
#define LOCAL_NET_MULTICAST         0x000000E0
#define LOCAL_NET_MULTICAST_MASK    0x000000F0

#define CLASSA_ADDR(a)  (( (*((uchar *)&(a))) & 0x80) == 0)
#define CLASSB_ADDR(a)  (( (*((uchar *)&(a))) & 0xc0) == 0x80)
#define CLASSC_ADDR(a)  (( (*((uchar *)&(a))) & 0xe0) == 0xc0)
#define CLASSE_ADDR(a)  ((( (*((uchar *)&(a))) & 0xf0) == 0xf0) && \
                        ((a) != 0xffffffff))

#define CLASSA_MASK     0x000000ff
#define CLASSB_MASK     0x0000ffff
#define CLASSC_MASK     0x00ffffff
#define CLASSD_MASK     0x000000e0
#define CLASSE_MASK     0xffffffff

#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = ((((a)>>8) & 0x00ff0000) - (((b)>>8) & 0x00ff0000)))))))

#define GetClassMask(a)\
    (CLASSA_ADDR((a)) ? CLASSA_MASK : \
        (CLASSB_ADDR((a)) ? CLASSB_MASK : \
            (CLASSC_ADDR((a)) ? CLASSC_MASK : CLASSE_MASK)))

#define IsValidIpAddress(a)                                     \
    ((((ULONG)((a) & 0x000000FF)) <  ((ULONG)0x000000E0)) &&    \
     (((a) & 0x000000FF) != 0))

//
// Number of pending IRPs
//

#define NUM_MCAST_IRPS              3
#define NUM_ROUTE_CHANGE_IRPS       3

#define EVENT_DEMANDDIAL            0
#define EVENT_IPINIP                (EVENT_DEMANDDIAL       + 1)
#define EVENT_STOP_ROUTER           (EVENT_IPINIP           + 1)
#define EVENT_SET_FORWARDING        (EVENT_STOP_ROUTER      + 1)
#define EVENT_FORWARDING_CHANGE     (EVENT_SET_FORWARDING   + 1)
#define EVENT_STACK_CHANGE          (EVENT_FORWARDING_CHANGE + 1)
#define EVENT_ROUTINGPROTOCOL       (EVENT_STACK_CHANGE     + 1)
#define EVENT_RTRDISCTIMER          (EVENT_ROUTINGPROTOCOL  + 1)
#define EVENT_RTRDISCSOCKET         (EVENT_RTRDISCTIMER     + 1)
#define EVENT_MCMISCSOCKET          (EVENT_RTRDISCSOCKET    + 1)
#define EVENT_MHBEAT                (EVENT_MCMISCSOCKET     + 1)
#define EVENT_MZAPTIMER             (EVENT_MHBEAT           + 1)
#define EVENT_MZAPSOCKET            (EVENT_MZAPTIMER        + 1)
#define EVENT_RASADVTIMER           (EVENT_MZAPSOCKET       + 1)
#define EVENT_MCAST_0               (EVENT_RASADVTIMER      + 1)
#define EVENT_MCAST_1               (EVENT_MCAST_0          + 1)
#define EVENT_MCAST_2               (EVENT_MCAST_1          + 1)
#define EVENT_ROUTE_CHANGE_0        (EVENT_MCAST_2          + 1)
#define EVENT_ROUTE_CHANGE_1        (EVENT_ROUTE_CHANGE_0   + 1)
#define EVENT_ROUTE_CHANGE_2        (EVENT_ROUTE_CHANGE_1   + 1)


//
// Last one + 1
//

#define NUMBER_OF_EVENTS            (EVENT_ROUTE_CHANGE_2   + 1)

//
// The polling time to see if all interfaces have been deleted
//

#define INTERFACE_DELETE_POLL_TIME  2500

//
// Number of times we try to read the server adapter address
//

#define MAX_SERVER_INIT_TRIES       1

//
// Number of millisecs we sleep between tries
//

#define SERVER_INIT_SLEEP_TIME      3000


#define REGISTER                    register

#define IP_ROUTE_HASH_TABLE_SIZE    257
#define IP_ROUTE_TABLE_MEMORY       64 * 50000  // 64 approx size of route, 50000 routes

#define MGM_IF_TABLE_SIZE           29
#define MGM_GROUP_TABLE_SIZE        257
#define MGM_SOURCE_TABLE_SIZE       257

#define ICB_HASH_TABLE_SIZE         57

#define BINDING_HASH_TABLE_SIZE     57

#define BIND_HASH(X)                ((X) % BINDING_HASH_TABLE_SIZE)

//#define ADAPTER_HASH_TABLE_SIZE     57
//#define ADAPTER_HASH(X)             ((X) % ADAPTER_HASH_TABLE_SIZE)


//
// A coherency number put into the ICBs. It is incremented with each added
// interface. The internal interface is 1, and the loopback interface is 2
// hence this must be > 2
//

#define LOOPBACK_INTERFACE_INDEX    1
//#define SERVER_INTERFACE_INDEX      2
#define INITIAL_SEQUENCE_NUMBER         1

//
// For links we dont know about, we set the MTU to 1500
//

#define DEFAULT_MTU                 1500


#define LOOPBACK_STRID              9990
#define INTERNAL_STRID              9991
#define WAN_STRID                   9992
#define IPIP_STRID                  9993

//
// Macros called each time an api is called and exited. This is to
// facilitate RouterStop() functionality.
//

#define EnterRouterApi() {                               \
            EnterCriticalSection(&RouterStateLock) ;     \
            if (RouterState.IRS_State == RTR_STATE_RUNNING) {      \
                RouterState.IRS_RefCount++ ;             \
                LeaveCriticalSection(&RouterStateLock) ; \
            } else {                                     \
                LeaveCriticalSection(&RouterStateLock) ; \
                Trace1(ANY, "error %d on RM API", ERROR_ROUTER_STOPPED);    \
                return ERROR_ROUTER_STOPPED ;            \
            }                                            \
        }

#define ExitRouterApi() {                                \
            EnterCriticalSection(&RouterStateLock) ;     \
            RouterState.IRS_RefCount-- ;                 \
            LeaveCriticalSection(&RouterStateLock) ;     \
        }


//++
//
//  BOOL
//  IsIfP2P(
//      IN  DWORD   dwRouterIfType
//      )
//
//--


#define IsIfP2P(t)                              \
    (((t) == ROUTER_IF_TYPE_FULL_ROUTER) ||     \
     ((t) == ROUTER_IF_TYPE_HOME_ROUTER) ||     \
     ((t) == ROUTER_IF_TYPE_TUNNEL1)     ||     \
     ((t) == ROUTER_IF_TYPE_DIALOUT))


//
// Additional flags for the IP route structure
// These are not in RTM.H because we dont want to expose them
// to the public's prying eyes.
//
// NOTE IP_VALID_ROUTE is #defined as 0x00000001
//

#define IP_VALID_ROUTE      0x00000001
#define IP_STACK_ROUTE      0x00000002
#define IP_P2P_ROUTE        0x00000004

#define IP_SETTABLE_ROUTE   (IP_VALID_ROUTE | IP_STACK_ROUTE)

#define ClearRouteFlags(pRoute)         \
    ((pRoute)->Flags1 = 0x00000000)


#define IsRouteValid(pRoute)            \
    ((pRoute)->Flags1 & IP_VALID_ROUTE)

#define SetRouteValid(pRoute)           \
    ((pRoute)->Flags1 |= IP_VALID_ROUTE)

#define ClearRouteValid(pRoute)         \
    ((pRoute)->Flags1 &= ~IP_VALID_ROUTE)


#define IsRouteStack(pRoute)            \
    ((pRoute)->Flags1 & IP_STACK_ROUTE)

#define SetRouteStack(pRoute)           \
    ((pRoute)->Flags1 |= IP_STACK_ROUTE)

#define ClearRouteStack(pRoute)         \
    ((pRoute)->Flags1 &= ~IP_STACK_ROUTE)


#define IsRouteP2P(pRoute)              \
    ((pRoute)->Flags1 & IP_P2P_ROUTE)

#define SetRouteP2P(pRoute)             \
    ((pRoute)->Flags1 |= IP_P2P_ROUTE)

#define ClearRouteP2P(pRoute)           \
    ((pRoute)->Flags1 &= ~IP_P2P_ROUTE)

/*

//
// VOID 
// ConvertRTMToForward(PMIB_IPFORWARDROW forwardRow, RTM_IP_ROUTE *route)
//

#define ConvertRTMToForward(f,route){                                       \
    (f)->dwForwardDest      = (route)->RR_Network.N_NetNumber;              \
    (f)->dwForwardIfIndex   = (route)->RR_InterfaceID;                      \
    (f)->dwForwardMetric1   = (route)->RR_FamilySpecificData.FSD_Metric1;   \
    (f)->dwForwardMetric2   = (route)->RR_FamilySpecificData.FSD_Metric2;   \
    (f)->dwForwardMetric3   = (route)->RR_FamilySpecificData.FSD_Metric3;   \
    (f)->dwForwardMetric4   = (route)->RR_FamilySpecificData.FSD_Metric4;   \
    (f)->dwForwardMetric5   = (route)->RR_FamilySpecificData.FSD_Metric5;   \
    (f)->dwForwardNextHop   = (route)->RR_NextHopAddress.N_NetNumber;       \
    (f)->dwForwardType	    = (route)->RR_FamilySpecificData.FSD_Type;      \
    (f)->dwForwardProto     = (route)->RR_RoutingProtocol;                  \
    (f)->dwForwardAge       = RtmGetRouteAge((route));                      \
    (f)->dwForwardMask      = (route)->RR_Network.N_NetMask;                \
    (f)->dwForwardNextHopAS = (route)->RR_FamilySpecificData.FSD_NextHopAS; \
    (f)->dwForwardPolicy    = (route)->RR_FamilySpecificData.FSD_Policy;}

//
// VOID 
// ConvertForwardToRTM(PMIB_IPFORWARDROW forwardRow, 
//                     RTM_IP_ROUTE       *route, 
//                     DWORD              dwNextHopMask)
//

#define ConvertForwardToRTM(f,route,mask){                                  \
    (route)->RR_Network.N_NetNumber               = (f)->dwForwardDest;     \
    (route)->RR_InterfaceID                       = (f)->dwForwardIfIndex;  \
    (route)->RR_FamilySpecificData.FSD_Metric     =                         \
    (route)->RR_FamilySpecificData.FSD_Metric1    = (f)->dwForwardMetric1;  \
    (route)->RR_FamilySpecificData.FSD_Metric2    = (f)->dwForwardMetric2;  \
    (route)->RR_FamilySpecificData.FSD_Metric3    = (f)->dwForwardMetric3;  \
    (route)->RR_FamilySpecificData.FSD_Metric4    = (f)->dwForwardMetric4;  \
    (route)->RR_FamilySpecificData.FSD_Metric5    = (f)->dwForwardMetric5;  \
    (route)->RR_FamilySpecificData.FSD_Priority   = 0;                      \
    (route)->RR_NextHopAddress.N_NetNumber        = (f)->dwForwardNextHop;  \
    (route)->RR_NextHopAddress.N_NetMask          = (mask);                 \
    (route)->RR_Network.N_NetMask                 = (f)->dwForwardMask;     \
    (route)->RR_FamilySpecificData.FSD_Policy     = (f)->dwForwardPolicy;   \
    (route)->RR_FamilySpecificData.FSD_NextHopAS  = (f)->dwForwardNextHopAS;\
    (route)->RR_FamilySpecificData.FSD_Type       = (f)->dwForwardType;     \
    (route)->RR_RoutingProtocol                   = (f)->dwForwardProto;    \
    ClearRouteFlags((route));                                               \
    SetRouteValid((route));                                                 \
    SetRouteStack((route)); }

//
// VOID 
// ConvertStackToRTM(RTM_IP_ROUTE   *route,
//                   IPRouteEntry   *ipreRow
//                   DWORD          dwNextHopMask)
//

#define ConvertStackToRTM(route,ipreRow,mask){                                  \
    (route)->RR_Network.N_NetNumber               = (ipreRow)->ire_dest;    \
    (route)->RR_InterfaceID                       = (ipreRow)->ire_index;   \
    (route)->RR_FamilySpecificData.FSD_Metric     =                         \
    (route)->RR_FamilySpecificData.FSD_Metric1    = (ipreRow)->ire_metric1; \
    (route)->RR_FamilySpecificData.FSD_Metric2    = (ipreRow)->ire_metric2; \
    (route)->RR_FamilySpecificData.FSD_Metric3    = (ipreRow)->ire_metric3; \
    (route)->RR_FamilySpecificData.FSD_Metric4    = (ipreRow)->ire_metric4; \
    (route)->RR_FamilySpecificData.FSD_Metric5    = (ipreRow)->ire_metric5; \
    (route)->RR_FamilySpecificData.FSD_Priority   = 0;                      \
    (route)->RR_NextHopAddress.N_NetNumber        = (ipreRow)->ire_nexthop; \
    (route)->RR_NextHopAddress.N_NetMask          = (mask);                 \
    (route)->RR_Network.N_NetMask                 = (ipreRow)->ire_mask;    \
    (route)->RR_FamilySpecificData.FSD_Policy     = 0;                      \
    (route)->RR_FamilySpecificData.FSD_NextHopAS  = 0;                      \
    (route)->RR_FamilySpecificData.FSD_Type       = (ipreRow)->ire_type;    \
    (route)->RR_RoutingProtocol                   = (ipreRow)->ire_proto;   \
    ClearRouteFlags((route));                                               \
    SetRouteValid((route));                                                 \
    SetRouteStack((route)); }

//
// VOID 
// ConvertStackToForward(PMIB_IPFORWARDROW forwardRow,
//                       IPRouteEntry       *ipreRow)
//

#define ConvertStackToForward(forwardRow,ipreRow) {              \
    (forwardRow)->dwForwardDest      = (ipreRow)->ire_dest;      \
    (forwardRow)->dwForwardIfIndex   = (ipreRow)->ire_index;     \
    (forwardRow)->dwForwardMetric1   = (ipreRow)->ire_metric1;   \
    (forwardRow)->dwForwardMetric2   = (ipreRow)->ire_metric2;   \
    (forwardRow)->dwForwardMetric3   = (ipreRow)->ire_metric3;   \
    (forwardRow)->dwForwardMetric4   = (ipreRow)->ire_metric4;   \
    (forwardRow)->dwForwardMetric5   = (ipreRow)->ire_metric5;   \
    (forwardRow)->dwForwardNextHop   = (ipreRow)->ire_nexthop;   \
    (forwardRow)->dwForwardType	     = (ipreRow)->ire_type;      \
    (forwardRow)->dwForwardProto     = (ipreRow)->ire_proto;     \
    (forwardRow)->dwForwardAge       = (ipreRow)->ire_age;       \
    (forwardRow)->dwForwardMask      = (ipreRow)->ire_mask;      \
    (forwardRow)->dwForwardNextHopAS = 0;                        \
    (forwardRow)->dwForwardPolicy    = 0; }

*/

#define IPADDRCACHE                 0
#define IPFORWARDCACHE              IPADDRCACHE    + 1
#define IPNETCACHE                  IPFORWARDCACHE + 1
#define TCPCACHE                    IPNETCACHE     + 1
#define UDPCACHE                    TCPCACHE       + 1

//
// Last Cache + 1
//

#define NUM_CACHE                   UDPCACHE    + 1

//
// We tag the ICB_LIST and the PROTOCOL_CB_LIST locks at the end of the 
// locks used by the MIB handler.
//

#define ICB_LIST                    NUM_CACHE
#define PROTOCOL_CB_LIST            ICB_LIST            + 1
#define BINDING_LIST                PROTOCOL_CB_LIST    + 1
#define BOUNDARY_TABLE              BINDING_LIST        + 1
#define MZAP_TIMER                  BOUNDARY_TABLE      + 1
#define ZBR_LIST                    MZAP_TIMER          + 1
#define ZLE_LIST                    ZBR_LIST            + 1
#define ZAM_CACHE                   ZLE_LIST            + 1
#define STACK_ROUTE_LIST            ZAM_CACHE           + 1

//
// Number of locks
//

#define NUM_LOCKS                   STACK_ROUTE_LIST    + 1

#define IPADDRCACHE_TIMEOUT         1000
#define IPFORWARDCACHE_TIMEOUT      1000
#define IPNETCACHE_TIMEOUT          1000
#define TCPCACHE_TIMEOUT            1000   
#define UDPCACHE_TIMEOUT            1000   
#define ARPENTCACHE_TIMEOUT         300 * IPNETCACHE_TIMEOUT

#define SPILLOVER                   5
#define MAX_DIFF                    5

//
// All ACCESS_XXX > ACCESS_GET_NEXT are SETS
// All ACCESS_XXX which have bit0 set require an EXACT MATCH
//

#define ACCESS_GET                  1 
#define ACCESS_GET_FIRST            2
#define ACCESS_GET_NEXT             4
#define ACCESS_SET                  5
#define ACCESS_CREATE_ENTRY         7
#define ACCESS_DELETE_ENTRY         9

#define EXACT_MATCH(X)              ((X) & 0x00000001)

#ifdef DEADLOCK_DEBUG

extern PBYTE   g_pszLockNames[];

#define EXIT_LOCK(id) {                                     \
    Trace1(LOCK,"Exit lock %s",g_pszLockNames[id]);         \
    RtlReleaseResource(&(g_LockTable[(id)]));               \
    Trace1(LOCK,"Exited lock %s",g_pszLockNames[id]);       \
}

#define READER_TO_WRITER(id) {                              \
    Trace1(LOCK,"Reader To Writer %s",g_pszLockNames[id]);  \
    RtlConvertSharedToExclusive(&(g_LockTable[(id)]));      \
    Trace1(LOCK,"Promoted for %s",g_pszLockNames[id]);      \
}

#define ENTER_READER(id) {                                  \
    Trace1(LOCK,"Entering Reader %s",g_pszLockNames[id]);   \
    RtlAcquireResourceShared(&(g_LockTable[(id)]),TRUE);    \
    Trace1(LOCK,"Entered %s",g_pszLockNames[id]);           \
}

#define ENTER_WRITER(id) {                                  \
    Trace1(LOCK,"Entering Writer %s",g_pszLockNames[id]);   \
    RtlAcquireResourceExclusive(&(g_LockTable[(id)]),TRUE); \
    Trace1(LOCK,"Entered %s",g_pszLockNames[id]);           \
}

#define WRITER_TO_READER(id) {                              \
    Trace1(LOCK,"Writer To Reader %s",g_pszLockNames[id]);  \
    RtlConvertExclusiveToShared(&(g_LockTable[(id)]));      \
    Trace1(LOCK,"Demoted for %s",g_pszLockNames[id]);       \
}

#else   // DEADLOCK_DEBUG

#define EXIT_LOCK(id)           RtlReleaseResource(&(g_LockTable[(id)]))
#define READER_TO_WRITER(id)    RtlConvertSharedToExclusive(&(g_LockTable[(id)]))
#define ENTER_READER(id)        RtlAcquireResourceShared(&(g_LockTable[(id)]),TRUE)
#define ENTER_WRITER(id)        RtlAcquireResourceExclusive(&(g_LockTable[(id)]),TRUE)
#define WRITER_TO_READER(id)    RtlConvertExclusiveToShared(&(g_LockTable[(id)]))

#endif  // DEADLOCK_DEBUG


#if DBG

#define IpRtAssert(exp){                                               \
    if(!(exp))                                                          \
    {                                                                   \
        TracePrintf(TraceHandle,                                        \
                    "Assertion failed in %s : %d \n",__FILE__,__LINE__);\
        RouterAssert(#exp,__FILE__,__LINE__,NULL);                      \
    }                                                                   \
}

#else

#define IpRtAssert(exp) 

#endif

//
// Registry defines
//

#define REGISTRY_ENABLE_DHCP           "EnableDHCP"
#define REGISTRY_IPADDRESS             "IPAddress"
#define REGISTRY_SUBNETMASK            "SubnetMask"
#define REGISTRY_DHCPSUBNETMASK        "DhcpSubnetMask"
#define REGISTRY_DHCPIPADDRESS         "DhcpIPAddress"
#define REGISTRY_AUTOCONFIGSUBNETMASK  "IPAutoconfigurationMask"
#define REGISTRY_AUTOCONFIGIPADDRESS   "IPAutoconfigurationAddress"
#define REG_KEY_TCPIP_INTERFACES        \
    "System\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces"

#define net_long(x) (((((ulong)(x))&0xffL)<<24) | \
                     ((((ulong)(x))&0xff00L)<<8) | \
                     ((((ulong)(x))&0xff0000L)>>8) | \
                     ((((ulong)(x))&0xff000000L)>>24))

#define SIZEOF_ROUTEINFO(X)     ((X) * sizeof (MIB_IPFORWARDROW))
#define MAX_ROUTES_IN_BUFFER(X) ((X) / sizeof (MIB_IPFORWARDROW))

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

//
// VOID
// PrintRoute(IPMultihopRouteEntry pRoute)
//

#define PrintRoute(ID,p)                                                    \
{                                                                           \
    ULONG   _i;                                                             \
    Trace4(ID,"%d.%d.%d.%d/%d.%d.%d.%d Proto: %d Metric %d",                \
           PRINT_IPADDR((p)->imre_routeinfo.ire_dest),                      \
           PRINT_IPADDR((p)->imre_routeinfo.ire_mask),                      \
           (p)->imre_routeinfo.ire_proto, (p)->imre_routeinfo.ire_metric1); \
    Trace4(ID,"Via %d.%d.%d.%d/0x%x Type %d Context 0x%x",                  \
           PRINT_IPADDR((p)->imre_routeinfo.ire_nexthop),                   \
           (p)->imre_routeinfo.ire_index,                                   \
           (p)->imre_routeinfo.ire_type,                                    \
           (p)->imre_routeinfo.ire_context);                                \
    for(_i = 1; _i < (p)->imre_numnexthops; i++) {                          \
        Trace4(ID,"Via %d.%d.%d.%d/0x%x Type %d Context 0x%x\n",            \
               PRINT_IPADDR((p)->imre_morenexthops[_i].ine_nexthop),        \
               (p)->imre_morenexthops[_i].ine_ifindex,                      \
               (p)->imre_morenexthops[_i].ine_iretype,                      \
               (p)->imre_morenexthops[_i].ine_context);}                    \
}

//
// System Unit is in 100s of NanoSecs = 1 * 10^7
//

#define SYS_UNITS_IN_1_SEC 10000000

#define SecsToSysUnits(X)  RtlEnlargedIntegerMultiply((X),SYS_UNITS_IN_1_SEC)


#endif // __DEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\demand.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\demand.c

Abstract:

    Handles demand dial/connection events from WANARP driver.

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#include "allinc.h"

DWORD
InitializeWanArp(
    VOID
    )

/*++

Routine Description:

    Creates a handle to WANARP and posts an IRP for notification
    Since the IRP is completed asynchrnously and uses DemandDialEvent for
    notification, the event must have already been created

Arguments:

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    DWORD       dwResult;
    ULONG       ulSize, ulCount, i;
    NTSTATUS    Status;

    IO_STATUS_BLOCK     IoStatusBlock;
    PWANARP_QUEUE_INFO  pQueueInfo;

    TraceEnter("InitializeWanArp");

    g_hWanarpRead = CreateFile(WANARP_DOS_NAME_T,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_OVERLAPPED,
                               NULL);

    if(g_hWanarpRead is INVALID_HANDLE_VALUE)
    {
        g_hWanarpRead  = NULL;

        dwResult = GetLastError();

        Trace1(ERR,
               "InitializeWanArp: Could not open WANARP for read - %d",
               dwResult);

        TraceLeave("InitializeWanArp");

        return dwResult;
    }

    g_hWanarpWrite = CreateFile(WANARP_DOS_NAME_T,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_OVERLAPPED,
                                NULL);

    if(g_hWanarpWrite is INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hWanarpRead);

        g_hWanarpRead  = NULL;
        g_hWanarpWrite = NULL;

        dwResult = GetLastError();

        Trace1(ERR,
               "InitializeWanArp: Could not open WANARP for write - %d",
               dwResult);

        TraceLeave("InitializeWanArp");

        return dwResult;
    }

    //
    // Get the number of call out interfaces and start queueing notifications
    //

    ulCount = 5;
    i       = 0;

    while(i < 3)
    {
        ulSize  = FIELD_OFFSET(WANARP_QUEUE_INFO, rgIfInfo) + 
                  (ulCount * sizeof(WANARP_IF_INFO));

        pQueueInfo = HeapAlloc(IPRouterHeap,
                               0,
                               ulSize);

        if(pQueueInfo is NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;

            break;
        }

        pQueueInfo->fQueue = 1;

        Status = NtDeviceIoControlFile(g_hWanarpWrite,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       IOCTL_WANARP_QUEUE,
                                       pQueueInfo,
                                       sizeof(WANARP_QUEUE_INFO),
                                       pQueueInfo,
                                       ulSize);

        if(Status isnot STATUS_SUCCESS)
        {
            if(Status is STATUS_MORE_ENTRIES)
            {
                IpRtAssert(ulCount > pQueueInfo->ulNumCallout);

                i++;

                ulCount = pQueueInfo->ulNumCallout + (i * 5);

                HeapFree(IPRouterHeap,
                         0,
                         pQueueInfo);

                pQueueInfo = NULL;

                //
                // Go to the top of while()
                //
                
                continue;

            }
            else
            {
                HeapFree(IPRouterHeap,
                         0,
                         pQueueInfo);

                pQueueInfo = NULL;

                break;
            }
        }
        else
        {
            break;
        }
    }
   
    if(Status isnot STATUS_SUCCESS)
    {
        //
        // Close the device and return failure
        //

        CloseHandle(g_hWanarpRead);
        CloseHandle(g_hWanarpWrite);

        g_hWanarpRead  = NULL;
        g_hWanarpWrite = NULL;

        return Status;
    }
 
    //
    // Create any dial out interfaces
    //

    for(i = 0; i < pQueueInfo->ulNumCallout; i++)
    {
        UNICODE_STRING  usTempName;
        PICB            pIcb;

        dwResult = RtlStringFromGUID(&(pQueueInfo->rgIfInfo[i].InterfaceGuid),
                                     &usTempName);

        if(dwResult isnot STATUS_SUCCESS)
        {
            continue;
        }

        //
        // RtlString... returns a NULL terminated buffer
        //

        dwResult = 
            CreateDialOutInterface(usTempName.Buffer,
                                   pQueueInfo->rgIfInfo[i].dwAdapterIndex,
                                   pQueueInfo->rgIfInfo[i].dwLocalAddr,
                                   pQueueInfo->rgIfInfo[i].dwLocalMask,
                                   pQueueInfo->rgIfInfo[i].dwRemoteAddr,
                                   &pIcb);
    }


    HeapFree(IPRouterHeap,
             0,
             pQueueInfo);

    //
    // Post an irp for demand dial notifications.
    //

    PostIoctlForDemandDialNotification() ;

    TraceLeave("InitializeWanArp");

    return NO_ERROR ;
}

VOID
CloseWanArp(
    VOID
    )
{
    NTSTATUS    Status;

    IO_STATUS_BLOCK     IoStatusBlock;
    WANARP_QUEUE_INFO   QueueInfo;

    TraceEnter("CloseWanArp");

    if(g_hWanarpRead)
    {
        CloseHandle(g_hWanarpRead);

        g_hWanarpRead = NULL;
    }

    if(g_hWanarpWrite)
    {
        QueueInfo.fQueue = 0;

        Status = NtDeviceIoControlFile(g_hWanarpWrite,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       IOCTL_WANARP_QUEUE,
                                       &QueueInfo,
                                       sizeof(WANARP_QUEUE_INFO),
                                       &QueueInfo,
                                       sizeof(WANARP_QUEUE_INFO));

        if(Status isnot STATUS_SUCCESS)
        {
        }

        CloseHandle(g_hWanarpWrite);

        g_hWanarpWrite = NULL;
    }

    TraceLeave("CloseWanArp");
}

DWORD
HandleDemandDialEvent(
    VOID
    )

/*++

Routine Description:

    Called by the main thread whenever a demand dial event is received
    We mereley dispatch it to the right handler
    
Locks:

    None

Arguments:

    None

Return Value:

    None    

--*/

{
    PICB            picb;
    DWORD           dwResult;
    NTSTATUS        Status;
    BOOL            bPost;
    
    //
    // drain all demand dial events queued up in WANARP
    //

    TraceEnter("HandleDemandDialEvent");

    bPost = TRUE;
    
    //
    // Since, potentially, this can cause stuff to be written in the ICB,
    // we take lock as a WRITER
    //
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    EnterCriticalSection(&RouterStateLock);

    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
    {
        if(wnWanarpMsg.ddeEvent isnot DDE_INTERFACE_DISCONNECTED)
        {
            Trace1(IF,
                   "ProcessDemandDialEvent: Shutting down. Ignoring event %d",
                   wnWanarpMsg.ddeEvent);

            LeaveCriticalSection(&RouterStateLock);

            return NO_ERROR;
        }
        else
        {
            bPost = FALSE;
        }
    }

    LeaveCriticalSection(&RouterStateLock);

    picb = InterfaceLookupByICBSeqNumber( wnWanarpMsg.dwUserIfIndex );

    if ((wnWanarpMsg.ddeEvent is DDE_CONNECT_INTERFACE) or
        (wnWanarpMsg.ddeEvent is DDE_INTERFACE_CONNECTED) or
        (wnWanarpMsg.ddeEvent is DDE_INTERFACE_DISCONNECTED))
    {
        IpRtAssert(picb);
        
        if (picb isnot NULL)
        {
            switch(wnWanarpMsg.ddeEvent)
            {
                case DDE_CONNECT_INTERFACE:
                {
                    HandleConnectionRequest(picb);

                    break ;
                }

                case DDE_INTERFACE_CONNECTED:
                {
                    HandleConnectionNotification(picb);

                    break ;
                }
                
                case DDE_INTERFACE_DISCONNECTED:
                {
                    HandleDisconnectionNotification(picb);
                    
                    break ;
                }
                
                default:
                {
                    Trace1(ERR,
                           "ProcessDemandDialEvent: Illegal event %d from WanArp",
                           wnWanarpMsg.ddeEvent);
                    
                    break;
                }
            }
        }

        else
        {
            Trace2(
                ANY, "Event %d, could not find interface with ICB %d",
                wnWanarpMsg.ddeEvent, wnWanarpMsg.dwUserIfIndex
                );
        }
    }

    else
    {
        switch(wnWanarpMsg.ddeEvent)
        {
            case DDE_CALLOUT_LINKUP:
            {
                HandleDialOutLinkUp();

                break ;
            }

            case DDE_CALLOUT_LINKDOWN:
            {
                HandleDialOutLinkDown();

                break ;
            }

            default:
            {
                Trace1(ERR,
                       "ProcessDemandDialEvent: Illegal event %d from WanArp",
                       wnWanarpMsg.ddeEvent);
                
                break;
            }
        }
    }

    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    if(bPost)
    {
        PostIoctlForDemandDialNotification();
    }
    
    TraceLeave("HandleDemandDialEvent");
    
    return NO_ERROR;
}

VOID
HandleConnectionRequest(
    PICB    picb
    )

/*++

Routine Description:

    Called when we get a connection request from WANARP.

Locks:

    ICB_LIST lock held as WRITER

Arguments:

    None

Return Value:

    None    

--*/

{
    BOOL        bRet;
    HANDLE      hDim;
    DWORD       dwResult;
    NTSTATUS    nStatus;
    
    
    Trace2(IF,
           "HandleConnectionRequest: Connection request for %S, %d",
           picb->pwszName, picb->dwSeqNumber);

    if(picb->dwOperationalState is CONNECTED)
    {
        //
        // Really weird. Connection attempt for an i/f that
        // WANARP knows is already connected
        //

        Trace2(IF,
               "HandleConnectionRequest: Connection request for %S but %S is already UP",
               picb->pwszName, picb->pwszName);

        return;
    }

    bRet = FALSE;
    
    do
    {
        dwResult = ProcessPacketFromWanArp(picb);

        if(dwResult isnot NO_ERROR)
        {
            //
            // Demand dial filter rules are to drop this packet
            //

            break;
        }
        
        if ((picb->dwAdminState is IF_ADMIN_STATUS_DOWN) or
            (picb->dwOperationalState is UNREACHABLE))
        {
            Trace3(IF,
                   "HandleConnectionRequest: %S has admin state %d and operational state %d. Failing connection request",
                   picb->pwszName,
                   picb->dwAdminState,
                   picb->dwOperationalState);
            
            break;
        }

#if DBG

        if(picb->dwOperationalState is CONNECTING)
        {
            Trace2(IF,
                   "HandleConnectionRequest: RACE CONDITION %S is connecting. Notifications %d",
                   picb->pwszName,
                   picb->fConnectionFlags);
        }
        
#endif
                
        Trace1(DEMAND, "Calling DIM to connect %S",
               picb->pwszName);
        
        //
        // Call DIM to make the connection. Let go of the ICB lock
        //

        hDim = picb->hDIMHandle;
        
        EXIT_LOCK(ICB_LIST);
        
        dwResult = (ConnectInterface)(hDim,
                                      PID_IP);
        
        ENTER_WRITER(ICB_LIST);
        
        if(dwResult isnot NO_ERROR)
        {
            if(dwResult is PENDING)
            {
                //
                // We dont clear notification flags because there may be a
                // race condition and we may have already gotten
                // InterfaceConnected() from DIM
                //
                        
                Trace1(DEMAND,
                       "HandleConnectionRequest: Conn attempt for %S pending",
                       picb->pwszName);
            }
            else
            {
                break;
            }
        }
        
        //
        // So bRet is TRUE if DIM returned NO_ERROR or PENDING
        //
        
        bRet = TRUE;
        
    }while(FALSE);
    

    if(!bRet)
    {
        nStatus = NotifyWanarpOfFailure(picb);
        
        if((nStatus isnot STATUS_PENDING) and
           (nStatus isnot STATUS_SUCCESS))
        {
            Trace2(ERR,
                   "HandleConnectionRequest: %X for connection failed for %S",
                   nStatus,
                   picb->pwszName);
        }
                        
        //
        // If it was connecting, then the stack has set the 
        // interface context to something other than 0xffffffff. 
        // Hence he wont dial out on that route We need to change 
        // the context in the stack back to invalid so that new
        // packets cause the demand dial 
        //
        
        ChangeAdapterIndexForDodRoutes(picb->dwIfIndex);
        
    }
    else
    {
        picb->dwOperationalState = CONNECTING;
    }
}

VOID
HandleConnectionNotification(
    PICB    picb
    )

/*++

Routine Description:

    Called when WANARP informs us that an interface is connected

Locks:

    None

Arguments:

    None

Return Value:

    None    

--*/

{
    PADAPTER_INFO   pBindNode;

    //
    // Plug in the Adapter info we get from the LINE_UP indication.
    // There is only one address for a WAN interface
    //

    ENTER_WRITER(BINDING_LIST);
   
    picb->bBound            = TRUE; 
    picb->dwNumAddresses    = wnWanarpMsg.dwLocalAddr?1:0;
    
    IpRtAssert(picb->dwIfIndex is wnWanarpMsg.dwAdapterIndex);

    if(picb->dwNumAddresses)
    {
        picb->pibBindings[0].dwAddress  = wnWanarpMsg.dwLocalAddr;
        picb->pibBindings[0].dwMask     = wnWanarpMsg.dwLocalMask;

        IpRtAssert(picb->pibBindings[0].dwMask is 0xFFFFFFFF);
    }
    else
    {
        picb->pibBindings[0].dwAddress  = 0;
        picb->pibBindings[0].dwMask     = 0;
    }
    
    if(picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER)
    {
        picb->dwRemoteAddress   = wnWanarpMsg.dwRemoteAddr;
    }
    else
    {
        picb->dwRemoteAddress   = 0;
    } 

    Trace4(IF,
           "HandleConnNotif: Connection notification for %S. Local %d.%d.%d.%d. Remote %d.%d.%d.%d",
           picb->pwszName,
           PRINT_IPADDR(picb->pibBindings[0].dwAddress),
           PRINT_IPADDR(picb->dwRemoteAddress),
           picb->dwSeqNumber);

    //
    // For wan interfaces we always have a binding struct in the hash
    // table. So retrieve that
    //
    
    pBindNode = GetInterfaceBinding(picb->dwIfIndex);
    
    if(!pBindNode)
    {
        Trace1(ERR,
               "HandleConnNotif: Binding not found for %S",
               picb->pwszName);
        
        IpRtAssert(FALSE);
                
        //
        // Something really bad happened and we didnt have a
        // bind block for the interface
        //
        
        AddBinding(picb);
    }
    else
    {
        //
        // Good a binding was found. Assert that it is ours
        // and then update it
        //
        
        IpRtAssert(pBindNode->dwIfIndex is picb->dwIfIndex);
        IpRtAssert(pBindNode->pInterfaceCB is picb);
       
        pBindNode->bBound           = TRUE; 
        pBindNode->dwNumAddresses   = picb->dwNumAddresses;
        pBindNode->dwRemoteAddress  = picb->dwRemoteAddress ;
        
        //
        // struct copy out the address and mask
        //
        
        pBindNode->rgibBinding[0]   = picb->pibBindings[0];

        //
        // We dont take the IP_ADDR_TABLE lock here because we have the
        // ICB lock. During SNMP get we first take the addr lock then
        // the icb lock. So we cant do the opposite here else we will
        // deadlock. This may cause inconsistent information for one
        // request, but we can live with that
        //

        g_LastUpdateTable[IPADDRCACHE] = 0;

    }
    
    EXIT_LOCK(BINDING_LIST);
    
    if(picb->dwOperationalState is UNREACHABLE)
    {
        //
        // going from unreachable to connecting
        //
        
        WanInterfaceDownToInactive(picb);
    }
    
    if(picb->dwOperationalState isnot CONNECTING)
    {
        //
        // We can get a LinkUp without getting a ConnectionRequest
        // This is the case when a user explicitly brings up a 
        // connection.
        //
        
        picb->dwOperationalState = CONNECTING;
    }
    
    SetNdiswanNotification(picb);
    
    if(HaveAllNotificationsBeenReceived(picb))
    {
        picb->dwOperationalState = CONNECTED ;
        
        WanInterfaceInactiveToUp(picb) ;
    }
}

VOID
HandleDisconnectionNotification(
    PICB    picb
    )

/*++

Routine Description:

    Handles a disconnection notification from WANARP
    If the interface was connected, we make it inactive
    We remove and bindings on the interface. This removal doesnt free the
    bindings, only set the state to unbound
    If the interface was marked for deletion, we go ahead and delete the
    interface
    
Locks:

    None

Arguments:

    None

Return Value:

    None    

--*/

{
    Trace2(IF,
           "HandleDisconnectionNotif: Disconnection notification for %S %d",
           picb->pwszName, picb->dwSeqNumber);
    
    
    if(picb->dwOperationalState is CONNECTED)
    {
        //
        // We would have called InactiveToUp
        //
        
        WanInterfaceUpToInactive(picb,
                                 FALSE);
    }   
    else    
    {
        //
        // We have only set the addresses, clear those out
        //
        
        DeAllocateBindings(picb);
    }
    
    picb->dwOperationalState = DISCONNECTED ;
    
    g_LastUpdateTable[IPADDRCACHE] = 0;
    
    if(IsInterfaceMarkedForDeletion(picb))
    {
        RemoveInterfaceFromLists(picb);

        DeleteSingleInterface(picb);
       
        HeapFree(IPRouterHeap, 0, picb);
    }
    else
    {
        ClearNotificationFlags(picb);
    }
}

DWORD
HandleDialOutLinkUp(
    VOID
    )

/*++

Routine Description:

    Handles the notification from wanarp that we have a new dial out interface

Locks:

    ICB list lock as writer

Arguments:

    None

Return Value:

    NO_ERROR

--*/

{
    DWORD   dwResult;
    PICB    pNewIcb;

    INTERFACE_ROUTE_INFO    rifRoute;

    Trace4(IF,
           "DialOutLinkUp: Connection notification for 0x%x %d.%d.%d.%d/%d.%d.%d.%d %d.%d.%d.%d",
           wnWanarpMsg.dwAdapterIndex,
           PRINT_IPADDR(wnWanarpMsg.dwLocalAddr),
           PRINT_IPADDR(wnWanarpMsg.dwLocalMask),
           PRINT_IPADDR(wnWanarpMsg.dwRemoteAddr));
            
    dwResult =  CreateDialOutInterface(wnWanarpMsg.rgwcName,
                                       wnWanarpMsg.dwAdapterIndex,
                                       wnWanarpMsg.dwLocalAddr,
                                       wnWanarpMsg.dwLocalMask,
                                       wnWanarpMsg.dwRemoteAddr,
                                       &pNewIcb);

    if(dwResult isnot NO_ERROR)
    {
        return dwResult;
    }

    AddAutomaticRoutes(pNewIcb,
                       wnWanarpMsg.dwLocalAddr,
                       wnWanarpMsg.dwLocalMask);

#if 0
    //
    // Add the route to the server
    //

    if(pNewIcb->dwRemoteAddress isnot INVALID_IP_ADDRESS)
    {
        rifRoute.dwRtInfoMask          = HOST_ROUTE_MASK;
        rifRoute.dwRtInfoNextHop       = pNewIcb->dwRemoteAddress;
        rifRoute.dwRtInfoDest          = pNewIcb->dwRemoteAddress;
        rifRoute.dwRtInfoIfIndex       = pNewIcb->dwIfIndex;
        rifRoute.dwRtInfoMetric1       = 1;
        rifRoute.dwRtInfoMetric2       = 0;
        rifRoute.dwRtInfoMetric3       = 0;
        rifRoute.dwRtInfoPreference    = 
            ComputeRouteMetric(MIB_IPPROTO_NETMGMT);
        rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                          RTM_VIEW_MASK_MCAST; // XXX config
        rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
        rifRoute.dwRtInfoProto         = MIB_IPPROTO_NETMGMT;
        rifRoute.dwRtInfoAge           = 0;
        rifRoute.dwRtInfoNextHopAS     = 0;
        rifRoute.dwRtInfoPolicy        = 0;

        dwResult = AddSingleRoute(pNewIcb->dwIfIndex,
                                  &rifRoute,
                                  pNewIcb->pibBindings[0].dwMask,
                                  0,        // RTM_ROUTE_INFO::Flags
                                  TRUE,     // Valid route
                                  TRUE,
                                  TRUE,
                                  NULL);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "HandleDialOutLinkUp: Couldnt add server route for 0x%x",
                   pNewIcb->dwIfIndex);
        }
    }

    if(wnWanarpMsg.fDefaultRoute)
    {
        INTERFACE_ROUTE_INFO    rifRoute;

        ChangeDefaultRouteMetrics(TRUE);

        pNewIcb->bChangedMetrics = TRUE;

        //
        // Add route to def gateway
        //

        rifRoute.dwRtInfoDest          = 0;
        rifRoute.dwRtInfoMask          = 0;
        rifRoute.dwRtInfoNextHop       = wnWanarpMsg.dwLocalAddr;
        rifRoute.dwRtInfoIfIndex       = wnWanarpMsg.dwAdapterIndex;
        rifRoute.dwRtInfoMetric1       = 1;
        rifRoute.dwRtInfoMetric2       = 0;
        rifRoute.dwRtInfoMetric3       = 0;
        rifRoute.dwRtInfoPreference    = 
            ComputeRouteMetric(PROTO_IP_LOCAL);
        rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                          RTM_VIEW_MASK_MCAST; // XXX config

        rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
        rifRoute.dwRtInfoProto         = PROTO_IP_NETMGMT;
        rifRoute.dwRtInfoAge           = INFINITE;
        rifRoute.dwRtInfoNextHopAS     = 0;
        rifRoute.dwRtInfoPolicy        = 0;

        dwResult = AddSingleRoute(wnWanarpMsg.dwAdapterIndex,
                                  &rifRoute,
                                  ALL_ONES_MASK,
                                  0,        // RTM_ROUTE_INFO::Flags
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  NULL);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "HandleDialOutLinkUp: Couldnt add default route for 0x%x",
                   wnWanarpMsg.dwAdapterIndex);
        }
    }
    else
    {
        DWORD   dwAddr, dwMask;

        dwMask  = GetClassMask(wnWanarpMsg.dwLocalAddr);
        dwAddr  = wnWanarpMsg.dwLocalAddr & dwMask;

        //
        // Add route to class subnet
        //

        rifRoute.dwRtInfoDest          = dwAddr;
        rifRoute.dwRtInfoMask          = dwMask;
        rifRoute.dwRtInfoNextHop       = wnWanarpMsg.dwLocalAddr;
        rifRoute.dwRtInfoIfIndex       = wnWanarpMsg.dwAdapterIndex;
        rifRoute.dwRtInfoMetric1       = 1;
        rifRoute.dwRtInfoMetric2       = 0;
        rifRoute.dwRtInfoMetric3       = 0;
        rifRoute.dwRtInfoPreference    = ComputeRouteMetric(PROTO_IP_LOCAL);
        rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                          RTM_VIEW_MASK_MCAST; // XXX config
        rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
        rifRoute.dwRtInfoProto         = PROTO_IP_LOCAL;
        rifRoute.dwRtInfoAge           = INFINITE;
        rifRoute.dwRtInfoNextHopAS     = 0;
        rifRoute.dwRtInfoPolicy        = 0;

        dwResult = AddSingleRoute(wnWanarpMsg.dwAdapterIndex,
                                  &rifRoute,
                                  ALL_ONES_MASK,
                                  0,        // RTM_ROUTE_INFO::Flags
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  NULL);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "HandleDialOutLinkUp: Couldnt add subnet route for 0x%x",
                   wnWanarpMsg.dwAdapterIndex);
        }
    }
#endif

    return NO_ERROR;
}

DWORD
CreateDialOutInterface(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwIfIndex,
    IN  DWORD   dwLocalAddr,
    IN  DWORD   dwLocalMask,
    IN  DWORD   dwRemoteAddr,
    OUT ICB     **ppIcb
    )

/*++

Routine Description:

    Creates an ICB for a dial out interface
    We check to see that the interface doesnt already exist and if so, we
    add the interface to our list using the index and name supplied by
    wanarp.

Locks:

    ICB list lock as writer

Arguments:


Return Value:

    NO_ERROR

--*/

{
    PICB            pNewIcb;
    PADAPTER_INFO   pBindNode;
    PICB_BINDING    pBinding;

#if DBG

    pNewIcb = InterfaceLookupByIfIndex(dwIfIndex);

    IpRtAssert(pNewIcb is NULL);

#endif // DBG

    pNewIcb = CreateIcb(pwszIfName,
                        NULL,
                        ROUTER_IF_TYPE_DIALOUT,
                        IF_ADMIN_STATUS_UP,
                        dwIfIndex);

    if(pNewIcb is NULL)
    {
        *ppIcb = NULL;

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Set up the bindings
    //

    pNewIcb->bBound            = TRUE;
    pNewIcb->dwNumAddresses    = dwLocalAddr ? 1 : 0;

    pNewIcb->dwRemoteAddress   = dwRemoteAddr;

    IpRtAssert(pNewIcb->dwIfIndex is dwIfIndex);

    if(pNewIcb->dwNumAddresses)
    {
        pNewIcb->pibBindings[0].dwAddress  = dwLocalAddr;
        pNewIcb->pibBindings[0].dwMask     = dwLocalMask;
    }
    else
    {
        pNewIcb->pibBindings[0].dwAddress  = 0;
        pNewIcb->pibBindings[0].dwMask     = 0;
    }

    ENTER_WRITER(BINDING_LIST);

    pBindNode = GetInterfaceBinding(pNewIcb->dwIfIndex);

    if(pBindNode is NULL)
    {
        IpRtAssert(FALSE);

        AddBinding(pNewIcb);
    }
    else
    {
        IpRtAssert(pBindNode->dwIfIndex is pNewIcb->dwIfIndex);
        IpRtAssert(pBindNode->pInterfaceCB is pNewIcb);

        pBindNode->bBound           = TRUE;
        pBindNode->dwNumAddresses   = pNewIcb->dwNumAddresses;
        pBindNode->dwRemoteAddress  = pNewIcb->dwRemoteAddress;

        //
        // struct copy out the address and mask
        //

        pBindNode->rgibBinding[0]   = pNewIcb->pibBindings[0];
    }

    EXIT_LOCK(BINDING_LIST);

    //
    // Insert pNewIcb in interface list and hash table
    // This increments the interface count and sets the seq number
    //

    InsertInterfaceInLists(pNewIcb);

    *ppIcb = pNewIcb;

    //
    // Update the address cache
    //

    g_LastUpdateTable[IPADDRCACHE] = 0;

    return NO_ERROR;
}

DWORD
HandleDialOutLinkDown(
    VOID
    )

/*++

Routine Description:

    Handles the linkdown notification for a dial out interface.

Locks:

    ICB list lock as writer

Arguments:

    None

Return Value:

    NO_ERROR

--*/

{
    PICB    pIcb;

    Trace1(IF,
           "DialOutLinkDown: Disconnection notification for %d",
           wnWanarpMsg.dwAdapterIndex);
            
    pIcb = InterfaceLookupByIfIndex(wnWanarpMsg.dwAdapterIndex);

    if(pIcb is NULL)
    {
        IpRtAssert(FALSE);

        return NO_ERROR;
    }

    RemoveInterfaceFromLists(pIcb);

    //
    // This will delete the default route if there was one
    //

    DeleteSingleInterface(pIcb);

    if(pIcb->bChangedMetrics)
    {
        ChangeDefaultRouteMetrics(FALSE);
    }

    HeapFree(IPRouterHeap,
             0,
             pIcb);

    return NO_ERROR;
}

NTSTATUS
NotifyWanarpOfFailure(
    PICB    picb
    )

/*++

Routine Description:

    Sends an IOCTL_WANARP_CONNECT_FAILED to WANARP

Locks:

    None

Arguments:

    picb    ICB of the interface on whom the connection failed

Return Value:

    None    

--*/

{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;

    WANARP_CONNECT_FAILED_INFO  ConnectInfo;
 
    ConnectInfo.dwUserIfIndex = picb->dwSeqNumber;
 
    Status = NtDeviceIoControlFile(g_hWanarpWrite,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_WANARP_CONNECT_FAILED,
                                   &ConnectInfo,
                                   sizeof(WANARP_CONNECT_FAILED_INFO),
                                   NULL,
                                   0);

    IpRtAssert(Status isnot STATUS_PENDING);

    return Status;
}

DWORD
ProcessPacketFromWanArp(
    PICB    picb
    )

/*++
  
Routine Description:

    Filters the packet which is causing a demand dial connection. If the
    packet is valid, logs the packet

Locks:

    ICB_LIST held as READER

Arguments:

    picb    ICB of interface to dial
    
Return Value:

    NO_ERROR            Dial out
    ERROR_INVALID_DATA  Dont dial out
    
--*/

{
    CHAR    pszSrc[20], pszDest[20], pszProto[5], pszLength[32]; 
    CHAR    pszName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD   dwSize, dwResult;
    BYTE    rgbyPacket[sizeof(IP_HEADER) + MAX_PACKET_COPY_SIZE];
    PBYTE   pbyData;
    
    PFFORWARD_ACTION    faAction; 
    PIP_HEADER          pHeader;
    
    TraceEnter("ProcessPacketFromWanArp");

    //
    // Now create a packet
    //

    dwSize = min(wnWanarpMsg.ulPacketLength,
                 MAX_PACKET_COPY_SIZE);

    if(picb->ihDemandFilterInterface isnot INVALID_HANDLE_VALUE)
    {
        IpRtAssert(picb->pDemandFilter);

        //
        // TCP/IP seems to not give us a packet sometimes
        //

        if(!dwSize)
        {
            Trace3(ERR, 
                   "ProcPktFromWanarp: Packet from %d.%d.%d.%d to %d.%d.%d.%d protocol 0x%02x had 0 size!!",
                   PRINT_IPADDR(wnWanarpMsg.dwPacketSrcAddr),
                   PRINT_IPADDR(wnWanarpMsg.dwPacketDestAddr),
                   wnWanarpMsg.byPacketProtocol); 

            TraceLeave("ProcessPacketFromWanArp");

            return ERROR_INVALID_DATA;
        }

        pHeader = (PIP_HEADER)rgbyPacket;

        //
        // Zero out the header
        //
    
        ZeroMemory(rgbyPacket,
                   sizeof(IP_HEADER));
    
        //
        // Set the header with the info we have
        //
    
        pHeader->byVerLen   = 0x45;
        pHeader->byProtocol = wnWanarpMsg.byPacketProtocol;
        pHeader->dwSrc      = wnWanarpMsg.dwPacketSrcAddr;
        pHeader->dwDest     = wnWanarpMsg.dwPacketDestAddr;
        pHeader->wLength    = htons((WORD)(dwSize + sizeof(IP_HEADER)));
    
        //
        // Copy out the data portion
        //
    
        pbyData = rgbyPacket + sizeof(IP_HEADER);
        
        CopyMemory(pbyData,
                   wnWanarpMsg.rgbyPacket,
                   dwSize);
    
        dwResult = PfTestPacket(picb->ihDemandFilterInterface,
                                NULL,
                                dwSize + sizeof(IP_HEADER),
                                rgbyPacket,
                                &faAction);
    
        //
        // If the call succeeded and the action was drop, no need to process
        // futher
        //
    
        if(dwResult is NO_ERROR)
        {
            if(faAction is PF_ACTION_DROP)
            {
                Trace5(DEMAND,
                       "ProcPktFromWanarp: Result %d action %s for packet from %d.%d.%d.%d to %d.%d.%d.%d protocol 0x%02x",
                       dwResult, faAction == PF_ACTION_DROP? "Drop": "RtInfo",
                       PRINT_IPADDR(wnWanarpMsg.dwPacketSrcAddr),
                       PRINT_IPADDR(wnWanarpMsg.dwPacketDestAddr),
                       wnWanarpMsg.byPacketProtocol); 

                TraceLeave("ProcessPacketFromWanarp");
        
                return ERROR_INVALID_DATA;
            }
        }
        else
        {
            //
            // In case of error we fall through and bring the link up
            //

            Trace4(DEMAND,
                   "ProcPktFromWanarp: Result %d for packet from %d.%d.%d.%d to %d.%d.%d.%d protocol 0x%02x",
                   dwResult,
                   PRINT_IPADDR(wnWanarpMsg.dwPacketSrcAddr),
                   PRINT_IPADDR(wnWanarpMsg.dwPacketDestAddr),
                   wnWanarpMsg.byPacketProtocol); 
        }
    }

    strcpy(pszSrc,
           inet_ntoa(*((PIN_ADDR)(&(wnWanarpMsg.dwPacketSrcAddr)))));
    
    strcpy(pszDest,
           inet_ntoa(*((PIN_ADDR)(&(wnWanarpMsg.dwPacketDestAddr)))));
    
    sprintf(pszProto,"%02x",wnWanarpMsg.byPacketProtocol);
    
    WideCharToMultiByte(CP_ACP,
                        0,
                        picb->pwszName,
                        -1,
                        pszName,
                        MAX_INTERFACE_NAME_LEN,
                        NULL,
                        NULL);
    
    pszName[MAX_INTERFACE_NAME_LEN] = '\0';
    
    sprintf(pszLength,"%d",dwSize);
    
    LogWarnData5(DEMAND_DIAL_PACKET,
                 pszSrc,
                 pszDest,
                 pszProto,
                 pszName,
                 pszLength,
                 dwSize,
                 wnWanarpMsg.rgbyPacket);

    TraceLeave("ProcessPacketFromWanarp");

    return NO_ERROR;
}


DWORD
PostIoctlForDemandDialNotification(
    VOID
    )

/*++
  
Routine Description:

    Posts a notification irp with WANARP.
  
Arguments:

    None

Return Value:

--*/

{
    DWORD   bytesrecvd ;
    DWORD   retcode = NO_ERROR;

    TraceEnter("PostIoctlForDemandDialNotification");

    ZeroMemory(&WANARPOverlapped,
               sizeof (OVERLAPPED));

    WANARPOverlapped.hEvent = g_hDemandDialEvent ;

    if (!DeviceIoControl(g_hWanarpWrite,
                         (DWORD) IOCTL_WANARP_NOTIFICATION,
                         &wnWanarpMsg,
                         sizeof(wnWanarpMsg),
                         &wnWanarpMsg,
                         sizeof(wnWanarpMsg),
                          (LPDWORD) &bytesrecvd,
                          &WANARPOverlapped))
    {
        retcode = GetLastError();
        
        if(retcode isnot ERROR_IO_PENDING)
        {
            Trace1(ERR, 
                   "PostIoctlForDemandDialNotification: Couldnt post irp with WANARP: %d\n",
                   retcode) ;
        }
        else
        {
            Trace0(IF, "PostIoctlForDemandDialNotification: Notification pending in WANARP");

        }
    }

    TraceLeave("PostIoctlForDemandDialNotification");
    
    return retcode ;
}

DWORD
AddInterfaceToWanArp(
    PICB    picb
    )

/*++
  
Routine Description:

    Adds the given interface with WANARP
    Has a side effect of getting an interface index
  
Arguments:

    The ICB of the interface to add

Return Value:

--*/

{
    DWORD               out,dwResult;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            nStatus;
    PADAPTER_INFO       pBindNode;
    
    WANARP_ADD_INTERFACE_INFO   info;

    TraceEnter("AddInterfaceToWanArp");

    Trace1(IF,
           "AddInterfaceToWanArp: Adding %S to WanArp",
           picb->pwszName);
    
    info.dwUserIfIndex  = picb->dwSeqNumber;
    info.dwAdapterIndex = INVALID_IF_INDEX;
    
    if(picb->ritType is ROUTER_IF_TYPE_INTERNAL)
    {
        info.bCallinInterface = TRUE;
             
    }
    else
    {
        info.bCallinInterface = FALSE;
    }
   
    nStatus = NtDeviceIoControlFile(g_hWanarpWrite,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_WANARP_ADD_INTERFACE,
                                    &info,
                                    sizeof(WANARP_ADD_INTERFACE_INFO),
                                    &info,
                                    sizeof(WANARP_ADD_INTERFACE_INFO));
 
    if(nStatus isnot STATUS_SUCCESS) 
    {
        Trace2(ERR,
               "AddInterfaceToWANARP: Status %x adding %S to WanArp",
               nStatus,
               picb->pwszName);

        return RtlNtStatusToDosError(nStatus);
    }

    IpRtAssert(info.dwAdapterIndex isnot 0);
    IpRtAssert(info.dwAdapterIndex isnot INVALID_IF_INDEX);
    
    picb->dwIfIndex = info.dwAdapterIndex;
    
    //
    // If this was the internal interface allocate memory and copy out
    // the name
    //

    if(picb->ritType is ROUTER_IF_TYPE_INTERNAL)
    {
        info.rgwcDeviceName[WANARP_MAX_DEVICE_NAME_LEN] = UNICODE_NULL;
 
        picb->pwszDeviceName =
            HeapAlloc(IPRouterHeap,
                      HEAP_ZERO_MEMORY,
                      (wcslen(info.rgwcDeviceName) + 1) * sizeof(WCHAR));


        if(picb->pwszDeviceName is NULL)
        {
            Trace2(ERR,
                   "AddInterfaceToWANARP: Unable to allocate %d bytes when adding %S to wanarp",
                   (wcslen(info.rgwcDeviceName) + 1) * sizeof(WCHAR),
                   picb->pwszName);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(picb->pwszDeviceName,
               info.rgwcDeviceName);


        Trace2(DEMAND,
               "AddInterfaceToWANARP: %S device name %S\n",
               picb->pwszName,
               picb->pwszDeviceName);

        g_pInternalInterfaceCb = picb;
               
    }

        
    TraceLeave("AddInterfaceToWANARP");
    
    return NO_ERROR;
}

DWORD
DeleteInterfaceWithWanArp(
    PICB  picb
    )

/*++
  
Routine Description:

    Deletes the given interface with WANARP
  
Arguments:

    The ICB of the interface to delete

Return Value:

--*/

{
    DWORD       out,dwResult;
    OVERLAPPED  overlapped ;

    WANARP_DELETE_INTERFACE_INFO    DeleteInfo;

    TraceEnter("DeleteInterfaceWithWANARP");
    
    DeleteInfo.dwUserIfIndex = picb->dwSeqNumber;

    memset (&overlapped, 0, sizeof(OVERLAPPED)) ;

    if (!DeviceIoControl (g_hWanarpWrite,
                          IOCTL_WANARP_DELETE_INTERFACE,
                          &DeleteInfo,
                          sizeof(WANARP_DELETE_INTERFACE_INFO),
                          NULL,
                          0,
                          &out,
                          &overlapped)) 
    {
        dwResult = GetLastError();
        
        Trace2(ERR,
               "DeleteInterfaceWithWANARP: Error %d deleting %S",
               dwResult,
               picb->pwszName);

        return dwResult;
    }

    TraceLeave("DeleteInterfaceWithWANARP");
    
    return NO_ERROR;
}

#if 0

DWORD
CreateInternalInterfaceIcb(
    PWCHAR  pwszName,
    ICB     **ppicb
    )

/*++
  
Routine Description:

    This routine parses the TCPIP Parameters\Interfaces key to figure out 
    the name of the Internal Interface (ServerAdapter). The internal interface 
    has the substring "IPIN"
    
Arguments:

    None

Return Value:

    NO_ERROR
    
--*/

{
    HKEY    hIfKey;
    DWORD   i, dwResult, dwSize, dwNumEntries, dwMaxKeyLen;
    BOOL    bFoundAdapter;
    CHAR    *pbyKeyName, pszServerAdapter[256];
    PICB    pInterfaceCb;

    TraceEnter("CreateInternalInterfaceIcb");

    *ppicb = NULL;

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            REG_KEY_TCPIP_INTERFACES,
                            0,
                            KEY_ALL_ACCESS,
                            &hIfKey);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "CreateInternalIcb: Error %d opening %s\n",
               dwResult,
               REG_KEY_TCPIP_INTERFACES);

        return dwResult;
    }
    
    dwResult = RegQueryInfoKey(hIfKey,
                               NULL,
                               NULL,
                               NULL,
                               &dwNumEntries,
                               &dwMaxKeyLen,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "CreateIpIpInterface: Error %d querying key",
               dwResult);

        return dwResult;
    }

    //
    // Have to have some interfaces
    //

    IpRtAssert(dwNumEntries isnot 0)

    //
    // Allocate enough memory for max key len
    //

    dwSize = (dwMaxKeyLen + 4) * sizeof(CHAR);

    pbyKeyName = HeapAlloc(IPRouterHeap,
                           HEAP_ZERO_MEMORY,
                           dwSize);


    if(pbyKeyName is NULL)
    {
        Trace1(ERR,
               "CreateIpIpInterface: Error allocating %d bytes",
               dwSize);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0; ; i++)
    {
        DWORD       dwKeyLen;
        FILETIME    ftLastTime;
    

        dwKeyLen = dwMaxKeyLen;

        dwResult = RegEnumKeyExA(hIfKey,
                                 i,
                                 pbyKeyName,
                                 &dwKeyLen,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &ftLastTime);

        if(dwResult isnot NO_ERROR)
        {
            if(dwResult is ERROR_NO_MORE_ITEMS)
            {
                //
                // Done
                //

                break;
            }
    
            continue;
        }

        //
        // See if this is the server adapter. That is known by the fact that it contains
        // IPIN as a substring
        //

        //           
        // Upcase the string
        //

        _strupr(pbyKeyName);
        
        if(strstr(pbyKeyName,SERVER_ADAPTER_SUBSTRING) is NULL)
        {
            //
            // This is not the server adapter
            //

            continue;
        }
        
        //
        // Well we have a server adapter
        //
        
        ZeroMemory(pszServerAdapter,256);

        strcpy(pszServerAdapter,"\\DEVICE\\");
            
        strcat(pszServerAdapter,pbyKeyName);

        Trace1(IF,
               "InitInternalInterface: Using %s as the dial in adapter",
               pszServerAdapter);
        
        bFoundAdapter = TRUE;
        
        break;
    }

    HeapFree(IPRouterHeap,
             0,
             pbyKeyName);

    RegCloseKey(hIfKey); 

    if(!bFoundAdapter)
    {
        return ERROR_NOT_FOUND;
    }
    else
    {
        WCHAR           pwszTempName[256];
        DWORD           dwICBSize, dwNameLen;
        UNICODE_STRING  usTempString,usIcbName;

        usTempString.MaximumLength      = 256 * sizeof(WCHAR);
        usTempString.Buffer             = pwszTempName;
        usIcbName.MaximumLength         = 256 * sizeof(WCHAR);

        //
        // Only copy out the name and not the \Device\ part
        //

        MultiByteToWideChar(CP_ACP,
                            0,
                            pszServerAdapter + strlen(ADAPTER_PREFIX_STRING),
                            -1,
                            pwszTempName,
                            256);
      
        //
        // Add a WCHAR each for UNICODE_NULL for name and device name
        // Add 2 bytes for alignment issues
        //

        dwNameLen = 
            (sizeof(WCHAR) * (wcslen(pwszName) + wcslen(pwszTempName) + 2)) + 2;

        dwICBSize = sizeof(ICB) + dwNameLen;

        pInterfaceCb = (PICB)HeapAlloc(IPRouterHeap,
                                       HEAP_ZERO_MEMORY,
                                       dwICBSize);

        if(pInterfaceCb is NULL)
        {
            Trace1(ERR,
                   "InitInternalInterface: Error allocating %d bytes for ICB",
                   dwICBSize);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        // 
        // Save the DIM name in the pwszName field
        //

        pInterfaceCb->pwszName  = (PWCHAR) ((PBYTE)pInterfaceCb + sizeof(ICB));
       
        //
        // Word align the pointer
        //

        pInterfaceCb->pwszName = 
            (PWCHAR)(((UINT_PTR)pInterfaceCb->pwszName + 1) & ~0x1);

        CopyMemory(pInterfaceCb->pwszName,
                   pwszName,
                   wcslen(pwszName) * sizeof(WCHAR));

        //
        // 1 WCHAR for UNICODE_NULL and 1 byte for alignment
        //

        pInterfaceCb->pwszDeviceName = 
            (PWCHAR)((PBYTE)pInterfaceCb->pwszName +  
                     ((wcslen(pwszName) + 1) * sizeof(WCHAR)) + 1);

        //
        // And align this, too
        //

        pInterfaceCb->pwszDeviceName = 
            (PWCHAR)(((UINT_PTR)pInterfaceCb->pwszDeviceName + 1) & ~0x1);
        
            
        usTempString.Length = sizeof(WCHAR) * wcslen(pwszTempName);
        usIcbName.Buffer    = pInterfaceCb->pwszDeviceName;

        RtlUpcaseUnicodeString(&usIcbName,
                               &usTempString,
                               FALSE);

        pInterfaceCb->pwszDeviceName[wcslen(pwszTempName)] = UNICODE_NULL;

        *ppicb = pInterfaceCb;
    }
   
    TraceLeave("CreateInternalInterfaceIcb");

    
    return NO_ERROR;
}

#endif

DWORD
AccessIfEntryWanArp(
    IN      DWORD dwAction,
    IN      PICB  picb,
    IN OUT  PMIB_IFROW lpOutBuf
    )

/*++
  
Routine Description:

    Gets or sets the statistics from the wanarp

Arguments:

    dwAction   Can be SET_IF or GET_IF
    picb       the Interface Control Block
    pOutBuf

Return Value:

    NO_ERROR or some error code
    
--*/

{
    NTSTATUS                    Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK             IoStatusBlock;
    WANARP_GET_IF_STATS_INFO    GetStatsInfo;

    
    TraceEnter("AccessIfEntryWanArp");
   
    GetStatsInfo.dwUserIfIndex = picb->dwSeqNumber;

    if(dwAction is ACCESS_GET)
    {
        Status = NtDeviceIoControlFile(g_hWanarpRead,
                                       NULL,
                                       NULL,    
                                       NULL,        
                                       &IoStatusBlock,
                                       IOCTL_WANARP_GET_IF_STATS,
                                       &GetStatsInfo,
                                       sizeof(WANARP_GET_IF_STATS_INFO),
                                       &GetStatsInfo,
                                       sizeof(WANARP_GET_IF_STATS_INFO));

        RtlCopyMemory(&(lpOutBuf->dwIndex),
                      &(GetStatsInfo.ifeInfo),
                      sizeof(IFEntry));
        
    }
    else
    {
        // To be implemented: return SUCCESS for now
    }
    
    if(Status isnot STATUS_SUCCESS)
    {
        IpRtAssert(Status isnot STATUS_PENDING);

        Trace2(ERR,
               "AccessIfEntryWanArp: NtStatus %x when getting information for %S",
               Status,
               picb->pwszName);

        TraceLeave("AccessIfEntryWanArp");

        return Status;
    }   

    TraceLeave("AccessIfEntryWanArp");

    return NO_ERROR;
}

DWORD
DeleteInternalInterface(
    VOID
    )

/*++
  
Routine Description:

    Deletes the ServerAdapter (internal) interface
  
Locks: 


Arguments:
      

Return Value:

    NO_ERROR

--*/

{

    if(g_pInternalInterfaceCb is NULL)
    {
        return NO_ERROR;
    }

    if(g_pInternalInterfaceCb->pwszDeviceName isnot NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 g_pInternalInterfaceCb->pwszDeviceName);

        g_pInternalInterfaceCb->pwszDeviceName = NULL;
    }

    //
    // Call DeleteSingleInterface to do the same thing as is done
    // for LAN interfaces
    //

    DeleteSingleInterface(g_pInternalInterfaceCb);

    RemoveInterfaceLookup(g_pInternalInterfaceCb);
    
    HeapFree(IPRouterHeap,
             0,
             g_pInternalInterfaceCb);


    g_pInternalInterfaceCb = NULL;

    return NO_ERROR;
}


DWORD
AddDemandFilterInterface(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    )

/*++

Routine Description:

    Adds an interface to the filter driver. This interface is never bound to
    an IP interface, instead we add demand dial filters to it and when a
    request is made to dial out, we match the packet causing the dialling
    against the filters (using the TestPacket() function) and use the returned
    action to determine whether we should dial out or not.
    
    If there are no filters, the interface is not added to the driver.
    Otherwise, a copy of the filters is kept with the picb, and a transformed
    set of filters is added to the driver
    The handle associated with the interface and the driver is kept in the
    picb
    
Arguments:

    picb
    pInterfaceInfo
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                   dwResult;
    PPF_FILTER_DESCRIPTOR   pfdFilters;
    PFFORWARD_ACTION        faAction;
    PRTR_TOC_ENTRY          pToc;
    PFILTER_DESCRIPTOR      pInfo;
    ULONG                   i, j, ulSize, ulNumFilters;
    
    TraceEnter("AddDemandFilterInterface");

    IpRtAssert((picb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
               (picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER));
    
    IpRtAssert(picb->pDemandFilter is NULL);
    
    picb->ihDemandFilterInterface = INVALID_HANDLE_VALUE;

    pToc  = GetPointerToTocEntry(IP_DEMAND_DIAL_FILTER_INFO,
                                 pInterfaceInfo);
  
    //
    // We dont add if there is no INFO, or if the info size is 0 or
    // if the number of filters is 0 AND the default action is DROP
    //
 
    if((pToc is NULL) or (pToc->InfoSize is 0))
    {
        //
        // Either there is no filter info (TOC is NULL) or the user
        // wanted the filters deleted (which they have been)
        //
        
        Trace1(IF,
               "AddDemandFilterInterface: filter info NULL or info size 0 for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("AddDemandFilterInterface");

        return NO_ERROR;
    }
    
    pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                pToc);

    if(pInfo is NULL)
    {
        Trace1(IF,
               "AddDemandFilterInterface: filter info NULL for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("AddDemandFilterInterface");

        return NO_ERROR;
    }

    
    //
    // See how many filters we have
    //
    
    pfdFilters  = NULL;

    ulNumFilters = pInfo->dwNumFilters;

    if((ulNumFilters is 0) and
       (pInfo->faDefaultAction is PF_ACTION_FORWARD))
    {
        Trace1(IF,
               "AddDemandFilterInterface: 0 filters and default of FORWARD for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("AddDemandFilterInterface");

        return NO_ERROR;
    }

    //
    // The size we need for these many filters
    //
        
    ulSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
             (ulNumFilters * sizeof(FILTER_INFO));

    //
    // The infosize must be atleast as large as the filters
    //
        
    IpRtAssert(ulSize <= pToc->InfoSize);
    
    //
    // Copy out the info for ourselves
    //
    
    picb->pDemandFilter = HeapAlloc(IPRouterHeap,
                                    0,
                                    ulSize);
        
    if(picb->pDemandFilter is NULL)
    {
        Trace1(ERR,
               "AddDemandFilterInterface: Error allocating %d bytes for demand dial filters",
               ulSize);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(picb->pDemandFilter,
               pInfo,
               ulSize);
        
    faAction = pInfo->faDefaultAction;
    
    if(ulNumFilters isnot 0)
    {
        PDWORD  pdwAddr;

        //
        // We have filters, so copy them to the new format
        // The address and mask will come at the end of all of the filters
        // so we allocate 16 bytes extra for each filter. Then we add a
        // 8 bytes so that we can align the block
        //
            

        ulSize = ulNumFilters * (sizeof(PF_FILTER_DESCRIPTOR) + 16) + 8;
        
        
        pfdFilters = HeapAlloc(IPRouterHeap,
                               0,
                               ulSize);
            
        if(pfdFilters is NULL)
        {
            HeapFree(IPRouterHeap,
                     0,
                     picb->pDemandFilter);
            
            Trace1(ERR,
                   "AddDemandFilterInterface: Error allocating %d bytes",
                   ulSize);
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
            
        //
        // Pointer to the start of the address block
        //
        
        pdwAddr = (PDWORD)&(pfdFilters[ulNumFilters]);
        
        //
        // Now convert the filters
        //
        
        for(i = 0, j = 0; i < ulNumFilters; i++)
        {
            pfdFilters[i].dwFilterFlags = 0;
            pfdFilters[i].dwRule        = 0;
            pfdFilters[i].pfatType      = PF_IPV4;

            //
            // Set the pointers
            //
            
            pfdFilters[i].SrcAddr = (PBYTE)&(pdwAddr[j++]);
            pfdFilters[i].SrcMask = (PBYTE)&(pdwAddr[j++]);
            pfdFilters[i].DstAddr = (PBYTE)&(pdwAddr[j++]);
            pfdFilters[i].DstMask = (PBYTE)&(pdwAddr[j++]);
            
            //
            // Copy in the src/dst addr/masks
            //
            
            *(PDWORD)pfdFilters[i].SrcAddr = pInfo->fiFilter[i].dwSrcAddr;
            *(PDWORD)pfdFilters[i].SrcMask = pInfo->fiFilter[i].dwSrcMask;
            *(PDWORD)pfdFilters[i].DstAddr = pInfo->fiFilter[i].dwDstAddr;
            *(PDWORD)pfdFilters[i].DstMask = pInfo->fiFilter[i].dwDstMask;
            
            //
            // Copy the protocol
            //
            
            pfdFilters[i].dwProtocol = pInfo->fiFilter[i].dwProtocol;

            //
            // Late bound makes no sense for this
            //
            
            pfdFilters[i].fLateBound = 0;

            //
            // The ports
            //
            
            pfdFilters[i].wSrcPort  = pInfo->fiFilter[i].wSrcPort;
            pfdFilters[i].wDstPort  = pInfo->fiFilter[i].wDstPort;
            
            //
            // Since we dont support ranges, set to 0
            //
            
            pfdFilters[i].wSrcPortHighRange = 0;
            pfdFilters[i].wDstPortHighRange = 0;
        }   
    }


    //
    // Now add create the interace and set the info
    //

    dwResult = PfCreateInterface(0,
                                 faAction,
                                 PF_ACTION_FORWARD,
                                 FALSE,
                                 FALSE,
                                 &(picb->ihDemandFilterInterface));

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "AddDemandFilterInterface: Err %d creating filter i/f for %S",
               dwResult,
               picb->pwszName);
    }
    else
    {
        //
        // Set the filters
        //

        if(ulNumFilters isnot 0)
        {
            dwResult = PfAddFiltersToInterface(picb->ihDemandFilterInterface,
                                               ulNumFilters,
                                               pfdFilters,
                                               0,
                                               NULL,
                                               NULL);
        
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "AddDemandFilterInterface: Err %d setting filters on %S",
                       dwResult,
                       picb->pwszName);

                PfDeleteInterface(picb->ihDemandFilterInterface);
            }
        }
    }

    if(pfdFilters)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pfdFilters);
    }   

    if(dwResult isnot NO_ERROR)
    {
        //
        // Something bad happened. Set the handles to invalid so that
        // we know we did not add the filters
        //

        picb->ihDemandFilterInterface = INVALID_HANDLE_VALUE;
        
        if(picb->pDemandFilter)
        {
            HeapFree(IPRouterHeap,
                     0,
                     picb->pDemandFilter);

            picb->pDemandFilter = NULL;
        }
    }

    TraceLeave("SetInterfaceFilterInfo");
        
    return dwResult;
}

     
DWORD
DeleteDemandFilterInterface(
    PICB picb
    )

/*++

Routine Description:

    This function deletes a filter interface (and all associated filters)
    Also frees the memory holding the filters

Locks:

    ICB_LIST held as WRITER

Arguments:

    None

Return Value:

    None    

--*/

{
    TraceEnter("DeleteDemandFilterInterface");

    IpRtAssert((picb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
               (picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER));
    
    if(picb->pDemandFilter isnot NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 picb->pDemandFilter);
        
        picb->pDemandFilter = NULL;
    }

    if(picb->ihDemandFilterInterface is INVALID_HANDLE_VALUE)
    {
        Trace1(IF,
               "DeleteDemandFilterInterface: No context, assuming interface %S not added to filter driver",
               picb->pwszName);
    
        return NO_ERROR;
    }

    PfDeleteInterface(picb->ihDemandFilterInterface);
    
    picb->ihDemandFilterInterface  = INVALID_HANDLE_VALUE;

    TraceLeave("DeleteDemandFilterInterface");
    
    return NO_ERROR;
}

DWORD
SetDemandDialFilters(
    PICB                     picb, 
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    )
{
    DWORD           dwResult;
    PRTR_TOC_ENTRY  pToc;
    
    if((picb->ritType isnot ROUTER_IF_TYPE_HOME_ROUTER) and
       (picb->ritType isnot ROUTER_IF_TYPE_FULL_ROUTER))
    {
        return NO_ERROR;
    }
    
    TraceEnter("SetDemandDialFilters");

    pToc  = GetPointerToTocEntry(IP_DEMAND_DIAL_FILTER_INFO,
                                 pInterfaceInfo);

    if(pToc is NULL)
    {
        //
        // Both NULL, means we dont need to change anything
        //
        
        Trace1(DEMAND,
               "SetDemandDialFilters: No filters for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("SetDemandDialFilters");

        return NO_ERROR;
    }

    if(picb->ihDemandFilterInterface isnot INVALID_HANDLE_VALUE)
    {
        //
        // This interface was added to the filter driver,
        // Delete it so that the filters are all deleted and then readd
        // the filters
        //

        IpRtAssert(picb->pDemandFilter isnot NULL);

        dwResult = DeleteDemandFilterInterface(picb);

        //
        // This better succeed, we dont have a failure path here
        //
        
        IpRtAssert(dwResult is NO_ERROR);
        
    }

    dwResult = AddDemandFilterInterface(picb,
                                        pInterfaceInfo);

    if(dwResult isnot NO_ERROR)
    {
        CHAR   Name[MAX_INTERFACE_NAME_LEN + 1];
        PCHAR  pszName;

        pszName = Name;

        WideCharToMultiByte(CP_ACP,
                            0,
                            picb->pwszName,
                            -1,
                            pszName,
                            MAX_INTERFACE_NAME_LEN,
                            NULL,
                            NULL);

        LogErr1(CANT_ADD_DD_FILTERS,
                pszName,
                dwResult);
    }

    TraceLeave("SetDemandDialFilters");
        
    return dwResult;
}

DWORD
GetDemandFilters(
    PICB                      picb, 
    PRTR_TOC_ENTRY            pToc, 
    PBYTE                     pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    )

/*++

Routine Description:

    This function copies out the demand dial filters and set the TOC

Locks:

    ICB_LIST lock held as READER

Arguments:

    None

Return Value:

    None    

--*/

{
    DWORD                       dwInBufLen,i;
    PFILTER_DESCRIPTOR          pFilterDesc;
    
    TraceEnter("GetDemandFilters");
   
    IpRtAssert((picb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
               (picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER));
    
    //
    // Set size returned to 0
    //
    
    *pdwSize = 0;

    //
    // Safe init of both the TOCs. 
    //
    
    //pToc[0].InfoVersion = IP_DEMAND_DIAL_FILTER_INFO;
    pToc[0].InfoType    = IP_DEMAND_DIAL_FILTER_INFO;
    pToc[0].Count       = 0;
    pToc[0].InfoSize    = 0;
    
    if((picb->ihDemandFilterInterface is INVALID_HANDLE_VALUE) or
       (picb->pDemandFilter is NULL))
    {
        Trace1(IF,
               "GetDemandFilters: No context or no filters for %S",
               picb->pwszName);
        
        return ERROR_NO_DATA;
    }

    //
    // Set the offset in the TOC
    //
    
    pToc[0].Offset   = (ULONG) (pbDataPtr - (PBYTE)pInfoHdrAndBuffer);
    pToc[0].Count    = 1;
    pToc[0].InfoSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                       (picb->pDemandFilter->dwNumFilters * sizeof(FILTER_INFO));
    //pToc[0].Version  = IPRTR_INFO_VERSION_5;
   
    //
    // Just copy out the filters
    //
    
    CopyMemory(pbDataPtr,
               picb->pDemandFilter,
               pToc[0].InfoSize);

    //
    // The size copied in
    //
    
    *pdwSize = pToc[0].InfoSize;
        
    TraceLeave("GetDemandFilters");
        
    return NO_ERROR;
}

VOID
TryUpdateInternalInterface(
    VOID
    )

/*++

Routine Description:

    This function is called when a client dials in and we have not
    bound the internal interface
    The way of doing this is as follows:
    If the server adapter is not initialized, read the address from the
    registry. If we read the address, all is good, break out and move on
    If no address was found, wait on the DHCP event with a time out
    If someone configures the server adapter in the meantime, we will get
    the DHCP event, if we miss the event (since it is PULSED), we will
    timeout and we loop back and retry the steps above.
    Now we do this N times. If we fail, then we just wait for the next
    client to dial in

Locks:

    ICB_LIST held as WRITER

Arguments:

    None

Return Value:

    None    

--*/

{
    DWORD dwResult, dwInitCount;

    TraceEnter("TryUpdateInternalInterface");

    dwInitCount = 0;
     
    //
    // This is only called when the server is not initialized
    //

    IpRtAssert(g_bUninitServer);
 
    while(g_bUninitServer)
    {
        Trace0(ERR,
               "TryUpdateInternalInterface: Server adapter not init");
        
        dwResult = UpdateBindingInformation(g_pInternalInterfaceCb);
        
        if(dwResult isnot NO_ERROR)
        {
            if((dwResult is ERROR_ADDRESS_ALREADY_ASSOCIATED) and
               (g_pInternalInterfaceCb->bBound is TRUE)) 
            {
                //
                // This means that the worker thread found an address
                //
               
                IpRtAssert(g_pInternalInterfaceCb->dwNumAddresses is 1);
 
                Trace1(IF,
                       "TryUpdateInternalInterface: Address already present for %S",
                       g_pInternalInterfaceCb->pwszName);
                
                g_bUninitServer = FALSE;
                
                break;
            }
            else
            {
                Trace2(ERR,
                       "TryUpdateInternalInterface: Err %d trying to update binding for %S",
                       dwResult,
                       g_pInternalInterfaceCb->pwszName);
            }   
            
            dwInitCount++;
            
            if(dwInitCount >= MAX_SERVER_INIT_TRIES)
            {
                //
                // We try x times and then give up. Next client around
                // things should work
                //
                
                break;
            }
            else
            {
                Sleep(SERVER_INIT_SLEEP_TIME);
            }
        }
        else
        {
            g_bUninitServer = FALSE;
        }
    }

    //
    // If we broke out because the interface was initialized, bring it up
    //

    if(!g_bUninitServer)
    {
        dwResult = LanEtcInterfaceDownToUp(g_pInternalInterfaceCb,
                                           FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "TryUpdateInternalInterface: Error %d bringing up server if",
                   dwResult);
        }
    }

    TraceLeave("TryUpdateInternalInterface");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\exdeclar.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\exdeclar.h

Abstract:

       This file contains the data definitions used by IP Router Manager
                	    

Revision History:

    Amritansh Raghav          7/8/95  Created

--*/

#ifndef __EXDECLAR_H__
#define __EXDECLAR_H__

//
// This table holds the timeout values for all the caches. Currently they are 
// #defined
//

DWORD g_TimeoutTable[NUM_CACHE] =   {
                                        IPADDRCACHE_TIMEOUT,
                                        IPFORWARDCACHE_TIMEOUT, 
                                        IPNETCACHE_TIMEOUT,   
                                        TCPCACHE_TIMEOUT,        
                                        UDPCACHE_TIMEOUT,
                                    };

//
// This table holds pointers to functions that load each of the caches
//

DWORD (*g_LoadFunctionTable[NUM_CACHE])() = {
                                                LoadIpAddrTable,
                                                LoadIpForwardTable,
                                                LoadIpNetTable,
                                                LoadTcpTable,
                                                LoadUdpTable,
                                            };

//
// This table holds the time when each of the cache's were last updated
//
                    
DWORD g_LastUpdateTable[NUM_CACHE];

//
// This is a table of locks around each of the caches and it also hold the 
// ICB_LIST and the PROTOCOL_CB_LIST locks
//

RTL_RESOURCE g_LockTable[NUM_LOCKS];

//
// This table holds the functions that are used to access the MIB variables 
// made visible by IP Router Manager
//

DWORD 
(*g_AccessFunctionTable[NUMBER_OF_EXPORTED_VARIABLES])(
    DWORD               dwQueryType, 
    DWORD               dwInEntrySize,
    PMIB_OPAQUE_QUERY   pInEntry, 
    PDWORD              pOutEntrySize,
    PMIB_OPAQUE_INFO    pOutEntry,
    PBOOL               pbCache
    ) = {
            AccessIfNumber,
            AccessIfTable,
            AccessIfRow,
            AccessIpStats,
            AccessIpAddrTable,
            AccessIpAddrRow,
            AccessIpForwardNumber,
            AccessIpForwardTable, 
            AccessIpForwardRow, 
            AccessIpNetTable, 
            AccessIpNetRow, 
            AccessIcmpStats, 
            AccessTcpStats,
            AccessTcpTable,
            AccessTcpRow,
            AccessUdpStats,
            AccessUdpTable,
            AccessUdpRow,
            AccessMcastMfe,
            AccessMcastMfeStats,
            AccessBestIf,
            AccessBestRoute,
            AccessProxyArp,
            AccessMcastIfStats,
            AccessMcastStats,
            AccessIfStatus,
            AccessMcastBoundary,
            AccessMcastScope,
            AccessDestMatching,
            AccessDestLonger,
            AccessDestShorter,
            AccessRouteMatching,
            AccessRouteLonger,
            AccessRouteShorter,
            AccessSetRouteState,
            AccessMcastMfeStatsEx
        };


#ifdef DEADLOCK_DEBUG

PBYTE   g_pszLockNames[NUM_LOCKS] = {"IP Address Lock",
                                     "IP Forward Lock",
                                     "IP Net Lock",
                                     "TCP Lock",
                                     "UDP Lock",
                                     "ICB List Lock",
                                     "ProtocolCB List Lock",
                                     "Binding List Lock",
                                     "Boundary Table Lock",
                                     "MZAP Timer Lock",
                                     "ZBR List Lock",
                                     "ZLE List Lock",
                                     "ZAM Cache Lock"
                                    };

#endif // DEADLOCK_DEBUG

//
// The following is the time the Router Manager started
//

DWORD  g_dwStartTime;



HANDLE g_hIpDevice;
HANDLE g_hMcastDevice;
HANDLE g_hIpRouteChangeDevice;


//
// These various caches
//

IP_CACHE  g_IpInfo;
TCP_CACHE g_TcpInfo;
UDP_CACHE g_UdpInfo;

//
// Each of the groups have a private heap
//

HANDLE  g_hIfHeap;
HANDLE  g_hIpAddrHeap;
HANDLE  g_hIpForwardHeap;
HANDLE  g_hIpNetHeap;
HANDLE  g_hTcpHeap;
HANDLE  g_hUdpHeap;

PICB    g_pInternalInterfaceCb;
PICB    g_pLoopbackInterfaceCb;

DWORD   g_dwNextICBSeqNumberCounter;

ULONG   g_ulNumBindings;
ULONG   g_ulNumInterfaces;
ULONG   g_ulNumNonClientInterfaces;
    
LIST_ENTRY          g_leStackRoutesToRestore;

SUPPORT_FUNCTIONS       g_sfnDimFunctions;
PICMP_ROUTER_ADVT_MSG   g_pIcmpAdvt;
SOCKADDR_IN             g_sinAllSystemsAddr;
WSABUF                  g_wsabufICMPAdvtBuffer;
WSABUF                  g_wsaIpRcvBuf;

BOOL                    g_bUninitServer;

MCAST_OVERLAPPED    g_rginMcastMsg[NUM_MCAST_IRPS];

IPNotifyData        g_IpNotifyData;
ROUTE_CHANGE_INFO   g_rgIpRouteNotifyOutput[NUM_ROUTE_CHANGE_IRPS];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\filter.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\filter.h

Abstract:

    Function declarations for filter.c

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/


DWORD
AddFilterInterface(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    );

DWORD
SetGlobalFilterOnIf(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    );

DWORD
DeleteFilterInterface(
    PICB picb
    );

DWORD
SetFilterInterfaceInfo(
    PICB                   picb,
    PRTR_INFO_BLOCK_HEADER pInterfaceInfo
    );

DWORD
BindFilterInterface(
    PICB  picb
    );

DWORD
UnbindFilterInterface(
    PICB  picb
    );

DWORD
GetInFilters(
    PICB                      picb,
    PRTR_TOC_ENTRY            pToc,
    PBYTE                     pbDataPtr,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    );

DWORD
GetOutFilters(
    PICB                      picb,
    PRTR_TOC_ENTRY            pToc,
    PBYTE                     pbDataPtr,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    );

DWORD
GetGlobalFilterOnIf(
    PICB                      picb,
    PRTR_TOC_ENTRY            pToc,
    PBYTE                     pbDataPtr,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\demand.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\demand.h

Abstract:

    Header for demand.c

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/


#define REGISTRY_WANARP_LINKAGE     \
    "System\\CurrentControlSet\\Services\\WanArp\\Linkage"

#define REGISTRY_BIND_VALUE_NAME    \
    "Bind"

#define SERVER_ADAPTER_SUBSTRING    \
    "NDISWANIPIN"

#define REGISTRY_ROUTER_SERVICE_KEY \
    "System\\CurrentControlSet\\Services\\Router\\"


DWORD
InitializeWanArp(
    VOID
    );

VOID
CloseWanArp(
    VOID
    );

DWORD
AddInterfaceToWanArp(
    PICB    picb
    );

DWORD
HandleDemandDialEvent(
    VOID
    );

VOID
HandleConnectionRequest(
    PICB    picb
    );

VOID
HandleConnectionNotification(
    PICB    picb
    );

VOID
HandleDisconnectionNotification(
    PICB    picb
    );

DWORD
HandleDialOutLinkUp(
    VOID
    );

DWORD
CreateDialOutInterface(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwIfIndex,
    IN  DWORD   dwLocalAddress,
    IN  DWORD   dwLocalMask,
    IN  DWORD   dwRemoteAddr,
    OUT ICB     **ppIcb
    );

DWORD
HandleDialOutLinkDown(
    VOID
    );

NTSTATUS
NotifyWanarpOfFailure(
    PICB    picb
    );

DWORD
ProcessPacketFromWanArp(
    PICB    picb 
    );

DWORD
PostIoctlForDemandDialNotification(
    VOID
    );

DWORD
DeleteInterfaceWithWanArp(
    PICB  picb
    );

DWORD
DisableInterfaceWithWanArp(
    PICB picb
    );

DWORD
AddDemandFilterInterface(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    );

DWORD
DeleteDemandFilterInterface(
    PICB picb
    );

DWORD
SetDemandDialFilters(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    );

DWORD
GetDemandFilters(
    PICB                      picb,
    PRTR_TOC_ENTRY            pToc,
    PBYTE                     pbDataPtr,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    );

VOID
TryUpdateInternalInterface(
    VOID
    );

DWORD
DeleteInternalInterface(
    VOID
    );

DWORD
AccessIfEntryWanArp(
    IN      DWORD dwAction,
    IN      PICB  picb,
    IN OUT  PMIB_IFROW lpOutBuf
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\disctest.c ===
#include "allinc.h"

static WORD
Compute16BitXSum(
                 IN PVOID pvData,
                 IN DWORD dwNumBytes
                 )
/*++
  Routine Description
  

  Arguments
      

  Return Value
      16 Bit one's complement of the one's complement sum of dwNumBytes starting at pData
--*/
{
    REGISTER PWORD  pwStart;
    REGISTER DWORD  dwNumWords,i;
    REGISTER DWORD  dwSum = 0;
    
    pwStart = (PWORD)pvData;
    
    // 
    // If there are odd numbered bytes, that has to be handled differently
    // However we can never have odd numbered bytes in our case so we optimize.
    //
    

    dwNumWords = dwNumBytes/2;
    
    for(i = 0; i < dwNumWords; i++)
    {
        dwSum += pwStart[i];
        
        if(dwSum & 0x80000000)
        {
            dwSum = (dwSum & 0x0000FFFF) + (dwSum >> 16);
        }
    }
    
    return (WORD)~dwSum;
}

int __cdecl
main()
{
    SOCKET                  Socket;
    DWORD                   dwResult,dwNumBytesSent,dwBytesRead,dwAns,dwAddrLen,dwFlags;
    LONG                    i;
    DWORD                   dwSizeOfHeader;
    BOOL                    bOption;
    SOCKADDR_IN             sinSourceAddr, sinSockAddr;
    WSABUF                  wsaBuf;
    DWORD                   pdwIpAndIcmpBuf[ICMP_RCV_BUFFER_LEN+2];
    PIP_HEADER              pIpHeader;
    PICMP_ROUTER_ADVT_MSG   pIcmpAdvt;
    ICMP_ROUTER_SOL_MSG     icmpSolMsg;
    WORD                    wVersion = MAKEWORD(2,0); //Winsock version 2.0 minimum
    WSADATA                 wsaData;
    struct ip_mreq          imOption;
    
    
    icmpSolMsg.byType = 0x0A;
    icmpSolMsg.byCode = 0x00;
    icmpSolMsg.dwReserved = 0;
    icmpSolMsg.wXSum = 0x0000;
    
    icmpSolMsg.wXSum = Compute16BitXSum((PVOID)&icmpSolMsg,
                                        8);
    
    if(WSAStartup(wVersion,&wsaData) isnot NO_ERROR)
    {
        printf("WSAStartup failed\n");
        exit(1);
    }
    
    Socket = WSASocket(AF_INET,
                       SOCK_RAW,
                       IPPROTO_ICMP,
                       NULL,
                       0,
                       RTR_DISC_SOCKET_FLAGS);
    
    if(Socket is INVALID_SOCKET)
    {
        dwResult = WSAGetLastError();
        
        printf("Couldnt create socket. Error %d\n",
               dwResult);
        
        exit(1);
    }
    
    //
    // Set to SO_REUSEADDR
    //
    
    bOption = TRUE;
    
    if(setsockopt(Socket,
                  SOL_SOCKET,
                  SO_REUSEADDR,
                  (const char FAR*)&bOption,
                  sizeof(BOOL)) is SOCKET_ERROR)
    {
        printf("Couldnt set linger option. Error %d\n",
               WSAGetLastError());
    }
    
    //
    // Bind to the addresses on the interface
    //
    
    sinSourceAddr.sin_family      = AF_INET;
    sinSourceAddr.sin_addr.s_addr = INADDR_ANY;
    sinSourceAddr.sin_port        = 0;
    
    if(bind(Socket,
            (const struct sockaddr FAR*)&sinSourceAddr,
            sizeof(SOCKADDR_IN)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        printf("Couldnt bind. Error %d\n",
               dwResult);
        
        exit(1);
    }
   
#if 0
    //
    // Join the multicast session on ALL_SYSTEMS_MULTICAST
    //

    sinSockAddr.sin_family      = AF_INET;
    sinSockAddr.sin_addr.s_addr = ALL_SYSTEMS_MULTICAST_GROUP;
    sinSockAddr.sin_port        = 0;
        
    if(WSAJoinLeaf(Socket,
                   (const struct sockaddr FAR*)&sinSockAddr,
                   sizeof(SOCKADDR_IN),
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   JL_BOTH) is INVALID_SOCKET)
    {
        dwResult = WSAGetLastError();
            
        printf("Error %d joining ALL_SYSTEMS  multicast group on socket for %s",
               dwResult,
               inet_ntoa(*(PIN_ADDR)&(sinSourceAddr.sin_addr)));
        

            
        closesocket(Socket);

        exit(1);
    }

#endif
    
    if(setsockopt(Socket,
                  IPPROTO_IP, 
                  IP_MULTICAST_IF,
                  (PBYTE)&sinSourceAddr.sin_addr, 
                  sizeof(IN_ADDR)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        printf("Couldnt join multicast group on socket for %s",
               inet_ntoa(*(PIN_ADDR)&(sinSourceAddr.sin_addr)));
        
        exit(1);
    }
    
    imOption.imr_multiaddr.s_addr = ALL_SYSTEMS_MULTICAST_GROUP;
    imOption.imr_interface.s_addr = sinSourceAddr.sin_addr.s_addr;
    
    if(setsockopt(Socket,
                  IPPROTO_IP, 
                  IP_ADD_MEMBERSHIP,
                  (PBYTE)&imOption, 
                  sizeof(imOption)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        printf("Couldnt join multicast group on socket for %s",
               inet_ntoa(*(PIN_ADDR)&(sinSourceAddr.sin_addr)));
        
        exit(1);
    } 

    
    while(TRUE)
    {
        printf("Send Solicitation? (1 - yes, 0 - no) ");

        scanf("%d",&dwAns);
        
        if(!dwAns)
        {
            break;
        }
        
        sinSourceAddr.sin_family      = AF_INET;
        sinSourceAddr.sin_addr.s_addr = ALL_ROUTERS_MULTICAST_GROUP;
        sinSourceAddr.sin_port        = 0;
    
        wsaBuf.buf = (PBYTE)&icmpSolMsg;  
        wsaBuf.len = sizeof(ICMP_ROUTER_SOL_MSG);

        if(WSASendTo(Socket,
                     &wsaBuf,
                     1,
                     &dwNumBytesSent,
                     MSG_DONTROUTE,
                     (const struct sockaddr FAR*)&sinSourceAddr,
                     sizeof(SOCKADDR_IN),
                     NULL,
                     NULL
                     ) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();
            
            printf("WSASendTo failed with %d\n",
                   dwResult);
            break;
        }
        
        while(TRUE)
        {
            dwAddrLen = sizeof(SOCKADDR_IN);
            dwFlags = 0;
            
            pIpHeader  = (PIP_HEADER)pdwIpAndIcmpBuf;
            wsaBuf.buf = (PBYTE)pIpHeader;
            wsaBuf.len = (ICMP_RCV_BUFFER_LEN+2) * sizeof(DWORD);
            
            if(WSARecvFrom(Socket,
                           &wsaBuf,
                           1,
                           &dwBytesRead,
                           &dwFlags,
                           (struct sockaddr FAR*)&sinSourceAddr,
                           &dwAddrLen,
                           NULL,
                           NULL) is SOCKET_ERROR)
            {
                dwResult = WSAGetLastError();
                
                printf("Error %d doing a receive\n",
                       dwResult);
                
                break;
            }
            
            dwSizeOfHeader = ((pIpHeader->byVerLen)&0x0f)<<2;
            
            pIcmpAdvt = (PICMP_ROUTER_ADVT_MSG)(((PBYTE)pIpHeader) + dwSizeOfHeader);
                    
            if(pIcmpAdvt->byType is 0x9)
            {
                for(i = 0; i < MAKELONG(MAKEWORD(pIcmpAdvt->byNumAddrs,0x00),0x0000); i++)
                {
                    printf("Router Address %s \t Preference %d Lifetime %d\n",
                           inet_ntoa(*(PIN_ADDR)&(pIcmpAdvt->iaAdvt[i].dwRtrIpAddr)),
                           ntohl(pIcmpAdvt->iaAdvt[i].lPrefLevel),
                           ntohs(pIcmpAdvt->wLifeTime));
                }
                
                break;
            }
        }
    }  
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\globals.h

Abstract:

    Header for IP Router Manager globals

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#ifndef __GLOBALS_H__
#define __GLOBALS_H__

//
// Interface Control Block (ICB) list.
//

LIST_ENTRY  ICBList ;

//
// Hash lookup for mapping interfaceids to picb
//

LIST_ENTRY  ICBHashLookup[ICB_HASH_TABLE_SIZE];

//
// Hash lookup for mapping ICB sequence number to picb
//

LIST_ENTRY  ICBSeqNumLookup[ICB_HASH_TABLE_SIZE];

//
// Hash lookup for bindings
//

LIST_ENTRY  g_leBindingTable[BINDING_HASH_TABLE_SIZE];


//
// Hash table for interface to adapter mapping
//

//LIST_ENTRY  g_rgleAdapterMapTable[ADAPTER_HASH_TABLE_SIZE];

//
// Routing Protocols list
//

LIST_ENTRY  g_leProtoCbList;

//
// Timer Queue for Router Discovery advts
//

LIST_ENTRY g_leTimerQueueHead;

//
// Trace Handle used for traces/logging
//

DWORD  TraceHandle ;

//
// Handle used for logging events
//

HANDLE g_hLogHandle;

//
// Level of logging 
//

DWORD g_dwLoggingLevel;

//
// Flag indicating if the router is being started in LAN only or 
// LAN and WAN mode.
//

BOOL    RouterRoleLanOnly ;

//
// Handle to the heap used for all allocations
//

HANDLE  IPRouterHeap ;

//
// Info useful in making RTMv2 calls
//

RTM_REGN_PROFILE  g_rtmProfile;

//
// RTM Handle for static/admin routes
//

HANDLE  g_hLocalRoute;
HANDLE  g_hAutoStaticRoute;
HANDLE  g_hStaticRoute;
HANDLE  g_hNonDodRoute;
HANDLE  g_hNetMgmtRoute;

// RTM handle for obtaining notifications

HANDLE  g_hNotification;

//
// RTM handle for obtaining default route notifications
//

HANDLE  g_hDefaultRouteNotification;

//
// Handle to event used for stopping the IP Router
//

HANDLE  g_hStopRouterEvent ;

//
// Handle to event used for demand dial
//

HANDLE  g_hDemandDialEvent ;

//
// Handle to event used for demand dial
//

HANDLE  g_hIpInIpEvent;

//
// Handle to event used for stack change notifications
//

HANDLE  g_hStackChangeEvent;

//
// Handle to event used request forwarding change from worker
//

HANDLE  g_hSetForwardingEvent;

//
// Handle to event used to get notification about forwarding changes
//

HANDLE  g_hForwardingChangeEvent;

//
// Handle to event used by Routing Protocols for notification
//

HANDLE  g_hRoutingProtocolEvent ;

//
// Timer to handle Router discover advts
//

HANDLE g_hRtrDiscTimer;

//
// Timer to handle Ras Server advertisements
//

HANDLE g_hRasAdvTimer;

//
// Timer to handle MZAP advertisements
//

HANDLE g_hMzapTimer;

//
// Event for Winsock2
//

HANDLE g_hRtrDiscSocketEvent;

//
// Event for mrinfo/mtrace services
//

HANDLE g_hMcMiscSocketEvent;
WSABUF g_wsaMcRcvBuf;
BYTE   g_byMcMiscBuffer[1500];


HANDLE g_hMcastEvents[NUM_MCAST_IRPS];

//
// Events for Route Change notifications
//

HANDLE g_hRouteChangeEvents[NUM_ROUTE_CHANGE_IRPS];


//
// Handle to WANARP device
//

HANDLE  g_hWanarpRead;
HANDLE  g_hWanarpWrite;

//
// Count of all routing protocols configured
//

DWORD TotalRoutingProtocols ;

//
// Lock for tracking router usage: this facilitates stop router functionality
//

CRITICAL_SECTION    RouterStateLock ;

//
// Structure keeping the router state
//

IPRouterState         RouterState ;

//
// used for WANARP demand dial mechanism
//

WANARP_NOTIFICATION     wnWanarpMsg;
OVERLAPPED              WANARPOverlapped;

//
// Critical section for the forwarding state data
//

CRITICAL_SECTION        g_csFwdState;

//
// The last request to the worker thread
//

BOOL                    g_bEnableFwdRequest;

//
// The last action by the worker
//

BOOL                    g_bFwdEnabled;

//
// Should we set routes to the stack?
//

BOOL                    g_bSetRoutesToStack;

//
// Flag indicating if NETBT proxy should be enabled
//

BOOL                    g_bEnableNetbtBcastFrowarding;

//
// The NETBT proxy mode prior to starting RRAS
//

DWORD                   g_dwOldNetbtProxyMode;

//
// copy of the support functions Routing Protocols need
//

extern SUPPORT_FUNCTIONS        g_sfnDimFunctions;

//
// Router Discovery stuff
//

extern PICMP_ROUTER_ADVT_MSG    g_pIcmpAdvt;
extern SOCKADDR_IN              g_sinAllSystemsAddr;
extern WSABUF                   g_wsabufICMPAdvtBuffer;
extern WSABUF                   g_wsaIpRcvBuf;

//
// Buffer to hold maximum length IP header and 8 bytes of the ICMP packet
//

DWORD  g_pdwIpAndIcmpBuf[ICMP_RCV_BUFFER_LEN];

PIP_HEADER g_pIpHeader;

//
// externs defined in exdeclar.h
//

//
// The CB for the Internal Interface
//

extern PICB   g_pInternalInterfaceCb;

//
// The CB for the Loopback Interface
//

extern PICB   g_pLoopbackInterfaceCb;

//
// Counter for sequence numbers
//

extern DWORD    g_dwNextICBSeqNumberCounter;

//
// Number of addresses in the system
//

extern ULONG    g_ulNumBindings;
extern ULONG    g_ulNumInterfaces;
extern ULONG    g_ulNumNonClientInterfaces;

extern HANDLE g_hIpDevice;
extern HANDLE g_hMcastDevice;
extern HANDLE g_hIpRouteChangeDevice;

extern BOOL   g_bUninitServer;

extern IP_CACHE  g_IpInfo;
extern TCP_CACHE g_TcpInfo;
extern UDP_CACHE g_UdpInfo;

extern HANDLE   g_hIfHeap;
extern HANDLE   g_hIpAddrHeap;
extern HANDLE   g_hIpForwardHeap;
extern HANDLE   g_hIpNetHeap;
extern HANDLE   g_hTcpHeap;
extern HANDLE   g_hUdpHeap;

LIST_ENTRY          g_leStackRoutesToRestore;

ULONG   g_ulGatewayCount;
ULONG   g_ulGatewayMaxCount;

PGATEWAY_INFO   g_pGateways;


extern HANDLE    g_hMibRtmHandle;

extern DWORD g_TimeoutTable[NUM_CACHE];

extern DWORD (*g_LoadFunctionTable[NUM_CACHE])();

extern DWORD 
(*g_AccessFunctionTable[NUMBER_OF_EXPORTED_VARIABLES])(DWORD dwQueryType, 
                                                       DWORD dwInEntrySize, 
                                                       PMIB_OPAQUE_QUERY lpInEntry, 
                                                       LPDWORD lpOutEntrySize, 
                                                       PMIB_OPAQUE_INFO lpOutEntry,
                                                       LPBOOL lpbCache);

                    
extern DWORD g_LastUpdateTable[NUM_CACHE];
extern DWORD g_dwStartTime;

extern RTL_RESOURCE g_LockTable[NUM_LOCKS];

extern MCAST_OVERLAPPED g_rginMcastMsg[NUM_MCAST_IRPS];

extern IPNotifyData g_IpNotifyData;
extern ROUTE_CHANGE_INFO g_rgIpRouteNotifyOutput[NUM_ROUTE_CHANGE_IRPS];

extern HKEY         g_hIpIpIfKey;

extern HANDLE       g_hMHbeatSocketEvent;

extern HANDLE       g_hMzapSocketEvent;

//
// Entrypoints into DIM
//

DWORD (*ConnectInterface)(IN HANDLE hDIMInterface, IN DWORD dwProtocolId);

DWORD (*DisconnectInterface)(IN HANDLE hDIMInterface, IN DWORD dwProtocolId);

DWORD
(*SaveInterfaceInfo)(
    IN HANDLE hDIMInterface,
    IN DWORD dwProtocolId,
    IN LPVOID pInterfaceInfo,
    IN DWORD cBInterfaceInfoSize
    );

DWORD
(*RestoreInterfaceInfo)(
    IN HANDLE hDIMInterface,
    IN DWORD dwProtocolId,
    IN LPVOID lpInterfaceInfo,
    IN LPDWORD lpcbInterfaceInfoSize
    );


VOID  (*RouterStopped)(IN DWORD dwProtocolId, IN DWORD dwError);


DWORD
(APIENTRY *SaveGlobalInfo)(
            IN      DWORD           dwProtocolId,
            IN      LPVOID          pGlobalInfo,
            IN      DWORD           cbGlobalInfoSize );

VOID
(APIENTRY *EnableInterfaceWithDIM)(
            IN      HANDLE          hDIMInterface,
            IN      DWORD           dwProtocolId,
            IN      BOOL            fEnabled);


//
// Callbacks into MGM
//

PMGM_INDICATE_MFE_DELETION          g_pfnMgmMfeDeleted;
PMGM_NEW_PACKET_INDICATION          g_pfnMgmNewPacket;
PMGM_BLOCK_GROUPS                   g_pfnMgmBlockGroups;
PMGM_UNBLOCK_GROUPS                 g_pfnMgmUnBlockGroups;
PMGM_WRONG_IF_INDICATION            g_pfnMgmWrongIf;


INFO_CB     g_rgicInfoCb[NUM_INFO_CBS];

CHAR    g_rgcLoopbackString[MAXLEN_IFDESCR + 1];
CHAR    g_rgcInternalString[MAXLEN_IFDESCR + 1];
CHAR    g_rgcWanString[MAXLEN_IFDESCR + 1];
CHAR    g_rgcIpIpString[MAXLEN_IFDESCR + 1];

HINSTANCE   g_hOwnModule;

HANDLE      g_hMprConfig;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\filter.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\filter.c

Abstract:
    All filters related code lives here.

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

#include "allinc.h"


DWORD
AddFilterInterface(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    )

/*++

Routine Description

    Adds an interface to the filter driver and sets the filters on the
    interface.
    If there are no filters, the interface is not added to the driver.
    Otherwise, a copy of the filters is kept with the picb, and a transformed
    set of filters is added to the driver
    The handle associated with the interface and the driver is kept in the
    picb
    
Arguments

    picb
    pInterfaceInfo
    
Return Value

    NO_ERROR
    
--*/

{
    DWORD                   dwResult;
    PPF_FILTER_DESCRIPTOR   pfdInFilters, pfdOutFilters;
    PFFORWARD_ACTION        faInAction,faOutAction;
    PRTR_TOC_ENTRY          pInToc, pOutToc;
    ULONG                   i, j, ulSize, ulNumInFilters, ulNumOutFilters;
    PFILTER_DESCRIPTOR      pInfo;
    PDWORD                  pdwAddr;
    BOOL                    bAdd;
    WCHAR                   rgwcName[MAX_INTERFACE_NAME_LEN + 2];
    PWCHAR                  pName;

    TraceEnter("AddFilterInterface");

    //
    // We dont add the following interfaces to the stack
    //
    
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK));

    //
    // There should be no turds lying around
    //
    
    IpRtAssert(picb->pInFilter is NULL);
    IpRtAssert(picb->pOutFilter is NULL);

    //
    // Safe init
    //
    
    picb->ihFilterInterface = INVALID_HANDLE_VALUE;

    //
    // First thing, just add the frag filter. Since we arent added to 
    // the filter driver, all this will do is set the value in the
    // picb
    //

    SetGlobalFilterOnIf(picb,
                        pInterfaceInfo);

    //
    // Get the TOCs for in and out filters
    //
    
    pInToc  = GetPointerToTocEntry(IP_IN_FILTER_INFO,
                                   pInterfaceInfo);

    pOutToc = GetPointerToTocEntry(IP_OUT_FILTER_INFO,
                                   pInterfaceInfo);

  
    //
    // We only add the interface if there is atleast one (input or output)
    // filter infoblock and it has either non zero filters or its default
    // action is DROP
    //
 
    bAdd = FALSE;

    do
    {
        if((pInToc isnot NULL) and 
           (pInToc->InfoSize isnot 0))
        {
            pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                        pInToc);

            if ((pInfo isnot NULL) and
                ((pInfo->dwNumFilters isnot 0) or
                 (pInfo->faDefaultAction is PF_ACTION_DROP)))
            {
                bAdd = TRUE;

                break;
            }
        }


        if((pOutToc isnot NULL) and 
           (pOutToc->InfoSize isnot 0))
        {
            pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                        pOutToc);

            if ((pInfo isnot NULL) and
                ((pInfo->dwNumFilters isnot 0) or
                 (pInfo->faDefaultAction is PF_ACTION_DROP)))
            {
                bAdd = TRUE;

                break;
            }
        }

    }while(FALSE);

    if(!bAdd)
    {
        //
        // Either there is no filter info (both are NULL) or the user
        // wanted the filters deleted (which they have been)
        //
        
        Trace1(IF,
               "AddFilterInterface: Both filters info are NULL or info size 0 for both for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("AddFilterInterface");

        return NO_ERROR;
    }

    //
    // Some more init
    //
    
    faInAction  = PF_ACTION_FORWARD;
    faOutAction = PF_ACTION_FORWARD;

    pfdInFilters  = NULL;
    pfdOutFilters = NULL;
    
    ulNumInFilters  = 0;
    ulNumOutFilters = 0;
    
    if((pInToc) and (pInToc->InfoSize))
    {
        //
        // So we have in filter info
        //
        
        pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                    pInToc);

        if (pInfo isnot NULL)
        {
            ulNumInFilters = pInfo->dwNumFilters;

            //
            // The size we need for these many filters
            //
            
            ulSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                     (ulNumInFilters * sizeof(FILTER_INFO));

            //
            // The infosize must be atleast as large as the filters
            //
            
            IpRtAssert(ulSize <= pInToc->InfoSize);
            
            //
            // Copy out the info for ourselves
            //

            picb->pInFilter = HeapAlloc(IPRouterHeap,
                                        0,
                                        ulSize);
            
            if(picb->pInFilter is NULL)
            {
                Trace1(ERR,
                       "AddFilterInterface: Error allocating %d bytes for in filters",
                       ulSize);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            CopyMemory(picb->pInFilter,
                       pInfo,
                       ulSize);
            
            //
            // Save a copy of the default action.
            // If there is not TOC/Info for the filter set, then the action
            // is set to FORWARD (initialization done before this block)
            //
            
            faInAction = pInfo->faDefaultAction;

            if(ulNumInFilters isnot 0)
            {
                //
                // We have filters, so copy them to the new format
                // The address and mask will come at the end of all of the filters
                // so we allocate 16 bytes extra for each filter. Then we add a
                // 8 bytes so that we can align the block
                //
                

                ulSize = ulNumInFilters * (sizeof(PF_FILTER_DESCRIPTOR) + 16) + 8;
                
                
                pfdInFilters = HeapAlloc(IPRouterHeap,
                                         0,
                                         ulSize);
                
                if(pfdInFilters is NULL)
                {
                    HeapFree(IPRouterHeap,
                             0,
                             picb->pInFilter);

                    picb->pInFilter = NULL;

                    Trace1(ERR,
                           "AddFilterInterface: Error allocating %d bytes",
                           ulSize);

                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                
                //
                // Pointer to the start of the address block
                //
                
                pdwAddr = (PDWORD)&(pfdInFilters[ulNumInFilters]);
                
                //
                // Now convert the filters
                //

                for(i = 0, j = 0; i < ulNumInFilters; i++)
                {
                    pfdInFilters[i].dwFilterFlags = 0;
                    pfdInFilters[i].dwRule        = 0;
                    pfdInFilters[i].pfatType      = PF_IPV4;

                    //
                    // Set the pointers
                    //
                
                    pfdInFilters[i].SrcAddr = (PBYTE)&(pdwAddr[j++]);
                    pfdInFilters[i].SrcMask = (PBYTE)&(pdwAddr[j++]);
                    pfdInFilters[i].DstAddr = (PBYTE)&(pdwAddr[j++]);
                    pfdInFilters[i].DstMask = (PBYTE)&(pdwAddr[j++]);

                    //
                    // Copy in the src/dst addr/masks
                    //
                    
                    *(PDWORD)pfdInFilters[i].SrcAddr =
                        pInfo->fiFilter[i].dwSrcAddr;
                    
                    *(PDWORD)pfdInFilters[i].SrcMask =
                        pInfo->fiFilter[i].dwSrcMask;
                    
                    *(PDWORD)pfdInFilters[i].DstAddr =
                        pInfo->fiFilter[i].dwDstAddr;
                    
                    *(PDWORD)pfdInFilters[i].DstMask =
                        pInfo->fiFilter[i].dwDstMask;

                    //
                    // Copy the protocol and flag
                    //
                    
                    pfdInFilters[i].dwProtocol = pInfo->fiFilter[i].dwProtocol;
                    pfdInFilters[i].fLateBound = pInfo->fiFilter[i].fLateBound;

                    if(pfdInFilters[i].dwProtocol is FILTER_PROTO_TCP)
                    {
                        if(IsTcpEstablished(&(pInfo->fiFilter[i])))
                        {
                            pfdInFilters[i].dwFilterFlags |= FD_FLAGS_NOSYN;
                        }
                    }

                    pfdInFilters[i].fLateBound = pInfo->fiFilter[i].fLateBound;

                    //
                    // The ports
                    //
                    
                    pfdInFilters[i].wSrcPort  = pInfo->fiFilter[i].wSrcPort;
                    pfdInFilters[i].wDstPort  = pInfo->fiFilter[i].wDstPort;
                    
                    //
                    // Since we dont support ranges, set the high to 0
                    //
                    
                    pfdInFilters[i].wSrcPortHighRange = 0;
                    
                    pfdInFilters[i].wDstPortHighRange = 0;
                }
            }
        }
    }

    if((pOutToc) and (pOutToc->InfoSize))
    {
        pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                    pOutToc);

        
        if (pInfo isnot NULL)
        {
            ulNumOutFilters = pInfo->dwNumFilters;

            //
            // The size we need for these many filters
            //
            
            ulSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                     (ulNumOutFilters * sizeof(FILTER_INFO));

            //
            // The infosize must be atleast as large as the filters
            //
            
            IpRtAssert(ulSize <= pOutToc->InfoSize);
            
            //
            // Copy out the info for ourselves
            //

            picb->pOutFilter = HeapAlloc(IPRouterHeap,
                                         0,
                                         ulSize);

            if(picb->pOutFilter is NULL)
            {
                //
                // Free any in filter related memory
                //
                
                if(picb->pInFilter)
                {
                    HeapFree(IPRouterHeap,
                             0,
                             picb->pInFilter);

                    picb->pInFilter = NULL;
                }

                if(pfdInFilters)
                {
                    HeapFree(IPRouterHeap,
                             0,
                             pfdInFilters);
                }

                Trace1(ERR,
                       "AddFilterInterface: Error allocating %d bytes for out filters",
                       ulSize);

                return ERROR_NOT_ENOUGH_MEMORY;
            }


            CopyMemory(picb->pOutFilter,
                       pInfo,
                       ulSize);
            
            faOutAction = pInfo->faDefaultAction;
            
            if(ulNumOutFilters isnot 0)
            {   
                ulSize = ulNumOutFilters * (sizeof(PF_FILTER_DESCRIPTOR) + 16) + 8;
                
                pfdOutFilters = HeapAlloc(IPRouterHeap,
                                          0,
                                          ulSize);

                if(pfdOutFilters is NULL)
                {
                    if(picb->pInFilter)
                    {
                        HeapFree(IPRouterHeap,
                                 0,
                                 picb->pInFilter);

                        picb->pInFilter = NULL;
                    }

                    if(pfdInFilters)
                    {
                        HeapFree(IPRouterHeap,
                                 0,
                                 pfdInFilters);
                    }

                    HeapFree(IPRouterHeap,
                             0,
                             picb->pOutFilter);

                    picb->pOutFilter = NULL;

                    Trace1(ERR,
                           "AddFilterInterface: Error allocating %d bytes",
                           ulSize);

                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                
                //
                // The address and masks come at the end
                //

                pdwAddr = (PDWORD)&(pfdOutFilters[ulNumOutFilters]);
                

                //
                // Now convert the filters
                //

                for(i = 0, j = 0; i < ulNumOutFilters; i++)
                {
                    pfdOutFilters[i].dwFilterFlags = 0;
                    pfdOutFilters[i].dwRule        = 0;
                    pfdOutFilters[i].pfatType      = PF_IPV4;

                    //
                    // Set the pointers
                    //
                
                    pfdOutFilters[i].SrcAddr = (PBYTE)&(pdwAddr[j++]);
                    pfdOutFilters[i].SrcMask = (PBYTE)&(pdwAddr[j++]);
                    pfdOutFilters[i].DstAddr = (PBYTE)&(pdwAddr[j++]);
                    pfdOutFilters[i].DstMask = (PBYTE)&(pdwAddr[j++]);

                    //
                    // Copy in the src/dst addr/masks
                    //
                    
                    *(PDWORD)pfdOutFilters[i].SrcAddr =
                        pInfo->fiFilter[i].dwSrcAddr;
                    
                    *(PDWORD)pfdOutFilters[i].SrcMask =
                        pInfo->fiFilter[i].dwSrcMask;
                    
                    *(PDWORD)pfdOutFilters[i].DstAddr =
                        pInfo->fiFilter[i].dwDstAddr;
                    
                    *(PDWORD)pfdOutFilters[i].DstMask =
                        pInfo->fiFilter[i].dwDstMask;

                    //
                    // Copy the protocol and flag
                    //
                    
                    pfdOutFilters[i].dwProtocol = pInfo->fiFilter[i].dwProtocol;
                    pfdOutFilters[i].fLateBound = pInfo->fiFilter[i].fLateBound;

                    if(pfdOutFilters[i].dwProtocol is FILTER_PROTO_TCP)
                    {
                        if(IsTcpEstablished(&(pInfo->fiFilter[i])))
                        {
                            pfdOutFilters[i].dwFilterFlags |= FD_FLAGS_NOSYN;
                        }
                    }

                    //
                    // The ports
                    //
                    
                    pfdOutFilters[i].wSrcPort  = pInfo->fiFilter[i].wSrcPort;
                    pfdOutFilters[i].wDstPort  = pInfo->fiFilter[i].wDstPort;
                    
                    //
                    // Since we dont support ranges, set the high  to 0
                    //
                    
                    pfdOutFilters[i].wSrcPortHighRange = 0;
                    
                    pfdOutFilters[i].wDstPortHighRange = 0;
                }
            }
        }
    }

    if(MprConfigGetFriendlyName(g_hMprConfig,
                                picb->pwszName,
                                rgwcName,
                                sizeof(rgwcName)) is NO_ERROR)
    {
        pName = rgwcName;
    }
    else
    {
        pName = picb->pwszName;
    }

    //
    // Now add create the interace and set the info
    //

    dwResult = PfCreateInterface(0,
                                 faInAction,
                                 faOutAction,
                                 FALSE,
                                 FALSE,
                                 &(picb->ihFilterInterface));

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "AddFilterInterface: Err %d creating filter i/f for %S",
               dwResult,
               picb->pwszName);

        RouterLogEventEx(g_hLogHandle,
                         EVENTLOG_ERROR_TYPE,
                         dwResult,
                         ROUTERLOG_IP_CANT_ADD_PFILTERIF,
                         TEXT("%S"),
                         pName);
    }
    else
    {
        //
        // Set the filters
        //

        if((ulNumInFilters + ulNumOutFilters) isnot 0)
        {
            dwResult = PfAddFiltersToInterface(picb->ihFilterInterface,
                                               ulNumInFilters,
                                               pfdInFilters,
                                               ulNumOutFilters,
                                               pfdOutFilters,
                                               NULL);
        
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "AddFilterInterface: Err %d setting filters on %S",
                       dwResult,
                       picb->pwszName);

                RouterLogEventEx(g_hLogHandle,
                                 EVENTLOG_ERROR_TYPE,
                                 dwResult,
                                 ROUTERLOG_IP_CANT_ADD_PFILTERIF,
                                 TEXT("%S"),
                                 pName);

                PfDeleteInterface(picb->ihFilterInterface);
            }
        }
       
        if(dwResult is NO_ERROR) 
        {
            if(picb->bBound)
            {
                dwResult = BindFilterInterface(picb);
        
                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddFilterInterface: Err %d binding filters on %S",
                           dwResult,
                           picb->pwszName);

                    RouterLogEventEx(g_hLogHandle,
                                     EVENTLOG_ERROR_TYPE,
                                     dwResult,
                                     ROUTERLOG_IP_CANT_ADD_PFILTERIF,
                                     TEXT("%S"),
                                     pName);

                    PfDeleteInterface(picb->ihFilterInterface);
                }
            }
        }

        //
        // So if we successfully added filters, enable frag checking if the
        // user had asked for it. Note that the bFragCheckEnable is set up
        // in the SetFilterInterfaceInfo call.
        //

        if((dwResult is NO_ERROR) and
           (picb->bFragCheckEnable))
        {
            dwResult = PfAddGlobalFilterToInterface(picb->ihFilterInterface,
                                                    GF_FRAGCACHE);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetGlobalFilterOnIf: Error %d adding frag filter to %S",
                       dwResult,
                       picb->pwszName);

                picb->bFragCheckEnable = FALSE;

                dwResult = NO_ERROR;
            }
        }
    }

    if(pfdInFilters)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pfdInFilters);
    }   

    if(pfdOutFilters)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pfdOutFilters);
    }


    if(dwResult isnot NO_ERROR)
    {
        //
        // Something bad happened
        //

        picb->ihFilterInterface = INVALID_HANDLE_VALUE;
        
        if(picb->pInFilter)
        {
            HeapFree(IPRouterHeap,
                     0,
                     picb->pInFilter);

            picb->pInFilter = NULL;
        }
        
        if(picb->pOutFilter)
        {
            HeapFree(IPRouterHeap,
                     0,
                     picb->pOutFilter);

            picb->pOutFilter = NULL;
        }
    }

    TraceLeave("SetInterfaceFilterInfo");
        
    return dwResult;
}

DWORD
SetGlobalFilterOnIf(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    )

/*++

Routine Description


Arguments

    picb
    pInterfaceInfo

Return Value

    NO_ERROR

--*/

{
    DWORD           dwResult;    
    PRTR_TOC_ENTRY  pFragToc;
    PIFFILTER_INFO  pGlobFilter;
    BOOL            bEnable;

    pFragToc  = GetPointerToTocEntry(IP_IFFILTER_INFO,
                                     pInterfaceInfo);

    //
    // Add global filters if any
    //

    if(pFragToc is NULL)
    {
        return NO_ERROR;
    }

    dwResult = NO_ERROR;

    if(pFragToc->InfoSize is 0)
    {
        bEnable = FALSE;
    }
    else
    {
        pGlobFilter = GetInfoFromTocEntry(pInterfaceInfo,
                                          pFragToc);

        bEnable = (pGlobFilter isnot NULL) ? pGlobFilter->bEnableFragChk :
                                             FALSE;
    }

    //
    // If the interface has not been added to the filter driver
    // just set the info
    //

    if(picb->ihFilterInterface is INVALID_HANDLE_VALUE)
    {
        picb->bFragCheckEnable = bEnable;

        return NO_ERROR;
    }


    if(!bEnable)
    {
        dwResult = NO_ERROR;

        if(picb->bFragCheckEnable)
        {
            dwResult = 
                PfRemoveGlobalFilterFromInterface(picb->ihFilterInterface,
                                                  GF_FRAGCACHE);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetGlobalFilterOnIf: Error %d removing frag filter from %S",
                       dwResult,
                       picb->pwszName);
            }
            else
            {
                picb->bFragCheckEnable = FALSE;
            }
        }

        return dwResult;
    }
    else
    {
        if(picb->bFragCheckEnable is FALSE)
        {
            dwResult = PfAddGlobalFilterToInterface(picb->ihFilterInterface,
                                                    GF_FRAGCACHE);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetGlobalFilterOnIf: Error %d adding frag filter to %S",
                       dwResult,
                       picb->pwszName);
            }
            else
            {
                picb->bFragCheckEnable = TRUE;
            }
        }
    }

    return dwResult;
}

DWORD
DeleteFilterInterface(
    PICB picb
    )

/*++

Routine Description

    This function deletes a filter interface (and all associated filters)
    Also frees the memory holding the filters

Locks

    ICB_LIST held as WRITER

Arguments

    None

Return Value

    None    

--*/

{
    DWORD                           dwInBufLen;

    TraceEnter("DeleteFilterInterface");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK));

    if(picb->pInFilter isnot NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 picb->pInFilter);
        
        picb->pInFilter = NULL;
    }

    if(picb->pOutFilter isnot NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 picb->pOutFilter);
        
        picb->pOutFilter = NULL;
    }


    if(picb->ihFilterInterface is INVALID_HANDLE_VALUE)
    {
        Trace1(IF,
               "DeleteFilterInterface: No context, assuming interface %S not added to filter driver",
               picb->pwszName);
    
        return NO_ERROR;
    }

    PfDeleteInterface(picb->ihFilterInterface);
    
    picb->ihFilterInterface  = INVALID_HANDLE_VALUE;

    TraceLeave("DeleteFilterInterface");
    
    return NO_ERROR;
}

DWORD
SetFilterInterfaceInfo(
    PICB                     picb, 
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    )
{
    DWORD           dwResult;
    PRTR_TOC_ENTRY  pInToc, pOutToc, pFragToc;
    
    TraceEnter("SetInterfaceFilterInfo");

    if((picb->ritType is ROUTER_IF_TYPE_DIALOUT) or
       (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
       (picb->ritType is ROUTER_IF_TYPE_INTERNAL))
    {
        return NO_ERROR;
    }

    
    pInToc   = GetPointerToTocEntry(IP_IN_FILTER_INFO,
                                    pInterfaceInfo);

    pOutToc  = GetPointerToTocEntry(IP_OUT_FILTER_INFO,
                                    pInterfaceInfo);

    pFragToc = GetPointerToTocEntry(IP_IFFILTER_INFO,
                                    pInterfaceInfo);

    if((pInToc is NULL) and
       (pOutToc is NULL))
    {
        dwResult = NO_ERROR;

        if(pFragToc is NULL)
        {
            //
            // All NULL, means we dont need to change anything
            //
        
            Trace1(IF,
                   "SetInterfaceFilterInfo: Both filters info are NULL for %S, so leaving",
                   picb->pwszName);
       
            TraceLeave("SetInterfaceFilterInfo");
        }
        else
        {
            dwResult = SetGlobalFilterOnIf(picb,
                                           pInterfaceInfo);
        }
    
        return dwResult;
    }


    if(picb->ihFilterInterface isnot INVALID_HANDLE_VALUE)
    {
        //
        // This interface was added to the filter driver,
        // Delete it so that the filters are all deleted and then readd
        // the filters
        //

        IpRtAssert((picb->pInFilter isnot NULL) or
                   (picb->pOutFilter isnot NULL));

        dwResult = DeleteFilterInterface(picb);

        //
        // This better succeed, we dont have a failure path here
        //
        
        IpRtAssert(dwResult is NO_ERROR);
        
    }

    dwResult = AddFilterInterface(picb,
                                  pInterfaceInfo);



    TraceLeave("SetInterfaceFilterInfo");
        
    return dwResult;
}

DWORD
BindFilterInterface(
    PICB  picb
    )

/*++

Routine Description

    This function binds a filter interface to an IP interface. The IP
    interface is identified by the adapter index.
    The code assumes that the picb has a valid adapter index
    If the interface is a WAN link, the late binding information is also
    set.
    
Locks

    The ICB_LIST (which protects the ICB) needs to be locked as READER

Arguments

    picb    The ICB for the interface to be bound

Return Value

    NO_ERROR

--*/

{
    DWORD   dwResult, dwIfIndex, dwNHop;
    
    TraceEnter("BindFilterInterface");

    if (picb->ritType is ROUTER_IF_TYPE_INTERNAL)
    {
        TraceLeave("BindFilterInterface");

        return NO_ERROR;
    }
    
    IpRtAssert(picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK);

    if(picb->ihFilterInterface is INVALID_HANDLE_VALUE)
    {
        Trace1(IF,
               "BindFilterInterface: No context, assuming interface %S not added to filter driver",
               picb->pwszName);

        TraceLeave("BindFilterInterface");
        
        return NO_ERROR;
    }

    //
    // Bind the interface by index
    //

    IpRtAssert(picb->bBound);

   
    if(picb->ritType is ROUTER_IF_TYPE_CLIENT)
    {
        dwIfIndex = g_pInternalInterfaceCb->dwIfIndex;
        dwNHop    = picb->pibBindings[0].dwAddress;
    }
    else
    {
        dwIfIndex = picb->dwIfIndex;
        dwNHop    = 0;
    }

    dwResult = PfBindInterfaceToIndex(picb->ihFilterInterface,
                                      dwIfIndex,
                                      PF_IPV4,
                                      (PBYTE)&dwNHop);

    if(dwResult isnot NO_ERROR)
    {
        //
        // Some error trying to bind. Bail out of here
        //

        Trace4(ERR,
               "BindFilterInterface: Err %d binding %S to %d/%d.%d.%d.%d",
               dwResult,
               picb->pwszName,
               dwIfIndex,
               PRINT_IPADDR(dwNHop));

        TraceLeave("BindFilterInterface");
        
        return dwResult;
    }

    //
    // If this is a WAN interface, also set the late binding info
    //

#if 0    
    if(((picb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
        (picb->ritType is ROUTER_IF_TYPE_FULL_ROUTER)) and
       (picb->dwNumAddresses isnot 0))
    {
        DWORD               rgdwLateInfo[sizeof(PF_LATEBIND_INFO)/sizeof(DWORD) + 1 + 3 + 4];

        PPF_LATEBIND_INFO   pLateBindInfo;

        pLateBindInfo = rgdwLateInfo;

        pvStart = (PBYTE)pLateBindInfo + 3 
        lateBindInfo.dwSrcAddr  = picb->pibBindings[0].dwAddress;
        lateBindInfo.dwDstAddr  = picb->dwRemoteAddress;
        lateBindInfo.dwMask     = picb->pibBindings[0].dwMask;

        dwResult = PfRebindFilters(picb->ihFilterInterface,
                                   &lateBindInfo);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "BindFilterInterface: Err %d rebinding to %S",
                   dwResult,
                   picb->pwszName);
        }
    }

#endif
            
    TraceLeave("BindFilterInterface");

    return dwResult;
}


DWORD
UnbindFilterInterface(
    PICB  picb
    )

/*++

Routine Description

    This function unbinds a filter interface 
    
Locks

    The ICB_LIST (which protects the ICB) needs to be locked as READER

Arguments

    picb    The ICB for the interface to be bound

Return Value

    NO_ERROR

--*/

{
    DWORD   dwResult;
    
    TraceEnter("UnbindFilterInterface");
    
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT))

    if(picb->ihFilterInterface is INVALID_HANDLE_VALUE)
    {
        Trace1(IF,
               "UnbindFilterInterface: No context, assuming interface %S not added to filter driver",
               picb->pwszName);

        TraceLeave("UnbindFilterInterface");
        
        return NO_ERROR;
    }

    dwResult = PfUnBindInterface(picb->ihFilterInterface);
    
    if(dwResult isnot NO_ERROR)
    {
        //
        // Some error trying to bind. Bail out of here
        //

        Trace2(ERR,
               "UnbindFilterInterface: Err %d binding to %S",
               dwResult,
               picb->pwszName);
    }
            
    TraceLeave("UnbindFilterInterface");

    return dwResult;
}

DWORD
GetInFilters(
    PICB                      picb, 
    PRTR_TOC_ENTRY            pToc, 
    PBYTE                     pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    )
{
    DWORD                       dwInBufLen,i;
    
    TraceEnter("GetInFilters");
   
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    //
    // Set size returned to 0
    //
    
    *pdwSize = 0;

    //
    // Safe init of both the TOCs. 
    //
    
    // pToc->InfoVersion = IP_IN_FILTER_INFO;
    pToc->InfoType    = IP_IN_FILTER_INFO;
    pToc->Count       = 0;
    pToc->InfoSize    = 0;
    
    if((picb->ihFilterInterface is INVALID_HANDLE_VALUE) or
       (picb->pInFilter is NULL))
    {
        Trace1(IF,
               "GetInFilters: No context or no filters for %S",
               picb->pwszName);
    
        return ERROR_NO_DATA;
    }

    //
    // Set the offset in the TOC
    //
    
    pToc->Offset   = (ULONG)(pbDataPtr - (PBYTE)pInfoHdrAndBuffer);
    pToc->Count    = 1;
    pToc->InfoSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                       (picb->pInFilter->dwNumFilters * sizeof(FILTER_INFO));
   
    //
    // Just copy out the filters
    //
    
    CopyMemory(pbDataPtr,
               picb->pInFilter,
               pToc->InfoSize);

    //
    // The size copied in
    //
    
    *pdwSize = pToc->InfoSize;
        
    TraceLeave("GetInFilters");
        
    return NO_ERROR;
}

DWORD
GetOutFilters(
    PICB                      picb, 
    PRTR_TOC_ENTRY            pToc, 
    PBYTE                     pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    )
{
    DWORD       dwInBufLen,i;
    
    TraceEnter("GetOutFilters");
   
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    //
    // Set size returned to 0
    //
    
    *pdwSize = 0;

    //
    // Safe init of both the TOCs. 
    //
    
    //pToc->InfoVersion = IP_OUT_FILTER_INFO;
    pToc->InfoType    = IP_OUT_FILTER_INFO;
    pToc->Count       = 0;
    pToc->InfoSize    = 0;
    
    if((picb->ihFilterInterface is INVALID_HANDLE_VALUE) or
       (picb->pOutFilter is NULL))
    {
        Trace1(IF,
               "GetOutFilters: No context or no filters for %S",
               picb->pwszName);
        
        return ERROR_NO_DATA;
    }

    //
    // Set the offset in the TOC
    //
    
    pToc->Offset   = (ULONG)(pbDataPtr - (PBYTE)pInfoHdrAndBuffer);
    pToc->Count    = 1;
    pToc->InfoSize = FIELD_OFFSET(FILTER_DESCRIPTOR,fiFilter[0]) +
                       (picb->pOutFilter->dwNumFilters * sizeof(FILTER_INFO));
   
    //
    // Just copy out the filters
    //
    
    CopyMemory(pbDataPtr,
               picb->pOutFilter,
               pToc->InfoSize);

    //
    // The size copied in
    //
    
    *pdwSize = pToc->InfoSize;
        
    TraceLeave("GetOutFilters");
        
    return NO_ERROR;
}

DWORD
GetGlobalFilterOnIf(
    PICB                      picb, 
    PRTR_TOC_ENTRY            pToc, 
    PBYTE                     pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    PDWORD                    pdwSize
    )
{
    DWORD       dwInBufLen,i;
    
    TraceEnter("GetGlobalFilterOnIf");
   
    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    
    //pToc->InfoVersion = IP_IFFILTER_INFO;
    pToc->InfoType = IP_IFFILTER_INFO;
    pToc->Offset   = (ULONG)(pbDataPtr - (PBYTE)pInfoHdrAndBuffer);
    pToc->Count    = 1;
    pToc->InfoSize = sizeof(IFFILTER_INFO);
   
    
    ((PIFFILTER_INFO)pbDataPtr)->bEnableFragChk = picb->bFragCheckEnable;

    //
    // The size copied in
    //
    
    *pdwSize = pToc->InfoSize;
        
    TraceLeave("GetOutFilters");
        
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\if.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\if.c

Abstract:

    IP Router Manager interface related functions

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

#include "allinc.h"

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The interface state machine:                                             //
//                                                                          //
//                           ----------                                     //
//                          | Unbound  |                                    //
//             ------------>| Disabled |<---------------                    //
//            |              ----------                 |                   //
//            V                                         V                   //
//       ----------                                  ---------              //
//      | Bound    |                                | Unbound |             //
//      | Disabled |                                | Enabled |             //
//       ----------                                  ---------              //
//           ^                                          ^                   //
//           |               ---------                  |                   //
//            ------------->| Bound   |<----------------                    //
//                          | Enabled |                                     //
//                           ---------                                      //
//                                                                          //
//                                                                          //
//  LAN interfaces:                                                         //
//                                                                          //
//  Characteristics    UP (Operational)    DOWN (Non-Operational)           //
//  ------------------------------------------------------------------      //
//  Binding (IP Address)    Yes                 No                          //
//  Protocols Added         Yes                 Yes                         //
//  Static Routes           Yes                 No                          //
//  Other Routes            Yes                 No                          //
//  Added to Filter Driver  Yes                 Yes                         //
//  Filters                 Added               Not added                   //
//  Filter Ctxt in IP Stack Set (Valid)         Not Set (Invalid)           //
//  Router Discovery        Active (if necc)    Inactive                    //
//  Adapter ID (and Map)    Valid               Invalid                     //
//                                                                          //
//  WAN interfaces:                                                         //
//                                                                          //
//  Characteristics       CONNECTED     DISCON/CONNECTING     UNREACHABLE   //
//  -------------------------------------------------------------------     //
//  Binding (IP Address)    Yes             No                  No          //
//  Protocols Added         Yes             Yes                 Yes         //
//  Static Routes           Yes             Yes                 No          //
//  Other Routes            Yes             No                  No          //
//  Added to Filter Driver  Yes             Yes                 Yes         //
//  Filters                 Yes             Yes                 No          //
//  Filter Ctxt in IP Stack Set (Valid)     Not Set (Invalid)   Not Set     //
//  Router Discovery        Active          Inactive            Inactive    //
//  Adapter ID (and Map)    Valid           Invalid             Invalid     //
//                                                                          //
//  Enabled/Disabled depends upon the AdminState and not upon the           //
//  operational state                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


PICB
CreateIcb(
    PWSTR                   pwszInterfaceName,
    HANDLE                  hDIMInterface,
    ROUTER_INTERFACE_TYPE   InterfaceType,
    DWORD                   dwAdminState,
    DWORD                   dwIfIndex OPTIONAL
    )

/*++

Routine Description

    This function creates an interface control block

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD           dwResult;
    PICB            pNewInterfaceCb;
    GUID            Guid;

    //
    // Make sure this is a valid name
    //

    if(InterfaceType is ROUTER_IF_TYPE_TUNNEL1)
    {
        UNICODE_STRING  usTempName;

        //
        // For now only these interfaces are GUIDs
        //

        usTempName.Length        = wcslen(pwszInterfaceName) * sizeof(WCHAR);
        usTempName.MaximumLength = usTempName.Length + sizeof(WCHAR);
        usTempName.Buffer        = pwszInterfaceName;

        if(RtlGUIDFromString(&usTempName,
                             &Guid) isnot STATUS_SUCCESS)
        {
            Trace1(ERR,
                   "CreateIcb: %S is not a GUID\n",
                   pwszInterfaceName);
 
            return NULL;
        }
    }

    //
    // Allocate an ICB
    //
   
    dwResult = AllocateIcb(pwszInterfaceName,
                           &pNewInterfaceCb);

    if(dwResult isnot NO_ERROR)
    {
        return NULL;
    }

    pNewInterfaceCb->dwIfIndex    = INVALID_IF_INDEX;
    pNewInterfaceCb->hDIMHandle   = hDIMInterface;
    pNewInterfaceCb->ritType      = InterfaceType;
    pNewInterfaceCb->dwMcastTtl   = 1;


    //
    // "Unique" interface ID used for ICBs.
    // This ID is passed to WANARP and DIM and they in
    // turn pass this back to Router Manager when 
    // requesting/indicating actions on the interface.
    //
    
    pNewInterfaceCb->dwSeqNumber = g_dwNextICBSeqNumberCounter;


    //
    // Initialize the filter, and wanarp contexts to invalid values
    // (NAT invalid is NULL)
    //

    pNewInterfaceCb->ihFilterInterface         = INVALID_HANDLE_VALUE;
    pNewInterfaceCb->ihDemandFilterInterface   = INVALID_HANDLE_VALUE;

    //
    // Initialize the lists of which async notifications and
    // the protocol blocks are queued
    //
    
    InitializeListHead(&pNewInterfaceCb->lePendingResultList);
    InitializeListHead(&pNewInterfaceCb->leProtocolList);

    //
    // Since we HEAP zeroed the ICB, all our binding related
    // stuff is already zero, the bBound is FALSE and dwNumAddress is 0
    // The adapter id was set to invalid in InitializeInterfaceContext
    //


    //
    // set the operational status based on the interface type
    // Also figure out the interface index
    //

    dwResult = NO_ERROR;
    
    switch(pNewInterfaceCb->ritType) 
    {
        case ROUTER_IF_TYPE_CLIENT:
        {
            //
            // Clients come up in connecting, since we dont get a LINE_UP for
            // them.  We also set the notification flags to fake the LINE UP
            //

            pNewInterfaceCb->dwAdminState       = IF_ADMIN_STATUS_UP;
            pNewInterfaceCb->dwOperationalState = CONNECTING; 
            pNewInterfaceCb->nitProtocolType    = REMOTE_WORKSTATION_DIAL;

            SetNdiswanNotification(pNewInterfaceCb);

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            //
            // We dont really care about dial out ifIndex
            // so clients will have an index of -1 (since we init to -1)
            //
            
            break;
        }

        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
        {
            //
            // HOME and FULL routers are disconnected
            //

            pNewInterfaceCb->dwAdminState       = dwAdminState;
            pNewInterfaceCb->dwOperationalState = DISCONNECTED;
            pNewInterfaceCb->nitProtocolType    = DEMAND_DIAL;

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            //
            // WANARP reserves and index when we add an interface to it
            //
            
            dwResult = AddInterfaceToWanArp(pNewInterfaceCb);

            break;
        }

        case ROUTER_IF_TYPE_DEDICATED:
        {
            //
            // LAN interfaces come up as NON_OPERATIONAL. If the admin
            // wants them up we will try to do a LanInterfaceDownToUp()
            // If that succeeds, it will set the operational state
            // correctly
            //

            pNewInterfaceCb->dwAdminState       = dwAdminState;
            pNewInterfaceCb->dwOperationalState = NON_OPERATIONAL;
            pNewInterfaceCb->nitProtocolType    = PERMANENT;

            dwResult = NhpGetInterfaceIndexFromStack(
                            pNewInterfaceCb->pwszName,
                            &(pNewInterfaceCb->dwIfIndex)
                            );

            break;
        }

        case ROUTER_IF_TYPE_INTERNAL:
        {
            
            pNewInterfaceCb->dwAdminState       = IF_ADMIN_STATUS_UP;
            pNewInterfaceCb->dwOperationalState = DISCONNECTED;
            pNewInterfaceCb->nitProtocolType    = LOCAL_WORKSTATION_DIAL;

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            //
            // WANARP reserves and index when we add an interface to it
            //
            
            dwResult = AddInterfaceToWanArp(pNewInterfaceCb);

            break;
        }
        
        case ROUTER_IF_TYPE_LOOPBACK:
        {
            
            pNewInterfaceCb->dwAdminState       = IF_ADMIN_STATUS_UP;
            pNewInterfaceCb->dwOperationalState = OPERATIONAL;
            pNewInterfaceCb->nitProtocolType    = PERMANENT;

            //
            // Note that IP uses 1
            //

            pNewInterfaceCb->dwIfIndex = LOOPBACK_INTERFACE_INDEX;
            
            break;
        }

        case ROUTER_IF_TYPE_TUNNEL1:
        {
  
            pNewInterfaceCb->dwAdminState       = dwAdminState;
            pNewInterfaceCb->dwOperationalState = NON_OPERATIONAL;
            pNewInterfaceCb->nitProtocolType    = PERMANENT;

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            //
            // IP in IP does the same thing as WANARP
            //

            dwResult = AddInterfaceToIpInIp(&Guid,
                                            pNewInterfaceCb);

            break;
        }

        case ROUTER_IF_TYPE_DIALOUT:
        {
            //
            // Dial out interface are not known to DIM. We learn about
            // them via a back door mechanism.
            //

            IpRtAssert(dwIfIndex isnot INVALID_IF_INDEX);
            IpRtAssert(dwIfIndex isnot 0);

            pNewInterfaceCb->dwAdminState       = IF_ADMIN_STATUS_UP;
            pNewInterfaceCb->dwOperationalState = CONNECTED;
            pNewInterfaceCb->nitProtocolType    = REMOTE_WORKSTATION_DIAL;
            pNewInterfaceCb->dwIfIndex          = dwIfIndex;

            pNewInterfaceCb->dwBCastBit       = 1;
            pNewInterfaceCb->dwReassemblySize = DEFAULT_MTU;

            break;
        }

         
        default:
        {
            IpRtAssert(FALSE);

            break;
        }
    }

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "CreateIcb: Error %d in getting index for %S\n",
               dwResult,
               pNewInterfaceCb->pwszName);

        HeapFree(IPRouterHeap,
                 0,
                 pNewInterfaceCb);

        return NULL;
    }
        
    //
    // Once the interface index is done we can Initialize the bindings
    //

    dwResult = CreateBindingForNewIcb(pNewInterfaceCb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "CreateIcb: Error %d in creating binding for %S\n",
               dwResult,
               pNewInterfaceCb->pwszName);

        HeapFree(IPRouterHeap, 
                 0,
                 pNewInterfaceCb);

        return NULL;
    }

    return pNewInterfaceCb;
}

DWORD
AllocateIcb(
    PWCHAR  pwszName,
    ICB     **ppIcb
    )

/*++

Routine Description

    Allocates memory for the ICB

Locks

    None

Arguments

    pwszName    Interface name
    ppIcb       OUT: pointer to allocate ICB

Return Value

    NO_ERROR
    
--*/

{
    DWORD   dwNameLen, dwAllocSize;
    PICB    pNewInterfaceCb;

    *ppIcb = NULL;
    
    dwNameLen       = sizeof(WCHAR) * (wcslen(pwszName) + 1); // +1 for NULL
    dwNameLen       = min(dwNameLen, MAX_INTERFACE_NAME_LEN);
    dwAllocSize     = sizeof (ICB) + dwNameLen + 4; // +4 for alignment
    
    pNewInterfaceCb = HeapAlloc(IPRouterHeap, 
                                HEAP_ZERO_MEMORY, 
                                dwAllocSize);

    if(pNewInterfaceCb is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // The interface name is after the ICB
    //
    
    pNewInterfaceCb->pwszName = (PWCHAR)((PBYTE)pNewInterfaceCb +
                                         sizeof (ICB));
    
    //
    // Align it to DWORD boundary - easier to copy out the name
    //
    
    pNewInterfaceCb->pwszName = 
        (PWCHAR)(((ULONG_PTR)pNewInterfaceCb->pwszName + 3) & ~((ULONG_PTR)0x3));
    
    //
    // Initialize the name
    //
    
    CopyMemory(pNewInterfaceCb->pwszName,
               pwszName,
               dwNameLen);
    
    pNewInterfaceCb->pwszName[wcslen(pwszName)] = UNICODE_NULL;

    *ppIcb = pNewInterfaceCb;
    
    return NO_ERROR;
}

DWORD
CreateBindingForNewIcb(
    PICB    pNewIcb
    )

/*++

Routine Description

    Creates a binding and bind node for the ICB

    LAN interfaces get the binding setup when they are being brought UP.
    Since the other interfaces will ALWAYS have ONLY 1 address, we can
    set their binding info here, even if we dont have the address
    
    We skip INTERNAL, too because of the way the internal address is 
    got. Otherwise we will get an assert in UpdateBindingInformation
    when we find an existing binding with no address 
    
Locks

    

Arguments

    

Return Value


--*/

{
    PADAPTER_INFO   pBindNode;
    PICB_BINDING    pBinding;

    if((pNewIcb->ritType is ROUTER_IF_TYPE_TUNNEL1) or
       (pNewIcb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
       (pNewIcb->ritType is ROUTER_IF_TYPE_FULL_ROUTER) or
       (pNewIcb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
       (pNewIcb->ritType is ROUTER_IF_TYPE_DIALOUT))
    {

        IpRtAssert(pNewIcb->dwIfIndex isnot INVALID_IF_INDEX);

        pBindNode   = HeapAlloc(IPRouterHeap,
                                HEAP_ZERO_MEMORY,
                                SIZEOF_ADAPTER_INFO(1));
       
        pBinding    = HeapAlloc(IPRouterHeap,
                                HEAP_ZERO_MEMORY,
                                sizeof(ICB_BINDING)); 

        if((pBinding is NULL) or
           (pBindNode is NULL))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pBindNode->pInterfaceCB             = pNewIcb;
        pBindNode->dwIfIndex                = pNewIcb->dwIfIndex;
        pBindNode->dwSeqNumber              = pNewIcb->dwSeqNumber;
        pBindNode->bBound                   = pNewIcb->bBound;
       
        pBindNode->dwRemoteAddress          = INVALID_IP_ADDRESS;
        pBindNode->rgibBinding[0].dwAddress = INVALID_IP_ADDRESS;
        pBindNode->rgibBinding[0].dwMask    = INVALID_IP_ADDRESS;

        pBindNode->dwBCastBit               = pNewIcb->dwBCastBit;
        pBindNode->dwReassemblySize         = pNewIcb->dwReassemblySize;

        pBindNode->ritType                  = pNewIcb->ritType;

        pNewIcb->pibBindings                = pBinding;
        
        //
        // Set the binding in the hash table
        //
        
        ENTER_WRITER(BINDING_LIST);

        InsertHeadList(
            &g_leBindingTable[BIND_HASH(pNewIcb->dwIfIndex)],
            &(pBindNode->leHashLink)
            );

        g_ulNumBindings++;

        g_LastUpdateTable[IPADDRCACHE] = 0;

        EXIT_LOCK(BINDING_LIST);

        return NO_ERROR;
    }
   
    //
    // For client (dial in our out) interfaces, we only create the BINDING
    //

    if((pNewIcb->ritType is ROUTER_IF_TYPE_CLIENT) or
       (pNewIcb->ritType is ROUTER_IF_TYPE_DIALOUT))
    {
        pBinding = HeapAlloc(IPRouterHeap,
                             HEAP_ZERO_MEMORY,
                             sizeof(ICB_BINDING));

        if(pBinding is NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pNewIcb->pibBindings  = pBinding;

        return NO_ERROR;
    }

    return NO_ERROR;
}

VOID    
InsertInterfaceInLists(
    PICB     pNewIcb
    )

/*++

Routine Description

    Insert the new ICB. The newicb must have a valid interface
    index. The code walks all the current ICBs and inserts this
    ICB in increasing ifIndex order. It also sets a sequence
    number in the ICB and increments the global counter. 
  
Locks

    ICB_LIST as writer
      
Arguments

    newicb          The ICB of the interface to init

Return Value

    None
    
--*/

{
    PLIST_ENTRY pleNode;
    PICB        pIcb;

    for(pleNode = &ICBList;
        pleNode->Flink != &ICBList;
        pleNode = pleNode->Flink)
    {
        pIcb = CONTAINING_RECORD(pleNode->Flink, 
                                 ICB, 
                                 leIfLink);

        if(pIcb->dwIfIndex > pNewIcb->dwIfIndex)
        {
            break;
        }
    }

    InsertHeadList(pleNode, 
                   &pNewIcb->leIfLink);

    AddInterfaceLookup(pNewIcb);


    //
    // Find next unassigned ICB number
    //
    
    do
    {
        InterlockedIncrement(&g_dwNextICBSeqNumberCounter);

        //
        // WANARP considers 0 to be an invalid value for an
        // interface
        //
        
        if ((g_dwNextICBSeqNumberCounter == 0) or
            (g_dwNextICBSeqNumberCounter == INVALID_IF_INDEX))
        {
            InterlockedIncrement(&g_dwNextICBSeqNumberCounter);
        }

    } while(InterfaceLookupByICBSeqNumber(g_dwNextICBSeqNumberCounter) != NULL);
    
    //
    // Increment total number of interfaces
    //
    
    InterlockedIncrement(&g_ulNumInterfaces);


    //
    // Count for non client interfaces
    //

    if(pNewIcb->ritType isnot ROUTER_IF_TYPE_CLIENT)
    {
        InterlockedIncrement(&g_ulNumNonClientInterfaces);
    }
}

VOID
RemoveInterfaceFromLists(
    PICB    pIcb
    )

/*++

Routine Description

    This

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    RemoveEntryList(&(pIcb->leIfLink));

    pIcb->leIfLink.Flink = NULL;
    pIcb->leIfLink.Blink = NULL;

    RemoveInterfaceLookup(pIcb);

    if(pIcb->ritType isnot ROUTER_IF_TYPE_CLIENT)
    {
        InterlockedDecrement(&g_ulNumNonClientInterfaces);
    }

    InterlockedDecrement(&g_ulNumInterfaces);
}

DWORD
BindInterfaceInAllProtocols(
    PICB pIcb
    )

/*++

Routine Description

    Binds the interface in all protocols running over the interface
      
Locks 

    The ICB_LIST lock must be held as READER. 
    Acquires the PROTOCOL_CB_LIST as READER

Arguments

    pIcb  ICB of the interface to bind

Return Value

    NO_ERROR

--*/

{
    IP_ADAPTER_BINDING_INFO *pBindInfo;
    DWORD                   i = 0 ;
    DWORD                   dwResult,dwReturn;
    PLIST_ENTRY             pleNode;
    
    TraceEnter("BindInterfaceInAllProtocols");

    CheckBindingConsistency(pIcb);
    
    if(!pIcb->bBound)
    {
        //
        // This may happen if we are in non operational state
        // It is not an error. We could do this check at the place
        // we called the function but it would make it tougher
        //

        Trace1(IF,
               "BindInterfaceInAllProtocols: Not binding %S since no addresses present",
               pIcb->pwszName);

        return NO_ERROR;
    }

    pBindInfo = HeapAlloc(IPRouterHeap,
                          0,
                          SIZEOF_IP_BINDING(pIcb->dwNumAddresses));

    if(pBindInfo is NULL)
    {
        
        Trace1(ERR,
               "BindInterfaceInAllProtocols: Error allocating %d bytes for bindings",
               SIZEOF_IP_BINDING(pIcb->dwNumAddresses));

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    
    pBindInfo->AddressCount  = pIcb->dwNumAddresses ;
    pBindInfo->RemoteAddress = pIcb->dwRemoteAddress;

    pBindInfo->Mtu           = pIcb->ulMtu;
    pBindInfo->Speed         = pIcb->ullSpeed;

    for (i = 0; i < pIcb->dwNumAddresses; i++) 
    {
        pBindInfo->Address[i].Address = pIcb->pibBindings[i].dwAddress;
        pBindInfo->Address[i].Mask    = pIcb->pibBindings[i].dwMask;
    }

    
    
    //
    // walk the array of routing protocols to activate
    //
    
    dwReturn = NO_ERROR;
    
    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);

    for(pleNode = pIcb->leProtocolList.Flink;
        pleNode isnot &(pIcb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO   pProto;
        
        pProto = CONTAINING_RECORD(pleNode,
                                   IF_PROTO,
                                   leIfProtoLink);

        dwResult = BindInterfaceInProtocol(pIcb,
                                           pProto->pActiveProto,
                                           pBindInfo);

        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR,
                   "BindInterfaceInAllProtocols: Couldnt bind interface %S to %S. Error %d",
                   pIcb->pwszName,
                   pProto->pActiveProto->pwszDisplayName,
                   dwResult);
            
            dwReturn = ERROR_CAN_NOT_COMPLETE;
        }
    }

    HeapFree(IPRouterHeap,
             0,
             pBindInfo);
    
    // *** Exclusion End ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    return dwReturn;
}

DWORD
BindInterfaceInProtocol(
    PICB                        pIcb,
    PPROTO_CB                   pProto,
    PIP_ADAPTER_BINDING_INFO    pBindInfo
    )

/*++

Routine Description

    Binds the interface in the given protocol

Locks

    The ICB_LIST lock must be held as READER.
    The PROTOCOL_CB_LIST lock must also be held as READER

Arguments

    pIcb        ICB of the interface to bind
    pProto      PROTO_CB of the protocol
    pBindInfo   Binding info

Return Value

    NO_ERROR

--*/

{
    DWORD   dwResult;
 
    //
    // If this is a mcast protocol and the interface is not
    // mcast enabled, do so now
    //

    if((pIcb->bMcastEnabled is FALSE) and
       (TYPE_FROM_PROTO_ID(pProto->dwProtocolId) is PROTO_TYPE_MCAST))
    {
        dwResult = SetMcastOnIf(pIcb,
                                TRUE);

        if(dwResult isnot NO_ERROR)
        {
            WCHAR   rgwcName[MAX_INTERFACE_NAME_LEN + 2];
            PWCHAR  pName;

            Trace2(ERR,
                   "BindInterfaceInProtocol: Err %d activating mcast on %S",
                   dwResult,
                   pIcb->pwszName);

            if(MprConfigGetFriendlyName(g_hMprConfig,
                                        pIcb->pwszName,
                                        rgwcName,
                                        sizeof(rgwcName)) is NO_ERROR)
            {
                pName = rgwcName;
            }
            else
            {
                pName = pIcb->pwszName;
            }

            RouterLogEventEx(g_hLogHandle,
                             EVENTLOG_ERROR_TYPE,
                             dwResult,
                             ROUTERLOG_IP_MCAST_NOT_ENABLED,
                             TEXT("%S%S"),
                             pName,
                             pProto->pwszDisplayName);

            //
            // Dont add this protocol
            //

            return dwResult;
        }

        pIcb->bMcastEnabled = TRUE;
    }

    //
    // Call the routing protocol's BindInterface() entrypoint
    //

    dwResult = (pProto->pfnInterfaceStatus)(
                    pIcb->dwIfIndex,
                    (pIcb->dwOperationalState >= CONNECTED),
                    RIS_INTERFACE_ADDRESS_CHANGE,
                    pBindInfo
                    );

    if(dwResult isnot NO_ERROR)
    {
        Trace3(ERR,
               "BindInterfaceInProtocol: Couldnt bind interface %S to %S.Error %d",
               pIcb->pwszName,
               pProto->pwszDisplayName,
               dwResult);

    }

    return dwResult;
}

DWORD
UnbindInterfaceInAllProtocols(
    PICB pIcb
    )

/*++
  
Routine Description

    Removes the binding information from the protocols on this interface
  
Locks 

    ICB_LIST lock as READER
    Acquires the PROTOCOL_CB_LIST as READER

Arguments
      

Return Value

    NO_ERROR

--*/

{
    PLIST_ENTRY pleNode;
    DWORD       dwResult,dwReturn = NO_ERROR;

    IP_ADAPTER_BINDING_INFO BindInfo;

    BindInfo.AddressCount = 0;
    
    TraceEnter("UnbindInterfaceInAllProtocols");

    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);


    for(pleNode = pIcb->leProtocolList.Flink;
        pleNode isnot &(pIcb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);

        dwResult = (pProto->pActiveProto->pfnInterfaceStatus)(
                        pIcb->dwIfIndex,
                        FALSE,
                        RIS_INTERFACE_ADDRESS_CHANGE,
                        &BindInfo
                        );

        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR,
                   "UnbindInterfaceInAllProtocols: Error %d unbinding %S in %S",
                   dwResult,
                   pIcb->pwszName,
                   pProto->pActiveProto->pwszDisplayName);

            dwReturn = ERROR_CAN_NOT_COMPLETE;
        }
    }

    
    // *** Exclusion Begin ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    return dwReturn;
}


DWORD
AddInterfaceToAllProtocols(
    PICB                     pIcb, 
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    )

/*++

Routine Description

    Walks thru list of  routing protocols and calls AddInterface if
    TOC and info for that protocol exists
  
Locks 

    ICB_LIST lock as WRITER
    Acquires PROTOCOL_CB_LIST as READER

Arguments
      

Return Value

    NO_ERROR

--*/

{
    DWORD           i = 0 , dwResult;
    LPVOID          pvProtoInfo ;
    PPROTO_CB       pProtoCbPtr ;
    PLIST_ENTRY     pleNode;
    PRTR_TOC_ENTRY  pToc;
    ULONG           ulStructureVersion, ulStructureSize, ulStructureCount;
    
    TraceEnter("AddInterfaceToAllProtocols");

    if(!ARGUMENT_PRESENT(pInfoHdr))
    {
        Trace1(IF,
               "AddInterfaceToAllProtocols: No interface info for %S. Not adding to any protocols",
               pIcb->pwszName);

        return NO_ERROR;
    }

    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);
    
    for(pleNode = g_leProtoCbList.Flink; 
        pleNode != &g_leProtoCbList; 
        pleNode = pleNode->Flink) 
    {
        pProtoCbPtr = CONTAINING_RECORD(pleNode, PROTO_CB, leList);
      
        pToc = GetPointerToTocEntry(pProtoCbPtr->dwProtocolId, 
                                    pInfoHdr);

        pvProtoInfo = NULL;

        if(pToc and (pToc->InfoSize > 0))
        {
            pvProtoInfo = GetInfoFromTocEntry(pInfoHdr,
                                              pToc);

            //ulStructureVersion = pInfoHdr->TocEntry[i].InfoVersion;
            ulStructureVersion = 0x500;
            ulStructureSize  = pInfoHdr->TocEntry[i].InfoSize;
            ulStructureCount = pInfoHdr->TocEntry[i].Count;

        }

        //
        // If the protocol block is found, add the interface with the
        // routing protocol.
        //
        
        if((pProtoCbPtr->fSupportedFunctionality & RF_ADD_ALL_INTERFACES) or
           (pvProtoInfo))
        {
            dwResult = AddInterfaceToProtocol(pIcb,
                                              pProtoCbPtr,
                                              pvProtoInfo,
                                              ulStructureVersion,
                                              ulStructureSize,
                                              ulStructureCount);

            if(dwResult isnot NO_ERROR)
            {
                Trace3(ERR,
                       "AddInterfaceToAllProtocols: Error %d adding %S to %S",
                       dwResult,
                       pIcb->pwszName,
                       pProtoCbPtr->pwszDisplayName);
            }
        }
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    return NO_ERROR;
}

DWORD
AddInterfaceToProtocol(
    IN  PICB            pIcb,
    IN  PPROTO_CB       pProtocolCb,
    IN  PVOID           pvProtoInfo,
    IN  ULONG           ulStructureVersion,
    IN  ULONG           ulStructureSize,
    IN  ULONG           ulStructureCount
    )

/*++

Routine Description

    Adds an interface to a single routing protocol

Locks

    

Arguments

    

Return Value


--*/

{
    PIF_PROTO   pProto;
    DWORD       dwResult;

        
    pProto = HeapAlloc(IPRouterHeap,
                       0,
                       sizeof(IF_PROTO));
                
    if(pProto is NULL)
    {
        Trace3(ERR,
               "AddInterfaceToProtocol: Error allocating %d bytes to add %S to %S",
               sizeof(IF_PROTO),
               pIcb->pwszName,
               pProtocolCb->pwszDisplayName);

        return ERROR_NOT_ENOUGH_MEMORY;
    }
            
    //
    // The protocol wants all the interfaces indicated to it or
    // there is info for this protocol
    //
            
    Trace2(IF,
           "AddInterfaceToProtocol: Adding %S to %S",
           pIcb->pwszName,
           pProtocolCb->pwszDisplayName);
    
    dwResult = (pProtocolCb->pfnAddInterface)(pIcb->pwszName,
                                              pIcb->dwIfIndex,
                                              pIcb->nitProtocolType,
                                              pIcb->dwMediaType,
                                              pIcb->wAccessType,
                                              pIcb->wConnectionType,
                                              pvProtoInfo,
                                              ulStructureVersion,
                                              ulStructureSize,
                                              ulStructureCount);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace3(ERR,
               "AddInterfaceToProtocol: Error %d adding %S to %S",
               dwResult,
               pIcb->pwszName,
               pProtocolCb->pwszDisplayName);

        HeapFree(IPRouterHeap,
                 0,
                 pProto);
    }   
    else
    {
        pProto->pActiveProto = pProtocolCb;
            
        //
        // Mark this block as being added, because of prom.
        // mode, if that is the case
        //
            
        pProto->bPromiscuous = (pvProtoInfo is NULL);
        
        InsertTailList(&(pIcb->leProtocolList),
                       &(pProto->leIfProtoLink));
    }

    return dwResult;
}   

DWORD
DeleteInterfaceFromAllProtocols(
    PICB pIcb
    )

/*++
  
Routine Description

    Deletes the interface from all protocols running on it
    Frees the protocol info on the interface
  
Locks 

    Called with ICB_LIST as WRITER
    Acquires PROTOCOL_CB_LIST as READER

Arguments

    pIcb  ICB of interface

Return Value

    NO_ERROR

--*/

{
    DWORD       i = 0 ;
    PLIST_ENTRY pleNode;
    
    TraceEnter("DeleteInterfaceFromAllProtocols");
    
    //
    // If the router has stopped we do not need to delete the interface
    // from the routing protocol. This is handled before we get here by
    // the UnloadRoutingProtocol()
    //
    
    if (RouterState.IRS_State is RTR_STATE_STOPPED)
    {
        return NO_ERROR;
    }

    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);
    
    
    while(!(IsListEmpty(&(pIcb->leProtocolList))))
    {
        PIF_PROTO  pProto;
        
        pleNode = RemoveHeadList(&(pIcb->leProtocolList));
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);
        
        //
        // Call the routing protocol's deleteinterface entrypoint
        //
        
        (pProto->pActiveProto->pfnDeleteInterface) (pIcb->dwIfIndex);
        
        //
        // Delete this protocol from the list of protocols in the Interface
        //
        
        HeapFree(IPRouterHeap,0,pProto);
    }

    // *** Exclusion End ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    return NO_ERROR;
}


DWORD
DisableInterfaceWithAllProtocols(
    PICB   pIcb
    )
{
    PLIST_ENTRY pleNode;
    DWORD       dwResult,dwReturn = NO_ERROR;

    TraceEnter("DisableInterfaceWithAllProtocols");

    ENTER_READER(PROTOCOL_CB_LIST);

    for(pleNode = pIcb->leProtocolList.Flink;
        pleNode isnot &(pIcb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);

        //
        // Call the routing protocol's DisableInterface() entrypoint
        //
    
        dwResult = (pProto->pActiveProto->pfnInterfaceStatus)(
                        pIcb->dwIfIndex,
                        FALSE,
                        RIS_INTERFACE_DISABLED,
                        NULL
                        );
    
        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR, 
                   "DisableInterfaceWithAllProtocols: Couldnt disable %S with %S. Error %d",
                   pIcb->pwszName,
                   pProto->pActiveProto->pwszDisplayName,
                   dwResult);
            
            dwReturn = ERROR_CAN_NOT_COMPLETE;
        }
    }

    EXIT_LOCK(PROTOCOL_CB_LIST);
   
    return dwReturn;
}


DWORD
EnableInterfaceWithAllProtocols(
    PICB    pIcb
    )
{
    PLIST_ENTRY pleNode;
    DWORD       dwResult, dwReturn = NO_ERROR;

    TraceEnter("EnableInterfaceWithAllProtocols");

    ENTER_READER(PROTOCOL_CB_LIST);
    
    for(pleNode = pIcb->leProtocolList.Flink;
        pleNode isnot &(pIcb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;

        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);

        dwResult = (pProto->pActiveProto->pfnInterfaceStatus)(
                    pIcb->dwIfIndex,
                    (pIcb->dwOperationalState >= CONNECTED),
                    RIS_INTERFACE_ENABLED,
                    NULL
                    );

        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR, 
                   "EnableInterfaceWithAllProtocols: Couldnt enable %S with %S. Error %d",
                   pIcb->pwszName,
                   pProto->pActiveProto->pwszDisplayName,
                   dwResult);
            
            dwReturn = ERROR_CAN_NOT_COMPLETE;

            continue;
        }
    }

    EXIT_LOCK(PROTOCOL_CB_LIST);
    
    return dwReturn;
}

        
VOID
DeleteAllInterfaces(
    VOID
    )
{

    PLIST_ENTRY pleNode ;
    PICB        pIcb ;
    
    TraceEnter("DeleteAllInterfaces");

    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);


    //
    // We do this backwards. Quick hack for fixing OSPF
    //

    //
    // First we unlink the internal interface because if the worker function
    // finds the ICB list non empty, it loops, waiting for the interfaces
    // to get deleted. After all interfaces are deleted it deletes the
    // internal interface
    // Hence we remove the i/f from the list here and decrement the count.
    //

    if(g_pInternalInterfaceCb)
    {
        RemoveEntryList(&(g_pInternalInterfaceCb->leIfLink));

        InterlockedDecrement(&g_ulNumInterfaces);
    }

    if(g_pLoopbackInterfaceCb)
    {
        g_pLoopbackInterfaceCb = NULL;
    }

    for(pleNode = ICBList.Blink; pleNode != &ICBList;) 
    {
        pIcb = CONTAINING_RECORD (pleNode, ICB, leIfLink) ;

        if((pIcb->dwOperationalState is CONNECTED) and
           ((pIcb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
            (pIcb->ritType is ROUTER_IF_TYPE_FULL_ROUTER)))
        {

            MarkInterfaceForDeletion(pIcb);
            
            pleNode = pleNode->Blink;

            continue;
        }
        
        pleNode = pleNode->Blink;

        RemoveInterfaceFromLists(pIcb);

        DeleteSingleInterface(pIcb);      // clean up interface.

        //
        // Free the ICB
        //

        HeapFree(IPRouterHeap, 
                 0, 
                 pIcb);
    }

    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

}

DWORD
DeleteSingleInterface(
    PICB pIcb
    )
{
    PICB_BINDING    pBinding;
    PADAPTER_INFO   pBindNode;
    DWORD           dwResult;
    
    TraceEnter("DeleteSingleInterface");

    if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
    { 
        IpRtAssert(g_pInternalInterfaceCb);
 
        if(pIcb->bBound)
        { 
            PLIST_ENTRY         pleNode;
            IP_LOCAL_BINDING    clientAddr;

            clientAddr.Address = pIcb->pibBindings->dwAddress;
            clientAddr.Mask    = pIcb->pibBindings->dwMask;

#if 0
            //
            // Remove the client host route
            //

            DeleteSingleRoute(g_pInternalInterfaceCb->dwIfIndex,
                              clientAddr.Address,
                              HOST_ROUTE_MASK,
                              clientAddr.Address,
                              MIB_IPPROTO_NETMGMT,
                              FALSE);
#endif

            ENTER_READER(PROTOCOL_CB_LIST);


            //
            // Call ConnectClient for all the protocols configured
            // over the ServerInterface
            //

            for(pleNode = g_pInternalInterfaceCb->leProtocolList.Flink;
                pleNode isnot &(g_pInternalInterfaceCb->leProtocolList);
                pleNode = pleNode->Flink)
            {
                PIF_PROTO   pIfProto;

                pIfProto = CONTAINING_RECORD(pleNode,
                                             IF_PROTO,
                                             leIfProtoLink);

                if(pIfProto->pActiveProto->pfnDisconnectClient)
                {
                    pIfProto->pActiveProto->pfnDisconnectClient(
                        g_pInternalInterfaceCb->dwIfIndex,
                        &clientAddr
                        );
                }
            }

            EXIT_LOCK(PROTOCOL_CB_LIST);

            //
            // Delete static routes from RTM (and the stack)
            //

            DeleteAllClientRoutes(pIcb,
                                  g_pInternalInterfaceCb->dwIfIndex);


            if(pIcb->pStoredRoutes)
            {
                HeapFree(IPRouterHeap,
                         0,
                         pIcb->pStoredRoutes);
        
                pIcb->pStoredRoutes = NULL;
            }

            //
            // Delete the interface from the filter driver
            //

            DeleteFilterInterface(pIcb);

            HeapFree(IPRouterHeap,
                     0,
                     pIcb->pibBindings);

            pIcb->pibBindings = NULL;
        }

        return NO_ERROR;
    }

    if(pIcb->ritType is ROUTER_IF_TYPE_DIALOUT)
    {
        IpRtAssert(pIcb->bBound);

        pBinding = pIcb->pibBindings;

        IpRtAssert(pBinding);

        DeleteAutomaticRoutes(pIcb,
                              pBinding[0].dwAddress,
                              pBinding[0].dwMask);

        DeleteAllRoutes(pIcb->dwIfIndex,
                        FALSE);

        ENTER_WRITER(BINDING_LIST);

#if DBG

        pBindNode = GetInterfaceBinding(pIcb->dwIfIndex);

        IpRtAssert(pBindNode);

#endif // DBG

        RemoveBinding(pIcb);

        EXIT_LOCK(BINDING_LIST);

        HeapFree(IPRouterHeap,
                 0,
                 pBinding);

        pIcb->pibBindings = NULL;

        return NO_ERROR;
    }


    //
    // So at this point we are only dealing with FULL_ROUTER, HOME_ROUTER and
    // DEDICATED type interfaces
    //

    //
    // Delete static routes from RTM (and the stack)
    //

    DeleteAllRoutes(pIcb->dwIfIndex,
                    FALSE);

    //
    // WAN interfaces: bringing down an interface will not delete
    // the binding. Hence we do it here
    //
    
    pBinding    = NULL;
    pBindNode   = NULL;

    if((pIcb->ritType is ROUTER_IF_TYPE_FULL_ROUTER) or
       (pIcb->ritType is ROUTER_IF_TYPE_HOME_ROUTER))
    {
        pBinding    = pIcb->pibBindings;
        pBindNode   = GetInterfaceBinding(pIcb->dwIfIndex);
    }
   
    //
    // Bringing down the interfaces clears out stack contexts
    //

    if((pIcb->ritType is ROUTER_IF_TYPE_DEDICATED) or
       (pIcb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
       (pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1) or
       (pIcb->ritType is ROUTER_IF_TYPE_INTERNAL))
    {
        LanEtcInterfaceUpToDown(pIcb,
                                TRUE);
    }
    else
    {
        WanInterfaceInactiveToDown(pIcb,
                                   TRUE);
    }

    
    //
    // This also frees up the list of IF_PROTO blocks
    //

    DeleteInterfaceFromAllProtocols(pIcb);

    //
    // Now remove the interface from the stack components
    //

    if((pIcb->ritType is ROUTER_IF_TYPE_FULL_ROUTER) or
       (pIcb->ritType is ROUTER_IF_TYPE_HOME_ROUTER) or
       (pIcb->ritType is ROUTER_IF_TYPE_INTERNAL))
    {
        if(pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL)
        {
            DeleteDemandFilterInterface(pIcb);
        }

        DeleteInterfaceWithWanArp(pIcb);
    }

   
    if((pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
       (pIcb->ritType isnot ROUTER_IF_TYPE_LOOPBACK))
    {
        dwResult = DeleteFilterInterface(pIcb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "Error %d deleting %S from the filter driver",
                   dwResult,
                   pIcb->pwszName);
        }
    }

    if(pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwResult = DeleteInterfaceFromIpInIp(pIcb);
                                             

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "Error %d deleting %S from the IpInIp driver",
                   dwResult,
                   pIcb->pwszName);
        }

        RemoveBinding(pIcb);
    }

    //
    // Delete the binding for wan interfaces
    //
    
    if(pBindNode)
    {
        ENTER_WRITER(BINDING_LIST);
        
        RemoveBinding(pIcb);

        EXIT_LOCK(BINDING_LIST);
    }

    if(pBinding)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pBinding);
    }

    if(pIcb->pRtrDiscAdvt)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pIcb->pRtrDiscAdvt);

        pIcb->pRtrDiscAdvt = NULL;
    }

    return NO_ERROR;
}

DWORD
IpIpTunnelDownToUp(
    PICB    pIcb
    )
{
    return NO_ERROR;
}

DWORD
LanEtcInterfaceDownToUp(
    PICB   pIcb,
    BOOL   bAdding
    )

/*++

Routine Description

    The interface's admin state MUST be UP or this function will simply
    return
    
    The interface to adapter map MUST have already been stored before this
    is called

Locks

    ICB_LIST lock held as writer

Arguments

    pIcb    ICB of the interface to bring up
    bAdding Set to TRUE if we are adding the interface (as opposed to bringing
            it up when the admin state changed etc)   

Return Value

    NO_ERROR
    
--*/

{
    DWORD                   dwResult;
    PRESTORE_INFO_CONTEXT   pricInfo;
    
    TraceEnter("LanInterfaceDownToUp");
   
    if(pIcb->dwAdminState isnot IF_ADMIN_STATUS_UP)
    {
        Trace2(ERR,
               "LanInterfaceDownToUp: Tried to bring up %S when its admin state is %d",
               pIcb->pwszName,
               pIcb->dwAdminState);

        return ERROR_INVALID_PARAMETER;
    }
 
    //
    // Read the address from the registry for LAN interfaces. This function
    // is also called for the INTERNAL interface, whose address is already
    // plumbed by the time it is called and for TUNNEL which currently
    // run in unnumbered mode
    //

    if(pIcb->ritType is ROUTER_IF_TYPE_DEDICATED)
    {
        IpRtAssert(!pIcb->bBound);
        IpRtAssert(pIcb->dwNumAddresses is 0);

        CheckBindingConsistency(pIcb);
    
        dwResult = UpdateBindingInformation(pIcb);
   
        if(dwResult isnot NO_ERROR)
        {
            //
            // UpdateBindingInf can return ERROR_ALREADY_ASSOC, 
            // but since we have asserted earlier that we dont have
            // an address, that error only means we still dont have an
            // address
            //

            if(dwResult isnot ERROR_ADDRESS_ALREADY_ASSOCIATED)
            {
                Trace1(ERR,
                       "LanInterfaceDownToUp: Couldnt read binding information for %S",
                       pIcb->pwszName);
            }
       
            pIcb->dwOperationalState = IF_OPER_STATUS_NON_OPERATIONAL;
        
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    IpRtAssert(pIcb->bBound);

    if(pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL)
    {
        pIcb->dwOperationalState = IF_OPER_STATUS_OPERATIONAL;
    }
    else
    {
        pIcb->dwOperationalState = IF_OPER_STATUS_CONNECTED;
    }

    //
    // First do the generic interface to up stuff
    //
    
    GenericInterfaceComingUp(pIcb);

    //
    // We restore routes even when this function is being called from
    // add interface, because that is the only way to pick up stack
    // routes
    //

    pricInfo = HeapAlloc(IPRouterHeap,
                         0,
                         sizeof(RESTORE_INFO_CONTEXT));

    if(pricInfo isnot NULL)
    {
        pricInfo->dwIfIndex     = pIcb->dwIfIndex;

        pIcb->bRestoringRoutes  = TRUE;

        dwResult = QueueAsyncFunction(RestoreStaticRoutes,
                                      (PVOID)pricInfo,
                                      FALSE);

        if(dwResult isnot NO_ERROR)
        {
            pIcb->bRestoringRoutes = FALSE;

            IpRtAssert(FALSE);

            Trace2(ERR,
                   "LanInterfaceDownToUp: Error %d queueing function for %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }
    else
    {
        IpRtAssert(FALSE);

        Trace1(ERR,
               "LanInterfaceDownToUp: Error allocating context for %S",
               pIcb->pwszName);
    }   

    return NO_ERROR;
}

DWORD
WanInterfaceInactiveToUp(
    PICB   pIcb
    )

/*++

Routine Description

    This function does things slighlty differently from above because, for
    one, there is no UpdateBindingInfo() call for such adapters

Locks

    

Arguments

    

Return Value


--*/

{
    PRESTORE_INFO_CONTEXT pricInfo;
    DWORD                 dwResult;
    INTERFACE_ROUTE_INFO  rifRoute;
    
    TraceEnter("WanInterfaceInactiveToUp");

    CheckBindingConsistency(pIcb);
    
    Trace1(IF,
           "WanInterfaceInactiveToUp: %S coming up",
           pIcb->pwszName);

    //
    // quick look up of interface given the adapter index.
    // This is done in UpdateBindingInfo for LAN interfaces.
    //

    //StoreAdapterToInterfaceMap(pIcb->dwAdapterId, 
    //                           pIcb->dwIfIndex);
    

    //
    // First do the generic thing
    //
    
    GenericInterfaceComingUp(pIcb);

    //
    // Delete all static routes.  These will be re-added
    // by RestoreStaticRoutes (below) with the correct next hop
    //

    DeleteAllRoutes(pIcb->dwIfIndex, TRUE);

    //
    // Restore all static and NON-Dod routes on this interface
    //

    pricInfo = HeapAlloc(IPRouterHeap,
                         0,
                         sizeof(RESTORE_INFO_CONTEXT));

    if(pricInfo isnot NULL)
    {
        pricInfo->dwIfIndex     = pIcb->dwIfIndex;

        pIcb->bRestoringRoutes  = TRUE;

        dwResult = QueueAsyncFunction(RestoreStaticRoutes,
                                      (PVOID)pricInfo,
                                      FALSE);

        if(dwResult isnot NO_ERROR)
        {
            pIcb->bRestoringRoutes = FALSE;

            IpRtAssert(FALSE);

            Trace2(ERR,
                   "WanInterfaceInactiveToUp: Error %d queueing function for %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }
    else
    {
        IpRtAssert(FALSE);

        Trace1(ERR,
               "WanInterfaceInactiveToUp: Error allocating context for %S",
               pIcb->pwszName);
    }   

    //
    // Change Static route so that it uses the correct adapter index
    //
    
    // ChangeAdapterIndexForDodRoutes(pIcb->dwIfIndex);

    //
    // Add a host route for the remote side
    //
    
    if(pIcb->dwRemoteAddress isnot INVALID_IP_ADDRESS)
    {
        rifRoute.dwRtInfoMask          = HOST_ROUTE_MASK;
        rifRoute.dwRtInfoNextHop       = pIcb->pibBindings[0].dwAddress;
        rifRoute.dwRtInfoDest          = pIcb->dwRemoteAddress;
        rifRoute.dwRtInfoIfIndex       = pIcb->dwIfIndex;
        rifRoute.dwRtInfoMetric1       = 1;
        rifRoute.dwRtInfoMetric2       = 0;
        rifRoute.dwRtInfoMetric3       = 0;
        rifRoute.dwRtInfoPreference    = 
            ComputeRouteMetric(MIB_IPPROTO_NETMGMT);
        rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                          RTM_VIEW_MASK_MCAST; // XXX config
        rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
        rifRoute.dwRtInfoProto         = MIB_IPPROTO_NETMGMT;
        rifRoute.dwRtInfoAge           = 0;
        rifRoute.dwRtInfoNextHopAS     = 0;
        rifRoute.dwRtInfoPolicy        = 0;
        
        dwResult = AddSingleRoute(pIcb->dwIfIndex,
                                  &rifRoute,
                                  pIcb->pibBindings[0].dwMask,
                                  0,        // RTM_ROUTE_INFO::Flags
                                  TRUE,     // Valid route 
                                  TRUE,
                                  TRUE,
                                  NULL);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "WanInterfaceInactiveToUp: Couldnt add host route for %x",
                   pIcb->dwRemoteAddress);
        }
    }

    return NO_ERROR;
}


DWORD
GenericInterfaceComingUp(
    PICB   pIcb
    )

/*++

Routine Description

    This function has the common code for bringing up an interface.
    It assumes that the interface is bound.

    If NAT is running and we have an address (not unnumbered) we add the
    address to NAT.
    We activate router discovery and multicast heartbeat (if they are present)
    Then we add
        (i)   local loopback
        (ii)  local multicast
        (iii) all subnets broadcast
        (iv)  all 1's broadcast
    routes
    Then we call out to the routing protocols and the filter driver to inform
    them of the binding
    
Locks

    ICB_LIST lock held as WRITER

Arguments

    pIcb    ICB of the interface to bring up

Return Value


--*/

{
    DWORD               dwResult, i;
    MIB_IPFORWARDROW    rifRoute;
    PADAPTER_INFO       pBinding;
    
    TraceEnter("GenericInterfaceComingUp");
    
    Trace1(IF,
           "GenericInterfaceComingUp: %S coming UP",
           pIcb->pwszName);

    // Join the All-Routers multicast group

    {
        extern SOCKET McMiscSocket;

        Trace1(IF,
               "CreateSockets: Joining ALL_ROUTERS on %S",
               pIcb->pwszName);
    
        if ( McJoinGroupByIndex( McMiscSocket, 
                                 SOCK_RAW, 
                                 ALL_ROUTERS_MULTICAST_GROUP,
                                 pIcb->dwIfIndex ) is SOCKET_ERROR )
        {
            Trace2(ERR,
                   "GenericInterfaceComingUp: Error %d joining all-routers group on %S",
                   WSAGetLastError(),
                   pIcb->pwszName);
        }
    }
   
    //
    // Start router discovery on this interface. This will cause
    // the advertisement to get updated
    //
    
    dwResult = ActivateRouterDiscovery(pIcb);

        
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "GenericInterfaceComingUp: Error %d activating router discovery on %S",
               dwResult,
               pIcb->pwszName);
    }

    dwResult = ActivateMHeartbeat(pIcb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "GenericInterfaceComingUp: Error %d activating router discovery on %S",
               dwResult,
               pIcb->pwszName);
    }

    //
    // Add default routes for the connected network 
    //

    for(i = 0; i < pIcb->dwNumAddresses; i++)
    {
        if(pIcb->pibBindings[i].dwAddress is INVALID_IP_ADDRESS)
        {
            continue;
        }

        AddAutomaticRoutes(pIcb,
                           pIcb->pibBindings[i].dwAddress,
                           pIcb->pibBindings[i].dwMask);
        
    }

    //
    // Interfaces going to UP must have valid binding information.
    // This is passed to the routing protocols
    //
    
    BindInterfaceInAllProtocols(pIcb);
   
    // Set Multicast limits in stack

    ActivateMcastLimits(pIcb);

    for (i=0; i<NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnBindInterface)
        {
            continue;
        }

        dwResult = g_rgicInfoCb[i].pfnBindInterface(pIcb);

        if (dwResult isnot NO_ERROR)
        {
            Trace3(ERR,
                   "GenericInterfaceComingUp: Error %d binding %S for %s info",
                   dwResult,
                   pIcb->pwszName,
                   g_rgicInfoCb[i].pszInfoName);
        }
    }

    return NO_ERROR ;
}


DWORD
LanEtcInterfaceUpToDown(
    PICB pIcb,
    BOOL bDeleted
    )

/*++

Routine Description

    This function is called when a LAN, INTERNAL or LOOPBACK interface goes
    down.

    If the interface is not being deleted, we delete all the static routes.
    We then disable the interface with the routing protocols and call
    the generic routing to handle all the rest
    
Locks

    ICB_LOCK held as WRITER

Arguments

    pIcb
    bDeleted

Return Value

    None    

--*/

{
    DWORD   i,dwResult;

    TraceEnter("LanInterfaceUpToDown");

    if(!bDeleted)
    {
        DeleteAllRoutes(pIcb->dwIfIndex,
                        FALSE);
    }

    GenericInterfaceNoLongerUp(pIcb,
                               bDeleted);

    pIcb->dwOperationalState = IF_OPER_STATUS_NON_OPERATIONAL;

    return NO_ERROR;
}

DWORD
WanInterfaceUpToInactive(
    PICB   pIcb,
    BOOL   bDeleted
    )
{
    DWORD                   dwResult;
    PRESTORE_INFO_CONTEXT   pricInfo;
    

    TraceEnter("WanInterfaceUpToInactive");

    //
    // Delete the route before deallocating the address (which is called in
    // GenericInterfaceNoLongerUp), because that will set Remote addr to
    // invalid and then this route will never be deleted
    //
   
    CheckBindingConsistency(pIcb);

    //
    // If it was up, it should be bound
    //

    IpRtAssert(pIcb->bBound);
    
    if(!bDeleted and
       (pIcb->dwRemoteAddress isnot INVALID_IP_ADDRESS))
    {
        dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                     pIcb->dwRemoteAddress,
                                     HOST_ROUTE_MASK,
                                     pIcb->pibBindings[0].dwAddress,
                                     PROTO_IP_NETMGMT,
                                     TRUE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "WanInterfaceUpToInactive: Couldnt delete host route for %d.%d.%d.%d",
                   PRINT_IPADDR(pIcb->dwRemoteAddress));
        }
    }

    
    GenericInterfaceNoLongerUp(pIcb,
                               bDeleted);

    if(!bDeleted)
    {
#if 1
        //
        // Delete all static routes/nexthops
        //

        DeleteAllRoutes(pIcb->dwIfIndex, FALSE);


/*
        //
        // Delete all netmgmt routes/nexthops
        //
        
        dwResult = DeleteRtmRoutes(g_hNetMgmtRoute, pIcb->dwIfIndex, FALSE);

        if (dwResult is NO_ERROR)
        {
            dwResult = DeleteRtmNexthopsOnInterface(
                        g_hNetMgmtRoute, pIcb->dwIfIndex
                        );
            if (dwResult isnot NO_ERROR)
            {
                Trace1(
                    ERR,
                    "WanInterfaceUpToInactive: Couldnt delete next hops for "
                    "Interface 0x%x",
                     pIcb->dwIfIndex
                     );
            }
        }
*/
        //
        // Restore all static and NON-Dod routes on this interface
        //

        pricInfo = HeapAlloc(
                    IPRouterHeap, 0, sizeof(RESTORE_INFO_CONTEXT)
                    );

        if(pricInfo isnot NULL)
        {
            pricInfo->dwIfIndex     = pIcb->dwIfIndex;

            pIcb->bRestoringRoutes  = TRUE;

            dwResult = QueueAsyncFunction(RestoreStaticRoutes,
                                          (PVOID)pricInfo,
                                          FALSE);

            if(dwResult isnot NO_ERROR)
            {
                pIcb->bRestoringRoutes = FALSE;

                IpRtAssert(FALSE);

                Trace2(ERR,
                       "WanInterfaceUpToInactive: Error %d queueing"
                       " function for %S",
                       dwResult,
                       pIcb->pwszName);
            }
        }
        else
        {
            IpRtAssert(FALSE);

            Trace1(ERR,
                   "WanInterfaceInactiveToUp: Error allocating context for %S",
                   pIcb->pwszName);
        }   

#else
        //
        // Delete all NON-Dod, Netmgmt routes on this interface
        //
        
        DeleteRtmRoutes(g_hNonDodRoute,  pIcb->dwIfIndex, FALSE);
        DeleteRtmRoutes(g_hNetMgmtRoute, pIcb->dwIfIndex, FALSE);

        ChangeAdapterIndexForDodRoutes(pIcb->dwIfIndex);
#endif
    }

    pIcb->dwOperationalState = IF_OPER_STATUS_DISCONNECTED;
 
    return NO_ERROR;
}
    
DWORD
GenericInterfaceNoLongerUp(
    PICB pIcb,
    BOOL bDeleted
    )

/*++

Routine Description

    This function is called by all interfaces (other than CLIENT) when
    they go to DOWN state (The actual state depends upon the interface). This
    may happen because of state change or because the interface is being
    deleted

    If we are not deleting the interface, we delete all the automatically
    generated routes

    We deactivate router discovery and multicast hearbeat.
    If NAT is running, we remove the FIREWALL context for the interface
    from IP and THEN unbind the address in NAT
    (This MUST be done in this order)

    Then we Unbind the interface in the routing protocols running over it.
    We delete the Adapter->Interface map, deallocate the bindings (which does
    different things depending on LAN/WAN) and if there is a DIM event we
    set the event

Locks

    ICB_LIST lock held as WRITER

Arguments

    pIcb     ICB of the interface
    bDeleted Set to TRUE if the state change is because of deletion

Return Value

    None    

--*/

{
    DWORD           dwResult;
    DWORD           i, j;

    TraceEnter("GenericInterfaceNoLongerUp");

    Trace1(IF,
           "GenericInterfaceNoLongerUp: %S no longer UP",
           pIcb->pwszName);

    if(pIcb->bMcastEnabled)
    {
        pIcb->bMcastEnabled = FALSE;

        dwResult = SetMcastOnIf(pIcb,
                                FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GenericIfNoLongerUp: Error %d deactivating mcast on %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }

    if(!bDeleted)
    {
        for (i = 0; i < pIcb->dwNumAddresses; i++)
        {
            if(pIcb->pibBindings[i].dwAddress isnot INVALID_IP_ADDRESS)
            {
                DeleteAutomaticRoutes(pIcb,
                                      pIcb->pibBindings[i].dwAddress,
                                      pIcb->pibBindings[i].dwMask);
            }
        }
    }
   
    //
    // Delete any gateways on this
    //

    for(i = 0; i < g_ulGatewayMaxCount; i++)
    {
        if(g_pGateways[i].dwIfIndex is pIcb->dwIfIndex)
        {
            g_pGateways[i].dwAddress = 0;
        }
    }

    //
    // Compress the array
    //

    for(i = 0, j = 1; j < g_ulGatewayMaxCount;j++)
    {
        if(g_pGateways[i].dwAddress isnot 0)
        {
            i++;
        }
        else
        {
            if(g_pGateways[j].dwAddress isnot 0)
            {
                g_pGateways[i] = g_pGateways[j];

                g_pGateways[j].dwAddress = 0;

                i++;
            }
        }
    }

    g_ulGatewayCount = i;

    dwResult = DeActivateRouterDiscovery(pIcb);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "GenericInterfaceNoLongerUp: Error %d deactivating router discovery on %S",
               dwResult,
               pIcb->pwszName);
    }

    dwResult = DeActivateMHeartbeat(pIcb);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "GenericInterfaceNoLongerUp: Error %d deactivating multicast heartbeat on %S",
               dwResult,
               pIcb->pwszName);
    }
   
    if((pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
       (pIcb->ritType isnot ROUTER_IF_TYPE_LOOPBACK))
    {
        UnbindFilterInterface(pIcb);
    }

    //
    // When going out of UP state, the interface loses its address
    //
   
    UnbindInterfaceInAllProtocols(pIcb);

    //if(pIcb->pibBindings) 
    //{
    //    DeleteAdapterToInterfaceMap(pIcb->dwAdapterId) ;
    //}
    
    DeAllocateBindings(pIcb);

    if(pIcb->hDIMNotificationEvent isnot NULL)
    {
        //
        // There was an update pending. Set the event, when the user asks us
        // for info, we will fail the request
        //
        
        if(!SetEvent(pIcb->hDIMNotificationEvent))
        {
            Trace1(ERR,
                   "GenericInterfaceNoLongerUp: Error %d setting update route event",
                   GetLastError());
        }

        CloseHandle(pIcb->hDIMNotificationEvent);

        pIcb->hDIMNotificationEvent = NULL;

    }
    
    return NO_ERROR ;
}

DWORD
WanInterfaceInactiveToDown(
    PICB pIcb,
    BOOL bDeleted
    )
{
    TraceEnter("WanInterfaceInactiveToDown");

    CheckBindingConsistency(pIcb);
    
    IpRtAssert(!pIcb->bBound);
    
    if(!bDeleted)
    { 
        DeleteAllRoutes(pIcb->dwIfIndex,
                        FALSE);
    }

    pIcb->dwOperationalState = UNREACHABLE;

    //DisableInterfacewithWanArp(pIcb);
    
    return NO_ERROR;
}

DWORD
WanInterfaceDownToInactive(
    PICB pIcb
    )
{
    PRESTORE_INFO_CONTEXT   pricInfo;
    DWORD                   dwResult;
    PADAPTER_INFO           pBinding;

    TraceEnter("WanInterfaceDownToInactive");

#if STATIC_RT_DBG

    ENTER_WRITER(BINDING_LIST);

    pBinding = GetInterfaceBinding(pIcb->dwIfIndex);

    pBinding->bUnreach = FALSE;

    EXIT_LOCK(BINDING_LIST);

#endif

    //
    // Set the state before calling restore
    //

    pIcb->dwOperationalState = DISCONNECTED;

    pricInfo = HeapAlloc(IPRouterHeap,
                         0,
                         sizeof(RESTORE_INFO_CONTEXT));

    if(pricInfo isnot NULL)
    {
        pricInfo->dwIfIndex     = pIcb->dwIfIndex;

        pIcb->bRestoringRoutes  = TRUE;

        dwResult = QueueAsyncFunction(RestoreStaticRoutes,
                                      (PVOID)pricInfo,
                                      FALSE);

        if(dwResult isnot NO_ERROR)
        {
            pIcb->bRestoringRoutes = FALSE;

            IpRtAssert(FALSE);

            Trace2(ERR,
                   "WanInterfaceDownToInactive: Error %d queueing function for %S",
                   dwResult,
                   pIcb->pwszName);

            HeapFree(
                IPRouterHeap,
                0,
                pricInfo
                );
        }
    }
    else
    {
        IpRtAssert(FALSE);

        Trace1(ERR,
               "WanInterfaceDownToInactive: Error allocating context for %S",
               pIcb->pwszName);
    }   
    
    return NO_ERROR;
}
      
DWORD
GetInterfaceStatusInfo(
    IN     PICB                   pIcb,
    IN     PRTR_TOC_ENTRY         pToc,
    IN     PBYTE                  pbDataPtr,
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    )
{
    PINTERFACE_STATUS_INFO  pisiInfo;

    TraceEnter("GetInterfaceStatusInfo");
    
    if(*pdwInfoSize < sizeof(INTERFACE_STATUS_INFO))
    {
        *pdwInfoSize = sizeof(INTERFACE_STATUS_INFO);
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pdwInfoSize    = sizeof(INTERFACE_STATUS_INFO);
    
    //pToc->InfoVersion sizeof(INTERFACE_STATUS_INFO);
    pToc->InfoSize  = sizeof(INTERFACE_STATUS_INFO);
    pToc->InfoType  = IP_INTERFACE_STATUS_INFO;
    pToc->Count     = 1;
    pToc->Offset    = (ULONG)(pbDataPtr - (PBYTE) pInfoHdr) ;

    pisiInfo = (PINTERFACE_STATUS_INFO)pbDataPtr;

    pisiInfo->dwAdminStatus         = pIcb->dwAdminState;
    
    return NO_ERROR;
}
    
DWORD
SetInterfaceStatusInfo(
    PICB                     pIcb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    )
{
    PINTERFACE_STATUS_INFO  pisiInfo;
    PRTR_TOC_ENTRY          pToc;
    DWORD                   dwResult;
    
    TraceEnter("SetInterfaceStatusInfo");

    
    pToc = GetPointerToTocEntry(IP_INTERFACE_STATUS_INFO, pInfoHdr);

    if((pToc is NULL) or
       (pToc->InfoSize is 0))
    {
        //
        // No TOC means no change. Also empty TOC means no change (IN THIS
        // ONE CASE ONLY)
        //

        return NO_ERROR;
    }


    pisiInfo = (PINTERFACE_STATUS_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                           pToc);

    if (pisiInfo is NULL)
    {
        //
        // no info block means no change.
        //

        return NO_ERROR;
    }
    
    dwResult = SetInterfaceAdminStatus(pIcb,
                                       pisiInfo->dwAdminStatus);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetInterfaceStatusInfo: Error %d setting admin status for %S",
               dwResult,
               pIcb->pwszName);
    }

    return dwResult;
}
    
VOID
DeAllocateBindings(
    PICB  pIcb
    )
{
    PADAPTER_INFO pBinding;
    
    TraceEnter("DeAllocateBindings");

    ENTER_WRITER(BINDING_LIST);

    //
    // For LAN interfaces we remove the binding from the
    // list and free the addresses
    // For WAN  and IPIP tunnel interfaces, to avoid allocations when 
    // connections are coming up and down, we zero out the fields and keep 
    // the memory around. Which means we need to free the memory and the 
    // binding when the interface is deleted
    //
    
    if((pIcb->ritType is ROUTER_IF_TYPE_DEDICATED) or
       (pIcb->ritType is ROUTER_IF_TYPE_INTERNAL) or
       (pIcb->ritType is ROUTER_IF_TYPE_LOOPBACK))
    {
        if(pIcb->bBound)
        {
            //
            // These can not be unnumbered
            //

            IpRtAssert(pIcb->dwNumAddresses isnot 0);
            IpRtAssert(pIcb->pibBindings);

            RemoveBinding(pIcb);
            
            HeapFree(IPRouterHeap, 0, pIcb->pibBindings);

            pIcb->pibBindings     = NULL;
            pIcb->dwNumAddresses  = 0;
            pIcb->bBound          = FALSE;
            pIcb->dwRemoteAddress = INVALID_IP_ADDRESS;
        }
    }
    else
    {
        pBinding = GetInterfaceBinding(pIcb->dwIfIndex);

        if (pBinding) {
            IpRtAssert(pBinding isnot NULL);
        
            pIcb->bBound        = FALSE;
            pBinding->bBound    = FALSE;

            pIcb->dwNumAddresses      = 0;
            pBinding->dwNumAddresses  = 0;
        
            pIcb->dwRemoteAddress     = INVALID_IP_ADDRESS;
            pBinding->dwRemoteAddress = INVALID_IP_ADDRESS;
        
            pIcb->pibBindings[0].dwAddress     = INVALID_IP_ADDRESS;
            pIcb->pibBindings[0].dwMask        = INVALID_IP_ADDRESS;
            pBinding->rgibBinding[0].dwAddress = INVALID_IP_ADDRESS;
            pBinding->rgibBinding[0].dwMask    = INVALID_IP_ADDRESS;

            g_LastUpdateTable[IPADDRCACHE] = 0;
        }
    }

    EXIT_LOCK(BINDING_LIST);

}

DWORD 
GetInterfaceStatistics(
    IN   PICB       pIcb, 
    OUT  PMIB_IFROW pOutBuffer
    )
{
    DWORD           dwResult;

    dwResult = NO_ERROR;
    
    TraceEnter("GetInterfaceStatistics");

    switch(pIcb->ritType)
    {
        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
        {
            dwResult = AccessIfEntryWanArp(ACCESS_GET,
                                           pIcb,
                                           pOutBuffer);

            pOutBuffer->dwIndex        = pIcb->dwIfIndex;

            wcscpy(pOutBuffer->wszName, pIcb->pwszName);

            pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
            pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;
       
            strncpy(pOutBuffer->bDescr,
                    g_rgcWanString,
                    MAXLEN_IFDESCR - 1);

            pOutBuffer->dwDescrLen =
                min((MAXLEN_IFDESCR-1),strlen(g_rgcWanString));

            pOutBuffer->bDescr[MAXLEN_IFDESCR -1] = '\0';
 
            break;
        }
            
        case ROUTER_IF_TYPE_DEDICATED:
        case ROUTER_IF_TYPE_TUNNEL1:
        case ROUTER_IF_TYPE_DIALOUT:
        {
            //
            // A Lan Interface that is up
            //
            
            dwResult = GetIfEntryFromStack(pOutBuffer,
                                           pIcb->dwIfIndex,
                                           FALSE);
            
            if(dwResult is NO_ERROR)
            {
                IpRtAssert(pOutBuffer->dwIndex is pIcb->dwIfIndex);

                //
                // Copy out the name too
                //
                
                wcscpy(pOutBuffer->wszName, pIcb->pwszName);

                //
                // Set the user mode status
                //
                
                pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;

                //
                // Till the notification from ipinip to router is done
                // pass the driver status back for tunnels
                //pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

                if(pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1)
                {
                    strncpy(pOutBuffer->bDescr,
                            g_rgcIpIpString,
                            MAXLEN_IFDESCR - 1);

                    pOutBuffer->dwDescrLen =
                        min((MAXLEN_IFDESCR-1),
                            strlen(g_rgcIpIpString));

                    pOutBuffer->bDescr[MAXLEN_IFDESCR -1] = '\0';

                }
                else
                {
                    pOutBuffer->dwOperStatus = pIcb->dwOperationalState;
                }
            }
            
            break;
        }
        
        case ROUTER_IF_TYPE_INTERNAL:
        {
            
            pOutBuffer->dwIndex = pIcb->dwIfIndex;
            
            wcscpy(pOutBuffer->wszName, pIcb->pwszName);

            pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
            pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

            strncpy(pOutBuffer->bDescr,
                    g_rgcInternalString,
                    MAXLEN_IFDESCR - 1);

            pOutBuffer->dwDescrLen =
                min((MAXLEN_IFDESCR-1),strlen(g_rgcInternalString));

            pOutBuffer->bDescr[MAXLEN_IFDESCR -1] = '\0';

            pOutBuffer->dwType = IF_TYPE_PPP;

            dwResult = NO_ERROR;
            
            break;
        }
        
        case ROUTER_IF_TYPE_LOOPBACK:
        {
            
            pOutBuffer->dwIndex = pIcb->dwIfIndex;
            wcscpy(pOutBuffer->wszName, pIcb->pwszName);

            pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
            pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

            strncpy(pOutBuffer->bDescr,
                    g_rgcLoopbackString,
                    MAXLEN_IFDESCR - 1);

            pOutBuffer->dwDescrLen =
                min((MAXLEN_IFDESCR-1),strlen(g_rgcLoopbackString));

            pOutBuffer->bDescr[MAXLEN_IFDESCR - 1] = '\0';

            pOutBuffer->dwType  = IF_TYPE_SOFTWARE_LOOPBACK;
            pOutBuffer->dwMtu   = 32768;
            pOutBuffer->dwSpeed = 10000000;

            dwResult = NO_ERROR;
            
            break;
        }

        case ROUTER_IF_TYPE_CLIENT:
        {
            RtlZeroMemory(pOutBuffer,
                          sizeof(MIB_IFROW));

            pOutBuffer->dwIndex        = pIcb->dwIfIndex;

            wcscpy(pOutBuffer->wszName, pIcb->pwszName);

            pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
            pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

            pOutBuffer->dwType     = IF_TYPE_PPP;

            dwResult = NO_ERROR;
        }

        default:
        {
            IpRtAssert(FALSE);
        }
    }

    if((dwResult isnot NO_ERROR) and
       ((pIcb->dwOperationalState is NON_OPERATIONAL) or
        (pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN)))
    {
        RtlZeroMemory(pOutBuffer,
                      sizeof(MIB_IFROW));

        pOutBuffer->dwIndex        = pIcb->dwIfIndex;

        wcscpy(pOutBuffer->wszName, pIcb->pwszName);

        pOutBuffer->dwAdminStatus  = pIcb->dwAdminState;
        pOutBuffer->dwOperStatus   = pIcb->dwOperationalState;

        if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
        {
            pOutBuffer->dwType     = IF_TYPE_PPP;
        }
        else
        {
            if(pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1)
            {
                strncpy(pOutBuffer->bDescr,
                        g_rgcIpIpString,
                        MAXLEN_IFDESCR - 1);

                pOutBuffer->dwDescrLen =
                    min((MAXLEN_IFDESCR-1),
                        strlen(g_rgcIpIpString));

                pOutBuffer->bDescr[MAXLEN_IFDESCR -1] = '\0';

                pOutBuffer->dwType     = IF_TYPE_TUNNEL;
            }

            pOutBuffer->dwType     = IF_TYPE_OTHER;
        }

        dwResult = NO_ERROR;
    }


    return dwResult;
}



DWORD 
SetInterfaceStatistics(
    IN PICB pIcb, 
    IN PMIB_IFROW lpInBuffer 
    )
{
    DWORD dwResult = NO_ERROR;

    TraceEnter("SetInterfaceStatistics");

    dwResult = SetInterfaceAdminStatus(pIcb,
                                       lpInBuffer->dwAdminStatus);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetInterfaceStatistics: Error %d setting admin status for %S",
               dwResult,
               pIcb->pwszName);
    }

    return dwResult;
}

DWORD
SetInterfaceAdminStatus(
    IN PICB     pIcb, 
    IN DWORD    dwAdminStatus
    )
{
    DWORD   dwResult;

    TraceEnter("SetInterfaceAdminStatus");
        
    //
    // Not allowed to set to TESTING in NT
    //

    CheckBindingConsistency(pIcb);
    
    if(!((dwAdminStatus is IF_ADMIN_STATUS_DOWN) or
         (dwAdminStatus is IF_ADMIN_STATUS_UP)))
    {

        return ERROR_INVALID_PARAMETER;
    }
    
    dwResult = NO_ERROR;
    
    if((pIcb->dwAdminState is IF_ADMIN_STATUS_UP) and
       (dwAdminStatus is IF_ADMIN_STATUS_DOWN))
    {
        //
        // Going from up to down
        //

        dwResult = InterfaceAdminStatusSetToDown(pIcb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetInterfaceAdminStatus: Error %d bringing down %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }

    
    if((pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN) and
       (dwAdminStatus is IF_ADMIN_STATUS_UP))
    {
        //
        // Going from down to up
        //

        dwResult = InterfaceAdminStatusSetToUp(pIcb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetInterfaceAdminStatus: Error %d bringing up %S",
                   dwResult,
                   pIcb->pwszName);
        }
    }
    

    //
    // Check the state after you leave
    //

    CheckBindingConsistency(pIcb);
    
    //
    // All other cases, no change
    //
    
    return dwResult;
}

DWORD
InterfaceAdminStatusSetToUp(
    IN  PICB    pIcb
    )
{
    DWORD       dwResult;
    MIB_IFROW   riInBuffer;

    TraceEnter("InterfaceAdminStatusSetToUp");
    
    riInBuffer.dwIndex       = pIcb->dwIfIndex;
    riInBuffer.dwAdminStatus = IF_ADMIN_STATUS_UP;

    //
    // Going from Down to UP
    //

    dwResult = NO_ERROR;

    //
    // Set the state to UP first so that any functions that checks it sees that
    // we want to be up
    //
    
    pIcb->dwAdminState = IF_ADMIN_STATUS_UP;
    
    switch(pIcb->ritType)
    {
        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
        {
            //
            // Couldnt be in down state and have been connecting or
            // connected
            //
            
            IpRtAssert((pIcb->dwOperationalState isnot CONNECTING) and
                       (pIcb->dwOperationalState isnot CONNECTED));
           

            dwResult = AccessIfEntryWanArp(ACCESS_SET,
                                           pIcb,
                                           &riInBuffer);
            
            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToUp: Couldnt set IFEntry for %S",
                       pIcb->pwszName);

                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;
            }   
            else
            {
                WanInterfaceDownToInactive(pIcb);
            }
            
            break;
        }

        case ROUTER_IF_TYPE_DEDICATED:
        case ROUTER_IF_TYPE_TUNNEL1:
        {
            //
            // Bring the stuff up in stack
            // We need to set to stack before we add routes etc
            //

            riInBuffer.dwIndex = pIcb->dwIfIndex;

            //
            // Force an update
            //
            
            dwResult = SetIfEntryToStack(&riInBuffer,
                                         TRUE);
            
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "InterfaceAdminStatusSetToDown: Couldnt set IFEntry for %S. Error %d",
                       pIcb->pwszName,
                       dwResult);

                LanEtcInterfaceUpToDown(pIcb,
                                        FALSE);

                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;

                dwResult = ERROR_CAN_NOT_COMPLETE;

                break;
            }

            dwResult = LanEtcInterfaceDownToUp(pIcb,
                                               FALSE);

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToUp: Error %d bringing up LanInterface",
                       dwResult);
                
                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;
            }

            break;
        }
        
        default:
        {
            // TBD: Handle other types too

            Trace1(ERR,
                   "InterfaceAdminStatusSetToUp: Tried to set status for %S",
                   pIcb->pwszName);
            
            break;
        }
    }
 
    //
    // If we succeeded in setting status, let DIM know
    //
 
    if(dwResult is NO_ERROR)
    {
        IpRtAssert(pIcb->dwAdminState is IF_ADMIN_STATUS_UP);

        EnableInterfaceWithAllProtocols(pIcb);
        
        EnableInterfaceWithDIM(pIcb->hDIMHandle,
                               PID_IP,
                               TRUE);
    }

    return dwResult;
}

DWORD
InterfaceAdminStatusSetToDown(
    IN  PICB    pIcb
    )
{
    DWORD           dwResult;
    MIB_IFROW       riInBuffer;
    
    TraceEnter("InterfaceAdminStatusSetToDown");
    
    riInBuffer.dwIndex       = pIcb->dwIfIndex;
    riInBuffer.dwAdminStatus = IF_ADMIN_STATUS_DOWN;
    
    //
    // Going from up to down
    //
       
    dwResult = NO_ERROR;

    switch(pIcb->ritType)
    {
        case ROUTER_IF_TYPE_DEDICATED:
        case ROUTER_IF_TYPE_TUNNEL1:
        {
            //
            // A Lan Interface that is up or non operational. We can only go
            // to stack if we have an IP Address
            //
          
            if(pIcb->bBound)
            {
                riInBuffer.dwIndex = pIcb->dwIfIndex;

                //
                // Force an update
                //
            
                dwResult = SetIfEntryToStack(&riInBuffer,
                                             TRUE);
            }
                
            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToDown: Couldnt set IFEntry for %S",
                       pIcb->pwszName);
            }
            else
            {
                LanEtcInterfaceUpToDown(pIcb,
                                        FALSE);
                
                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;
            }

            break;
        }
            
        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
        {
            //
            // A Wan Interface that is down.We need to disable
            // the interface and set the status in WANARP
            //

            if((pIcb->dwOperationalState is CONNECTED) or
               (pIcb->dwOperationalState is CONNECTING))
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToDown: Can set %S down since it is a connected WAN interface",
                       pIcb->pwszName);

                dwResult = ERROR_INVALID_DATA;

                break;
            }
                
            dwResult = AccessIfEntryWanArp(ACCESS_SET,
                                           pIcb,
                                           &riInBuffer);
                
            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InterfaceAdminStatusSetToDown: Couldnt set IFEntry for %S",
                       pIcb->pwszName);
            }
            else
            {
                WanInterfaceInactiveToDown(pIcb,
                                           FALSE);
                    
                pIcb->dwAdminState = IF_ADMIN_STATUS_DOWN;
            }

            break;
        }

        default:
        {
            Trace1(ERR,
                   "InterfaceAdminStatusSetToDown: Tried to set status for %S",
                   pIcb->pwszName);

            break;
        }
            
    }

    //
    // If we succeeded in setting status, let DIM know
    //

    if(pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN)
    {
        DisableInterfaceWithAllProtocols(pIcb);

        EnableInterfaceWithDIM(pIcb->hDIMHandle,
                               PID_IP,
                               FALSE);
    }

    return dwResult;
}

VOID
HandleAddressChangeNotification(
    VOID
    )

/*++

Routine Description

    Called in the context of the worker thread when we get a address change
    notification from winsock

Locks

    Acquires the ICB LOCK as WRITER

Arguments

    None

Return Value

    None

--*/

{
    DWORD       dwResult;
    PLIST_ENTRY pleNode;
    PICB        pIcb;

    ENTER_WRITER(ICB_LIST);

    if(g_pInternalInterfaceCb isnot NULL)
    {
        dwResult = UpdateBindingInformation(g_pInternalInterfaceCb);

        if(dwResult isnot NO_ERROR)
        {
            //
            // Cases in which no address was found
            //

            if(dwResult is ERROR_ADDRESS_ALREADY_ASSOCIATED)
            {
                //
                // This may mean that the i/f had no
                // address and still has no address
                //

                Trace1(IF,
                       "AddressChange: No address change for %S",
                       g_pInternalInterfaceCb->pwszName);

            }
            else
            {
                if(dwResult is ERROR_NO_DATA)
                {
                    //
                    // No data means we had an address and now have none
                    //

                    IpRtAssert(!g_bUninitServer);

                    dwResult = LanEtcInterfaceUpToDown(g_pInternalInterfaceCb,
                                                       FALSE);

                    g_bUninitServer = TRUE;

                    if(dwResult isnot NO_ERROR)
                    {
                        Trace2(ERR,
                               "AddressChange: Error %d bringing down interface %S",
                               dwResult,
                               g_pInternalInterfaceCb->pwszName);
                    }
                }
                else
                {
                    //
                    // All others
                    //

                    Trace2(ERR,
                           "AddressChange: Error %d trying to update binding for %S",
                           dwResult,
                           g_pInternalInterfaceCb->pwszName);
                }
            }
        }
        else
        {
            //
            // Cases in which an address was actually read out
            //

            if(g_bUninitServer)
            {
                //
                // First time we are getting an address
                //

                g_bUninitServer = FALSE;

                dwResult = LanEtcInterfaceDownToUp(g_pInternalInterfaceCb,
                                                   FALSE);

                if(dwResult isnot NO_ERROR)
                {
                    Trace1(ERR,
                           "AddressChange: Error %d bringing up server if",
                           dwResult);
                }
            }
            else
            {
                //
                // We had an address, it is changing
                //

                UnbindInterfaceInAllProtocols(g_pInternalInterfaceCb);

                BindInterfaceInAllProtocols(g_pInternalInterfaceCb);
            }
        }
    }

    for(pleNode = &ICBList;
        pleNode->Flink isnot &ICBList;
        pleNode = pleNode->Flink)
    {
        pIcb = CONTAINING_RECORD(pleNode->Flink,
                                 ICB,
                                 leIfLink);


        //
        // Already handled the INTERNAL case above, We only
        // handle LAN cards here
        //

        if(pIcb->ritType isnot ROUTER_IF_TYPE_DEDICATED)
        {
            continue;
        }

        if(pIcb->dwOperationalState is IF_OPER_STATUS_NON_OPERATIONAL)
        {
            //
            // If the admin state is down, we skip the interface
            //

            if(pIcb->dwAdminState isnot IF_ADMIN_STATUS_UP)
            {
                continue;
            }

            //
            // If the interface is DOWN, maybe this DHCP event will get it 
            // up. So lets try that first
            //

            IpRtAssert(pIcb->bBound is FALSE);

            dwResult = LanEtcInterfaceDownToUp(pIcb,
                                               FALSE);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(IF,
                       "AddressChange: Tried to bring up %S on receiving DHCP notification. However LanInterfaceDownToUp() returned error %d",
                       pIcb->pwszName,
                       dwResult);
            }
            else
            {
                Trace1(IF,
                       "AddressChange: Succesfully brought up %S",
                       pIcb->pwszName);
            }

            continue;
        }

        //
        // This interface was already up. Maybe the
        // address is changing
        //

        IpRtAssert(pIcb->bBound);

        dwResult = UpdateBindingInformation(pIcb);

        CheckBindingConsistency(pIcb);

        if(dwResult isnot NO_ERROR)
        {
            if(dwResult is ERROR_ADDRESS_ALREADY_ASSOCIATED)
            {
                //
                // This may mean that the i/f had no
                // address and still has no address
                //

                Trace1(IF,
                       "AddressChange: No address change for %S",
                       pIcb->pwszName);

                continue;
            }

            if(dwResult is ERROR_NO_DATA)
            {
                //
                // No data means we lost addresses
                //

                dwResult = LanEtcInterfaceUpToDown(pIcb,
                                                   FALSE);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddressChange: Error %d bringing down interface %S",
                           dwResult,
                           pIcb->pwszName);
                }

                continue;
            }

            Trace2(ERR,
                   "AddressChange: Error %d trying to update binding for %S",
                   dwResult,
                   pIcb->pwszName);

            continue;
        }

        //
        // Addresses changed so bind and unbind
        // with all protocols
        //

        UnbindInterfaceInAllProtocols(pIcb);

        BindInterfaceInAllProtocols(pIcb);

        UpdateAdvertisement(pIcb);
    }

    EXIT_LOCK(ICB_LIST);

}

DWORD
UpdateBindingInformation(
    PICB pIcb
    )

/*++
  
Routine Description

    Reads the registry for the ip address and mask associated with the
    interface. Then calls down into the stack to get a valid index
  
Locks 


Arguments
      

Return Value

    NO_ERROR        There was an address change and a new address was found
    ERROR_NO_DATA   No addresses were found (and there were addresses on
                    this interface originally) 
    ERROR_ADDRESS_ALREADY_ASSOCIATED 
        If there is no change in addresses. Also returned if the interface
        had no addresses to begin with and still has no addresses


--*/

{
    DWORD           dwResult, dwNumNewAddresses, dwNumOldAddresses;
    PICB_BINDING    pNewBinding,pOldBinding;
    DWORD           dwNewIfIndex,dwBCastBit,dwReasmSize;
    BOOL            bFound, bChange, bStack;
    DWORD           i, j;
    PWCHAR          pwszName;

    DWORD           dwAddr, dwLen;

    TraceEnter("UpdateBindingInformation");

    CheckBindingConsistency(pIcb);
   
    //
    // Only called for LAN and ras server interfaces. These DO NOT run in
    // unnumbered mode. Thus we can continue making assumptions that
    // if bound, dwNumAddresses != 0
    //
 
    if((pIcb->ritType isnot ROUTER_IF_TYPE_DEDICATED) and
       (pIcb->ritType isnot ROUTER_IF_TYPE_INTERNAL))
    {
        Trace2(IF,
               "UpdateBindingInformation: %S is type %d so not updating binding information",
               pIcb->pwszName,
               pIcb->ritType);

        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    IpRtAssert((pIcb->dwIfIndex isnot 0) and 
               (pIcb->dwIfIndex isnot INVALID_IF_INDEX));

    dwNumNewAddresses   = 0;
    pNewBinding         = NULL;
    pOldBinding         = pIcb->pibBindings;
    dwNumOldAddresses   = pIcb->dwNumAddresses;


    dwResult = GetIpInfoForInterface(pIcb->dwIfIndex,
                                     &dwNumNewAddresses,
                                     &pNewBinding,
                                     &dwBCastBit,
                                     &dwReasmSize);

    if(dwResult isnot NO_ERROR)
    {
        if(dwResult isnot ERROR_NO_DATA)
        {
            Trace2(ERR,
                   "UpdateBindingInformation: Error %d getting IP info for interface %S",
                   dwResult,
                   pIcb->pwszName);
        }
        else
        {
            //
            // If no addresses were found and there were no addresses to begin
            // with, then change the error code
            //

            if(pIcb->dwNumAddresses is 0)
            {
                dwResult = ERROR_ADDRESS_ALREADY_ASSOCIATED;
            }
        }

        return dwResult;
    }
            
    IpRtAssert(dwNumNewAddresses);
    IpRtAssert(pNewBinding);

    //
    // Make sure you will find an adapter index. Otherwise all this is no use
    //


#if DBG
        
    for(i = 0; i < dwNumNewAddresses; i++)
    {
        Trace4(IF,
               "UpdateBindingInformation: Interface: %S, Address: %d.%d.%d.%d Mask: %d.%d.%d.%d Index: 0x%x", 
               pIcb->pwszName, 
               PRINT_IPADDR(pNewBinding[i].dwAddress),
               PRINT_IPADDR(pNewBinding[i].dwMask),
               pIcb->dwIfIndex);
    }

#endif
    
    //
    // At this point the interface can be considered bound
    //

    pIcb->bBound = TRUE;
    
    //
    // Go through the address you have and if they dont appear in the list of 
    // the ones you read out, delete the associated static route
    //

    bChange = FALSE;

    for(i = 0; i < dwNumOldAddresses; i++)
    {
        bFound = FALSE;
        
        for(j = 0; j < dwNumNewAddresses; j++)
        {
            //
            // Check both the mask and the address
            //

            if((pOldBinding[i].dwAddress is pNewBinding[j].dwAddress) and
               (pOldBinding[i].dwMask is pNewBinding[j].dwMask))
            {
                bFound = TRUE;

                break;
            }
        }

        if(!bFound)
        {
            bChange = TRUE;
            
            //
            // Only delete routes we would have added in the first place
            //

            Trace2(IF,
                   "UpdateBindingInformation: Address %d.%d.%d.%d existed on %S earlier, but is now absent",
                   PRINT_IPADDR(pOldBinding[i].dwAddress),
                   pIcb->pwszName);
            
            DeleteAutomaticRoutes(pIcb,
                                  pOldBinding[i].dwAddress,
                                  pOldBinding[i].dwMask);
        }
    }

    //
    // Now go through the stuff read out from the registry and see if you 
    // already have the address(es). 
    //
    
    for(i = 0; i < dwNumNewAddresses; i++)
    {
        bFound = FALSE;
        
        for(j = 0; j < dwNumOldAddresses; j++)
        {
            if((pNewBinding[i].dwAddress is pOldBinding[j].dwAddress) and
               (pNewBinding[i].dwMask is pOldBinding[j].dwMask))
            {
                bFound = TRUE;

                break;
            }
        }

        if(!bFound)
        {
            bChange = TRUE;
        }
    }

    if(!bChange)
    {
        //
        // No change so we can leave
        //

        if(pNewBinding)
        {
            HeapFree(IPRouterHeap,
                     0,
                     pNewBinding);
        }

        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }
    
    //
    // So there has been some change
    // At this point we need to add the binding to the hash table
    //

    ENTER_WRITER(BINDING_LIST);

    //
    // If you had old bindings, remove them
    // Also remove the adapter to Interface map
    //

    if(pOldBinding)
    {
        RemoveBinding(pIcb);
    }

    pIcb->pibBindings         = pNewBinding;
    pIcb->dwNumAddresses      = dwNumNewAddresses;
    pIcb->dwBCastBit          = dwBCastBit;
    pIcb->dwReassemblySize    = dwReasmSize;
        
    
    AddBinding(pIcb);

    //
    // We do the same thing we did above, but now we add the routes.
    // We cant do this before because the adapter id and binding info
    // hasnt been set in the hash table
    //

    for(i = 0; i < dwNumNewAddresses; i++)
    {
        bFound = FALSE;
        
        for(j = 0; j < dwNumOldAddresses; j++)
        {
            if((pNewBinding[i].dwAddress is pOldBinding[j].dwAddress) and
               (pNewBinding[i].dwMask is pOldBinding[j].dwMask))
            {
                bFound = TRUE;
            }
        }

        if(!bFound)
        {
            Trace3(IF,
                   "UpdateBindingInformation: Address %d.%d.%d.%d/%d.%d.%d.%d new for %S",
                   PRINT_IPADDR(pNewBinding[i].dwAddress),
                   PRINT_IPADDR(pNewBinding[i].dwMask),
                   pIcb->pwszName);
            
            AddAutomaticRoutes(pIcb,
                               pNewBinding[i].dwAddress,
                               pNewBinding[i].dwMask);
        }
    }
   
    if(pOldBinding)
    { 
        HeapFree(IPRouterHeap,
                 0,
                 pOldBinding);
    }

    //
    // Such interfaces can not have a kernel context
    //
        
    EXIT_LOCK(BINDING_LIST);

    return NO_ERROR;
}


DWORD
GetAdapterInfo(
    DWORD    dwIpAddress,
    PDWORD   pdwAdapterId,
    PDWORD   pdwBCastBit,
    PDWORD   pdwReasmSize
    )

/*++
  
Routine Description

    Queries the tcpip driver with IP_MIB_STATS to figure out the
    adapter index for the adapter with the given ip address.
  
Locks 


Arguments
      

Return Value

    Index if successfule
    INVALID_IF_INDEX otherwise
    
--*/

{
    DWORD   i, dwNumEntries, MatchIndex, dwResult, Size;
    
    PMIB_IPADDRTABLE pAddrTable;
    
    *pdwAdapterId    = INVALID_ADAPTER_ID;
    *pdwBCastBit     = 1;
    *pdwReasmSize    = 0;
    
    dwResult = AllocateAndGetIpAddrTableFromStack(&pAddrTable,
                                                  FALSE,
                                                  IPRouterHeap,
                                                  0);
    
    if(dwResult isnot NO_ERROR) 
    {

        Trace1(ERR,
               "GetAdapterInfo: Error %d getting IP Address table from stack",
               dwResult);

        return dwResult;
    }
    
    for (i = 0; i < pAddrTable->dwNumEntries; i++) 
    {
        if(pAddrTable->table[i].dwAddr is dwIpAddress) 
        {
            *pdwAdapterId       = pAddrTable->table[i].dwIndex;
            *pdwBCastBit        = pAddrTable->table[i].dwBCastAddr;
            *pdwReasmSize       = pAddrTable->table[i].dwReasmSize;

            HeapFree(IPRouterHeap,
                     0,
                     pAddrTable);
            
            return NO_ERROR;
        }
    }

    HeapFree(IPRouterHeap,
             0,
             pAddrTable);
            
    return ERROR_INVALID_DATA;
}

DWORD
GetBestNextHopMaskGivenICB(
    PICB     pIcb,
    DWORD    dwNextHopAddr
    )

/*++

Routine Description

    Gets the longest mask for the next hop
  
Locks 


Arguments

    pIcb           the Interface Control Block over which the route goes out
    dwNextHopAddr  The next hop addr

Return Value

    0xFFFFFFFF if not found

--*/

{
    DWORD           i, dwLastMask;
    
#if DBG
    
    BOOL    bFound = FALSE;
    
#endif

    CheckBindingConsistency(pIcb);
    
    dwLastMask = 0;
    
    for(i = 0; i < pIcb->dwNumAddresses; i++)
    {
        if((pIcb->pibBindings[i].dwAddress & pIcb->pibBindings[i].dwMask) is
           (dwNextHopAddr & pIcb->pibBindings[i].dwMask))
        {

#if DBG            
            bFound = TRUE;
#endif
            if(pIcb->pibBindings[i].dwMask > dwLastMask)
            {
                dwLastMask = pIcb->pibBindings[i].dwMask;
            }
        }
    }

#if DBG
    
    if(!bFound)
    {
        Trace2(ERR,
               "GetBestNextHopMaskGivenICB: Didnt find match. I/f 0x%x Nexthop %x",
               pIcb->dwIfIndex,
               dwNextHopAddr);
    }
    
#endif

    if(dwLastMask is 0x00000000)
    {
        return 0xFFFFFFFF;
    }
    else
    {
        return dwLastMask;
    }
}

DWORD
GetBestNextHopMaskGivenIndex(
    DWORD  dwIfIndex,
    DWORD  dwNextHopAddr
    )

/*++

Routine Description

    Gets the longest mask for the next hop
  
Locks 


Arguments

    pIcb           the Interface Control Block over which the route goes out
    dwNextHopAddr  The next hop addr

Return Value

    0x00000000 if not found

--*/

{
    PICB pIcb;

    pIcb = InterfaceLookupByIfIndex(dwIfIndex);

    if(pIcb is NULL)
    {
        Trace1(ERR,
               "GetBestNextHopMaskGivenIndex: Couldnt find pIcb for index 0x%x",
               dwIfIndex);

        return 0x00000000;
    }

    return GetBestNextHopMaskGivenICB(pIcb,
                                      dwNextHopAddr);
}

DWORD
InitializeLoopbackInterface(
    PICB    pIcb
    )
{
    DWORD               dwResult, i, j;
    PADAPTER_INFO       pBindNode;
    INTERFACE_ROUTE_INFO rifRoute;
    PLIST_ENTRY         pleNode;

    TraceEnter("InitLoopIf");
    
    g_pLoopbackInterfaceCb = pIcb;
    
    dwResult = GetAdapterInfo(IP_LOOPBACK_ADDRESS,
                              &(pIcb->dwIfIndex),
                              &(pIcb->dwBCastBit),
                              &(pIcb->dwReassemblySize));

    if(dwResult isnot NO_ERROR)
    {
        Trace0(ERR,
               "InitLoopIf: Couldnt find adapter id for loopback interface");

        return ERROR_CAN_NOT_COMPLETE;
    }

    IpRtAssert(pIcb->dwIfIndex is LOOPBACK_INTERFACE_INDEX);

    IpRtAssert(pIcb->pibBindings isnot NULL);

    //
    // This will always have one address
    //

    pIcb->dwNumAddresses = 1;
    pIcb->bBound         = TRUE;
    
    //
    // Loopback interfaces have a class A mask
    //

    pIcb->pibBindings[0].dwAddress   = IP_LOOPBACK_ADDRESS;
    pIcb->pibBindings[0].dwMask      = CLASSA_MASK;
        
    ENTER_WRITER(BINDING_LIST);

    pBindNode = GetInterfaceBinding(pIcb->dwIfIndex);

    if(!pBindNode)
    {
        Trace1(ERR,
               "IniteLoopIf: Binding not found for %S",
               pIcb->pwszName);

        IpRtAssert(FALSE);

        //
        // Something really bad happened and we didnt have a
        // bind block for the interface
        //

        AddBinding(pIcb);
    }
    else
    {
        pBindNode->bBound                   = TRUE;
        pBindNode->dwNumAddresses           = 1;
        pBindNode->dwRemoteAddress          = INVALID_IP_ADDRESS;
        pBindNode->rgibBinding[0].dwAddress = IP_LOOPBACK_ADDRESS;
        pBindNode->rgibBinding[0].dwMask    = CLASSA_MASK;

        pBindNode->dwBCastBit               = pIcb->dwBCastBit;
        pBindNode->dwReassemblySize         = pIcb->dwReassemblySize;
        pBindNode->ritType                  = pIcb->ritType;
    }
    
    EXIT_LOCK(BINDING_LIST);
    
    rifRoute.dwRtInfoMask          = CLASSA_MASK;
    rifRoute.dwRtInfoNextHop       = IP_LOOPBACK_ADDRESS;
    rifRoute.dwRtInfoDest          = (IP_LOOPBACK_ADDRESS & CLASSA_MASK);
    rifRoute.dwRtInfoIfIndex       = pIcb->dwIfIndex;
    rifRoute.dwRtInfoMetric1       = 1;
    rifRoute.dwRtInfoMetric2       = 0;
    rifRoute.dwRtInfoMetric3       = 0;
    rifRoute.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                      RTM_VIEW_MASK_MCAST; // XXX config
    rifRoute.dwRtInfoPreference    = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
    rifRoute.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
    rifRoute.dwRtInfoProto         = MIB_IPPROTO_LOCAL;
    rifRoute.dwRtInfoAge           = 0;
    rifRoute.dwRtInfoNextHopAS     = 0;
    rifRoute.dwRtInfoPolicy        = 0;

    dwResult = AddSingleRoute(pIcb->dwIfIndex,
                              &rifRoute,
                              CLASSA_MASK,
                              0,     // RTM_ROUTE_INFO::Flags
                              FALSE, // We dont know what protocols might do
                              FALSE, // No need to add to stack
                              FALSE,
                              NULL);

    //
    // Now we need to go through all the bindings that are there
    // and add the loopback route for them. We do this here because
    // the loopback interface may be add AFTER the other interfaces
    //
    
    //
    // NOTE - this is going to take a lock recursively when it goes
    // to rtmif.c
    //

    ENTER_READER(BINDING_LIST);

    for(i = 0; i < BINDING_HASH_TABLE_SIZE; i++)
    {
        for(pleNode = g_leBindingTable[i].Flink;
            pleNode isnot &g_leBindingTable[i];
            pleNode = pleNode->Flink)
        {
            PADAPTER_INFO   pBinding;

            pBinding = CONTAINING_RECORD(pleNode, ADAPTER_INFO, leHashLink);

            for(j = 0; j < pBinding->dwNumAddresses; j++)
            {
                if(pBinding->rgibBinding[j].dwAddress is INVALID_IP_ADDRESS)
                {
                    continue;
                }

                AddLoopbackRoute( 
                    pBinding->rgibBinding[j].dwAddress,
                    pBinding->rgibBinding[j].dwMask
                    );
            }
        }
    }
    
    EXIT_LOCK(BINDING_LIST);
    
    return NO_ERROR;
}

DWORD
IpIpTunnelInitToDown(
    PICB    pIcb
    )
{
    return NO_ERROR;
}

DWORD
LanEtcInterfaceInitToDown(
    PICB pIcb
    )
{
    DWORD           dwResult, dwNumAddresses, dwMask;
    PICB_BINDING    pBinding;
    DWORD           dwIfIndex = INVALID_IF_INDEX,dwBCastBit,dwReasmSize;
    DWORD           i;
    MIB_IFROW       riInBuffer;
    PWCHAR          pwszName;
    PLIST_ENTRY     ple;
    PROUTE_LIST_ENTRY prl;
    
    IPRouteEntry    *pRouteEntry;

    TraceEnter("LanInterfaceInitToDown");

    dwNumAddresses  = 0;
    pBinding        = NULL;
    pwszName        = pIcb->pwszName;
    
    dwResult = ReadAddressFromRegistry(pwszName,
                                       &dwNumAddresses,
                                       &pBinding,
                                       FALSE);
    
    if(dwResult isnot NO_ERROR) 
    {
        //
        // If there is no data, means the lan card wasnot UP anyway
        //

        if(dwResult is ERROR_NO_DATA)
        {
            return NO_ERROR;
        }
        
        Trace2(ERR, 
               "LanInterfaceInitToDown: Error %d reading IP Address information for interface %S",
               dwResult,
               pIcb->pwszName);

        return dwResult;
    }

    //
    // Make sure you will find an adapter index. Otherwise all this is no use
    //

    for(i = 0; i < dwNumAddresses; i++)
    {
        //
        // Try to get an index using all possible addresses
        //
        
        dwResult = GetAdapterInfo(pBinding[i].dwAddress,
                                  &dwIfIndex,
                                  &dwBCastBit,
                                  &dwReasmSize);

        if(dwResult is NO_ERROR)
        {
            //
            // Ok so we found a valid index from a good address
            //

            break;
        }
    }
        
    if((dwIfIndex is INVALID_IF_INDEX) or
       (dwIfIndex isnot pIcb->dwIfIndex))
    {
        Trace2(ERR, 
               "LanInterfaceInitToDown: Couldnt find adapter index for interface %S using %d.%d.%d.%d",
               pIcb->pwszName,
               PRINT_IPADDR(pBinding[0].dwAddress));
        
        HeapFree(IPRouterHeap,
                 0,
                 pBinding);
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Delete all the routes in the stack
    //

    for (ple = g_leStackRoutesToRestore.Flink;
         ple != &g_leStackRoutesToRestore;
         ple = ple->Flink)
    {
        prl = (PROUTE_LIST_ENTRY) 
                CONTAINING_RECORD(ple, ROUTE_LIST_ENTRY, leRouteList); 

        TraceRoute2(
            ROUTE, "%d.%d.%d.%d/%d.%d.%d.%d",
            PRINT_IPADDR( prl->mibRoute.dwForwardDest ),
            PRINT_IPADDR( prl->mibRoute.dwForwardMask )
            );
                
        if(prl->mibRoute.dwForwardIfIndex isnot dwIfIndex)
        {
            //
            // Not going out over this interface
            //
            
            continue;
        }

        prl->mibRoute.dwForwardType = MIB_IPROUTE_TYPE_INVALID;
        
        dwResult = SetIpForwardEntryToStack(&(prl->mibRoute));
        
        if (dwResult isnot NO_ERROR) 
        {
            Trace2(ERR,
                   "ReinstallOldRoutes: Failed to add route to %x from "
                   " init table. Error %x",
                   prl->mibRoute.dwForwardDest,
                   dwResult);
        }
    }


    //
    // Dont really need it anymore
    //
    
    HeapFree(IPRouterHeap,
             0,
             pBinding);
        

    //
    // Going from up to down
    //

    riInBuffer.dwIndex          = dwIfIndex;
    riInBuffer.dwAdminStatus    = IF_ADMIN_STATUS_DOWN;


    dwResult = SetIfEntryToStack(&riInBuffer,
                                 TRUE);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LanInterfaceInitToDown: Couldnt set IFEntry for %S",
               pIcb->pwszName);
    }
    
    DeleteAllRoutes(pIcb->dwIfIndex,
                    FALSE);

    return dwResult;
}

DWORD
GetIpInfoForInterface(
    IN  DWORD   dwIfIndex,
    OUT PULONG  pulNumAddresses,
    OUT ICB_BINDING **ppAddresses,
    OUT PDWORD  pdwBCastBit,
    OUT PDWORD  pdwReasmSize
    )

/*++

Routine Description

    Gets the addresses and other ip information for an interface

Locks

    None needed

Arguments

    dwIfIndex,
    pdwNumAddresses
    ppAddresses
    pdwBCastBit
    pdwReasmSize

Return Value

    NO_ERROR
    Win32 Errorcode

--*/

{
    DWORD   dwResult, i;
    ULONG   ulAddrIndex, ulCount, ulValid;

    PMIB_IPADDRTABLE pAddrTable;

    *pulNumAddresses = 0;
    *pdwBCastBit     = 1;
    *pdwReasmSize    = 0;
    *ppAddresses     = NULL;

    dwResult = AllocateAndGetIpAddrTableFromStack(&pAddrTable,
                                                  TRUE,
                                                  IPRouterHeap,
                                                  0);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIpInfoForInterface: Error %d getting IP Address table from stack",
               dwResult);

        return dwResult;
    }

    ulCount = 0;
    ulValid = 0;

    for (i = 0; i < pAddrTable->dwNumEntries; i++)
    {
        if(pAddrTable->table[i].dwIndex is dwIfIndex)
        {
            ulCount++;

            //
            // Make sure this is not a duplicate. Since this is ordered, we
            // merely check the next address
            //

            if(!(IsValidIpAddress(pAddrTable->table[i].dwAddr)) or
               (pAddrTable->table[i].dwMask is 0))
            {
                //
                // Since this is only called for numbered links
                //

                continue;
            }

            if((i isnot (pAddrTable->dwNumEntries - 1)) and
               (pAddrTable->table[i].dwAddr is pAddrTable->table[i + 1].dwAddr))
            {
                Trace1(ERR,
                       "GetIpInfoForInterface: %d.%d.%d.%d duplicate address",
                       PRINT_IPADDR(pAddrTable->table[i].dwAddr));

                continue;
            }

            ulValid++;
        }
    }

    //
    // See if we have good addresses
    //

    if(ulValid is 0)
    {
        if(ulCount isnot 0)
        {
            Trace1(ERR,
                   "GetIpInfoForInterface: If 0x%x has addresses entries which are 0s",
                   dwIfIndex);
        }

        HeapFree(IPRouterHeap,
                 0,
                 pAddrTable);

        return ERROR_NO_DATA;
    }  

    //
    // Allocate from private heap
    //

    *ppAddresses = HeapAlloc(IPRouterHeap,
                             HEAP_ZERO_MEMORY,
                             (sizeof(ICB_BINDING) * ulValid));

    if(*ppAddresses is NULL)
    {
        Trace0(ERR,
               "GetIpInfoForInterface: Error allocating memory");

        HeapFree(IPRouterHeap,
                 0,
                 pAddrTable);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now copy out the valid addresses
    //

    ulAddrIndex = 0;

    for (i = 0; i < pAddrTable->dwNumEntries; i++)
    {
        if(pAddrTable->table[i].dwIndex is dwIfIndex)
        {

            if(!(IsValidIpAddress(pAddrTable->table[i].dwAddr)) or
               (pAddrTable->table[i].dwMask is 0))
            {
                continue;
            }

            if((i isnot (pAddrTable->dwNumEntries - 1)) and
               (pAddrTable->table[i].dwAddr is pAddrTable->table[i + 1].dwAddr))
            {
                continue;
            }

            if(!(*pdwReasmSize))
            {
                *pdwReasmSize = pAddrTable->table[i].dwReasmSize;
                *pdwBCastBit  = pAddrTable->table[i].dwBCastAddr;
            }

            (*ppAddresses)[ulAddrIndex].dwAddress = pAddrTable->table[i].dwAddr;
            (*ppAddresses)[ulAddrIndex].dwMask    = pAddrTable->table[i].dwMask;

            ulAddrIndex++;
        }
    }

    IpRtAssert(ulAddrIndex is ulValid);

    *pulNumAddresses = ulValid;

    HeapFree(IPRouterHeap,
             0,
             pAddrTable);

    return NO_ERROR;
}

DWORD
ReadAddressFromRegistry(
    IN  PWCHAR          pwszIfName,
    OUT PDWORD          pdwNumAddresses,
    OUT ICB_BINDING     **ppibAddressInfo,
    IN  BOOL            bInternalIf
    )
{
    HKEY    hadapkey ;
    CHAR    buff[512], pszInterfaceName[256];
    DWORD   dwDhcp, dwResult, dwSize, dwType;
    
    TraceEnter("ReadAddressFromRegistry");

    Trace1(IF,
           "ReadAddressFromRegistry: Reading address for %S",
           pwszIfName);

    wcstombs(pszInterfaceName, pwszIfName, wcslen(pwszIfName));

    pszInterfaceName[wcslen(pwszIfName)] = '\0';

    
    *pdwNumAddresses    = 0;
    *ppibAddressInfo    = NULL;
    
    //
    // The IP address should be in the registry
    //
    
    strcpy(buff, REG_KEY_TCPIP_INTERFACES);
    strcat(buff,"\\");
    strcat(buff, pszInterfaceName) ;


    dwResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                          buff,
                          &hadapkey);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "ReadAddressFromRegistry: Unable to open key %s",
               buff);

        return dwResult;
    }

    dwDhcp = 0;
  
    if(!bInternalIf)
    {
        //
        // Get the EnableDHCP flag
        //

        dwSize = sizeof(DWORD);

        dwResult = RegQueryValueEx(hadapkey,
                                   REGISTRY_ENABLE_DHCP,
                                   NULL,
                                   &dwType,
                                   (PBYTE)&dwDhcp,
                                   &dwSize);

        if(dwResult isnot NO_ERROR)
        {
            Trace0(ERR,
                   "ReadAddressFromRegistry: Unable to read DHCP Enabled key");

            RegCloseKey(hadapkey);

            return dwResult;
        }
    }
    else
    {
        //
        // tcpcfg writes server adapter address as DHCP but
        // does not set dhcp enable
        //

        dwDhcp = 1;
    }
  
    //
    // Get the ip address for the net interface
    //
    
    dwSize = 0 ;

    if(dwDhcp == 0) 
    {
        dwResult = ReadAddressAndMaskValues(hadapkey,
                                            REGISTRY_IPADDRESS,
                                            REGISTRY_SUBNETMASK,
                                            ppibAddressInfo,
                                            pdwNumAddresses);
    }
    else 
    {

        //
        // First try autonet, and if that fails, read the DHCP
        // This needs to be done because the DHCP address is not cleared
        // out when running in autonet mode, but the autonet address is set
        // to 0.0.0.0 when in DHCP mode
        //

        dwResult = ReadAddressAndMaskValues(hadapkey,
                                            REGISTRY_AUTOCONFIGIPADDRESS,
                                            REGISTRY_AUTOCONFIGSUBNETMASK,
                                            ppibAddressInfo,
                                            pdwNumAddresses);

        if(dwResult isnot NO_ERROR)
        {
            dwResult = ReadAddressAndMaskValues(hadapkey,
                                                REGISTRY_DHCPIPADDRESS,
                                                REGISTRY_DHCPSUBNETMASK,
                                                ppibAddressInfo,
                                                pdwNumAddresses);
        }
    }   

    RegCloseKey(hadapkey);

    if(dwResult isnot NO_ERROR)
    {
        Trace3(ERR,
               "ReadAddressFromRegistry: Couldnt read address for %S. Error %d. DHCP %d",
               pwszIfName,
               dwResult,
               dwDhcp);
        
        return dwResult;
    }
    else
    {
#if DBG
        DWORD i;

        Trace2(IF,
               "--%d addresses on %S\n",
               *pdwNumAddresses,
               pwszIfName);

        for(i = 0; i < *pdwNumAddresses; i++)
        {
            Trace1(IF, "%d.%d.%d.%d",
                   PRINT_IPADDR((*ppibAddressInfo)[i].dwAddress));
        }
#endif
    }
    
    
    return dwResult;
}

DWORD
ReadAddressAndMaskValues(
    IN  HKEY        hkeyAdapterSection,
    IN  PSZ         pszRegAddressValue,
    IN  PSZ         pszRegMaskValue,
    OUT ICB_BINDING **ppibAddressInfo,
    OUT PDWORD      pdwNumAddresses
    )
{
    DWORD   dwResult, dwType;
    PBYTE   pbyAddresses,pbyMasks;
    DWORD   dwAddressSize, dwMaskSize;

    dwAddressSize = dwMaskSize  = 0;
    
    dwResult = RegQueryValueEx(hkeyAdapterSection,
                               pszRegAddressValue,
                               NULL,
                               &dwType,
                               NULL,
                               &dwAddressSize);

    if((dwAddressSize is 0) or (dwResult isnot NO_ERROR))
    {
        Trace3(ERR,
               "ReadAddressAndMaskValues: Registry reported size = %d with error %d for size of %s",
               dwAddressSize,
               dwResult,
               pszRegAddressValue);
        
        return ERROR_REGISTRY_CORRUPT;
    }
    
    //
    // We allocate size+4 so that even if we read out a REG_SZ, it looks
    // like a REG_MULTI_SZ to the parse routine because we guarantee atleast
    // 2 terminating NULLS
    // 

    pbyAddresses = HeapAlloc(IPRouterHeap,
                             HEAP_ZERO_MEMORY,
                             dwAddressSize + 4);
    
    if(pbyAddresses is NULL)
    {
        Trace2(ERR,
               "ReadAddressAndMaskValues: Error allocating %d bytes for %s",
               dwAddressSize + 4,
               pszRegAddressValue);

        return ERROR_NOT_ENOUGH_MEMORY;
    }
     
    dwResult = RegQueryValueEx(hkeyAdapterSection,
                               pszRegAddressValue,                               
                               NULL,
                               &dwType,
                               pbyAddresses,
                               &dwAddressSize);

    if(dwResult isnot NO_ERROR)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pbyAddresses);

        Trace2(ERR,
               "ReadAddressAndMaskValues: Error %d reading %s from registry",
               dwResult,
               pszRegAddressValue);
        
        
        return dwResult;
    }
    
    //
    // Now get the subnet mask for the net interface
    //
    
    dwResult = RegQueryValueEx(hkeyAdapterSection,
                               pszRegMaskValue,
                               NULL,
                               &dwType,
                               NULL,
                               &dwMaskSize);
    
    if((dwMaskSize is 0) or (dwResult isnot NO_ERROR))
    {
        HeapFree(IPRouterHeap,
                 0,
                 pbyAddresses);
        
        Trace3(ERR,
               "ReadAddressAndMaskValues: Registry reported size = %d with error %d for size of %s",
               dwMaskSize,
               dwResult,
               pszRegMaskValue);
        
        return ERROR_REGISTRY_CORRUPT;
    }
    
    pbyMasks = HeapAlloc(IPRouterHeap,
                         HEAP_ZERO_MEMORY,
                         dwMaskSize + 4);
    
    if(pbyMasks is NULL)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pbyAddresses);

        
        Trace2(ERR,
               "ReadAddressAndMaskValues: Error allocating %d bytes for %s",
               dwMaskSize + 4,
               pszRegMaskValue);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    dwResult = RegQueryValueEx(hkeyAdapterSection,
                               pszRegMaskValue,
                               NULL,
                               &dwType,
                               pbyMasks,
                               &dwMaskSize) ;
    
    if(dwResult isnot NO_ERROR)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pbyAddresses);
        
        HeapFree(IPRouterHeap,
                 0,
                 pbyMasks);

        
        Trace2(ERR,
               "ReadAddressAndMaskValues: Error %d reading %s from registry",
               dwResult,
               pszRegMaskValue);
        
        return dwResult;
    }

    dwResult = ParseAddressAndMask(pbyAddresses,
                                   dwAddressSize,
                                   pbyMasks,
                                   dwMaskSize,
                                   ppibAddressInfo,
                                   pdwNumAddresses);
    
    HeapFree(IPRouterHeap,
             0,
             pbyAddresses);
    
    HeapFree(IPRouterHeap,
             0,
             pbyMasks);
    
    return dwResult;
}

DWORD
ParseAddressAndMask(
    IN  PBYTE       pbyAddresses,
    IN  DWORD       dwAddressSize,
    IN  PBYTE       pbyMasks,
    IN  DWORD       dwMaskSize,
    OUT ICB_BINDING **ppibAddressInfo,
    OUT PDWORD      pdwNumAddresses
    )
{
    DWORD   dwAddrCount, dwMaskCount, dwTempLen, dwAddrIndex;
    DWORD   dwMask, dwAddr, i, j;
    PBYTE   pbyTempAddr, pbyTempMask;
    BOOL    bDuplicate;


    *pdwNumAddresses = 0;
    *ppibAddressInfo = NULL;
    
    //
    // If there are only two characters in the string or if the
    // the first two are NULL, we have no data. Due to tcp/ip config
    // we may be passed a REG_SZ instead of a REG_MULTI_SZ. The code works
    // around that by assuming that if a REG_SZ was read out then extra 
    // padding was added to the end so that we ALWAYS have 2 terminating NULLs
    //
    
    if((dwAddressSize < 2) or
       ((pbyAddresses[0] is '\0') and
        (pbyAddresses[1] is '\0')))
    {
        Trace0(IF,
               "ParseAddressAndMask: No addresses found");
        
        return ERROR_NO_DATA;
    }


    //
    // The mask should also have some data
    //

    
    if((dwMaskSize < 2) or
       ((pbyMasks[0] is '\0') and
        (pbyMasks[1] is '\0')))
    {
        Trace0(IF,
               "ParseAddressAndMask: No masks found");
        
        return ERROR_NO_DATA;
    }
    
        
    //
    // Count the number of addresses
    //
    
    dwAddrCount = 0;
    pbyTempAddr = pbyAddresses;
    dwTempLen   = dwAddressSize;
        
    while(dwTempLen)
    {
        if(*pbyTempAddr == '\0')
        {
            dwAddrCount++;
            
            if(*(pbyTempAddr+1) == '\0')
            {
                break;
            }
        }

        pbyTempAddr++ ;
        
        dwTempLen-- ;
    }

    
    if(dwAddrCount is 0)
    {
        Trace0(IF,
               "ParseAddressAndMask: No addresses found");
        
        return ERROR_NO_DATA;
    }

    //
    // Count the number of masks
    //
    
    dwMaskCount = 0;
    pbyTempMask = pbyMasks;
    dwTempLen   = dwMaskSize;
        
    while(dwTempLen)
    {
        if(*pbyTempMask is '\0')
        {
            dwMaskCount++;
            
            if(*(pbyTempMask+1) is '\0')
            {
                break;
            }
        }

        pbyTempMask++ ;
        
        dwTempLen-- ;
    }

    //
    // Make sure that the two are the same
    //

    if(dwAddrCount isnot dwMaskCount)
    {
        Trace0(IF,
               "ParseAddressAndMask: Address and mask count is not same");
        
        return ERROR_NO_DATA;
    }
            
    //
    // Allocate the memory required to store all the addresses
    //

    *ppibAddressInfo = HeapAlloc(IPRouterHeap,
                                 HEAP_ZERO_MEMORY,
                                 (sizeof(ICB_BINDING) * dwAddrCount));

    if(*ppibAddressInfo is NULL)
    {
        Trace1(ERR,
               "ParseAddressAndMask: Error allocating %d bytes for AddressInfo",
               sizeof(ICB_BINDING) * dwAddrCount);

        return ERROR_NOT_ENOUGH_MEMORY;
    }
     
    pbyTempAddr = pbyAddresses;
    pbyTempMask = pbyMasks;

    dwAddrIndex = 0;
 
    for (i = 0; i < dwAddrCount; i++)
    {
        dwAddr = inet_addr(pbyTempAddr);
        dwMask = inet_addr(pbyTempMask);

        pbyTempAddr = strchr(pbyTempAddr, '\0');
        pbyTempMask = strchr(pbyTempMask, '\0');

        pbyTempAddr++;
        pbyTempMask++;

        bDuplicate = FALSE;

        for(j = 0; j < dwAddrIndex; j++)
        {
            if((*ppibAddressInfo)[j].dwAddress is dwAddr)
            {

                Trace1(ERR,
                       "ParseAddressAndMask: Addr %x is duplicate",
                       dwAddr);

                bDuplicate = TRUE;
                
                break;
            }
        }
        
        if(bDuplicate or
           (dwAddr is INVALID_IP_ADDRESS) or
           (dwMask is 0x00000000))
        {
            continue;
        }

        (*ppibAddressInfo)[dwAddrIndex].dwAddress    = dwAddr;
        (*ppibAddressInfo)[dwAddrIndex].dwMask       = dwMask;

        dwAddrIndex++;
    }

    *pdwNumAddresses = dwAddrIndex; 
   
    
    //
    // Make sure that there is atleast one valid address
    //


    if(dwAddrIndex is 0)
    {
        Trace0(ERR,
               "ParseAddressAndMask: No valid addresses found");
        
        HeapFree(IPRouterHeap,
                 0,
                 *ppibAddressInfo);
        
        *ppibAddressInfo    = NULL;

        return ERROR_NO_DATA;
    }

    return NO_ERROR;
}

DWORD
SetInterfaceReceiveType(
    IN  DWORD   dwProtocolId,
    IN  DWORD   dwIfIndex,
    IN  DWORD   dwInterfaceReceiveType,
    IN  BOOL    bActivate
    )

{
    DWORD                       dwResult;
    IO_STATUS_BLOCK             ioStatus;
    IP_SET_IF_PROMISCUOUS_INFO  PromInfo;
    HANDLE                      hEvent;

    hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    if(hEvent is NULL)
    {
        dwResult = GetLastError();

        Trace1(ERR,
               "SetInterfaceReceiveType: Error %d creating event",
               dwResult);

        return dwResult;
    }

    if(dwInterfaceReceiveType is IR_PROMISCUOUS_MULTICAST)
    {
        PromInfo.Type  = PROMISCUOUS_MCAST;
    }
    else
    {
        if(dwInterfaceReceiveType is IR_PROMISCUOUS)
        {
            PromInfo.Type  = PROMISCUOUS_BCAST;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    PromInfo.Index = dwIfIndex;
    PromInfo.Add   = bActivate?1:0;

    dwResult = NtDeviceIoControlFile(g_hIpDevice,
                                     hEvent,
                                     NULL,
                                     NULL,
                                     &ioStatus,
                                     IOCTL_IP_SET_IF_PROMISCUOUS,
                                     (PVOID)&PromInfo,
                                     sizeof(IP_SET_IF_PROMISCUOUS_INFO),
                                     NULL,
                                     0);

    if(dwResult is STATUS_PENDING)
    {
        Trace0(ERR,
               "SetInterfaceReceiveType: Pending from ioctl");

        dwResult = WaitForSingleObject(hEvent,
                                       INFINITE);

        if(dwResult isnot WAIT_OBJECT_0) // 0
        {
            Trace1(ERR,
                   "SetInterfaceReceiveType: Error %d from wait",
                   dwResult);

            dwResult = GetLastError();
        }
        else
        {
            dwResult = STATUS_SUCCESS;
        }
    }

    if(dwResult isnot STATUS_SUCCESS)
    {
        Trace4(ERR,
               "SetInterfaceReceiveType: NtStatus %x while %s i/f %x into %s mode",
               dwResult,
               (PromInfo.Add == 1) ? "activating" : "deactivating",
               dwIfIndex,
               (PromInfo.Type == PROMISCUOUS_MCAST) ? "prom mcast" : "prom all");

        return dwResult;
    }

    return NO_ERROR;
} 

DWORD
HandleMediaSenseEvent(
    IN  PICB    pIcb,
    IN  BOOL    bSensed
    )
    
/*++

Routine Description:

    Called when media sense status changes for a LAN interface

Locks:

    Called with the ICB list lock held as WRITER

Arguments:

    pIcb    ICB of the interface for which the event it
    bSensed TRUE is cable is present

Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr;

    return NO_ERROR;

    //
    // Not for NT 5.0
    //

    if(pIcb->ritType isnot ROUTER_IF_TYPE_DEDICATED)
    {
        IpRtAssert(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    if(bSensed)
    {
        //
        // Bring the interface up
        //

        dwErr = LanEtcInterfaceDownToUp(pIcb,
                                        FALSE);
    }
    else
    {
        dwErr = LanEtcInterfaceUpToDown(pIcb,
                                        FALSE);
    }

    if(dwErr isnot NO_ERROR)
    {
        Trace2(ERR,
               "HandleMediaSense: Err %d when changing status for %S",
               dwErr,
               pIcb->pwszName);
    }

    return dwErr;
}

DWORD
GetRouterId()
{
    PLIST_ENTRY pleNode;
    PICB        picb;
    ULONG       ulIdx;
    DWORD       dwRouterId      = -1; // lower is better
    DWORD       dwRouterTypePri = -1; // lower is better
    DWORD       dwTypePri;
    
    TraceEnter("GetRouterId");

    ENTER_READER(ICB_LIST);

    for (pleNode = ICBList.Flink;   // walk the ICBList
         pleNode isnot &ICBList;
         pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD (pleNode, ICB, leIfLink) ;

        // Get Type priority
        switch(picb->ritType) {
        case ROUTER_IF_TYPE_LOOPBACK : dwTypePri = 0;  break; // best
        case ROUTER_IF_TYPE_INTERNAL : dwTypePri = 1;  break;
        case ROUTER_IF_TYPE_TUNNEL1  : dwTypePri = 2;  break; 
        case ROUTER_IF_TYPE_DEDICATED: dwTypePri = 3;  break; 
        default:                       dwTypePri = 10; break; // worst
        }

        // Walk addresses
        for (ulIdx=0; ulIdx<picb->dwNumAddresses; ulIdx++)
        {
            if (!IS_ROUTABLE(picb->pibBindings[ulIdx].dwAddress))
            {
                continue;
            }

            // update if better
            if (dwTypePri < dwRouterTypePri
             || (dwTypePri==dwRouterTypePri 
                  && picb->pibBindings[ulIdx].dwAddress<dwRouterId))
            {
                dwRouterTypePri = dwTypePri;
                dwRouterId      = picb->pibBindings[ulIdx].dwAddress;
            }
        }
    }

    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    TraceLeave("GetRouterId");

    return dwRouterId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\info.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\info.h

Abstract:

    Header for info.c

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

//
// Routes, filters, demand filters, nat, mcast boundaries
//

#define NUM_INFO_CBS    6

typedef 
DWORD
(*PINFOCB_GET_IF_INFO)(
    IN     PICB                   picb,
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pbDataPtr,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    );


typedef 
DWORD
(*PINFOCB_SET_IF_INFO)(
    IN  PICB                    picb,
    IN  PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    );

typedef
DWORD
(*PINFOCB_BIND_IF)(
    IN  PICB                    picb
    );

typedef 
DWORD
(*PINFOCB_GET_GLOB_INFO)(
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pbDataPtr,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    );

typedef struct _INFO_CB
{
    PCHAR                   pszInfoName;
    PINFOCB_GET_IF_INFO     pfnGetInterfaceInfo;
    PINFOCB_SET_IF_INFO     pfnSetInterfaceInfo;
    PINFOCB_BIND_IF         pfnBindInterface;
    PINFOCB_GET_GLOB_INFO   pfnGetGlobalInfo;

}INFO_CB, *PINFO_CB;


PRTR_TOC_ENTRY
GetPointerToTocEntry(
    DWORD                     dwType, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdr
    );

DWORD
GetSizeOfInterfaceConfig(
    PICB   picb
    );


DWORD
GetInterfaceConfiguration(
    PICB                      picb,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    DWORD                     dwInfoSize
    );

DWORD
GetInterfaceRoutingProtoInfo(
    PICB                   picb, 
    PPROTO_CB              pProtoCbPtr,
    PRTR_TOC_ENTRY         pToc,
    PBYTE                  pbDataPtr, 
    PRTR_INFO_BLOCK_HEADER pInfoHdrAndBuffer,
    PDWORD                 pdwSize
    );


DWORD
GetGlobalConfiguration(
    PRTR_INFO_BLOCK_HEADER   pInfoHdrAndBuffer,
    DWORD                    dwInfoSize
    );

DWORD
GetSizeOfGlobalInfo(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\if.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\if.h

Abstract:

    Header for if.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

#define ADAPTER_PREFIX_STRING           "\\DEVICE\\"
#define ADAPTER_PREFIX_UNICODE_STRING   L"\\DEVICE\\"


PICB
CreateIcb(
    PWSTR                   pwszInterfaceName,
    HANDLE                  hDIMInterface,
    ROUTER_INTERFACE_TYPE   InterfaceType,
    DWORD                   dwAdminState,
    DWORD                   dwIfIndex OPTIONAL
    );

DWORD
CreateDefaultIcb(
    PWCHAR  pwszName,
    ICB     **ppicb
    );

DWORD
AllocateIcb(
    PWCHAR  pwszName,
    ICB     **ppicb
    );

DWORD
CreateBindingForNewIcb(
    PICB    pNewIcb
    );

VOID
InsertInterfaceInLists(
    PICB     pNewIcb
    );

VOID
RemoveInterfaceFromLists(
    PICB    picb
    );

DWORD
BindInterfaceInAllProtocols(
    PICB picb
    );

DWORD
BindInterfaceInProtocol(
    PICB                        pIcb,
    PPROTO_CB                   pProto,
    PIP_ADAPTER_BINDING_INFO    pBindInfo
    );

DWORD
UnbindInterfaceInAllProtocols(
    PICB picb
    );

DWORD
AddInterfaceToAllProtocols(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    );

DWORD
AddInterfaceToProtocol(
    IN  PICB            picb,
    IN  PPROTO_CB       pProtocolCb,
    IN  PVOID           pvProtoInfo,
    IN  ULONG           ulInfoVersion,
    IN  ULONG           ulInfoSize,
    IN  ULONG           ulInfoCount
    );

DWORD
DeleteInterfaceFromAllProtocols(
    PICB picb
    );

DWORD
DisableInterfaceWithAllProtocols(
    PICB   picb
    );

DWORD
EnableInterfaceWithAllProtocols(
    PICB    picb
    );

VOID
DeleteAllInterfaces(
    VOID
    );

DWORD
DeleteSingleInterface(
    PICB picb
    );

DWORD
LanEtcInterfaceDownToUp(
    PICB   picb,
    BOOL   bAdding
    );

DWORD
WanInterfaceInactiveToUp(
    PICB   picb
    );

DWORD
GenericInterfaceComingUp(
    PICB   picb
    );

DWORD
LanEtcInterfaceUpToDown(
    PICB picb,
    BOOL bDeleted
    );

DWORD
WanInterfaceUpToInactive(
    PICB   picb,
    BOOL   bDeleted
    );

DWORD
GenericInterfaceNoLongerUp(
    PICB picb,
    BOOL bDeleted
    );

DWORD
WanInterfaceInactiveToDown(
    PICB picb,
    BOOL bDeleted
    );

DWORD
WanInterfaceDownToInactive(
    PICB picb
    );

DWORD
GetInterfaceStatusInfo(
    IN     PICB                   picb,
    IN     PRTR_TOC_ENTRY         pToc,
    IN     PBYTE                  pbDataPtr,
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    );

DWORD
SetInterfaceStatusInfo(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    );

VOID
DeAllocateBindings(
    PICB  picb
    );

DWORD
GetInterfaceStatistics(
    IN   PICB       picb,
    OUT  PMIB_IFROW pOutBuffer
    );

DWORD
SetInterfaceStatistics(
    IN PICB picb,
    IN PMIB_IFROW lpInBuffer
    );

DWORD
SetInterfaceAdminStatus(
    IN PICB     picb,
    IN DWORD    dwAdminStatus
    );

DWORD
InterfaceAdminStatusSetToUp(
    IN  PICB    picb
    );

DWORD
InterfaceAdminStatusSetToDown(
    IN  PICB    picb
    );

VOID
HandleAddressChangeNotification(
    VOID
    );

DWORD
UpdateBindingInformation(
    PICB picb
    );

DWORD
GetAdapterInfo(
    DWORD    dwIpAddress,
    PDWORD   pdwAdapterId,
    PDWORD   pdwBCastBit,
    PDWORD   pdwReasmSize
    );

DWORD
GetIpInfoForInterface(
    IN  DWORD   dwIfIndex,
    OUT PULONG  pulNumAddresses,
    OUT ICB_BINDING **ppAddresses,
    OUT PDWORD  pdwBCastBit,
    OUT PDWORD  pdwReasmSize
    );

DWORD
GetBestNextHopMaskGivenICB(
    PICB     picb,
    DWORD    dwNextHopAddr
    );

DWORD
GetBestNextHopMaskGivenIndex(
    DWORD  dwIfIndex,
    DWORD  dwNextHopAddr
    );

DWORD
InitializeLoopbackInterface(
    PICB    picb
    );

DWORD
DeleteLoopbackInterface(
    VOID
    );

DWORD
LanEtcInterfaceInitToDown(
    PICB picb
    );

DWORD
ReadAddressFromRegistry(
    IN  PWCHAR          pwszIfName,
    OUT PDWORD          pdwNumAddresses,
    OUT ICB_BINDING     **ppibAddressInfo,
    IN  BOOL            bInternalIf
    );

DWORD
ReadAddressAndMaskValues(
    IN  HKEY        hkeyAdapterSection,
    IN  PSZ         pszRegAddressValue,
    IN  PSZ         pszRegMaskValue,
    OUT ICB_BINDING **ppibAddressInfo,
    OUT PDWORD      pdwNumAddresses
    );


DWORD
ParseAddressAndMask(
    IN  PBYTE       pbyAddresses,
    IN  DWORD       dwAddressSize,
    IN  PBYTE       pbyMasks,
    IN  DWORD       dwMaskSize,
    OUT ICB_BINDING **ppibAddressInfo,
    OUT PDWORD      pdwNumAddresses
    );

DWORD
SetInterfaceReceiveType(
    IN  DWORD   dwProtocolId,
    IN  DWORD   dwIfIndex,
    IN  DWORD   dwInterfaceReceiveType,
    IN  BOOL    bActivate
    );

DWORD
HandleMediaSenseEvent(
    IN  PICB    pIcb,
    IN  BOOL    bSensed
    );

#define IS_ROUTABLE(ipAddr)  ((ipAddr) != htonl(INADDR_LOOPBACK))

DWORD
GetRouterId(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\info.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\info.c

Abstract:
    All info structure related code lives here

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

#include "allinc.h"

PRTR_TOC_ENTRY
GetPointerToTocEntry(
    DWORD                     dwType, 
    PRTR_INFO_BLOCK_HEADER    pInfoHdr
    )

/*++

Routine Description

    Given a pointer to an InfoBlock, this returns a pointer to the
    TOC of a given type

Locks

    None

Arguments

    dwType      InfoType for TOC
    pInfoHdr    Pointer to the InfoBlock header
    
Return Value

    NULL if the structure was not found
    Pointer to TOC other wise

--*/

{
    DWORD   i;

    if(pInfoHdr is NULL)
    {
        return NULL;
    }

    for(i = 0; i < pInfoHdr->TocEntriesCount; i++) 
    {
        if(pInfoHdr->TocEntry[i].InfoType is dwType) 
        {
            return &(pInfoHdr->TocEntry[i]);
        }
    }

    return NULL;
}


DWORD
GetSizeOfInterfaceConfig(
    PICB   picb
    )

/*++

Routine Description

    This function figures out the size of interface configuration

Locks

    ICB_LIST lock taken as READER
    Takes the PROTOCOL_CB_LIST lock as reader
    
Arguments

    picb    ICB for the interface

Return Value

    None    

--*/

{
    DWORD        dwRoutProtInfoSize,dwRouteCount;
    PLIST_ENTRY  pleNode;
    DWORD        dwSize = 0, dwNumFilters;
    DWORD        dwResult;
    DWORD        dwInfoSize, i;
    ULONG        ulStructureSize, ulStructureVersion, ulStructureCount;
    TraceEnter("GetSizeOfInterfaceConfig");

    //
    // Start with just the header (no TOC entry)
    //
    
    dwSize = FIELD_OFFSET(RTR_INFO_BLOCK_HEADER,
                          TocEntry[0]);
    
    //
    // Static Routes:
    // Get the count, figure out the size needed to hold those, add the
    // size of a TOC and an ALIGN_SIZE added for alignment
    //
    
    dwRouteCount = GetNumStaticRoutes(picb);
    
    dwSize += (SIZEOF_ROUTEINFO(dwRouteCount) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

    //
    // Router Discovery info
    //
    
    dwSize += (sizeof(RTR_DISC_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

    //
    // Interface Status info
    //

    dwSize += (sizeof(INTERFACE_STATUS_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

    //
    // If this is an ip in ip interface, add that info
    //

    if(picb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwSize += (sizeof(IPINIP_CONFIG_INFO) +
                   sizeof(RTR_TOC_ENTRY) +
                   ALIGN_SIZE);
    }

    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetInterfaceInfo)
            continue;

        dwInfoSize = 0;

        dwResult = g_rgicInfoCb[i].pfnGetInterfaceInfo(picb,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       &dwInfoSize);

        if((dwResult isnot NO_ERROR) and
           (dwResult isnot ERROR_INSUFFICIENT_BUFFER))
        {
            //
            // The only errors which will tell us the size needed are
            // NO_ERROR and ERROR_INSUFFICIENT_BUFFER. Anything else means
            // we didnt get the right size
            //
            
            Trace2(ERR,
                   "GetSizeOfInterfaceConfig: Error %d in GetIfInfo for %s\n",
                   dwResult,
                   g_rgicInfoCb[i].pszInfoName);
            
            continue;
        }

        dwSize += (dwInfoSize +
                   sizeof(RTR_TOC_ENTRY) +
                   ALIGN_SIZE); 
    }

    //
    // Information for all routing protocols ON THIS interface
    //
    
    ENTER_READER(PROTOCOL_CB_LIST);

    for(pleNode = picb->leProtocolList.Flink;
        pleNode isnot &(picb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);
       
        if(pProto->bPromiscuous)
        {
            //
            // This interface was added merely because of promiscuous mode
            //

            continue;
        }
 
        //
        // Call the routing protocol's GetInterfaceConfigInfo() entrypoint
        // with a NULL buffer. This will cause it to tell us the size of
        // its config
        //
        
        dwRoutProtInfoSize = 0;

        dwResult = (pProto->pActiveProto->pfnGetInterfaceInfo)(
                       picb->dwIfIndex, 
                       NULL, 
                       &dwRoutProtInfoSize,
                       &ulStructureVersion,
                       &ulStructureSize,
                       &ulStructureCount);
        
        if((dwResult isnot NO_ERROR) and
           (dwResult isnot ERROR_INSUFFICIENT_BUFFER))
        {
            //
            // The only errors which will tell us the size needed are
            // NO_ERROR and ERROR_INSUFFICIENT_BUFFER. Anything else means
            // we didnt get the right size
            //
            
            Trace2(ERR,
                   "GetSizeOfInterfaceConfig: Error %d in GetIfInfo for %S\n",
                   dwResult,
                   pProto->pActiveProto->pwszDisplayName);
            
            continue;
        }
        
        dwSize += (dwRoutProtInfoSize +
                   sizeof(RTR_TOC_ENTRY) +
                   ALIGN_SIZE); 
    }

    EXIT_LOCK(PROTOCOL_CB_LIST);

    //
    // If we have filters on this interface, add that info
    //
    
    if(picb->pInFilter)
    {
        dwNumFilters = picb->pInFilter->dwNumFilters;

        
        dwSize += (sizeof(RTR_TOC_ENTRY) +
                   FIELD_OFFSET(FILTER_DESCRIPTOR, fiFilter[0]) +
                   (dwNumFilters * sizeof(FILTER_INFO)) +
                   ALIGN_SIZE);
    }

    if(picb->pOutFilter)
    {
        dwNumFilters = picb->pOutFilter->dwNumFilters;

        
        dwSize += (sizeof(RTR_TOC_ENTRY) +
                   FIELD_OFFSET(FILTER_DESCRIPTOR, fiFilter[0]) +
                   (dwNumFilters * sizeof(FILTER_INFO)) +
                   ALIGN_SIZE);
    }

    //
    // Always report the fragmentation filter.
    //

    dwSize += (sizeof(IFFILTER_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

    
    if(picb->pDemandFilter)
    {
        dwNumFilters = picb->pDemandFilter->dwNumFilters;

        
        dwSize += (sizeof(RTR_TOC_ENTRY) +
                   FIELD_OFFSET(FILTER_DESCRIPTOR, fiFilter[0]) +
                   (dwNumFilters * sizeof(FILTER_INFO)) +
                   ALIGN_SIZE);
    }

    return dwSize;
}


DWORD
GetInterfaceConfiguration(
    PICB                      picb,
    PRTR_INFO_BLOCK_HEADER    pInfoHdrAndBuffer,
    DWORD                     dwInfoSize
    )
{
    DWORD                   i,dwErr, dwRet;
    DWORD                   dwTocIndex;
    PBYTE                   pbyDataPtr , pbyEndPtr;
    DWORD                   dwNumTocEntries;
    LONG                    lSize;
    PLIST_ENTRY             pleNode;

    TraceEnter("GetInterfaceConfiguration");
   
    dwRet = NO_ERROR;
 
    //
    // First calculate number of TOCs
    //

    //
    // for static routes, router discovery, interface info and frag info
    //
    
    dwNumTocEntries = TOCS_ALWAYS_IN_INTERFACE_INFO;

    //
    // One TOC for each filter that exists
    //
    
    if(picb->pInFilter)
    {
        dwNumTocEntries++;
    }

    if(picb->pOutFilter)
    {
        dwNumTocEntries++;
    }

    if(picb->pDemandFilter)
    {
        dwNumTocEntries++;
    }

    if(picb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwNumTocEntries++;
    }

    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetInterfaceInfo)
            continue;

        lSize = 0;

        dwErr = g_rgicInfoCb[i].pfnGetInterfaceInfo(picb,
                                     NULL,
                                     &dwNumTocEntries,
                                     NULL,
                                     NULL,
                                     &lSize);
    }


    //
    // One TOC for each configured protocol
    //

    // *** Exclusion Begin ***
    ENTER_READER(PROTOCOL_CB_LIST);

    for(pleNode = picb->leProtocolList.Flink;
        pleNode isnot &(picb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;

        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);

        if(pProto->bPromiscuous)
        {
            continue;
        }

        dwNumTocEntries++;
    }

    //
    // fill in RTR_INFO_BLOCK_HEADER
    //
    
    dwTocIndex = 0;

    pInfoHdrAndBuffer->Version          = IP_ROUTER_MANAGER_VERSION;
    pInfoHdrAndBuffer->TocEntriesCount  = dwNumTocEntries;
    pInfoHdrAndBuffer->Size             = dwInfoSize;
    
    //
    // Data begins after TocEntry[dwNumTocEntries - 1]
    //
    
    pbyDataPtr = ((PBYTE) &(pInfoHdrAndBuffer->TocEntry[dwNumTocEntries]));

    //
    // Align to an 8byte boundary
    //
    
    ALIGN_POINTER(pbyDataPtr);
    
    pbyEndPtr = (PBYTE)pInfoHdrAndBuffer + dwInfoSize;
    
    //
    // So the size of buffer left for information is
    //
    
    lSize =  (LONG)(pbyEndPtr - pbyDataPtr);
    
    //
    // fill in routing protocol info
    //
    
    
    for(pleNode = picb->leProtocolList.Flink;
        pleNode isnot &(picb->leProtocolList);
        pleNode = pleNode->Flink)
    {
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,IF_PROTO,leIfProtoLink);
        
        if(pProto->bPromiscuous)
        {
            //
            // This interface was added merely because of promiscuous mode
            //

            continue;
        }

        if(lSize <= 0)
        {
            Trace0(ERR,
                   "GetInterfaceConfiguration: There is no more space left to fill in config info even though there are more protocols");

            break;
        }
            
        dwErr = GetInterfaceRoutingProtoInfo(
                    picb, 
                    pProto->pActiveProto, 
                    &pInfoHdrAndBuffer->TocEntry[dwTocIndex++], 
                    pbyDataPtr, 
                    pInfoHdrAndBuffer, 
                    &lSize);
        
        if(dwErr isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GetInterfaceConfiguration: Info from %S. Error %d",
                   pProto->pActiveProto->pwszDisplayName,
                   dwErr);

            dwRet = ERROR_MORE_DATA;
        }
        else
        {
            pbyDataPtr += lSize;
            ALIGN_POINTER(pbyDataPtr);
        }
            
        lSize =  (LONG)(pbyEndPtr - pbyDataPtr);
    }

    EXIT_LOCK(PROTOCOL_CB_LIST);

    if(lSize <= 0)
    {
        Trace0(ERR,
               "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
        return ERROR_MORE_DATA;
    }


    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetInterfaceInfo)
            continue;

        dwErr = g_rgicInfoCb[i].pfnGetInterfaceInfo(picb,
                                     &pInfoHdrAndBuffer->TocEntry[dwTocIndex],
                                     &dwTocIndex,
                                     pbyDataPtr,
                                     pInfoHdrAndBuffer,
                                     &lSize);

        if(dwErr isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GetInterfaceConfiguration: Error %d getting %s info.",
                   dwErr,
                   g_rgicInfoCb[i].pszInfoName);

            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        else
        {
            pbyDataPtr += lSize;

            ALIGN_POINTER(pbyDataPtr);
        }

        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);
    }

    if(picb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwErr = GetInterfaceIpIpInfo(picb,
                                     &pInfoHdrAndBuffer->TocEntry[dwTocIndex++],
                                     pbyDataPtr,
                                     pInfoHdrAndBuffer,
                                     &lSize);

        if(dwErr isnot NO_ERROR)
        {
            Trace1(ERR,
                   "GetInterfaceConfiguration: Couldnt ipip info. Error %d",
                   dwErr);

            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        else
        {
            pbyDataPtr += lSize;

            ALIGN_POINTER(pbyDataPtr);
        }

        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);
    }

        
    //
    // fill in route info
    //

    
    dwErr = GetInterfaceRouteInfo(picb, 
                                  &pInfoHdrAndBuffer->TocEntry[dwTocIndex++], 
                                  pbyDataPtr, 
                                  pInfoHdrAndBuffer,
                                  &lSize);
    
    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetInterfaceConfiguration: Couldnt Interface route info. Error %d",
               dwErr);

        if(dwErr isnot ERROR_NO_DATA)
        {
            dwRet = ERROR_MORE_DATA;
        }
    }
    else
    {
        pbyDataPtr += lSize;
        
        ALIGN_POINTER(pbyDataPtr);
    }
        
    lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

    if(lSize <= 0)
    {
        Trace0(ERR,
               "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
        return ERROR_MORE_DATA;
    }
     
    //
    // Fill in the status info
    //

    dwErr = GetInterfaceStatusInfo(picb,
                                   &pInfoHdrAndBuffer->TocEntry[dwTocIndex++],
                                   pbyDataPtr,
                                   pInfoHdrAndBuffer,
                                   &lSize);

    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetInterfaceConfiguration: Error %d getting Interface status",
               dwErr);

        if(dwErr isnot ERROR_NO_DATA)
        {
            dwRet = ERROR_MORE_DATA;
        }
    }
    else
    {
        pbyDataPtr += lSize;

        ALIGN_POINTER(pbyDataPtr);
    }

    lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

    if(lSize <= 0)
    {
        Trace0(ERR,
               "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
        return ERROR_MORE_DATA;
    }
     
    //
    // Fill in the Router Discovery information
    //
    
    dwErr = GetInterfaceRouterDiscoveryInfo(
                picb, 
                &pInfoHdrAndBuffer->TocEntry[dwTocIndex++],
                pbyDataPtr, 
                pInfoHdrAndBuffer,
                &lSize);

    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetInterfaceConfiguration: Couldnt Interface router discovery info. Error %d",
               dwErr);

        if(dwErr isnot ERROR_NO_DATA)
        {
            dwRet = ERROR_MORE_DATA;
        }
    }
    else
    {
        pbyDataPtr += lSize;

        ALIGN_POINTER(pbyDataPtr);
    }

    lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

    if(lSize <= 0)
    {
        Trace0(ERR,
               "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
        return ERROR_MORE_DATA;
    }
     
    if(picb->pInFilter)
    {
        dwErr = GetInFilters(picb,
                             &pInfoHdrAndBuffer->TocEntry[dwTocIndex], 
                             pbyDataPtr, 
                             pInfoHdrAndBuffer, 
                             &lSize);
        
        if(dwErr is NO_ERROR)
        {
            dwTocIndex++;
            
            pbyDataPtr += lSize;
            
            ALIGN_POINTER(pbyDataPtr);
        }
        else
        {
            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        
        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

        if(lSize <= 0)
        {
            Trace0(ERR,
                   "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
            return ERROR_MORE_DATA;
        }
    }
     
    if(picb->pOutFilter)
    {
        dwErr = GetOutFilters(picb,
                              &pInfoHdrAndBuffer->TocEntry[dwTocIndex], 
                              pbyDataPtr, 
                              pInfoHdrAndBuffer, 
                              &lSize);
        
        if(dwErr is NO_ERROR)
        {
            dwTocIndex++;
            
            pbyDataPtr += lSize;
            
            ALIGN_POINTER(pbyDataPtr);
        }
        else
        {
            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        
        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

        if(lSize <= 0)
        {
            Trace0(ERR,
                   "GetInterfaceConfiguration: There is no more space left to fill in config info");
        
            return ERROR_MORE_DATA;
        }
    }
   
    if((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
       (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
       (picb->ritType isnot ROUTER_IF_TYPE_CLIENT))
    {
        dwErr = GetGlobalFilterOnIf(picb,
                                    &pInfoHdrAndBuffer->TocEntry[dwTocIndex],
                                    pbyDataPtr,
                                    pInfoHdrAndBuffer,
                                    &lSize);

        if(dwErr is NO_ERROR)
        {
            dwTocIndex++;

            pbyDataPtr += lSize;

            ALIGN_POINTER(pbyDataPtr);
        }
        else
        {
            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }

        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);

        if(lSize <= 0)
        {
            Trace0(ERR,
                   "GetInterfaceConfiguration: There is no more space left to fill in config info");

            return ERROR_MORE_DATA;
        }
    }

    if(picb->pDemandFilter)
    {
        dwErr = GetDemandFilters(picb,
                                 &pInfoHdrAndBuffer->TocEntry[dwTocIndex], 
                                 pbyDataPtr, 
                                 pInfoHdrAndBuffer, 
                                 &lSize);
        
        if(dwErr is NO_ERROR)
        {
            dwTocIndex++;
            
            pbyDataPtr += lSize;
            
            ALIGN_POINTER(pbyDataPtr);
        }
        else
        {
            if(dwErr isnot ERROR_NO_DATA)
            {
                dwRet = ERROR_MORE_DATA;
            }
        }
        
        lSize =  (LONG) (pbyEndPtr - pbyDataPtr);
    }

    return dwRet;
}


DWORD
GetInterfaceRoutingProtoInfo(
    PICB                   picb, 
    PPROTO_CB     pProtoCbPtr,
    PRTR_TOC_ENTRY         pToc,
    PBYTE                  pbyDataPtr, 
    PRTR_INFO_BLOCK_HEADER pInfoHdrAndBuffer,
    PDWORD                 pdwSize
    )
{
    ULONG   ulStructureSize, ulStructureCount, ulStructureVersion;
    DWORD   dwError = NO_ERROR;

    TraceEnter("GetInterfaceRoutingProtoInfo");
    
    dwError = (pProtoCbPtr->pfnGetInterfaceInfo)(picb->dwIfIndex,
                                                 pbyDataPtr,
                                                 pdwSize,
                                                 &ulStructureVersion,
                                                 &ulStructureSize,
                                                 &ulStructureCount);
    
    if(dwError isnot NO_ERROR) 
    {
        Trace1(ERR,
               "GetInterfaceRoutingProtoInfo: GetIfConfigInfo() failed for protocol %S", 
               pProtoCbPtr->pwszDisplayName);

        return dwError;
    }

    //IpRtAssert(*pdwSize is (ulStructureSize * ulStructureCount));

    pToc->InfoSize  = ulStructureSize;
    pToc->InfoType  = pProtoCbPtr->dwProtocolId;
    pToc->Count     = ulStructureCount;
    pToc->Offset    = (ULONG)(pbyDataPtr - (PBYTE)pInfoHdrAndBuffer);
    //pToc->InfoVersion   = ulStructureVersion;

    return NO_ERROR;
}


DWORD
GetGlobalConfiguration(
    PRTR_INFO_BLOCK_HEADER   pInfoHdrAndBuffer,
    DWORD                    dwInfoSize
    )
{
    DWORD               dwRoutProtInfoSize;
    PPROTO_CB  pProtoCbPtr;
    DWORD               dwNumTocEntries, i;
    DWORD               dwTocIndex,dwResult;
    DWORD               dwBufferRemaining,dwSize,dwIndex;
    PBYTE               pbyDataPtr, pbyEndPtr;
    PLIST_ENTRY         pleNode;
    PGLOBAL_INFO        pGlobalInfo;
    ULONG               ulStructureVersion, ulStructureSize, ulStructureCount;
 
    TraceEnter("GetGlobalConfiguration");

    // 
    // First calculate number of TOCs
    //

    dwNumTocEntries = TotalRoutingProtocols + TOCS_ALWAYS_IN_GLOBAL_INFO;
    
    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetGlobalInfo)
            continue;

        dwSize = 0;

        dwResult = g_rgicInfoCb[i].pfnGetGlobalInfo(NULL,
                                                    &dwNumTocEntries,
                                                    NULL,
                                                    NULL,
                                                    &dwSize);
    }
    
    //
    // Fill Header, RTR_TOC_ENTRYs for global, priority and each of the protos
    //
    
    pInfoHdrAndBuffer->Version          = IP_ROUTER_MANAGER_VERSION;
    pInfoHdrAndBuffer->TocEntriesCount  = dwNumTocEntries;


    //
    // Fill in TOCs. Data starts after the last TOC
    //
    
    pbyDataPtr   = (PBYTE)&(pInfoHdrAndBuffer->TocEntry[pInfoHdrAndBuffer->TocEntriesCount]);

    pbyEndPtr    = (PBYTE)pInfoHdrAndBuffer + dwInfoSize;

    ALIGN_POINTER(pbyDataPtr);
    
    dwTocIndex        = 0;
    dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);
                        

    //
    // Fill in Routing Protocol Priority infoblock
    //
    
    dwRoutProtInfoSize = dwBufferRemaining;

    dwResult = GetPriorityInfo(pbyDataPtr, &dwRoutProtInfoSize);
    
    //pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoVersion  = dwRoutProtInfoSize;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoSize  = dwRoutProtInfoSize;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoType  = IP_PROT_PRIORITY_INFO;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].Count     = 1;
    
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].Offset    =
        (ULONG)(pbyDataPtr - (PBYTE)pInfoHdrAndBuffer);
    
    dwTocIndex++;
    
    pbyDataPtr           += dwRoutProtInfoSize;
    
    ALIGN_POINTER(pbyDataPtr);

    dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);

    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetGlobalInfo)
            continue;

        dwSize = dwBufferRemaining;

        dwResult = g_rgicInfoCb[i].pfnGetGlobalInfo(
                                     &pInfoHdrAndBuffer->TocEntry[dwTocIndex],
                                     &dwTocIndex,
                                     pbyDataPtr,
                                     pInfoHdrAndBuffer,
                                     &dwSize);

        pbyDataPtr += dwSize;
    
        ALIGN_POINTER(pbyDataPtr);

        dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);
    }

    dwSize = sizeof(GLOBAL_INFO);

    pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoSize  = dwSize;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoType  = IP_GLOBAL_INFO;
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].Count     = 1;
    //pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoVersion = 1;
    
    pInfoHdrAndBuffer->TocEntry[dwTocIndex].Offset    =
        (ULONG)(pbyDataPtr - (PBYTE) pInfoHdrAndBuffer);
    
    pGlobalInfo = (PGLOBAL_INFO)pbyDataPtr;

    //
    // unused
    //
    
    pGlobalInfo->bFilteringOn   = 0;
    
    pGlobalInfo->dwLoggingLevel = g_dwLoggingLevel;
 
    dwTocIndex++;
    
    pbyDataPtr           += dwSize;
    
    ALIGN_POINTER(pbyDataPtr);

    dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);
    
    //
    // fill in global info for all routing protocols
    //
    
    for(pleNode = g_leProtoCbList.Flink; 
        pleNode != &g_leProtoCbList; 
        pleNode = pleNode->Flink) 
    {
        
    	pProtoCbPtr = CONTAINING_RECORD(pleNode,
                                        PROTO_CB,
                                        leList);

        dwRoutProtInfoSize = dwBufferRemaining;

    	dwResult = (pProtoCbPtr->pfnGetGlobalInfo)(pbyDataPtr,
                                                   &dwRoutProtInfoSize,
                                                   &ulStructureVersion,
                                                   &ulStructureSize,
                                                   &ulStructureCount);
        
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GetGlobalConfiguration: Error %d getting global info from %s",
                   dwResult,
                   pProtoCbPtr->pwszDllName);
            
            continue;
        }
        
    	// pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoVersion = ulStructureVersion;
        
    	pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoSize =
            ulStructureSize;
        
    	pInfoHdrAndBuffer->TocEntry[dwTocIndex].InfoType =
            pProtoCbPtr->dwProtocolId;
        
    	pInfoHdrAndBuffer->TocEntry[dwTocIndex].Offset   =
            (ULONG)(pbyDataPtr - (PBYTE)pInfoHdrAndBuffer);

        pInfoHdrAndBuffer->TocEntry[dwTocIndex].Count = ulStructureCount;

        dwTocIndex++;
        
        pbyDataPtr += dwRoutProtInfoSize;

        ALIGN_POINTER(pbyDataPtr);

        dwBufferRemaining = (DWORD)(pbyEndPtr - pbyDataPtr);
    }

    pInfoHdrAndBuffer->Size = (ULONG) ((ULONG_PTR)pbyDataPtr - (ULONG_PTR)pInfoHdrAndBuffer);

    return NO_ERROR;
}

DWORD
GetSizeOfGlobalInfo(
    VOID
    )
{
    DWORD               dwSize = 0, dwResult;
    DWORD               dwRoutProtInfoSize;
    PICB                picb;
    PPROTO_CB  pProtoCbPtr;
    PLIST_ENTRY         pleNode;
    DWORD               dwInfoSize, i;
    ULONG               ulStructureVersion, ulStructureSize, ulStructureCount;

    TraceEnter("GetSizeOfGlobalInfo");
    
    dwSize = sizeof(RTR_INFO_BLOCK_HEADER) - sizeof(RTR_TOC_ENTRY);
    
    //
    // get size of Routing Protocol Priority info
    //
    
    dwRoutProtInfoSize = 0;
    
    GetPriorityInfo(NULL,
                    &dwRoutProtInfoSize);
    
    //
    // ALIGN_SIZE added for alignment
    //

    dwSize += (dwRoutProtInfoSize +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE); 

    for(i = 0; i < NUM_INFO_CBS; i++)
    {
        if (!g_rgicInfoCb[i].pfnGetGlobalInfo)
            continue;

        dwInfoSize = 0;

        dwResult = g_rgicInfoCb[i].pfnGetGlobalInfo(NULL,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    &dwInfoSize);

        if((dwResult isnot NO_ERROR) and
           (dwResult isnot ERROR_INSUFFICIENT_BUFFER))
        {
            //
            // The only errors which will tell us the size needed are
            // NO_ERROR and ERROR_INSUFFICIENT_BUFFER. Anything else means
            // we didnt get the right size
            //
            
            Trace2(ERR,
                   "GetSizeOfGlobalInfo: Error %d in GetGlobInfo for %s\n",
                   dwResult,
                   g_rgicInfoCb[i].pszInfoName);
            
            continue;
        }

        dwSize += (dwInfoSize +
                   sizeof(RTR_TOC_ENTRY) +
                   ALIGN_SIZE); 
    }


    //
    // The names of the Dlls - part of Global Info
    //
    
    dwSize += (sizeof(GLOBAL_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);
    
    //
    // get size of infoblocks for all routing protocols
    //
    
    for(pleNode  = g_leProtoCbList.Flink; 
        pleNode isnot &g_leProtoCbList; 
        pleNode = pleNode->Flink) 
    {
        pProtoCbPtr = CONTAINING_RECORD(pleNode,
                                        PROTO_CB,
                                        leList);
        
        //
        // Call the routing protocol's GetGlobalConfigInfo() entrypoint
        // with NULL. This should return the buffer size needed
        //
        
        dwRoutProtInfoSize = 0;
        
        dwResult = (pProtoCbPtr->pfnGetGlobalInfo)(NULL,
                                                   &dwRoutProtInfoSize,
                                                   &ulStructureVersion,
                                                   &ulStructureSize,
                                                   &ulStructureCount);

        if((dwResult is NO_ERROR) or
           (dwResult is ERROR_INSUFFICIENT_BUFFER))
        {
            dwSize += (dwRoutProtInfoSize +
                       sizeof(RTR_TOC_ENTRY) +
                       ALIGN_SIZE);
        }
    }

    return dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\ipipcfg.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    net\routing\ip\ipinip\ipipcfg.h

Abstract:

    The configuration DLL for ipinip

Revision History:

    Amritansh Raghav

--*/


#ifndef __IPIPCFG_H__
#define __IPIPCFG_H__


#define REG_VAL_DEFGATEWAY              TEXT("DefaultGateway")
#define REG_VAL_ENABLEDHCP              TEXT("EnableDHCP")
#define REG_VAL_IPADDRESS               TEXT("IPAddress")
#define REG_VAL_NTECONTEXTLIST          TEXT("NTEContextList")
#define REG_VAL_SUBNETMASK              TEXT("SubnetMask")
#define REG_VAL_ZEROBCAST               TEXT("UseZeroBroadcast")

#define IPIP_PREFIX_STRING              TEXT("IpInIp")
#define IPIP_PREFIX_STRING_U            L"IpInIp"

//
// used for notifications
//

IPINIP_NOTIFICATION     g_inIpInIpMsg;
OVERLAPPED              g_IpInIpOverlapped;

DWORD
OpenIpIpKey(
    VOID
    );

VOID
CloseIpIpKey(
    VOID
    );

VOID
DeleteIpIpKeyAndInfo(
    IN  PICB    pIcb
    );

DWORD
CreateIpIpKeyAndInfo(
    IN  PICB    pIcb
    );


DWORD
AddInterfaceToIpInIp(
    IN  GUID    *pGuid,
    IN  PICB    picb
    );

DWORD
DeleteInterfaceFromIpInIp(
    PICB    picb
    );

DWORD
SetIpInIpInfo(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    );

DWORD
GetInterfaceIpIpInfo(
    IN     PICB                   picb,
    IN     PRTR_TOC_ENTRY         pToc,
    IN     PBYTE                  pbDataPtr,
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    );

DWORD
PostIpInIpNotification(
    VOID
    );

VOID
HandleIpInIpEvent(
    VOID
    );

#endif //__IPIPCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\init.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\init.c

Abstract:
    IP Router Manager code

Revision History:

    Gurdeep Singh Pall          6/14/95  Created

--*/

#include "allinc.h"


DWORD
RtrMgrMIBEntryCreate(
    IN DWORD           dwRoutingPid,
    IN DWORD           dwEntrySize,
    IN LPVOID          lpEntry
    );


DWORD
RtrMgrMIBEntryDelete(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );

DWORD
RtrMgrMIBEntryGet(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );

DWORD
RtrMgrMIBEntryGetFirst(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );

DWORD
RtrMgrMIBEntryGetNext(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );

DWORD
RtrMgrMIBEntrySet(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );


DWORD
InitRouter(
    PRTR_INFO_BLOCK_HEADER pGlobalInfo
    )

/*++

Routine Description:

    Loads routing protocols, loads bootp agent, opens the approp. drivers,
    and starts the worker thread.

Arguments:

    GlobalInfo passed in by DIM

Return Value:

    NO_ERROR or some error code

--*/

{
    HANDLE          hThread;
    DWORD           dwResult, dwTid, i;
    PGLOBAL_INFO    pInfo;
    PRTR_TOC_ENTRY  pToc;
    IPSNMPInfo      ipsiInfo;

    RTM_ENTITY_INFO entityInfo;

    PIP_NAT_GLOBAL_INFO     pNatInfo;
    PMIB_IPFORWARDTABLE     pInitRouteTable;
    PROUTE_LIST_ENTRY       prl;
    MGM_CALLBACKS           mgmCallbacks;
    ROUTER_MANAGER_CONFIG   mgmConfig;

    TraceEnter("InitRouter");

    //
    // Initialize all the locks (MIB handlers and ICB_LIST/PROTOCOL_CB_LIST)
    // VERY IMPORTANT, since we break out of this and try and do a cleanup
    // which needs the lists and the locks, WE MUST initialize the lists
    // and the locks BEFORE the first abnormal exit from this function
    //

    for(i = 0; i < NUM_LOCKS; i++)
    {
        RtlInitializeResource(&g_LockTable[i]);
    }

    //
    // Init the list head for interfaces
    //

    InitializeListHead(&ICBList);

    //
    // Initialize ICB Hash lookup table and the Adapter to Interface Hash
    //

    for (i=0; i<ICB_HASH_TABLE_SIZE; i++)
    {
        InitializeListHead(&ICBHashLookup[i]);
        InitializeListHead(&ICBSeqNumLookup[i]);
    }

    InitHashTables();

    //
    // Initialize Routing protocol List
    //

    InitializeListHead(&g_leProtoCbList);

    //
    // Initialize the Router Discovery Timer Queue
    //

    InitializeListHead(&g_leTimerQueueHead);


    pToc = GetPointerToTocEntry(IP_GLOBAL_INFO, pGlobalInfo);

    if(!pToc or (pToc->InfoSize is 0))
    {
        LogErr0(NO_GLOBAL_INFO,
                ERROR_NO_DATA);

        Trace0(ERR,
               "InitRouter: No Global Info - can not start router");

        TraceLeave("InitRouter");

        return ERROR_CAN_NOT_COMPLETE;
    }

    pInfo = (PGLOBAL_INFO)GetInfoFromTocEntry(pGlobalInfo,
                                              pToc);
    if(pInfo is NULL)
    {
        LogErr0(NO_GLOBAL_INFO,
                ERROR_NO_DATA);

        Trace0(ERR,
               "InitRouter: No Global Info - can not start router");

        TraceLeave("InitRouter");
        
        return ERROR_CAN_NOT_COMPLETE;
    }

#pragma warning(push)
#pragma warning(disable:4296)

    if((pInfo->dwLoggingLevel > IPRTR_LOGGING_INFO) or
       (pInfo->dwLoggingLevel < IPRTR_LOGGING_NONE))

#pragma warning(pop)

    {
        Trace1(ERR,
               "InitRouter: Global info has invalid logging level of %d",
               pInfo->dwLoggingLevel);

        g_dwLoggingLevel = IPRTR_LOGGING_INFO;
    }
    else
    {
        g_dwLoggingLevel = pInfo->dwLoggingLevel;
    }


    //
    // Allocate private heap
    //

    IPRouterHeap = HeapCreate(0, 5000, 0);

    if(IPRouterHeap is NULL)
    {
        dwResult = GetLastError() ;

        Trace1(ERR,
               "InitRouter: Error %d creating IPRouterHeap",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    //
    // Create the events needed to talk to the routing protocols,
    // DIM and WANARP
    //

    g_hRoutingProtocolEvent     = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hStopRouterEvent          = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hSetForwardingEvent       = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hForwardingChangeEvent    = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hDemandDialEvent          = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hIpInIpEvent              = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hStackChangeEvent         = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hRtrDiscSocketEvent       = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hMHbeatSocketEvent        = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hMcMiscSocketEvent        = CreateEvent(NULL,FALSE,FALSE,NULL);
    g_hMzapSocketEvent          = CreateEvent(NULL,FALSE,FALSE,NULL);

    for(i = 0; i < NUM_MCAST_IRPS; i++)
    {
        g_hMcastEvents[i] = CreateEvent(NULL,FALSE,FALSE,NULL);
    }

    for(i = 0; i < NUM_ROUTE_CHANGE_IRPS; i++)
    {
        g_hRouteChangeEvents[i] = CreateEvent(NULL,FALSE,FALSE,NULL);
    }


    g_hRtrDiscTimer = CreateWaitableTimer(NULL,
                                          FALSE,
                                          NULL);

    g_hRasAdvTimer = CreateWaitableTimer(NULL,
                                         FALSE,
                                         NULL);

    g_hMzapTimer = CreateWaitableTimer(NULL,
                                       FALSE,
                                       NULL);

    if((g_hRoutingProtocolEvent is NULL) or
       (g_hStopRouterEvent is NULL) or
       (g_hSetForwardingEvent is NULL) or
       (g_hForwardingChangeEvent is NULL) or
       (g_hDemandDialEvent is NULL) or
       (g_hIpInIpEvent is NULL) or
       (g_hStackChangeEvent is NULL) or
       (g_hRtrDiscSocketEvent is NULL) or
       (g_hRtrDiscTimer is NULL) or
       (g_hRasAdvTimer is NULL) or
       (g_hMcMiscSocketEvent is NULL) or
       (g_hMzapSocketEvent is NULL) or
       (g_hMHbeatSocketEvent is NULL))
    {
        Trace0(ERR,
               "InitRouter: Couldnt create the needed events and timer");

        TraceLeave("InitRouter");

        return ERROR_CAN_NOT_COMPLETE;
    }

    for(i = 0; i < NUM_MCAST_IRPS; i++)
    {
        if(g_hMcastEvents[i] is NULL)
        {
            Trace0(ERR,
                   "InitRouter: Couldnt create the mcast events");

            TraceLeave("InitRouter");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }


    for(i = 0; i < NUM_ROUTE_CHANGE_IRPS; i++)
    {
        if(g_hRouteChangeEvents[i] is NULL)
        {
            Trace0(ERR,
                   "InitRouter: Couldnt create the mcast events");

            TraceLeave("InitRouter");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    
    Trace0(GLOBAL,
           "InitRouter: Created necessary events and timer");

    dwResult = MprConfigServerConnect(NULL,
                                      &g_hMprConfig);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter:  Error %d calling MprConfigServerConnect",
               dwResult);

        return dwResult;
    }

    g_sinAllSystemsAddr.sin_family      = AF_INET;
    g_sinAllSystemsAddr.sin_addr.s_addr = ALL_SYSTEMS_MULTICAST_GROUP;
    g_sinAllSystemsAddr.sin_port        = 0;

    g_pIpHeader = (PIP_HEADER)g_pdwIpAndIcmpBuf;

    g_wsaIpRcvBuf.buf = (PBYTE)g_pIpHeader;
    g_wsaIpRcvBuf.len = ICMP_RCV_BUFFER_LEN * sizeof(DWORD);

    g_wsaMcRcvBuf.buf = g_byMcMiscBuffer;
    g_wsaMcRcvBuf.len = sizeof(g_byMcMiscBuffer);


    //
    // Get all the routes that are in the stack and store them away
    //

    pInitRouteTable = NULL;

    InitializeListHead( &g_leStackRoutesToRestore );

    dwResult = AllocateAndGetIpForwardTableFromStack(&pInitRouteTable,
                                                     FALSE,
                                                     IPRouterHeap,
                                                     0);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: Couldnt get initial routes. Error %d",
               dwResult);
    }

    else
    {
        if(pInitRouteTable->dwNumEntries isnot 0)
        {
            TraceRoute0( ROUTE, "Init. table routes\n" );
            
            for ( i = 0; i < pInitRouteTable-> dwNumEntries; i++ )
            {
                if (pInitRouteTable->table[i].dwForwardProto != 
                        MIB_IPPROTO_NETMGMT)
                {
                    continue;
                }

                TraceRoute3(
                    ROUTE, "%d.%d.%d.%d/%d.%d.%d.%d, type 0x%x",
                    PRINT_IPADDR( pInitRouteTable-> table[i].dwForwardDest ),
                    PRINT_IPADDR( pInitRouteTable-> table[i].dwForwardMask ),
                    pInitRouteTable-> table[i].dwForwardType
                    );

                //
                // Allocate and store route in a linked list
                //

                prl = HeapAlloc(
                        IPRouterHeap, HEAP_ZERO_MEMORY, 
                        sizeof(ROUTE_LIST_ENTRY)
                        );

                if (prl is NULL)
                {
                    Trace2(
                        ERR, 
                        "InitRouter: error %d allocating %d bytes "
                        "for stack route entry",
                        ERROR_NOT_ENOUGH_MEMORY,
                        sizeof(ROUTE_LIST_ENTRY)
                        );

                    dwResult = ERROR_NOT_ENOUGH_MEMORY;

                    break;                        
                }

                InitializeListHead( &prl->leRouteList );

                prl->mibRoute = pInitRouteTable-> table[i];

                InsertTailList( 
                    &g_leStackRoutesToRestore, &prl->leRouteList 
                    );
            }

            if (dwResult isnot NO_ERROR)
            {
                while (!IsListEmpty(&g_leStackRoutesToRestore))
                {
                    prl = (PROUTE_LIST_ENTRY) RemoveHeadList(
                                &g_leStackRoutesToRestore
                                );

                    HeapFree(IPRouterHeap, 0, prl);
                }
            }
        }

        HeapFree(IPRouterHeap, 0, pInitRouteTable);
        pInitRouteTable = NULL;
    }



    //
    // The route table is created implicitly by RTM at the
    // time of the first registration call (see call below)
    //

    //
    // Setup common params for all registrations with RTMv2
    //

    entityInfo.RtmInstanceId = 0; // routerId;
    entityInfo.AddressFamily = AF_INET;
    entityInfo.EntityId.EntityInstanceId = 0;

    //
    // Register with RTM using the appropriate proto ids
    //

    //
    // This 1st registration is also used for performing
    // RTM operations common for all these registrations,
    // As an example it is used to get any changed dests.
    //

    entityInfo.EntityId.EntityProtocolId = PROTO_IP_LOCAL;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 RtmEventCallback,
                                 FALSE,
                                 &g_rtmProfile,
                                 &g_hLocalRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for local routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }

    // Also register for dest change notifications

    dwResult = RtmRegisterForChangeNotification(g_hLocalRoute,
                                                RTM_VIEW_MASK_UCAST,
                                                RTM_CHANGE_TYPE_FORWARDING,
                                                NULL,
                                                &g_hNotification);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterForChangeNotificaition failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }

    //
    // Register more times for each type of route
    //

    entityInfo.EntityId.EntityProtocolId = PROTO_IP_NT_AUTOSTATIC;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 &g_rtmProfile,
                                 &g_hAutoStaticRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for AutoStatic routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    entityInfo.EntityId.EntityProtocolId = PROTO_IP_NT_STATIC;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 &g_rtmProfile,
                                 &g_hStaticRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for Static routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    entityInfo.EntityId.EntityProtocolId = PROTO_IP_NT_STATIC_NON_DOD;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 &g_rtmProfile,
                                 &g_hNonDodRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for DOD routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    entityInfo.EntityId.EntityProtocolId = PROTO_IP_NETMGMT;

    dwResult = RtmRegisterEntity(&entityInfo,
                                 NULL,
                                 RtmEventCallback,
                                 FALSE,
                                 &g_rtmProfile,
                                 &g_hNetMgmtRoute);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterClient for NetMgmt routes failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }

    // Also register for marked dest change notifications

    dwResult = RtmRegisterForChangeNotification(g_hNetMgmtRoute,
                                                RTM_VIEW_MASK_UCAST,
                                                RTM_CHANGE_TYPE_ALL |
                                                RTM_NOTIFY_ONLY_MARKED_DESTS,
                                                NULL,
                                                &g_hDefaultRouteNotification);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: RtmRegisterForChangeNotificaition failed %d",
               dwResult) ;

        TraceLeave("InitRouter");

        return dwResult ;
    }


    g_rgRtmHandles[0].dwProtoId     = PROTO_IP_LOCAL;
    g_rgRtmHandles[0].hRouteHandle  = g_hLocalRoute;
    g_rgRtmHandles[0].bStatic       = FALSE;

    g_rgRtmHandles[1].dwProtoId     = PROTO_IP_NT_AUTOSTATIC;
    g_rgRtmHandles[1].hRouteHandle  = g_hAutoStaticRoute;
    g_rgRtmHandles[1].bStatic       = TRUE;

    g_rgRtmHandles[2].dwProtoId     = PROTO_IP_NT_STATIC;
    g_rgRtmHandles[2].hRouteHandle  = g_hStaticRoute;
    g_rgRtmHandles[2].bStatic       = TRUE;

    g_rgRtmHandles[3].dwProtoId     = PROTO_IP_NT_STATIC_NON_DOD;
    g_rgRtmHandles[3].hRouteHandle  = g_hNonDodRoute;
    g_rgRtmHandles[3].bStatic       = TRUE;

    g_rgRtmHandles[4].dwProtoId     = PROTO_IP_NETMGMT;
    g_rgRtmHandles[4].hRouteHandle  = g_hNetMgmtRoute;
    g_rgRtmHandles[4].bStatic       = FALSE;


    //
    // Initialize MGM
    //

    mgmConfig.dwLogLevel                = g_dwLoggingLevel;

    mgmConfig.dwIfTableSize             = MGM_IF_TABLE_SIZE;
    mgmConfig.dwGrpTableSize            = MGM_GROUP_TABLE_SIZE;
    mgmConfig.dwSrcTableSize            = MGM_SOURCE_TABLE_SIZE;

    mgmConfig.pfnAddMfeCallback         = SetMfe;
    mgmConfig.pfnDeleteMfeCallback      = DeleteMfe;
    mgmConfig.pfnGetMfeCallback         = GetMfe;
    mgmConfig.pfnHasBoundaryCallback    = RmHasBoundary;

    dwResult = MgmInitialize(&mgmConfig,
                             &mgmCallbacks);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: Error %d initializing MGM\n",
               dwResult);

        TraceLeave("InitRouter");

        return dwResult;
    }

    //
    // Store callbacks into MGM
    //

    g_pfnMgmMfeDeleted      = mgmCallbacks.pfnMfeDeleteIndication;
    g_pfnMgmNewPacket       = mgmCallbacks.pfnNewPacketIndication;
    g_pfnMgmBlockGroups     = mgmCallbacks.pfnBlockGroups;
    g_pfnMgmUnBlockGroups   = mgmCallbacks.pfnUnBlockGroups;
    g_pfnMgmWrongIf         = mgmCallbacks.pfnWrongIfIndication;


    if(OpenIPDriver() isnot NO_ERROR)
    {
        Trace0(ERR,
               "InitRouter: Couldnt open IP driver");

        TraceLeave("InitRouter");

        return ERROR_OPEN_FAILED;
    }

    //
    // Do the multicast initialization
    //

    dwResult = OpenMulticastDriver();

    if(dwResult isnot NO_ERROR)
    {
        Trace0(ERR,
               "InitRoute: Could not open IP Multicast device");

        //
        // not an error, just continue;
        //
    }
    else
    {
        //
        // Find if we are in multicast mode
        //

        dwResult = StartMulticast();

        if(dwResult isnot NO_ERROR)
        {
            Trace0(ERR,
                   "InitRoute: Could not start multicast");
        }
    }

    if(!RouterRoleLanOnly)
    {
        if((dwResult = InitializeWanArp()) isnot NO_ERROR)
        {
            Trace0(ERR,
                   "InitRouter: Couldnt open WanArp driver");

            TraceLeave("InitRouter");

            return dwResult;
        }
    }

    SetPriorityInfo(pGlobalInfo);

    SetScopeInfo(pGlobalInfo);

    if((dwResult = InitializeMibHandler()) isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: InitializeMibHandler failed, returned %d",
               dwResult);

        TraceLeave("InitRouter");

        return dwResult;
    }

    //
    // Create Worker thread
    //

    hThread = CreateThread(NULL,
                           0,
                           (PVOID) WorkerThread,
                           pGlobalInfo,
                           0,
                           &dwTid) ;

    if(hThread is NULL)
    {
        dwResult = GetLastError () ;

        Trace1(ERR,
               "InitRouter: CreateThread failed %d",
               dwResult);

        TraceLeave("InitRouter");

        return dwResult ;
    }
    else
    {
        CloseHandle(hThread);
    }

    dwResult = OpenIpIpKey();

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitRouter: Error %d opening ipinip key",
               dwResult);

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // We load are routing protocols after all our own initialization,
    // since we dont know how they will interact with us
    //

    ENTER_WRITER(ICB_LIST);
    ENTER_WRITER(PROTOCOL_CB_LIST);

    LoadRoutingProtocols (pGlobalInfo);

    EXIT_LOCK(PROTOCOL_CB_LIST);
    EXIT_LOCK(ICB_LIST);

    TraceLeave("InitRouter");

    return NO_ERROR;
}


DWORD
LoadRoutingProtocols(
    PRTR_INFO_BLOCK_HEADER pGlobalInfo
    )

/*++

Routine Description:

    Loads and initializes all the routing protocols configured
    Called with ICBListLock and RoutingProcotoclCBListLock held

Arguments

    GlobalInfo passed in by DIM

Return Value:

    NO_ERROR or some error code

--*/

{
    DWORD               i, j, dwSize, dwNumProtoEntries, dwResult;
    PPROTO_CB  pNewProtocolCb;
    PWCHAR              pwszDllNames ; // array of dll names
    MPR_PROTOCOL_0      *pmpProtocolInfo;
    PVOID               pvInfo;
    BOOL                bFound;

    TraceEnter("LoadRoutingProtocols");

    dwResult = MprSetupProtocolEnum(PID_IP,
                                     (PBYTE *)(&pmpProtocolInfo),
                                     &dwNumProtoEntries);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadRoutingProtocols: Error %d loading protocol info from registry",
               dwResult);

        TraceLeave("LoadRoutingProtocols");

        return dwResult;
    }

    for(i=0; i < pGlobalInfo->TocEntriesCount; i++)
    {
        ULONG   ulStructureVersion, ulStructureSize, ulStructureCount;
        DWORD   dwType;

        //
        // Read each TOC and see if it is PROTO_TYPE_UCAST/MCAST
        // If it does it is a loadable protocol and we get its info
        // from the registry
        //

        dwType = TYPE_FROM_PROTO_ID(pGlobalInfo->TocEntry[i].InfoType);
        if((dwType < PROTO_TYPE_MS1) and
           (pGlobalInfo->TocEntry[i].InfoSize > 0))
        {

            bFound = FALSE;

            for(j = 0; j < dwNumProtoEntries; j ++)
            {
                if(pmpProtocolInfo[j].dwProtocolId is pGlobalInfo->TocEntry[i].InfoType)
                {
                    //
                    // well great, we have found it
                    //

                    bFound = TRUE;

                    break;
                }
            }

            if(!bFound)
            {
                Trace1(ERR,
                       "LoadRoutingProtocols: Couldnt find information for protocol ID %d",
                       pGlobalInfo->TocEntry[i].InfoType);

                continue;
            }


            //
            // load library on the dll name provided
            //

            dwSize = (wcslen(pmpProtocolInfo[j].wszProtocol) +
                      wcslen(pmpProtocolInfo[j].wszDLLName) + 2) * sizeof(WCHAR) +
                      sizeof(PROTO_CB);

            pNewProtocolCb = HeapAlloc(IPRouterHeap,
                                       HEAP_ZERO_MEMORY,
                                       dwSize);

            if (pNewProtocolCb is NULL)
            {
                Trace2(ERR,
                       "LoadRoutingProtocols: Error allocating %d bytes for %S",
                       dwSize,
                       pmpProtocolInfo[j].wszProtocol);

                continue ;
            }

            pvInfo = GetInfoFromTocEntry(pGlobalInfo,
                                         &(pGlobalInfo->TocEntry[i]));

            //ulStructureVersion = pGlobalInfo->TocEntry[i].InfoVersion;
            ulStructureVersion = 0x500;
            ulStructureSize  = pGlobalInfo->TocEntry[i].InfoSize;
            ulStructureCount = pGlobalInfo->TocEntry[i].Count;

            dwResult = LoadProtocol(&(pmpProtocolInfo[j]),
                                     pNewProtocolCb,
                                     pvInfo,
                                     ulStructureVersion,
                                     ulStructureSize,
                                     ulStructureCount);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "LoadRoutingProtocols: %S failed to load: %d",
                       pmpProtocolInfo[j].wszProtocol,
                       dwResult);

                HeapFree (IPRouterHeap, 0, pNewProtocolCb) ;
            }
            else
            {
                pNewProtocolCb->posOpState = RTR_STATE_RUNNING ;

                //
                // Insert this routing protocol in the list of routing
                // protocols
                //

                InsertTailList(&g_leProtoCbList,
                               &pNewProtocolCb->leList) ;

                Trace1(GLOBAL,
                       "LoadRoutingProtocols: %S successfully initialized",
                       pmpProtocolInfo[j].wszProtocol) ;

                TotalRoutingProtocols++ ;
            }
        }
    }

    MprSetupProtocolFree(pmpProtocolInfo);

    TraceLeave("LoadRoutingProtocols");

    return NO_ERROR ;
}


DWORD
StartDriverAndOpenHandle(
    PCHAR   pszServiceName,
    PWCHAR  pwszDriverName,
    PHANDLE phDevice
    )

/*++

Routine Description:

    Creates a handle to the IP NAT service on the local machine
    Then tries to start the service. Loops till the service starts.
    Can potentially loop forever.

    Then creates a handle to the device.

Arguments

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    SC_HANDLE           schSCManager, schService;
    DWORD               dwErr;
    SERVICE_STATUS      ssStatus;
    BOOL                bErr, bRet;
    ULONG               ulCount;

    TraceEnter("StartDriver");

    schSCManager = OpenSCManager(NULL,
                                 NULL,
                                 SC_MANAGER_ALL_ACCESS);


    if (schSCManager is NULL)
    {
        dwErr = GetLastError();

        Trace2(ERR,
               "StartDriver: Error %d opening svc controller for %s",
               dwErr,
               pszServiceName);

        TraceLeave("StartDriver");

        return ERROR_OPEN_FAILED;
    }

    schService = OpenService(schSCManager,
                             pszServiceName,
                             SERVICE_ALL_ACCESS);

    if(schService is NULL)
    {
        dwErr = GetLastError();

        Trace2(ERR,
               "StartDriver: Error %d opening %s",
               dwErr,
               pszServiceName);

        CloseServiceHandle(schSCManager);

        TraceLeave("StartDriver");

        return ERROR_OPEN_FAILED;
    }

    __try
    {
        bRet = FALSE;

        bErr = QueryServiceStatus(schService,
                                  &ssStatus);

        if(!bErr)
        {
            dwErr = GetLastError();

            Trace2(ERR,
                   "StartDriver: Error %d querying %s status to see if it is already running",
                   dwErr,
                   pszServiceName);

            __leave;
        }

        //
        // If the driver is running, we shut it down. This forces a
        // cleanup of all its internal data structures.
        //


        if(ssStatus.dwCurrentState isnot SERVICE_STOPPED)
        {
            if(!ControlService(schService,
                               SERVICE_CONTROL_STOP,
                               &ssStatus))
            {
                dwErr = GetLastError();

                Trace2(ERR,
                       "StartDriver: %s was running at init time. Attempts to stop it caused error %d",
                       pszServiceName,
                       dwErr);

            }
            else
            {
                Sleep(1000);

                //
                // Now loop for 10 seconds waiting for the service to stop
                //

                ulCount = 0;

                while(ulCount < 5)
                {

                    bErr = QueryServiceStatus(schService,
                                              &ssStatus);

                    if(!bErr)
                    {
                        dwErr = GetLastError();

                        break;
                    }
                    else
                    {
                        if (ssStatus.dwCurrentState is SERVICE_STOPPED)
                        {
                            break;
                        }
                        else
                        {
                            ulCount++;

                            Sleep(2000);
                        }
                    }
                }

                if(ssStatus.dwCurrentState isnot SERVICE_STOPPED)
                {
                    if(ulCount is 5)
                    {
                        dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
                    }

                    Trace2(ERR,
                           "StartDriver: Error %d stopping %s which was running at init time",
                           dwErr,
                           pszServiceName);

                    __leave;
                }
            }
        }

        //
        // Query the service status one more time to see
        // if it is now stopped (because it was never running
        // or because it was started and we managed to stop
        // it successfully
        //

        bErr = QueryServiceStatus(schService,
                                  &ssStatus);

        if(!bErr)
        {
            dwErr = GetLastError();

            Trace2(ERR,
                   "StartDriver: Error %d querying %s status to see if it is stopped",
                   dwErr,
                   pszServiceName);

            __leave;
        }

        if(ssStatus.dwCurrentState is SERVICE_STOPPED)
        {
            //
            // Ok so at this time the service is stopped, lets start the
            // service
            //

            if(!StartService(schService, 0, NULL))
            {
                dwErr = GetLastError();

                Trace2(ERR,
                       "StartDriver: Error %d starting %s",
                       dwErr,
                       pszServiceName);

                __leave;
            }

            //
            // Sleep for 1 second to avoid loop
            //

            Sleep(1000);

            ulCount = 0;

            //
            // We will wait for 30 seconds for the driver to start
            //

            while(ulCount < 6)
            {
                bErr = QueryServiceStatus(schService,
                                          &ssStatus);

                if(!bErr)
                {
                    dwErr = GetLastError();

                    break;
                }
                else
                {
                    if (ssStatus.dwCurrentState is SERVICE_RUNNING)
                    {
                        break;
                    }
                    else
                    {
                        ulCount++;

                        Sleep(5000);
                    }
                }
            }

            if(ssStatus.dwCurrentState isnot SERVICE_RUNNING)
            {
                if(ulCount is 6)
                {
                    dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
                }

                Trace2(ERR,
                       "StartDriver: Error %d starting %s",
                       dwErr,
                       pszServiceName);

                __leave;
            }
        }

        //
        // Now the service is definitely up and running
        //

        RtlInitUnicodeString(&nameString,
                             pwszDriverName);


        InitializeObjectAttributes(&objectAttributes,
                                   &nameString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        status = NtCreateFile(phDevice,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              0,
                              NULL,
                              0);

        if(!NT_SUCCESS(status))
        {
            Trace2(ERR,
                   "StartDriver: NtStatus %x creating handle to %S",
                   status,
                   pwszDriverName);

            __leave;
        }

        bRet = TRUE;

    }
    __finally
    {
        CloseServiceHandle(schSCManager);
        CloseServiceHandle(schService);

        TraceLeave("StartDriver");

    }

    if(!bRet) {
        return ERROR_OPEN_FAILED;
    } else {
        return NO_ERROR;
    }
}



DWORD
OpenIPDriver(
    VOID
    )

/*++

Routine Description:

    Opens a handle to the IP Driver

Arguments

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    DWORD               dwResult = NO_ERROR;


    TraceEnter("OpenIPDriver");

    do
    {
        RtlInitUnicodeString(&nameString, DD_IP_DEVICE_NAME);

        InitializeObjectAttributes(&objectAttributes, &nameString,
                                   OBJ_CASE_INSENSITIVE, NULL, NULL);

        status = NtCreateFile(&g_hIpDevice,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              0,
                              NULL,
                              0);

        if(!NT_SUCCESS(status))
        {
            Trace1(ERR,
                   "OpenIPDriver: Couldnt create IP driver handle. NtStatus %x",
                   status);

            dwResult = ERROR_OPEN_FAILED;

            break;
        }


        //
        // Open change notification handle to TCPIP stack
        //

        ZeroMemory(&ioStatusBlock, sizeof(IO_STATUS_BLOCK));

#if 1        
        status = NtCreateFile(
                    &g_hIpRouteChangeDevice,
                    GENERIC_EXECUTE,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0
                    );

#else
        g_hIpRouteChangeDevice = CreateFile(
                                    TEXT("\\\\.\\Ip"),
                                    GENERIC_EXECUTE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL | 
                                    FILE_ATTRIBUTE_OVERLAPPED,
                                    NULL
                                    );

        if (g_hIpRouteChangeDevice is NULL)
#endif

        if (!NT_SUCCESS(status))
        {
            Trace1(
                ERR,
                "OpenIPDriver: Couldnt create change notificatio handle."
                "NtStatus %x",
                status
                );

            dwResult = ERROR_OPEN_FAILED;

            CloseHandle( g_hIpDevice );
            g_hIpDevice = NULL;
        }

        g_IpNotifyData.Version = IPNotifySynchronization;
        g_IpNotifyData.Add = 0;
        
    } while( FALSE );
    
    TraceLeave("OpenIPDriver");

    return dwResult;
}



DWORD
OpenMulticastDriver(
    VOID
    )
{
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    DWORD               i;

    TraceEnter("OpenMulticastDriver");


    RtlInitUnicodeString(&nameString,
                         DD_IPMCAST_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&g_hMcastDevice,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0);

    if(status isnot STATUS_SUCCESS)
    {
        Trace2(MCAST,
               "OpenMulticastDriver: Device Name %S could not be opened -> error code %d\n",
               DD_IPMCAST_DEVICE_NAME,
               status);

        g_hMcastDevice = NULL;

        return ERROR_OPEN_FAILED;
    }

    TraceLeave("OpenMulticastDriver");

    return NO_ERROR;
}



DWORD
EnableNetbtBcastForwarding(
    DWORD   dwEnable
)


/*++

Routine description:

    Sets the NETBT proxy mode to enable NETBT broadcast forwarding.
    This enables RAS clients to resolve names (and consequently)
    access resources on the networks (LANs) connected to the RAS
    server without having WINS/DNS configured.

Arguements :


Return Value :

    NO_ERROR
--*/

{

    HKEY hkWanarpAdapter = NULL, hkNetbtParameters = NULL,
         hkNetbtInterface = NULL;
    DWORD dwSize = 0, dwResult, dwType = 0, dwMode = 0, dwFlags;
    PBYTE pbBuffer = NULL;
    PWCHAR pwcGuid;
    WCHAR wszNetbtInterface[256] = L"\0";
    
    
    TraceEnter("EnableNetbtBcastForwarding");

    do
    {
        //
        // Step I
        // Query appropriate WANARP regsitry keys to find GUID
        // corresponding to Internal (RAS server adapter)
        //

        dwResult = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters\\NdisWanIP",
                        0,
                        KEY_READ,
                        &hkWanarpAdapter
                        );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d opening"
                "NdisWanIP key\n",
                dwResult
                );

            break;
        }


        //
        // query size of buffer required.
        //
        
        dwResult = RegQueryValueExW(
                        hkWanarpAdapter,
                        L"IpConfig",
                        NULL,
                        &dwType,
                        (PBYTE)NULL,
                        &dwSize
                        );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d querying"
                "IPConfig value\n",
                dwResult
                );

            break;
        }


        //
        // Allocate buffer for value
        //

        pbBuffer = (PBYTE) HeapAlloc(
                                GetProcessHeap(),
                                0,
                                dwSize
                                );

        if ( pbBuffer == NULL )
        {
            dwResult = GetLastError();
            
            Trace2(
                ERR,
                "EnableNetbtBcastForwarding : error %d allocating buffer of" 
                "size %d for IPConfig value",
                dwResult, dwSize
                );

            break;
        }
        

        //
        // query registry value of IPConfig
        //

        dwResult = RegQueryValueExW(
                        hkWanarpAdapter,
                        L"IpConfig",
                        NULL,
                        &dwType,
                        (PBYTE)pbBuffer,
                        &dwSize
                        );

        if ( (dwResult isnot NO_ERROR) || (dwType != REG_MULTI_SZ) )
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d querying"
                "IPConfig value\n",
                dwResult
                );

            break;
        }


        //
        // Extract the GUID of the Internal (RAS Server) adapter
        //

        pwcGuid = wcschr( (PWCHAR)pbBuffer, '{' );

        Trace1(
            INIT, "Internal adapter GUID is %lS",
            pwcGuid
            );

            
        //
        // Step II
        //
        // Save the old setting for NETBT PROXY mode.  This will be restored
        // when the RRAS server is stopped. and set the new PROXY mode
        //

        //
        // open NETBT Key
        //
        
        dwResult = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Services\\Netbt\\Parameters",
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkNetbtParameters
                        );


        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d opening"
                "Netbt\\Parameters key\n",
                dwResult
                );

            break;
        }

        //
        // query EnableProxy mode
        //

        dwSize = sizeof( DWORD );
        dwMode = 0;
        dwResult = RegQueryValueExW(
                        hkNetbtParameters,
                        L"EnableProxy",
                        NULL,
                        &dwType,
                        (PBYTE)&dwMode,
                        &dwSize
                        );

        if (dwResult isnot NO_ERROR)
        {
            //
            // It is possible the key is not present esp. if this 
            // is the first time you are running RRAS or if the 
            // key has been manually deleted
            // In this case assume proxy is set to 0 (disabled)
            //

            g_dwOldNetbtProxyMode = 0;
        }

        else 
        {
            g_dwOldNetbtProxyMode = dwMode;

        }

        Trace1(
            INIT,
            "Netbt Proxy mode in registry is %d",
            dwMode
            );

        //
        // Set the NETBT proxy mode to enable/disable broadcast forwarding
        //

        //
        // if NETBT broadcast fwdg is disabled, make sure
        // the the EnableProxy setting matches that
        // 

        if ( dwEnable == 0 )
        {
            //
            // Netbt broadcast fwd'g is disabled
            //
            
            if ( dwMode == 2 )
            {
                //
                // But the registry setting does not reflect this
                //

                g_dwOldNetbtProxyMode = 0;

                dwMode = 0;
                
                Trace1(
                    INIT,
                    "Forcing Netbt Proxy mode to be %d",
                    g_dwOldNetbtProxyMode
                    );
            }
        }

        else
        {
            //
            // Note: Need a #define value for netbt proxy mode
            //
            
            dwMode = 2;
        }


        Trace2(
            INIT,
            "Old Netbt Proxy mode is %d, New Nebt Proxy Mode is %d",
            g_dwOldNetbtProxyMode, dwMode
            );
            
        dwResult = RegSetValueExW(
                        hkNetbtParameters,
                        L"EnableProxy",
                        0,
                        REG_DWORD,
                        (PBYTE) &dwMode,
                        dwSize
                        );

        if ( dwResult != NO_ERROR )
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d setting"
                "EnableProxy value\n",
                dwResult
                );

            break;
        }

        
        //
        // Step III:
        //
        // Check for RASFlags under NETBT_TCPIP_{RAS_SERVER_GUID} key
        //

        //
        // Open interface key under NETBT
        //
        
        wcscpy(
            wszNetbtInterface,
            L"System\\CurrentControlSet\\Services\\Netbt\\Parameters\\Interfaces\\Tcpip_"
            );

        wcscat(
            wszNetbtInterface,
            pwcGuid
            );
            
        dwResult = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        wszNetbtInterface,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkNetbtInterface
                        );

        if (dwResult isnot NO_ERROR)
        {
            Trace2(
                ERR, 
                "EnableNetbtBcastForwarding : error %d opening"
                "%ls key\n",
                dwResult, wszNetbtInterface
                );

            break;
        }

        //
        // query RASFlags value
        //
        // If present 
        //      leave as is.
        // else 
        //      create and set it to 0x00000001 to disable NETBT
        //      broadcasts on WAN.
        //

        dwFlags = 0;
        dwResult = RegQueryValueExW(
                        hkNetbtInterface,
                        L"RASFlags",
                        NULL,
                        &dwType,
                        (PBYTE)&dwFlags,
                        &dwSize
                        );

        if (dwResult isnot NO_ERROR)
        {
            //
            // It is possible the key is not present esp. if this 
            // is the first time you are running RRAS or if the 
            // key has been manually deleted
            // In this case set RASFlags to 1 (default behavior).
            //

            dwFlags = 1;

            dwResult = RegSetValueExW(
                            hkNetbtInterface,
                            L"RASFlags",
                            0,
                            REG_DWORD,
                            (PBYTE) &dwFlags,
                            sizeof( DWORD )
                            );
                            
            if ( dwResult != NO_ERROR )
            {
                Trace1(
                    ERR,
                    "error %d setting RASFlags",
                    dwResult
                    );
            }
        }
        
        else 
        {
            //
            // RASFlags value is already present. leave it as is.
            //

            Trace1(
                INIT,
                "RASFlags already present with value %d",
                dwFlags
                );
        }


        //
        // Close NETBT keys.  Doing so to avoid any contention issues
        // with the NETBT.SYS driver trying to read them in the following
        // function
        //

        RegCloseKey( hkNetbtParameters );

        hkNetbtParameters = NULL;

        RegCloseKey( hkNetbtInterface );

        hkNetbtInterface = NULL;

        dwResult = ForceNetbtRegistryRead();

    } while (FALSE);


    if ( hkWanarpAdapter )
    {
        RegCloseKey( hkWanarpAdapter );
    }
    
    if ( hkNetbtParameters )
    {
        RegCloseKey( hkNetbtParameters );
    }

    if ( hkNetbtInterface )
    {
        RegCloseKey( hkNetbtInterface );
    }

    if ( pbBuffer )
    {
        HeapFree( GetProcessHeap(), 0, pbBuffer );
    }

    TraceLeave("EnableNetbtBcastForwarding");

    return dwResult;
}


DWORD
RestoreNetbtBcastForwardingMode(
    VOID
)
/*++

Routine description:

    Return the NETBT proxy mode setting to its original setting

Arguements :


Return Value :


--*/
{
    DWORD dwResult, dwSize = 0;

    HKEY hkNetbtParameters = NULL;
    
    
    TraceEnter("RestoreNetbtBcastForwardingMode");

    do
    {
        //
        // open NETBT Key
        //
        
        dwResult = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Services\\Netbt\\Parameters",
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkNetbtParameters
                        );


        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d opening"
                "Netbt\\Parameters key\n",
                dwResult
                );

            break;
        }

        //
        // restore EnableProxy mode
        //

        dwSize = sizeof( DWORD );

        dwResult = RegSetValueExW(
                        hkNetbtParameters,
                        L"EnableProxy",
                        0,
                        REG_DWORD,
                        (PBYTE) &g_dwOldNetbtProxyMode,
                        dwSize
                        );

        if ( dwResult != NO_ERROR )
        {
            Trace1(
                ERR, 
                "EnableNetbtBcastForwarding : error %d setting"
                "EnableProxy value\n",
                dwResult
                );

            break;
        }


        dwResult = ForceNetbtRegistryRead();

    } while (FALSE);
    
    TraceLeave("RestoreNetbtBcastForwardingMode");

    return dwResult;
}


DWORD
ForceNetbtRegistryRead(
    VOID
)
/*++

Routine description:

    Issue IOCTL to NETBT to re-read its registry setting.

Arguements :


Return Value :


--*/
{
    DWORD               dwErr = NO_ERROR;
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              hNetbtDevice = NULL;

    TraceEnter("ForceNetbtRegistryRead");

    do
    {
        //
        // Step I:
        //
        // Open NETBT driver
        //
        
        RtlInitUnicodeString(
            &nameString, 
            L"\\Device\\NetbiosSmb"
            );

        InitializeObjectAttributes(
            &objectAttributes, 
            &nameString,
            OBJ_CASE_INSENSITIVE, 
            NULL, 
            NULL
            );

        status = NtCreateFile(
                    &hNetbtDevice,
                    SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS(status))
        {
            Trace1(
                ERR,
                "ForceNetbtRegistryRead: Couldnt create NETBT driver handle. NtStatus %x",
                status
                );

            dwErr = ERROR_OPEN_FAILED;

            break;
        }


        //
        // Issue IOCTL to re-read registry
        //

        status = NtDeviceIoControlFile(
                    hNetbtDevice,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    IOCTL_NETBT_REREAD_REGISTRY,
                    NULL,
                    0,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS(status))
        {
            Trace1(
                ERR,
                "ForceNetbtRegistryRead: Failed IOCTL call to NETBT, status %x",
                status
                );

            dwErr = ERROR_UNKNOWN;

            break;
        }

    } while ( FALSE );


    //
    // Close NETBT driver
    //

    CloseHandle( hNetbtDevice );

    TraceLeave("ForceNetbtRegistryRead");

    return dwErr;
}


DWORD
InitializeMibHandler(
    VOID
    )

/*++

Routine Description:

    Initalizes the heaps and Locks needed by the MIB handling code

Arguments:

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    DWORD i,dwResult, dwIpIfSize, dwMibSize;
    BOOL  fUpdate;

    TraceEnter("InitializeMibHandler");

    //
    // Assert the size of MIB to stack mappings for which direct copy is
    // being done
    //

    dwIpIfSize = IFE_FIXED_SIZE + MAX_IFDESCR_LEN;
    dwMibSize  = sizeof(MIB_IFROW) - FIELD_OFFSET(MIB_IFROW, dwIndex);

    IpRtAssert(dwIpIfSize is dwMibSize);
    IpRtAssert(sizeof(MIB_ICMP) is sizeof(ICMPSNMPInfo));
    IpRtAssert(sizeof(MIB_UDPSTATS) is sizeof(UDPStats));
    IpRtAssert(sizeof(MIB_UDPROW) is sizeof(UDPEntry));
    IpRtAssert(sizeof(MIB_TCPSTATS) is sizeof(TCPStats));
    IpRtAssert(sizeof(MIB_TCPROW) is sizeof(TCPConnTableEntry));
    IpRtAssert(sizeof(MIB_IPSTATS) is sizeof(IPSNMPInfo));
    IpRtAssert(sizeof(MIB_IPADDRROW) is sizeof(IPAddrEntry));
    IpRtAssert(sizeof(MIB_IPNETROW) is sizeof(IPNetToMediaEntry));

    g_dwStartTime = GetCurrentTime();

    __try
    {
        //
        // We dont initialize the locks since we do it in one shot at the
        // beginning of StartRouter
        //

        //
        // Now Create the heaps. Since only writers Alloc from the heap we
        // are already guaranteed serialization, so lets not ask for it again
        // Let all initial size be 1K, this doesnt really cost any thing
        // since the memory is not committed
        // We will just allocate a minimum size for the cache tables so
        // that the startup doesnt barf
        //

#define INIT_TABLE_SIZE 10

        g_hIfHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hIfHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate IF Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_hUdpHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hUdpHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate UDP Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_UdpInfo.pUdpTable = HeapAlloc(g_hUdpHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_UDPTABLE(INIT_TABLE_SIZE));

        if(g_UdpInfo.pUdpTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate UDP table");

            __leave;
        }

        g_UdpInfo.dwTotalEntries = INIT_TABLE_SIZE;

        g_hTcpHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hTcpHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate TCP Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_TcpInfo.pTcpTable = HeapAlloc(g_hTcpHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_TCPTABLE(INIT_TABLE_SIZE));

        if(g_TcpInfo.pTcpTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate TCP table");

            __leave;
        }

        g_TcpInfo.dwTotalEntries = INIT_TABLE_SIZE;

        g_hIpAddrHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hIpAddrHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Addr Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_IpInfo.pAddrTable = HeapAlloc(g_hIpAddrHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_IPADDRTABLE(INIT_TABLE_SIZE));

        if(g_IpInfo.pAddrTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Addr table.");

            __leave;
        }

        g_IpInfo.dwTotalAddrEntries = INIT_TABLE_SIZE;

        g_hIpForwardHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hIpForwardHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Forward Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_IpInfo.pForwardTable = HeapAlloc(g_hIpForwardHeap,
                                           HEAP_NO_SERIALIZE,
                                           SIZEOF_IPFORWARDTABLE(INIT_TABLE_SIZE));

        if(g_IpInfo.pForwardTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Forward table");

            __leave;
        }

        g_IpInfo.dwTotalForwardEntries = INIT_TABLE_SIZE;

        g_hIpNetHeap = HeapCreate(HEAP_NO_SERIALIZE,1000,0);

        if(g_hIpNetHeap is NULL)
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Net Heap. Error %d",
                   dwResult);

            __leave;
        }

        g_IpInfo.pNetTable = HeapAlloc(g_hIpNetHeap,
                                       HEAP_NO_SERIALIZE,
                                       SIZEOF_IPNETTABLE(INIT_TABLE_SIZE));


        if(g_IpInfo.pNetTable is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            Trace0(ERR,
                   "InitializeMibHandler: Couldnt allocate IP Net table");

            __leave;
        }

        g_IpInfo.dwTotalNetEntries = INIT_TABLE_SIZE;

        //
        // Now set up the caches
        //

        for(i = 0; i < NUM_CACHE; i++)
        {
            g_LastUpdateTable[i] = 0;

            if(UpdateCache(i,&fUpdate) isnot NO_ERROR)
            {
                Trace1(ERR,
                       "InitializeMibHandler: Couldnt update %s Cache",
                       CacheToA(i));

                //__leave;
            }
        }

        dwResult = NO_ERROR;
    }
    __finally
    {
        TraceLeave("InitializeMibHandler");

    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\iprtrmgr.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\iprtrmgr.c

Abstract:

    The interface to DIM/DDM

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#include "allinc.h"
#include "exdeclar.h"


BOOL
InitIPRtrMgrDLL(
    HANDLE  hInst,
    DWORD   dwCallReason,
    PVOID   pReserved
    )
{
    switch (dwCallReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // Init the state
            //

            InitializeCriticalSection(&RouterStateLock);
            InitializeCriticalSection(&g_csFwdState);

            RouterState.IRS_RefCount = 0;
            RouterState.IRS_State    = RTR_STATE_STOPPED;

            //
            // We are not interested in THREAD_XXX reasons
            //

            DisableThreadLibraryCalls(hInst);

            //
            // Setup our info routines
            //

            g_rgicInfoCb[0].pfnGetInterfaceInfo = NULL;
            g_rgicInfoCb[0].pfnSetInterfaceInfo = SetRouteInfo;
            g_rgicInfoCb[0].pfnBindInterface    = NULL;
            g_rgicInfoCb[0].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[0].pszInfoName         = "Route";

            g_rgicInfoCb[1].pfnGetInterfaceInfo = NULL;
            g_rgicInfoCb[1].pfnSetInterfaceInfo = SetFilterInterfaceInfo;
            g_rgicInfoCb[1].pfnBindInterface    = BindFilterInterface;
            g_rgicInfoCb[1].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[1].pszInfoName         = "Filter";

            g_rgicInfoCb[2].pfnGetInterfaceInfo = NULL;
            g_rgicInfoCb[2].pfnSetInterfaceInfo = SetDemandDialFilters;
            g_rgicInfoCb[2].pfnBindInterface    = NULL;
            g_rgicInfoCb[2].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[2].pszInfoName         = "DemandFilter";
            
            g_rgicInfoCb[3].pfnGetInterfaceInfo = NULL;
            g_rgicInfoCb[3].pfnSetInterfaceInfo = SetIpInIpInfo;
            g_rgicInfoCb[3].pfnBindInterface    = NULL;
            g_rgicInfoCb[3].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[3].pszInfoName         = "IpIpInfo";

            g_rgicInfoCb[4].pfnGetInterfaceInfo = GetBoundaryInfo;
            g_rgicInfoCb[4].pfnSetInterfaceInfo = SetBoundaryInfo;
            g_rgicInfoCb[4].pfnBindInterface    = BindBoundaryInterface;
            g_rgicInfoCb[4].pfnGetGlobalInfo    = GetScopeInfo;
            g_rgicInfoCb[4].pszInfoName         = "MulticastBoundary";
            
            g_rgicInfoCb[5].pfnGetInterfaceInfo = GetMcastLimitInfo;
            g_rgicInfoCb[5].pfnSetInterfaceInfo = SetMcastLimitInfo;
            g_rgicInfoCb[5].pfnBindInterface    = NULL;
            g_rgicInfoCb[5].pfnGetGlobalInfo    = NULL;
            g_rgicInfoCb[5].pszInfoName         = "MulticastLimit";
            
            break ;
        }
        
        case DLL_PROCESS_DETACH:
        {
            DeleteCriticalSection(&RouterStateLock);
            DeleteCriticalSection(&g_csFwdState);
    
            break;
        }

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        {
            //
            // not of interest.
            //

            break;
        }
    }

    return TRUE;
}

const static WCHAR pszIpxStackService[] = L"TcpIp";

DWORD 
VerifyOrStartIpStack(
    VOID
    ) 
/*++

Routine Description

    Verifies that the ipx stack is started and attempts to start the stack
    if not.

Locks

    None - called at init time

Arguments

    None

Return Value

    NO_ERROR
    ERROR_CAN_NOT_COMPLETE

--*/
{
    SC_HANDLE hSC = NULL, hStack = NULL;
    SERVICE_STATUS Status;
    DWORD dwErr;

    TraceEnter("VerifyOrStartIpxStack");

    __try 
    {

        //
        // Get a handle to the service controller
        //

        if ((hSC = OpenSCManager (NULL, NULL, GENERIC_READ | GENERIC_EXECUTE)) == NULL)
        {
            return GetLastError();
        }

        //
        // Get a handle to the ipx stack service
        //

        hStack = OpenServiceW (hSC,
                              pszIpxStackService,
                              SERVICE_START | SERVICE_QUERY_STATUS);
        if (!hStack)
        {
            return GetLastError();
        }

        //
        // Find out if the service is running
        //

        if (QueryServiceStatus (hStack, &Status) == 0)
        {
            return GetLastError();
        }

        //
        // See if the service is running
        //

        if (Status.dwCurrentState != SERVICE_RUNNING) 
        {
            //
            // If it's stopped, start it
            //

            if (Status.dwCurrentState == SERVICE_STOPPED) 
            {
                if (StartService (hStack, 0, NULL) == 0)
                {
                    return GetLastError();
                }

                //
                // Make sure that the service started.  StartService is not supposed
                // to return until the driver is started.
                //

                if (QueryServiceStatus (hStack, &Status) == 0)
                {
                    return GetLastError();
                }

                if (Status.dwCurrentState != SERVICE_RUNNING)
                {
                    return ERROR_CAN_NOT_COMPLETE;
                }
            }
            else
            {
                //
                // If it's not stopped, don't worry about it.
                //

                return NO_ERROR;
            }
        }

    }
    __finally 
    {
        if (hSC)
        {
            CloseServiceHandle (hSC);
        }

        if (hStack)
        {
            CloseServiceHandle (hStack);
        }
    }

    return NO_ERROR;
}

DWORD
StartRouter(
    IN OUT  DIM_ROUTER_INTERFACE *pDimRouterIf,
    IN      BOOL                 bLanOnlyMode, 
    IN      PVOID                pvGlobalInfo
    )

/*++

Routine Description

    This function is called by DIM to at startup. WE initialize tracing
    and event logging.
    Call InitRouter() to do the main stuff and then pass pointers to 
    the rest of our functions back to DIM
    
Locks

    None - called at init time

Arguments

    pDimRouterIf    structure that holds all the function pointers
    bLanOnlyMode    True if not a WAN router
    pvGlobalInfo    Pointer to our global info

Return Value

    None    

--*/

{
    DWORD   dwResult, i;
    WORD    wVersion = MAKEWORD(2,0); //Winsock version 2.0 minimum
    WSADATA wsaData;

    OSVERSIONINFOEX VersionInfo;

    //
    // Initialize Trace and logging
    //
    
    TraceHandle     = TraceRegister("IPRouterManager");
    g_hLogHandle    = RouterLogRegister("IPRouterManager");

    TraceEnter("StartRouter") ;


    if(pvGlobalInfo is NULL)
    {
        //
        // Sometimes setup screws up
        //
        
        LogErr0(NO_GLOBAL_INFO,
                ERROR_NO_DATA);
        
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We need to make sure that the stack is started before westart.
    //

    if ( VerifyOrStartIpStack() isnot NO_ERROR )
    {
        Trace0(ERR, "StartRouter: Unable to start ip stack." );

        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    g_hOwnModule  = LoadLibraryEx("IPRTRMGR.DLL",
                                  NULL,
                                  0);

    if(g_hOwnModule is NULL)
    {
        dwResult = GetLastError();

        Trace1(ERR,
               "StartRouter: Unable to load itself. %d",
               dwResult);

        return dwResult;
    }


    RouterState.IRS_State = RTR_STATE_RUNNING ;

    g_bUninitServer = TRUE;

    g_dwNextICBSeqNumberCounter = INITIAL_SEQUENCE_NUMBER;

    if(WSAStartup(wVersion,&wsaData) isnot NO_ERROR)
    {
        Trace1(ERR,
               "StartRouter: WSAStartup failed. Error %d",
               WSAGetLastError());

        TraceDeregister(TraceHandle);

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Read only variable, no locks protect this
    //

    RouterRoleLanOnly = bLanOnlyMode ;

    //
    // Do we have forwarding enabled?
    //

    EnterCriticalSection(&g_csFwdState);

    g_bEnableFwdRequest = TRUE;
    g_bSetRoutesToStack = TRUE;
    g_bEnableNetbtBcastFrowarding = FALSE;

    
    //
    // Are we running workstation?
    //

    ZeroMemory(&VersionInfo,
               sizeof(VersionInfo));

    VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);

    if(GetVersionEx((POSVERSIONINFO)&VersionInfo))
    {
        if(VersionInfo.wProductType is VER_NT_WORKSTATION)
        {
            g_bSetRoutesToStack = FALSE;
        }
    }
    else
    {
        Trace1(ERR,
               "StartRouter: GetVersionEx failed with %d\n",
               GetLastError());
    }

    Trace1(GLOBAL,
           "\n\nStartRouter: Machine will run as %s\n\n",
           g_bSetRoutesToStack?"router":"non-router");

    if(!RouterRoleLanOnly)
    {
        HKEY    hkIpcpParam;

        dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                 L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ip",
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 &hkIpcpParam);


        if(dwResult is NO_ERROR)
        {
            DWORD   dwEnable, dwSize;

            dwSize = sizeof(dwEnable);

            dwResult = RegQueryValueExW(hkIpcpParam,
                                        L"AllowNetworkAccess",
                                        NULL,
                                        NULL,
                                        (PBYTE)&dwEnable,
                                        &dwSize);


            if(dwResult is NO_ERROR)
            {
                if(dwEnable is 0)
                {
                    g_bEnableFwdRequest = FALSE;
                }
            }


            //
            // NETBT broadcast forwarding was enabled as an option
            // to allow simple RAS server configurations to perform
            // name resolution in the absence of WINS/DNS server
            // configuration.
            // This in turn was necessiated by the removal of NBF from the
            // system (NT SERVER).  When NBF was present this functionality
            // was performed by the RAS Netbios gateway.
            //
            // NETBT broadcast forwarding is enabled only if
            //  1. Router is not in LanOnly Mode
            //  2. NETBT bcast fwd'g has been explicity turned on.
            //
            
            dwResult = RegQueryValueExW(hkIpcpParam,
                                        L"EnableNetbtBcastFwd",
                                        NULL,
                                        NULL,
                                        (PBYTE)&dwEnable,
                                        &dwSize);


            if(dwResult isnot NO_ERROR)
            {
                //
                // It is possible the value is not present
                // esp. if this is the first time RRAS is being
                // run or if the key was manually deleted
                //
                // Assume a default value of 1 (enabled) and set
                // the value in the registry
                //

                dwEnable = 1;

                dwResult = RegSetValueExW(
                                hkIpcpParam,
                                L"EnableNetbtBcastFwd",
                                0,
                                REG_DWORD,
                                (PBYTE) &dwEnable,
                                sizeof( DWORD )
                                );

                if(dwResult isnot NO_ERROR)
                {
                    Trace1(
                        ERR, 
                        "error %d setting EnableNetbtBcastFwd value",
                        dwResult
                        );
                }
            }

            Trace1(
                INIT, "Netbt Enable mode is %d", dwEnable
                );
                
            if(dwEnable isnot 0)
            {
                g_bEnableNetbtBcastFrowarding = TRUE;
            }
            
            EnableNetbtBcastForwarding(dwEnable);


            RegCloseKey(hkIpcpParam);
        }
    }

    LeaveCriticalSection(&g_csFwdState);

    //
    // Keep the entry points in a global structure. 
    // Saves the overhead of copying into a structure everytime a protocol
    // has to be loaded
    //
    
    g_sfnDimFunctions.DemandDialRequest = DemandDialRequest;
    g_sfnDimFunctions.SetInterfaceReceiveType = SetInterfaceReceiveType;
    g_sfnDimFunctions.ValidateRoute     = ValidateRouteForProtocolEx;
    g_sfnDimFunctions.MIBEntryGet       = RtrMgrMIBEntryGet;
    g_sfnDimFunctions.MIBEntryGetNext   = RtrMgrMIBEntryGetNext;
    g_sfnDimFunctions.MIBEntryGetFirst  = RtrMgrMIBEntryGetFirst;
    g_sfnDimFunctions.MIBEntrySet       = RtrMgrMIBEntrySet;
    g_sfnDimFunctions.MIBEntryCreate    = RtrMgrMIBEntryCreate;
    g_sfnDimFunctions.MIBEntryDelete    = RtrMgrMIBEntryDelete;
    g_sfnDimFunctions.GetRouterId       = GetRouterId;
    g_sfnDimFunctions.HasMulticastBoundary = RmHasBoundary;
    
    Trace1(GLOBAL,
           "StartRouter: LAN MODE = %d",
           RouterRoleLanOnly) ;
    
    //
    // Do all the necessary initializations for the router
    //
    
    if((dwResult = InitRouter(pvGlobalInfo)) isnot NO_ERROR) 
    {
        Trace1(ERR,
               "StartRouter: InitRouter failed %d", dwResult) ;
        
        RouterManagerCleanup();

        RouterState.IRS_State = RTR_STATE_STOPPED;

        return dwResult ;
    }
    
    //
    // fill in information required by DIM
    //
    
    pDimRouterIf->dwProtocolId = PID_IP;
    
    //
    // Set IP Router Manager entrypoints
    //
    
    pDimRouterIf->StopRouter            = StopRouter;
    pDimRouterIf->AddInterface          = AddInterface;
    pDimRouterIf->DeleteInterface       = DeleteInterface;
    pDimRouterIf->GetInterfaceInfo      = GetInterfaceInfo;
    pDimRouterIf->SetInterfaceInfo      = SetInterfaceInfo;
    pDimRouterIf->InterfaceNotReachable = InterfaceNotReachable;
    pDimRouterIf->InterfaceReachable    = InterfaceReachable;
    pDimRouterIf->InterfaceConnected    = InterfaceConnected;
    pDimRouterIf->UpdateRoutes          = UpdateRoutes;
    pDimRouterIf->GetUpdateRoutesResult = GetUpdateRoutesResult;
    pDimRouterIf->SetGlobalInfo         = SetGlobalInfo;
    pDimRouterIf->GetGlobalInfo         = GetGlobalInfo;
    pDimRouterIf->MIBEntryCreate        = RtrMgrMIBEntryCreate;
    pDimRouterIf->MIBEntryDelete        = RtrMgrMIBEntryDelete;
    pDimRouterIf->MIBEntryGet           = RtrMgrMIBEntryGet;
    pDimRouterIf->MIBEntryGetFirst      = RtrMgrMIBEntryGetFirst;
    pDimRouterIf->MIBEntryGetNext       = RtrMgrMIBEntryGetNext;
    pDimRouterIf->MIBEntrySet           = RtrMgrMIBEntrySet;
    pDimRouterIf->SetRasAdvEnable       = SetRasAdvEnable;
    pDimRouterIf->RouterBootComplete    = RouterBootComplete;


    //
    // Get DIM entrypoints
    //
    
    ConnectInterface        = pDimRouterIf->ConnectInterface ;
    DisconnectInterface     = pDimRouterIf->DisconnectInterface ;
    SaveInterfaceInfo       = pDimRouterIf->SaveInterfaceInfo ;
    RestoreInterfaceInfo    = pDimRouterIf->RestoreInterfaceInfo ;
    RouterStopped           = pDimRouterIf->RouterStopped ;
    SaveGlobalInfo          = pDimRouterIf->SaveGlobalInfo;
    EnableInterfaceWithDIM  = pDimRouterIf->InterfaceEnabled;

    LoadStringA(g_hOwnModule,
                LOOPBACK_STRID,
                g_rgcLoopbackString,
                sizeof(g_rgcLoopbackString));

    LoadStringA(g_hOwnModule,
                INTERNAL_STRID,
                g_rgcInternalString,
                sizeof(g_rgcInternalString));

    LoadStringA(g_hOwnModule,
                WAN_STRID,
                g_rgcWanString,
                sizeof(g_rgcWanString));

    LoadStringA(g_hOwnModule,
                IPIP_STRID,
                g_rgcIpIpString,
                sizeof(g_rgcIpIpString));

    return NO_ERROR;
}

DWORD
RouterBootComplete( 
    VOID 
    )

/*++

Routine Description

    This function is called by DIM after all the interfaces in the registry
    have been loaded with the router manager.

Locks

    None - called at init time

Arguments

    None.

Return Value

    NO_ERROR

--*/
{
    DWORD   dwErr, dwSize, dwInfoSize, dwLastIndex;
    PVOID   pvBuffer;


    Trace0(ERR,
           "\n-----------------------------------------------------------\n\n");

    //
    // Call DIM to save the interface info
    //
  
    dwLastIndex = 0;
    dwInfoSize  = 0;
    pvBuffer    = NULL;
 
    ENTER_WRITER(ICB_LIST);

    // Tell all protocols that start is complete
    ENTER_READER(PROTOCOL_CB_LIST);
    {
        PLIST_ENTRY pleNode;
        PPROTO_CB   pProtocolCb;

        for(pleNode = g_leProtoCbList.Flink;
            pleNode != &g_leProtoCbList;
            pleNode = pleNode->Flink)
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;

            if (pProtocolCb->pfnStartComplete)
            {
                dwErr = (pProtocolCb->pfnStartComplete)();
            }
        }
    }
    EXIT_LOCK(PROTOCOL_CB_LIST);

    if(IsListEmpty(&ICBList))
    {
        EXIT_LOCK(ICB_LIST);

        return NO_ERROR;
    }

#if 0
    while(TRUE)
    {
        PICB        pIcb;
        PLIST_ENTRY pleNode;
        HANDLE  hDimHandle;

        //
        // Walk the list finding the first ICB that has an index larger than
        // the last index we processed
        //

        pIcb = NULL;

        for(pleNode  = ICBList.Flink;
            pleNode != &ICBList;
            pleNode  = pleNode->Flink)
        {
            PICB    pTempIcb;

            pTempIcb = CONTAINING_RECORD(pleNode,
                                         ICB,
                                         leIfLink);

            if((pTempIcb->ritType is ROUTER_IF_TYPE_CLIENT)  or
               (pTempIcb->ritType is ROUTER_IF_TYPE_DIALOUT) or
               (pTempIcb->dwAdminState isnot IF_ADMIN_STATUS_UP))
            {
                continue;
            }

            if(pTempIcb->dwIfIndex > dwLastIndex)
            {
                //
                // Found the next ICB to save
                //

                pIcb = pTempIcb;

                break;
            }
        }

        //
        // If none found, we are done
        //

        if(pIcb is NULL)
        {
            break;
        }

        dwLastIndex = pIcb->dwIfIndex;
        hDimHandle  = pIcb->hDIMHandle;

        //
        // Get the info for this ICB
        //

        dwSize = GetSizeOfInterfaceConfig(pIcb);

        //
        // If this will fit in the current buffer, use it
        //

        if(dwSize > dwInfoSize)
        {
            //
            // otherwise, allocate a new one
            //

            dwInfoSize = dwSize * 2;

            if(pvBuffer)
            {
                //
                // Free the old buffer
                //

                HeapFree(IPRouterHeap,
                         0,
                         pvBuffer);

                pvBuffer = NULL;
            }

            pvBuffer  = HeapAlloc(IPRouterHeap,
                                  HEAP_ZERO_MEMORY,
                                  dwInfoSize);

            if(pvBuffer is NULL)
            {
                dwInfoSize = 0;

                //
                // Go to the while(TRUE)
                //

                continue;
            }
        }

        dwErr = GetInterfaceConfiguration(pIcb,
                                          pvBuffer,
                                          dwInfoSize);

        
        if(dwErr is NO_ERROR)
        {
            //
            // Need to leave the lock for this
            //

            EXIT_LOCK(ICB_LIST);

            SaveInterfaceInfo(hDimHandle,
                              PID_IP,
                              pvBuffer,
                              dwSize);

            //
            // Reacquire it once we are done
            //

            ENTER_WRITER(ICB_LIST);
        }
        else
        {
            Trace1(ERR,
                   "RouterBootComplete: Error getting info for %S\n",
                   pIcb->pwszName);
        }
    }

#endif

    EXIT_LOCK(ICB_LIST);

    //
    // Now go in and start forwarding if we are not in lanonly mode
    // and IPCP is so configured
    //

    EnterCriticalSection(&g_csFwdState);

    Trace1(GLOBAL,
           "RouterBootComplete: Signalling worker to %s forwarding",
           g_bEnableFwdRequest ? "enable" : "disable");

    SetEvent(g_hSetForwardingEvent);

    LeaveCriticalSection(&g_csFwdState);

    return NO_ERROR;
}

DWORD
AddInterface(
    IN      PWSTR                   pwsInterfaceName,
    IN      PVOID                   pInterfaceInfo,
    IN      ROUTER_INTERFACE_TYPE   InterfaceType,
    IN      HANDLE                  hDIMInterface,
    IN OUT  HANDLE                  *phInterface
    )

/*++

Routine Description

    Called by DIM to add an interface. This could be one of our configured
    interfaces or a client dialling in

Locks

    Takes the ICB_LIST lock as WRITER

Arguments

    pwsInterfaceName
    pInterfaceInfo
    InterfaceType
    hDIMInterface
    phInterface

Return Value

    NO_ERROR
    ERROR_INVALID_PARAMETER

--*/

{
    PICB                    pNewInterfaceCb;
    DWORD                   dwResult, dwAdminState;
    PRTR_TOC_ENTRY          pTocEntry;
    PRTR_INFO_BLOCK_HEADER  pInfoHdr;
    PINTERFACE_STATUS_INFO  pInfo;
    BOOL                    bEnable;


    EnterRouterApi();
   
    TraceEnter("AddInterface");

    Trace1(IF,
           "AddInterface: Adding %S",
           pwsInterfaceName);
   

    pInfoHdr = (PRTR_INFO_BLOCK_HEADER)pInterfaceInfo;


#if !defined( __IPINIP )

    //
    // In preparation for IPinIP interface removal
    //

    if(InterfaceType is ROUTER_IF_TYPE_TUNNEL1)
    {
        Trace1(ERR,
               "AddInterface: Interface type is TUNNEL (%d), which is no longer"
               "supported",
               InterfaceType);
        
        LogErr0(IF_TYPE_NOT_SUPPORTED, ERROR_INVALID_PARAMETER);
        
        TraceLeave("AddInterface");
        
        ExitRouterApi();

        return ERROR_INVALID_PARAMETER;
    }

#endif
    
    if(RouterRoleLanOnly and 
       (InterfaceType isnot ROUTER_IF_TYPE_DEDICATED) and
       (InterfaceType isnot ROUTER_IF_TYPE_TUNNEL1) and
       (InterfaceType isnot ROUTER_IF_TYPE_LOOPBACK))
    {
        //
        // If we are in LAN only mode, we should not see CLIENT, INTERNAL
        // HOME_ROUTER or FULL_ROUTER
        //

        Trace1(ERR,
               "AddInterface: Interface is %d, but Router is in LanOnly Mode",
               InterfaceType);
        
        TraceLeave("AddInterface");
        
        ExitRouterApi();

        return ERROR_INVALID_PARAMETER;
    }
    
    ENTER_WRITER(ICB_LIST);

    EXIT_LOCK(ICB_LIST);

    //
    // Figure out the admin state (if any)
    // If there is no status info, we assume state to be UP
    //
    
    dwAdminState = IF_ADMIN_STATUS_UP;
    
    pTocEntry = GetPointerToTocEntry(IP_INTERFACE_STATUS_INFO,
                                     pInfoHdr);

    if(pTocEntry and (pTocEntry->InfoSize > 0) and (pTocEntry->Count > 0))
    {
        pInfo = (PINTERFACE_STATUS_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                            pTocEntry);

        //
        // Set it only if it is a valid value. Ignore others
        //
        
        if((pInfo isnot NULL) and
           ((pInfo->dwAdminStatus is IF_ADMIN_STATUS_UP) or
            (pInfo->dwAdminStatus is IF_ADMIN_STATUS_DOWN)))
        {
            dwAdminState = pInfo->dwAdminStatus;
        }
    }

    //
    // Create an ICB
    //

    pNewInterfaceCb = CreateIcb(pwsInterfaceName,
                                hDIMInterface,
                                InterfaceType,
                                dwAdminState,
                                0);

    if(pNewInterfaceCb is NULL)
    {
        ExitRouterApi();
        
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // HEAP_ZERO_MEMORY so we dont need to set any of the rtrdisc fields to 0
    //
 
    InitializeRouterDiscoveryInfo(pNewInterfaceCb,
                                  pInfoHdr);
    
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    //
    // Insert pNewInterfaceCb in interface list and hash table
    // This increments the interface count and sets the seq number
    //
    
    InsertInterfaceInLists(pNewInterfaceCb);

    Trace2(IF, "ICB number for %S is %d\n\n",
           pwsInterfaceName, pNewInterfaceCb->dwSeqNumber);

    //
    // The interface have been added to wanarp, so now add the demand dial
    // filters
    //
    
    if((pNewInterfaceCb->ritType is ROUTER_IF_TYPE_FULL_ROUTER) or
       (pNewInterfaceCb->ritType is ROUTER_IF_TYPE_HOME_ROUTER))
    {
        dwResult = SetDemandDialFilters(pNewInterfaceCb,
                                        pInfoHdr);
            
        if(dwResult isnot NO_ERROR)
        {
            CHAR   Name[MAX_INTERFACE_NAME_LEN + 1];
            PCHAR  pszName;

            pszName = Name;

            WideCharToMultiByte(CP_ACP,
                                0,
                                pwsInterfaceName,
                                -1,
                                pszName,
                                MAX_INTERFACE_NAME_LEN,
                                NULL,
                                NULL);

            LogErr1(CANT_ADD_DD_FILTERS,
                    pszName,
                    dwResult);
        }
    }

    //
    // If this is the loopback interface, do that extra something to
    // initialize it
    //

    if(pNewInterfaceCb->ritType is ROUTER_IF_TYPE_LOOPBACK)
    {
        InitializeLoopbackInterface(pNewInterfaceCb);
    }

    //
    // If this is an IP in IP tunnel, add the info if present
    //

    if(pNewInterfaceCb->ritType is ROUTER_IF_TYPE_TUNNEL1)
    {
        dwResult = SetIpInIpInfo(pNewInterfaceCb,
                                 pInfoHdr);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "AddInterface: Error %d adding %S to ipinip",
                   dwResult,
                   pwsInterfaceName);
        }
    }

    // 
    // Add multicast scope boundary info if present
    //
    
    dwResult = SetMcastLimitInfo(pNewInterfaceCb, 
                                 pInfoHdr);

    dwResult = SetBoundaryInfo(pNewInterfaceCb, 
                               pInfoHdr);
    if(dwResult isnot NO_ERROR)
    {
         Trace2(ERR,
                "AddInterface: Error %d adding boundary info for %S",
                dwResult,
                pwsInterfaceName);
    }
    
    //
    // Add Interfaces with the approp. routing protocols
    // FULL_ROUTER and HOME_ROUTER -> demand dial
    // DEDICATED, INTERNAL and CLIENT -> permanent
    //
    
    AddInterfaceToAllProtocols(pNewInterfaceCb,
                               pInfoHdr);

    //
    // Add filters and NAT info. We dont add the contexts to IP stack
    // over here, because that will happen when we bring the interface up
    //

    if((pNewInterfaceCb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
       (pNewInterfaceCb->ritType isnot ROUTER_IF_TYPE_LOOPBACK))
    {
        dwResult = SetFilterInterfaceInfo(pNewInterfaceCb,
                                          pInfoHdr);
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "AddInterface: Couldnt set filters for %S",
                   pNewInterfaceCb->pwszName);
        }
    }


    if(pNewInterfaceCb->dwAdminState is IF_ADMIN_STATUS_UP)
    {   
        //
        // If the admin wants the interface up, well good for hir
        //

        switch(pNewInterfaceCb->ritType)
        {
            case ROUTER_IF_TYPE_HOME_ROUTER:
            case ROUTER_IF_TYPE_FULL_ROUTER:
            {
                dwResult = WanInterfaceDownToInactive(pNewInterfaceCb);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddInterface: Error %d down->inactive for %S",
                           dwResult,
                           pNewInterfaceCb->pwszName);
                }

                break;
            }
            
            case ROUTER_IF_TYPE_DEDICATED:
            case ROUTER_IF_TYPE_TUNNEL1:
            {
                if((pNewInterfaceCb->ritType is ROUTER_IF_TYPE_TUNNEL1) and
                   (pNewInterfaceCb->pIpIpInfo->dwLocalAddress is 0))
                {
                    //
                    // Means we added the interface, but dont have info to
                    // add it to IP in IP
                    //

                    break;
                }

                dwResult = LanEtcInterfaceDownToUp(pNewInterfaceCb,
                                                   TRUE);
                
                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddInterface: Error %d down->up for %S",
                           dwResult,
                           pNewInterfaceCb->pwszName);
                }

                break;
            }
        }
    }
    else
    {
        //
        // The problem with LAN and IP in IP interfaces is that the stack 
        // brings them up even before we start. So if the user wants the 
        // interface DOWN to begin with, we need to tell the stack to bring 
        // the i/f down
        //

        switch(pNewInterfaceCb->ritType)
        {
            case ROUTER_IF_TYPE_DEDICATED:
            case ROUTER_IF_TYPE_TUNNEL1:
            {
                dwResult = LanEtcInterfaceInitToDown(pNewInterfaceCb);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "AddInterface: Interface %S could not be set to DOWN in the stack. Results are undefined. Error %d",
                           pNewInterfaceCb->pwszName,
                           dwResult);
                }

                break;
            }
        }
    }


    //
    // Add Static Routes
    //

    if(pNewInterfaceCb->dwAdminState is IF_ADMIN_STATUS_UP)
    {
        //
        // Only add routes if the i/f is up
        //

        //
        // Note that since init static routes is not being called for some 
        // interfaces the stack routes will not be picked up. But that 
        // may be OK since bringing the i/f down will delete the routes anyway
        //
       
        //
        // Can only be called when the pIcb has the correct
        // dwOperational State
        //
 
        InitializeStaticRoutes(pNewInterfaceCb,
                               pInfoHdr);
    }
    
    
    //
    // The handle we return to DIM is a pointer to our ICB
    //

    *phInterface = ULongToHandle(pNewInterfaceCb->dwSeqNumber);

    //
    // Check if we want to enable with DIM. Do this check while we still have
    // the LOCK
    //

    bEnable = (pNewInterfaceCb->dwAdminState is IF_ADMIN_STATUS_UP);
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    //
    // We can not call upwards from a component while holding
    // a lock, so we first exit the lock and then call
    // enabled
    //

    if(bEnable)
    {
        EnableInterfaceWithAllProtocols(pNewInterfaceCb);

        EnableInterfaceWithDIM(hDIMInterface,
                               PID_IP,
                               TRUE);
    }

    
    Trace4(IF,
           "AddInterface: Added %S: Type- %d, Index- %d, ICB 0x%x",
           pwsInterfaceName, 
           InterfaceType, 
           pNewInterfaceCb->dwIfIndex,
           pNewInterfaceCb);

    
    TraceLeave("AddInterface");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
DeleteInterface(
    IN HANDLE hInterface
    )
    
/*++

Routine Description

    Called by DIM to delete an interface (or when a CLIENT disconnects)
    The main work is done by DeleteSingleInterface()
    
Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    PICB        pIcb;

    EnterRouterApi();

    TraceEnter("DeleteInterface");
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        Trace1(IF,
               "DeleteInterface: Deleting %S,",
               pIcb->pwszName);

        RemoveInterfaceFromLists(pIcb);

        DeleteSingleInterface(pIcb);

        if(pIcb is g_pInternalInterfaceCb)
        {
            g_pInternalInterfaceCb = NULL;
        }

        //
        // Free the memory
        //
        
        HeapFree(IPRouterHeap,
                 0,
                 pIcb);
    }
    else
    {
        Trace1(
            ANY, 
            "DeleteInterface: No interface for ICB number %d",
            HandleToULong(hInterface)
            );
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    TraceLeave("DeleteInterface");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
StopRouter(
    VOID
    )

/*++

Routine Description

    Called by DIM to shut us down. We set our state to STOPPING (which stops
    other APIs from being serviced) and set the event to let the worker
    thread clean up

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    TraceEnter("Stop Router") ;

    EnterCriticalSection(&RouterStateLock);

    RouterState.IRS_State   = RTR_STATE_STOPPING;

    LeaveCriticalSection(&RouterStateLock);

    //
    // Try and delete as many interfaces as you can. The ones that are
    // connected will be handled in worker thread
    //
    
    DeleteAllInterfaces();

    SetEvent(g_hStopRouterEvent) ; 

    TraceLeave("Stop Router");

    return PENDING;
}


DWORD
GetInterfaceInfo(
    IN     HANDLE   hInterface,
    OUT    PVOID    pvInterfaceInfo,
    IN OUT PDWORD   pdwInterfaceInfoSize
    )

/*++

Routine Description

    Called by DIM to get interface info. 

Locks

    Acquires the ICB_LIST lock as READER

Arguments

    hInterface           Our handle to the i/f (pIcb)
    pvInterfaceInfo      Buffer to store info
    pdwInterfaceInfoSize Size of Buffer. If the info is more than this, we
                         return the needed size
Return Value

    NO_ERROR
    ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD dwErr;
    DWORD dwInfoSize = 0;
    PICB  pIcb;
    
    EnterRouterApi();

    TraceEnter("GetInterfaceInfo");

    dwErr = NO_ERROR;


    // *** Exclusion Begin ***
    ENTER_READER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));
    
    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        dwInfoSize = GetSizeOfInterfaceConfig(pIcb);
        
        
        if(dwInfoSize > *pdwInterfaceInfoSize)
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            dwErr = GetInterfaceConfiguration(pIcb,
                                              pvInterfaceInfo,
                                              *pdwInterfaceInfoSize);
            
            if(dwErr isnot NO_ERROR)
            {
                Trace1(ERR,
                       "GetInterfaceInfo: Error %d getting interface configuration",
                       dwErr);
                
                dwErr = ERROR_CAN_NOT_COMPLETE;
            }
        }
    }

    else
    {
        Trace1(
            ANY,
            "GetInterfaceInfo : No interface with ICB number %d",
            HandleToULong(hInterface)
            );

        dwErr = ERROR_INVALID_INDEX;
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);
    
    *pdwInterfaceInfoSize = dwInfoSize;
    
    TraceLeave("GetInterfaceInfo");
    
    ExitRouterApi();

    return dwErr;
}


DWORD
SetInterfaceInfo(
    IN HANDLE hInterface, 
    IN LPVOID pInterfaceInfo
    )

/*++

Routine Description

    Called by DIM when a users sets interface info. All our sets follow 
    OVERWRITE semantics, i.e. the new info overwrites the old info instead of
    being appended to the old info.

Locks

    ICB_LIST lock as WRITER

Arguments

    None

Return Value

    None    

--*/

{
    DWORD                   i, dwResult;
    PVOID                   *pInfo ;
    PPROTO_CB               pIfProt;
    PIF_PROTO               pProto;
    PICB                    pIcb;
    PLIST_ENTRY             pleProto,pleNode;
    PADAPTER_INFO           pBinding;
    IP_ADAPTER_BINDING_INFO *pBindInfo ;
    PRTR_INFO_BLOCK_HEADER  pInfoHdr;
    PRTR_TOC_ENTRY          pToc;
    PINTERFACE_STATUS_INFO  pStatusInfo;
    BOOL                    bStatusChanged;
    
    EnterRouterApi();

    TraceEnter("SetInterfaceInfo");
    
    //
    // The set info is the standard Header+TOC
    //
    
    pInfoHdr = (PRTR_INFO_BLOCK_HEADER)pInterfaceInfo;
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    //
    // If the current AdminState is DOWN and we are being asked to
    // bring it up, we do so BEFORE setting any other info
    //

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));
    
    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        Trace1(IF,
               "SetInterfaceInfo: Setting configuration for %S",
               pIcb->pwszName);

        bStatusChanged = FALSE;
        
        pToc = GetPointerToTocEntry(IP_INTERFACE_STATUS_INFO, pInfoHdr);

        if((pToc isnot NULL) and (pToc->InfoSize isnot 0))
        {
            pStatusInfo = (PINTERFACE_STATUS_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                                      pToc);

            if((pStatusInfo isnot NULL) and 
               (pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN) and
               (pStatusInfo->dwAdminStatus is IF_ADMIN_STATUS_UP))
            {
                dwResult = SetInterfaceAdminStatus(pIcb,
                                                   pStatusInfo->dwAdminStatus);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "SetInterfaceInfo: Error %d setting Admin Status on %S",
                           dwResult,
                           pIcb->pwszName);

                    EXIT_LOCK(ICB_LIST);

                    TraceLeave("SetInterfaceInfo");
                    
                    ExitRouterApi();

                    return dwResult;
                }

                bStatusChanged = TRUE;
            }
        }

        if(pIcb->dwAdminState is IF_ADMIN_STATUS_DOWN)
        {
            //
            // If we are still down, we dont allow any SETS
            //

            Trace1(ERR,
                   "SetInterfaceInfo: Can not set info for %S since the the admin state is DOWN",
                   pIcb->pwszName);
            
            EXIT_LOCK(ICB_LIST);

            TraceLeave("SetInterfaceInfo");
            
            ExitRouterApi();

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Set router discovery info
        //
        
        SetRouterDiscoveryInfo(pIcb,
                               pInfoHdr);

        //
        // Make a copy of the binding info
        // This may be needed to be passed to the protocols
        //
        
        pBindInfo   = NULL;

        CheckBindingConsistency(pIcb);
        
        if(pIcb->bBound)
        {
            pBindInfo = HeapAlloc(IPRouterHeap,
                                  0,
                                  SIZEOF_IP_BINDING(pIcb->dwNumAddresses));
            
            if(pBindInfo is NULL)
            {
                Trace1(ERR,
                       "SetInterfaceInfo: Error allocating %d bytes for binding",
                       SIZEOF_IP_BINDING(pIcb->dwNumAddresses));

                EXIT_LOCK(ICB_LIST);

                TraceLeave("SetInterfaceInfo");
                
                ExitRouterApi();

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            pBindInfo->AddressCount  = pIcb->dwNumAddresses;
            pBindInfo->RemoteAddress = pIcb->dwRemoteAddress;

            pBindInfo->Mtu           = pIcb->ulMtu;
            pBindInfo->Speed         = pIcb->ullSpeed;
            
            for (i = 0; i < pIcb->dwNumAddresses; i++) 
            {
                pBindInfo->Address[i].Address = pIcb->pibBindings[i].dwAddress;
                pBindInfo->Address[i].Mask    = pIcb->pibBindings[i].dwMask;
            }
        }

        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);
        
        //
        // Walk all the protocols and see if we have info for that protocol
        //      If we do, we see if the interface is already added to the protocol.
        //          If it is, we just call the SetInfo callback.
        //          Otherwise we add the interface and then bind it.
        //      If we dont, we see if the interface had been added to the protocol
        //          If it had, we delete the interface from the protocol
        //
     
        for(pleProto =  g_leProtoCbList.Flink;
            pleProto isnot &g_leProtoCbList;
            pleProto = pleProto->Flink)
        {
            PPROTO_CB   pProtoCb;
            ULONG       ulStructureVersion, ulStructureSize, ulStructureCount;
            
            pProtoCb = CONTAINING_RECORD(pleProto,
                                         PROTO_CB,
                                         leList);
           
            Trace1(IF,
                   "SetInterfaceInfo: Checking for info for %S",
                   pProtoCb->pwszDisplayName);

            pToc = GetPointerToTocEntry(pProtoCb->dwProtocolId, 
                                        pInfoHdr);

            if(pToc is NULL)
            {
                //
                // Block absent means do not change anything
                //

                Trace1(IF,
                       "SetInterfaceInfo: No TOC for %S. No change",
                       pProtoCb->pwszDisplayName);

                continue;
            }
            else
            {
                pInfo = GetInfoFromTocEntry(pInfoHdr,
                                            pToc);
            }
           
            ulStructureVersion  = 0x500;
            ulStructureSize     = pToc->InfoSize;
            ulStructureCount    = pToc->Count; 

            if((pToc->InfoSize isnot 0) and (pInfo isnot NULL))
            {
                BOOL bFound;

                //
                // So we have protocol info
                //
                
                Trace1(IF,
                       "SetInterfaceInfo: TOC Found for %S",
                       pProtoCb->pwszDisplayName);

                //
                // See if this protocol exists on the active protocol list
                // for the interface
                //

                bFound = FALSE;
                
                for(pleNode = pIcb->leProtocolList.Flink;
                    pleNode isnot &(pIcb->leProtocolList);
                    pleNode = pleNode->Flink)
                {
                    pProto = CONTAINING_RECORD(pleNode,
                                               IF_PROTO,
                                               leIfProtoLink);
                    
                    if(pProto->pActiveProto->dwProtocolId is
                       pProtoCb->dwProtocolId)
                    {
                        //
                        // The interface has already been added to the interface
                        // Just set info
                        //
                        
                          
                        bFound = TRUE;
                       
                        Trace2(IF,
                               "SetInterfaceInfo: %S already on %S. Setting info",
                               pProtoCb->pwszDisplayName,
                               pIcb->pwszName);

                        dwResult = (pProto->pActiveProto->pfnSetInterfaceInfo)(
                                        pIcb->dwIfIndex,
                                        pInfo,
                                        ulStructureVersion,
                                        ulStructureSize,
                                        ulStructureCount);

                        //
                        // Set the promiscuous mode to false since this time we
                        // actually have info
                        //

                        pProto->bPromiscuous = FALSE;

                        break;
                    }
                }
                
                if(!bFound)
                {
                    //
                    // The interface is being added to the protocol for the
                    // first time
                    //
                   
                    Trace2(IF,
                           "SetInterfaceInfo: %S not running %S. Adding interface",
                           pProtoCb->pwszDisplayName,
                           pIcb->pwszName);

                    dwResult = AddInterfaceToProtocol(pIcb,
                                                      pProtoCb,
                                                      pInfo,
                                                      ulStructureVersion,
                                                      ulStructureSize,
                                                      ulStructureCount);
     
                    if(dwResult isnot NO_ERROR)
                    {
                        Trace3(ERR,
                               "SetInterfaceInfo: Error %d adding %S to %S",
                               dwResult,
                               pIcb->pwszName,
                               pProtoCb->pwszDisplayName);
                    }

                    dwResult = (pProtoCb->pfnInterfaceStatus)(
                                    pIcb->dwIfIndex,
                                    (pIcb->dwOperationalState >= CONNECTED),
                                    RIS_INTERFACE_ENABLED,
                                    NULL
                                    );

                    if(dwResult isnot NO_ERROR)
                    {
                        Trace3(ERR,
                               "SetInterfaceInfo: Error %d enabling %S with %S",
                               dwResult,
                               pIcb->pwszName,
                               pProtoCb->pwszDisplayName);
                    }
                    
                    //
                    // If the binding information is available, pass it to the
                    // protocol
                    //
               
                    if(pBindInfo)
                    {
                        Trace2(IF,
                               "SetInterfaceInfo: Binding %S in %S",
                               pIcb->pwszName,
                               pProtoCb->pwszDllName);

                        dwResult = BindInterfaceInProtocol(pIcb,
                                                           pProtoCb,
                                                           pBindInfo);
                        
                        if(dwResult isnot NO_ERROR)
                        {
                            Trace3(ERR, 
                                   "SetInterfaceInfo: Error %d binding %S to %S",
                                   dwResult,
                                   pIcb->pwszName,
                                   pProtoCb->pwszDllName);
                        }
                    }


                    //
                    // If this is the internal interface, also call connect client
                    // for connected clients
                    //

                    if((pIcb is g_pInternalInterfaceCb) and
                       (pProtoCb->pfnConnectClient))
                    {
                        PLIST_ENTRY         pleTempNode;
                        IP_LOCAL_BINDING    clientAddr;
                        PICB                pTempIf;

                        for(pleTempNode = &ICBList;
                            pleTempNode->Flink != &ICBList;
                            pleTempNode = pleTempNode->Flink)
                        {
                            pTempIf = CONTAINING_RECORD(pleTempNode->Flink,
                                                        ICB,
                                                        leIfLink);


                            if(pTempIf->ritType isnot ROUTER_IF_TYPE_CLIENT)
                            {
                                continue;
                            }

                            clientAddr.Address = pTempIf->pibBindings[0].dwAddress;
                            clientAddr.Mask    = pTempIf->pibBindings[0].dwMask;

                            pProtoCb->pfnConnectClient(g_pInternalInterfaceCb->dwIfIndex,
                                                       &clientAddr);
                        }
                    }
                }
            }
            else
            {
                //
                // A zero size TOC was found for this particular protocol. If
                // this protocol exists in the current ActiveProtocol list,
                // remove the interface from the protocol
                //
               
                Trace2(IF,
                       "SetInterfaceInfo: A zero size TOC was found for %S on %S",
                       pProtoCb->pwszDllName,
                       pIcb->pwszName);
     
                pleNode = pIcb->leProtocolList.Flink;
                
                while(pleNode isnot &(pIcb->leProtocolList))
                {
                    pProto = CONTAINING_RECORD(pleNode,
                                               IF_PROTO,
                                               leIfProtoLink);
                    
                    pleNode = pleNode->Flink;
                    
                    if(pProto->pActiveProto->dwProtocolId is pProtoCb->dwProtocolId)
                    {
                        IpRtAssert(pProto->pActiveProto is pProtoCb);

                        //
                        // Call the routing protocol's deleteinterface entrypoint
                        //
                      
                        Trace2(IF,
                               "SetInterfaceInfo: Deleting %S from %S",
                               pProtoCb->pwszDllName, 
                               pIcb->pwszName);

                        dwResult = (pProtoCb->pfnDeleteInterface)(pIcb->dwIfIndex);
                        
                        if(dwResult isnot NO_ERROR)
                        {
                            Trace3(ERR,
                                   "SetInterfaceInfo: Err %d deleting %S from %S",
                                   dwResult,
                                   pIcb->pwszName,
                                   pProtoCb->pwszDllName);
                        }
                        else
                        {
                            //
                            // Delete this protocol from the list of protocols
                            // in the Interface
                            //
                            
                            RemoveEntryList(&(pProto->leIfProtoLink));
                            
                            HeapFree(IPRouterHeap,
                                     0,
                                     pProto);
                        }
                    }
                }
            }
        }
        
        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

        for(i = 0; i < NUM_INFO_CBS; i++)
        {
            dwResult = g_rgicInfoCb[i].pfnSetInterfaceInfo(pIcb,
                                                           pInfoHdr);

            if(dwResult isnot NO_ERROR)
            {
                Trace3(ERR,
                       "SetInterfaceInfo: Error %d setting %s info for %S",
                       dwResult,
                       g_rgicInfoCb[i].pszInfoName,
                       pIcb->pwszName);
            }
        }
        
        if(pBindInfo)
        {
            HeapFree(IPRouterHeap,
                     0,
                     pBindInfo);
        }


        //
        // If we have already changed the status dont do it again
        //

        if(!bStatusChanged)
        {
            dwResult = SetInterfaceStatusInfo(pIcb,
                                              pInfoHdr);
        
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetInterfaceInfo: Error %d setting status info for %S",
                       dwResult,
                       pIcb->pwszName);
            }
        }
    }

    else
    {
        Trace1(
            ANY,
            "SetInterfaceInfo : No interface with ICB number %d",
            HandleToULong(hInterface)
            );
    }
    
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);
    
    TraceLeave("SetInterfaceInfo");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
InterfaceNotReachable(
    IN HANDLE                hInterface, 
    IN UNREACHABILITY_REASON Reason
    )

/*++

Routine Description

    Called by DIM to tell us that an interface should be considered
    UNREACHABLE till further notice

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    PICB            pIcb;
    PADAPTER_INFO   pBinding;

    EnterRouterApi();

    TraceEnter("InterfaceNotReachable");

    ENTER_WRITER(ICB_LIST);
  
    //
    // If it is a CLIENT interface all this means is that the connection
    // failed
    //

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
        {
            pIcb->dwOperationalState = UNREACHABLE;

            EXIT_LOCK(ICB_LIST);

            ExitRouterApi();

            return NO_ERROR;
        }
     
        Trace2(IF, 
               "InterfaceNotReachable: %S is not reachable for reason %d",
               pIcb->pwszName,
               Reason) ;

        if(Reason == INTERFACE_NO_MEDIA_SENSE)
        {
            HandleMediaSenseEvent(pIcb,
                                  FALSE);

            
            EXIT_LOCK(ICB_LIST);

            ExitRouterApi();

            return NO_ERROR;
        }

#if STATIC_RT_DBG

        ENTER_WRITER(BINDING_LIST);

        pBinding = GetInterfaceBinding(pIcb->dwIfIndex);

        pBinding->bUnreach = TRUE;

        EXIT_LOCK(BINDING_LIST);

#endif


        //
        // If we were trying to connect on this - then inform WANARP to 
        // drain its queued up packets
        //
        
        if(pIcb->dwOperationalState is CONNECTING)
        {
            NTSTATUS           Status;

            Status = NotifyWanarpOfFailure(pIcb);

            if((Status isnot STATUS_PENDING) and
               (Status isnot STATUS_SUCCESS))
            {
                Trace1(ERR,
                       "InterfaceNotReachable: IOCTL_WANARP_CONNECT_FAILED failed. Status %x",
                       Status);
            }

            //
            // If it was connecting, then the stack has set the interface context
            // to something other than 0xffffffff. Hence he wont dial out on that 
            // route. We need to change the context in the stack back to invalid 
            // so that new packets cause the demand dial 
            //
                
            ChangeAdapterIndexForDodRoutes(pIcb->dwIfIndex);

            //
            // We are still in INACTIVE state so dont have to call any if the
            // WanInterface*To*() functions. But since we are in CONNECTING
            // WANARP must have called us with CONNECTION notification
            // so we undo what we did there
            //

            DeAllocateBindings(pIcb);

            ClearNotificationFlags(pIcb);
            
        }
        else
        {
            //
            // A connected interface must first be disconnected
            //
            
            if(pIcb->dwOperationalState is CONNECTED)
            {
                Trace1(IF,
                       "InterfaceNotReachable: %S is already connected",
                       pIcb->pwszName);

                EXIT_LOCK(ICB_LIST);

                ExitRouterApi();

                return ERROR_INVALID_HANDLE_STATE;
            }
        }

        //
        // This sets the state to UNREACHABLE
        //

        WanInterfaceInactiveToDown(pIcb,
                                   FALSE);
    }
    
    else
    {
        Trace1(
            ANY,
            "InterfaceNotReachable : No interface with ICB number %d",
            HandleToULong(hInterface)
            );
    }
    
    EXIT_LOCK(ICB_LIST);
    
    TraceLeave("InterfaceNotReachable");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
InterfaceReachable(
    IN HANDLE hInterface
    )

/*++

Routine Description

    Notification by DIM that the interface is REACHABLE again

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD   dwErr;

    PICB    pIcb;
    
    EnterRouterApi();

    TraceEnter("InterfaceReachable");

    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb isnot NULL)
    {
        Trace1(IF, "InterfaceReachable: %S is now reachable",
               pIcb->pwszName);

        if((pIcb->dwOperationalState <= UNREACHABLE) and
           (pIcb->dwAdminState is IF_ADMIN_STATUS_UP))
        {
            //
            // only if it was unreachable before.
            //
           
            if(pIcb->ritType is ROUTER_IF_TYPE_DEDICATED)
            {
                dwErr = LanEtcInterfaceDownToUp(pIcb,
                                                FALSE);
            }
            else
            {
                dwErr = WanInterfaceDownToInactive(pIcb);
            }

            if(dwErr isnot NO_ERROR) 
            {
                Trace2(ERR,
                       "InterfaceReachable: Err %d bringing up %S",
                       dwErr,
                       pIcb->pwszName);
            }
        }
    }
    else
    {
        Trace1(
            ANY,
            "InterfaceReachable : No interface with ICB number %d",
            HandleToULong(hInterface)
            );
    }
    

    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);
  
    TraceLeave("InterfaceNotReachable");

    ExitRouterApi();

    return NO_ERROR;
}

DWORD
InterfaceConnected(
    IN   HANDLE  hInterface,
    IN   PVOID   pFilter,
    IN   PVOID   pPppProjectionResult
    )

/*++

Routine Description

    Notification by DIM that an interface has connected.

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD   dwResult, i;
    PICB    pIcb;

    INTERFACE_ROUTE_INFO rifRoute;

    EnterRouterApi(); 

    TraceEnter("InterfaceConnected");
    
    ENTER_WRITER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb != NULL)
    {
        Trace2(IF,
               "InterfaceConnected: InterfaceConnected called for %S. State is %d",
               pIcb->pwszName,
               pIcb->dwOperationalState);

        if((pIcb->ritType is ROUTER_IF_TYPE_CLIENT) and
           (g_pInternalInterfaceCb is NULL))
        {
            EXIT_LOCK(ICB_LIST);

            ExitRouterApi();

            return ERROR_INVALID_HANDLE_STATE;
        }

        if((pIcb->ritType is ROUTER_IF_TYPE_CLIENT) and
           g_bUninitServer)
        {
            TryUpdateInternalInterface();
        }

        if(pIcb->dwOperationalState is UNREACHABLE)
        {
            //
            // going from unreachable to connecting. This can happen
            //

            WanInterfaceDownToInactive(pIcb);
        }
            
        if(pIcb->dwOperationalState isnot CONNECTING)
        {
            //
            // Wanarp has not called us as yet, so set the state to connecting
            //
            
            pIcb->dwOperationalState = CONNECTING;
        }

        SetDDMNotification(pIcb);

        if(HaveAllNotificationsBeenReceived(pIcb))
        {
            //
            // Wanarp has also called us
            //
          
            pIcb->dwOperationalState = CONNECTED ;
            
            if(pIcb->ritType isnot ROUTER_IF_TYPE_CLIENT)
            {
                WRITER_TO_READER(ICB_LIST);

                WanInterfaceInactiveToUp(pIcb);
            }
            else
            {
                IP_LOCAL_BINDING    clientAddr;
                PLIST_ENTRY         pleNode;
                PPP_IPCP_RESULT     *pProjInfo;

                pProjInfo = &(((PPP_PROJECTION_RESULT *)pPppProjectionResult)->ip);

                IpRtAssert(pIcb->pibBindings);

                pIcb->dwNumAddresses = 1;

                pIcb->bBound = TRUE;

                pIcb->pibBindings[0].dwAddress = pProjInfo->dwRemoteAddress;

                if(g_pInternalInterfaceCb->bBound)
                {
                    pIcb->pibBindings[0].dwMask = 
                        g_pInternalInterfaceCb->pibBindings[0].dwMask;
                }
                else
                {
                    pIcb->pibBindings[0].dwMask = 
                        GetClassMask(pProjInfo->dwRemoteAddress);
                }
     
                clientAddr.Address = pIcb->pibBindings[0].dwAddress;
                clientAddr.Mask    = pIcb->pibBindings[0].dwMask;


#if 0               
                //
                // Add a non-stack host route to the client
                //

                rifRoute.dwRtInfoMask      = HOST_ROUTE_MASK;
                rifRoute.dwRtInfoNextHop   = clientAddr.Address;
                rifRoute.dwRtInfoDest      = clientAddr.Address;
                rifRoute.dwRtInfoIfIndex   = g_pInternalInterfaceCb->dwIfIndex;
                rifRoute.dwRtInfoMetric1   = 1;
                rifRoute.dwRtInfoMetric2   = 0;
                rifRoute.dwRtInfoMetric3   = 0;
                rifRoute.dwRtInfoPreference= 
                    ComputeRouteMetric(MIB_IPPROTO_LOCAL);
                rifRoute.dwRtInfoViewSet   = RTM_VIEW_MASK_UCAST |
                                              RTM_VIEW_MASK_MCAST; // XXX config
                rifRoute.dwRtInfoType      = MIB_IPROUTE_TYPE_DIRECT;
                rifRoute.dwRtInfoProto     = MIB_IPPROTO_NETMGMT;
                rifRoute.dwRtInfoAge       = INFINITE;
                rifRoute.dwRtInfoNextHopAS = 0;
                rifRoute.dwRtInfoPolicy    = 0;

                dwResult = AddSingleRoute(g_pInternalInterfaceCb->dwIfIndex,
                                          &rifRoute,
                                          clientAddr.Mask,
                                          0,        // RTM_ROUTE_INFO::Flags
                                          TRUE,
                                          FALSE,
                                          FALSE,
                                          NULL);

#endif
                ENTER_READER(PROTOCOL_CB_LIST);

                //
                // Call ConnectClient for all the protocols configured
                // over the ServerInterface
                //

                for(pleNode = g_pInternalInterfaceCb->leProtocolList.Flink; 
                    pleNode isnot &(g_pInternalInterfaceCb->leProtocolList);
                    pleNode = pleNode->Flink)
                {
                    PIF_PROTO   pIfProto;

                    pIfProto = CONTAINING_RECORD(pleNode,
                                                 IF_PROTO,
                                                 leIfProtoLink);

                    if(pIfProto->pActiveProto->pfnConnectClient)
                    {
                        pIfProto->pActiveProto->pfnConnectClient(
                            g_pInternalInterfaceCb->dwIfIndex,
                            &clientAddr
                            );
                    }
                }

                EXIT_LOCK(PROTOCOL_CB_LIST);

                for (i=0; i<NUM_INFO_CBS; i++)
                {
                    if (!g_rgicInfoCb[i].pfnBindInterface)
                    {
                        continue;
                    }

                    dwResult = g_rgicInfoCb[i].pfnBindInterface(pIcb);

                    if(dwResult isnot NO_ERROR)
                    {
                        Trace3(IF,
                               "InterfaceConnected: Error %d binding %S for %s info",
                               dwResult,
                               pIcb->pwszName,
                               g_rgicInfoCb[i].pszInfoName);
                    }
                }
                    
                AddAllClientRoutes(pIcb,
                                   g_pInternalInterfaceCb->dwIfIndex);


            }
        }
    }

    else
    {
        Trace1(
            ANY,
            "InterfaceConnected : No interface with ICB number %d",
            HandleToULong(hInterface)
            );
    }
    
    
    EXIT_LOCK(ICB_LIST);

    TraceLeave("InterfaceConnected");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
SetGlobalInfo(
    IN LPVOID pGlobalInfo
    )
{
    DWORD                   dwSize, dwResult, i, j;
    PPROTO_CB               pProtocolCb;
    PLIST_ENTRY             pleNode ;
    BOOL                    bFoundProto, bFoundInfo;
    PRTR_INFO_BLOCK_HEADER  pInfoHdr;
    MPR_PROTOCOL_0          *pmpProtocolInfo;
    DWORD                   dwNumProtoEntries;
    PVOID                   pvInfo;
    PRTR_TOC_ENTRY          pToc;
    PGLOBAL_INFO            pRtrGlobalInfo;
    
    EnterRouterApi();
    
    TraceEnter("SetGlobalInfo");

    if(pGlobalInfo is NULL)
    {
        TraceLeave("SetGlobalInfo");
    
        ExitRouterApi();
        
        return NO_ERROR;
    }

    pInfoHdr = (PRTR_INFO_BLOCK_HEADER)pGlobalInfo;
    
    //
    // Set Routing Protocol Priority info. Priority information is in its
    // own DLL so no locks need to be taken
    //
    
    SetPriorityInfo(pInfoHdr);

    //
    // Set Multicast Scope info (no locks needed)
    //

    SetScopeInfo(pInfoHdr);

    //
    // Enforce the discipline of taking ICBListLock before Routing lock
    //
    
    
    ENTER_WRITER(ICB_LIST);
    
    ENTER_WRITER(PROTOCOL_CB_LIST);
    
    pToc = GetPointerToTocEntry(IP_GLOBAL_INFO,
                                pInfoHdr);

    if(pToc is NULL)
    {
        Trace0(GLOBAL,
               "SetGlobalInfo: No TOC found for Global Info");
    }
    else
    {
        if(pToc->InfoSize is 0)
        {
            g_dwLoggingLevel = IPRTR_LOGGING_NONE;

        }
        else
        {
            pRtrGlobalInfo   = (PGLOBAL_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                                 pToc);
            g_dwLoggingLevel = (pRtrGlobalInfo isnot NULL) ? 
                                    pRtrGlobalInfo->dwLoggingLevel : 
                                    IPRTR_LOGGING_NONE;
        }
    }

    dwResult = MprSetupProtocolEnum(PID_IP,
                                    (PBYTE *)(&pmpProtocolInfo),
                                    &dwNumProtoEntries);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "SetGlobalInfo: Error %d loading protocol info from registry",
               dwResult);

                    
        EXIT_LOCK(PROTOCOL_CB_LIST);

        EXIT_LOCK(ICB_LIST);
    
        TraceLeave("SetGlobalInfo");

        ExitRouterApi();

        return ERROR_REGISTRY_CORRUPT;
    }
    

    //
    // Now go looking for protocols TOCs
    //
    
    for(i = 0; i < pInfoHdr->TocEntriesCount; i++)
    {
        ULONG       ulStructureVersion, ulStructureSize, ulStructureCount;
        DWORD       dwType;

        dwType = TYPE_FROM_PROTO_ID(pInfoHdr->TocEntry[i].InfoType);

        if(dwType == PROTO_TYPE_MS1)
        {
            continue;
        }
            
        //
        // Go through the loaded routing protocols and see if the protocol is
        // in the list
        // If it is, we just call SetGlobalInfo callback.
        // If not we load the protocol
        //
            
        pProtocolCb = NULL;
        bFoundProto = FALSE;
            
        for(pleNode = g_leProtoCbList.Flink; 
            pleNode != &g_leProtoCbList; 
            pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;
                
            if(pProtocolCb->dwProtocolId is pInfoHdr->TocEntry[i].InfoType)
            {
                bFoundProto = TRUE;
                    
                break;
            }
        }
            
        if(bFoundProto)
        {
            //
            // Ok, so this protocol was already loaded.
            //
                
            if(pInfoHdr->TocEntry[i].InfoSize is 0)
            {
                //
                // 0 TOC size means delete
                //
                    
                if(pProtocolCb->posOpState is RTR_STATE_RUNNING) 
                {
                    //
                    // If its stopped or stopping, we dont tell it again
                    //

                    Trace1(GLOBAL,
                           "SetGlobalInfo: Removing %S since the TOC size was 0",
                           pProtocolCb->pwszDisplayName);
                    
                    dwResult = StopRoutingProtocol(pProtocolCb);
                    
                    if(dwResult is NO_ERROR)
                    {
                        //
                        // The routing protocol stopped synchronously and
                        // all references to it in the interfaces have
                        // been removed
                        //
                            
                        //
                        // At this point we need to hold the PROTOCOL_CB_LIST
                        // lock exclusively
                        //

                        //
                        // relenquish CPU to enable DLL threads to
                        // finish
                        //
                        
                        Sleep(0);
                        
                        FreeLibrary(pProtocolCb->hiHInstance);
                            
                        RemoveEntryList(&(pProtocolCb->leList));
                            
                        HeapFree(IPRouterHeap, 
                                 0, 
                                 pProtocolCb);
                    
                        TotalRoutingProtocols--;
                    }
                    else
                    {
                        if(dwResult isnot ERROR_PROTOCOL_STOP_PENDING)
                        {
                            Trace2(ERR,
                                   "SetGlobalInfo: Error %d stopping %S. Not removing from list",
                                   dwResult,
                                   pProtocolCb->pwszDisplayName);
                        }
                    }
                }
            }
            else
            {
                //
                // So we do have info with this protocol
                //
                    
                pvInfo = GetInfoFromTocEntry(pInfoHdr,
                                             &(pInfoHdr->TocEntry[i]));
           
                
                //ulStructureVersion = pInfoHdr->TocEntry[i].InfoVersion;
                ulStructureVersion = 0x500;
                ulStructureSize  = pInfoHdr->TocEntry[i].InfoSize;
                ulStructureCount = pInfoHdr->TocEntry[i].Count;
 
                dwResult = (pProtocolCb->pfnSetGlobalInfo)(pvInfo,
                                                           ulStructureVersion,
                                                           ulStructureSize,
                                                           ulStructureCount);

                if(dwResult isnot NO_ERROR)
                {
                    Trace2(ERR,
                           "SetGlobalInfo: Error %d setting info for %S",
                           dwResult,
                           pProtocolCb->pwszDisplayName);
                }
            }
        }
        else
        {
            //
            // Well the protocol was not found so, lets load it up
            // 

            //
            // Bad case when size == 0
            //

            if(pInfoHdr->TocEntry[i].InfoSize is 0)
            {
                continue;
            }

            bFoundInfo = FALSE;
                
            for(j = 0; j < dwNumProtoEntries; j ++)
            {
                if(pmpProtocolInfo[j].dwProtocolId is pInfoHdr->TocEntry[i].InfoType)
                {
                    bFoundInfo = TRUE;

                    break;
                }
            }

            if(!bFoundInfo)
            {
                Trace1(ERR,
                       "SetGlobalInfo: Couldnt find config information for %d",
                       pInfoHdr->TocEntry[i].InfoType);

                continue;
            }

            //
            // Load the library and make a cb for this protocol
            //

            
            dwSize =
                (wcslen(pmpProtocolInfo[j].wszProtocol) + wcslen(pmpProtocolInfo[j].wszDLLName) + 2) * sizeof(WCHAR) +
                sizeof(PROTO_CB);
            
            pProtocolCb = HeapAlloc(IPRouterHeap, 
                                    HEAP_ZERO_MEMORY, 
                                    dwSize);

            if(pProtocolCb is NULL) 
            {
                Trace2(ERR,
                       "SetGlobalInfo: Error allocating %d bytes for %S",
                       dwSize,
                       pmpProtocolInfo[j].wszProtocol);
                
                continue ;
            }

            pvInfo = GetInfoFromTocEntry(pInfoHdr,
                                         &(pInfoHdr->TocEntry[i]));

            //ulStructureVersion = pInfoHdr->TocEntry[i].InfoVersion;
            ulStructureSize  = pInfoHdr->TocEntry[i].InfoSize;
            ulStructureCount = pInfoHdr->TocEntry[i].Count;

            dwResult = LoadProtocol(&(pmpProtocolInfo[j]),
                                    pProtocolCb,
                                    pvInfo,
                                    ulStructureVersion,
                                    ulStructureSize,
                                    ulStructureCount);
       
            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "SetGlobalInfo: %S failed to load: %d",
                       pmpProtocolInfo[j].wszProtocol,
                       dwResult);
            
                HeapFree (IPRouterHeap,
                          0,
                          pProtocolCb) ;
            
            }
            else
            {
                pProtocolCb->posOpState = RTR_STATE_RUNNING ;
            
                //
                // Insert this routing protocol in the list of routing
                // protocols
                //
            
                InsertTailList (&g_leProtoCbList, &pProtocolCb->leList);
                
                Trace1(GLOBAL, 
                       "SetGlobalInfo: %S successfully initialized", 
                       pmpProtocolInfo[j].wszProtocol) ;
            
                TotalRoutingProtocols++;

                //
                // Lets see if it wants to be in promiscuous add mode.
                // If so, add all the current interfaces
                //

                if(pProtocolCb->fSupportedFunctionality & RF_ADD_ALL_INTERFACES)
                {
                    //
                    // First lets add the internal interface
                    //

                    if(g_pInternalInterfaceCb)
                    {
                        dwResult = AddInterfaceToProtocol(g_pInternalInterfaceCb,
                                                          pProtocolCb,
                                                          NULL,
                                                          0,
                                                          0,
                                                          0);

                        if(dwResult isnot NO_ERROR)
                        {
                            Trace3(ERR,
                                   "SetGlobalInfo: Error %d adding %S to %S promously",
                                   dwResult,
                                   g_pInternalInterfaceCb->pwszName,
                                   pProtocolCb->pwszDisplayName);
    
                        }
    
                        if(g_pInternalInterfaceCb->dwAdminState is IF_ADMIN_STATUS_UP)
                        {
                            EnableInterfaceWithAllProtocols(g_pInternalInterfaceCb);
                        }
    
                        if(g_pInternalInterfaceCb->bBound)
                        {
                            BindInterfaceInAllProtocols(g_pInternalInterfaceCb);
                        }
                    }

                    for(pleNode = &ICBList;
                        pleNode->Flink != &ICBList;
                        pleNode = pleNode->Flink)
                    {
                        PICB    pIcb;

                        pIcb = CONTAINING_RECORD(pleNode->Flink,
                                                 ICB,
                                                 leIfLink);


                        if(pIcb is g_pInternalInterfaceCb)
                        {
                            //
                            // Already added, continue;
                            //
                        
                            continue;
                        }

                        if(pIcb->ritType is ROUTER_IF_TYPE_DIALOUT)
                        {
                            //
                            // Skip dial out interfaces
                            //

                            continue;
                        }

                        if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
                        {
                            IP_LOCAL_BINDING    clientAddr;

                            //
                            // Just call connect client for these
                            // We have to have internal interface
                            //

                            clientAddr.Address = pIcb->pibBindings[0].dwAddress;
                            clientAddr.Mask    = pIcb->pibBindings[0].dwMask;

                            if(pProtocolCb->pfnConnectClient)
                            {
                                pProtocolCb->pfnConnectClient(g_pInternalInterfaceCb->dwIfIndex,
                                                              &clientAddr);
                            }

                            continue;
                        }

                        //
                        // The rest we add
                        //

                        dwResult = AddInterfaceToProtocol(pIcb,
                                                          pProtocolCb,
                                                          NULL,
                                                          0,
                                                          0,
                                                          0);

                        if(dwResult isnot NO_ERROR)
                        {
                            Trace3(ERR,
                                   "SetGlobalInfo: Error %d adding %S to %S promiscuously",
                                   dwResult,
                                   pIcb->pwszName,
                                   pProtocolCb->pwszDisplayName);

                            continue;
                        }

                        if(pIcb->dwAdminState is IF_ADMIN_STATUS_UP)
                        {
                            EnableInterfaceWithAllProtocols(pIcb);
                        }

                        if(pIcb->bBound)
                        {
                            BindInterfaceInAllProtocols(pIcb);
                        }
                    }
                }
            }
        }
    }

    MprSetupProtocolFree(pmpProtocolInfo);

    EXIT_LOCK(PROTOCOL_CB_LIST);

    EXIT_LOCK(ICB_LIST);
    
    TraceLeave("SetGlobalInfo");

    ExitRouterApi();
    
    return NO_ERROR;
}

DWORD
GetGlobalInfo(
    OUT    LPVOID    pGlobalInfo,
    IN OUT LPDWORD   lpdwGlobalInfoSize
    )

/*++

Routine Description

    This function

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD dwSize;
    DWORD dwResult;

    EnterRouterApi();

    TraceEnter("GetGlobalInfo");
    
    ENTER_READER(ICB_LIST);
    ENTER_READER(PROTOCOL_CB_LIST);
    
    dwSize = GetSizeOfGlobalInfo();
    
    if(dwSize > *lpdwGlobalInfoSize)
    {
        *lpdwGlobalInfoSize = dwSize;
        
        EXIT_LOCK(PROTOCOL_CB_LIST);
        EXIT_LOCK(ICB_LIST);
        
        TraceLeave("GetGlobalInfo");
        
        ExitRouterApi();

        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    
    dwResult = GetGlobalConfiguration((PRTR_INFO_BLOCK_HEADER)pGlobalInfo,
                                      *lpdwGlobalInfoSize);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetGlobalInfo: Error %d getting global config",
               dwResult);
    }
    
    EXIT_LOCK(PROTOCOL_CB_LIST);
    EXIT_LOCK(ICB_LIST);


    TraceLeave("GetGlobalInfo");
    
    ExitRouterApi();

    return NO_ERROR;
}


DWORD
UpdateRoutes(
    IN HANDLE hInterface, 
    IN HANDLE hEvent
    )
{
    DWORD           i;
    DWORD           dwResult;
    PIF_PROTO       pProto;
    PICB            pIcb;
    PLIST_ENTRY     pleNode;
    
    EnterRouterApi();

    TraceEnter("UpdateRoutes");
    
    // *** Exclusion Begin ***
    ENTER_READER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb != NULL)
    {
        Trace1(ROUTE,
               "UpdateRoutes: Updating routes over %S", pIcb->pwszName) ;
        
        if(pIcb->dwOperationalState < CONNECTED)
        {
            Trace1(ERR,
                   "UpdateRoutes: %S is not connected.",
                   pIcb->pwszName);

            EXIT_LOCK(ICB_LIST);

            TraceLeave("UpdateRoutes");

            ExitRouterApi();

            return ERROR_INVALID_PARAMETER;
        }

        //
        // We first delete all the routes over this interface. If we
        // fail the update routes, that means we have lost the autostatic
        // routes. But that is OK, since if we fail for some reason - that
        // is an error condition and we should be getting rid of the routes
        // anyway. Sure, we can fail for non protocol related reasons
        // (out of memory) but that is also an error.  Earlier we used to
        // let the routing protocol finish its update and then delete the
        // route. However if RIP did not have "Overwrite routes" stuff 
        // set, it would not write its routes to RTM. So now we first delete
        // the routes. This means that for some time (while the update is
        // going on) we have loss of reachability. 
        //

        dwResult = DeleteRtmRoutesOnInterface(g_hAutoStaticRoute,
                                              pIcb->dwIfIndex);

        if(//(dwResult isnot ERROR_NO_ROUTES) and
           (dwResult isnot NO_ERROR))
        {
            Trace1(ERR,
                   "UpdateRoutes: Error %d block deleting routes",
                   dwResult);

            EXIT_LOCK(ICB_LIST);

            TraceLeave("UpdateRoutes");
            
            ExitRouterApi();

            return dwResult ;
        }
            
        if(pIcb->hDIMNotificationEvent isnot NULL)
        {
            //
            // There is already an update routes for this interface in progress 
            //
            
            dwResult = ERROR_UPDATE_IN_PROGRESS;
        }
        else
        {
            dwResult = ERROR_FILE_NOT_FOUND;

            // *** Exclusion Begin ***
            ENTER_READER(PROTOCOL_CB_LIST);
                
            //
            // Find a protocol that supports update route operation. we
            // settle for the first one that does.
            //
            
            for(pleNode = pIcb->leProtocolList.Flink;
                pleNode isnot &(pIcb->leProtocolList);
                pleNode = pleNode->Flink)
            {
                pProto = CONTAINING_RECORD(pleNode,
                                           IF_PROTO,
                                           leIfProtoLink);
                
                if(pProto->pActiveProto->pfnUpdateRoutes isnot NULL)
                {
                    //
                    // found a routing protocol that supports updates
                    //
                    
                    dwResult = (pProto->pActiveProto->pfnUpdateRoutes)(
                                   pIcb->dwIfIndex
                                   );

                    if((dwResult isnot NO_ERROR) and (dwResult isnot PENDING))
                    {
                        //
                        // The protocol can return NO_ERROR, or PENDING all
                        // else is an error
                        //

                        Trace2(ERR,
                               "UpdateRoutes: %S returned %d while trying to update routes. Trying other protocols",
                               pProto->pActiveProto->pwszDisplayName,
                               dwResult);
                    }
                    else
                    {
                        //
                        // Even if the protocol returned NO_ERROR, this is
                        // an inherently
                        // asynchronous call, so we return PENDING
                        //

                        dwResult = PENDING;

                        pIcb->hDIMNotificationEvent = hEvent;

                        break;
                    }
                }
            }
                
            // *** Exclusion End ***
            EXIT_LOCK(PROTOCOL_CB_LIST);
        }
    }
    else
    {
        Trace1(
            ANY,
            "UpdateRoutes : No interface with ICB number %d",
            HandleToULong(hInterface)
            );

        dwResult = ERROR_INVALID_INDEX;
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    TraceLeave("UpdateRoutes");
    
    ExitRouterApi();

    return dwResult ;
}

DWORD
GetUpdateRoutesResult(
    IN  HANDLE  hInterface, 
    OUT PDWORD  pdwUpdateResult
    )
{
    DWORD               dwResult ;
    UpdateResultList    *pResult ;
    PLIST_ENTRY         pleNode ;
    PICB                pIcb;
    
    EnterRouterApi();
    
    TraceEnter("GetUpdateRoutesResult") ;
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    pIcb = InterfaceLookupByICBSeqNumber(HandleToULong(hInterface));

    IpRtAssert(pIcb);

    if (pIcb != NULL)
    {
        if (IsListEmpty (&pIcb->lePendingResultList))
        {
            dwResult = ERROR_CAN_NOT_COMPLETE ;
        }
        else
        {
            pleNode = RemoveHeadList (&pIcb->lePendingResultList) ;
            
            pResult = CONTAINING_RECORD(pleNode,
                                        UpdateResultList,
                                        URL_List) ;
            
            *pdwUpdateResult = pResult->URL_UpdateStatus;
            
            HeapFree(IPRouterHeap,
                     0,
                     pResult) ;
            
            dwResult = NO_ERROR ;
        }
    }
    else
    {
        Trace1(
            ANY,
            "GetInterfaceInfo : No interface with ICB number %d",
            HandleToULong(hInterface)
            );

        dwResult = ERROR_INVALID_INDEX;
    }
    
    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    TraceLeave("GetUpdateRoutesResult");
    
    ExitRouterApi();

    return dwResult;
}

DWORD
DemandDialRequest(
    IN DWORD dwProtocolId,
    IN DWORD dwInterfaceIndex
    )
{
    PICB    pIcb;
    DWORD   dwResult;
    HANDLE  hDim;

    EnterRouterApi();

    TraceEnter("DemandDialRequest");

    //
    // This doesnt follow the normal locking rules of not taking locks
    // when calling up
    //

    ENTER_READER(ICB_LIST);

    pIcb = InterfaceLookupByIfIndex(dwInterfaceIndex);

    if(pIcb is NULL)
    {
        EXIT_LOCK(ICB_LIST);

        return ERROR_INVALID_INDEX;
    }

    hDim = pIcb->hDIMHandle;

    EXIT_LOCK(ICB_LIST);

    dwResult = (ConnectInterface)(hDim,
                                  PID_IP);

    TraceLeave("DemandDialRequest");
    
    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryCreate(
    IN DWORD   dwRoutingPid,
    IN DWORD   dwEntrySize,
    IN LPVOID  lpEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpEntry;
    DWORD               dwInEntrySize,dwOutEntrySize, dwResult;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;
    DWORD               rgdwQuery[6];
    
    EnterRouterApi();;

    TraceEnter("RtrMgrMIBEntryCreate");
    
    pQuery = (PMIB_OPAQUE_QUERY)rgdwQuery;
    
    if(dwRoutingPid is IPRTRMGR_PID)
    {
        switch(pInfo->dwId)
        {
            case IP_FORWARDROW:
            {
                PMIB_IPFORWARDROW pRow = (PMIB_IPFORWARDROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_FORWARDROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwForwardDest;
                pQuery->rgdwVarIndex[1] = pRow->dwForwardProto;
                pQuery->rgdwVarIndex[2] = pRow->dwForwardPolicy;
                pQuery->rgdwVarIndex[3] = pRow->dwForwardNextHop;
                
                dwOutEntrySize  = dwEntrySize;
                dwInEntrySize   = sizeof(MIB_OPAQUE_QUERY) + 3 * sizeof(DWORD);
                
                dwResult = AccessIpForwardRow(ACCESS_CREATE_ENTRY,
                                              dwInEntrySize,
                                              pQuery,
                                              &dwOutEntrySize,
                                              pInfo,
                                              &fCache);
                

                break;
            }

            case ROUTE_MATCHING:
            {
                dwOutEntrySize = dwEntrySize;

                dwResult = AccessIpMatchingRoute(ACCESS_CREATE_ENTRY,
                                                 0, 
                                                 NULL,
                                                 &dwOutEntrySize,
                                                 pInfo,
                                                 &fCache);
                break;
            }
            
            case IP_NETROW:
            {
                PMIB_IPNETROW pRow = (PMIB_IPNETROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_NETROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwIndex;
                pQuery->rgdwVarIndex[1] = pRow->dwAddr;
                
                dwOutEntrySize = dwEntrySize;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + sizeof(DWORD);
                
                dwResult = AccessIpNetRow(ACCESS_CREATE_ENTRY,
                                          dwInEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache);
                

                break;
            }

            case PROXY_ARP:
            {
                PMIB_PROXYARP pRow = (PMIB_PROXYARP)(pInfo->rgbyData);

                pQuery->dwVarId = IP_NETROW;

                pQuery->rgdwVarIndex[0] = pRow->dwAddress;
                pQuery->rgdwVarIndex[1] = pRow->dwMask;
                pQuery->rgdwVarIndex[2] = pRow->dwIfIndex;

                dwOutEntrySize = dwEntrySize;

                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + (2 * sizeof(DWORD));

                dwResult = AccessProxyArp(ACCESS_CREATE_ENTRY,
                                          dwInEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache);


                break;
            }

            default:
            {
                dwResult = ERROR_INVALID_PARAMETER;
                
                break;
            }
        }
    }
    else
    {
        //
        // Send over to other pids
        //

        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);
        
        dwResult = ERROR_CAN_NOT_COMPLETE;

        for(pleNode = g_leProtoCbList.Flink; 
             pleNode != &g_leProtoCbList; 
             pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList);
            
            if (dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibCreateEntry)(dwEntrySize,
                                                       lpEntry) ;
                break;
            }
        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

    }

    TraceLeave("RtrMgrMIBEntryCreate");
    
    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryDelete(
    IN DWORD   dwRoutingPid,
    IN DWORD   dwEntrySize,
    IN LPVOID  lpEntry
    )
{
    DWORD               dwOutEntrySize = 0;
    PMIB_OPAQUE_QUERY   pQuery = (PMIB_OPAQUE_QUERY) lpEntry;
    DWORD               dwResult;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;

    
    EnterRouterApi();

    TraceEnter("RtrMgrMIBEntryDelete");

    if(dwRoutingPid is IPRTRMGR_PID)
    {
        switch(pQuery->dwVarId)
        {
            case IP_FORWARDROW:
            {
                dwResult = AccessIpForwardRow(ACCESS_DELETE_ENTRY,
                                              dwEntrySize,
                                              pQuery,
                                              &dwOutEntrySize,
                                              NULL,
                                              &fCache);
                break;
            }

            case ROUTE_MATCHING:
            {
                dwResult = AccessIpMatchingRoute(ACCESS_DELETE_ENTRY,
                                                 dwEntrySize,
                                                 pQuery,
                                                 &dwOutEntrySize,
                                                 NULL,
                                                 &fCache);
                break;
            }

            case IP_NETROW:
            {
                dwResult = AccessIpNetRow(ACCESS_DELETE_ENTRY,
                                          dwEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          NULL,
                                          &fCache);
                break;
            }
            case PROXY_ARP:
            {
                dwResult = AccessProxyArp(ACCESS_DELETE_ENTRY,
                                          dwEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          NULL,
                                          &fCache);
                break;
            }
            case IP_NETTABLE:
            {
                dwResult = AccessIpNetRow(ACCESS_DELETE_ENTRY,
                                          dwEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          NULL,
                                          &fCache);
                break;
            }
            default:
            {
                dwResult = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }
    else
    {

        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);

        dwResult = ERROR_CAN_NOT_COMPLETE;

        for (pleNode = g_leProtoCbList.Flink; 
             pleNode != &g_leProtoCbList; 
             pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList);

            if(dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibDeleteEntry)(dwEntrySize,
                                                       lpEntry);
                break ;
            }

        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

    }

    TraceLeave("RtrMgrMIBEntryDelete");
    
    ExitRouterApi();

    return dwResult;
    
}

DWORD
RtrMgrMIBEntrySet(
    IN DWORD  dwRoutingPid,
    IN DWORD  dwEntrySize,
    IN LPVOID lpEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpEntry;
    DWORD               dwInEntrySize, dwOutEntrySize, dwResult=NO_ERROR;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;
    DWORD               rgdwQuery[6];
    
    EnterRouterApi();;

    TraceEnter("RtrMgrMIBEntrySet");

    pQuery = (PMIB_OPAQUE_QUERY)rgdwQuery;
    
    if(dwRoutingPid is IPRTRMGR_PID)
    {

        switch(pInfo->dwId)
        {
            case IF_ROW:
            {
                PMIB_IFROW  pRow = (PMIB_IFROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IF_ROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwIndex;
                
                dwOutEntrySize = dwEntrySize;
                
                dwInEntrySize  = sizeof(MIB_OPAQUE_QUERY);
                
                dwResult = AccessIfRow(ACCESS_SET,
                                       dwInEntrySize,
                                       pQuery,
                                       &dwOutEntrySize,
                                       pInfo,
                                       &fCache);
                

                break;
            }

            case TCP_ROW:
            {
                PMIB_TCPROW pRow = (PMIB_TCPROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = TCP_ROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwLocalAddr;
                pQuery->rgdwVarIndex[1] = pRow->dwLocalPort;
                pQuery->rgdwVarIndex[2] = pRow->dwRemoteAddr;
                pQuery->rgdwVarIndex[3] = pRow->dwRemotePort;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + (3 * sizeof(DWORD));
                
                dwOutEntrySize = dwEntrySize;
                
                dwResult = AccessTcpRow(ACCESS_SET,
                                        dwInEntrySize,
                                        pQuery,
                                        &dwOutEntrySize,
                                        pInfo,
                                        &fCache);
                
                break;
            }
            
            case IP_STATS:
            {
                PMIB_IPSTATS pStats = (PMIB_IPSTATS)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_STATS;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) - sizeof(DWORD);
                
                dwOutEntrySize = dwEntrySize;
                
                dwResult = AccessIpStats(ACCESS_SET,
                                         dwInEntrySize,
                                         pQuery,
                                         &dwOutEntrySize,
                                         pInfo,
                                         &fCache);
                
                break;
            }
              
            case IP_FORWARDROW:
            {
                PMIB_IPFORWARDROW pRow = (PMIB_IPFORWARDROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_FORWARDROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwForwardDest;
                pQuery->rgdwVarIndex[1] = pRow->dwForwardProto;
                pQuery->rgdwVarIndex[2] = pRow->dwForwardPolicy;
                pQuery->rgdwVarIndex[3] = pRow->dwForwardNextHop;

                dwOutEntrySize = dwEntrySize;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + 3 * sizeof(DWORD);
                
                dwResult = AccessIpForwardRow(ACCESS_SET,
                                              dwInEntrySize,
                                              pQuery,
                                              &dwOutEntrySize,
                                              pInfo,
                                              &fCache);
                
                break;
            }

            case ROUTE_MATCHING:
            {
                dwOutEntrySize = dwEntrySize;

                dwResult = AccessIpMatchingRoute(ACCESS_SET,
                                                 0, 
                                                 NULL,
                                                 &dwOutEntrySize,
                                                 pInfo,
                                                 &fCache);
                break;
            }
            
            case IP_NETROW:
            {
                PMIB_IPNETROW pRow = (PMIB_IPNETROW)(pInfo->rgbyData);
                
                pQuery->dwVarId = IP_NETROW;
                
                pQuery->rgdwVarIndex[0] = pRow->dwIndex;
                pQuery->rgdwVarIndex[1] = pRow->dwAddr;
                
                dwOutEntrySize = dwEntrySize;
                
                dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + sizeof(DWORD);
                
                dwResult = AccessIpNetRow(ACCESS_SET,
                                          dwInEntrySize,
                                          pQuery,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache);
                
                break;
            }

            case MCAST_MFE:
            {
                dwResult = AccessMcastMfe(ACCESS_SET,
                                          0,
                                          NULL,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache); 

                break;
            }

            case MCAST_BOUNDARY:
            {
                dwResult = AccessMcastBoundary(ACCESS_SET,
                                          0,
                                          NULL,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache); 

                break;
            }

            case MCAST_SCOPE:
            {
                dwResult = AccessMcastScope(ACCESS_SET,
                                          0,
                                          NULL,
                                          &dwOutEntrySize,
                                          pInfo,
                                          &fCache); 

                break;
            }

            case PROXY_ARP:
            {
                 PMIB_PROXYARP pRow = (PMIB_PROXYARP)(pInfo->rgbyData);

                 pQuery->dwVarId = IP_NETROW;

                 pQuery->rgdwVarIndex[0] = pRow->dwAddress;
                 pQuery->rgdwVarIndex[1] = pRow->dwMask;
                 pQuery->rgdwVarIndex[2] = pRow->dwIfIndex;

                 dwOutEntrySize = dwEntrySize;

                 dwInEntrySize = sizeof(MIB_OPAQUE_QUERY) + (2 *  sizeof(DWORD));

                 dwResult = AccessProxyArp(ACCESS_CREATE_ENTRY,
                                           dwInEntrySize,
                                           pQuery,
                                           &dwOutEntrySize,
                                           pInfo,
                                           &fCache);
                 break;
            }
            
            default:
            {
                dwResult = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }
    else
    {
        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);

        dwResult = ERROR_CAN_NOT_COMPLETE;

        for (pleNode = g_leProtoCbList.Flink; 
             pleNode != &g_leProtoCbList; 
             pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;

            if (dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibSetEntry) (dwEntrySize, lpEntry) ;
                break ;
            }

        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

    }
    
    TraceLeave("RtrMgrMIBEntrySet");

    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryGet(
    IN     DWORD      dwRoutingPid,
    IN     DWORD      dwInEntrySize,
    IN     LPVOID     lpInEntry,
    IN OUT LPDWORD    lpOutEntrySize,
    OUT    LPVOID     lpOutEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery = (PMIB_OPAQUE_QUERY)lpInEntry;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpOutEntry;
    BOOL                fCache;
    DWORD               dwResult;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;

    EnterRouterApi();
    
    TraceEnter("RtrMgrMIBEntryGet");

    if(dwRoutingPid is IPRTRMGR_PID)
    {
        if(*lpOutEntrySize > 0)
        {
            ZeroMemory(lpOutEntry,
                       *lpOutEntrySize);
        }

        dwResult = (*g_AccessFunctionTable[pQuery->dwVarId])(ACCESS_GET,
                                                             dwInEntrySize,
                                                             pQuery,
                                                             lpOutEntrySize,
                                                             pInfo,
                                                             &fCache);
    }
    else
    {

        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);

        dwResult = ERROR_CAN_NOT_COMPLETE;

        for (pleNode = g_leProtoCbList.Flink; 
             pleNode != &g_leProtoCbList; 
             pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList);

            if (dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibGetEntry) (dwInEntrySize,
                                                     lpInEntry, 
                                                     lpOutEntrySize,
                                                     lpOutEntry) ;
                break ;
            }
        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);
    }
    
    TraceLeave("RtrMgrMIBEntryGet");
    
    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryGetFirst(
    IN     DWORD     dwRoutingPid,
    IN     DWORD     dwInEntrySize,
    IN     LPVOID    lpInEntry,
    IN OUT LPDWORD   lpOutEntrySize,
    OUT    LPVOID    lpOutEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery = (PMIB_OPAQUE_QUERY)lpInEntry;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpOutEntry;
    DWORD               dwResult;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;

    EnterRouterApi();

    TraceEnter("RtrMgrMIBEntryGetFirst");

    if(dwRoutingPid is IPRTRMGR_PID)
    {
        if(*lpOutEntrySize > 0)
        {
            ZeroMemory(lpOutEntry,
                       *lpOutEntrySize);
        }

        dwResult = (*g_AccessFunctionTable[pQuery->dwVarId])(ACCESS_GET_FIRST,
                                                             dwInEntrySize,
                                                             pQuery,
                                                             lpOutEntrySize,
                                                             pInfo,
                                                             &fCache);
    }
    else
    {
        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);
        
        dwResult = ERROR_CAN_NOT_COMPLETE;

        for(pleNode = g_leProtoCbList.Flink; 
            pleNode != &g_leProtoCbList; 
            pleNode = pleNode->Flink) 
        {
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;

            if (dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibGetFirstEntry)(dwInEntrySize,
                                                              lpInEntry, 
                                                              lpOutEntrySize,
                                                              lpOutEntry);
                break;
            }
        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);

    }

    TraceLeave("RtrMgrMIBEntryGetFirst");

    ExitRouterApi();

    return dwResult;
}

DWORD
RtrMgrMIBEntryGetNext(
    IN     DWORD      dwRoutingPid,
    IN     DWORD      dwInEntrySize,
    IN     LPVOID     lpInEntry,
    IN OUT LPDWORD    lpOutEntrySize,
    OUT    LPVOID     lpOutEntry
    )
{
    PMIB_OPAQUE_QUERY   pQuery = (PMIB_OPAQUE_QUERY)lpInEntry;
    PMIB_OPAQUE_INFO    pInfo = (PMIB_OPAQUE_INFO)lpOutEntry;
    DWORD               dwResult;
    BOOL                fCache;
    PPROTO_CB  pProtocolCb ;
    PLIST_ENTRY         pleNode ;

    EnterRouterApi();

    TraceEnter("RtrMgrMIBEntryGetNext");

    if(dwRoutingPid is IPRTRMGR_PID)
    {
        if(*lpOutEntrySize > 0)
        {
            ZeroMemory(lpOutEntry,
                       *lpOutEntrySize);
        }
    
        dwResult = (*g_AccessFunctionTable[pQuery->dwVarId])(ACCESS_GET_NEXT,
                                                             dwInEntrySize,
                                                             pQuery,
                                                             lpOutEntrySize,
                                                             pInfo,
                                                             &fCache);
    } 
    else
    {
        // *** Exclusion Begin ***
        ENTER_READER(PROTOCOL_CB_LIST);
        
        dwResult = ERROR_CAN_NOT_COMPLETE;
        
        for(pleNode = g_leProtoCbList.Flink; 
            pleNode != &g_leProtoCbList; 
            pleNode = pleNode->Flink) 
        { 
            pProtocolCb = CONTAINING_RECORD(pleNode,
                                            PROTO_CB,
                                            leList) ;
            
            if(dwRoutingPid == pProtocolCb->dwProtocolId) 
            {
                dwResult = (pProtocolCb->pfnMibGetNextEntry)(dwInEntrySize,
                                                             lpInEntry, 
                                                             lpOutEntrySize,
                                                             lpOutEntry);
                break;
            }
            
        }

        // *** Exclusion End ***
        EXIT_LOCK(PROTOCOL_CB_LIST);
    }

    TraceLeave("RtrMgrMIBEntryGetNext");

    ExitRouterApi();

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\ipipcfg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\ipipcfg.c

Abstract:

    The configuration code for ipinip

Revision History:

    Amritansh Raghav

--*/

#include "allinc.h"

//
// All the following are protected by the ICB_LIST lock
//

HKEY        g_hIpIpIfKey;
DWORD       g_dwNumIpIpInterfaces;
HANDLE      g_hIpInIpDevice;


DWORD
OpenIpIpKey(
    VOID
    )

/*++

Routine Description

    Opens the necessary reg keys for IP in IP

Locks

    None

Arguments

    None

Return Value

    Win32 errors
    
--*/

{
    DWORD   dwResult;

    g_hIpIpIfKey = NULL;
    
    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            REG_KEY_TCPIP_INTERFACES,
                            0,
                            KEY_ALL_ACCESS,
                            &g_hIpIpIfKey);

    if(dwResult isnot NO_ERROR)
    {
        g_hIpIpIfKey = NULL;

        Trace1(ERR,
               "OpenIpIpKey: Error %d opening interfaces key\n",
              dwResult);

        return dwResult;
    }

    return NO_ERROR;
}

VOID
CloseIpIpKey(
    VOID
    )

/*++

Routine Description

    Closes the necessary reg keys for IP in IP

Locks

    None

Arguments

    None

Return Value

    None
    
--*/

{
    if(g_hIpIpIfKey isnot NULL)
    {
        RegCloseKey(g_hIpIpIfKey);

        g_hIpIpIfKey = NULL;
    }
}

VOID
DeleteIpIpKeyAndInfo(
    IN  PICB    pIcb
    )

/*++

Routine Description

    Deletes the key used for the interface

Locks

    ICB_LIST as writer

Arguments

    pIcb    ICB of the interface to delete
 
Return Value

    None
    
--*/

{
    if(pIcb->pIpIpInfo)
    {
        HeapFree(IPRouterHeap,
                 0,
                 pIcb->pIpIpInfo);

        pIcb->pIpIpInfo = NULL;
    }
    
    RegDeleteKeyW(g_hIpIpIfKey,
                  pIcb->pwszName);
}

DWORD
CreateIpIpKeyAndInfo(
    IN  PICB    pIcb
    )

/*++

Routine Description

    Creates a key under the tcpip interfaces 

Locks

    ICB_LIST lock held as READER (atleast)

Arguments

    ICB for whom to create a key

Return Value

    Win32 errors

--*/

{
    DWORD       dwResult, dwDisposition, dwIndex, dwSize;
    HKEY        hNewIfKey;
    TCHAR       ptszNoAddr[] = "0.0.0.0\0";
    
    dwDisposition = 0;

    dwResult = RegCreateKeyExW(g_hIpIpIfKey,
                               pIcb->pwszName,
                               0,
                               UNICODE_NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hNewIfKey,
                               &dwDisposition);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "CreateIpIpKey: Error %d creating %S",
               dwResult,
               pIcb->pwszName);

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Good, key is done, now do the minimum needed by IP
    //

    do
    {
        //
        // Create a block for the configuration. When the dwLocalAddress is
        // 0, it means that the information hasnt been set
        //

        pIcb->pIpIpInfo = HeapAlloc(IPRouterHeap,
                                    HEAP_ZERO_MEMORY,
                                    sizeof(IPINIP_CONFIG_INFO));

        if(pIcb->pIpIpInfo is NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;

            break;
        }
        
        dwResult = RegSetValueEx(hNewIfKey,
                                 REG_VAL_DEFGATEWAY,
                                 0,
                                 REG_MULTI_SZ,
                                 NULL,
                                 0);
    
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "CreateIpIpKey: Error %d setting %s",
                   dwResult, REG_VAL_DEFGATEWAY);

            break;
        }

        dwDisposition = 0;
    
        dwResult = RegSetValueEx(hNewIfKey,
                                 REG_VAL_ENABLEDHCP,
                                 0,
                                 REG_DWORD,
                                 (CONST BYTE *)&dwDisposition,
                                 sizeof(DWORD));
    
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "CreateIpIpKey: Error %d setting %s",
                   dwResult, REG_VAL_ENABLEDHCP);

            break;
        }

        dwResult = RegSetValueEx(hNewIfKey,
                                 REG_VAL_IPADDRESS,
                                 0,
                                 REG_MULTI_SZ,
                                 (CONST BYTE *)ptszNoAddr,
                                 sizeof(ptszNoAddr));
    
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "CreateIpIpKey: Error %d setting %s",
                   dwResult, REG_VAL_IPADDRESS);

            break;
        }

        dwResult = RegSetValueEx(hNewIfKey,
                                 REG_VAL_NTECONTEXTLIST,
                                 0,
                                 REG_MULTI_SZ,
                                 NULL,
                                 0);
    
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "CreateIpIpKey: Error %d setting %s",
                   dwResult, REG_VAL_NTECONTEXTLIST);

            break;
        }

        dwResult = RegSetValueEx(hNewIfKey,
                                 REG_VAL_SUBNETMASK,
                                 0,   
                                 REG_MULTI_SZ,
                                 (CONST BYTE *)ptszNoAddr,
                                 sizeof(ptszNoAddr));
    
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "CreateIpIpKey: Error %d setting %s",
                   dwResult, REG_VAL_SUBNETMASK);

            break;
        }

        dwDisposition = 0;
    
        dwResult = RegSetValueEx(hNewIfKey,
                                 REG_VAL_ZEROBCAST,
                                 0,
                                 REG_DWORD,
                                 (CONST BYTE *)&dwDisposition,
                                 sizeof(DWORD));
    
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "CreateIpIpKey: Error %d setting %s",
                   dwResult, REG_VAL_ZEROBCAST);
            
            break;
        }

    }while(FALSE);

    RegCloseKey(hNewIfKey);

    if(dwResult isnot NO_ERROR)
    {
        DeleteIpIpKeyAndInfo(pIcb);
    }

    return dwResult;
}       

DWORD
AddInterfaceToIpInIp(
    IN  GUID    *pGuid,
    IN  PICB    pIcb
    )

/*++

Routine Description

    Adds an interface to IP in IP driver    

Locks

    ICB_LIST lock held as WRITER
    

Arguments

    pIcb    ICB of the interface to add

Return Value

    NO_ERROR
    
--*/

{
    DWORD           dwResult;
    NTSTATUS        ntStatus;
    PADAPTER_INFO   pBindNode;
    ULONG           ulSize;
    IO_STATUS_BLOCK IoStatusBlock;

    IPINIP_CREATE_TUNNEL    CreateInfo;


    IpRtAssert(pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1);

    //
    // Get a key for this interface
    //
    
    dwResult = CreateIpIpKeyAndInfo(pIcb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "AddInterfaceToIpInIp: Error %d creating key for %S",
               dwResult,
               pIcb->pwszName);

        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // See if we need to start IP in IP
    //

    g_dwNumIpIpInterfaces++;

    if(g_dwNumIpIpInterfaces is 1)
    {
        dwResult = StartDriverAndOpenHandle(IPINIP_SERVICE_NAME,
                                            DD_IPINIP_DEVICE_NAME,
                                            &g_hIpInIpDevice);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "AddInterfaceToIpInIp: Error %d starting ipinip for %S",
                   dwResult,
                   pIcb->pwszName);

            g_dwNumIpIpInterfaces--;

            DeleteIpIpKeyAndInfo(pIcb);

            return dwResult;
        }

        //
        // Once you start, post a notification
        //

        PostIpInIpNotification();
    }

    //
    // Copy out the name
    //
   
    CreateInfo.Guid = *pGuid;
    
    ntStatus = NtDeviceIoControlFile(g_hIpInIpDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IPINIP_CREATE_TUNNEL,
                                     &CreateInfo,
                                     sizeof(IPINIP_CREATE_TUNNEL),
                                     &CreateInfo,
                                     sizeof(IPINIP_CREATE_TUNNEL));

    if(!NT_SUCCESS(ntStatus))
    {
        Trace1(ERR,
               "AddInterfaceToIpInIp: NtStatus %x creating tunnel",
               ntStatus);

        g_dwNumIpIpInterfaces--;

        if(g_dwNumIpIpInterfaces is 0)
        {
            StopDriverAndCloseHandle(IPINIP_SERVICE_NAME,
                                     g_hIpInIpDevice);
        }
        
        DeleteIpIpKeyAndInfo(pIcb);
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Set the interface index
    //

    pIcb->bBound         = TRUE;
    pIcb->dwNumAddresses = 0;
    pIcb->dwIfIndex      = CreateInfo.dwIfIndex;

    return NO_ERROR;
}

DWORD
DeleteInterfaceFromIpInIp(
    PICB    pIcb
    )

/*++

Routine Description

    Removes an interface to IP in IP driver. Also removes binding information
    and frees the ipipcfg

Locks

    ICB_LIST lock held as WRITER
    

Arguments

    pIcb        ICB of the interface to remove

Return Value

    NO_ERROR
    
--*/

{
    NTSTATUS                ntStatus;
    IPINIP_DELETE_TUNNEL    DeleteInfo;
    PADAPTER_INFO           pBindNode; 
    IO_STATUS_BLOCK         IoStatusBlock;
    DWORD                   dwResult;

    
    IpRtAssert(pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1);

    //
    // See if the interface was added to ipinip
    //

    if(pIcb->pIpIpInfo is NULL)
    {
        return NO_ERROR;
    }

    DeleteInfo.dwIfIndex    = pIcb->dwIfIndex;

    ntStatus = NtDeviceIoControlFile(g_hIpInIpDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IPINIP_DELETE_TUNNEL,
                                     (PVOID)&DeleteInfo,
                                     sizeof(IPINIP_DELETE_TUNNEL),
                                     NULL,
                                     0);
    
    if(!NT_SUCCESS(ntStatus))
    {
        Trace1(ERR,
               "DeleteInterfaceFromIpInIp: NtStatus %x setting info",
               ntStatus);
    }

    pIcb->bBound         = FALSE;
    pIcb->dwNumAddresses = 0;

    //
    // These interfaces always have a binding
    // Clear out any info there
    //

    pIcb->pibBindings[0].dwAddress  = 0;
    pIcb->pibBindings[0].dwMask     = 0;
    
    DeleteIpIpKeyAndInfo(pIcb);

    g_dwNumIpIpInterfaces--;

    if(g_dwNumIpIpInterfaces is 0)
    {
        StopDriverAndCloseHandle(IPINIP_SERVICE_NAME,
                                 g_hIpInIpDevice);
    }

    return NO_ERROR;
}

    
DWORD
SetIpInIpInfo(
    PICB                    pIcb,
    PRTR_INFO_BLOCK_HEADER  pInterfaceInfo
    )

/*++

Routine Description

    The routine sets the IP in IP info to the driver. The interface must
    have already been added to the driver

Locks

    ICB_LIST lock held as WRITER

Arguments

    pIcb            ICB of the tunnel interface
    pInterfaceInfo  Header to the interface info

Return Value

    NO_ERROR
    
--*/

{
    PRTR_TOC_ENTRY          pToc;
    PIPINIP_CONFIG_INFO     pInfo;
    IPINIP_SET_TUNNEL_INFO  SetInfo;
    IO_STATUS_BLOCK         IoStatusBlock;
    NTSTATUS                ntStatus;
    DWORD                   dwResult;

    if(pIcb->ritType isnot ROUTER_IF_TYPE_TUNNEL1)
    {
        return NO_ERROR;
    }

    pToc  = GetPointerToTocEntry(IP_IPINIP_CFG_INFO,
                                 pInterfaceInfo);

    if(pToc is NULL)
    {
        //
        // No change
        //

        return NO_ERROR;
    }

    IpRtAssert(pToc->InfoSize isnot 0);

#if 0

    if(pToc->InfoSize is 0)
    {
        //
        // Blow the interface away from protocols etc
        //

        dwResult = LanEtcInterfaceUpToDown(pIcb,
                                           FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetIpInIpInfo: Error %d bringing %S down\n",
                   dwResult,
                   pIcb->pwszName);
        }

        //
        // Tear down the tunnel
        //

        DeleteInterfaceFromIpInIp(pIcb);

        return NO_ERROR;
    }

#endif

    //
    // Verify the information
    //

    pInfo = GetInfoFromTocEntry(pInterfaceInfo,
                                 pToc);

    if (pInfo is NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if((pInfo->dwLocalAddress is INVALID_IP_ADDRESS) or
       (pInfo->dwRemoteAddress is INVALID_IP_ADDRESS) or
       ((DWORD)(pInfo->dwLocalAddress & 0x000000E0) >= (DWORD)0x000000E0) or
       ((DWORD)(pInfo->dwRemoteAddress & 0x000000E0) >= (DWORD)0x000000E0) or
       (pInfo->byTtl is 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // See if the interface has already been added to the driver
    //

    IpRtAssert(pIcb->pIpIpInfo isnot NULL);

    SetInfo.dwIfIndex       = pIcb->dwIfIndex;
    SetInfo.dwRemoteAddress = pInfo->dwRemoteAddress;
    SetInfo.dwLocalAddress  = pInfo->dwLocalAddress;
    SetInfo.byTtl           = pInfo->byTtl;
    
    
    //
    // Set the info to the driver
    //

    ntStatus = NtDeviceIoControlFile(g_hIpInIpDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IPINIP_SET_TUNNEL_INFO,
                                     (PVOID)&SetInfo,
                                     sizeof(IPINIP_SET_TUNNEL_INFO),
                                     NULL,
                                     0);
    
    if(!NT_SUCCESS(ntStatus))
    {
        Trace1(ERR,
               "SetIpInIpInfo: NtStatus %x setting info",
               ntStatus);

#if 0
        DeleteInterfaceFromIpInIp(pIcb);

#endif

        return ERROR_CAN_NOT_COMPLETE;
    }

    pIcb->dwOperationalState           = SetInfo.dwOperationalState;
    pIcb->pIpIpInfo->dwRemoteAddress   = SetInfo.dwRemoteAddress;
    pIcb->pIpIpInfo->dwLocalAddress    = SetInfo.dwLocalAddress;
    pIcb->pIpIpInfo->byTtl             = SetInfo.byTtl;

    //
    // Also set the operational state to UP
    //

    pIcb->dwOperationalState = CONNECTED;

    return NO_ERROR;
}

DWORD
GetInterfaceIpIpInfo(
    IN     PICB                   pIcb,
    IN     PRTR_TOC_ENTRY         pToc,
    IN     PBYTE                  pbDataPtr,
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    )
{
    PIPINIP_CONFIG_INFO pInfo;

    TraceEnter("GetInterfaceIpIpInfo");

    IpRtAssert(pIcb->ritType is ROUTER_IF_TYPE_TUNNEL1);

    if(*pdwInfoSize < sizeof(IPINIP_CONFIG_INFO))
    {
        *pdwInfoSize = sizeof(IPINIP_CONFIG_INFO);

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pdwInfoSize = 0;

    if(pIcb->pIpIpInfo is NULL)
    {
        //
        // Have no info
        //

        return ERROR_NO_DATA;
    }

    *pdwInfoSize    = sizeof(IPINIP_CONFIG_INFO);

    //pToc->InfoVersion sizeof(IPINIP_CONFIG_INFO);
    pToc->InfoSize  = sizeof(IPINIP_CONFIG_INFO);
    pToc->InfoType  = IP_IPINIP_CFG_INFO;
    pToc->Count     = 1;
    pToc->Offset    = (ULONG)(pbDataPtr - (PBYTE) pInfoHdr);

    pInfo = (PIPINIP_CONFIG_INFO)pbDataPtr;

    *pInfo = *(pIcb->pIpIpInfo);

    TraceLeave("GetInterfaceIpIpInfo");

    return NO_ERROR;
}

DWORD
PostIpInIpNotification(
    VOID
    )
{
    DWORD   dwBytesRead;
    DWORD   dwErr = NO_ERROR;

    TraceEnter("PostIpInIpNotification");

    ZeroMemory(&g_IpInIpOverlapped,
               sizeof(OVERLAPPED));

    g_IpInIpOverlapped.hEvent = g_hIpInIpEvent ;

    if (!DeviceIoControl(g_hIpInIpDevice,
                         IOCTL_IPINIP_NOTIFICATION,
                         &g_inIpInIpMsg,
                         sizeof(g_inIpInIpMsg),
                         &g_inIpInIpMsg,
                         sizeof(g_inIpInIpMsg),
                         (PDWORD) &dwBytesRead,
                         &g_IpInIpOverlapped))
    {
        dwErr = GetLastError();

        if(dwErr isnot ERROR_IO_PENDING)
        {
            Trace1(ERR,
                   "PostIpInIpNotification: Couldnt post irp with IpInIp: %d",
                   dwErr);

            dwErr = NO_ERROR;
        }
        else
        {
            Trace0(IF, 
                   "PostIpInIpNotification: Notification pending in IpInIP");
        }
    }

    return dwErr;
}

VOID
HandleIpInIpEvent(
    VOID
    )
{
    PICB    pIcb;
    DWORD   dwBytes;

    ENTER_WRITER(ICB_LIST);

    TraceEnter("HandleIpInIpEvent");

    do
    {
        if((g_inIpInIpMsg.ieEvent isnot IE_INTERFACE_UP) and
           (g_inIpInIpMsg.ieEvent isnot IE_INTERFACE_DOWN))
        {
            Trace1(IF,
                   "HandleIpInIpEvent: Unknown event code %d\n",
                   g_inIpInIpMsg.ieEvent);

            break;
        }

        if(!GetOverlappedResult(g_hIpInIpDevice,
                                &g_IpInIpOverlapped,
                                &dwBytes,
                                FALSE))
        {
            Trace1(IF,
                   "HandleIpInIpEvent: Error %d from GetOverlappedResult",
                   GetLastError());

            break;
        }

        pIcb = InterfaceLookupByIfIndex(g_inIpInIpMsg.dwIfIndex);

        if(pIcb is NULL)
        {
            Trace1(IF,
                   "HandleIpInIpEvent: Interface %x not found",
                   g_inIpInIpMsg.dwIfIndex);

            break;
        }

        if(pIcb->ritType isnot ROUTER_IF_TYPE_TUNNEL1)
        {
            Trace1(IF,
                   "HandleIpInIpEvent: Interface %x not an IpInIp tunnel",
                   g_inIpInIpMsg.dwIfIndex);

            IpRtAssert(FALSE);

            break;
        }

        Trace3(IF,
               "HandleIpInIpEvent: Interface %S is %s due to %d",
               pIcb->pwszName,
               (g_inIpInIpMsg.ieEvent is IE_INTERFACE_UP) ? "operational" : "non-operational",
               g_inIpInIpMsg.iseSubEvent);

        pIcb->dwOperationalState = 
            (g_inIpInIpMsg.ieEvent is IE_INTERFACE_UP) ? OPERATIONAL : NON_OPERATIONAL;
    }while(FALSE);

    EXIT_LOCK(ICB_LIST);

    PostIpInIpNotification();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\iprtrmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\iprtrmgr.h

Abstract:

    Header for IP Router Manager

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#ifndef __RTRMGR_IPRTRMGR_H__
#define __RTRMGR_IPRTRMGR_H__


//
// Router State
//

typedef enum _RouterOperationalState 
{
    RTR_STATE_RUNNING,
    RTR_STATE_STOPPING,
    RTR_STATE_STOPPED
}RouterOperationalState, ProtocolOperationalState ;

typedef struct _IPRouterState 
{
    RouterOperationalState  IRS_State ;

    DWORD                   IRS_RefCount ;
}IPRouterState, *pIPRouterState ;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following are the the operational states for WAN and LAN interfaces. //
// These are not the same as the MIB-II operational states.                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define NON_OPERATIONAL     IF_OPER_STATUS_NON_OPERATIONAL
#define UNREACHABLE         IF_OPER_STATUS_UNREACHABLE
#define DISCONNECTED        IF_OPER_STATUS_DISCONNECTED
#define CONNECTING          IF_OPER_STATUS_CONNECTING
#define CONNECTED           IF_OPER_STATUS_CONNECTED
#define OPERATIONAL         IF_OPER_STATUS_OPERATIONAL

//
// Control blocks for all Routing Protocols
//

#pragma warning(disable:4201)

typedef struct _PROTO_CB
{
    LIST_ENTRY                  leList;  
    ProtocolOperationalState    posOpState;     
    PWCHAR                      pwszDllName;     
    PWCHAR                      pwszDisplayName; 
    HINSTANCE                   hiHInstance;    
    MPR_ROUTING_CHARACTERISTICS;

}PROTO_CB, *PPROTO_CB;

#pragma warning(default:4201)

typedef struct _IF_PROTO
{
    LIST_ENTRY  leIfProtoLink;
    BOOL        bPromiscuous;
    PPROTO_CB   pActiveProto;
}IF_PROTO, *PIF_PROTO;

typedef struct _ICB_BINDING
{
    DWORD   dwAddress;
    DWORD   dwMask;
}ICB_BINDING, *PICB_BINDING;

typedef struct _GATEWAY_INFO
{
    DWORD   dwAddress;
    DWORD   dwIfIndex;
    DWORD   dwMetric;
}GATEWAY_INFO, *PGATEWAY_INFO;

#define MAX_DEFG    5

//
// Interface Control Block
//

typedef struct _ICB 
{
    //
    // Link into the doubly linked list of all interfaces
    //

    LIST_ENTRY              leIfLink;
    
    //
    // The interface index
    //

    DWORD                   dwIfIndex; 

    //
    // Link into the doubly linked list of interfaces hashed of the index
    //

    LIST_ENTRY              leHashLink;

    //
    // Link into doubly linked list of interfaces hashed on ICB seq. number
    //

    LIST_ENTRY              leICBHashLink;
    
    //
    // List of all the protocols on which the interface is added
    // (IF_PROTO structures)
    //

    LIST_ENTRY              leProtocolList;

    //
    // Pointer to interface name. The storage for the name is after the ICB
    //

    PWCHAR                  pwszName;

    //
    // Pointer to device name
    // Only used for internal interfaces
    //

    PWCHAR                  pwszDeviceName;

    DWORD                   dwSeqNumber;

    //
    // Handle from PfCreateInterface. Set to INVALID_HANDLE_VALUE if 
    // the interface was not/could not be created
    //

    INTERFACE_HANDLE        ihFilterInterface;
    INTERFACE_HANDLE        ihDemandFilterInterface;

    //
    // The filter info. We keep this here, because we dont have
    // a GET call from the filter driver
    //

    PFILTER_DESCRIPTOR      pInFilter;
    PFILTER_DESCRIPTOR      pOutFilter;
    PFILTER_DESCRIPTOR      pDemandFilter;

    BOOL                    bFragCheckEnable;

    //
    // Set to true when we are restoring routes
    //

    BOOL                    bRestoringRoutes;

    //
    // Type of the interface
    //

    ROUTER_INTERFACE_TYPE   ritType;
    NET_INTERFACE_TYPE      nitProtocolType;
    DWORD                   dwMediaType;
    WORD                    wAccessType;
    WORD                    wConnectionType;

    //
    // Operational and admin states
    //

    DWORD                   dwOperationalState;
    DWORD                   dwAdminState;

    //
    // Mcast state
    //

    BOOL                    bMcastEnabled;

    //
    // State of the connection
    //

    DWORD                   fConnectionFlags;

    //
    // DIM's handle for this interface
    //

    HANDLE                  hDIMHandle;

    //
    // Event to be signalled to inform DIM that an UpdateRoutes is completed.
    // A non NULL value => UpdateRoutes in progress
    //

    HANDLE                  hDIMNotificationEvent;

    //
    // The list of results
    //

    LIST_ENTRY              lePendingResultList;

    //
    // The router discovery information for this interface
    //

    ROUTER_DISC_CB          rdcRtrDiscInfo;

    //
    // Pointer to the advertisement. The memory for this is allocated from
    // the IPRouterHeap
    //

    PICMP_ROUTER_ADVT_MSG   pRtrDiscAdvt;
    WSABUF                  wsAdvtWSABuffer;
    DWORD                   dwRtrDiscAdvtSize;

    //
    // IP in IP config
    //

    PIPINIP_CONFIG_INFO     pIpIpInfo;

    // 
    // The TTL scope for multicasts
    //

    DWORD                   dwMcastTtl;

    //
    // The rate limit for multicast traffic.
    //

    DWORD                   dwMcastRateLimit;

    //
    // The multicast heartbeat info
    //

    MCAST_HBEAT_CB          mhcHeartbeatInfo;

    //
    // For clients only
    //

    PINTERFACE_ROUTE_TABLE  pStoredRoutes;

    //
    // Stuff for IPAddressTable
    //

    //
    // Indicates whether the interface is bound or not
    //

    BOOL                    bBound;

    //
    // Set to true if we bumped up metric
    //

    BOOL                    bChangedMetrics;
    
    //
    // The rest of the fields are valid only if an interface is
    // bound
    //

    //DWORD                   dwAdapterId;
    DWORD                   dwBCastBit;
    DWORD                   dwReassemblySize;
    ULONG                   ulMtu;
    ULONGLONG               ullSpeed;

    DWORD                   dwGatewayCount;
   
    GATEWAY_INFO            Gateways[MAX_DEFG];

    //
    // dwNumAddresses may be 0 even if the interface is bound. This happens
    // when the interface is in unnumbered mode
    //

    DWORD                   dwNumAddresses;
    DWORD                   dwRemoteAddress;

    PICB_BINDING            pibBindings;

}ICB, *PICB;

//
// An adapter info is an alternate store for the binding info kept in 
// the ICB to avoid some deadlock conditions
// Even if this belongs to an unnumbered interface, we still have space
// for one ICB_BINDING, iow the minimum size is SIZEOF_ADAPTER_INFO(1)
// 

typedef struct _ADAPTER_INFO
{
    LIST_ENTRY              leHashLink;
    BOOL                    bBound;
    DWORD                   dwIfIndex;
    PICB                    pInterfaceCB;
    ROUTER_INTERFACE_TYPE   ritType;
    DWORD                   dwNumAddresses;
    DWORD                   dwRemoteAddress;
    DWORD                   dwBCastBit;
    DWORD                   dwReassemblySize;
    DWORD                   dwSeqNumber;
    
#if STATIC_RT_DBG
    BOOL        bUnreach;
#endif

    ICB_BINDING             rgibBinding[1];
}ADAPTER_INFO, *PADAPTER_INFO;

#define SIZEOF_ADAPTER_INFO(X)            \
    (FIELD_OFFSET(ADAPTER_INFO,rgibBinding[0]) + ((X) * sizeof(ICB_BINDING)))

#define NDISWAN_NOTIFICATION_RECEIVED   0x00000001
#define DDM_NOTIFICATION_RECEIVED       0x00000002
#define ALL_NOTIFICATIONS_RECEIVED      (NDISWAN_NOTIFICATION_RECEIVED | DDM_NOTIFICATION_RECEIVED)

#define INTERFACE_MARKED_FOR_DELETION   0x00000004

#define HasNdiswanNoticationBeenReceived(picb)  \
    ((picb)->fConnectionFlags & NDISWAN_NOTIFICATION_RECEIVED)

#define HasDDMNotificationBeenReceived(picb)    \
    ((picb)->fConnectionFlags & DDM_NOTIFICATION_RECEIVED)

#define IsInterfaceMarkedForDeletion(picb)      \
    ((picb)->fConnectionFlags & INTERFACE_MARKED_FOR_DELETION)

#define HaveAllNotificationsBeenReceived(picb)  \
    (((picb)->fConnectionFlags & ALL_NOTIFICATIONS_RECEIVED) == ALL_NOTIFICATIONS_RECEIVED)


#define ClearNotificationFlags(picb) ((picb)->fConnectionFlags = 0x00000000)

#define SetNdiswanNotification(picb)            \
    ((picb)->fConnectionFlags |= NDISWAN_NOTIFICATION_RECEIVED)

#define SetDDMNotification(picb)                \
    ((picb)->fConnectionFlags |= DDM_NOTIFICATION_RECEIVED)

#define MarkInterfaceForDeletion(picb)          \
    ((picb)->fConnectionFlags |= INTERFACE_MARKED_FOR_DELETION)

//
// List of NETMGMT routes that need to be restored to the stack
//

typedef struct _ROUTE_LIST_ENTRY
{
    LIST_ENTRY          leRouteList;
    MIB_IPFORWARDROW    mibRoute;
} ROUTE_LIST_ENTRY, *PROUTE_LIST_ENTRY;

//
// List of update route results
//

typedef struct _UpdateResultList 
{
    LIST_ENTRY      URL_List;
    DWORD           URL_UpdateStatus;
}UpdateResultList, *pUpdateResultList;

/*
typedef struct _ADAPTER_MAP
{
  LIST_ENTRY  leHashLink;
  DWORD       dwAdapterId;
  DWORD       dwIfIndex;
}ADAPTER_MAP, *PADAPTER_MAP;
*/

typedef struct _IP_CACHE
{
  PMIB_IPADDRTABLE      pAddrTable;
  PMIB_IPFORWARDTABLE   pForwardTable;
  PMIB_IPNETTABLE       pNetTable;
  DWORD                 dwTotalAddrEntries;
  DWORD                 dwTotalForwardEntries;
  DWORD                 dwTotalNetEntries;
}IP_CACHE, *PIP_CACHE;

typedef struct _TCP_CACHE
{
  PMIB_TCPTABLE         pTcpTable;
  DWORD                 dwTotalEntries;
}TCP_CACHE, *PTCP_CACHE;

typedef struct _UDP_CACHE
{
  PMIB_UDPTABLE         pUdpTable;
  DWORD                 dwTotalEntries;
}UDP_CACHE, *PUDP_CACHE;


DWORD
AddInterface(
    IN      LPWSTR lpwsInterfaceName,
    IN      LPVOID pInterfaceInfo,
    IN      ROUTER_INTERFACE_TYPE InterfaceType,
    IN      HANDLE hDIMInterface,
    IN OUT  HANDLE *phInterface
    );

DWORD
RouterBootComplete( 
    VOID
    );

DWORD
StopRouter(
    VOID
    );

DWORD
DeleteInterface(
    IN  HANDLE   hInterface
    );

DWORD
GetInterfaceInfo(
    IN      HANDLE  hInterface,
    OUT     LPVOID  pInterfaceInfo,
    IN OUT  LPDWORD lpdwInterfaceInfoSize
    );

DWORD
SetInterfaceInfo(
    IN  HANDLE  hInterface,
    IN  LPVOID  pInterfaceInfo
    );
                 
DWORD
InterfaceNotReachable(
    IN  HANDLE                  hInterface,
    IN  UNREACHABILITY_REASON   Reason
    );
                      
DWORD
InterfaceReachable(
    IN  HANDLE  hInterface
    );

DWORD
InterfaceConnected(
    IN   HANDLE  hInterface,
    IN   PVOID   pFilter,
    IN   PVOID   pPppProjectionResult
    );
                                         
DWORD 
UpdateRoutes(
    IN HANDLE hInterface, 
    IN HANDLE hEvent
    );

DWORD 
GetUpdateRoutesResult(
    IN HANDLE hInterface, 
    OUT LPDWORD pUpdateResult
    );

DWORD
SetGlobalInfo(
    IN  LPVOID  pGlobalInfo
    );
 
DWORD
GetGlobalInfo(
    OUT    LPVOID    pGlobalInfo,
    IN OUT LPDWORD   lpdwGlobalInfoSize
    );
             
DWORD
DemandDialRequest(
    IN DWORD dwProtocolId,
    IN DWORD dwInterfaceIndex
    );

DWORD 
RtrMgrMIBEntryCreate(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );
                     

DWORD 
RtrMgrMIBEntryDelete(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );
                     
DWORD 
RtrMgrMIBEntryGet(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );
                        
DWORD 
RtrMgrMIBEntryGetFirst(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );
                       
DWORD 
RtrMgrMIBEntryGetNext(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwInEntrySize,
    IN      LPVOID          lpInEntry,
    IN OUT  LPDWORD         lpOutEntrySize,
    OUT     LPVOID          lpOutEntry
    );

DWORD 
RtrMgrMIBEntrySet(
    IN      DWORD           dwRoutingPid,
    IN      DWORD           dwEntrySize,
    IN      LPVOID          lpEntry
    );


#endif // __RTRMGR_IPRTRMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\load.c ===
/*++
Copyright (c) 1995  Microsoft Corporation


Module Name:

    routing\ip\load.c

Abstract:
    	
    The Load functions load the appropriate caches. They all follow a
    somewhat similar algorithm. They figure out how much space is needed
    for the cache. If there is a need to allocate memory, that is done.
    Then they read the tables from stack or RTM. They keep track of the
    space in the cache as the dwTotalEntries and the actual number of
    entries as the dwValidEntries

Revision History:

    Amritansh Raghav	      7/8/95  Created

--*/

#include "allinc.h"



int
__cdecl
CompareIpAddrRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    int iRes;

    PMIB_IPADDRROW  pRow1 = (PMIB_IPADDRROW)pvElem1;
    PMIB_IPADDRROW  pRow2 = (PMIB_IPADDRROW)pvElem2;

    InetCmp(pRow1->dwAddr,
            pRow2->dwAddr,
            iRes);

    return iRes;
}

int
__cdecl
CompareIpForwardRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;

    PMIB_IPFORWARDROW   pRow1 = (PMIB_IPFORWARDROW)pvElem1;
    PMIB_IPFORWARDROW   pRow2 = (PMIB_IPFORWARDROW)pvElem2;

    if(InetCmp(pRow1->dwForwardDest,
               pRow2->dwForwardDest,
               lResult) isnot 0)
    {
        return lResult;
    }

    if(Cmp(pRow1->dwForwardProto,
           pRow2->dwForwardProto,
           lResult) isnot 0)
    {
        return lResult;
    }

    if(Cmp(pRow1->dwForwardPolicy,
           pRow2->dwForwardPolicy,
           lResult) isnot 0)
    {
        return lResult;
    }

    return InetCmp(pRow1->dwForwardNextHop,
                   pRow2->dwForwardNextHop,
                   lResult);
}

int
__cdecl
CompareIpNetRow(
    CONST VOID *pvElem1,
    CONST VOID *pvElem2
    )
{
    LONG lResult;

    PMIB_IPNETROW   pRow1 = (PMIB_IPNETROW)pvElem1;
    PMIB_IPNETROW   pRow2 = (PMIB_IPNETROW)pvElem2;

    if(Cmp(pRow1->dwIndex,
           pRow2->dwIndex,
           lResult) isnot 0)
    {
        return lResult;
    }
    else
    {
        return InetCmp(pRow1->dwAddr,
                       pRow2->dwAddr,
                       lResult);
    }
}

//
// Since all these are called from within UpdateCache, the appropriate
// lock is already being held as a writer so dont try and grab locks here
//

DWORD
LoadUdpTable(
    VOID
    )
/*++

Routine Description

    Loads the UDP cache from the stack

Locks

    UDP Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    DWORD       dwResult;
    ULONG       ulRowsPresent,ulRowsNeeded;

    MIB_UDPSTATS    usInfo;

    dwResult = GetUdpStatsFromStack(&usInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadUdpTable: Error %d trying to to determine table size",
               dwResult);

        TraceLeave("LoadUdpTable");

        return dwResult;
    }

    ulRowsNeeded  = usInfo.dwNumAddrs + SPILLOVER;
    ulRowsPresent = g_UdpInfo.dwTotalEntries;

    if((ulRowsNeeded > ulRowsPresent) or
       (ulRowsPresent - ulRowsNeeded > MAX_DIFF))
    {
        //
        // Need to allocate space
        //

        if(g_UdpInfo.pUdpTable)
        {
            HeapFree(g_hUdpHeap,
                     HEAP_NO_SERIALIZE,
                     g_UdpInfo.pUdpTable);
        }

        ulRowsPresent = ulRowsNeeded + MAX_DIFF;

        g_UdpInfo.pUdpTable = HeapAlloc(g_hUdpHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_UDPTABLE(ulRowsPresent));

        if(g_UdpInfo.pUdpTable is NULL)
        {
            Trace1(ERR,
                   "LoadUdpTable: Error allocating %d bytes for Udp table",
                   SIZEOF_UDPTABLE(ulRowsPresent));

            g_UdpInfo.dwTotalEntries = 0;

            TraceLeave("LoadUdpTable");

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_UdpInfo.dwTotalEntries = ulRowsPresent;
    }

    dwResult = GetUdpTableFromStack(g_UdpInfo.pUdpTable,
                                    SIZEOF_UDPTABLE(ulRowsPresent),
                                    TRUE);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadUdpTable: NtStatus %x getting UdpTable from stack",
               dwResult);

        g_UdpInfo.pUdpTable->dwNumEntries = 0;
    }


    return dwResult;
}

DWORD
LoadTcpTable(
    VOID
    )
/*++

Routine Description

    Loads the TCP cache from the stack

Locks

    TCP Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    DWORD       dwResult;
    ULONG       ulRowsPresent,ulRowsNeeded;

    MIB_TCPSTATS    tsInfo;

    dwResult = GetTcpStatsFromStack(&tsInfo);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadTcpTable: Error %d trying to determince table size",
                dwResult);

        TraceLeave("LoadTcpTable");

        return dwResult;
    }

    ulRowsNeeded    = tsInfo.dwNumConns + SPILLOVER;
    ulRowsPresent   = g_TcpInfo.dwTotalEntries;

    if((ulRowsNeeded > ulRowsPresent) or
       (ulRowsPresent - ulRowsNeeded > MAX_DIFF))
    {
        if(g_TcpInfo.pTcpTable)
        {	
            HeapFree(g_hTcpHeap,
                     HEAP_NO_SERIALIZE,
                     g_TcpInfo.pTcpTable);
        }

        ulRowsPresent       = ulRowsNeeded + MAX_DIFF;

        g_TcpInfo.pTcpTable = HeapAlloc(g_hTcpHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_TCPTABLE(ulRowsPresent));

        if(g_TcpInfo.pTcpTable is NULL)
        {
            Trace1(ERR,
                   "LoadTcpTable: Error allocating %d bytes for tcp table",
                   SIZEOF_TCPTABLE(ulRowsPresent));

            g_TcpInfo.dwTotalEntries = 0;

            TraceLeave("LoadTcpTable");

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_TcpInfo.dwTotalEntries = ulRowsPresent;
    }

    dwResult = GetTcpTableFromStack(g_TcpInfo.pTcpTable,
                                    SIZEOF_TCPTABLE(ulRowsPresent),
                                    TRUE);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadTcpTable: NtStatus %x load TcpTable from stack",
               dwResult);

        g_TcpInfo.pTcpTable->dwNumEntries = 0;
    }


    return dwResult;
}

DWORD
LoadIpAddrTable(
    VOID
    )
/*++

Routine Description

    Loads the IPAddress cache. Unlike the other functions, this cache is
    loaded from the BINDING list kept in user mode. The binding list is
    however kept in a hash table (with no thread linking all the addresses
    in lexicographic order).  Thus we just copy out all the address and then
    run qsort() over them

Locks

    The IP Address Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    ULONG       ulRowsPresent,ulRowsNeeded;
    DWORD       dwIndex, i, j;

    PLIST_ENTRY     pleNode;
    PADAPTER_INFO   pBind;


    ENTER_READER(BINDING_LIST);

    ulRowsNeeded  = g_ulNumBindings + SPILLOVER;
    ulRowsPresent = g_IpInfo.dwTotalAddrEntries;

    if((ulRowsNeeded > ulRowsPresent) or
       (ulRowsPresent - ulRowsNeeded > MAX_DIFF))
    {
        if(g_IpInfo.pAddrTable)
        {
            HeapFree(g_hIpAddrHeap,
                     HEAP_NO_SERIALIZE,
                     g_IpInfo.pAddrTable);
        }

        ulRowsPresent       = ulRowsNeeded + MAX_DIFF;

        g_IpInfo.pAddrTable = HeapAlloc(g_hIpAddrHeap,
                                        HEAP_NO_SERIALIZE,
                                        SIZEOF_IPADDRTABLE(ulRowsPresent));

        if(g_IpInfo.pAddrTable is NULL)
        {
            EXIT_LOCK(ICB_LIST);


            Trace1(ERR,
                   "LoadIpAddrTable: Error allocating %d bytes for table",
                   SIZEOF_IPADDRTABLE(ulRowsPresent));

            g_IpInfo.dwTotalAddrEntries = 0;

            TraceLeave("LoadIpAddrTable");

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_IpInfo.dwTotalAddrEntries = ulRowsPresent;
    }

    dwIndex = 0;

    for(i = 0;
        i < BINDING_HASH_TABLE_SIZE;
        i++)
    {
        for(pleNode = g_leBindingTable[i].Flink;
            pleNode isnot &g_leBindingTable[i];
            pleNode = pleNode->Flink)
        {
            pBind = CONTAINING_RECORD(pleNode,
                                      ADAPTER_INFO,
                                      leHashLink);

            if(!pBind->bBound)
            {
                continue;
            }

            //
            // If the nte is bound, but has no address, we still have
            // space for 1 address
            //

            for(j = 0;
                j < (pBind->dwNumAddresses? pBind->dwNumAddresses : 1);
                j++)
            {
                g_IpInfo.pAddrTable->table[dwIndex].dwIndex     =
                    pBind->dwIfIndex;

                g_IpInfo.pAddrTable->table[dwIndex].dwBCastAddr =
                    pBind->dwBCastBit;

                g_IpInfo.pAddrTable->table[dwIndex].dwReasmSize =
                    pBind->dwReassemblySize;

                g_IpInfo.pAddrTable->table[dwIndex].dwAddr      =
                    pBind->rgibBinding[j].dwAddress;

                g_IpInfo.pAddrTable->table[dwIndex].dwMask      =
                    pBind->rgibBinding[j].dwMask;

                g_IpInfo.pAddrTable->table[dwIndex].wType     = 1;

                dwIndex++;
            }
        }
    }

    g_IpInfo.pAddrTable->dwNumEntries = dwIndex;

    EXIT_LOCK(BINDING_LIST);

    if(g_IpInfo.pAddrTable->dwNumEntries > 0)
    {
        qsort(g_IpInfo.pAddrTable->table,
              dwIndex,
              sizeof(MIB_IPADDRROW),
              CompareIpAddrRow);
    }

    return NO_ERROR;
}

DWORD
LoadIpForwardTable(
    VOID
    )
/*++

Routine Description

    Loads the UDP cache from the stack

Locks

    UDP Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    HANDLE            hRtmEnum;
    PHANDLE           hRoutes;
    PRTM_NET_ADDRESS  pDestAddr;
    PRTM_ROUTE_INFO   pRoute;
    RTM_NEXTHOP_INFO  nhiInfo;
    RTM_ENTITY_INFO   entityInfo;
    DWORD             dwCount;
    DWORD             dwResult;
    DWORD             dwRoutes;
    DWORD             i,j;
    IPSNMPInfo        ipsiInfo;
    ULONG             ulRowsPresent,ulRowsNeeded;
    ULONG             ulEntities;
    RTM_ADDRESS_FAMILY_INFO rtmAddrFamilyInfo;

    //
    // Get the number of destinations in the RTM's table
    //

    dwResult = RtmGetAddressFamilyInfo(0, // routerId
                                       AF_INET,
                                       &rtmAddrFamilyInfo,
                                       &ulEntities,
                                       NULL);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadIpForwardTable: Error %d getting number of destinations",
               dwResult);

        return dwResult;
    }

    //
    // Use an enumeration to retrieve routes from RTM
    //

    dwResult = RtmCreateRouteEnum(g_hLocalRoute,
                                  NULL,
                                  RTM_VIEW_MASK_UCAST,
                                  RTM_ENUM_ALL_ROUTES,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &hRtmEnum);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "LoadIpForwardTable: Error %d creating RTM enumeration handle",
               dwResult);

        return dwResult;
    }

    ulRowsNeeded  = rtmAddrFamilyInfo.NumDests + SPILLOVER;
    ulRowsPresent = g_IpInfo.dwTotalForwardEntries;

    if((ulRowsNeeded > ulRowsPresent) or
       (ulRowsPresent - ulRowsNeeded > MAX_DIFF))
    {
        if(g_IpInfo.pForwardTable)
        {
            HeapFree(g_hIpForwardHeap,
                     HEAP_NO_SERIALIZE,
                     g_IpInfo.pForwardTable);
        }

        ulRowsPresent = ulRowsNeeded + MAX_DIFF;

        g_IpInfo.pForwardTable = HeapAlloc(g_hIpForwardHeap,
                                           HEAP_NO_SERIALIZE,
                                           SIZEOF_IPFORWARDTABLE(ulRowsPresent));

        if(g_IpInfo.pForwardTable is NULL)
        {
            Trace1(ERR,
                   "LoadIpForwardTable: Error allocating %d bytes for forward table",
                   SIZEOF_IPFORWARDTABLE(ulRowsPresent));

            g_IpInfo.dwTotalForwardEntries = 0;

            RtmDeleteEnumHandle(g_hLocalRoute, hRtmEnum);

            TraceLeave("LoadIpForwardTable");

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_IpInfo.dwTotalForwardEntries = ulRowsPresent;
    }

    //
    // Routes are enum'ed from the RTM route table
    //

    pRoute = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if (pRoute == NULL)
    {
        TraceLeave("LoadIpForwardTable");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pDestAddr = HeapAlloc(
                IPRouterHeap,
                0,
                sizeof(RTM_NET_ADDRESS)
                );

    if (pDestAddr == NULL)
    {
        TraceLeave("LoadIpForwardTable");

        HeapFree(IPRouterHeap, 0, pRoute);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        TraceLeave("LoadIpForwardTable");

        HeapFree(IPRouterHeap, 0, pRoute);
        
        HeapFree(IPRouterHeap, 0, pDestAddr);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwCount = 0;

    do
    {
        // Get next set of routes in RTM table

        dwRoutes = g_rtmProfile.MaxHandlesInEnum;

        RtmGetEnumRoutes(g_hLocalRoute,
                         hRtmEnum,
                         &dwRoutes,
                         hRoutes);

        for (i = 0; i < dwRoutes; i++)
        {
            // Get the route info given the route handle

            dwResult = RtmGetRouteInfo(g_hLocalRoute,
                                       hRoutes[i],
                                       pRoute,
                                       pDestAddr);

            // Route would have got deleted meanwhile

            if (dwResult isnot NO_ERROR)
            {
                continue;
            }

            // Process info for the route from above

            // This route with multiple next hops
            // might end up as multiple ip routes
            if(dwCount + pRoute->NextHopsList.NumNextHops
                    > g_IpInfo.dwTotalForwardEntries)
            {
                //
                // Hmm - we accounted for spillover and still have extra routes
                // Lets double the route table
                //

                g_IpInfo.dwTotalForwardEntries =
                    (g_IpInfo.dwTotalForwardEntries)<<1;

                // Are we still short in terms of number of routes required ?
                if (g_IpInfo.dwTotalForwardEntries <
                        dwCount + pRoute->NextHopsList.NumNextHops)
                {
                    g_IpInfo.dwTotalForwardEntries =
                        dwCount + pRoute->NextHopsList.NumNextHops;
                }

                g_IpInfo.pForwardTable =
                    HeapReAlloc(g_hIpForwardHeap,
                                HEAP_NO_SERIALIZE,
                                g_IpInfo.pForwardTable,
                                SIZEOF_IPFORWARDTABLE(g_IpInfo.dwTotalForwardEntries));

                if(g_IpInfo.pForwardTable is NULL)
                {
                    Trace1(ERR,
                           "LoadIpForwardTable: Error reallocating %d bytes for forward table",
                           SIZEOF_IPFORWARDTABLE(g_IpInfo.dwTotalForwardEntries));

                    g_IpInfo.dwTotalForwardEntries = 0;

                    RtmReleaseRouteInfo(g_hLocalRoute, pRoute);

                    RtmReleaseRoutes(g_hLocalRoute, dwRoutes, hRoutes);

                    RtmDeleteEnumHandle(g_hLocalRoute, hRtmEnum);

                    HeapFree(IPRouterHeap, 0, pRoute);
                    
                    HeapFree(IPRouterHeap, 0, pDestAddr);

                    HeapFree(IPRouterHeap, 0, hRoutes);

                    TraceLeave("LoadIpForwardTable");

                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            if (RtmGetEntityInfo(g_hLocalRoute,
                                 pRoute->RouteOwner,
                                 &entityInfo) is NO_ERROR)
            {
                // Try getting the nexthop information from the route

                for (j = 0; j < pRoute->NextHopsList.NumNextHops; j++)
                {
                    if (RtmGetNextHopInfo(g_hLocalRoute,
                                          pRoute->NextHopsList.NextHops[j],
                                          &nhiInfo) is NO_ERROR)
                    {
                        ConvertRtmToRouteInfo(entityInfo.EntityId.EntityProtocolId,
                                                 pDestAddr,
                                                 pRoute,
                                                 &nhiInfo,
                                                 (PINTERFACE_ROUTE_INFO)&(g_IpInfo.pForwardTable->table[dwCount++]));

                        RtmReleaseNextHopInfo(g_hLocalRoute, &nhiInfo);
                    }
                }
            }

            RtmReleaseRouteInfo(g_hLocalRoute, pRoute);
        }

        RtmReleaseRoutes(g_hLocalRoute, dwRoutes, hRoutes);
    }
    while (dwRoutes != 0);

    RtmDeleteEnumHandle(g_hLocalRoute, hRtmEnum);

    g_IpInfo.pForwardTable->dwNumEntries = dwCount;

    if(dwCount > 0)
    {
        qsort(g_IpInfo.pForwardTable->table,
              dwCount,
              sizeof(MIB_IPFORWARDROW),
              CompareIpForwardRow);
    }

    HeapFree(IPRouterHeap, 0, pRoute);
    
    HeapFree(IPRouterHeap, 0, pDestAddr);

    HeapFree(IPRouterHeap, 0, hRoutes);

    return NO_ERROR;
}


DWORD
LoadIpNetTable(
    VOID
    )
/*++

Routine Description

    Loads the UDP cache from the stack

Locks

    UDP Cache lock must be taken as writer

Arguments

    None

Return Value
    NO_ERROR

--*/

{
    DWORD		dwResult, i;
    BOOL		fUpdate;

    //
    // Arp entries change so fast that we deallocate the table
    // every time
    //

    if(g_IpInfo.pNetTable isnot NULL)
    {
        HeapFree(g_hIpNetHeap,
                 HEAP_NO_SERIALIZE,
                 g_IpInfo.pNetTable);
    }

    dwResult = AllocateAndGetIpNetTableFromStack(&(g_IpInfo.pNetTable),
                                                 FALSE,
                                                 g_hIpNetHeap,
                                                 HEAP_NO_SERIALIZE,
                                                 FALSE);
    if(dwResult is NO_ERROR)
    {
        Trace0(MIB,
               "LoadIpNetTable: Succesfully loaded net table");
    }
    else
    {
        HeapFree(g_hIpNetHeap,
                 HEAP_NO_SERIALIZE,
                 g_IpInfo.pNetTable);

        g_IpInfo.pNetTable  = NULL;

        Trace1(ERR,
               "LoadIpNetTable: NtStatus %x loading IpNetTable from stack",
               dwResult);
    }

    if((g_IpInfo.pNetTable isnot NULL) and
       (g_IpInfo.pNetTable->dwNumEntries > 0))
    {
        qsort(g_IpInfo.pNetTable->table,
              g_IpInfo.pNetTable->dwNumEntries,
              sizeof(MIB_IPNETROW),
              CompareIpNetRow);
    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\locate.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\locate.c

Abstract:

    The LocateXXXRow Functions are passed a variable sized array of 
    indices, a count of the number of indices passed and the type of search
    that needs to be executed. There are three types of searches:
    Locate the first item (ACCESS_GET_FIRST)
    Locate the next item  (ACCESS_GET_NEXT)
    Locate the exact item (ACCESS_GET, ACCESS_SET, ACCESS_CREATE_ENTRY
                           ACCESS_DELETE_ENTRY)

    The functions fill in the index of the corresponding row and return 

    NO_ERROR            if an item matching the indices and criterion was found
    ERROR_NO_DATA       if no item is found 
    ERROR_INVALID_INDEX
    ERROR_NO_MORE_ITEMS 

    The general search algorithm is this:

    If the table is empty
        return ERROR_NO_DATA
	
	If the query is a LOCATE_FIRST
	    return the first row
	
	Build the index as follows:

    Set the Index to all 0s
    From the number of indices passed  figure out how much of the index
    can be built keeping the rest 0.
    If the query is a LOCATE_EXACT then the complete index must be given.
    This check is, however, supposed to be done by the caller
    If the full index has not been given, the index is deemed to be
    modified (Again this can only happen in the LOCATE_NEXT case).
    Once the index is created, a search is done.
    We try for an exact match with the index. For all queries other than
    LOCATE_NEXT there is no problem.
    For LOCATE_NEXT there are two cases:

        If the complete index was given and we get an exact match, then we
        return the next entry.
        If we dont get an exact match we return the next higher entry
        If an incomplete index was given and we modified it by padding 0s, 
        and if an exact match is found, then we return the matching entry
        (Of course if an exact match is not found just return the next
        higher entry)

    ALL THESE FUNCTION ARE CALLED WITH THE LOCK OF THE RESPECTIVE CACHE
    HELD ATLEAST AS READER
    
Revision History:

    Amritansh Raghav          6/8/95  Created

--*/

#include "allinc.h"

#define LOCAL_ADDR  0
#define LOCAL_PORT  1
#define REM_ADDR    2
#define REM_PORT    3

	

DWORD  
LocateIfRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex, 
    ICB     **ppicb,
    BOOL    bNoClient 
    )
{
    PLIST_ENTRY currentList,startIndex,stopIndex ;
    DWORD       dwIndex = 0;
    BOOL        fNext, fModified;
    PICB        pIf;
    
    *ppicb = NULL;
    
    if(g_ulNumInterfaces is 0)
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }

    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        
        if(bNoClient)
        {
            for(currentList  = ICBList.Flink;
                currentList isnot &ICBList;
                currentList  = currentList->Flink)
            {
                //
                // Find the first one which is not internal loopback
                // or client
                //

                pIf = CONTAINING_RECORD (currentList, ICB, leIfLink);
                
                if(pIf->ritType is ROUTER_IF_TYPE_CLIENT)
                {
                    continue;
                }

                *ppicb = pIf;

                break;
            }
        }
        else
        {
            *ppicb = CONTAINING_RECORD(ICBList.Flink,
                                       ICB,
                                       leIfLink);
        }

        if(*ppicb)
        {
            return NO_ERROR;
        }
        else
        {
            return ERROR_NO_DATA;
        }
    }

    fModified = TRUE;
    
    if(dwNumIndices > 0)
    {
        dwIndex = pdwIndex[0];
        
        fModified = FALSE;
    }

    //
    // Should we take the match or the next entry in case of an exact match?
    //
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
    
    
    startIndex = ICBList.Flink;
    stopIndex  = &ICBList;
    
    for(currentList = startIndex;
        currentList isnot stopIndex;
        currentList = currentList->Flink)
    {
        *ppicb = CONTAINING_RECORD(currentList,
                                   ICB,
                                   leIfLink) ;

        if(bNoClient and
           ((*ppicb)->ritType is ROUTER_IF_TYPE_CLIENT))
        {
            //
            // Go to the next one
            //

            continue;
        }
        
        if((dwIndex is (*ppicb)->dwIfIndex) and !fNext)
        {
            //
            // Found it
            //

            return NO_ERROR;
        }
        
        if(dwIndex < (*ppicb)->dwIfIndex)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                return NO_ERROR;
            }
            else
            {
                //
                // Since the list is ordered we wont find this index further on
                //

                *ppicb = NULL;
                
                return ERROR_INVALID_INDEX;
            }
        }
    }

    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateIpAddrRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex, 
    PDWORD  pdwRetIndex
    )
{
    DWORD dwIpAddr;
    DWORD dwResult, startIndex, stopIndex;
    LONG  lCompare;
    DWORD i;
    BOOL  fNext, fModified;
    
    if((g_IpInfo.pAddrTable is NULL) or
       (g_IpInfo.pAddrTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }
       
        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
    if(dwNumIndices > 0)
    {
        dwIpAddr = pdwIndex[0];
        
        fModified = FALSE;
    }
    else
    {
        dwIpAddr = 0;
        
        fModified = TRUE;
    }
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
  
    startIndex = 0;
    stopIndex  = g_IpInfo.pAddrTable->dwNumEntries;
    
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare = InetCmp(dwIpAddr,
                           g_IpInfo.pAddrTable->table[i].dwAddr,
                           lCompare);
        
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
        
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    }

    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateIpForwardRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex, 
    PDWORD  pdwRetIndex
    )
{
    DWORD rgdwIpForwardIndex[4];
    DWORD dwResult,startIndex, stopIndex;
    LONG  lCompare;
    DWORD i;
    BOOL  fNext,fModified;
    
    if((g_IpInfo.pForwardTable is NULL) or
       (g_IpInfo.pForwardTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
    // Quick way to copy the valid part of index
    // TBD: just might want to asssert the sizes
    
    ZeroMemory(rgdwIpForwardIndex,
               4*sizeof(DWORD));
    
    memcpy(rgdwIpForwardIndex,
           pdwIndex,
           dwNumIndices * sizeof(DWORD));

    //
    // We have modified it if the index is not the exact size
    //
    
    if(dwNumIndices isnot 4)
    {
        fModified = TRUE;
    }
    else
    {
        fModified = FALSE;
    }
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
    
    startIndex = 0;
    stopIndex  = g_IpInfo.pForwardTable->dwNumEntries;
  
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare =
            IpForwardCmp(rgdwIpForwardIndex[0],
                         rgdwIpForwardIndex[1],
                         rgdwIpForwardIndex[2],
                         rgdwIpForwardIndex[3],
                         g_IpInfo.pForwardTable->table[i].dwForwardDest,
                         g_IpInfo.pForwardTable->table[i].dwForwardProto,
                         g_IpInfo.pForwardTable->table[i].dwForwardPolicy,
                         g_IpInfo.pForwardTable->table[i].dwForwardNextHop);
        
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
        
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    }
    
    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateIpNetRow(
    DWORD dwQueryType, 
    DWORD dwNumIndices,
    PDWORD  pdwIndex, 
    PDWORD  pdwRetIndex
    )
{
    DWORD dwResult,i;
    LONG  lCompare;
    DWORD dwIpNetIfIndex,dwIpNetIpAddr;
    BOOL  fNext, fModified;
    DWORD startIndex,stopIndex;
    
    if((g_IpInfo.pNetTable is NULL) or
       (g_IpInfo.pNetTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
	

    switch(dwNumIndices)
    {
        case 0:
        {
            dwIpNetIfIndex = 0;
            dwIpNetIpAddr  = 0;
            
            fModified = TRUE;
            
            break;
        }
        
        case 1:
        {
            dwIpNetIfIndex = pdwIndex[0];
            
            dwIpNetIpAddr  = 0;
            
            fModified = TRUE;
            
            break;
        }
        
        case 2:
        {
            dwIpNetIfIndex = pdwIndex[0];
            
            dwIpNetIpAddr  = pdwIndex[1];
            
            fModified = FALSE;
            
            break;
        }
        
        default:
        {
            return ERROR_INVALID_INDEX;
        }
    }
    
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
	
    startIndex  = 0;
    stopIndex   = g_IpInfo.pNetTable->dwNumEntries;
    
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare = IpNetCmp(dwIpNetIfIndex,
                            dwIpNetIpAddr, 
                            g_IpInfo.pNetTable->table[i].dwIndex,
                            g_IpInfo.pNetTable->table[i].dwAddr);
    
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
        
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    }
    
    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateUdpRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    )
{
    DWORD   i;
    LONG    lCompare;
    DWORD   rgdwLocal[2];
    BOOL    fNext, fModified;
    DWORD   startIndex, stopIndex;
    
    if((g_UdpInfo.pUdpTable is NULL) or
       (g_UdpInfo.pUdpTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
    rgdwLocal[0] = 0;
    rgdwLocal[1] = 0;
    
    fModified = TRUE;
    
    switch(dwNumIndices)
    {
        case 0:
        {
            break;
        }
        case 1:
        {
            rgdwLocal[LOCAL_ADDR] = pdwIndex[0];
            
            break;
        }
        case 2:
        {
            fModified = FALSE;
            
            rgdwLocal[LOCAL_ADDR] = pdwIndex[0];
            rgdwLocal[LOCAL_PORT] = pdwIndex[1];
            
            break;
        }
    }
  
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
    
    startIndex  = 0;
    stopIndex   = g_UdpInfo.pUdpTable->dwNumEntries;
    
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare = UdpCmp(rgdwLocal[LOCAL_ADDR],
                          rgdwLocal[LOCAL_PORT],
                          g_UdpInfo.pUdpTable->table[i].dwLocalAddr,
                          g_UdpInfo.pUdpTable->table[i].dwLocalPort);
        
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
        
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    } 
  
    return ERROR_NO_MORE_ITEMS;
}

DWORD 
LocateTcpRow(
    DWORD   dwQueryType, 
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    )
{
    LONG    lCompare;
    DWORD   rgdwAddr[4];
    BOOL    fNext, fModified;
    DWORD   startIndex, stopIndex,i;
	
    if((g_TcpInfo.pTcpTable is NULL) or
       (g_TcpInfo.pTcpTable->dwNumEntries is 0))
    {
        if(EXACT_MATCH(dwQueryType))
        {
            return ERROR_INVALID_INDEX;
        }

        if(dwQueryType is ACCESS_GET_FIRST)
        {
            return ERROR_NO_DATA;
        }

        return ERROR_NO_MORE_ITEMS;
    }
    
    if(dwQueryType is ACCESS_GET_FIRST)
    {
        *pdwRetIndex = 0;
        
        return NO_ERROR;
    }
    
    //
    // Quick way to copy the valid part of index
    // BUG might want to asssert the sizes
    //
    
    ZeroMemory(rgdwAddr,
               4*sizeof(DWORD));
    
    memcpy(rgdwAddr,
           pdwIndex,
           dwNumIndices * sizeof(DWORD));

    //
    // We have modified it if the index is not the exact size
    //
    
    if(dwNumIndices isnot 4)
    {
        fModified = TRUE;
    }
    else
    {
        fModified = FALSE;
    }
    
    fNext = (dwQueryType is ACCESS_GET_NEXT) and (fModified is FALSE);
    
    startIndex  = 0;
    stopIndex   = g_TcpInfo.pTcpTable->dwNumEntries;
    
    for(i = startIndex; i < stopIndex; i++)
    {
        lCompare = TcpCmp(rgdwAddr[LOCAL_ADDR],
                          rgdwAddr[LOCAL_PORT],
                          rgdwAddr[REM_ADDR],
                          rgdwAddr[REM_PORT],
                          g_TcpInfo.pTcpTable->table[i].dwLocalAddr,
                          g_TcpInfo.pTcpTable->table[i].dwLocalPort,
                          g_TcpInfo.pTcpTable->table[i].dwRemoteAddr,
                          g_TcpInfo.pTcpTable->table[i].dwRemotePort);
        
        if((lCompare is 0) and !fNext)
        {
            *pdwRetIndex = i;
            
            return NO_ERROR;
        }
	
        if(lCompare < 0)
        {
            if(dwQueryType is ACCESS_GET_NEXT)
            {
                *pdwRetIndex = i;
                
                return NO_ERROR;
            }
            else
            {
                return ERROR_INVALID_INDEX;
            }
        }
    }
    
    return ERROR_NO_MORE_ITEMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\logtrdef.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routign\ip\rtrmgr\logtrdefs.c

Abstract:

    IP Router Manager defines for tracing and logging

Revision History:

    Gurdeep Singh Pall          6/16/95  Created

--*/

#ifndef __LOGTRDEF_H__
#define __LOGTRDEF_H__

//
// constants and macros used for tracing
//

#define IPRTRMGR_TRACE_ANY              ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_ERR              ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_ENTER            ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_IF               ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_ROUTE            ((DWORD)0x00080000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_MIB              ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_GLOBAL           ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_DEMAND           ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_RTRDISC          ((DWORD)0x00800000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_LOCK             ((DWORD)0x01000000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_MCAST            ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_MZAP             ((DWORD)0x04000000 | TRACE_USE_MASK)
#define IPRTRMGR_TRACE_INIT             ((DWORD)0x08000000 | TRACE_USE_MASK)


#define TRACEID         TraceHandle


#define Trace0(l,a)             \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g) \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d, e, f, g)
#define Trace7(l,a,b,c,d,e,f,g,h) \
            TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ ## l, a, b, c, d, e, f, g, h)

#if TRACE_DBG

#define TraceEnter(X)   TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ENTER, "Entered: "X)
#define TraceLeave(X)   TracePrintfEx(TRACEID, IPRTRMGR_TRACE_ENTER, "Leaving: "X"\n")

#define TraceRoute0     Trace0
#define TraceRoute1     Trace1
#define TraceRoute2     Trace2
#define TraceRoute3     Trace3
#define TraceRoute4     Trace4
#define TraceRoute5     Trace5

#else   // TRACE_DBG

#define TraceEnter(X)
#define TraceLeave(X)

#define TraceRoute0(l,a)
#define TraceRoute1(l,a,b)
#define TraceRoute2(l,a,b,c)
#define TraceRoute3(l,a,b,c,d)
#define TraceRoute4(l,a,b,c,d,e)
#define TraceRoute5(l,a,b,c,d,e,f)

#endif // TRACE_DBG


//
// Event logging macros
//

#define LOGLEVEL        g_dwLoggingLevel
#define LOGHANDLE       g_hLogHandle

#define LOGERR          RouterLogError
#define LOGERRW         RouterLogErrorW
#define LOGERRDATA      RouterLogErrorData
#define LOGWARN         RouterLogWarning
#define LOGWARNDATA     RouterLogWarningData
#define LOGINFO         RouterLogInformation
#define LOGINFODATA     RouterLogInformationData

//
// Error logging
//

//
//  VOID
//  Log{Err|Warn|Info}{NumArgs}(
//      DWORD    dwLogMsgId,
//      PSTR     pszInsertString1,
//      ....
//      PSTR     pszInsertString{NumArgs},
//      DWORD    dwErrorCode
//      );
//
//  VOID
//  Log{Err|Warn|Info}Data{NumArgs}(
//      DWORD    dwLogMsgId,
//      PSTR     pszInsertString1,
//      ....
//      PSTR     pszInsertString{NumArgs},
//      DWORD    dwDataSize,
//      PBYTE    pbData 
//      );
//


#define LogErr0(msg,err)                                    \
if (LOGLEVEL >= IPRTR_LOGGING_ERROR)                    \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,0,NULL,(err))
#define LogErr1(msg,a,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,1,&(a),(err))
#define LogErr2(msg,a,b,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPTSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,2,_asz,(err)); \
        }
#define LogErr3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPTSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,3,_asz,(err)); \
        }
#define LogErr4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,4,_asz,(err)); \
        }
#define LogErr5(msg,a,b,c,d,e,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPSTR _asz[5] = { (a), (b), (c), (d), (e) }; \
            LOGERR(LOGHANDLE,ROUTERLOG_IP_ ## msg,5,_asz,(err)); \
        }

#define LogErrW3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_ERROR) { \
            LPTSTR _asz[3] = { (a), (b), (c) }; \
            LOGERRW(LOGHANDLE,ROUTERLOG_IP_ ## msg,3,_asz,(err)); \
        }


// Warning logging

#define LogWarn0(msg,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,0,NULL,(err))
#define LogWarn1(msg,a,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,1,&(a),(err))
#define LogWarn2(msg,a,b,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,2,_asz,(err)); \
        }
#define LogWarn3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,3,_asz,(err)); \
        }
#define LogWarn4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,ROUTERLOG_IP_ ## msg,4,_asz,(err)); \
        }

#define LogWarnData2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,ROUTERLOG_IP_ ## msg,2,_asz,(dw),(buf)); \
        }

#define LogWarnData5(msg,a,b,c,d,e,dw,buf) \
        if (LOGLEVEL >= IPRTR_LOGGING_WARN) { \
            LPTSTR _asz[5] = { (a), (b), (c), (d), (e)}; \
            LOGWARNDATA(LOGHANDLE,ROUTERLOG_IP_ ## msg,5,_asz,(dw),(buf)); \
        }


// Information logging

#define LogInfo0(msg,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,0,NULL,(err))
#define LogInfo1(msg,a,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,1,&(a),(err))
#define LogInfo2(msg,a,b,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) { \
            LPTSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,2,_asz,(err)); \
        }
#define LogInfo3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) { \
            LPTSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,3,_asz,(err)); \
        }
#define LogInfo4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRTR_LOGGING_INFO) { \
            LPTSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,ROUTERLOG_IP_ ## msg,4,_asz,(err)); \
        }


#endif // __LOGTRDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\locate.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\locate.h

Abstract:

    Header for locate.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/


DWORD
LocateIfRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    ICB     **ppicb,
    BOOL    bNoClient
    );

DWORD
LocateIpAddrRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );

DWORD
LocateIpForwardRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );

DWORD
LocateIpNetRow(
    DWORD dwQueryType,
    DWORD dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );

DWORD
LocateUdpRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );

DWORD
LocateTcpRow(
    DWORD   dwQueryType,
    DWORD   dwNumIndices,
    PDWORD  pdwIndex,
    PDWORD  pdwRetIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\map.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\map.c

Abstract:

    Header for map.c 

Revision History:

    Amritansh Raghav          10/6/95  Created

--*/

VOID
InitHashTables(
    VOID
    );

VOID
UnInitHashTables(
    VOID
    );

VOID
AddBinding(
    PICB picb
    );

VOID
RemoveBinding(
    PICB  picb
    );

PADAPTER_INFO
GetInterfaceBinding(
    DWORD   dwIfIndex
    );

#if DBG

VOID
CheckBindingConsistency(
    PICB    picb
    );

#else

#define CheckBindingConsistency(x)  NOTHING

#endif

/*
DWORD
StoreAdapterToInterfaceMap(
    DWORD dwAdapterId,
    DWORD dwIfIndex
    );

DWORD
DeleteAdapterToInterfaceMap(
    DWORD dwAdapterId
    );

DWORD
GetInterfaceFromAdapter(
    DWORD dwAdapterId
    );

PADAPTER_MAP
LookUpAdapterHash(
    DWORD dwAdapterId
    );

VOID
InsertAdapterHash(
    PADAPTER_MAP paiBlock
    );

DWORD
GetAdapterFromInterface(
    DWORD dwIfIndex
    );
*/

VOID
AddInterfaceLookup(
    PICB    picb
    );

VOID
RemoveInterfaceLookup(
    PICB    picb
    );

PICB
InterfaceLookupByIfIndex(
    DWORD           dwIfIndex
    );

PICB
InterfaceLookupByICBSeqNumber(
    DWORD           dwSeqNumber
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\mcastif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:

Revision History:



--*/


#include "allinc.h"

PCHAR   g_pszMsg[] = {
    "Packet Received",
    "MFE Deleted",
    "Wrong I/f Upcall"
};

DWORD
QueueAsyncFunction(
    WORKERFUNCTION   pfnFunction,
    PVOID            pvContext,
    BOOL             bAlertable
    );

DWORD
ValidateMfe(
    IN OUT  PIPMCAST_MFE    pMfe
    );


VOID
HandleRcvPkt(
    PVOID   pvContext
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    PIP_HEADER   pHdr;
    DWORD        dwResult, dwOldIf;
    ULONG        ulIndex;

    PIPMCAST_PKT_MSG        pPktInfo;
    PIPMCAST_NOTIFICATION   pMsg;

    ulIndex  = PtrToUlong(pvContext);

    pMsg     = &(g_rginMcastMsg[ulIndex].msg);
    pPktInfo = &(pMsg->ipmPkt);

    pHdr     = (PIP_HEADER)(pPktInfo->rgbyData);

    Trace3(MCAST,
           "HandleRcvPkt: Rcvd pkt from %d.%d.%d.%d to %d.%d.%d.%d on %d",
           PRINT_IPADDR(pHdr->dwSrc),
           PRINT_IPADDR(pHdr->dwDest),
           pPktInfo->dwInIfIndex);

    dwResult = g_pfnMgmNewPacket(pHdr->dwSrc,
                                 pHdr->dwDest,
                                 pPktInfo->dwInIfIndex,
                                 pPktInfo->dwInNextHopAddress,
                                 pPktInfo->cbyDataLen,
                                 pPktInfo->rgbyData);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "HandleRcvPkt: MGM returned error %d\n", dwResult);
    }

    PostNotificationForMcastEvents(&(g_rginMcastMsg[ulIndex]),
                                   g_hMcastEvents[ulIndex]);

    ExitRouterApi();
}

VOID
HandleDeleteMfe(
    PVOID   pvContext
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD        dwResult;
    ULONG        ulIndex, i;

    PIPMCAST_MFE_MSG        pMfeInfo;
    PIPMCAST_NOTIFICATION   pMsg;

    ulIndex  = PtrToUlong(pvContext);

    pMsg     = &(g_rginMcastMsg[ulIndex].msg);
    pMfeInfo = &(pMsg->immMfe);

    Trace1(MCAST,
           "HandleDeleteMfe: Kernel deleted %d MFEs\n",
           pMfeInfo->ulNumMfes);

    for(i = 0; i < pMfeInfo->ulNumMfes; i++)
    {
        Trace3(MCAST,
               "HandleDeleteMfe: Group %d.%d.%d.%d Source %d.%d.%d.%d/%d.%d.%d.%d\n",
               PRINT_IPADDR(pMsg->immMfe.idmMfe[i].dwGroup),
               PRINT_IPADDR(pMsg->immMfe.idmMfe[i].dwSource),
               PRINT_IPADDR(pMsg->immMfe.idmMfe[i].dwSrcMask));
    }

    dwResult = g_pfnMgmMfeDeleted(pMfeInfo->ulNumMfes,
                                  pMfeInfo->idmMfe);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "HandleDeleteMfe: MGM returned error %d\n", dwResult);
    }

    PostNotificationForMcastEvents(&(g_rginMcastMsg[ulIndex]),
                                   g_hMcastEvents[ulIndex]);

    ExitRouterApi();
}

VOID
HandleWrongIfUpcall(
    PVOID   pvContext
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    PIP_HEADER   pHdr;
    DWORD        dwResult, dwOldIf;
    ULONG        ulIndex;

    PIPMCAST_PKT_MSG        pPktInfo;
    PIPMCAST_NOTIFICATION   pMsg;

    ulIndex  = PtrToUlong(pvContext);

    pMsg     = &(g_rginMcastMsg[ulIndex].msg);
    pPktInfo = &(pMsg->ipmPkt);

    pHdr     = (PIP_HEADER)(pPktInfo->rgbyData);

    Trace3(MCAST,
           "HandleWrongIfUpcall: Pkt from %d.%d.%d.%d to %d.%d.%d.%d on %d is wrong",
           PRINT_IPADDR(pHdr->dwSrc),
           PRINT_IPADDR(pHdr->dwDest),
           pPktInfo->dwInIfIndex);

    dwResult = g_pfnMgmWrongIf(pHdr->dwSrc,
                               pHdr->dwDest,
                               pPktInfo->dwInIfIndex,
                               pPktInfo->dwInNextHopAddress,
                               pPktInfo->cbyDataLen,
                               pPktInfo->rgbyData);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "HandleWrongIfUpcall: MGM returned error %d\n", dwResult);
    }
        
    PostNotificationForMcastEvents(&(g_rginMcastMsg[ulIndex]),
                                   g_hMcastEvents[ulIndex]);

    ExitRouterApi();
}

VOID
HandleMcastNotification(
    DWORD   dwIndex
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD   dwResult;
    ULONG   i;
    
    PIPMCAST_NOTIFICATION   pMsg;
    

    pMsg = &(g_rginMcastMsg[dwIndex].msg);
    
    
    //
    // read the notification
    //


    Trace1(MCAST,
           "HandleMcastNotification: Notification received for %s\n",
           g_pszMsg[pMsg->dwEvent]);
                
    switch(pMsg->dwEvent)
    {
        case IPMCAST_RCV_PKT_MSG:
        {
            QueueAsyncFunction(HandleRcvPkt,
                               (PVOID)(ULONG_PTR)dwIndex,
                               FALSE);
            
            break;
        }
        
        case IPMCAST_DELETE_MFE_MSG:
        {
            QueueAsyncFunction(HandleDeleteMfe,
                               (PVOID)(ULONG_PTR)dwIndex,
                               FALSE);
            
            break;
        }

        case IPMCAST_WRONG_IF_MSG:
        {
            QueueAsyncFunction(HandleWrongIfUpcall,
                               (PVOID)(ULONG_PTR)dwIndex,
                               FALSE);

            break;
        }
        
        default:
        {
            Trace1(MCAST,
                   "HandleMcastNotification: Bad event code %d\n",
                   pMsg->dwEvent);        
            
            PostNotificationForMcastEvents(&(g_rginMcastMsg[dwIndex]),
                                           g_hMcastEvents[dwIndex]);

            break;
        }
    }
        
}


VOID
PostNotificationForMcastEvents(
    PMCAST_OVERLAPPED   pOverlapped,
    HANDLE              hEvent
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    NTSTATUS    nsStatus;

    nsStatus = SendIoctlToMcastDevice(IOCTL_IPMCAST_POST_NOTIFICATION,
                                      hEvent,
                                      &pOverlapped->ioStatus,
                                      &pOverlapped->msg,
                                      sizeof(IPMCAST_NOTIFICATION),
                                      &pOverlapped->msg,
                                      sizeof(IPMCAST_NOTIFICATION));
    
    if((nsStatus isnot STATUS_SUCCESS) and
       (nsStatus isnot STATUS_PENDING))
    {
        Trace1(ERR,
               "PostNotificationForMcastEvents: Error %X",
               nsStatus);
    }
}   


DWORD
SendIoctlToMcastDevice(
    DWORD               dwIoctl,
    HANDLE              hEvent,
    PIO_STATUS_BLOCK    pIoStatus,
    PVOID               pvInBuffer,
    DWORD               dwInBufLen,
    PVOID               pvOutBuffer,
    DWORD               dwOutBufLen
    )
{
    NTSTATUS                        ntStatus;

    ntStatus = NtDeviceIoControlFile(g_hMcastDevice,
                                     hEvent,
                                     NULL,
                                     NULL,
                                     pIoStatus,
                                     dwIoctl,
                                     pvInBuffer,
                                     dwInBufLen,
                                     pvOutBuffer,
                                     dwOutBufLen);

    return ntStatus;
}

DWORD
SetMfe(
    PIPMCAST_MFE    pMfe
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD           dwResult;
    IO_STATUS_BLOCK ioStatus; 
    
    dwResult = ValidateMfe(pMfe);
    
    if(dwResult isnot NO_ERROR)
    {
        //
        // Something bad happened while validating the MFE
        //

        Trace1(ERR,
               "SetMfe: Error %d validating MFE",
               dwResult);

        return dwResult;
    }

    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_SET_MFE,
                                      NULL,
                                      &ioStatus,
                                      pMfe,
                                      SIZEOF_MFE(pMfe->ulNumOutIf),
                                      NULL,
                                      0);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "SetMfe: NtStatus %x while setting MFE",
               dwResult);
    }

    return dwResult;
}

DWORD
GetMfe(
    PIPMCAST_MFE_STATS  pMfeStats
    )
{
    DWORD           dwResult;
    IO_STATUS_BLOCK ioStatus;

    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_GET_MFE,
                                      NULL,
                                      &ioStatus,
                                      pMfeStats,
                                      SIZEOF_MFE_STATS(pMfeStats->ulNumOutIf),
                                      pMfeStats,
                                      SIZEOF_MFE_STATS(pMfeStats->ulNumOutIf));

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "GetMfe: NtStatus %x while getting MFE",
               dwResult);
    }

    return dwResult;
}


DWORD
DeleteMfe(
    PIPMCAST_DELETE_MFE pDelMfe
    )
{
    DWORD           dwResult;
    IO_STATUS_BLOCK ioStatus;
    
    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_DELETE_MFE,
                                      NULL,
                                      &ioStatus,
                                      pDelMfe,
                                      sizeof(IPMCAST_DELETE_MFE),
                                      NULL,
                                      0);

    if(dwResult isnot NO_ERROR)
    {
        Trace1(MCAST,
               "DeleteMfe: NtStatus %x while deleting MFE",
               dwResult);
    }

    return dwResult;
}

DWORD
ActivateMcastLimits(
    PICB    picb
    )
{
    DWORD           dwResult;
    IO_STATUS_BLOCK ioStatus; 
    IPMCAST_IF_TTL  iitTtl;
    DWORD           dwTtl = picb->dwMcastTtl;

    // Set the TTL threshold

    iitTtl.dwIfIndex = picb->dwIfIndex;
    iitTtl.byTtl     = LOBYTE(LOWORD(dwTtl));
    
    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_SET_TTL,
                                      NULL,
                                      &ioStatus,
                                      &iitTtl,
                                      sizeof(IPMCAST_IF_TTL),
                                      NULL,
                                      0);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetMcastTtl: NtStatus %x from SendIoctl when setting TTL for %S",
               dwResult,
               picb->pwszName);

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Set the rate limit for multicast traffic on an interface.
    // Currently, the kernel does not support rate limiting.
    //

    return NO_ERROR;
}

DWORD
SetMcastLimits(
    PICB   picb,
    DWORD  dwTtl,
    DWORD  dwRateLimit
    )
{
    if (dwTtl > 255)
    {
        Trace2(ERR,
               "SetMcastTtl: TTL for %S is %d which is invalid",
               picb->pwszName,
               dwTtl);

        return ERROR_INVALID_DATA;
    }

    picb->dwMcastTtl = dwTtl;

    //
    // Set the rate limit for multicast traffic on an interface.
    // Currently, the kernel does not support rate limiting, so
    // the only valid value is 0 (=none).
    //

    if (dwRateLimit != 0)
    {
        Trace2(ERR,
               "SetMcastRateLimit: RateLimit for %S is %d which is invalid",
               picb->pwszName,
               dwRateLimit);

        return ERROR_INVALID_DATA;
    }

    picb->dwMcastRateLimit = dwRateLimit;

    if ( picb->dwOperationalState is IF_OPER_STATUS_OPERATIONAL )
    {
        return ActivateMcastLimits(picb);
    }

    return NO_ERROR;
}

DWORD
SetMcastLimitInfo(
    PICB                   picb,
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )
/*++
Routine Description:
    Sets the TTL and rate limit info associated with an interface.
Arguments:
    picb    The ICB of the interface
Called by:
    AddInterface() in iprtrmgr.c
    SetInterfaceInfo() in iprtrmgr.c
Locks:
    BOUNDARY_TABLE for writing
--*/
{
    DWORD            dwResult = NO_ERROR,
                     i, j;

    PRTR_TOC_ENTRY   pToc;

    PMIB_MCAST_LIMIT_ROW pLimit;

    BOOL             bFound;

    Trace1( MCAST, "ENTERED SetMcastLimitInfo for If %x", picb->dwIfIndex );

    pToc = GetPointerToTocEntry(IP_MCAST_LIMIT_INFO, pInfoHdr);

    if (pToc is NULL) 
    {
       // No TOC means no change
       Trace0( MCAST, "LEFT SetMcastLimitInfo" );
       return NO_ERROR;
    }

    pLimit = (PMIB_MCAST_LIMIT_ROW)GetInfoFromTocEntry(pInfoHdr, pToc);

    if (pLimit is NULL)
    {
        Trace0( MCAST, "LEFT SetMcastLimitInfo" );

        return NO_ERROR;
    }

    dwResult = SetMcastLimits( picb, pLimit->dwTtl, pLimit->dwRateLimit );

    Trace0( MCAST, "LEFT SetMcastLimitInfo" );

    return dwResult;
}

DWORD
SetMcastOnIf(
    PICB    picb,
    BOOL    bActivate
    )
{
    DWORD                       dwResult;
    IO_STATUS_BLOCK             ioStatus;
    IPMCAST_IF_STATE            iisState;

    iisState.dwIfIndex = picb->dwIfIndex;
    iisState.byState   = bActivate?1:0;

    dwResult = SendIoctlToMcastDevice(IOCTL_IPMCAST_SET_IF_STATE,
                                      NULL,
                                      &ioStatus,
                                      &iisState,
                                      sizeof(IPMCAST_IF_STATE),
                                      NULL,
                                      0);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetMcastOnIf: NtStatus %x from SendIoctl for %S",
               dwResult,
               picb->pwszName);

        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}

DWORD
StartMulticast(
    VOID
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD           i, dwStart;
    NTSTATUS        nStatus;
    IO_STATUS_BLOCK ioStatus;

    dwStart  = 1;

    nStatus  = SendIoctlToMcastDevice(IOCTL_IPMCAST_START_STOP,
                                      NULL,
                                      &ioStatus,
                                      &dwStart,
                                      sizeof(DWORD),
                                      NULL,
                                      0);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace1(MCAST, "StartMulticast: Error %x starting driver",
               nStatus);

        return ERROR_OPEN_FAILED;
    }

    for(i = 0; i < NUM_MCAST_IRPS; i++)
    {
        PostNotificationForMcastEvents(&(g_rginMcastMsg[i]),
                                       g_hMcastEvents[i]);
    }

    // Start up mrinfo and mtrace services
    StartMcMisc();

    return NO_ERROR;
}




DWORD
ValidateMfe(
    IN OUT PIPMCAST_MFE    pMfe
    )

/*++

Routine Description:


Locks:


Arguments:


Return Value:

    NO_ERROR

--*/

{
    PADAPTER_INFO   pBinding;
    ULONG           i;
    
    
    ENTER_READER(BINDING_LIST);

    //
    // First find the interface index for incoming i/f
    // If there are no outgoing interfaces, then this is a NEGATIVE
    // MFE and the incoming interface index must be 0 (and need not
    // be mapped)
    //

#if DBG
    
    if(pMfe->ulNumOutIf is 0)
    {
        IpRtAssert(pMfe->dwInIfIndex is 0);

        pMfe->dwInIfIndex = 0;
    }

#endif

    
    for(i = 0; i < pMfe->ulNumOutIf; i++)
    {
        pBinding = GetInterfaceBinding(pMfe->rgioOutInfo[i].dwOutIfIndex);

        if(!pBinding)
        {
            Trace1(ERR,
                   "ValidateMfe: Unable to find binding for outgoing i/f %d",
                   pMfe->rgioOutInfo[i].dwOutIfIndex);
            
            EXIT_LOCK(BINDING_LIST);

            return ERROR_INVALID_INDEX;
        }
        

        if(pBinding->bBound)
        {
            //
            // valid index
            //

            pMfe->rgioOutInfo[i].dwOutIfIndex = pBinding->dwIfIndex;
        }
        else
        {
            //
            // Demand dial interface
            //

            pMfe->rgioOutInfo[i].dwOutIfIndex = INVALID_IF_INDEX;
            
            pMfe->rgioOutInfo[i].dwDialContext = pBinding->dwSeqNumber;
            
        }
    }

    EXIT_LOCK(BINDING_LIST);
    
    return NO_ERROR;
}

DWORD
GetInterfaceMcastCounters(
    IN   PICB                   picb, 
    OUT  PIP_MCAST_COUNTER_INFO pOutBuffer
    )
{
    DWORD                 dwAdapterId,dwResult;
    PPROTO_CB             pcbOwner;
    IO_STATUS_BLOCK       ioStatus;
    ULONG                 Request = picb->dwIfIndex;
    HANDLE                hEvent;

    dwResult = NO_ERROR;
    
    hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    if(hEvent is NULL)
    {
        dwResult = GetLastError();

        Trace1(ERR,
               "GetInterfaceMcastCounters: Error %d creating event",
               dwResult);

        return dwResult;
    }

    dwResult = NtDeviceIoControlFile(g_hIpDevice,
                                     hEvent,
                                     NULL,
                                     NULL,
                                     &ioStatus,
                                     IOCTL_IP_GET_MCAST_COUNTERS,
                                     &Request,
                                     sizeof(Request),
                                     pOutBuffer,
                                     sizeof(IP_MCAST_COUNTER_INFO));

    if(dwResult is STATUS_PENDING)
    {
        Trace0(ERR,
               "GetInterfaceMcastCounters: Pending from ioctl");

        dwResult = WaitForSingleObject(hEvent,
                                       INFINITE);

        if(dwResult isnot WAIT_OBJECT_0) // 0
        {
            Trace1(ERR,
                   "GetInterfaceMcastCounters: Error %d from wait",
                   dwResult);

            dwResult = GetLastError();
        }
        else
        {
            dwResult = STATUS_SUCCESS;
        }
    }

    return dwResult;
}

DWORD 
GetInterfaceMcastStatistics(
    IN   PICB                  picb, 
    OUT  PMIB_IPMCAST_IF_ENTRY pOutBuffer
    )
{
    DWORD                 dwAdapterId,dwResult;
    PPROTO_CB             pcbOwner;
    IO_STATUS_BLOCK       ioStatus;
    IP_MCAST_COUNTER_INFO ifStats;

    dwResult = NO_ERROR;
    
    TraceEnter("GetInterfaceMcastStatistics");

    pOutBuffer->dwIfIndex       = picb->dwIfIndex;
    pOutBuffer->dwTtl           = picb->dwMcastTtl;
    pOutBuffer->dwRateLimit     = 0; // XXX change when we have rate limiting

    dwResult = GetInterfaceMcastCounters(picb, &ifStats);
    if (dwResult isnot STATUS_SUCCESS)
    {
        return dwResult;
    }

    pOutBuffer->ulOutMcastOctets = (ULONG)ifStats.OutMcastOctets; 
    pOutBuffer->ulInMcastOctets  = (ULONG)ifStats.InMcastOctets; 
    pOutBuffer->dwProtocol   = 2; // "local" (static only) is default

    dwResult = MulticastOwner(picb, &pcbOwner, NULL);
    if (dwResult == NO_ERROR && pcbOwner != NULL) {
       switch(pcbOwner->dwProtocolId) {
#ifdef MS_IP_DVMRP
       case MS_IP_DVMRP:  pOutBuffer->dwProtocol = 4; break;
#endif
#ifdef MS_IP_MOSPF
       case MS_IP_MOSPF:  pOutBuffer->dwProtocol = 5; break;
#endif
#ifdef MS_IP_CBT
       case MS_IP_CBT  :  pOutBuffer->dwProtocol = 7; break;
#endif
#ifdef MS_IP_PIMSM
       case MS_IP_PIMSM:  pOutBuffer->dwProtocol = 8; break;
#endif
#ifdef MS_IP_PIMDM
       case MS_IP_PIMDM:  pOutBuffer->dwProtocol = 9; break;
#endif
       case MS_IP_IGMP :  pOutBuffer->dwProtocol = 10; break;
       }
    } 

    TraceLeave("GetInterfaceMcastStatistics");
    return dwResult;
}


DWORD 
SetInterfaceMcastStatistics(
    IN PICB                  picb, 
    IN PMIB_IPMCAST_IF_ENTRY lpInBuffer
    )
{
    DWORD dwResult = NO_ERROR;

    TraceEnter("SetInterfaceMcastStatistics");

    dwResult = SetMcastLimits(picb, lpInBuffer->dwTtl, lpInBuffer->dwRateLimit);

    if(dwResult isnot NO_ERROR) {
        Trace2(ERR,
               "SetInterfaceStatistics: Error %d setting %S",
               dwResult,
               picb->pwszName);
    }

    TraceLeave("SetInterfaceMcastStatistics");
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\map.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\map.c

Abstract:

    Utility functions for various lookups and mappings

Revision History:

    Amritansh Raghav          10/6/95  Created

--*/

#include "allinc.h"

VOID 
InitHashTables(
    VOID
    )

/*++

Routine Description

    This function initializes the various mapping tables

Locks

    None. Called at init time

Arguments

    None

Return Value

    None

--*/

{
    DWORD i;

    TraceEnter("InitHashTables");

/*    
    for(i = 0; i < ADAPTER_HASH_TABLE_SIZE; i++)
    {
        InitializeListHead(&(g_rgleAdapterMapTable[i]));
    }
*/

    for(i = 0; i < BINDING_HASH_TABLE_SIZE; i++)
    {
        InitializeListHead(&g_leBindingTable[i]);
    }

    g_ulNumBindings = 0;
    
    TraceLeave("InitHashTables");
}

VOID
UnInitHashTables(
    VOID
    )

/*++

Routine Description

    Undo whatever was done in InitHasTables()

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD       i;
    PLIST_ENTRY pleHead;
    PLIST_ENTRY pleNode;
    
    TraceEnter("UnInitHashTables");

/*    
    for(i = 0; i < ADAPTER_HASH_TABLE_SIZE; i++)
    {
        pleHead = &g_rgleAdapterMapTable[i];
        
        while(!IsListEmpty(pleHead))
        {
            PADAPTER_MAP pAIBlock;
            
            pleNode = RemoveHeadList(pleHead);
            
            pAIBlock = CONTAINING_RECORD(pleNode,ADAPTER_MAP,leHashLink);
            
            HeapFree(GetProcessHeap(),0,pAIBlock);
        }
    }
*/

    for(i = 0; i < BINDING_HASH_TABLE_SIZE; i++)
    {
        pleHead = &g_leBindingTable[i];

        while(!IsListEmpty(pleHead))
        {
            PADAPTER_INFO   pBinding;

            pleNode = RemoveHeadList(pleHead);

            pBinding = CONTAINING_RECORD(pleNode, ADAPTER_INFO, leHashLink);

            Trace1(ERR,
                   "UnInitHashTables: Binding found for %d",
                   pBinding->dwIfIndex);

            HeapFree(IPRouterHeap,
                     0,
                     pBinding);
        }
    }

    g_ulNumBindings = 0;
    
    TraceLeave("UnInitHashTables");
}

VOID
AddBinding(
    PICB picb
    )

/*++

Routine Description

    Adds a binding info node to the hash table. Increments the
    g_ulNumBindings to track the number of addresses on the system
  
Locks 

    ICB lock as writer
    BINDING lock as writer
 
Arguments

    picb    The ICB of the interface whose bindings need to be added
            to the binding list.

Return Value

    None
    
--*/

{
    PADAPTER_INFO   pBinding;
    DWORD           i, dwNumAddr;

#if DBG

    PLIST_ENTRY     pleNode;

#endif

    IpRtAssert(picb->pibBindings isnot NULL);
    IpRtAssert(picb->bBound);

    //
    // adapter info always has space for one address/mask. This is needed
    // for the address table
    //

    dwNumAddr   = picb->dwNumAddresses ? picb->dwNumAddresses : 1;

    pBinding    = HeapAlloc(IPRouterHeap,
                            HEAP_ZERO_MEMORY,
                            SIZEOF_ADAPTER_INFO(picb->dwNumAddresses));

    if(pBinding is NULL)
    {
        Trace1(ERR,
               "AddBinding: Error %d allocating memory",
               GetLastError());
        
        IpRtAssert(FALSE);

        return;
    }

    pBinding->pInterfaceCB      = picb;
    pBinding->bBound            = picb->bBound;
    pBinding->dwIfIndex         = picb->dwIfIndex;
    pBinding->dwNumAddresses    = picb->dwNumAddresses;
    pBinding->dwRemoteAddress   = picb->dwRemoteAddress;

    pBinding->dwBCastBit        = picb->dwBCastBit;
    pBinding->dwReassemblySize  = picb->dwReassemblySize;

    pBinding->ritType           = picb->ritType;

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        //
        // structure assignment
        //
        
        pBinding->rgibBinding[i] = picb->pibBindings[i];
    }

#if DBG

    for(pleNode = g_leBindingTable[BIND_HASH(picb->dwIfIndex)].Flink;
        pleNode isnot &g_leBindingTable[BIND_HASH(picb->dwIfIndex)];
        pleNode = pleNode->Flink)
    {
        PADAPTER_INFO   pTempBind;

        pTempBind = CONTAINING_RECORD(pleNode,
                                      ADAPTER_INFO,
                                      leHashLink);

        IpRtAssert(pTempBind->dwIfIndex isnot picb->dwIfIndex);
    }

#endif

    InsertHeadList(&g_leBindingTable[BIND_HASH(picb->dwIfIndex)],
                   &(pBinding->leHashLink));

    g_ulNumBindings += (picb->dwNumAddresses ? picb->dwNumAddresses : 1);
    
    g_LastUpdateTable[IPADDRCACHE] = 0;
    
    return;
}

VOID
RemoveBinding(
    PICB  picb
    )

/*++

Routine Description

    Called to remove the bindings associated with an interface

Locks

    ICB lock held as WRITER
    BINDING list lock held as WRITER

Arguments

    picb    ICB of the interface whose bindings need to be removed

Return Value

    None

--*/

{
    PADAPTER_INFO   pBind;


    pBind = GetInterfaceBinding(picb->dwIfIndex);
    
    if(pBind isnot NULL)
    {
        RemoveEntryList(&(pBind->leHashLink));

        g_ulNumBindings -= (pBind->dwNumAddresses? pBind->dwNumAddresses : 1);
        
        HeapFree(IPRouterHeap,
                 0,
                 pBind);

        g_LastUpdateTable[IPADDRCACHE] = 0;

        return;
    }

    Trace0(ERR,
           "RemoveBinding: BINDING NOT FOUND");

    IpRtAssert(FALSE);
}

PADAPTER_INFO
GetInterfaceBinding(
    DWORD   dwIfIndex
    )

/*++

Routine Description

    Retrieves a pointer to the binding info from hash table

Locks

    BINDING lock held atleast as READER

Arguments

    dwIfIndex   Interface Index for the interface whose bindings need
                    to be looked up

Return Value

    Pointer to binding information if the binding was found
    NULL    if binding was not found
    
--*/

{
    PLIST_ENTRY     pleNode;
    PADAPTER_INFO   pBinding;

    for(pleNode = g_leBindingTable[BIND_HASH(dwIfIndex)].Flink;
        pleNode isnot &g_leBindingTable[BIND_HASH(dwIfIndex)];
        pleNode = pleNode->Flink)
    {
        pBinding = CONTAINING_RECORD(pleNode,ADAPTER_INFO,leHashLink);

        if(pBinding->dwIfIndex is dwIfIndex)
        {
            return pBinding;
        }
    }

    Trace0(ERR,
           "GetInterfaceBinding: BINDING NOT FOUND");

    return NULL;
}

#if DBG

VOID
CheckBindingConsistency(
    PICB    picb
    )

/*++

Routine Description

    This

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{

}

#endif


//
// The following are the set of various mapping functions
// They require that you already possess the dwLock before you call them
//

#if 0

DWORD 
StoreAdapterToInterfaceMap(
    DWORD dwAdapterId,
    DWORD dwIfIndex
    )
{
    PADAPTER_MAP pAIBlock;
    
    if((pAIBlock = LookUpAdapterHash(dwAdapterId)) isnot NULL)
    {
        pAIBlock->dwIfIndex = dwIfIndex;
        
        return NO_ERROR;
    }

    //
    // Wasnt found
    //
    
    if((pAIBlock = HeapAlloc(GetProcessHeap(),0,sizeof(ADAPTER_MAP))) is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAIBlock->dwAdapterId      = dwAdapterId;
    pAIBlock->dwIfIndex = dwIfIndex;

    InsertAdapterHash(pAIBlock);
    return NO_ERROR;
}

DWORD 
DeleteAdapterToInterfaceMap(
    DWORD dwAdapterId
    )
{
    PADAPTER_MAP pAIBlock;

    if((pAIBlock = LookUpAdapterHash(dwAdapterId)) isnot NULL)
    {
        pAIBlock->dwIfIndex = INVALID_IF_INDEX;
        
        return NO_ERROR;
    }

    return INVALID_ADAPTER_ID;
}

DWORD 
GetInterfaceFromAdapter(
    DWORD dwAdapterId
    )
{
    PADAPTER_MAP pAIBlock;

    if((pAIBlock = LookUpAdapterHash(dwAdapterId)) isnot NULL)
    {
        return pAIBlock->dwIfIndex;
    }

    return INVALID_ADAPTER_ID;
}

PADAPTER_MAP 
LookUpAdapterHash(
    DWORD dwAdapterId
    )
{
    DWORD dwHashIndex;
    PADAPTER_MAP pAIBlock;
    PLIST_ENTRY pleCurrent;
    
    dwHashIndex = ADAPTER_HASH(dwAdapterId);

    //
    // The list is not ordered, travel the whole hash bucket
    //
    
    for(pleCurrent = g_rgleAdapterMapTable[dwHashIndex].Flink;
        pleCurrent isnot &g_rgleAdapterMapTable[dwHashIndex];
        pleCurrent = pleCurrent->Flink)
    {
        pAIBlock = CONTAINING_RECORD(pleCurrent,ADAPTER_MAP,leHashLink);

        if(pAIBlock->dwAdapterId is dwAdapterId)
        {
            return pAIBlock;
        }
    }

    return NULL;
}

VOID 
InsertAdapterHash(
    PADAPTER_MAP paiBlock
    )
{
    DWORD dwHashIndex;

    dwHashIndex = ADAPTER_HASH(paiBlock->dwAdapterId);
    
    InsertHeadList(&g_rgleAdapterMapTable[dwHashIndex],
                   &paiBlock->leHashLink);
}

DWORD 
GetAdapterFromInterface(
    DWORD dwIfIndex
    )
{
    PICB            picb;
    
    picb = InterfaceLookupByIfIndex(dwIfIndex);

    CheckBindingConsistency(picb);
    
    if(!picb)
    {
        Trace0(ERR,
               "GetAdapterFromInterface: Unable to map interface to adapter since the interface id was not found!");
        
        return INVALID_IF_INDEX;
    }
    
    if((picb->dwOperationalState is CONNECTED) or
       (picb->dwOperationalState is OPERATIONAL))
    {
        return picb->dwAdapterId;
    }
    
    Trace1(IF,
           "GetAdapterFromInterface: Unable to map interface to adapter since its operational state was %d",
           picb->dwOperationalState);
    
    return INVALID_IF_INDEX;
}

#endif

// AddInterfaceLookup()
//
// Function: Adds the given interface to the hash table used for quick look up given
//           an interface id.
//
// Returns: Nothing
//

VOID
AddInterfaceLookup(
    PICB    picb
    )
{
    PLIST_ENTRY ple;
    PICB pIcbHash;
    
    InsertHeadList(&ICBHashLookup[picb->dwIfIndex % ICB_HASH_TABLE_SIZE],
                   &picb->leHashLink);

    for (
        ple = ICBSeqNumLookup[picb->dwSeqNumber % ICB_HASH_TABLE_SIZE].Flink;
        ple != &ICBSeqNumLookup[picb->dwSeqNumber % ICB_HASH_TABLE_SIZE];
        ple = ple->Flink
        )
    {
        pIcbHash = CONTAINING_RECORD(ple, ICB, leICBHashLink );
        
        if (pIcbHash->dwSeqNumber > picb->dwSeqNumber)
        {
            break;
        }
    }
    
    InsertTailList(ple, &picb->leICBHashLink);
}


// RemoveInterfaceLookup()
//
// Function: Removes the given interface from the hash table used for quick look up given
//           an interface id.
//
// Returns: Nothing
//

VOID
RemoveInterfaceLookup(
    PICB    picb
    )
{
    RemoveEntryList(&picb->leHashLink);

    picb->leHashLink.Flink = NULL;
    picb->leHashLink.Blink = NULL;

    RemoveEntryList(&picb->leICBHashLink);

    InitializeListHead(&picb->leICBHashLink);
}


// InterfaceLookupByICBSeqNumber()
//
// Function: Returns a pointer to ICB given the sequence number
//
// Returns: PICB if found - NULL otherwise.
//

PICB
InterfaceLookupByICBSeqNumber(
    DWORD           dwSeqNumber
    )
{
    PICB        picb;
    PLIST_ENTRY pleNode;

    for(pleNode = ICBSeqNumLookup[dwSeqNumber % ICB_HASH_TABLE_SIZE].Flink;
        pleNode isnot &ICBSeqNumLookup[dwSeqNumber % ICB_HASH_TABLE_SIZE];
        pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD(pleNode, ICB, leICBHashLink);

        if (picb->dwSeqNumber < dwSeqNumber)
        {
            continue;
        }

        if (picb->dwSeqNumber == dwSeqNumber)
        {
            return picb;
        }

        else
        {
            break;
        }
    }

    return NULL;
}


//
// InterfaceLookupByIfIndex()
//
// Function: Returns a pointer to ICB given the interfaceid
//
// Returns: PICB if found - NULL otherwise.
//

PICB
InterfaceLookupByIfIndex(
    DWORD dwIfIndex
    )
{
    PICB        picb;
    PLIST_ENTRY pleNode;

    for(pleNode = ICBHashLookup[dwIfIndex % ICB_HASH_TABLE_SIZE].Flink;
        pleNode isnot &ICBHashLookup[dwIfIndex % ICB_HASH_TABLE_SIZE];
        pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD(pleNode, ICB, leHashLink);

        if (picb->dwIfIndex is dwIfIndex)
        {
            return picb;
        }
    }

    return NULL;
}

DWORD
MapInterfaceToAdapter(
    DWORD Index
    )
{
    return Index;

#if 0
    ENTER_READER(ICB_LIST);
    Index = GetAdapterFromInterface(Index);
    EXIT_LOCK(ICB_LIST);
    return Index;
#endif
}


DWORD
MapInterfaceToRouterIfType(
    DWORD Index
    )
{
    DWORD   dwIfType = ROUTER_IF_TYPE_INTERNAL;
    PICB    picb;
    ENTER_READER(ICB_LIST);
    picb = InterfaceLookupByIfIndex(Index);
    if (picb) { dwIfType = picb->ritType; }
    EXIT_LOCK(ICB_LIST);
    return dwIfType;
}


DWORD
MapAddressToAdapter(
    DWORD Address
    )
{
    DWORD dwAdapterId;
    DWORD dwBCastBit;
    DWORD dwReassemblySize;
    if (GetAdapterInfo(Address, &dwAdapterId, &dwBCastBit, &dwReassemblySize))
    {
        return INVALID_IF_INDEX;
    }
    return dwAdapterId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\mcastif.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\mcastif.h

Abstract:

    Header for mcastif.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

//
// This is the size of buffer used for MGM queries
//

#define MIB_MFE_BUFFER_SIZE     (1 * 1024)

//
// This is the size of buffer used for boundary queries
//

#define MIB_BOUNDARY_BUFFER_SIZE  (1 * 1024)
#define MIB_SCOPE_BUFFER_SIZE     (1 * 1024)

typedef struct MCAST_OVERLAPPED
{
    IO_STATUS_BLOCK         ioStatus;
    IPMCAST_NOTIFICATION    msg;
}MCAST_OVERLAPPED, *PMCAST_OVERLAPPED;

VOID
HandleMcastNotification(
    DWORD   dwIndex
    );

DWORD
SendIoctlToMcastDevice(
    DWORD               dwIoctl,
    HANDLE              hEvent,
    PIO_STATUS_BLOCK    pIoStatus,
    PVOID               pvInBuffer,
    DWORD               dwInBufLen,
    PVOID               pvOutBuffer,
    DWORD               dwOutBufLen
    );

VOID
HandleRcvPkt(
    PVOID   pvContext
    );

VOID
PostNotificationForMcastEvents(
    PMCAST_OVERLAPPED       pOverlapped,
    HANDLE                  hEvent
    );

DWORD
SetMfe(
    PIPMCAST_MFE    pMfe
    );

DWORD
DeleteMfe(
    PIPMCAST_DELETE_MFE pDelMfe
    );

DWORD
GetMfe(
    PIPMCAST_MFE_STATS  pMfeStats
    );

DWORD
ActivateMcastLimits(
    PICB    picb
    );

DWORD
StartMulticast(
    VOID
    );

DWORD
SetMcastOnIf(
    PICB    picb,
    BOOL    bActivate
    );

DWORD
GetInterfaceMcastStatistics(
    PICB                  picb,
    PMIB_IPMCAST_IF_ENTRY pOutBuffer
    );

DWORD
GetInterfaceMcastCounters(
    PICB                   picb,
    PIP_MCAST_COUNTER_INFO pOutBuffer
    );

DWORD
SetInterfaceMcastStatistics(
    PICB                  picb,
    PMIB_IPMCAST_IF_ENTRY lpInBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\mbound.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mbound.c

Abstract:

    This module implements routines associated with administratively-
    scoped boundaries (i.e. group-prefix boundaries).  An IPv4 Local
    Scope boundary implicitly exists (no state needed) whenever any
    other boundary exists.  The IPv4 Local Scope implicitly exists
    whenever any other scope exists.

Author:

    dthaler@microsoft.com   4-20-98

Revision History:

--*/

#include "allinc.h"
#include "mbound.h"
#include <math.h>   // for floor()
#pragma hdrstop

#ifdef DEBUG
#define INLINE
#else
#define INLINE          __inline
#endif

#define MZAP_DEFAULT_BIT 0x80

#define MAX_SCOPES 10
SCOPE_ENTRY  g_scopeEntry[MAX_SCOPES];
SCOPE_ENTRY  g_LocalScope;

#define BOUNDARY_HASH_TABLE_SIZE 57
#define BOUNDARY_HASH(X)  ((X) % BOUNDARY_HASH_TABLE_SIZE)
BOUNDARY_BUCKET g_bbScopeTable[BOUNDARY_HASH_TABLE_SIZE];

#define ROWSTATUS_ACTIVE 1

#define MIN_SCOPE_ADDR         0xef000000
#define MAX_SCOPE_ADDR        (0xefff0000 - 1)

#define IPV4_LOCAL_SCOPE_LANG MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US)
#define IPV4_LOCAL_SCOPE_NAME SN_L"IPv4 Local Scope"
#define IPV4_LOCAL_SCOPE_ADDR htonl(0xefff0000)
#define IPV4_LOCAL_SCOPE_MASK htonl(0xffff0000)
#define IN_IPV4_LOCAL_SCOPE(x) \
    (((x) & IPV4_LOCAL_SCOPE_MASK) == IPV4_LOCAL_SCOPE_ADDR)

LIST_ENTRY g_MasterInterfaceList;
LIST_ENTRY g_MasterScopeList;

#define MALLOC(dwSize)       HeapAlloc(IPRouterHeap, 0, dwSize)
#define FREE(x)              HeapFree(IPRouterHeap, 0, x)
#define MIN(x,y)                 (((x)<(y))?(x):(y))

// Forward static declarations

DWORD
AssertBoundaryEntry(
    BOUNDARY_IF     *pBoundaryIf, 
    SCOPE_ENTRY     *pScope,
    PBOUNDARY_ENTRY *ppBoundary
    );

VOID
MzapInitScope(
    PSCOPE_ENTRY    pScope
    );

DWORD
MzapInitBIf(
    PBOUNDARY_IF    pBIf
    );

VOID
MzapUninitBIf(
    PBOUNDARY_IF    pBIf
    );

DWORD
MzapActivateBIf( 
    PBOUNDARY_IF    pBIf
    );

// 
// Functions to manipulate scopes
//

PSCOPE_ENTRY
NewScope()
{
    DWORD dwScopeIndex;

    // Find an unused scope index
    for (dwScopeIndex=0; dwScopeIndex<MAX_SCOPES; dwScopeIndex++) 
    {
        if ( !g_scopeEntry[dwScopeIndex].ipGroupAddress ) 
        {
            return &g_scopeEntry[ dwScopeIndex ];
        }
    }

    return NULL;
}

PSCOPE_ENTRY
FindScope(
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    )
/*++
Called by: 
    AssertScope(), RmGetBoundary()
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE.
--*/
{
    PLIST_ENTRY  pleNode;

    for (pleNode = g_MasterScopeList.Flink;
         pleNode isnot &g_MasterScopeList;
         pleNode = pleNode->Flink) 
    {

        SCOPE_ENTRY *pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY,
         leScopeLink);

        if (pScope->ipGroupAddress == ipGroupAddress
         && pScope->ipGroupMask    == ipGroupMask)
           return pScope;
    }

    return NULL;
}

PBYTE
GetLangName(
    IN LANGID  idLanguage
    )
{
    char b1[8], b2[8];
    static char buff[80];
    LCID lcid = MAKELCID(idLanguage, SORT_DEFAULT);

    GetLocaleInfo(lcid, LOCALE_SISO639LANGNAME, b1, sizeof(b1));

    GetLocaleInfo(lcid, LOCALE_SISO3166CTRYNAME, b2, sizeof(b2));

    if (_stricmp(b1, b2))
        sprintf(buff, "%s-%s", b1, b2);
    else
        strcpy(buff, b1);

    return buff;
}

PSCOPE_NAME_ENTRY
GetScopeNameByLangID(
    IN PSCOPE_ENTRY pScope, 
    IN LANGID       idLanguage
    )
/*++
Called by:
    AssertScopeName()
--*/
{
    PLIST_ENTRY       pleNode;
    PSCOPE_NAME_ENTRY pName;

    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        if (idLanguage == pName->idLanguage)
            return pName;
    }

    return NULL;
}

PSCOPE_NAME_ENTRY
GetScopeNameByLangName(
    IN PSCOPE_ENTRY pScope, 
    IN PBYTE        pLangName
    )
/*++
Called by:
    CheckForScopeNameMismatch()
--*/
{
    PLIST_ENTRY       pleNode;
    PSCOPE_NAME_ENTRY pName;

    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        if (!strcmp(pLangName, GetLangName(pName->idLanguage)))
            return pName;
    }

    return NULL;
}


VOID
MakePrefixStringW( 
    OUT PWCHAR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr, 
    IN  IPV4_ADDRESS ipMask
    )
{
    swprintf( pwcPrefixStr, 
              L"%d.%d.%d.%d/%d", 
              PRINT_IPADDR(ipAddr),  
              MaskToMaskLen(ipMask) );
}

// Global buffers used to create messages
WCHAR g_AddrBuf1[20];
WCHAR g_AddrBuf2[20];
WCHAR g_AddrBuf3[20];
WCHAR g_AddrBuf4[20];

VOID
MakeAddressStringW(
    OUT PWCHAR       pwcAddressStr,
    IN  IPV4_ADDRESS ipAddr
    )
{
    swprintf( pwcAddressStr,
              L"%d.%d.%d.%d",
              PRINT_IPADDR(ipAddr) );
}

SCOPE_NAME
GetDefaultName(
    IN PSCOPE_ENTRY pScope
    )
/*++
Called by:
    RmGetNextScope()
    Various other functions for use in Trace() calls
--*/
{
    PLIST_ENTRY       pleNode;
    PSCOPE_NAME_ENTRY pName;
    static SCOPE_NAME_BUFFER snScopeNameBuffer;
    SCOPE_NAME        pFirst = NULL;

    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        if (pName->bDefault)
            return pName->snScopeName;
        if (!pFirst)
            pFirst = pName->snScopeName;
    }

    // If any names were specified, just pick the first one.

    if (pFirst)
        return pFirst;

    MakePrefixStringW( snScopeNameBuffer, 
                       pScope->ipGroupAddress,
                       pScope->ipGroupMask );

    return snScopeNameBuffer;
}

VOID
DeleteScopeName(
    IN  PLIST_ENTRY   pleNode
    )
{
    PSCOPE_NAME_ENTRY pName = CONTAINING_RECORD( pleNode, 
                                                 SCOPE_NAME_ENTRY, 
                                                 leNameLink );

    RemoveEntryList(pleNode);

    if (pName->snScopeName)
        FREE(pName->snScopeName);

    FREE( pName );
}

DWORD
AssertScopeName(
    IN  PSCOPE_ENTRY  pScope,
    IN  LANGID        idLanguage,
    IN  SCOPE_NAME    snScopeName  // unicode string to duplicate
    )
/*++
Arguments:
    pScope - scope entry to modify
    idLanguage - language ID of new name
    snScopeName - new name to use
Called by:
    MzapInitLocalScope(), AddScope(), ParseScopeInfo(), SetScopeInfo(),
    SNMPSetScope()
--*/
{
    SCOPE_NAME_BUFFER snScopeNameBuffer;
    PSCOPE_NAME_ENTRY pName;

    pName = GetScopeNameByLangID(pScope, idLanguage);

    //
    // See if the name is already correct.
    //

    if (pName && snScopeName && !sn_strcmp( snScopeName, pName->snScopeName ))
    {
        return NO_ERROR;
    }

    //
    // Create a scope name if we weren't given one
    //

    if ( snScopeName is NULL 
      || snScopeName[0] is '\0' ) 
    {
        MakePrefixStringW( snScopeNameBuffer, 
                           pScope->ipGroupAddress,
                           pScope->ipGroupMask );

        snScopeName = snScopeNameBuffer;
    }

    // Add a name entry if needed

    if (!pName)
    {
        pName = (PSCOPE_NAME_ENTRY)MALLOC( sizeof(SCOPE_NAME_ENTRY) );
        if (!pName) 
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pName->bDefault = FALSE;
        pName->snScopeName = NULL;
        pName->idLanguage = idLanguage;
        InsertTailList( &pScope->leNameList, &pName->leNameLink );
        pScope->ulNumNames++;
    }

    //
    // Free the old name and save the new one
    //

    if (pName->snScopeName) 
    {
        FREE( pName->snScopeName );
    }

    pName->snScopeName = (SCOPE_NAME)MALLOC( (sn_strlen(snScopeName)+1) 
                               * SNCHARSIZE );

    if (pName->snScopeName == NULL)
    {
        DWORD dwErr = GetLastError();
        
        Trace3(
            ANY,
            "Error %d allocating %d bytes for scope name %s",
            dwErr, sn_strlen(snScopeName)+1, snScopeName
            );

        return dwErr;
    }
    
    sn_strcpy(pName->snScopeName, snScopeName);

    Trace4(MCAST, "Updated scope name for \"%s\": %ls (%d.%d.%d.%d/%d)", 
     GetLangName(idLanguage),
     snScopeName,
     PRINT_IPADDR(pScope->ipGroupAddress),
     MaskToMaskLen(pScope->ipGroupMask) );

    return NO_ERROR;
}

VOID
MzapInitLocalScope()
/*++
Called by:
    ActivateMZAP()
--*/
{
    PSCOPE_ENTRY pScope = &g_LocalScope;

    pScope->ipGroupAddress = IPV4_LOCAL_SCOPE_ADDR;
    pScope->ipGroupMask    = IPV4_LOCAL_SCOPE_MASK;

    InitializeListHead( &pScope->leNameList );
    pScope->ulNumNames = 0;

    MzapInitScope(pScope);

    AssertScopeName( pScope, IPV4_LOCAL_SCOPE_LANG, IPV4_LOCAL_SCOPE_NAME );
}

DWORD
AddScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    OUT PSCOPE_ENTRY *pScopeEntry
    )
/*++
Routine Description:
    Add a named scope.
Arguments:
    IN  ipGroupAddress - first address in the scope to add
    IN  ipGroupMask    - mask associated with the address
    OUT pScope         - scope entry added
Called by:
    AssertScope()
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE
Returns:
    NO_ERROR
    ERROR_NOT_ENOUGH_MEMORY
    ERROR_INVALID_PARAMETER
--*/
{
    SCOPE_ENTRY      *pScope;
    PLIST_ENTRY       pleNode;

    // See if any bits are set in the address but not the mask
    if (ipGroupAddress & ~ipGroupMask)
       return ERROR_INVALID_PARAMETER;

    // Make sure the address is a valid one
    if (ntohl(ipGroupAddress) < MIN_SCOPE_ADDR
     || ntohl(ipGroupAddress) > MAX_SCOPE_ADDR)
       return ERROR_INVALID_PARAMETER;

    // Make sure we have space for this entry
    if ((pScope = NewScope()) == NULL)
       return ERROR_NOT_ENOUGH_MEMORY;

    pScope->ipGroupAddress  = ipGroupAddress;
    pScope->ipGroupMask     = ipGroupMask;

    InitializeListHead( &pScope->leNameList );
    pScope->ulNumNames = 0;

#if 0
{
    SCOPE_NAME_BUFFER snScopeNameBuffer;

    // Create a scope name if we weren't given one
    if ( snScopeName is NULL 
      || snScopeName[0] is '\0' ) 
    {
        MakePrefixStringW( snScopeNameBuffer, 
                           pScope->ipGroupAddress,
                           pScope->ipGroupMask );

        snScopeName = snScopeNameBuffer;
    }

    AssertScopeName( pScope, idLanguage, snScopeName );
}
#endif

    MzapInitScope(pScope);

    //
    // Add it to the master scope list
    //

    // Search for entry after the new one
    for (pleNode = g_MasterScopeList.Flink;
         pleNode isnot &g_MasterScopeList;
         pleNode = pleNode->Flink) 
    {
       SCOPE_ENTRY *pPrevScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY,
        leScopeLink);
       IPV4_ADDRESS ipAddress = pPrevScope->ipGroupAddress;
       IPV4_ADDRESS ipMask    = pPrevScope->ipGroupMask;
       
       if (ipAddress > pScope->ipGroupAddress
        || (ipAddress==pScope->ipGroupAddress && ipMask>pScope->ipGroupMask))
          break;
    }

    InsertTailList( pleNode, &pScope->leScopeLink );
          
    *pScopeEntry = pScope;

#if 0
    Trace4(MCAST, "AddScope: added %s %ls (%d.%d.%d.%d/%d)", 
     GetLangName( idLanguage ),
     snScopeName,
     PRINT_IPADDR(ipGroupAddress),
     MaskToMaskLen(ipGroupMask) );
#endif
    Trace2(MCAST, "AddScope: added (%d.%d.%d.%d/%d)", 
     PRINT_IPADDR(ipGroupAddress),
     MaskToMaskLen(ipGroupMask) );
   
    return NO_ERROR;
}

DWORD
AssertScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    OUT PSCOPE_ENTRY *ppScopeEntry
    )
/*++
Arguments:
    ipGroupAddress - address part of the scope prefix
    ipGroupMask    - mask part of the scope prefix
    ppScopeEntry   - scope entry to return to caller
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE.
Called by: 
    SetScopeInfo()
    SNMPAddBoundaryToInterface()
Returns:
    NO_ERROR - success
    whatever AddScope() returns
--*/
{
    DWORD dwResult = NO_ERROR;

    *ppScopeEntry = FindScope(ipGroupAddress, ipGroupMask);

    if (! *ppScopeEntry) 
    {
        dwResult = AddScope(ipGroupAddress, ipGroupMask, ppScopeEntry);
    } 

    return dwResult;
}


DWORD
DeleteScope(
    IN PSCOPE_ENTRY pScope
    )
/*++
Routine Description:
    Remove all information about a given boundary.
Called by:
    SetScopeInfo(), SNMPDeleteBoundaryFromInterface()
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE
Returns:
    NO_ERROR
--*/
{
   Trace2( MCAST, "ENTERED DeleteScope: %d.%d.%d.%d/%d", 
    PRINT_IPADDR(pScope->ipGroupAddress),
    MaskToMaskLen(pScope->ipGroupMask) );

   if (pScope->ipGroupAddress == 0) {

      Trace0( MCAST, "LEFT DeleteScope" );
      return NO_ERROR; // already deleted
   }

   if (pScope->ulNumInterfaces > 0) 
   {
      //
      // Walk all interfaces looking for references.  It doesn't matter
      // whether this is inefficient, since it occurs extremely rarely,
      // if ever, and we don't care whether it takes a couple of seconds
      // to do.
      //
      DWORD dwBucketIdx;
      PLIST_ENTRY pleNode, pleNext;

      for (dwBucketIdx = 0; 
           dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE 
            && pScope->ulNumInterfaces > 0;
           dwBucketIdx++)
      {
         for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
              pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
              pleNode = pleNext)
         {
            BOUNDARY_ENTRY *pBoundary = CONTAINING_RECORD(pleNode, 
             BOUNDARY_ENTRY, leBoundaryLink);
  
            // Save pointer to next node, since we may delete the current one
            pleNext = pleNode->Flink;
  
            if (pBoundary->pScope == pScope) {

               // Delete boundary 
               RemoveEntryList(&(pBoundary->leBoundaryLink));
               pScope->ulNumInterfaces--;
               FREE(pBoundary);
            }
         }
      }
   }

   // Do the actual scope deletion
   RemoveEntryList(&(pScope->leScopeLink));
   pScope->ipGroupAddress = 0;
   pScope->ipGroupMask    = 0xFFFFFFFF;

   while (! IsListEmpty(&pScope->leNameList) )
   {
      DeleteScopeName(pScope->leNameList.Flink);
      pScope->ulNumNames--;
   }

   Trace0( MCAST, "LEFT DeleteScope" );

   return NO_ERROR;
}

//
// Routines to manipulate BOUNDARY_IF structures
//

BOUNDARY_IF *
FindBIfEntry(
    IN DWORD dwIfIndex
    )
/*++
Locks: 
    Assumes caller holds at least a read lock on BOUNDARY_TABLE
Called by: 
    AssertBIfEntry(), RmHasBoundary(), BindBoundaryInterface()
Returns:
    pointer to BOUNDARY_IF entry, if found
    NULL, if not found
--*/
{
    PLIST_ENTRY pleNode;
    BOUNDARY_IF *pIf;
    DWORD dwBucketIdx = BOUNDARY_HASH(dwIfIndex);

    for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
         pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
         pleNode = pleNode->Flink)
    {
         pIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF, leBoundaryIfLink);
         if (pIf->dwIfIndex == dwIfIndex)
            return pIf;
    }

    return NULL;
}

BOUNDARY_IF *
FindBIfEntryBySocket(
    IN SOCKET sMzapSocket
    )
{
    register PLIST_ENTRY pleNode;
    register DWORD dwBucketIdx;
    BOUNDARY_IF *pIf;

    for (dwBucketIdx = 0;
         dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE;
         dwBucketIdx++)
    {
        for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
             pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
             pleNode = pleNode->Flink)
        {
             pIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF, leBoundaryIfLink);

             if (pIf->sMzapSocket == sMzapSocket)
                return pIf;
        }
    }

    return NULL;
}



DWORD
AddBIfEntry(
    IN  DWORD         dwIfIndex,
    OUT PBOUNDARY_IF *ppBoundaryIf,
    IN  BOOL          bIsOperational
    )
/*++
Locks: 
    Assumes caller holds a write lock on BOUNDARY_TABLE
Called by: 
    AssertBIfEntry()
Returns:
    NO_ERROR on success
    ERROR_NOT_ENOUGH_MEMORY
--*/
{
    PLIST_ENTRY  pleNode;
    DWORD        dwBucketIdx, dwErr = NO_ERROR;
    BOUNDARY_IF *pBoundaryIf;

    Trace1(MCAST, "AddBIfEntry %x", dwIfIndex);

    dwBucketIdx = BOUNDARY_HASH(dwIfIndex);
    pBoundaryIf = MALLOC( sizeof(BOUNDARY_IF) );
    if (!pBoundaryIf)
       return ERROR_NOT_ENOUGH_MEMORY;

    pBoundaryIf->dwIfIndex = dwIfIndex;
    InitializeListHead(&pBoundaryIf->leBoundaryList);
    MzapInitBIf(pBoundaryIf);

    if (bIsOperational)
    {
        dwErr = MzapActivateBIf(pBoundaryIf);
    }

    // find entry in bucket's list to insert before
    for (pleNode =  g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
         pleNode isnot &g_bbScopeTable[dwBucketIdx].leInterfaceList;
         pleNode = pleNode->Flink) {
       BOUNDARY_IF *pPrevIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF,
        leBoundaryIfLink);
       
       if (pPrevIf->dwIfIndex > dwIfIndex)
          break;
    }

    InsertTailList( pleNode, &(pBoundaryIf->leBoundaryIfLink));

    // find entry in master list to insert before
    for (pleNode =  g_MasterInterfaceList.Flink;
         pleNode isnot &g_MasterInterfaceList;
         pleNode = pleNode->Flink) {
       BOUNDARY_IF *pPrevIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF,
        leBoundaryIfLink);
       
       if (pPrevIf->dwIfIndex > dwIfIndex)
          break;
    }

    InsertTailList( pleNode, &(pBoundaryIf->leBoundaryIfMasterLink));

    *ppBoundaryIf = pBoundaryIf;

    return dwErr;
}


DWORD
AssertBIfEntry(
    IN DWORD          dwIfIndex,
    OUT PBOUNDARY_IF *ppBoundaryIf,
    IN  BOOL          bIsOperational
    )
/*++
Locks: 
    Assumes caller holds a write lock on BOUNDARY_TABLE
Called by: 
    SetBoundaryInfo(), SNMPAddBoundaryToInterface()
--*/
{
    if ((*ppBoundaryIf = FindBIfEntry(dwIfIndex)) != NULL)
       return NO_ERROR;

    return AddBIfEntry(dwIfIndex, ppBoundaryIf, bIsOperational);
}

//
// Routines to manipulate BOUNDARY_ENTRY structures
//

BOUNDARY_ENTRY *
FindBoundaryEntry(
    BOUNDARY_IF *pBoundaryIf, 
    SCOPE_ENTRY *pScope
    )
/*++
Locks: 
    Assumes caller already holds at least a read lock on BOUNDARY_TABLE
Called by: 
    AssertBoundaryEntry()
Returns:
    pointer to BOUNDARY_ENTRY, if found
    NULL, if not found
--*/
{
    PLIST_ENTRY pleNode;

    for (pleNode = pBoundaryIf->leBoundaryList.Flink;
         pleNode isnot &(pBoundaryIf->leBoundaryList);
         pleNode = pleNode->Flink)
    {
        BOUNDARY_ENTRY *pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
         leBoundaryLink);
        if (pScope == &g_LocalScope || pScope == pBoundary->pScope)
           return pBoundary;
    }
    return NULL;
}

DWORD
AddBoundaryEntry(
    BOUNDARY_IF     *pBoundaryIf, 
    SCOPE_ENTRY     *pScope,
    PBOUNDARY_ENTRY *ppBoundary
    )
/*++
Called by: 
    AssertBoundaryEntry()
Locks:
    Assumes caller holds a write lock on BOUNDARY_TABLE
Returns:
    NO_ERROR on success
    ERROR_NOT_ENOUGH_MEMORY
--*/
{
    PLIST_ENTRY pleNode;

    Trace3(MCAST, "AddBoundaryEntry: If %x Scope %d.%d.%d.%d/%d", 
     pBoundaryIf->dwIfIndex,
     PRINT_IPADDR(pScope->ipGroupAddress),
     MaskToMaskLen(pScope->ipGroupMask) );

    if ((*ppBoundary = MALLOC( sizeof(BOUNDARY_ENTRY) )) == NULL)
       return ERROR_NOT_ENOUGH_MEMORY;

    (*ppBoundary)->pScope = pScope;

    // Search for entry after the new one
    for (pleNode = pBoundaryIf->leBoundaryList.Flink;
         pleNode isnot &pBoundaryIf->leBoundaryList;
         pleNode = pleNode->Flink) {
       BOUNDARY_ENTRY *pPrevRange = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
        leBoundaryLink);
       IPV4_ADDRESS ipAddress = pPrevRange->pScope->ipGroupAddress;
       IPV4_ADDRESS ipMask    = pPrevRange->pScope->ipGroupMask;
       
       if (ipAddress > pScope->ipGroupAddress
        || (ipAddress==pScope->ipGroupAddress && ipMask>pScope->ipGroupMask))
          break;
    }

    InsertTailList( pleNode, &((*ppBoundary)->leBoundaryLink));

    pScope->ulNumInterfaces++;

    return NO_ERROR;
}

DWORD
AssertBoundaryEntry(
    BOUNDARY_IF     *pBoundaryIf, 
    SCOPE_ENTRY     *pScope,
    PBOUNDARY_ENTRY *ppBoundary
    )
/*++
Called by: 
    SetBoundaryInfo()
Locks:
    Assumes caller holds a write lock on BOUNDARY_TABLE
Returns:
    NO_ERROR on success
    ERROR_NOT_ENOUGH_MEMORY
--*/
{
    if ((*ppBoundary = FindBoundaryEntry(pBoundaryIf, pScope)) != NULL)
       return NO_ERROR;

    return AddBoundaryEntry(pBoundaryIf, pScope, ppBoundary);
}

//
// Functions to manipulate boundaries
//

VOID
DeleteBoundaryFromInterface(pBoundary, pBoundaryIf)
    BOUNDARY_ENTRY *pBoundary;
    BOUNDARY_IF    *pBoundaryIf;
/*++
Called by:
    SetBoundaryInfo(), SNMPDeleteBoundaryFromInterface()
--*/
{
    Trace3(MCAST, "DeleteBoundaryFromInterface: If %x Scope %d.%d.%d.%d/%d", 
     pBoundaryIf->dwIfIndex,
     PRINT_IPADDR(pBoundary->pScope->ipGroupAddress),
     MaskToMaskLen(pBoundary->pScope->ipGroupMask) );

    RemoveEntryList(&(pBoundary->leBoundaryLink));
    pBoundary->pScope->ulNumInterfaces--;
    FREE(pBoundary);

    //
    // If there are no boundaries left, delete the pBoundaryIf.
    //
    if (IsListEmpty( &pBoundaryIf->leBoundaryList ))
    {
        // Remove the BoundaryIf
        MzapUninitBIf( pBoundaryIf );
        RemoveEntryList( &(pBoundaryIf->leBoundaryIfLink));
        RemoveEntryList( &(pBoundaryIf->leBoundaryIfMasterLink));
        FREE(pBoundaryIf);
    }
}

//
// Routines to process range information, which is what MGM deals with.
// It's much more efficient to pass range deltas to MGM than to pass
// prefixes, or original info, since overlapping boundaries might exist.
//

DWORD
AssertRange(
    IN OUT PLIST_ENTRY  pHead, 
    IN     IPV4_ADDRESS ipFirst,
    IN     IPV4_ADDRESS ipLast
    )
/*++
Called by:
    ConvertIfTableToRanges()
Locks:
    none
--*/
{
    PLIST_ENTRY  pleLast;
    RANGE_ENTRY *pRange;

    Trace2(MCAST, "AssertRange: (%d.%d.%d.%d - %d.%d.%d.%d)", 
     PRINT_IPADDR(ipFirst),
     PRINT_IPADDR(ipLast));

    //
    // Since we're calling this in <ipFirst,ipLast> order, the new
    // range may only overlap with the last range, if any.
    //

    pleLast = pHead->Blink;
    if (pleLast isnot pHead) 
    {
       RANGE_ENTRY *pPrevRange = CONTAINING_RECORD(pleLast, RANGE_ENTRY,
        leRangeLink);

       // See if it aggregates
       if (ntohl(ipFirst) <= ntohl(pPrevRange->ipLast) + 1) 
       { 
          if (ntohl(ipLast) > ntohl(pPrevRange->ipLast))
             pPrevRange->ipLast = ipLast;
          return NO_ERROR;
       }
    }

    //
    // Ok, no overlap, so add a new range
    //

    pRange = MALLOC( sizeof(RANGE_ENTRY) );
    if (pRange == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRange->ipFirst = ipFirst;
    pRange->ipLast  = ipLast;
    InsertTailList(pHead, &pRange->leRangeLink);

    return NO_ERROR;
}

VOID
ConvertIfTableToRanges(
    IN  DWORD       dwIfIndex,
    OUT PLIST_ENTRY pHead
    )
/*++
Routine Description:
    Go through the list of boundaries on a given interface, and
    compose an ordered list of non-overlapping ranges.
Called by:
    ConvertTableToRanges()
    SetBoundaryInfo(), SNMPAddBoundaryToInterface(), 
    SNMPDeleteBoundaryFromInterface()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE
--*/
{
    PLIST_ENTRY     pleNode;
    IPV4_ADDRESS    ipLastAddress;
    BOUNDARY_IF    *pBoundaryIf;
    BOUNDARY_ENTRY *pBoundary;

    Trace1( MCAST, "ENTERED ConvertIfTableToRanges: If=%x", dwIfIndex );

    InitializeListHead(pHead);

    pBoundaryIf = FindBIfEntry(dwIfIndex);
    if (pBoundaryIf) {
       for (pleNode = pBoundaryIf->leBoundaryList.Flink;
            pleNode isnot &pBoundaryIf->leBoundaryList;
            pleNode = pleNode->Flink) {
          pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
           leBoundaryLink);

          ipLastAddress = pBoundary->pScope->ipGroupAddress | 
                         ~pBoundary->pScope->ipGroupMask;
          AssertRange(pHead, pBoundary->pScope->ipGroupAddress,
           ipLastAddress);
       }

       // Finally, we also have one for the IPv4 Local Scope
       if ( !IsListEmpty( &pBoundaryIf->leBoundaryList ) ) {
           AssertRange(pHead, IPV4_LOCAL_SCOPE_ADDR,
            IPV4_LOCAL_SCOPE_ADDR | ~IPV4_LOCAL_SCOPE_MASK);
       }
    }

    Trace0( MCAST, "LEFT ConvertIfTableToRanges" );
}


DWORD
ConvertTableToRanges(
    OUT PLIST_ENTRY pIfHead
    )
/*++
Routine description:
    Calculate the list of blocked ranges on all interfaces.
Locks:
    BOUNDARY_TABLE for reading
--*/
{
    DWORD       i, dwErr = NO_ERROR;
    PLIST_ENTRY pleNode;
    BOUNDARY_IF *pBoundaryIf, *pRangeIf;

    InitializeListHead(pIfHead);

    ENTER_READER(BOUNDARY_TABLE);
    {
       // For each interface with boundaries...
       for (i=0; i<BOUNDARY_HASH_TABLE_SIZE; i++) {
          for (pleNode = g_bbScopeTable[i].leInterfaceList.Flink;
               pleNode isnot &g_bbScopeTable[i].leInterfaceList;
               pleNode = pleNode->Flink) {
             pBoundaryIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF,
              leBoundaryIfLink);
   
             // Add a node to the if range list 
             pRangeIf = MALLOC( sizeof(BOUNDARY_IF) );
             if (pRangeIf is NULL)
             {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
             }

             pRangeIf->dwIfIndex = pBoundaryIf->dwIfIndex;
             InsertTailList(pIfHead, &pRangeIf->leBoundaryIfLink);
      
             // Compose the range list for this interface
             ConvertIfTableToRanges(pBoundaryIf->dwIfIndex, 
              &pRangeIf->leBoundaryList);
          }
       }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    return dwErr;
}

VOID
GetRange(
    IN PLIST_ENTRY    pleNode, 
    IN PLIST_ENTRY    pHead,
    OUT PRANGE_ENTRY *ppRange, 
    OUT IPV4_ADDRESS *phipFirst, 
    OUT IPV4_ADDRESS *phipLast
    )
{
    if (pleNode isnot pHead) 
    {
       (*ppRange) = CONTAINING_RECORD(pleNode, RANGE_ENTRY, leRangeLink);
       *phipFirst = ntohl((*ppRange)->ipFirst);
       *phipLast  = ntohl((*ppRange)->ipLast);
    } 
    else 
    {
       (*ppRange) = NULL;
       *phipFirst = *phipLast = 0xFFFFFFFF;
    }
}

VOID
GetRangeIf(
    IN  PLIST_ENTRY   pleNode, 
    IN  PLIST_ENTRY   pHead,
    OUT PBOUNDARY_IF *ppRangeIf, 
    OUT ULONG        *pulIfIndex
    )
{
    if (pleNode isnot pHead) 
    {
       (*ppRangeIf) = CONTAINING_RECORD(pleNode, BOUNDARY_IF, leBoundaryIfLink);
       *pulIfIndex = (*ppRangeIf)->dwIfIndex;
    } 
    else 
    {
       (*ppRangeIf) = NULL;
       *pulIfIndex = 0xFFFFFFFF;
    }
}

VOID
FreeRangeList(
    IN PLIST_ENTRY pHead
    )
/*++
Routine description:
    Free up space from a range list
Called by:
    ProcessIfRangeDeltas()
Locks:
    none
--*/
{
    RANGE_ENTRY *pRange;
    PLIST_ENTRY  pleNode;

    for (pleNode = pHead->Flink;
         pleNode isnot pHead;
         pleNode = pHead->Flink) 
    {
       pRange = CONTAINING_RECORD(pleNode, RANGE_ENTRY, leRangeLink);
       RemoveEntryList(&pRange->leRangeLink);
       FREE(pRange);
    }
}

VOID
FreeIfRangeLists(
    IN PLIST_ENTRY pHead
    )
/*++
Routine description:
    Free all entries in the list, as well as the list of ranges off each entry.
Called by:
    ProcessRangeDeltas()
Locks:
    none
--*/
{
    BOUNDARY_IF *pRangeIf;
    PLIST_ENTRY  pleNode;

    for (pleNode = pHead->Flink;
         pleNode isnot pHead;
         pleNode = pHead->Flink) 
    {
       pRangeIf = CONTAINING_RECORD(pleNode, BOUNDARY_IF, leBoundaryIfLink);
       RemoveEntryList(&pRangeIf->leBoundaryIfLink);
       FreeRangeList(&pRangeIf->leBoundaryList);
       FREE(pRangeIf);
    }
}

//
//   Check if the interface
//   is the RAS Server Interface in which case, the 
//   callback should be invoked for all clients connected
//   and the NEXT HOP address should be set to the client
//   address.  Otherwise zero should be fine as NHOP
//
VOID
BlockGroups(
    IN IPV4_ADDRESS ipFirst, 
    IN IPV4_ADDRESS ipLast, 
    IN DWORD        dwIfIndex
    )
{
    IPV4_ADDRESS ipNextHop;
    PICB         picb;
    PLIST_ENTRY  pleNode;

    ENTER_READER(ICB_LIST);
    do {

        // Look up the type of this interface

        picb = InterfaceLookupByIfIndex(dwIfIndex);

        if (picb==NULL)
            break;


        // If interface is not an NBMA interface, just block on the interface
        // Currently, the only NBMA-like interface is the "internal" interface

        if (picb->ritType isnot ROUTER_IF_TYPE_INTERNAL)
        {
            Trace3( MCAST, 
                    "Blocking [%d.%d.%d.%d-%d.%d.%d.%d] on if %x",
                    PRINT_IPADDR(ipFirst),
                    PRINT_IPADDR(ipLast),
                    dwIfIndex );

            g_pfnMgmBlockGroups(ipFirst, ipLast, dwIfIndex, 0);

            break;
        }
    
        // For NBMA interfaces, need to block on each next hop
    
        //    to enumerate all next hops on the internal interface, 
        //    we have to walk the PICB list looking for entries with
        //    an ifIndex of -1.
    
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList;
             pleNode = pleNode->Flink)
        {
            picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);
    
            if (picb->ritType isnot ROUTER_IF_TYPE_CLIENT)
                continue;

            Trace4( MCAST, 
                    "Blocking [%d.%d.%d.%d-%d.%d.%d.%d] on if %x nh %d.%d.%d.%d",
                    PRINT_IPADDR(ipFirst),
                    PRINT_IPADDR(ipLast),
                    dwIfIndex,
                    PRINT_IPADDR(picb->dwRemoteAddress) );

            g_pfnMgmBlockGroups( ipFirst, 
                                 ipLast, 
                                 dwIfIndex, 
                                 picb->dwRemoteAddress );
        }
    } while(0);
    EXIT_LOCK(ICB_LIST);
}

//
//   Check if the interface
//   is the RAS Server Interface in which case, the 
//   callback should be invoked for all clients connected
//   and the NEXT HOP address should be set to the client
//   address.  Otherwise zero should be fine as NHOP
//
VOID
UnblockGroups(
    IN IPV4_ADDRESS ipFirst, 
    IN IPV4_ADDRESS ipLast, 
    IN DWORD        dwIfIndex
    )
{
    IPV4_ADDRESS ipNextHop;
    PICB         picb;
    PLIST_ENTRY  pleNode;

    ENTER_READER(ICB_LIST);
    do {

        // Look up the type of this interface

        picb = InterfaceLookupByIfIndex(dwIfIndex);

        if (picb == NULL ) 
            break;
        
        // If interface is not an NBMA interface, just block on the interface
        // Currently, the only NBMA-like interface is the "internal" interface

        if (picb->ritType isnot ROUTER_IF_TYPE_INTERNAL)
        {
            Trace3( MCAST, 
                    "Unblocking [%d.%d.%d.%d-%d.%d.%d.%d] on if %x",
                    PRINT_IPADDR(ipFirst),
                    PRINT_IPADDR(ipLast),
                    dwIfIndex );

            g_pfnMgmUnBlockGroups(ipFirst, ipLast, dwIfIndex, 0);

            break;
        }
    
        // For NBMA interfaces, need to block on each next hop
    
        //    to enumerate all next hops on the internal interface, 
        //    we have to walk the PICB list looking for entries with
        //    an ifIndex of -1.
    
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList;
             pleNode = pleNode->Flink)
        {
            picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);
    
            if (picb->ritType isnot ROUTER_IF_TYPE_CLIENT)
                continue;

            Trace4( MCAST, 
                    "Unblocking [%d.%d.%d.%d-%d.%d.%d.%d] on if %x nh %d.%d.%d.%d",
                    PRINT_IPADDR(ipFirst),
                    PRINT_IPADDR(ipLast),
                    dwIfIndex,
                    PRINT_IPADDR(picb->dwRemoteAddress) );

            g_pfnMgmUnBlockGroups( ipFirst, 
                                   ipLast, 
                                   dwIfIndex, 
                                   picb->dwRemoteAddress );
        }
    } while(0);
    EXIT_LOCK(ICB_LIST);
}

VOID
ProcessIfRangeDeltas(
    IN DWORD       dwIfIndex,
    IN PLIST_ENTRY pOldHead,
    IN PLIST_ENTRY pNewHead
    )
/*++
Routine Description:
    Go through the previous and current lists of ranges, and inform
    MGM of any differences found.
Called by:
    SetBoundaryInfo(), SNMPAddBoundaryToInterface(),
    SNMPDeleteBoundaryFromInterface()
Locks:
    none
--*/
{
    PLIST_ENTRY pleOld = pOldHead->Flink,
                pleNew = pNewHead->Flink;
    RANGE_ENTRY *pOld, *pNew;
    IPV4_ADDRESS hipOldFirst, hipOldLast, hipNewFirst, hipNewLast;
    IPV4_ADDRESS hipLast;

    // Get ranges in host order fields
    GetRange(pleOld, pOldHead, &pOld, &hipOldFirst, &hipOldLast);
    GetRange(pleNew, pNewHead, &pNew, &hipNewFirst, &hipNewLast);

    // Loop until we hit the end of both lists
    while (pOld || pNew) 
    {

       // See if there's a new range to block
       if (pNew && hipNewFirst < hipOldFirst) 
       {
          hipLast = MIN(hipNewLast, hipOldFirst-1);
          BlockGroups(pNew->ipFirst, htonl(hipLast), dwIfIndex);
          hipNewFirst   = hipOldFirst;
          pNew->ipFirst = htonl(hipNewFirst);
          if (hipNewFirst > hipNewLast) 
          {
             // advance new
             pleNew = pleNew->Flink;
             GetRange(pleNew, pNewHead, &pNew, &hipNewFirst, &hipNewLast);
          }
       }

       // See if there's an old range to unblock
       if (pOld && hipOldFirst < hipNewFirst) 
       {
          hipLast = MIN(hipOldLast, hipNewFirst-1);
          UnblockGroups(pOld->ipFirst, htonl(hipLast), dwIfIndex);
          hipOldFirst   = hipNewFirst;
          pOld->ipFirst = htonl(hipOldFirst);
          if (hipOldFirst > hipOldLast) 
          {
             // advance old
             pleOld = pleOld->Flink;
             GetRange(pleOld, pOldHead, &pOld, &hipOldFirst, &hipOldLast);
          }
       }

       // See if there's an unchanged range to skip
       if (pOld && pNew && hipOldFirst == hipNewFirst) 
       {
          hipLast = MIN(hipOldLast, hipNewLast);
          hipOldFirst   = hipLast+1;
          pOld->ipFirst = htonl(hipOldFirst);
          if (hipOldFirst > hipOldLast) 
          {
             // advance old
             pleOld = pleOld->Flink;
             GetRange(pleOld, pOldHead, &pOld, &hipOldFirst, &hipOldLast);
          }
          hipNewFirst   = hipLast+1;
          pNew->ipFirst = htonl(hipNewFirst);
          if (hipNewFirst > hipNewLast) 
          {
             // advance new
             pleNew = pleNew->Flink;
             GetRange(pleNew, pNewHead, &pNew, &hipNewFirst, &hipNewLast);
          }
       }
    }
    
    FreeRangeList(pOldHead);
    FreeRangeList(pNewHead);
}

VOID
ProcessRangeDeltas(
    IN PLIST_ENTRY pOldIfHead,
    IN PLIST_ENTRY pNewIfHead
    )
{
    PLIST_ENTRY pleOldIf = pOldIfHead->Flink,
                pleNewIf = pNewIfHead->Flink;
    BOUNDARY_IF *pOldIf, *pNewIf;
    ULONG       ulOldIfIndex, ulNewIfIndex;
    LIST_ENTRY  emptyList;

    GetRangeIf(pleOldIf, pOldIfHead, &pOldIf, &ulOldIfIndex);
    GetRangeIf(pleNewIf, pNewIfHead, &pNewIf, &ulNewIfIndex);

    InitializeListHead(&emptyList);

    // Loop until we hit the end of both lists
    while (pOldIf || pNewIf) 
    {

       // See if there's a new interface without old boundaries
       if (pNewIf && ulNewIfIndex < ulOldIfIndex) 
       {
          // process it
          ProcessIfRangeDeltas(ulNewIfIndex, &emptyList,
           &pNewIf->leBoundaryList);

          // advance new
          pleNewIf = pleNewIf->Flink;
          GetRangeIf(pleNewIf, pNewIfHead, &pNewIf, &ulNewIfIndex);
       }

       // See if there's an old interface without new boundaries 
       if (pOldIf && ulOldIfIndex < ulNewIfIndex) 
       {
          // process it
          ProcessIfRangeDeltas(ulOldIfIndex, &pOldIf->leBoundaryList, 
           &emptyList);

          // advance old
          pleOldIf = pleOldIf->Flink;
          GetRangeIf(pleOldIf, pOldIfHead, &pOldIf, &ulOldIfIndex);
       }

       // See if there's an ifindex to change
       if (pOldIf && pNewIf && ulOldIfIndex == ulNewIfIndex) 
       {
          // process it
          ProcessIfRangeDeltas(ulOldIfIndex, &pOldIf->leBoundaryList, 
           &pNewIf->leBoundaryList);

          // advance old
          pleOldIf = pleOldIf->Flink;
          GetRangeIf(pleOldIf, pOldIfHead, &pOldIf, &ulOldIfIndex);
          
          // advance new
          pleNewIf = pleNewIf->Flink;
          GetRangeIf(pleNewIf, pNewIfHead, &pNewIf, &ulNewIfIndex);
       }
    }
    
    FreeIfRangeLists(pOldIfHead);
    FreeIfRangeLists(pNewIfHead);
}

VOID
ParseScopeInfo(
    IN  PBYTE                  pBuffer,
    IN  ULONG                  ulNumScopes,
    OUT PSCOPE_ENTRY          *ppScopes
    )
/*++
Description:
   Routines to parse registry info into a pre-allocated array.
   Space for names will be dynamically allocated by this function,
   and it is the caller's responsibility to free them.
Called by:
    SetScopeInfo()
--*/
{
    DWORD             i, j, dwLen, dwNumNames, dwLanguage, dwFlags;
    SCOPE_NAME_BUFFER pScopeName;
    PSCOPE_ENTRY      pScopes;

    *ppScopes = pScopes = MALLOC( ulNumScopes * sizeof(SCOPE_ENTRY) );

    for (i=0; i<ulNumScopes; i++) 
    {
        // Copy group address, and mask
        dwLen = 2 * sizeof(IPV4_ADDRESS);
        CopyMemory(&pScopes[i].ipGroupAddress, pBuffer, dwLen);
        pBuffer += dwLen;

        // Get flags
        CopyMemory(&dwFlags, pBuffer, sizeof(DWORD));
        pBuffer += sizeof(DWORD);
        pScopes[i].bDivisible = dwFlags;
 
        CopyMemory(&dwNumNames, pBuffer, sizeof(DWORD));
        pBuffer += sizeof(DWORD);
 
        pScopes[i].ulNumInterfaces = 0; // this value is ignored
        pScopes[i].ulNumNames = 0;
        InitializeListHead( &pScopes[i].leNameList );
 
        for (j=0; j<dwNumNames; j++) 
        {
            // Set language name
            CopyMemory(&dwLanguage, pBuffer, sizeof(dwLanguage));
            pBuffer += sizeof(dwLanguage);

            // Get scope name length
            CopyMemory(&dwLen, pBuffer, sizeof(DWORD));
            pBuffer += sizeof(DWORD);
            if (dwLen > MAX_SCOPE_NAME_LEN)
            {
                Trace2(MCAST, 
                       "ERROR %d-char scope name in registry, truncated to %d",
                       dwLen, MAX_SCOPE_NAME_LEN);
                dwLen = MAX_SCOPE_NAME_LEN;
            }
     
            // Set scope name
            wcsncpy(pScopeName, (SCOPE_NAME)pBuffer, dwLen);
            pScopeName[ dwLen ] = '\0';
            pBuffer += dwLen * SNCHARSIZE;
    
            AssertScopeName( &pScopes[i], (LANGID)dwLanguage, pScopeName );
        }
    }
}

VOID
FreeScopeInfo(
    PSCOPE_ENTRY pScopes,
    DWORD        dwNumScopes
    )
{
    PLIST_ENTRY pleNode;
    DWORD       i;

    for (i=0; i<dwNumScopes; i++)
    {
        while (!IsListEmpty(&pScopes[i].leNameList)) 
        {
            DeleteScopeName( pScopes[i].leNameList.Flink );
        }
    }

    FREE(pScopes);
}

DWORD
SetScopeInfo(
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )
/*++
Routine Description:
    Sets the scope info associated with the router.
    First we add the scopes present in the scope info.  Then we
    enumerate the scopes and delete those that we don't find in the
    scope info.
Locks:
    BOUNDARY_TABLE for writing
Called by:
    InitRouter() in init.c
    SetGlobalInfo() in iprtrmgr.c
--*/
{
    DWORD             dwResult = NO_ERROR;
    DWORD             dwNumScopes, i, j;
    PRTR_TOC_ENTRY    pToc;
    SCOPE_ENTRY      *pScopes;
    BOOL              bFound;
    SCOPE_ENTRY      *pScope;
    BYTE             *pBuffer;
    LIST_ENTRY        leOldIfRanges, leNewIfRanges;
    PSCOPE_NAME_ENTRY pName;
    PLIST_ENTRY       pleNode;

    Trace0( MCAST, "ENTERED SetScopeInfo" );

    pToc = GetPointerToTocEntry(IP_MCAST_BOUNDARY_INFO, pInfoHdr);
    if (pToc is NULL) {
       // No TOC means no change
       Trace0( MCAST, "LEFT SetScopeInfo" );
       return NO_ERROR;
    }

    //
    // This call wouldn't be needed if we saved this info in the
    // BOUNDARY_IF structure, but since it should rarely, if ever,
    // change, we won't worry about it for now.
    //
    dwResult = ConvertTableToRanges(&leOldIfRanges);
    if (dwResult isnot NO_ERROR) {
       return dwResult;
    }

    if (pToc->InfoSize is 0) 
    {
       StopMZAP();

       // delete all scopes
       ENTER_WRITER(BOUNDARY_TABLE);
       {
          for (i=0; i<MAX_SCOPES; i++)
             DeleteScope(&g_scopeEntry[i]);
       }
       EXIT_LOCK(BOUNDARY_TABLE);

       // Inform MGM of deltas
       dwResult = ConvertTableToRanges(&leNewIfRanges);
       if (dwResult isnot NO_ERROR) 
       {
          return dwResult;
       }

       ProcessRangeDeltas(&leOldIfRanges, &leNewIfRanges);

       Trace0( MCAST, "LEFT SetScopeInfo" );
       return NO_ERROR;
    }

    pBuffer = (PBYTE)GetInfoFromTocEntry(pInfoHdr, pToc);
    if (pBuffer is NULL)
    {
       return ERROR_INSUFFICIENT_BUFFER;
    }

    // Scope count is stored in first DWORD
    dwNumScopes = *((PDWORD) pBuffer);
    pBuffer += sizeof(DWORD);

    ParseScopeInfo(pBuffer, dwNumScopes, &pScopes);

    ENTER_WRITER(BOUNDARY_TABLE);
    {
       //
       // Add all the new scopes
       //

       for (i=0; i<dwNumScopes; i++) 
       {
          dwResult = AssertScope( pScopes[i].ipGroupAddress, 
                                  pScopes[i].ipGroupMask, 
                                  &pScope );

          if (!pScope)
          {
              Trace2( MCAST, 
                      "Bad scope prefix %d.%d.%d.%d/%d.%d.%d.%d",
                      PRINT_IPADDR(pScopes[i].ipGroupAddress),
                      PRINT_IPADDR(pScopes[i].ipGroupMask) );

              continue;
          }

          pScope->bDivisible = pScopes[i].bDivisible;

          for (pleNode = pScopes[i].leNameList.Flink;
               pleNode isnot &pScopes[i].leNameList;
               pleNode = pleNode->Flink)
          {
              pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);

              AssertScopeName( pScope, pName->idLanguage, pName->snScopeName );
          }
       }

       //
       // Now enumerate the scopes, deleting the scopes that are not in the
       // new list.
       //
       for (i=0; i<MAX_SCOPES; i++) 
       {
          pScope = &g_scopeEntry[i];

          if (pScope->ipGroupAddress == 0)
             continue; // not active

          bFound = FALSE;
          for (j=0; j<dwNumScopes; j++) 
          {
             if (pScopes[j].ipGroupAddress == pScope->ipGroupAddress
              && pScopes[j].ipGroupMask    == pScope->ipGroupMask ) 
             {
                bFound = TRUE;
                break;
             }
          }
   
          if (!bFound)
             DeleteScope(pScope);
       }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Free scopes and names
    FreeScopeInfo(pScopes, dwNumScopes);

    dwResult = ConvertTableToRanges(&leNewIfRanges);
    if (dwResult isnot NO_ERROR) {
       return dwResult;
    }

    ProcessRangeDeltas(&leOldIfRanges, &leNewIfRanges);

    Trace0( MCAST, "LEFT SetScopeInfo" );

    return NO_ERROR;
}

DWORD
GetScopeInfo(
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    )
/*++
Routine Description:
    Called to get a copy of the scope information to write into the
    registry.
Locks:
    BOUNDARY_TABLE for reading
Arguments:
    pToc            Space to fill in the TOC entry (may be NULL)
    pdwTocIndex     Pointer to TOC index to be incremented if TOC written
    pBuffer         Pointer to buffer into which info is to be written
    pInfoHdr        Pointer to info block header for offset computation
    pdwBufferSize   [IN]  Size of the buffer pointed to by pBuffer
                    [OUT] Size of data copied out, or size of buffer needed
Called by:
    GetGlobalConfiguration() in info.c
Return Value:
    NO_ERROR                    Buffer of size *pdwBufferSize was copied out
    ERROR_INSUFFICIENT_BUFFER   The buffer was too small to copy out the info
                                The size of buffer needed is in *pdwBufferSize
--*/
{
    DWORD             i, dwSizeReqd, dwNumScopes, dwLen, dwNumNames,
                      dwLanguage, dwFlags;
    PLIST_ENTRY       pleNode, pleNode2;
    PSCOPE_ENTRY      pScope;
    PSCOPE_NAME_ENTRY pName;

    dwSizeReqd = sizeof(DWORD);
    dwNumScopes = 0;

    ENTER_READER(BOUNDARY_TABLE);
    {
        //
        // Calculate size required
        //

        for (pleNode = g_MasterScopeList.Flink;
             pleNode isnot &g_MasterScopeList;
             pleNode = pleNode->Flink) 
        {
           pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

           if ( !pScope->ipGroupAddress )
              continue; // not active

           dwSizeReqd += 2*sizeof(IPV4_ADDRESS) + 2*sizeof(DWORD);

           for (pleNode2 = pScope->leNameList.Flink;
                pleNode2 isnot &pScope->leNameList;
                pleNode2 = pleNode2->Flink)
           {
               pName = CONTAINING_RECORD( pleNode2, 
                                          SCOPE_NAME_ENTRY, 
                                          leNameLink );

               dwSizeReqd += (DWORD)(2 * sizeof(DWORD)
                             + sn_strlen(pName->snScopeName) * SNCHARSIZE);
           }

           dwNumScopes++;
        }
        if (dwNumScopes) {
           dwSizeReqd += sizeof(DWORD); // space for scope count
        }
 
        // 
        // Increment TOC index by number of TOC entries needed
        // 
        
        if (pdwTocIndex && dwSizeReqd>0)
           (*pdwTocIndex)++;
 
        if (dwSizeReqd > *pdwBufferSize) 
        {
           *pdwBufferSize = dwSizeReqd;
           EXIT_LOCK(BOUNDARY_TABLE);
           return ERROR_INSUFFICIENT_BUFFER;
        }
 
        *pdwBufferSize = dwSizeReqd;
 
        if (pToc) 
        {
            //pToc->InfoVersion = IP_MCAST_BOUNDARY_INFO;
            pToc->InfoType = IP_MCAST_BOUNDARY_INFO;
            pToc->Count    = 1; // single variable-sized opaque block
            pToc->InfoSize = dwSizeReqd;
            pToc->Offset   = (ULONG)(pBuffer - (PBYTE) pInfoHdr);
        }
 
        if (pBuffer)
        {

            //
            // Add scope count
            //

            CopyMemory(pBuffer, &dwNumScopes, sizeof(DWORD));
            pBuffer += sizeof(DWORD);

            //
            // Go through and get each scope
            //
    
            for (pleNode = g_MasterScopeList.Flink;
                 pleNode isnot &g_MasterScopeList;
                 pleNode = pleNode->Flink) 
            {
                pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

                if ( !pScope->ipGroupAddress )
                   continue; // not active
      
                // Copy scope address, and mask
                dwLen = 2 * sizeof(IPV4_ADDRESS);
                CopyMemory(pBuffer, &pScope->ipGroupAddress, dwLen);
                pBuffer += dwLen;

                // Copy flags
                dwFlags = pScope->bDivisible;
                CopyMemory(pBuffer, &dwFlags, sizeof(dwFlags));
                pBuffer += sizeof(dwFlags);

                // Copy # of names
                CopyMemory(pBuffer, &pScope->ulNumNames, sizeof(DWORD));
                pBuffer += sizeof(DWORD);
     
                for (pleNode2 = pScope->leNameList.Flink;
                     pleNode2 isnot &pScope->leNameList;
                     pleNode2 = pleNode2->Flink)
                {
                    pName = CONTAINING_RECORD( pleNode2, 
                                               SCOPE_NAME_ENTRY, 
                                               leNameLink );

                    // Save language
                    dwLanguage = pName->idLanguage;
                    CopyMemory(pBuffer, &dwLanguage, sizeof(dwLanguage));
                    pBuffer += sizeof(dwLanguage);
    
                    // Copy scope name (save length in words)
                    dwLen = sn_strlen(pName->snScopeName);
                    CopyMemory(pBuffer, &dwLen, sizeof(DWORD));
                    pBuffer += sizeof(DWORD);
                    dwLen *= SNCHARSIZE;
                    CopyMemory(pBuffer, pName->snScopeName, dwLen);
                    pBuffer += dwLen;
                }
            }
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    return NO_ERROR;
}

DWORD
SetBoundaryInfo(
    PICB                   picb,
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )
/*++
Routine Description:
    Sets the boundary info associated with an interface.
    First we add the boundaries present in the boundary info.  Then we
    enumerate the boundaries and delete those that we don't find in the
    boundary info.
Arguments:
    picb        The ICB of the interface
Called by:
    AddInterface() in iprtrmgr.c
    SetInterfaceInfo() in iprtrmgr.c
Locks:
    BOUNDARY_TABLE for writing
--*/
{
    DWORD            dwResult = NO_ERROR,
                     dwNumBoundaries, i, j;

    PRTR_TOC_ENTRY   pToc;

    PMIB_BOUNDARYROW pBoundaries;

    BOOL             bFound;

    BOUNDARY_ENTRY  *pBoundary;

    SCOPE_ENTRY     *pScope;

    LIST_ENTRY       leOldRanges, 
                     leNewRanges,
                    *pleNode, 
                    *pleNext;

    BOUNDARY_IF     *pBoundaryIf;

    Trace1( MCAST, "ENTERED SetBoundaryInfo for If %x", picb->dwIfIndex );

    pToc = GetPointerToTocEntry(IP_MCAST_BOUNDARY_INFO, pInfoHdr);

    if (pToc is NULL) 
    {
       // No TOC means no change
       Trace0( MCAST, "LEFT SetBoundaryInfo" );
       return NO_ERROR;
    }

    dwNumBoundaries = pToc->Count;

    ENTER_WRITER(BOUNDARY_TABLE);
    {

    //
    // This call wouldn't be needed if we saved this info in the
    // BOUNDARY_IF structure, but since it should rarely, if ever,
    // change, we won't worry about it for now.
    //
        ConvertIfTableToRanges(picb->dwIfIndex, &leOldRanges);

        if (pToc->InfoSize is 0) 
        {
            // Delete all boundaries on this interface
            pBoundaryIf = FindBIfEntry(picb->dwIfIndex);

            if (pBoundaryIf) 
            {
                for (pleNode = pBoundaryIf->leBoundaryList.Flink;
                     pleNode isnot &pBoundaryIf->leBoundaryList;
                     pleNode = pBoundaryIf->leBoundaryList.Flink) 
                {
                   pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
                    leBoundaryLink);

                   DeleteBoundaryFromInterface(pBoundary, pBoundaryIf);
                }
             }
        } 
        else 
        {
            pBoundaries = (PMIB_BOUNDARYROW)GetInfoFromTocEntry(pInfoHdr, pToc);

            dwResult = AssertBIfEntry(picb->dwIfIndex, &pBoundaryIf,
                (picb->dwOperationalState is IF_OPER_STATUS_OPERATIONAL));

            // Add all the new boundaries
            for (i=0; i<dwNumBoundaries; i++) 
            {
                dwResult = AssertScope( pBoundaries[i].dwGroupAddress,
                                        pBoundaries[i].dwGroupMask,
                                        &pScope );
                if (pScope)
                {
                   dwResult = AssertBoundaryEntry( pBoundaryIf, 
                                                   pScope, 
                                                   &pBoundary);
                }
            }

            //
            // Now enumerate the boundaries, deleting the boundaries that are 
            // not in the new list.
            //
   
            for (pleNode = pBoundaryIf->leBoundaryList.Flink;
                 pleNode isnot &pBoundaryIf->leBoundaryList;
                 pleNode = pleNext) 
            {
               pleNext = pleNode->Flink;
               pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
                leBoundaryLink);
               pScope = pBoundary->pScope;
               bFound = FALSE;
               for (j=0; j<dwNumBoundaries; j++) 
               {
                  if (pBoundaries[j].dwGroupAddress == pScope->ipGroupAddress
                   && pBoundaries[j].dwGroupMask    == pScope->ipGroupMask ) 
                  {
                     bFound = TRUE;
                     break;
                  }
               }
        
               if (!bFound)
                  DeleteBoundaryFromInterface(pBoundary, pBoundaryIf);
            }
        }
     
        ConvertIfTableToRanges(picb->dwIfIndex, &leNewRanges);
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Inform MGM of deltas 
    ProcessIfRangeDeltas(picb->dwIfIndex, &leOldRanges, &leNewRanges);

    StartMZAP();

    Trace0( MCAST, "LEFT SetBoundaryInfo" );

    return NO_ERROR;
}

DWORD
GetMcastLimitInfo(
    IN     PICB                   picb,
    OUT    PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    OUT    PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    )
/*++
Routine Description:
    Called to get a copy of the limit information to write into the
    registry.
Arguments:
    picb            Interface entry
    pToc            Space to fill in the TOC entry (may be NULL)
    pdwTocIndex     Pointer to TOC index to be incremented if TOC written
    pBuffer         Pointer to buffer into which info is to be written
    pInfoHdr        Pointer to info block header for offset computation
    pdwBufferSize   [IN]  Size of the buffer pointed to by pBuffer
                    [OUT] Size of data copied out, or size of buffer needed
Called by:
    GetInterfaceConfiguration() in info.c
Return Value:
    NO_ERROR                    Buffer of size *pdwBufferSize was copied out
    ERROR_INSUFFICIENT_BUFFER   The buffer was too small to copy out the info
                                The size of buffer needed is in *pdwBufferSize
--*/
{
    DWORD           i, dwLen, dwSizeReqd, dwNumBoundaries;
    PLIST_ENTRY     pleNode;
    PMIB_MCAST_LIMIT_ROW pLimit;

    dwSizeReqd = 0;
    dwNumBoundaries = 0;

    if (picb->dwMcastTtl < 2 and picb->dwMcastRateLimit is 0)
    {
        // No block needed, since values are default
        *pdwBufferSize = 0;
        return NO_ERROR;        
    }

    if (pdwTocIndex)
       (*pdwTocIndex)++;

    if (*pdwBufferSize < sizeof (MIB_MCAST_LIMIT_ROW))
    {
        *pdwBufferSize = sizeof(MIB_MCAST_LIMIT_ROW);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if (pToc)
    {
        //pToc->InfoVersion = IP_MCAST_BOUNDARY_INFO;
        pToc->InfoSize = sizeof(MIB_MCAST_LIMIT_ROW);
        pToc->InfoType = IP_MCAST_LIMIT_INFO;
        pToc->Count    = 1;
        pToc->Offset   = (DWORD)(pBuffer - (PBYTE) pInfoHdr);
    }

    *pdwBufferSize = sizeof(MIB_MCAST_LIMIT_ROW);

    pLimit              = (PMIB_MCAST_LIMIT_ROW)pBuffer;
    pLimit->dwTtl       = picb->dwMcastTtl;
    pLimit->dwRateLimit = picb->dwMcastRateLimit;

    return NO_ERROR;
}

DWORD
GetBoundaryInfo(
    IN     PICB                   picb,
    OUT    PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    OUT    PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    )
/*++
Routine Description:
    Called to get a copy of the boundary information to write into the
    registry.
Locks:
    BOUNDARY_TABLE for reading
Arguments:
    picb            Interface entry
    pToc            Space to fill in the TOC entry (may be NULL)
    pdwTocIndex     Pointer to TOC index to be incremented if TOC written
    pBuffer         Pointer to buffer into which info is to be written
    pInfoHdr        Pointer to info block header for offset computation
    pdwBufferSize   [IN]  Size of the buffer pointed to by pBuffer
                    [OUT] Size of data copied out, or size of buffer needed
Called by:
    GetInterfaceConfiguration() in info.c
Return Value:
    NO_ERROR                    Buffer of size *pdwBufferSize was copied out
    ERROR_INSUFFICIENT_BUFFER   The buffer was too small to copy out the info
                                The size of buffer needed is in *pdwBufferSize
--*/

{
    DWORD           i, dwLen, dwSizeReqd, dwNumBoundaries;
    PLIST_ENTRY     pleNode;
    BOUNDARY_ENTRY *pBoundary;
    MIB_BOUNDARYROW BoundaryRow;
    BOUNDARY_IF    *pIf;

    dwSizeReqd = 0;
    dwNumBoundaries = 0;

    ENTER_READER(BOUNDARY_TABLE);
    {
       pIf = FindBIfEntry(picb->dwIfIndex);
       if (!pIf) 
       {
          *pdwBufferSize = 0;
          EXIT_LOCK(BOUNDARY_TABLE);
          return NO_ERROR;
       }

       //
       // Calculate size required.  We could have stored the count
       // in the boundary entry, but we expect a pretty small number
       // of boundaries (1 or 2) so use brute force for now.
       //

       for (pleNode = pIf->leBoundaryList.Flink;
            pleNode isnot &pIf->leBoundaryList;
            pleNode = pleNode->Flink) 
       {
          dwNumBoundaries++;
       }

       dwSizeReqd += dwNumBoundaries * sizeof(MIB_BOUNDARYROW);

       //
       // Increment TOC index by number of TOC entries needed
       //

       if (pdwTocIndex && dwSizeReqd>0)
          (*pdwTocIndex)++;

       if (dwSizeReqd > *pdwBufferSize) 
       {
          *pdwBufferSize = dwSizeReqd;
          EXIT_LOCK(BOUNDARY_TABLE);
          return ERROR_INSUFFICIENT_BUFFER;
       }

       *pdwBufferSize = dwSizeReqd;

       if (pToc)
       {
           //pToc->InfoVersion = sizeof(MIB_BOUNDARYROW);
           pToc->InfoSize = sizeof(MIB_BOUNDARYROW);
           pToc->InfoType = IP_MCAST_BOUNDARY_INFO;
           pToc->Count    = dwNumBoundaries;
           pToc->Offset   = (DWORD)(pBuffer - (PBYTE) pInfoHdr);
       }

       // Go through and copy each boundary
       for (pleNode = pIf->leBoundaryList.Flink;
            pleNode isnot &pIf->leBoundaryList;
            pleNode = pleNode->Flink) 
       {
          pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
              leBoundaryLink);

          BoundaryRow.dwGroupAddress = pBoundary->pScope->ipGroupAddress;
          BoundaryRow.dwGroupMask    = pBoundary->pScope->ipGroupMask;

          CopyMemory(pBuffer, &BoundaryRow, sizeof(MIB_BOUNDARYROW));
          pBuffer += sizeof(MIB_BOUNDARYROW);
       }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    return NO_ERROR;
}




//
// Functions used by SNMP
//

DWORD
SNMPDeleteScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask
    )
/*++
Called by: 
Locks: 
    BOUNDARY_TABLE for writing.
    ICB_LIST and then PROTOCOL_CB_LIST for writing (for saving to registry).
Returns:
    ERROR_INVALID_PARAMETER if trying to delete the local scope
    whatever DeleteScope() returns
    whatever ProcessSaveGlobalConfigInfo() returns
--*/
{
    DWORD        dwErr = NO_ERROR;
    PSCOPE_ENTRY pScope;
    BOOL         bChanged = FALSE;

    if ( IN_IPV4_LOCAL_SCOPE(ipGroupAddress) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ENTER_WRITER(BOUNDARY_TABLE);
    {
        pScope = FindScope( ipGroupAddress, ipGroupMask );

        if (pScope)
        {
            dwErr = DeleteScope( pScope );
            bChanged = TRUE;
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Resave the scopes to the registry
    if (dwErr is NO_ERROR && bChanged) 
    {
       // ProcessSaveGlobalConfigInfo() requires us to have both the 
       // ICB_LIST and the PROTOCOL_CB_LIST locked.
       ENTER_WRITER(ICB_LIST);
       ENTER_WRITER(PROTOCOL_CB_LIST);

       dwErr = ProcessSaveGlobalConfigInfo();

       EXIT_LOCK(PROTOCOL_CB_LIST);
       EXIT_LOCK(ICB_LIST);
    }

    return dwErr;
}

DWORD
SNMPSetScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  SCOPE_NAME    snScopeName
    )
/*++
Called by: 
    AccessMcastScope() in access.c
Locks: 
    Locks BOUNDARY_TABLE for writing
    Locks ICB_LIST then PROTOCOL_CB_LIST for writing (for saving to registry)
Returns:
    whatever ProcessSaveGlobalConfigInfo() returns
--*/
{
    DWORD        dwErr;
    PSCOPE_ENTRY pScope;
    LANGID       idLanguage = MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT);

    ENTER_WRITER(BOUNDARY_TABLE);
    {
        pScope = FindScope( ipGroupAddress, ipGroupMask );

        if ( ! pScope ) 
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            dwErr = AssertScopeName( pScope, idLanguage, snScopeName );
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Save the scope to the registry
    if (dwErr is NO_ERROR) 
    {
       // ProcessSaveGlobalConfigInfo() requires us to have both the 
       // ICB_LIST and the PROTOCOL_CB_LIST locked.
       ENTER_WRITER(ICB_LIST);
       ENTER_WRITER(PROTOCOL_CB_LIST);

       dwErr = ProcessSaveGlobalConfigInfo();

       EXIT_LOCK(PROTOCOL_CB_LIST);
       EXIT_LOCK(ICB_LIST);
    }

    return dwErr;
}

DWORD
SNMPAddScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  SCOPE_NAME    snScopeName,
    OUT PSCOPE_ENTRY *ppScope
    )
/*++
Called by: 
    AccessMcastScope() in access.c
Locks: 
    Locks BOUNDARY_TABLE for writing
    Locks ICB_LIST then PROTOCOL_CB_LIST for writing (for saving to registry)
Returns:
    ERROR_INVALID_PARAMATER if already exists
    whatever AddScope() returns
    whatever ProcessSaveGlobalConfigInfo() returns
--*/
{
    DWORD             dwErr;
    PSCOPE_ENTRY      pScope;
    LANGID       idLanguage = MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT);

    ENTER_WRITER(BOUNDARY_TABLE);
    {
        pScope = FindScope( ipGroupAddress, ipGroupMask );

        if ( pScope ) 
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            dwErr = AddScope( ipGroupAddress, 
                              ipGroupMask, 
                              ppScope );

            if (dwErr is NO_ERROR)
                dwErr = AssertScopeName( *ppScope, idLanguage, snScopeName );
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Save the scope to the registry
    if (dwErr is NO_ERROR) 
    {
       // ProcessSaveGlobalConfigInfo() requires us to have both the 
       // ICB_LIST and the PROTOCOL_CB_LIST locked.
       ENTER_WRITER(ICB_LIST);
       ENTER_WRITER(PROTOCOL_CB_LIST);

       dwErr = ProcessSaveGlobalConfigInfo();

       EXIT_LOCK(PROTOCOL_CB_LIST);
       EXIT_LOCK(ICB_LIST);
    }

    return dwErr;
}

DWORD
SNMPAssertScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  PBYTE         pScopeName, // string to duplicate
    OUT PSCOPE_ENTRY *ppScopeEntry,
    OUT PBOOL         pbSaveGlobal
    )
/*++
Locks:
    Assumes caller holds write lock on BOUNDARY_TABLE.
Called by: 
    SNMPAddBoundaryToInterface()
Returns:
    NO_ERROR - success
    whatever AddScope() returns
--*/
{
    DWORD             dwErr = NO_ERROR;
    SCOPE_NAME_BUFFER snScopeNameBuffer;
    LANGID            idLanguage;

    if (pScopeName)
    {
        idLanguage = MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT );

        MultiByteToWideChar( CP_UTF8,
                             0,
                             pScopeName,
                             strlen(pScopeName),
                             snScopeNameBuffer,
                             MAX_SCOPE_NAME_LEN+1 );
    }

    *ppScopeEntry = FindScope(ipGroupAddress, ipGroupMask);

    if (! *ppScopeEntry) 
    {
        dwErr = AddScope( ipGroupAddress, 
                             ipGroupMask, 
                             ppScopeEntry);

        if (pScopeName and (dwErr is NO_ERROR))
        {
            dwErr = AssertScopeName( *ppScopeEntry, 
                                      idLanguage, 
                                      snScopeNameBuffer );
        }

        *pbSaveGlobal = TRUE;
    }

    return dwErr;
}

DWORD
SNMPAddBoundaryToInterface(
    IN DWORD         dwIfIndex,
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    )
/*++
Routine Description:
    Create a boundary if necessary, and add it to a given interface
    and to the registry.
Called by:
    AccessMcastBoundary() in access.c
Locks:
    BOUNDARY_TABLE for writing
    ICB_LIST and then PROTOCOL_CB_LIST for writing
Returns:
    NO_ERROR
    whatever AssertScope() returns
    whatever AssertBifEntry() returns
    whatever ProcessSaveInterfaceConfigInfo()
--*/
{
    DWORD           dwResult;

    LIST_ENTRY      leOldRanges, 
                    leNewRanges;

    BOOL            bSaveGlobal = FALSE,
                    bIsOperational = TRUE;

    BOUNDARY_ENTRY *pBoundary;

    BOUNDARY_IF    *pBIf;

    SCOPE_ENTRY    *pScope;

    //
    // bIsOperational should really be set to TRUE only if
    // picb->dwOperationalState is IF_OPER_STATUS_OPERATIONAL
    //

    // Add the boundary
    ENTER_WRITER(BOUNDARY_TABLE);
    {
        Trace0( MCAST, "SNMPAddBoundaryToInterface: converting old ranges" );
        ConvertIfTableToRanges(dwIfIndex, &leOldRanges);
 
        dwResult = SNMPAssertScope(ipGroupAddress, ipGroupMask, NULL, &pScope,
                                   &bSaveGlobal);

        if (dwResult == NO_ERROR) 
        {
            dwResult = AssertBIfEntry(dwIfIndex, &pBIf, bIsOperational);
            if (dwResult is NO_ERROR)
            {
                AssertBoundaryEntry(pBIf, pScope, &pBoundary);
            }
        }

        if (dwResult isnot NO_ERROR) 
        {
            EXIT_LOCK(BOUNDARY_TABLE);
            return dwResult;
        }

        Trace0( MCAST, "SNMPAddBoundaryToInterface: converting new ranges" );
        ConvertIfTableToRanges(dwIfIndex, &leNewRanges);
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Inform MGM of deltas
    ProcessIfRangeDeltas(dwIfIndex, &leOldRanges, &leNewRanges);

    // Save the boundary to the registry
    {
        // ProcessSaveInterfaceConfigInfo() requires us to have both the 
        // ICB_LIST and the PROTOCOL_CB_LIST locked.
        ENTER_WRITER(ICB_LIST);
        ENTER_WRITER(PROTOCOL_CB_LIST);

        if (bSaveGlobal)
            dwResult = ProcessSaveGlobalConfigInfo();
 
        dwResult = ProcessSaveInterfaceConfigInfo(dwIfIndex);
 
        EXIT_LOCK(PROTOCOL_CB_LIST);
        EXIT_LOCK(ICB_LIST);
    }
 
    return dwResult;
}

DWORD
SNMPDeleteBoundaryFromInterface(
    IN DWORD         dwIfIndex,
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    )
/*++
Routine Description:
    Remove a boundary from a given interface, and delete the scope
    entry if it's unnamed and no interfaces remain.
Called by:
    AccessMcastBoundary() in access.c
Locks:
    BOUNDARY_TABLE for writing
Returns:
    NO_ERROR
--*/
{
    LIST_ENTRY      leOldRanges, 
                    leNewRanges,
                   *pleNode, 
                   *pleNext;

    DWORD           dwResult = NO_ERROR;

    BOOL            bSaveGlobal = FALSE;

    BOUNDARY_IF    *pBIf;

    BOUNDARY_ENTRY *pBoundary;

    SCOPE_ENTRY    *pScope;

    ENTER_WRITER(BOUNDARY_TABLE);
    {
       Trace0( MCAST, 
              "SNMPDeleteBoundaryFromInterface: converting old ranges" );
       ConvertIfTableToRanges(dwIfIndex, &leOldRanges);

       //
       // We have to do a little more work than just calling 
       // DeleteBoundaryFromInterface(), since we first have to
       // look up which boundary matches.
       //
       pBIf = FindBIfEntry(dwIfIndex);
       if (pBIf is NULL)
       {
          // nothing to do
          FreeRangeList(&leOldRanges);
          EXIT_LOCK(BOUNDARY_TABLE);
          return NO_ERROR;
       }

       for (pleNode = pBIf->leBoundaryList.Flink;
            pleNode isnot &pBIf->leBoundaryList;
            pleNode = pleNext) 
       {
          // Save ptr to next node, since we may delete this one
          pleNext = pleNode->Flink;

          pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
           leBoundaryLink);

          pScope = pBoundary->pScope;

          if (pScope->ipGroupAddress == ipGroupAddress
           && pScope->ipGroupMask    == ipGroupMask) 
          {

             // Delete boundary from interface
             DeleteBoundaryFromInterface(pBoundary, pBIf);

             if (!pScope->ulNumInterfaces && IsListEmpty(&pScope->leNameList)) 
             {
                 DeleteScope(pScope);
                 bSaveGlobal = TRUE;
             }
          }
       }

       Trace0( MCAST, 
               "SNMPDeleteBoundaryFromInterface: converting new ranges" );
       ConvertIfTableToRanges(dwIfIndex, &leNewRanges);
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Inform MGM of deltas
    ProcessIfRangeDeltas(dwIfIndex, &leOldRanges, &leNewRanges);

    // Resave boundaries to registry
    {
        // ProcessSaveInterfaceConfigInfo() requires us to have both the 
        // ICB_LIST and the PROTOCOL_CB_LIST locked.
        ENTER_WRITER(ICB_LIST);
        ENTER_WRITER(PROTOCOL_CB_LIST);

        if (bSaveGlobal)
            dwResult = ProcessSaveGlobalConfigInfo();
 
        dwResult = ProcessSaveInterfaceConfigInfo(dwIfIndex);

        EXIT_LOCK(PROTOCOL_CB_LIST);
        EXIT_LOCK(ICB_LIST);
    }
 
    return dwResult;
}

//
// Functions which can be called from MGM and Routing Protocols
//

BOOL
WINAPI
RmHasBoundary(
    IN DWORD        dwIfIndex,
    IN IPV4_ADDRESS ipGroupAddress
    )
/*++
Routine Description:
    Test to see whether a boundary for the given group exists on the
    indicated interface.
Called by:
    (MGM, Routing Protocols)
Locks:
    BOUNDARY_TABLE for reading
Returns:
    TRUE, if a boundary exists
    FALSE, if not
--*/
{
    BOUNDARY_IF *pIf;
    BOUNDARY_ENTRY *pBoundary;
    PLIST_ENTRY pleNode;
    BOOL bFound = FALSE;

    ENTER_READER(BOUNDARY_TABLE);
    {
       pIf = FindBIfEntry(dwIfIndex);
       if (pIf) 
       {
          
          // An address in the IPv4 Local Scope has a boundary if
          // ANY boundary exists.
          if ( !IsListEmpty( &pIf->leBoundaryList )
            && IN_IPV4_LOCAL_SCOPE(ipGroupAddress) )
             bFound = TRUE;

          for (pleNode = pIf->leBoundaryList.Flink;
               !bFound && pleNode isnot &pIf->leBoundaryList;
               pleNode = pleNode->Flink) 
          {
             pBoundary = CONTAINING_RECORD(pleNode, BOUNDARY_ENTRY,
              leBoundaryLink);
             if ((ipGroupAddress & pBoundary->pScope->ipGroupMask)
              == pBoundary->pScope->ipGroupAddress)
                bFound = TRUE;
          }
       }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    return bFound;
}

//----------------------------------------------------------------------------
// Boundary enumeration API.
//
//----------------------------------------------------------------------------

DWORD
RmGetBoundary(
    IN       PMIB_IPMCAST_BOUNDARY pimm,
    IN  OUT  PDWORD                pdwBufferSize,
    IN  OUT  PBYTE                 pbBuffer
)
/*++
Called by:
    AccessMcastBoundary() in access.c
Returns:
    SNMP error code
--*/
{
    DWORD                  dwErr = NO_ERROR;
    BOUNDARY_IF           *pBIf;
    BOUNDARY_ENTRY        *pBoundary;
    SCOPE_ENTRY           *pScope;
    PMIB_IPMCAST_BOUNDARY *pOut;

    Trace1( ENTER, "ENTERED RmGetBoundary: %d", *pdwBufferSize );

    if (*pdwBufferSize < sizeof(MIB_IPMCAST_BOUNDARY)) {
       *pdwBufferSize = sizeof(MIB_IPMCAST_BOUNDARY);
       return ERROR_INSUFFICIENT_BUFFER;
    }

    do {
       ENTER_READER(BOUNDARY_TABLE);

       if ((pBIf = FindBIfEntry(pimm->dwIfIndex)) == NULL) 
       {
          dwErr = ERROR_NOT_FOUND;
          break;
       }

       if ( IN_IPV4_LOCAL_SCOPE(pimm->dwGroupAddress) )
       {
          dwErr = ERROR_NOT_FOUND;
          break;
       }
       else
       {
          pScope = FindScope(pimm->dwGroupAddress, pimm->dwGroupMask);
          if (pScope == NULL) 
          {
             dwErr = ERROR_NOT_FOUND;
             break;
          }

          if ((pBoundary = FindBoundaryEntry(pBIf, pScope)) == NULL) 
          {
             dwErr = ERROR_NOT_FOUND;
             break;
          }
       }

       // Ok, we found it.
       pimm->dwStatus = ROWSTATUS_ACTIVE;
       CopyMemory(pbBuffer, pimm, sizeof(MIB_IPMCAST_BOUNDARY));
        
    } while(0);
    EXIT_LOCK(BOUNDARY_TABLE);

    Trace1( ENTER, "LEAVING RmGetBoundary %x\n", dwErr );

    return dwErr;
}

//----------------------------------------------------------------------------
// SCOPE enumeration API.
//
//----------------------------------------------------------------------------

DWORD
AddNextScope(
    IN     IPV4_ADDRESS         ipAddr, 
    IN     IPV4_ADDRESS         ipMask, 
    IN     SCOPE_NAME           snScopeName,
    IN     PMIB_IPMCAST_SCOPE   pimmStart,
    IN OUT PDWORD               pdwNumEntries,
    IN OUT PDWORD               pdwBufferSize,
    IN OUT PBYTE               *ppbBuffer)
/*++
Arguments:
    pdwBufferSize:  [IN] size of buffer
                    [OUT] extra space left, if NO_ERROR is returned
                          total size needed, if ERROR_INSUFFICIENT_BUFFER
--*/
{

    //
    // See whether this scope fits the requested criteria
    //

    if (ntohl(ipAddr) > ntohl(pimmStart->dwGroupAddress)
     || (      ipAddr  ==       pimmStart->dwGroupAddress
      && ntohl(ipMask) >= ntohl(pimmStart->dwGroupMask)))
    {
        MIB_IPMCAST_SCOPE imm;

        //
        // Make sure enough space is left in the buffer
        //

        if (*pdwBufferSize < sizeof(MIB_IPMCAST_SCOPE)) 
        {
           if (*pdwNumEntries == 0)
              *pdwBufferSize = sizeof(MIB_IPMCAST_SCOPE);
           return ERROR_INSUFFICIENT_BUFFER;
        }

        //
        // Copy scope into buffer
        //

        imm.dwGroupAddress = ipAddr;
        imm.dwGroupMask    = ipMask;
        sn_strcpy(imm.snNameBuffer, snScopeName);
        imm.dwStatus       = ROWSTATUS_ACTIVE;
        CopyMemory(*ppbBuffer, &imm, sizeof(MIB_IPMCAST_SCOPE));
        (*ppbBuffer)     += sizeof(MIB_IPMCAST_SCOPE);
        (*pdwBufferSize) -= sizeof(MIB_IPMCAST_SCOPE);
        (*pdwNumEntries)++;
    }

    return NO_ERROR;
}

DWORD
RmGetNextScope(
    IN              PMIB_IPMCAST_SCOPE   pimmStart,
    IN  OUT         PDWORD               pdwBufferSize,
    IN  OUT         PBYTE                pbBuffer,
    IN  OUT         PDWORD               pdwNumEntries
)
/*++
Locks: 
    BOUNDARY_TABLE for reading
Called by:
    RmGetFirstScope(), 
    AccessMcastScope() in access.c
--*/
{
    DWORD             dwErr = NO_ERROR;
    DWORD             dwNumEntries=0, dwBufferSize = *pdwBufferSize;
    SCOPE_ENTRY      *pScope, local;
    DWORD             dwInd;
    BOOL              bHaveScopes = FALSE;
    PLIST_ENTRY       pleNode;

    Trace1( MCAST, "ENTERED RmGetNextScope: %d", dwBufferSize);

    // Bump index by 1
    pimmStart->dwGroupMask = htonl( ntohl(pimmStart->dwGroupMask) + 1);
    if (!pimmStart->dwGroupMask) 
    {
       pimmStart->dwGroupAddress = htonl( ntohl(pimmStart->dwGroupAddress) + 1);
    }

    ENTER_READER(BOUNDARY_TABLE);
    {

        // Walk master scope list
        for (pleNode = g_MasterScopeList.Flink;
             dwNumEntries < *pdwNumEntries && pleNode isnot &g_MasterScopeList;
             pleNode = pleNode->Flink) {

            pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

            if ( !pScope->ipGroupAddress )
                continue;

            bHaveScopes = TRUE;

            dwErr = AddNextScope(pScope->ipGroupAddress,
                                 pScope->ipGroupMask, 
                                 GetDefaultName( pScope ),
                                 pimmStart,
                                 &dwNumEntries,
                                 &dwBufferSize,
                                 &pbBuffer);

            if (dwErr == ERROR_INSUFFICIENT_BUFFER) 
            {
                *pdwBufferSize = dwBufferSize;
                return dwErr;
            }
        }
        
        //
        // Finally, if we have scopes, then we can also count
        // one for the IPv4 Local Scope.
        //

        if ( dwNumEntries > 0 && dwNumEntries < *pdwNumEntries && bHaveScopes )
        {
            dwErr = AddNextScope( IPV4_LOCAL_SCOPE_ADDR,
                                  IPV4_LOCAL_SCOPE_MASK, 
                                  IPV4_LOCAL_SCOPE_NAME,
                                  pimmStart,
                                  &dwNumEntries,
                                  &dwBufferSize,
                                  &pbBuffer );
        }
        if (!dwNumEntries && dwErr==NO_ERROR)
           dwErr = ERROR_NO_MORE_ITEMS;
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    *pdwBufferSize -= dwBufferSize;
    *pdwNumEntries  = dwNumEntries;

    Trace1( MCAST, "LEAVING RmGetNextScope %x", dwErr );

    return dwErr;
}

DWORD
RmGetScope(
    IN       PMIB_IPMCAST_SCOPE pimm,
    IN  OUT  PDWORD             pdwBufferSize,
    IN  OUT  PBYTE              pbBuffer
)
/*++
Called by:
    AccessMcastScope() in access.c
Returns:
    SNMP error code
--*/
{
    DWORD                  dwErr = NO_ERROR;
    SCOPE_ENTRY           *pScope;
    PMIB_IPMCAST_SCOPE    *pOut;

    Trace1( ENTER, "ENTERED RmGetScope: %d", *pdwBufferSize );

    if (*pdwBufferSize < sizeof(MIB_IPMCAST_SCOPE)) {
       *pdwBufferSize = sizeof(MIB_IPMCAST_SCOPE);
       return ERROR_INSUFFICIENT_BUFFER;
    }

    pimm->dwStatus = ROWSTATUS_ACTIVE;


    ENTER_READER(BOUNDARY_TABLE);
    do {

       if ( pimm->dwGroupAddress == IPV4_LOCAL_SCOPE_ADDR
         && pimm->dwGroupMask    == IPV4_LOCAL_SCOPE_MASK )
       {
          sn_strcpy( pimm->snNameBuffer, IPV4_LOCAL_SCOPE_NAME );
          CopyMemory(pbBuffer, pimm, sizeof(MIB_IPMCAST_SCOPE));
       }
       else
       {
          pScope = FindScope(pimm->dwGroupAddress, pimm->dwGroupMask);
          if (pScope == NULL) 
          {
             dwErr = ERROR_NOT_FOUND;
             break;
          }

          // Ok, we found it.
          CopyMemory(pbBuffer, pimm, sizeof(MIB_IPMCAST_SCOPE));
       }
        
    } while(0);
    EXIT_LOCK(BOUNDARY_TABLE);

    Trace1( ENTER, "LEAVING RmGetScope %x\n", dwErr );

    return dwErr;
}

DWORD
RmGetFirstScope(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
/*++
Routine description:
    Get the first scope in lexicographic order.  Since Addr=0
    is not used, a GetFirst is equivalent to a GetNext with Addr=0.
Called by:
    AccessMcastScope() in access.c
--*/
{
    MIB_IPMCAST_SCOPE imm;
    imm.dwGroupAddress = imm.dwGroupMask = 0;
    return RmGetNextScope(&imm, pdwBufferSize, pbBuffer, pdwNumEntries);
}

//----------------------------------------------------------------------------
// BOUNDARY enumeration API.
//
//----------------------------------------------------------------------------

DWORD
AddNextBoundary(
    IN     DWORD                   dwIfIndex, 
    IN     IPV4_ADDRESS            ipAddr, 
    IN     IPV4_ADDRESS            ipMask, 
    IN     PMIB_IPMCAST_BOUNDARY   pimmStart,
    IN OUT PDWORD                  pdwNumEntries,
    IN OUT PDWORD                  pdwBufferSize,
    IN OUT PBYTE                  *ppbBuffer)
/*++
Arguments:
    pdwBufferSize:  [IN] size of buffer
                    [OUT] extra space left, if NO_ERROR is returned
                          total size needed, if ERROR_INSUFFICIENT_BUFFER
--*/
{

    //
    // See whether this boundary fits the requested criteria
    //

    if (ntohl(ipAddr) > ntohl(pimmStart->dwGroupAddress)
     || (      ipAddr  ==       pimmStart->dwGroupAddress
      && ntohl(ipMask) >= ntohl(pimmStart->dwGroupMask)))
    {
        MIB_IPMCAST_BOUNDARY imm;

        //
        // Make sure enough space is left in the buffer
        //

        if (*pdwBufferSize < sizeof(MIB_IPMCAST_BOUNDARY)) 
        {
           if (*pdwNumEntries == 0)
              *pdwBufferSize = sizeof(MIB_IPMCAST_BOUNDARY);
           return ERROR_INSUFFICIENT_BUFFER;
        }

        //
        // Copy boundary into buffer
        //

        imm.dwIfIndex      = dwIfIndex;
        imm.dwGroupAddress = ipAddr;
        imm.dwGroupMask    = ipMask;
        imm.dwStatus       = ROWSTATUS_ACTIVE;
        CopyMemory(*ppbBuffer, &imm, sizeof(MIB_IPMCAST_BOUNDARY));
        (*ppbBuffer)     += sizeof(MIB_IPMCAST_BOUNDARY);
        (*pdwBufferSize) -= sizeof(MIB_IPMCAST_BOUNDARY);
        (*pdwNumEntries)++;
    }

    return NO_ERROR;
}

DWORD
RmGetNextBoundary(
    IN              PMIB_IPMCAST_BOUNDARY   pimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
/*++
Locks: 
    BOUNDARY_TABLE for reading
Called by:
    RmGetFirstBoundary(), 
    AccessMcastBoundary() in access.c
--*/
{
    DWORD                dwErr = NO_ERROR;
    PLIST_ENTRY          pleIf, pleBound;
    DWORD                dwNumEntries=0, dwBufferSize = *pdwBufferSize;
    BOUNDARY_ENTRY      *pBound, local;

    Trace1( MCAST, "ENTERED RmGetNextBoundary: %d", dwBufferSize);

    // Bump index by 1
    pimmStart->dwGroupMask = htonl( ntohl(pimmStart->dwGroupMask) + 1);
    if (!pimmStart->dwGroupMask) 
    {
       pimmStart->dwGroupAddress = htonl( ntohl(pimmStart->dwGroupAddress) + 1);
       if (!pimmStart->dwGroupAddress)
          pimmStart->dwIfIndex++;
    }

    ENTER_READER(BOUNDARY_TABLE);
    {

       // Walk master BOUNDARY_IF list
       for (pleIf =  g_MasterInterfaceList.Flink;
            dwErr == NO_ERROR && dwNumEntries < *pdwNumEntries 
             && pleIf isnot &g_MasterInterfaceList;
            pleIf = pleIf->Flink) 
       {
          BOUNDARY_IF *pBIf = CONTAINING_RECORD(pleIf, BOUNDARY_IF,
           leBoundaryIfMasterLink);
          
          if (pBIf->dwIfIndex >= pimmStart->dwIfIndex) 
          {

             // Walk BOUNDARY list
             for (pleBound = pBIf->leBoundaryList.Flink;
                  dwErr == NO_ERROR && dwNumEntries < *pdwNumEntries
                  && pleBound isnot &pBIf->leBoundaryList;
                  pleBound = pleBound->Flink) 
             {
                 pBound = CONTAINING_RECORD(pleBound, 
                  BOUNDARY_ENTRY, leBoundaryLink);

                 dwErr = AddNextBoundary(pBIf->dwIfIndex, 
                                         pBound->pScope->ipGroupAddress,
                                         pBound->pScope->ipGroupMask, 
                                         pimmStart,
                                         &dwNumEntries,
                                         &dwBufferSize,
                                         &pbBuffer);
             }

             //
             // Finally, if we have boundaries, then we can also count
             // one for the IPv4 Local Scope.
             //

             if (dwErr == NO_ERROR && dwNumEntries < *pdwNumEntries
                 && !IsListEmpty( &pBIf->leBoundaryList ) )
             {
                 dwErr = AddNextBoundary(pBIf->dwIfIndex, 
                                         IPV4_LOCAL_SCOPE_ADDR,
                                         IPV4_LOCAL_SCOPE_MASK, 
                                         pimmStart,
                                         &dwNumEntries,
                                         &dwBufferSize,
                                         &pbBuffer);
             }

             if (dwErr == ERROR_INSUFFICIENT_BUFFER) 
             {
                 *pdwBufferSize = dwBufferSize;
                 return dwErr;
             }
          }
       }
       if (!dwNumEntries && dwErr==NO_ERROR)
          dwErr = ERROR_NO_MORE_ITEMS;

    }
    EXIT_LOCK(BOUNDARY_TABLE);

    *pdwBufferSize -= dwBufferSize;
    *pdwNumEntries  = dwNumEntries;

    Trace1( MCAST, "LEAVING RmGetNextBoundary %x\n", dwErr );

    return dwErr;
}

DWORD
RmGetFirstBoundary(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
/*++
Routine description:
    Get the first boundary in lexicographic order.  Since IfIndex=0
    is not used, a GetFirst is equivalent to a GetNext with IfIndex=0.
Called by:
    AccessMcastBoundary() in access.c
--*/
{
    MIB_IPMCAST_BOUNDARY imm;
    imm.dwIfIndex = imm.dwGroupAddress = imm.dwGroupMask = 0;
    return RmGetNextBoundary(&imm, pdwBufferSize, pbBuffer, pdwNumEntries);
}

void
InitializeBoundaryTable()
/*++
Locks:
    BOUNDARY_TABLE for writing
--*/
{
    register int i;

    ENTER_WRITER(BOUNDARY_TABLE);
    {

       for (i=0; i<BOUNDARY_HASH_TABLE_SIZE; i++) 
           InitializeListHead(&g_bbScopeTable[i].leInterfaceList);

       InitializeListHead(&g_MasterInterfaceList);
       InitializeListHead(&g_MasterScopeList);

       ZeroMemory( g_scopeEntry, MAX_SCOPES * sizeof(SCOPE_ENTRY) );
    }
    EXIT_LOCK(BOUNDARY_TABLE);
}

//////////////////////////////////////////////////////////////////////////////
// START OF MZAP ROUTINES
//////////////////////////////////////////////////////////////////////////////
// Notes on MZAP write lock dependencies:
//    ZAM_CACHE  - no dependencies
//    MZAP_TIMER - no dependencies
//    ZBR_LIST   - lock BOUNDARY_ENTRY and MZAP_TIMER before ZBR_LIST
//    ZLE_LIST   - lock MZAP_TIMER before ZLE_LIST

#define TOP_OF_SCOPE(pScope) \
                        ((pScope)->ipGroupAddress | ~(pScope)->ipGroupMask)

// Convert number of seconds to number of 100ns intervals
#define TM_SECONDS(x)  ((x)*10000000)

//
// Define this if/when authentication of MZAP messages is provided
//

#undef SECURE_MZAP

//
// Address used as Message Origin for locally-originated messages
//

IPV4_ADDRESS  g_ipMyAddress = INADDR_ANY;
IPV4_ADDRESS  g_ipMyLocalZoneID = INADDR_ANY;
SOCKET        g_mzapLocalSocket = INVALID_SOCKET;
LIST_ENTRY    g_zbrTimerList;
LIST_ENTRY    g_zleTimerList;
BOOL          g_bMzapStarted = FALSE;
HANDLE        g_hMzapSocketEvent = NULL;

// For now, originate all ZAMs and ZCMs at the same time.
LARGE_INTEGER g_liZamExpiryTime;


DWORD
UpdateMzapTimer();

#include <packon.h>
typedef struct _IPV4_MZAP_HEADER {
    BYTE         byVersion;
    BYTE         byBPType;
    BYTE         byAddressFamily;
    BYTE         byNameCount;
    IPV4_ADDRESS ipMessageOrigin;
    IPV4_ADDRESS ipScopeZoneID;
    IPV4_ADDRESS ipScopeStart;
    IPV4_ADDRESS ipScopeEnd;
    BYTE         pScopeNameBlock[0];
} IPV4_MZAP_HEADER, *PIPV4_MZAP_HEADER;

typedef struct _IPV4_ZAM_HEADER {
    BYTE             bZT;
    BYTE             bZTL;
    WORD             wHoldTime;
    IPV4_ADDRESS     ipAddress[1]; 
} IPV4_ZAM_HEADER, *PIPV4_ZAM_HEADER;

typedef struct _IPV4_ZCM_HEADER {
    BYTE         bZNUM;
    BYTE         bReserved;
    WORD         wHoldTime;
    IPV4_ADDRESS ipZBR[0];
} IPV4_ZCM_HEADER, *PIPV4_ZCM_HEADER;
#include <packoff.h>


//////////////////////////////////////////////////////////////////////////////
// Functions for ZBR neighbor list and Zone ID maintenance
//////////////////////////////////////////////////////////////////////////////

ZBR_ENTRY *
FindZBR(
    IN PSCOPE_ENTRY pScope, 
    IN IPV4_ADDRESS ipAddress
    )
/*++
Description:
    Finds a given ZBR in a list.
Arguments:
    IN pscope    - scope to find a ZBR associated with
    IN ipAddress - address of ZBR to find
Returns:
    Pointer to ZBR entry, or NULL if not found
Called by:
    AssertZBR()
Locks:
    Assumes caller holds read lock on BOUNDARY_ENTRY and ZBR_LIST
--*/
{
    PZBR_ENTRY  pZbr;
    PLIST_ENTRY pleNode;

    for (pleNode = pScope->leZBRList.Flink;
         pleNode isnot &pScope->leZBRList;
         pleNode = pleNode->Flink)
    {
        pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leZBRLink);

        if (pZbr->ipAddress == ipAddress)
        {
            return pZbr;
        }
    }

    return NULL;
}

IPV4_ADDRESS
MyScopeZoneID(
    IN PSCOPE_ENTRY  pScope
    )
/*++
Description:
    Get the Zone ID which we're inside for a given scope
Arguments:
    IN pScope - scope to get the zone ID for
Returns:
    scope zone address
Called by:
    AddMZAPHeader(), HandleZAM()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE
    so that pScope won't go away.
--*/
{
    PLIST_ENTRY  pleNode;
    IPV4_ADDRESS ipScopeZoneID = g_ipMyAddress;

    // If first ZBR has a lower IP address than us, use that.
    pleNode = pScope->leZBRList.Flink;

    if (pleNode isnot &pScope->leZBRList)
    {
        ZBR_ENTRY *pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leZBRLink);
        
        if (ntohl(pZbr->ipAddress) < ntohl(ipScopeZoneID))
            ipScopeZoneID = pZbr->ipAddress;
    }

    return ipScopeZoneID;
}

VOID
SetZbrExpiryTime( 
    PZBR_ENTRY    pZbr, 
    LARGE_INTEGER liExpiryTime 
    )
{
    PLIST_ENTRY pleNode;

    pZbr->liExpiryTime = liExpiryTime;

    for (pleNode = g_zbrTimerList.Flink;
         pleNode isnot &g_zbrTimerList;
         pleNode = pleNode->Flink)
    {
        ZBR_ENTRY *pPrev = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leTimerLink);

        if (RtlLargeIntegerGreaterThan(pPrev->liExpiryTime, liExpiryTime))
            break;
    }

    InsertTailList( pleNode, &pZbr->leTimerLink );
}

ZBR_ENTRY *
AddZBR(
    IN PSCOPE_ENTRY  pScope, 
    IN IPV4_ADDRESS  ipAddress, 
    IN LARGE_INTEGER liExpiryTime
    )
/*++
Description:
    Adds ZBR to scope's list.  Initializes timer, and updates Zone ID.
Arguments:
    IN pScope       - scope to add a boundary router of
    IN ipAddress    - address of the boundary router to add
    IN liExpiryTime - time at which to expire the boundary router entry
Returns:
    Pointer to new boundary router entry, or NULL on memory alloc error
Called by:
    AssertZBR()
Locks:
    Assumes caller holds write lock on BOUNDARY_ENTRY, MZAP_TIMER, and ZBR_LIST
--*/
{
    PZBR_ENTRY  pZbr;
    PLIST_ENTRY pleNode;

    // Initialize new ZBR entry
    pZbr = MALLOC( sizeof(ZBR_ENTRY) );
    if (!pZbr)
    {
        return NULL;
    }

    pZbr->ipAddress    = ipAddress;

    // Add ZBR to list in order of lowest IP address

    for (pleNode = pScope->leZBRList.Flink;
         pleNode isnot &pScope->leZBRList;
         pleNode = pleNode->Flink)
    {
        ZBR_ENTRY *pPrev = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leZBRLink);

        if (ntohl(pPrev->ipAddress) > ntohl(ipAddress))
        {
            break;
        }
    }

    InsertTailList( pleNode, &pZbr->leZBRLink );

    // We don't need to update Zone ID since it's recalculated
    // whenever we need it.

    // Add ZBR to timer list in order of expiry time
    SetZbrExpiryTime( pZbr, liExpiryTime );

    UpdateMzapTimer();

    return pZbr;
}


ZBR_ENTRY *
AssertZBR(
    IN PSCOPE_ENTRY pScope, 
    IN IPV4_ADDRESS ipAddress, 
    IN WORD         wHoldTime
    )
/*++
Description:
    Finds ZBR in list, adding it if needed.  Resets timer for ZBR.
Arguments:
    IN pScope    - scope to find/add a boundary router of
    IN ipAddress - address of boundary router to find/add
    IN wHoldTime - hold time in seconds remaining to reset timer to
Returns:
    Pointer to boundary router entry
Called by:
    HandleZAM(), HandleZCM()
Locks:
    Assumes caller holds read lock on BOUNDARY_ENTRY
    Locks MZAP_TIMER and then ZBR_LIST for writing
--*/
{
    LARGE_INTEGER liCurrentTime, liExpiryTime;
    ZBR_ENTRY    *pZbr;

    NtQuerySystemTime( &liCurrentTime );

    liExpiryTime = RtlLargeIntegerAdd(liCurrentTime, 
      RtlConvertUlongToLargeInteger(TM_SECONDS((ULONG)wHoldTime)));

    ENTER_WRITER(MZAP_TIMER);
    ENTER_WRITER(ZBR_LIST);
    {
        pZbr = FindZBR( pScope, ipAddress );
    
        if (!pZbr) 
        {
            pZbr = AddZBR( pScope, ipAddress, liExpiryTime );
        }
        else
        {
            RemoveEntryList( &pZbr->leTimerLink );

            SetZbrExpiryTime( pZbr, liExpiryTime );
        }
    }
    EXIT_LOCK(ZBR_LIST);
    EXIT_LOCK(MZAP_TIMER);

    return pZbr;
}

VOID
DeleteZBR(
    IN PZBR_ENTRY pZbr
    )
/*++
Arguments:
    IN pZbr - Pointer to boundary router entry to delete
Called by:
    HandleMzapTimer()
Locks:
    Assumes caller has write lock on ZBR_LIST
--*/
{
    // Remove from timer list
    RemoveEntryList( &pZbr->leTimerLink );

    // Remove from ZBR list for the scope
    RemoveEntryList( &pZbr->leZBRLink );

    // We don't need to update the Zone ID, since it's recalculated
    // whenever we need it
}


//////////////////////////////////////////////////////////////////////////////
// Functions for pending ZLE store manipulation
//////////////////////////////////////////////////////////////////////////////

typedef struct _ZLE_PENDING {
    LIST_ENTRY    leTimerLink;
    PBYTE         pBuffer;
    ULONG         ulBuffLen;
    LARGE_INTEGER liExpiryTime;
} ZLE_PENDING, *PZLE_PENDING;

LIST_ENTRY g_leZleList;

PZLE_PENDING
AddPendingZLE(
    IN PBYTE         pBuffer, 
    IN ULONG         ulBuffLen,
    IN LARGE_INTEGER liExpiryTime
    )
/*++
Arguments:
    IN pBuffer      - buffer holding ZLE message
    IN ulBuffLen    - size in bytes of buffer passed in
    IN liExpiryTime - time at which to expire ZLE entry
Returns:
    Pointer to ZLE entry added, or NULL on memory alloc error
Called by:
    HandleZAM()
Locks:
    Assumes caller holds write lock on ZLE_LIST
--*/
{
    PLIST_ENTRY  pleNode;
    PZLE_PENDING pZle;

    pZle = MALLOC( sizeof(ZLE_PENDING) );
    if (!pZle)
    {
        return NULL;
    }

    pZle->pBuffer      = pBuffer;
    pZle->ulBuffLen    = ulBuffLen;
    pZle->liExpiryTime = liExpiryTime;

    // Search for entry after the new one
    for (pleNode = g_leZleList.Flink;
         pleNode isnot &g_leZleList;
         pleNode = pleNode->Flink)
    {
        PZLE_PENDING pPrev = CONTAINING_RECORD(pleNode,ZLE_PENDING,leTimerLink);

        if (RtlLargeIntegerGreaterThan(pPrev->liExpiryTime, 
                                       pZle->liExpiryTime))
        {
            break;
        }
    }

    // Insert into cache
    InsertTailList( pleNode, &pZle->leTimerLink );

    return pZle;
}

VOID
DeletePendingZLE(
    IN PZLE_PENDING zle
    )
/*++
Description:
    Remove all state related to a pending ZLE
Arguments:
    IN zle - pointer to ZLE entry to delete
Called by:
    HandleZLE(), SendZLE()
Locks:
    Assumes caller holds write lock on ZLE_LIST
--*/
{
    RemoveEntryList( &zle->leTimerLink );

    // Free up space 
    FREE(zle->pBuffer);
    FREE(zle);
}

PZLE_PENDING
FindPendingZLE(
    IN IPV4_MZAP_HEADER *mh
    )
/*++
Description:
    Find an entry for a pending ZLE which matches a given MZAP message header
Arguments:
    IN mh - pointer to MZAP message header to locate a matching ZLE entry for
Returns:
    Pointer to matching ZLE entry, if any
Called by:
    HandleZAM(), HandleZLE()
Locks:
    Assumes caller holds read lock on ZLE_LIST
--*/
{
    PLIST_ENTRY       pleNode;
    IPV4_MZAP_HEADER *mh2;

    for (pleNode = g_leZleList.Flink;
         pleNode isnot &g_leZleList;
         pleNode = pleNode->Flink)
    {
        PZLE_PENDING zle = CONTAINING_RECORD(pleNode, ZLE_PENDING, leTimerLink);

        mh2 = (PIPV4_MZAP_HEADER)zle->pBuffer;

        if (mh->ipScopeZoneID == mh2->ipScopeZoneID 
         && mh->ipScopeStart  == mh2->ipScopeStart)
        {
            return zle;
        }
    }
    
    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
// Functions for ZAM cache manipulation
//////////////////////////////////////////////////////////////////////////////

typedef struct _ZAM_ENTRY {
    LIST_ENTRY    leCacheLink;
    IPV4_ADDRESS  ipScopeZoneID;
    IPV4_ADDRESS  ipStartAddress;
    LARGE_INTEGER liExpiryTime;
} ZAM_ENTRY, *PZAM_ENTRY;

LIST_ENTRY g_leZamCache;

void
UpdateZamCache(
    IN LARGE_INTEGER liCurrentTime
    )
/*++
Description:
    Throw any expired entries out of the ZAM cache.
Arguments:
    IN liCurrentTime - current time, to compare vs expiry times of entries
Called by:
    AssertInZamCache()
Locks:
    Assumes caller has write lock on ZAM_CACHE
--*/
{
    PLIST_ENTRY pleNode;
    PZAM_ENTRY  pZam;

    // Throw out old cache entries
    while (g_leZamCache.Flink isnot &g_leZamCache) 
    {
        pleNode = g_leZamCache.Flink;

        pZam = CONTAINING_RECORD(pleNode, ZAM_ENTRY, leCacheLink);

        if ( RtlLargeIntegerLessThanOrEqualTo( pZam->liExpiryTime, 
                                               liCurrentTime )
         ||  RtlLargeIntegerEqualToZero( liCurrentTime ))
        {
            Trace6(MCAST,
                   "Evicting %d.%d.%d.%d/%d.%d.%d.%d from ZAM cache with current time %x.%x exp %x.%x",
                   PRINT_IPADDR(pZam->ipScopeZoneID),
                   PRINT_IPADDR(pZam->ipStartAddress),
                   liCurrentTime.HighPart, liCurrentTime.LowPart,
                   pZam->liExpiryTime.HighPart,  pZam->liExpiryTime.LowPart);
    
            RemoveEntryList( &pZam->leCacheLink );

            FREE( pZam );

            continue;
        }

        // Ok, we've reached one that stays, so we're done

        break;
    }
}

PZAM_ENTRY
AddToZamCache(
    IN IPV4_ADDRESS  ipScopeZoneID,
    IN IPV4_ADDRESS  ipStartAddress,
    IN LARGE_INTEGER liExpiryTime
    )
/*++
Description:
    This function takes a ZAM identifier and timeout, and adds it to the
    ZAM cache.
Arguments:
    IN ipScopeZoneID  - scope zone ID to cache
    IN ipStartAddress - scope start address to cache
    IN liExpiryTime   - time at which to expire the cache entry
Returns:
    Pointer to cache entry, or NULL on memory error
Called by:
    AssertInZamCache()
Locks:
    Assumes caller holds write lock on ZAM_CACHE
--*/
{
    PLIST_ENTRY pleNode;
    PZAM_ENTRY  pZam;

    // Add entry to cache
    pZam = MALLOC( sizeof(ZAM_ENTRY) );
    if (!pZam)
    {
        return NULL;
    }

    pZam->ipScopeZoneID  = ipScopeZoneID;
    pZam->ipStartAddress = ipStartAddress;
    pZam->liExpiryTime   = liExpiryTime;

    // Search for entry after the new one
    for (pleNode = g_leZamCache.Flink;
         pleNode isnot &g_leZamCache;
         pleNode = pleNode->Flink)
    {
        PZAM_ENTRY pPrevC = CONTAINING_RECORD(pleNode, ZAM_ENTRY, leCacheLink);

        if (RtlLargeIntegerGreaterThan(pPrevC->liExpiryTime, 
                                       pZam->liExpiryTime))
        {
            break;
        }
    }

    // Insert into cache
    InsertTailList( pleNode, &pZam->leCacheLink );

    return pZam;
}

PZAM_ENTRY
FindInZamCache(
    IN IPV4_ADDRESS ipScopeZoneID,
    IN IPV4_ADDRESS ipStartAddress
    )
/*++
Description:
    See if a given ZAM spec is in the cache.
Arguments:
    IN ipScopeZoneID  - scope zone ID to match
    IN ipStartAddress - scope start address to match
Return:
    Pointer to cache entry, or NULL if not found.
Called by:
    AssertInZamCache()
Locks:
    Assumes caller has read lock on ZAM_CACHE
--*/
{
    PLIST_ENTRY pleNode;

    // Search for cache entry
    for (pleNode = g_leZamCache.Flink;
         pleNode isnot &g_leZamCache;
         pleNode = pleNode->Flink)
    {
        ZAM_ENTRY *pZam = CONTAINING_RECORD(pleNode, ZAM_ENTRY, leCacheLink);

        if ( ipScopeZoneID is pZam->ipScopeZoneID
          && ipStartAddress is pZam->ipStartAddress)
        {
            return pZam;
        }
    }

    return NULL;
}

PZAM_ENTRY
AssertInZamCache(
    IN  IPV4_ADDRESS ipScopeZoneID,
    IN  IPV4_ADDRESS ipStartAddress,
    OUT BOOL        *pbFound
    )
/*++
Description:
    Locate a ZAM spec in the cache, adding it if not already present.
Arguments:
    IN  ipScopeZoneID  - scope zone ID to match/cache
    IN  ipStartAddress - scope start address to match/cache
    OUT pbFound        - TRUE if found, FALSE if newly cached
Called by:
    HandleZAM()
Locks:
    ZAM_CACHE for writing
--*/
{
    PZAM_ENTRY    pZam;
    LARGE_INTEGER liCurrentTime, liExpiryTime;

    // Get current time
    NtQuerySystemTime(&liCurrentTime);

    ENTER_WRITER(ZAM_CACHE);
    {
        UpdateZamCache(liCurrentTime);

        pZam = FindInZamCache( ipScopeZoneID, ipStartAddress);

        if (!pZam)
        {
            liExpiryTime = RtlLargeIntegerAdd(liCurrentTime, 
              RtlConvertUlongToLargeInteger(TM_SECONDS(ZAM_DUP_TIME)));
    
            AddToZamCache( ipScopeZoneID, ipStartAddress, liExpiryTime );

            Trace6(MCAST,
                   "Added %d.%d.%d.%d/%d.%d.%d.%d to ZAM cache with current time %x/%x exp %x/%x",
                   PRINT_IPADDR(ipScopeZoneID),
                   PRINT_IPADDR(ipStartAddress),
                   liCurrentTime.HighPart, liCurrentTime.LowPart,
                   liExpiryTime.HighPart,  liExpiryTime.LowPart);
    
            *pbFound = FALSE;
        }
        else
        {
            *pbFound = TRUE;
        }
    }
    EXIT_LOCK(ZAM_CACHE);

    return pZam;
}



//////////////////////////////////////////////////////////////////////////////
// Functions for message sending
//////////////////////////////////////////////////////////////////////////////

DWORD
SendMZAPMessageByIndex(
    IN PBYTE        pBuffer, 
    IN ULONG        ulBuffLen,
    IN IPV4_ADDRESS ipGroup,
    IN DWORD        dwIfIndex   
    )
{
    SOCKADDR_IN    sinAddr;
    DWORD          dwErr = NO_ERROR, dwLen;

    dwErr = McSetMulticastIfByIndex( g_mzapLocalSocket, SOCK_DGRAM, dwIfIndex );

    if (dwErr is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();

        Trace2( ERR, 
                "SendMZAPMessage: error %d setting oif to IF %x", 
                dwErr, 
                dwIfIndex );
    }

    sinAddr.sin_family      = AF_INET;
    sinAddr.sin_addr.s_addr = ipGroup;
    sinAddr.sin_port        = htons(MZAP_PORT);

#ifdef DEBUG_MZAP
    Trace2( ERR, "SendMZAPMessageByIndex: sending %d bytes on IF %d", 
            ulBuffLen, dwIfIndex );
#endif

    dwLen = sendto( g_mzapLocalSocket, 
                pBuffer, 
                ulBuffLen, 
                0, 
                (struct sockaddr*)&sinAddr,
                sizeof(sinAddr));

#ifdef DEBUG_MZAP
    Trace1( ERR, "SendMZAPMessageByIndex: sent %d bytes", dwLen);
#endif

    if (dwLen is SOCKET_ERROR )
    {
        dwErr = WSAGetLastError();

        Trace1( ERR, 
                "SendMZAPMessage: error %d sending message",
                dwErr );
    }

    return dwErr;
}

DWORD
SendMZAPMessage( 
    IN PBYTE        pBuffer, 
    IN ULONG        ulBuffLen,
    IN IPV4_ADDRESS ipGroup,
    IN IPV4_ADDRESS ipInterface
    )
/*++
Called by:
    HandleZAM()
Arguments:
    IN pBuffer     - buffer containing message to send
    IN ulBuffLen   - length of buffer in bytes
    IN ipGroup     - destination address to send message to
    IN ipInterface - interface to send message out
Returns:
    whatever WSAGetLastError() returns
Locks:
    None
--*/
{
    SOCKADDR_IN    sinAddr;
    DWORD          dwErr = NO_ERROR, dwLen;

    dwErr = McSetMulticastIf( g_mzapLocalSocket, ipInterface );

    if (dwErr is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();

        Trace2( ERR, 
                "SendMZAPMessage: error %d setting oif to %d.%d.%d.%d", 
                dwErr, 
                PRINT_IPADDR(ipInterface) );
    }

    sinAddr.sin_family      = AF_INET;
    sinAddr.sin_addr.s_addr = ipGroup;
    sinAddr.sin_port        = htons(MZAP_PORT);

#ifdef DEBUG_MZAP
    Trace2( ERR, "SendMZAPMessage: sending %d bytes on %d.%d.%d.%d", ulBuffLen,
            PRINT_IPADDR(ipInterface));
#endif

    dwLen = sendto( g_mzapLocalSocket, 
                pBuffer, 
                ulBuffLen, 
                0, 
                (struct sockaddr*)&sinAddr,
                sizeof(sinAddr));

#ifdef DEBUG_MZAP
    Trace1( ERR, "SendMZAPMessage: sent %d bytes", dwLen);
#endif

    if (dwLen is SOCKET_ERROR )
    {
        dwErr = WSAGetLastError();

        Trace1( ERR, 
                "SendMZAPMessage: error %d sending message",
                dwErr );
    }

    return dwErr;
}

void
AddMZAPHeader(
    IN OUT PBYTE       *ppb,     // IN: pointer into buffer 
    IN     BYTE         byPType, // IN: message type
    IN     PSCOPE_ENTRY pScope   // IN: scope
    )
/*++
Description:
    Compose an MZAP message header in a buffer.
Arguments:
    IN/OUT ppb     - buffer to add an MZAP header to
    IN     byPType - message type to fill into header
    IN     pScope  - scope to fill into header
Called by:
    SendZAM(), SendZCM()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE so pScope won't go away
--*/
{
    PBYTE             pb;
    IPV4_MZAP_HEADER *mh = (PIPV4_MZAP_HEADER)*ppb;
    BYTE              pConfName[257];
    ULONG             ulConfNameLen, ulConfLangLen;
    PSCOPE_NAME_ENTRY pName;
    int               iDefault;
    PLIST_ENTRY       pleNode;
    PBYTE             pLangName;

    // Make sure packing is correct
    ASSERT((((PBYTE)&mh->ipMessageOrigin) - ((PBYTE)mh)) is 4);
    
    mh->byVersion       = MZAP_VERSION;
    mh->byBPType        = byPType;
    if (pScope->bDivisible) 
    {
        mh->byBPType |= MZAP_BIG_BIT;
    }
    mh->byAddressFamily = ADDRFAMILY_IPV4;
    mh->byNameCount     = 0;
    mh->ipMessageOrigin = g_ipMyAddress;
    mh->ipScopeZoneID   = MyScopeZoneID(pScope);
    mh->ipScopeStart    = pScope->ipGroupAddress;
    mh->ipScopeEnd      = TOP_OF_SCOPE( pScope );

    // Append scope name blocks

    pb = *ppb + sizeof(IPV4_MZAP_HEADER);

    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        iDefault = (pName->bDefault)? MZAP_DEFAULT_BIT : 0;

        pLangName = GetLangName(pName->idLanguage);
        ulConfLangLen = strlen(pLangName);

        ulConfNameLen = WideCharToMultiByte( CP_UTF8,
                             0,
                             pName->snScopeName,
                             sn_strlen( pName->snScopeName ),
                             pConfName,
                             sizeof(pConfName),
                             NULL,
                             NULL );

        *pb++ = (BYTE)iDefault;
        *pb++ = (BYTE)ulConfLangLen;
        strncpy( pb, pLangName, ulConfLangLen );
        pb += ulConfLangLen;

        *pb++ = (BYTE)ulConfNameLen;
        strncpy( pb, pConfName, ulConfNameLen );
        pb += ulConfNameLen;

        mh->byNameCount++;
    }
    
    // Pad to a 4-byte boundary
    // Note that casting to a ULONG is 64-bit safe, since we only care about
    // the low-order bits anyway.

    while (((ULONG_PTR)pb) & 3)
    {
        *pb++ = '\0';
    }

    *ppb = pb;
}

INLINE
IPV4_ADDRESS
MzapRelativeGroup(
    IN PSCOPE_ENTRY pScope
    )
/*++
Description:
    Returns the Scope-relative group address for MZAP within a given scope.
Arguments:
    IN pScope - scope to find the MZAP group in
Returns:
    Address of the MZAP group in the scope
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE so pScope doesn't go away
--*/
{
    return htonl(ntohl(TOP_OF_SCOPE(pScope)) - MZAP_RELATIVE_GROUP);
}

ULONG
GetMZAPHeaderSize(
    IN PSCOPE_ENTRY pScope
    )
{
    PLIST_ENTRY       pleNode;
    ULONG             ulLen = sizeof(IPV4_MZAP_HEADER);
    BYTE              pConfName[257];
    PSCOPE_NAME_ENTRY pName;
    PBYTE             pLangName;
    ULONG             ulConfLangLen, ulConfNameLen;

    // For each scope name, add size needed to store it
    for (pleNode = pScope->leNameList.Flink;
         pleNode isnot &pScope->leNameList;
         pleNode = pleNode->Flink)
    {
        pName = CONTAINING_RECORD(pleNode, SCOPE_NAME_ENTRY, leNameLink);
        pLangName = GetLangName(pName->idLanguage);
        ulConfLangLen = strlen(pLangName);

        WideCharToMultiByte( CP_UTF8,
                             0,
                             pName->snScopeName,
                             sn_strlen( pName->snScopeName ),
                             pConfName,
                             sizeof(pConfName),
                             NULL,
                             NULL );

        ulConfNameLen = strlen( pConfName );

        ulLen += 3; // flags, langlen, and namelen
        ulLen += ulConfLangLen;
        ulLen += ulConfNameLen;
    }

    // Round up to multiple of 4
    ulLen =  4 * ((ulLen + 3) / 4);

    return ulLen;
}

ULONG
GetZAMBuffSize(
    IN PSCOPE_ENTRY pScope
    )
{
    ULONG ulLen = GetMZAPHeaderSize(pScope) + sizeof(IPV4_ZAM_HEADER);

#ifdef SECURE_MZAP
    // Add size of Authentication Block
    // XXX
#endif

    // return 512; // an unsigned IPv4 ZAM message is at most 284 bytes
    return ulLen;
}

DWORD
SendZAM(
    IN PSCOPE_ENTRY pScope
    )
/*++
Description:
    Send a ZAM message within a given scope.
Locks:
    Assumes caller holds lock on BOUNDARY_TABLE so pScope doesn't go away
--*/
{
    DWORD            dwErr;
    PBYTE            pBuffer, pb;
    PIPV4_ZAM_HEADER zam;
    ULONG            ulBuffLen;

    ulBuffLen = GetZAMBuffSize( pScope );

    pb = pBuffer = MALLOC( ulBuffLen );
    if (!pb)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Fill in MZAP header
    AddMZAPHeader(&pb, PTYPE_ZAM, pScope);

    zam = (PIPV4_ZAM_HEADER)pb;
    zam->bZT          = 0;
    zam->bZTL         = pScope->bZTL;
    zam->wHoldTime    = htons(ZAM_HOLDTIME);
    zam->ipAddress[0] = g_ipMyLocalZoneID;
    pb += sizeof(IPV4_ZAM_HEADER);

#ifdef SECURE_MZAP
    // Add optional authentication block here 
#endif

#ifdef DEBUG_MZAP
    Trace0(ERR, "Originate ZAM inside...");
#endif

    // Send on an interface which does not have a boundary for the given scope.
    dwErr = SendMZAPMessage( pBuffer, 
                             (DWORD)(pb-pBuffer), 
                             MZAP_LOCAL_GROUP, 
                             g_ipMyAddress );

    FREE( pBuffer );
    
    return dwErr;
}

ULONG
GetZCMBuffSize(
    IN PSCOPE_ENTRY pScope
    )
{
    PLIST_ENTRY pleNode;
    ULONG       ulLen = GetMZAPHeaderSize(pScope) + sizeof(IPV4_ZCM_HEADER);

    for (pleNode = pScope->leZBRList.Flink;
         pleNode isnot &pScope->leZBRList;
         pleNode = pleNode->Flink)
    {
        ulLen += sizeof(IPV4_ADDRESS);
    }

    return ulLen;
}

DWORD
SendZCM(
    IN PSCOPE_ENTRY pScope
    )
/*++
Description:
    Sends a Zone Convexity Message for a given scope.
Locks:
    Assumes caller has read lock on BOUNDARY_TABLE so pScope won't go away.
    Locks ZBR_LIST for reading.
--*/
{
    PBYTE             pb;
    PIPV4_ZCM_HEADER  zcm;
    PLIST_ENTRY       pleNode;
    PZBR_ENTRY        pZbr;
    WSABUF            wsaZcmBuf;
    DWORD             dwSize, dwErr;

    ENTER_READER(ZBR_LIST);
    {
        dwSize = GetZCMBuffSize(pScope);

        wsaZcmBuf.len = dwSize;
        wsaZcmBuf.buf = MALLOC( dwSize );
    
        pb = wsaZcmBuf.buf;
        if (!pb)
        {
            EXIT_LOCK(ZBR_LIST);

            return GetLastError();
        }
    
        // Fill in MZAP header
        AddMZAPHeader(&pb, PTYPE_ZCM, pScope);
    
        zcm = (PIPV4_ZCM_HEADER)pb;
        zcm->bZNUM      = 0;
        zcm->bReserved  = 0;
        zcm->wHoldTime  = htons(ZCM_HOLDTIME);
    
        // Add all known neighbors
        for (pleNode = pScope->leZBRList.Flink;
             pleNode isnot &pScope->leZBRList;
             pleNode = pleNode->Flink)
        {
            pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leZBRLink);
    
            zcm->ipZBR[ zcm->bZNUM++ ] = pZbr->ipAddress;
        }
    }
    EXIT_LOCK(ZBR_LIST);

    pb += sizeof(IPV4_ZCM_HEADER) + zcm->bZNUM * sizeof(IPV4_ADDRESS);

#ifdef DEBUG_MZAP
    Trace0(ERR, "Sending ZCM...");
#endif

    dwErr = SendMZAPMessage( wsaZcmBuf.buf, 
                             (DWORD)(pb-wsaZcmBuf.buf), 
                             MzapRelativeGroup(pScope), 
                             g_ipMyAddress );

    // Free the buffer

    FREE( wsaZcmBuf.buf );
    
    return dwErr;
}

DWORD
SendZLE(
    IN PZLE_PENDING zle
    )
/*++
Description:
    Given a buffer holding a ZAM, immediately send a ZLE to the origin.
Locks:
    Assumes caller holds write lock on ZLE_LIST
--*/
{
    DWORD             dwErr;
    PBYTE             pBuffer    = zle->pBuffer;
    ULONG             ulBuffLen  = zle->ulBuffLen;
    IPV4_MZAP_HEADER *mh         = (PIPV4_MZAP_HEADER)pBuffer;
    IPV4_ADDRESS      ipDestAddr = mh->ipScopeEnd - MZAP_RELATIVE_GROUP;

    // Change PType to ZLE
    mh->byBPType = (mh->byBPType & MZAP_BIG_BIT) | PTYPE_ZLE;

#ifdef DEBUG_MZAP
    Trace0(ERR, "Sending ZLE...");
#endif
    
    // Return to sender
    dwErr = SendMZAPMessage( pBuffer, 
                             ulBuffLen, 
                             ipDestAddr, 
                             g_ipMyAddress );

    // Free up space
    DeletePendingZLE(zle);
    
    return dwErr;
}

double
UniformRandom01()
{
    return ((double)rand()) / RAND_MAX;
}

VOID
SendAllZamsAndZcms()
/*++
Locks:
    BOUNDARY_TABLE for reading
--*/
{
    PLIST_ENTRY  pleNode;
    PSCOPE_ENTRY pScope;
    double       t,x;
    ULONG        Tmin,Trange;
    BOOL         bSent = FALSE;

    ENTER_READER(BOUNDARY_TABLE);
    {
        for (pleNode = g_MasterScopeList.Flink;
             pleNode isnot &g_MasterScopeList;
             pleNode = pleNode->Flink)
        {
            pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

            // Send ZAM inside
            SendZAM( pScope );

            // Send ZCM inside
            SendZCM( pScope );

            bSent = TRUE;
        }

        if (bSent)
        {
            SendZCM( &g_LocalScope );
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Schedule the next time to send them
    Tmin   = ZAM_INTERVAL/2;
    Trange = ZAM_INTERVAL;
    x = UniformRandom01();
    t = Tmin + x*Trange;

    g_liZamExpiryTime = RtlLargeIntegerAdd( g_liZamExpiryTime,
          RtlConvertUlongToLargeInteger(TM_SECONDS((ULONG)floor(t+0.5))));
}


//////////////////////////////////////////////////////////////////////////////
// Functions for message processing
//////////////////////////////////////////////////////////////////////////////


VOID
CheckForScopeNameMismatch(
    IN PSCOPE_ENTRY      pScope, 
    IN IPV4_MZAP_HEADER *mh
    )
/*++
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE so pScope won't go away
--*/
{
    DWORD i, dwMsgNameLen, dwMsgLangLen, dwConfNameLen = 0, dwConfLangLen;
    DWORD dwMsgNameWLen;
    BYTE pMsgLang[257], *pb, *pConfLang;
    SCOPE_NAME        snConfName = NULL;
    SCOPE_NAME_BUFFER snMsgName;
    PLIST_ENTRY       pleNode;
    PSCOPE_NAME_ENTRY pName;

    // For each language in the message
    //    If we know that language
    //       If the names are different
    //           Signal a conflict

    pb = mh->pScopeNameBlock;

    for (i=0; i<mh->byNameCount; i++)
    {
        pb++; // skip flags
        dwMsgLangLen = *pb++;
        strncpy(pMsgLang, pb, dwMsgLangLen);
        pMsgLang[ dwMsgLangLen ] = '\0';
        pb += dwMsgLangLen;

        dwMsgNameLen = *pb++;
        
        dwMsgNameWLen = MultiByteToWideChar( CP_UTF8,
                             0,
                             pb,
                             dwMsgNameLen,
                             snMsgName,
                             MAX_SCOPE_NAME_LEN+1 );

        snMsgName[dwMsgNameWLen] = L'\0';

        pb += dwMsgNameLen;

        pName = GetScopeNameByLangName( pScope, pMsgLang );
        if (!pName)
            continue;

        snConfName    = pName->snScopeName;
        dwConfNameLen = sn_strlen(snConfName);

        // Check for a name conflict

        if (dwConfNameLen != dwMsgNameWLen
         || sn_strncmp(snConfName, snMsgName, dwMsgNameWLen))
        {
            // Display origin and both scope names

            MakeAddressStringW(g_AddrBuf1, mh->ipMessageOrigin);

            Trace1( ERR,
                    "ERROR: Scope name conflict with %ls",
                    g_AddrBuf1 );

            Trace1( ERR, "ERROR: Our name = %ls", snConfName );

            Trace1( ERR, "ERROR: His name = %ls", snMsgName );

            RouterLogEventExW( LOGHANDLE,
                               EVENTLOG_ERROR_TYPE,
                               0,
                               ROUTERLOG_IP_SCOPE_NAME_CONFLICT,
                               L"%S%S%S",
                               g_AddrBuf1,
                               snConfName,
                               snMsgName );
        }
    }
}

VOID
ReportLeakyScope(
    IN PSCOPE_ENTRY      pScope,
    IN IPV4_MZAP_HEADER *mh,
    IN IPV4_ZAM_HEADER  *zam
    )
/*++
Called by:
    HandleZAM(), HandleZLE()
Locks:
    Assumes caller has read lock on BOUNDARY_TABLE so pScope won't go away
--*/
{
    ULONG  ulIdx;
    PWCHAR pwszBuffer, pb;

    Trace1( ERR,
            "ERROR: Leak detected in '%ls' scope!  One of the following routers is misconfigured:", 
            GetDefaultName( pScope ) );

    pb = pwszBuffer = MALLOC( zam->bZT * 20 + 1 );
    if (pwszBuffer is NULL)
    {
        Trace0( ERR, "ERROR: Couldn't allocate space for rest of message");
        return;
    }

    // Add origin.
    swprintf(pb, L"   %d.%d.%d.%d", PRINT_IPADDR(mh->ipMessageOrigin ));
    pb += wcslen(pb);
    
    Trace1( ERR, 
            "   %d.%d.%d.%d", 
            PRINT_IPADDR(mh->ipMessageOrigin ));

    // Display addresses of routers in the path list.
    for (ulIdx=0; ulIdx < zam->bZT; ulIdx++)
    {
        swprintf(pb,L"   %d.%d.%d.%d", PRINT_IPADDR(zam->ipAddress[ulIdx*2+1]));
        pb += wcslen(pb);

        Trace1( ERR, 
                "   %d.%d.%d.%d", 
                PRINT_IPADDR(zam->ipAddress[ulIdx*2+1] ));
    }

    // write to event log

    RouterLogEventExW( LOGHANDLE,
                       EVENTLOG_ERROR_TYPE,
                       0,
                       ROUTERLOG_IP_LEAKY_SCOPE,
                       L"%S%S",
                       GetDefaultName(pScope),
                       pwszBuffer );

    FREE( pwszBuffer );
}

VOID
CheckForScopeRangeMismatch(
    IN IPV4_MZAP_HEADER *mh
    )
/*++
Called by:
    HandleZAM(), HandleZCM()
Locks:
    Assumes caller has read lock on BOUNDARY_TABLE
--*/
{
    PLIST_ENTRY  pleNode;
    PSCOPE_ENTRY pScope;

    for (pleNode = g_MasterScopeList.Flink;
         pleNode isnot &g_MasterScopeList;
         pleNode = pleNode->Flink)
    {
        pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY, leScopeLink);

        if (mh->ipScopeStart > TOP_OF_SCOPE(pScope)
         || mh->ipScopeEnd   < pScope->ipGroupAddress)
            continue;
            
        MakeAddressStringW(g_AddrBuf1, mh->ipScopeStart);
        MakeAddressStringW(g_AddrBuf2, mh->ipScopeEnd);
        MakeAddressStringW(g_AddrBuf3, pScope->ipGroupAddress);
        MakeAddressStringW(g_AddrBuf4, TOP_OF_SCOPE(pScope) );

        Trace1( ERR,
                "ERROR: ZAM scope conflicts with configured scope '%ls'!",
                GetDefaultName(pScope) );

        Trace2( ERR,
                "ERROR: ZAM has: (%ls-%ls)",
                g_AddrBuf1,
                g_AddrBuf2 );

        Trace2( ERR,
                "ERROR: Scope is (%ls-%ls)",
                g_AddrBuf3,
                g_AddrBuf4 );

        RouterLogEventExW( LOGHANDLE,
                           EVENTLOG_ERROR_TYPE,
                           0,
                           ROUTERLOG_IP_SCOPE_ADDR_CONFLICT,
                           L"%S%S%S%S%S",
                           GetDefaultName(pScope),
                           g_AddrBuf1,
                           g_AddrBuf2,
                           g_AddrBuf3,
                           g_AddrBuf4 );

        break;
    }
}

BOOL
ZamIncludesZoneID(
    IPV4_ZAM_HEADER *zam,
    IPV4_ADDRESS     ipZoneID
    )
{
    ULONG ulIdx;

    for (ulIdx=0; ulIdx <= ((ULONG)zam->bZT)*2; ulIdx+=2)
    {
        if (zam->ipAddress[ulIdx] == ipZoneID)
        {
            return TRUE;
        }
    }

    return FALSE;
}

void
HandleZAM(
    IN PBYTE        pBuffer,    // IN: Buffer holding ZAM received
    IN ULONG        ulBuffLen,  // IN: Length of ZAM message
    IN PBOUNDARY_IF pInBIf      // IN: BIf on which ZAM arrived, or NULL
                                //     if it came from "inside"
    )
/*++
Called by:
    HandleMZAPSocket()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE
    Locks ZLE_LIST for writing
--*/
{
    PBYTE             pb;
    IPV4_MZAP_HEADER *mh;
    IPV4_ZAM_HEADER  *zam;
    BOOL              bFound, bFromInside = FALSE;
    PSCOPE_ENTRY      pScope, pOverlap;
    BOUNDARY_ENTRY   *pBoundary = NULL;
    ULONG             ulIdx;
    PBOUNDARY_IF      pBIf;

    mh = (PIPV4_MZAP_HEADER)pBuffer;

    // Set pb to end of MZAP header

    pb = pBuffer + sizeof(IPV4_MZAP_HEADER); 
    for (ulIdx=0; ulIdx < mh->byNameCount; ulIdx++)
    {
        // skip flags
        pb ++;

        // skip language tag len and str
        pb += (1 + *pb);

        // skip scope name len and str
        pb += (1 + *pb);
    }

    // Note that casting to a ULONG is safe, since we only care about
    // the low-order bits anyway.

    while (((ULONG_PTR)pb) & 3)
        *pb++ = '\0';

    zam = (PIPV4_ZAM_HEADER)pb;

    {
        // Find matching scope entry
        pScope = FindScope( mh->ipScopeStart, 
                            ~(mh->ipScopeEnd - mh->ipScopeStart) );
        if (pScope) {
    
            pBoundary = (pInBIf)? FindBoundaryEntry(pInBIf, pScope) : NULL;
    
            if (pBoundary)
            {
                // ZAM arrived from "outside"
    
                //
                // If ZAM is for a scope we're inside, but was received over a
                // boundary, signal a leaky scope warning.
                //
    
                if (mh->ipScopeZoneID == MyScopeZoneID(pScope))
                {
                    ReportLeakyScope(pScope, mh, zam);
                }
    
                // If the previous Local Zone ID was given, update our 
                // local copy.
                if ( zam->ipAddress[ zam->bZT * 2 ] ) 
                {
                    pInBIf->ipOtherLocalZoneID = zam->ipAddress[ zam->bZT * 2 ];
                }
    
                //
                // If ZAM was received on an interface with a boundary for the
                // given scope, drop it.
                //
    
                return;
            }
            else
            {
                // ZAM arrived from "inside"
                bFromInside = TRUE;
    
                // Make sure we know about the origin as a neighbor
                AssertZBR(pScope, mh->ipMessageOrigin, zam->wHoldTime);
    
                //
                // If a ZAM was received from within the zone, then the
                // Zone ID should match.  Persistent mismatches are evidence
                // of a leaky Local Scope.
                //
    
                if (mh->ipScopeZoneID != MyScopeZoneID(pScope))
                {
                    //
                    // Display origin and scope info, warn about
                    // possible leaky local scope.
                    //

                    MakeAddressStringW(g_AddrBuf1, mh->ipMessageOrigin);

                    MakeAddressStringW(g_AddrBuf2, mh->ipScopeStart);
    
                    Trace2( ERR,
                            "WARNING: Possible leaky Local Scope detected between this machine and %ls, boundary exists for %ls.",
                            g_AddrBuf1,
                            g_AddrBuf2 );

                    RouterLogEventExW( LOGHANDLE,
                                       EVENTLOG_WARNING_TYPE,
                                       0,
                                       ROUTERLOG_IP_POSSIBLE_LEAKY_SCOPE,
                                       L"%S%S",
                                       g_AddrBuf1,
                                       g_AddrBuf2 );
                }
    
                // See if scope names don't match
                CheckForScopeNameMismatch(pScope, mh);
            }
    
            // If last local zone ID is 0, but we know a zone ID, fill it in.
            if ( ! zam->ipAddress[ zam->bZT * 2 ] ) 
            {
               if (pBoundary)
                  zam->ipAddress[ zam->bZT*2 ] = pInBIf->ipOtherLocalZoneID;
               else
                  zam->ipAddress[ zam->bZT*2 ] = MyScopeZoneID(pScope);
            }
    
        }
        else 
        {
            //
            // Check for conflicting address ranges.  A scope conflicts
            // if any locally-configured scope's range overlaps that in the ZAM.
            //
    
            CheckForScopeRangeMismatch(mh);
        }
    }

    // Check ZAM cache.  If found, drop new ZAM.
    AssertInZamCache(mh->ipScopeZoneID, mh->ipScopeStart, &bFound);
    Trace3(MCAST, "ZAM Cache check for %d.%d.%d.%d, %d.%d.%d.%d is %d",
                  PRINT_IPADDR(mh->ipScopeZoneID),
                  PRINT_IPADDR( mh->ipScopeStart),
                  bFound);
    if (bFound)
    {
#ifdef SECURE_MZAP
        // If cached ZAM wasn't authenticated, and this one is, 
        // then go ahead and forward it. XXX
#endif
        return;
    }

    // If it's from outside, see if our Local Zone ID is already in 
    // the path list. If so, drop it.
    if (!bFromInside)
    {
        if (ZamIncludesZoneID(zam, g_ipMyLocalZoneID))
            return;
    }

    // Update Zones travelled, and drop if we've reached the limit
    zam->bZT++;
    if (zam->bZT >= zam->bZTL)
    {
        PBYTE  pBufferDup;
        ZLE_PENDING *zle;
        LARGE_INTEGER liCurrentTime, liExpiryTime;
        double x,c,t;

        ENTER_WRITER(MZAP_TIMER);
        ENTER_WRITER(ZLE_LIST);
        {
            // See if one is already scheduled
            if (FindPendingZLE(mh))
            {
                EXIT_LOCK(ZLE_LIST);
                EXIT_LOCK(MZAP_TIMER);
                return;
            }

            // Schedule a ZLE message
            x = UniformRandom01();
            c = 256.0;
            t = ZLE_SUPPRESSION_INTERVAL * log(c*x+1) / log(c);

            // Duplicate the message
            pBufferDup = MALLOC( ulBuffLen );
            if (!pBufferDup)
            {
                EXIT_LOCK(ZLE_LIST);
                EXIT_LOCK(MZAP_TIMER);
                return;
            }

            memcpy(pBufferDup, pBuffer, ulBuffLen);

            NtQuerySystemTime(&liCurrentTime);

            liExpiryTime = RtlLargeIntegerAdd(liCurrentTime, 
              RtlConvertUlongToLargeInteger(TM_SECONDS((ULONG)floor(t+0.5))));

            zle = AddPendingZLE(pBufferDup, ulBuffLen, liExpiryTime);
        }
        EXIT_LOCK(ZLE_LIST);

        UpdateMzapTimer();

        EXIT_LOCK(MZAP_TIMER);

        return;
    }

    // Add our address
    ulBuffLen += 2*sizeof(IPV4_ADDRESS);
    zam->ipAddress[ zam->bZT*2 - 1 ] = g_ipMyAddress;

    // If from outside, inject inside
    if ( !bFromInside )
    {
        zam->ipAddress[ zam->bZT*2 ] = g_ipMyLocalZoneID;

#ifdef DEBUG_MZAP
        Trace0(ERR, "Relaying ZAM inside...");
#endif

        SendMZAPMessage( pBuffer, 
                         ulBuffLen,
                         MZAP_LOCAL_GROUP, 
                         g_ipMyAddress );
    }

    //
    // Re-originate on all interfaces with boundaries
    // (skipping the arrival interface, if it has a boundary)
    // We don't need to hold the lock on the BOUNDARY_TABLE from
    // the first pass above, since it doesn't matter whether the
    // boundaries change in between.
    //
    ENTER_READER(BOUNDARY_TABLE);
    {
        PLIST_ENTRY       pleNode;
        DWORD             dwBucketIdx;

        for (dwBucketIdx = 0;
             dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE;
             dwBucketIdx++)
        {
            for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
                 pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
                 pleNode = pleNode->Flink)
            {
                pBIf = CONTAINING_RECORD( pleNode, 
                                          BOUNDARY_IF, 
                                          leBoundaryIfLink );
        
                if ( pBIf == pInBIf )
                    continue;

                if (FindBoundaryEntry(pBIf, pScope))
                {
#ifdef DEBUG_MZAP
                    Trace1(ERR, "NOT relaying ZAM on IF %d due to boundary",
                                 pBIf->dwIfIndex );
#endif
                    continue;
                }

                // If other local zone ID is already in the path,
                // skip it.

                if (pBIf->ipOtherLocalZoneID
                 && ZamIncludesZoneID(zam, pBIf->ipOtherLocalZoneID))
                    continue;

                zam->ipAddress[ zam->bZT*2 ] = pBIf->ipOtherLocalZoneID;

#ifdef DEBUG_MZAP
                Trace0(ERR, "Relaying ZAM outside by index...");
#endif

                SendMZAPMessageByIndex( pBuffer, 
                                        ulBuffLen, 
                                        MZAP_LOCAL_GROUP, 
                                        pBIf->dwIfIndex );
            }
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);
}

void
HandleZCM(
    IN PBYTE        pBuffer,    // IN: Buffer holding ZAM received
    IN ULONG        ulBuffLen,  // IN: Length of ZAM message
    IN PBOUNDARY_IF pInBIf      // IN: Interface on which the message arrived,
                                //     or NULL if from "inside"
    )
/*++
Called by:
    HandleMZAPSocket()
Locks:
    BOUNDARY_TABLE for reading
--*/
{
    PBYTE             pb;
    IPV4_MZAP_HEADER *mh = (PIPV4_MZAP_HEADER)pBuffer;
    IPV4_ZCM_HEADER  *zcm;
    PSCOPE_ENTRY      pScope;
    ULONG             i;
    BOOL              bRouteFound;

    // Set pb to end of MZAP header

    pb = pBuffer + sizeof(IPV4_MZAP_HEADER); 
    for (i=0; i < mh->byNameCount; i++)
    {
        // skip flags
        pb ++;

        // skip language tag len and str
        pb += (1 + *pb);

        // skip scope name len and str
        pb += (1 + *pb);
    }

    //
    // Note that casting to a ULONG is safe, since we only care about
    // the low-order bits anyway.
    //

    while (((ULONG_PTR)pb) & 3)
        *pb++ = '\0';

    zcm = (PIPV4_ZCM_HEADER)pb;

    ENTER_READER(BOUNDARY_TABLE);
    {
        // Find matching scope entry

        if (mh->ipScopeStart == IPV4_LOCAL_SCOPE_ADDR
         &&  ~(mh->ipScopeEnd - mh->ipScopeStart) == IPV4_LOCAL_SCOPE_MASK)
        {
            pScope = &g_LocalScope;
        }
        else
        {
            pScope = FindScope( mh->ipScopeStart, 
                            ~(mh->ipScopeEnd - mh->ipScopeStart) );
        }

        if (pScope) {
            PBOUNDARY_IF    pBIf;
            PBOUNDARY_ENTRY pBoundary;

            pBoundary = (pInBIf)? FindBoundaryEntry(pInBIf, pScope) : NULL;

            if (pBoundary)
            {
                // ZCM arrived from "outside"
    
                //
                // If ZCM was received on an interface with a boundary for the
                // given scope, drop it.
                //
    
                EXIT_LOCK(BOUNDARY_TABLE);

                return;
            }
            else
            {
                // ZCM arrived from "inside"

#ifdef HAVE_RTMV2
                RTM_NET_ADDRESS  naZBR;
                RTM_DEST_INFO    rdi;
                PRTM_ROUTE_INFO  pri;
                RTM_NEXTHOP_INFO nhi;
                ULONG            ulIdx;
#endif
    
                // Make sure we know about the origin as a neighbor
                AssertZBR(pScope, mh->ipMessageOrigin, zcm->wHoldTime);
    
#ifdef HAVE_RTMV2
                //
                // If multicast RIB route to any router address included
                // is over a boundary for the given scope, signal 
                // non-convexity warning.
                //

                pri = HeapAlloc(
                            IPRouterHeap,
                            0,
                            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                            );

                if (pri == NULL)
                {
                    EXIT_LOCK(BOUNDARY_TABLE);

                    return;
                }
                
                for (i = 0; i < zcm->bZNUM; i++)
                {
                    RTM_IPV4_MAKE_NET_ADDRESS(&naZBR, zcm->ipZBR[i], 32);

                    // Look up route in multicast RIB
                    if ( RtmGetMostSpecificDestination( g_hLocalRoute,
                                                        &naZBR,
                                                        RTM_BEST_PROTOCOL,
                                                        RTM_VIEW_MASK_MCAST,
                                                        &rdi ) isnot NO_ERROR )
                    {
                        continue;
                    }
    
                    //
                    // See if next hop interface has a boundary for the 
                    // ZCM group
                    //

                    ASSERT(rdi.ViewInfo[0].ViewId == RTM_VIEW_ID_MCAST);

                    if ( RtmGetRouteInfo( g_hLocalRoute, 
                                          rdi.ViewInfo[0].Route,
                                          pri,
                                          NULL ) is NO_ERROR )
                    {
                        for (ulIdx = 0;
                             ulIdx < pri->NextHopsList.NumNextHops;
                             ulIdx++)
                        {
                            if ( RtmGetNextHopInfo( g_hLocalRoute,
                                                    pri->NextHopsList.NextHops[ulIdx],
                                                    &nhi ) is NO_ERROR )
                            {
                                if ( RmHasBoundary( nhi.InterfaceIndex,
                                                    MzapRelativeGroup(pScope) ))
                                {
                                    MakeAddressStringW(g_AddrBuf1, 
                                                       mh->ipMessageOrigin);
                                    Trace2( ERR,
                                            "ERROR: non-convex scope zone for '%ls', router %ls",
                                            GetDefaultName(pScope),
                                            g_AddrBuf1 );

                                    RouterLogEventExW( LOGHANDLE,
                                                       EVENTLOG_ERROR_TYPE,
                                                       0,
                                                 ROUTERLOG_NONCONVEX_SCOPE_ZONE,
                                                       L"%S%S",
                                                       GetDefaultName(pScope),
                                                       g_AddrBuf1
                                                     );
                                }

                                RtmReleaseNextHopInfo( g_hLocalRoute, &nhi);
                            }
                        }

                        RtmReleaseRouteInfo( g_hLocalRoute, pri );
                    }

                    RtmReleaseDestInfo(g_hLocalRoute, &rdi);
                }

                HeapFree(IPRouterHeap, 0, pri);
                
#endif /* HAVE_RTMV2 */

                // See if scope names don't match
                CheckForScopeNameMismatch(pScope, mh);
            }
        }
        else 
        {
            //
            // Check for conflicting address ranges.  A scope conflicts
            // if any locally-configured scope's range overlaps that in the ZAM.
            //
            CheckForScopeRangeMismatch(mh);
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);
}

void
HandleZLE(
    IN PBYTE pBuffer,
    IN ULONG ulBuffLen    
    )
/*++
Called by:
    HandleMZAPSocket()
Locks:
    BOUNDARY_TABLE for reading
    ZLE_LIST for writing
--*/
{
    PBYTE             pb;
    IPV4_MZAP_HEADER *mh;
    IPV4_ZAM_HEADER  *zam;
    PSCOPE_ENTRY      pScope;
    ZLE_PENDING      *zle;
    ULONG             ulIdx;

    mh = (PIPV4_MZAP_HEADER)pBuffer;

    // Set pb to end of MZAP header

    pb = pBuffer + sizeof(IPV4_MZAP_HEADER); 
    for (ulIdx=0; ulIdx < mh->byNameCount; ulIdx++)
    {
        // skip flags
        pb ++;

        // skip language tag len and str
        pb += (1 + *pb);

        // skip scope name len and ptr
        pb += (1 + *pb);
    }

    //
    // Note that casting to a ULONG is safe, since we only care about
    // the low-order bits anyway.
    //

    while (((ULONG_PTR)pb) & 3)
        *pb++ = '\0';

    zam = (PIPV4_ZAM_HEADER)pb;

    ENTER_READER(BOUNDARY_TABLE);
    {
        // Find matching scope entry
        pScope = FindScope( mh->ipScopeStart, 
                            ~(mh->ipScopeEnd - mh->ipScopeStart) );

        //
        // ZLE's are multicast.  If we are the "Message Origin", signal a
        // leaky scope warning.  Display addresses of routers in the path list.
        //
    
        if (mh->ipMessageOrigin == g_ipMyAddress)
        {
            ReportLeakyScope(pScope, mh, zam);

            EXIT_LOCK(BOUNDARY_TABLE);
    
            return;
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    // Otherwise, abort any pending ZLE which matches the one received
    ENTER_WRITER(ZLE_LIST);
    {
        if ((zle = FindPendingZLE(mh)) isnot NULL)
        {
            DeletePendingZLE(zle);
        }
    }
    EXIT_LOCK(ZLE_LIST);
}

VOID
HandleMZAPSocket(
    PBOUNDARY_IF pBIf,
    SOCKET       s
    )
/*++
Description:
    Receive an MZAP message on a socket s, and dispatch it to the 
    appropriate function.
Called by:
    HandleMZAPMessages()
Locks:
    Assumes caller holds read lock on BOUNDARY_TABLE if pBIf is non-NULL
--*/
{
    IPV4_MZAP_HEADER *mh;
    DWORD             dwErr, dwNumBytes, dwFlags, dwAddrLen, dwSizeOfHeader;
    DWORD             dwDataLen;
    SOCKADDR_IN       sinFrom;
    WSANETWORKEVENTS  wsaNetworkEvents;

    if (s is INVALID_SOCKET)
        return;

    if (WSAEnumNetworkEvents( s,
                              NULL,
                              &wsaNetworkEvents) is SOCKET_ERROR)
    {
        dwErr = GetLastError();

        Trace1(ERR,
               "HandleMZAPMessages: WSAEnumNetworkEvents() returned %d",
               dwErr);

        return;
    }

    if (!(wsaNetworkEvents.lNetworkEvents & FD_READ))
    {
        return;
    }

    if (wsaNetworkEvents.iErrorCode[FD_READ_BIT] isnot NO_ERROR)
    {
        Trace1( ERR,
                "HandleMZAPMessages: Error %d on FD_READ",
                wsaNetworkEvents.iErrorCode[FD_READ_BIT] );

        return;
    }

    //
    // read the incoming packet.  If the buffer isn't big enough,
    // WSAEMSGSIZE will be returned, and we'll ignore the message.
    // We don't currently expect this will ever happen.
    //

    dwAddrLen  = sizeof(sinFrom);
    dwFlags    = 0;

    dwErr = WSARecvFrom( s,
                         &g_wsaMcRcvBuf,
                         1,
                         &dwNumBytes,
                         &dwFlags,
                         (SOCKADDR FAR *)&sinFrom,
                         &dwAddrLen,
                         NULL,
                         NULL );

    //
    // check if any error in reading packet
    //

    if ((dwErr!=0) || (dwNumBytes==0))
    {
        dwErr = WSAGetLastError();

        Trace1( MCAST,
                "HandleMZAPSocket: Error %d receiving MZAP message",
                dwErr);

        // LogErr1(RECVFROM_FAILED, lpszAddr, dwErr);

        return;
    }

    mh = (PIPV4_MZAP_HEADER)g_wsaMcRcvBuf.buf;

    if (mh->byVersion isnot MZAP_VERSION)
        return;

#ifdef DEBUG_MZAP
    Trace4( MCAST,
            "HandleMZAPSocket: received type %x len %d IF %x from %d.%d.%d.%d",
            mh->byBPType,
            dwNumBytes,
            ((pBIf)? pBIf->dwIfIndex : 0),
            PRINT_IPADDR(mh->ipMessageOrigin) );
#endif

    switch(mh->byBPType & ~MZAP_BIG_BIT) {
    case PTYPE_ZAM: 
        HandleZAM(g_wsaMcRcvBuf.buf, dwNumBytes, pBIf); 
        break;
    case PTYPE_ZLE: 
        HandleZLE(g_wsaMcRcvBuf.buf, dwNumBytes);            
        break;
    case PTYPE_ZCM: 
        HandleZCM(g_wsaMcRcvBuf.buf, dwNumBytes, pBIf); 
        break;
    }

    return;
}

VOID
HandleMZAPMessages()
/*++
Called by:
    WorkerThread() in worker.c
Locks:
    BOUNDARY_TABLE for reading
--*/
{
    DWORD            dwBucketIdx;
    PLIST_ENTRY      pleNode;

    TraceEnter("HandleMZAPMessages");

    ENTER_READER(BOUNDARY_TABLE);
    {
        // Check local socket
        HandleMZAPSocket(NULL, g_mzapLocalSocket);

        // Loop through all BIf entries...
        for (dwBucketIdx = 0;
             dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE;
             dwBucketIdx++)
        {
            for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
                 pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
                 pleNode = pleNode->Flink)
            {
                PBOUNDARY_IF pBIf = CONTAINING_RECORD( pleNode, 
                                                       BOUNDARY_IF,
                                                       leBoundaryIfLink );

                HandleMZAPSocket(pBIf, pBIf->sMzapSocket);
            }
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    TraceLeave("HandleMZAPMessages");
}


//////////////////////////////////////////////////////////////////////////////
// Functions for timer events
//////////////////////////////////////////////////////////////////////////////

DWORD
UpdateMzapTimer()
/*++
Called by:
    AddZBR(), HandleZAM(), HandleMzapTimer()
Locks:
    Assumes caller has write lock on MZAP_TIMER
--*/
{
    DWORD         dwErr = NO_ERROR;
    LARGE_INTEGER liExpiryTime;
    PLIST_ENTRY   pleNode;

    TraceEnter("UpdateMzapTimer");

    //
    // Expiry time of next ZAM/ZCM advertisement is already in
    // g_liZamExpiryTime
    //

    liExpiryTime = g_liZamExpiryTime;

    //
    // Get expiry time of first ZBR
    //

    if (!IsListEmpty( &g_zbrTimerList ))
    {
        ZBR_ENTRY    *pZbr;

        pleNode = g_zbrTimerList.Flink;

        pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leTimerLink);

        if (RtlLargeIntegerLessThan(pZbr->liExpiryTime, liExpiryTime))
        {
            liExpiryTime = pZbr->liExpiryTime;
        }
    }

    //
    // Get expiry time of first ZLE
    //

    if (!IsListEmpty( &g_zleTimerList ))
    {
        ZLE_PENDING  *zle;

        pleNode = g_zleTimerList.Flink;
        
        zle = CONTAINING_RECORD(pleNode, ZLE_PENDING, leTimerLink);

        if (RtlLargeIntegerLessThan(zle->liExpiryTime, liExpiryTime))
        {
            liExpiryTime = zle->liExpiryTime;
        }
    }

    //
    // Reset the event timer
    //

    if (!SetWaitableTimer( g_hMzapTimer,
                           &liExpiryTime,
                           0,
                           NULL,
                           NULL,
                           FALSE ))
    {
        dwErr = GetLastError();

        Trace1( ERR,
                "UpdateMzapTimer: Error %d setting timer",
                dwErr );

    }

    TraceLeave("UpdateMzapTimer");

    return dwErr;
}

VOID
HandleMzapTimer(
    VOID
    )
/*++
Description:
    Process all events which are now due
Locks:
    MZAP_TIMER and then ZBR_LIST for writing
--*/
{
    LARGE_INTEGER liCurrentTime;
    PLIST_ENTRY   pleNode;
    BOOL          bDidSomething;

    TraceEnter("HandleMzapTimer");

    ENTER_WRITER(MZAP_TIMER);

    do 
    {
        bDidSomething = FALSE;

        NtQuerySystemTime(&liCurrentTime);

        //
        // Process timing out ZBRs if due
        //

        ENTER_WRITER(ZBR_LIST);
        {
            for ( pleNode = g_zbrTimerList.Flink;
                  pleNode isnot &g_zbrTimerList;
                  pleNode = g_zbrTimerList.Flink)
            {
                ZBR_ENTRY *pZbr;
    
                pZbr = CONTAINING_RECORD(pleNode, ZBR_ENTRY, leTimerLink);
    
                if (RtlLargeIntegerLessThan(liCurrentTime, pZbr->liExpiryTime))
                    break;

                DeleteZBR(pZbr);

                bDidSomething = TRUE;
            }
        }
        EXIT_LOCK(ZBR_LIST);

        //
        // Process sending ZAM/ZCMs if due
        //

        if (RtlLargeIntegerGreaterThanOrEqualTo(liCurrentTime, 
                                                g_liZamExpiryTime))
        {
            SendAllZamsAndZcms();

            bDidSomething = TRUE;
        }

        //
        // Process sending ZLEs if due
        //

        ENTER_WRITER(ZLE_LIST);
        {
            for ( pleNode = g_zleTimerList.Flink;
                  pleNode isnot &g_zleTimerList;
                  pleNode = g_zleTimerList.Flink)
            {
                ZLE_PENDING *zle;

                zle = CONTAINING_RECORD(pleNode, ZLE_PENDING, leTimerLink);

                if (RtlLargeIntegerLessThan(liCurrentTime, zle->liExpiryTime))
                    break;

                SendZLE( zle );

                bDidSomething = TRUE;
            }
        }
        EXIT_LOCK(ZLE_LIST);

    } while (bDidSomething);

    // Reset the timer

    UpdateMzapTimer();

    EXIT_LOCK(MZAP_TIMER);

    TraceLeave("HandleMzapTimer");
}

//////////////////////////////////////////////////////////////////////////////


DWORD
ActivateMZAP()
/*++
Called by:
    StartMZAP(), BindBoundaryInterface()
--*/
{
    DWORD        dwErr = NO_ERROR;
    DWORD        dwBucketIdx;
    PLIST_ENTRY  pleNode;
    BOOL         bOption;
    SOCKADDR_IN  sinAddr;

    TraceEnter("ActivateMZAP");

    g_ipMyLocalZoneID = g_ipMyAddress;

    MzapInitLocalScope();

    // Start listening for MZAP messages

    g_mzapLocalSocket = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if (g_mzapLocalSocket is INVALID_SOCKET)
    {
        dwErr = WSAGetLastError();
        Trace1(ERR, "ActivateMZAP: error %d creating socket", dwErr);
        TraceLeave("ActivateMZAP");
        return dwErr;
    }

    if (WSAEventSelect( g_mzapLocalSocket,
                        g_hMzapSocketEvent,
                        FD_READ) is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();
        Trace1(ERR,
               "ActivateMZAP: WSAEventSelect failed for local socket, Err=%d",
               dwErr);

        closesocket( g_mzapLocalSocket );

        g_mzapLocalSocket = INVALID_SOCKET;

        TraceLeave("ActivateMZAP");

        return dwErr;
    }

    bOption = TRUE;

    if(setsockopt(g_mzapLocalSocket,
                  SOL_SOCKET,
                  SO_REUSEADDR,
                  (const char FAR*)&bOption,
                  sizeof(BOOL)) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "ActivateMZAP: Couldn't set reuse option - continuing. Error %d",
               WSAGetLastError());
    }

    // Bind to INADDR_ANY/MZAP_PORT to get ZLEs
    sinAddr.sin_family = AF_INET;
    sinAddr.sin_addr.s_addr = INADDR_ANY;
    sinAddr.sin_port = htons(MZAP_PORT);
    if (bind(g_mzapLocalSocket, (struct sockaddr*)&sinAddr, sizeof(sinAddr))
        is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();
        Trace2(ERR, "ActivateMZAP: error %d binding to port %d", dwErr, MZAP_PORT);
        TraceLeave("ActivateMZAP");
        return dwErr;
    }
                              
    // Set TTL to 255
    if (McSetMulticastTtl( g_mzapLocalSocket, 255 ) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "ActivateMZAP: Couldn't set TTL. Error %d",
               WSAGetLastError());
    }

    ENTER_READER(BOUNDARY_TABLE);
    {
        //
        // Join MZAP_RELATIVE_GROUPs locally, to get ZCMs
        //

        for (pleNode = g_MasterScopeList.Flink;
             pleNode isnot &g_MasterScopeList;
             pleNode = pleNode->Flink) 
        {
            SCOPE_ENTRY *pScope = CONTAINING_RECORD(pleNode, SCOPE_ENTRY,
             leScopeLink);
    
            if (McJoinGroup( g_mzapLocalSocket, 
                             MzapRelativeGroup(pScope), 
                             g_ipMyAddress ) is SOCKET_ERROR)
            {
                dwErr = WSAGetLastError();

                Trace3( ERR,
                        "Error %d joining %d.%d.%d.%d on %d.%d.%d.%d",
                        dwErr,
                        PRINT_IPADDR(MzapRelativeGroup(pScope)),
                        PRINT_IPADDR(g_ipMyAddress) );

                EXIT_LOCK(BOUNDARY_TABLE);

                TraceLeave("ActivateMZAP");

                return dwErr;
            }
        }
    
        //
        // Join MZAP_LOCAL_GROUP in each local zone we connect to, to get ZAMs
        //

        if (McJoinGroup( g_mzapLocalSocket, 
                         MZAP_LOCAL_GROUP, 
                         g_ipMyAddress ) is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();

            Trace3( ERR,
                    "Error %d joining %d.%d.%d.%d on %d.%d.%d.%d",
                    dwErr,
                    PRINT_IPADDR(MZAP_LOCAL_GROUP),
                    PRINT_IPADDR(g_ipMyAddress) );

            EXIT_LOCK(BOUNDARY_TABLE);

            TraceLeave("ActivateMZAP");

            return dwErr;
        }

        for (dwBucketIdx = 0;
             dwBucketIdx < BOUNDARY_HASH_TABLE_SIZE;
             dwBucketIdx++)
        {
            for (pleNode = g_bbScopeTable[dwBucketIdx].leInterfaceList.Flink;
                 pleNode isnot & g_bbScopeTable[dwBucketIdx].leInterfaceList;
                 pleNode = pleNode->Flink)
            {
                PBOUNDARY_IF pBIf = CONTAINING_RECORD( pleNode, 
                                                       BOUNDARY_IF,
                                                       leBoundaryIfLink );
                if ( pBIf->sMzapSocket is INVALID_SOCKET )
                {
                    // Interface is not yet active.  The join will be
                    // done at the time BindBoundaryInterface() is called

                    continue;
                }
    
                if (McJoinGroupByIndex( pBIf->sMzapSocket,
                                        SOCK_DGRAM,
                                        MZAP_LOCAL_GROUP, 
                                        pBIf->dwIfIndex ) is SOCKET_ERROR)
                {
                    dwErr = WSAGetLastError();

                    Trace3( ERR,
                            "Error %d joining %d.%d.%d.%d on IF %x",
                            dwErr,
                            PRINT_IPADDR(MZAP_LOCAL_GROUP),
                            pBIf->dwIfIndex );

                    EXIT_LOCK(BOUNDARY_TABLE);

                    TraceLeave("ActivateMZAP");

                    return dwErr;
                }
            }
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    //
    // Initialize timer used for sending messages
    //

    ENTER_WRITER(MZAP_TIMER);
    {
        LARGE_INTEGER liCurrentTime, liExpiryTime;

        NtQuerySystemTime( &liCurrentTime );

        g_liZamExpiryTime = RtlLargeIntegerAdd( liCurrentTime,
         RtlConvertUlongToLargeInteger(TM_SECONDS(ZAM_STARTUP_DELAY)) );

        UpdateMzapTimer();
    }
    EXIT_LOCK(MZAP_TIMER);

    TraceLeave("ActivateMZAP");

    return dwErr;
}

VOID
UpdateLowestAddress(
    PIPV4_ADDRESS pIpAddr, 
    PICB          picb
    )
{
    ULONG ulIdx;

    for (ulIdx=0; ulIdx<picb->dwNumAddresses; ulIdx++)
    {
         if (IS_ROUTABLE(picb->pibBindings[ulIdx].dwAddress)
             && (!*pIpAddr ||
                ntohl(picb->pibBindings[ulIdx].dwAddress)
              < ntohl(*pIpAddr)))
         {
                *pIpAddr = picb->pibBindings[ulIdx].dwAddress;
         }
    }
}

DWORD
MzapActivateBIf( 
    PBOUNDARY_IF pBIf
    )
/*++
Called by:
    AddBIfEntry(), BindBoundaryInterface()
Locks:
    Assumes caller holds at least a read lock on BOUNDARY_TABLE
--*/
{
    BOOL  bOption;
    DWORD dwErr = NO_ERROR;

    pBIf->sMzapSocket = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( pBIf->sMzapSocket is INVALID_SOCKET )
    {
        dwErr = WSAGetLastError();

        Trace1(ERR, "StartMZAP: error %d creating socket", dwErr);

        return dwErr;
    }

    if (setsockopt( pBIf->sMzapSocket,
                    SOL_SOCKET,
                    SO_REUSEADDR,
                    (const char FAR*)&bOption,
                    sizeof(BOOL)) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "MzapInitBIf: Couldn't set reuse option - continuing. Error %d",
               WSAGetLastError());
    }

#if 1
{
    struct sockaddr_in sinAddr;

    //
    // WORKAROUND FOR BUG #222214: must bind before set TTL will work
    //

    sinAddr.sin_family = AF_INET;
    sinAddr.sin_addr.s_addr = INADDR_ANY;
    sinAddr.sin_port = htons(MZAP_PORT);

    if (bind( pBIf->sMzapSocket, 
              (struct sockaddr*)&sinAddr, 
              sizeof(sinAddr) ) is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();

        Trace2( ERR, 
                "StartMZAP: error %d binding boundary socket to port %d", 
                dwErr, 
                MZAP_PORT);

        return dwErr;
    }
}
#endif                              

    // Set TTL to 255
    if (McSetMulticastTtl( pBIf->sMzapSocket, 255) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "StartMZAP: Couldn't set TTL. Error %d",
               WSAGetLastError());
    }

    if (WSAEventSelect( pBIf->sMzapSocket,
                        g_hMzapSocketEvent,
                        FD_READ) is SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();

        Trace1(ERR,
               "StartMZAP: WSAEventSelect failed for local socket, Err=%d",
               dwErr);

        closesocket( pBIf->sMzapSocket );

        pBIf->sMzapSocket = INVALID_SOCKET;

        return dwErr;
    }

    if (g_bMzapStarted)
    {
        if (McJoinGroupByIndex( pBIf->sMzapSocket,
                                SOCK_DGRAM,
                                MZAP_LOCAL_GROUP, 
                                pBIf->dwIfIndex ) is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();

            Trace3( ERR,
                    "Error %d joining %d.%d.%d.%d on IF %x",
                    dwErr,
                    PRINT_IPADDR(MZAP_LOCAL_GROUP),
                    pBIf->dwIfIndex );
        }
    }

    return dwErr;
}

DWORD
BindBoundaryInterface(
    PICB picb
    )
{
    DWORD        dwErr = NO_ERROR;
    ULONG        ulIdx;
    BOUNDARY_IF *pBif;

    TraceEnter("BindBoundaryInterface");

    if (!g_bMzapStarted)
        return NO_ERROR;

    ENTER_READER(BOUNDARY_TABLE);
    {
        pBif = FindBIfEntry(picb->dwIfIndex);

        if ( ! g_ipMyAddress && ! pBif )
        {
            UpdateLowestAddress(&g_ipMyAddress, picb);
    
            if (g_ipMyAddress)
                dwErr = ActivateMZAP();
        }
    
        if ( pBif && (pBif->sMzapSocket is INVALID_SOCKET))
        {
            dwErr = MzapActivateBIf(pBif );
        }
    }
    EXIT_LOCK(BOUNDARY_TABLE);

    TraceLeave("BindBoundaryInterface");

    return dwErr;
}

DWORD
StartMZAP()
/*++
Description:
    Initialize state and start running MZAP()
Called by:
    SetScopeInfo()
Locks:
    ICB_LIST for reading
    BOUNDARY_TABLE for reading
--*/
{
    DWORD        dwErr = NO_ERROR,
                 dwBucketIdx;
    SOCKADDR_IN  sinAddr;
    ULONG        ulIdx;
    PLIST_ENTRY  pleNode;
    PSCOPE_ENTRY pScope;
    BOOL         bOption;

    if (g_bMzapStarted)
        return NO_ERROR;

    g_bMzapStarted = TRUE;

    // Initialize local data structures
    InitializeListHead( &g_leZamCache );
    InitializeListHead( &g_leZleList );
    InitializeListHead( &g_zbrTimerList );
    InitializeListHead( &g_zleTimerList );

    //
    // Set address to lowest routable IP address which has no boundary 
    // configured on it.
    //

    ENTER_READER(ICB_LIST);
    {
        PICB picb;

        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList;
             pleNode = pleNode->Flink)
        {
            picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);
    
            if (FindBIfEntry(picb->dwIfIndex))
                continue;
    
            UpdateLowestAddress(&g_ipMyAddress, picb);

        }
    }
    EXIT_LOCK(ICB_LIST);

    if (!g_ipMyAddress)
    {
        Trace0(ERR, "StartMZAP: no IP address found in local scope");

        return ERROR_NOT_SUPPORTED;
    }

    dwErr = ActivateMZAP();

    return dwErr;
}

void
StopMZAP()
/*++
Called by:
    SetScopeInfo()
--*/
{
    if (!g_bMzapStarted)
        return;

    g_bMzapStarted = FALSE;

    // Stop timer used for sending messages
    ENTER_WRITER(MZAP_TIMER);
    {
        CancelWaitableTimer(g_hMzapTimer);
    }
    EXIT_LOCK(MZAP_TIMER);

    // Stop listening for MZAP messages
    if (g_mzapLocalSocket isnot INVALID_SOCKET)
    {
        closesocket(g_mzapLocalSocket);
        g_mzapLocalSocket = INVALID_SOCKET;
    }

    //
    // Free up local data stores
    //    Empty ZAM cache
    //

    ENTER_WRITER(ZAM_CACHE);
    UpdateZamCache(RtlConvertUlongToLargeInteger(0));
    EXIT_LOCK(ZAM_CACHE);
}

VOID
MzapInitScope(
    PSCOPE_ENTRY pScope
    )
/*++
Description:
    Initialize MZAP fields of a scope
--*/
{
    pScope->ipMyZoneID      = g_ipMyLocalZoneID;    
    InitializeListHead(&pScope->leZBRList);
    pScope->bZTL            = MZAP_DEFAULT_ZTL;
    pScope->ulNumInterfaces = 0;
    pScope->bDivisible      = FALSE;
}



DWORD
MzapInitBIf(
    PBOUNDARY_IF pBIf
    )
/*++
Description:
    Called when the first boundary is added to an interface, and we
    need to start up MZAP on it.  MZAP may (if we add a boundary
    while the router is running) or may not (startup time) already be 
    running at this point.
Called by:
    AddBIfEntry()
Locks:
    Assumes caller holds a write lock on BOUNDARY_TABLE
--*/
{
    BOOL  bOption;
    DWORD dwErr = NO_ERROR;

    pBIf->ipOtherLocalZoneID = 0;
    
    pBIf->sMzapSocket = INVALID_SOCKET;

    return dwErr;
}

VOID
MzapUninitBIf(
    PBOUNDARY_IF pBIf
    )
/*++
Called by:
--*/
{
    if ( pBIf->sMzapSocket isnot INVALID_SOCKET )
    {
        closesocket( pBIf->sMzapSocket );

        pBIf->sMzapSocket = INVALID_SOCKET;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\mbound.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\mbound.h

Abstract:

    Header file for admin-scoped boundaries

Revision History:

    Dave Thaler       20th Apr 1998      Created

--*/

#ifndef __MBOUND_H__
#define __MBOUND_H__

// Definitions for manipulating scope names

#ifdef SN_UNICODE
# define  sn_strlen  wcslen
# define  sn_strcpy  wcscpy
# define  sn_strncpy wcsncpy
# define  sn_strcmp  wcscmp
# define  sn_strncmp wcsncmp
# define  sn_sprintf wsprintf
# define  SN_L       L
#else
# define  sn_strlen  strlen
# define  sn_strcpy  strcpy
# define  sn_strncpy strncpy
# define  sn_strcmp  strcmp
# define  sn_strncmp strncmp
# define  sn_sprintf sprintf
# define  SN_L       
#endif

#define   SNCHARSIZE sizeof(SN_CHAR)

typedef struct _SCOPE_NAME_ENTRY {
    LIST_ENTRY   leNameLink;
    LANGID       idLanguage;
    SCOPE_NAME   snScopeName; // in unicode
    BOOL         bDefault;
} SCOPE_NAME_ENTRY, *PSCOPE_NAME_ENTRY;

typedef struct _SCOPE_ENTRY {
    LIST_ENTRY   leScopeLink;
    IPV4_ADDRESS ipGroupAddress;
    IPV4_ADDRESS ipGroupMask;
    ULONG        ulNumInterfaces;

    ULONG        ulNumNames;
    LIST_ENTRY   leNameList;

    // fields used by MZAP
    BOOL         bDivisible;
    IPV4_ADDRESS ipMyZoneID;
    LIST_ENTRY   leZBRList;
    BYTE         bZTL;
} SCOPE_ENTRY, *PSCOPE_ENTRY;

typedef struct _ZBR_ENTRY {
    LIST_ENTRY    leZBRLink;
    LIST_ENTRY    leTimerLink;
    IPV4_ADDRESS  ipAddress;
    LARGE_INTEGER liExpiryTime;
} ZBR_ENTRY, *PZBR_ENTRY;

typedef struct _BOUNDARY_BUCKET {
    LIST_ENTRY   leInterfaceList;
} BOUNDARY_BUCKET;

typedef struct _BOUNDARY_IF {
    LIST_ENTRY   leBoundaryIfLink;       // entry in list per bucket
    LIST_ENTRY   leBoundaryIfMasterLink; // entry in master list
    DWORD        dwIfIndex;
    LIST_ENTRY   leBoundaryList;

    // fields used by MZAP
    SOCKET       sMzapSocket;
    IPV4_ADDRESS ipOtherLocalZoneID;
} BOUNDARY_IF, *PBOUNDARY_IF;

typedef struct _BOUNDARY_ENTRY {
    LIST_ENTRY   leBoundaryLink;
    PSCOPE_ENTRY pScope;
} BOUNDARY_ENTRY, *PBOUNDARY_ENTRY;

typedef struct _RANGE_ENTRY {
    LIST_ENTRY   leRangeLink;
    IPV4_ADDRESS ipFirst;
    IPV4_ADDRESS ipLast;
} RANGE_ENTRY, *PRANGE_ENTRY;

// should this be moved into some snmp header file?
#define ROWSTATUS_ACTIVE        1
#define ROWSTATUS_NOTINSERVICE  2
#define ROWSTATUS_NOTREADY      3
#define ROWSTATUS_CREATEANDGO   4
#define ROWSTATUS_CREATEANDWAIT 5
#define ROWSTATUS_DESTROY       6

//
// Function prototypes
//

DWORD
SetMcastLimitInfo(
    IN PICB                   picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );                                

DWORD
GetMcastLimitInfo(
    IN     PICB                   picb,
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    );

void
InitializeBoundaryTable();

BOOL
RmHasBoundary(
    IN DWORD        dwIfIndex,
    IN IPV4_ADDRESS ipGroupAddress
    );

DWORD
SetBoundaryInfo(
    IN PICB                   picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );                                

DWORD
GetBoundaryInfo(
    IN     PICB                   picb,
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    );

DWORD
SetScopeInfo(
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );

DWORD
GetScopeInfo(
    IN OUT PRTR_TOC_ENTRY         pToc,
    IN OUT PDWORD                 pdwTocIndex,
    IN OUT PBYTE                  pBuffer,
    IN     PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwBufferSize
    );

DWORD
SNMPSetScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  SCOPE_NAME    snScopeName
    );

DWORD
SNMPAddScope(
    IN  IPV4_ADDRESS  ipGroupAddress,
    IN  IPV4_ADDRESS  ipGroupMask,
    IN  SCOPE_NAME    snScopeName,
    OUT PSCOPE_ENTRY *ppScope
    );

DWORD
SNMPDeleteScope(
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    );                                    

DWORD
SNMPAddBoundaryToInterface(
    IN DWORD         dwIfIndex,
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    );

DWORD
SNMPDeleteBoundaryFromInterface(
    IN DWORD         dwIfIndex,
    IN IPV4_ADDRESS  ipGroupAddress,
    IN IPV4_ADDRESS  ipGroupMask
    );                                    

//----------------------------------------------------------------------------
// BOUNDARY enumeration API
//----------------------------------------------------------------------------

DWORD
RmGetBoundary(
    IN              PMIB_IPMCAST_BOUNDARY   pimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer
);

DWORD
RmGetFirstBoundary(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
);


DWORD
RmGetNextBoundary(
    IN              PMIB_IPMCAST_BOUNDARY   pimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
);

//----------------------------------------------------------------------------
// SCOPE enumeration API
//----------------------------------------------------------------------------

DWORD
RmGetScope(
    IN              PMIB_IPMCAST_SCOPE      pimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer
);

DWORD
RmGetFirstScope(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
);


DWORD
RmGetNextScope(
    IN              PMIB_IPMCAST_SCOPE      pimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
);

#endif


// Constants used by MZAP

#define MZAP_VERSION               0
#define MZAP_LOCAL_GROUP ((DWORD)0xFcFFFFeF) // 239.255.255.252
#define MZAP_RELATIVE_GROUP        3 // TOP-3
#define MZAP_PORT               2106
#define MZAP_DEFAULT_ZTL          32
#if 0 
 // values used for testing
#define DEBUG_MZAP
#define ZAM_INTERVAL               5 // 5 seconds
#define ZAM_HOLDTIME              17 // 17 seconds
#define ZAM_DUP_TIME              15 // 15 seconds
#define ZAM_STARTUP_DELAY          0 // 0 seconds
#define ZCM_INTERVAL               5 // 5 seconds
#define ZCM_HOLDTIME              17 // 17 mins
#define ZLE_SUPPRESSION_INTERVAL   5 // 5 seconds
#define ZLE_MIN_INTERVAL           5 // 5 seconds
#else
#define ZAM_INTERVAL             600 // 10 mins
#define ZAM_HOLDTIME            1860 // 31 mins
#define ZAM_DUP_TIME              30 // 30 seconds
#define ZAM_STARTUP_DELAY          0 // 0 seconds
#define ZCM_INTERVAL             600 // 10 mins
#define ZCM_HOLDTIME            1860 // 31 mins
#define ZLE_SUPPRESSION_INTERVAL 300 // 5 mins
#define ZLE_MIN_INTERVAL         300 // 5 mins
#endif

#define MZAP_BIG_BIT            0x80

#define ADDRFAMILY_IPV4            1
#define ADDRFAMILY_IPV6            2

#define PTYPE_ZAM                  0
#define PTYPE_ZLE                  1
#define PTYPE_ZCM                  2
#define PTYPE_NIM                  3

DWORD
StartMZAP();

void
StopMZAP();

VOID
HandleMZAPMessages();

VOID
HandleMzapTimer();

DWORD
BindBoundaryInterface(
    PICB  picb
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\mhrtbt.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\mhrtbt.c

Abstract:

    Multicast heartbeat

Revision History:

    Amritansh Raghav  

--*/

#include "allinc.h"

HANDLE g_hMHbeatSocketEvent;

DWORD
SetMHeartbeatInfo(
    IN PICB                      picb,
    IN PRTR_INFO_BLOCK_HEADER    pInfoHdr
    )

/*++

Routine Description

    Sets multicast heartbeat information passed to the ICB. 

Locks

    Must be called with ICB_LIST lock held as WRITER

Arguments

    picb        The ICB of the interface for whom the multicast hearbeat
                related variables have to be set
    pInfoHdr    Interface Info header

Return Value

    None

--*/

{
    PMCAST_HBEAT_INFO   pInfo;
    PRTR_TOC_ENTRY      pToc;
    DWORD               dwResult;
    PMCAST_HBEAT_CB     pHbeatCb;    
    
    TraceEnter("SetMHeartbeatInfo");
    
    pHbeatCb = &picb->mhcHeartbeatInfo;

    pToc = GetPointerToTocEntry(IP_MCAST_HEARBEAT_INFO,
                                pInfoHdr);
        
    if(!pToc)
    {
        //
        // Leave things as they are
        //

        TraceLeave("SetMHeartbeatInfo");
        
        return NO_ERROR;
    }

    pInfo = (PMCAST_HBEAT_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                   pToc);

        
    if((pToc->InfoSize is 0) or (pInfo is NULL))
    {
        //
        // If the size is zero, stop detecting
        //
        
        DeActivateMHeartbeat(picb);

        //
        // Also, blow away any old info
        //

        ZeroMemory(pHbeatCb,
                   sizeof(MCAST_HBEAT_CB));

        //
        // Set the socket to invalid
        //
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return NO_ERROR;
    }

    //
    // Set the info present. We dont care if resolution is in progress
    // because it will find that the name has changed or that detection has
    // been deactivated and will not do anything
    //
    
    //
    // If the address protocol or port changes deactivate the heartbeat
    //
    
    if((pInfo->bActive is FALSE) or
       (wcsncmp(pInfo->pwszGroup,
                pHbeatCb->pwszGroup,
                MAX_GROUP_LEN) isnot 0) or
       (pInfo->byProtocol isnot pHbeatCb->byProtocol) or
       (pInfo->wPort isnot pHbeatCb->wPort))
    {
        DeActivateMHeartbeat(picb);
    }

    //
    // Copy out the info
    //

    wcsncpy(pHbeatCb->pwszGroup,
            pInfo->pwszGroup,
            MAX_GROUP_LEN);

    pHbeatCb->pwszGroup[MAX_GROUP_LEN - 1] = UNICODE_NULL;

    pHbeatCb->wPort           = pInfo->wPort;
    pHbeatCb->byProtocol      = pInfo->byProtocol;
    pHbeatCb->ullDeadInterval = 
        (ULONGLONG)(60 * SYS_UNITS_IN_1_SEC * pInfo->ulDeadInterval);
    
    //
    // Leave the group and socket as they are
    //

    //
    // If the info says that detection should be on, but the i/f is not
    // detecting, either it is being switched on or it was deactivated due
    // to a info change and needs to be on
    //

    dwResult = NO_ERROR;
    
    if((pHbeatCb->bActive is FALSE) and
       (pInfo->bActive is TRUE))                              
    {
        pHbeatCb->bActive = TRUE;
        
        dwResult = ActivateMHeartbeat(picb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetMHeartbeatInfo: Error %d activating hbeat for  %S",
                   GetLastError(),
                   picb->pwszName);
        
            ZeroMemory(pHbeatCb,
                       sizeof(MCAST_HBEAT_CB));
        }
    }

    TraceLeave("SetMHeartbeatInfo");

    return dwResult;
}

DWORD
GetMHeartbeatInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr,
    PDWORD                  pdwSize
    )

/*++

Routine Description

    Gets the multicast hearbeat info related to the interface

Locks

    Called with ICB_LIST lock held as READER

Arguments

    picb        The ICB of the interface whose multicast heartbeat information
                is being retrieved
    pToc        Pointer to TOC for router discovery info
    pbDataPtr   Pointer to start of data buffer
    pInfoHdr    Pointer to the header of the whole info
    pdwSize     [IN]  Size of data buffer
                [OUT] Size of buffer consumed

Return Value
  
--*/

{
    PMCAST_HBEAT_INFO   pInfo;
    PMCAST_HBEAT_CB     pHbeatCb;
    
    TraceEnter("GetMHeartbeatInfo");
    
    if(*pdwSize < sizeof(MCAST_HBEAT_INFO))
    {
        *pdwSize = sizeof(MCAST_HBEAT_INFO);

        TraceLeave("GetMHeartbeatInfo");
    
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    *pdwSize = pToc->InfoSize = sizeof(MCAST_HBEAT_INFO);

    //pToc->InfoVersion IP_MCAST_HEARBEAT_INFO;
    pToc->InfoType  = IP_MCAST_HEARBEAT_INFO;
    pToc->Count     = 1;
    pToc->Offset    = (ULONG)(pbDataPtr - (PBYTE) pInfoHdr);
    
    pInfo = (PMCAST_HBEAT_INFO)pbDataPtr;

    pHbeatCb = &picb->mhcHeartbeatInfo;
    
    wcsncpy(pHbeatCb->pwszGroup,
            pInfo->pwszGroup,
            MAX_GROUP_LEN);

    pHbeatCb->pwszGroup[MAX_GROUP_LEN - 1] = UNICODE_NULL;

    
    pInfo->bActive          = pHbeatCb->bActive;
    pInfo->byProtocol       = pHbeatCb->byProtocol;
    pInfo->wPort            = pHbeatCb->wPort;
    pInfo->ulDeadInterval   = 
        (ULONG)(pHbeatCb->ullDeadInterval/(60 * SYS_UNITS_IN_1_SEC));

    
    TraceLeave("GetMHeartbeatInfo");
    
    return NO_ERROR;
}
    
    
DWORD
ActivateMHeartbeat(
    PICB    picb
    )

/*++

Routine Description

    Function to activate heartbeat detection. If there is no info or the
    detection is configured to be inactive, we quit. We try to get the
    group address. If a name is given we queue a worker to resolve the
    group name, otherwise we start detection

Locks

    ICB_LIST lock held as WRITER

Arguments

    picb    ICB of the interface to activate

Return Value


--*/

{
    PMCAST_HBEAT_CB     pHbeatCb;    
    CHAR                pszGroup[MAX_GROUP_LEN];
    PHEARTBEAT_CONTEXT  pContext;
    DWORD               dwResult;


    TraceEnter("ActivateMHeartbeat");
    
    pHbeatCb = &picb->mhcHeartbeatInfo;

    if((pHbeatCb->bActive is FALSE) or
       (pHbeatCb->bResolutionInProgress is TRUE))
    {
        return NO_ERROR;
    }
    
    //
    // Convert to ansi
    //
    
    WideCharToMultiByte(CP_ACP,
                        0,
                        pHbeatCb->pwszGroup,
                        -1,
                        pszGroup,
                        MAX_GROUP_LEN,
                        NULL,
                        NULL);
    
    pHbeatCb->dwGroup = inet_addr((CONST CHAR *)pszGroup);

    if(pHbeatCb->dwGroup is INADDR_NONE)
    {
        //
        // we need to resolve the name. This will be done in a
        // worker function. Create a context for the function and
        // queue it
        //

        pContext = HeapAlloc(IPRouterHeap,
                             0,
                             sizeof(HEARTBEAT_CONTEXT));

        if(pContext is NULL)
        {
            Trace2(ERR,
                   "SetMHeartbeatInfo: Error %d allocating context for %S",
                   GetLastError(),
                   picb->pwszName);
            

            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pContext->dwIfIndex = picb->dwIfIndex;
        pContext->picb      = picb;

        
        CopyMemory(&pContext->pwszGroup,
                   pHbeatCb->pwszGroup,
                   sizeof(MCAST_HBEAT_INFO));
        
        dwResult = QueueAsyncFunction(ResolveHbeatName,
                                      pContext,
                                      FALSE);
        
        if(dwResult isnot NO_ERROR)
        {
            HeapFree(IPRouterHeap,
                     0,
                     pContext);
            
            Trace2(ERR,
                   "SetMHeartbeatInfo: Error %d queuing worker for %S",
                   GetLastError(),
                   picb->pwszName);

            return dwResult;
        }
            
        pHbeatCb->bResolutionInProgress = TRUE;

        return NO_ERROR;
    }
    
    //
    // No need to do name resultion. Just start
    //

    dwResult = StartMHeartbeat(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "SetMHeartbeatInfo: Error %d starting hbeat for %S",
               dwResult,
               picb->pwszName);

    }

    return dwResult;
}

DWORD
StartMHeartbeat(    
    IN PICB  picb
    )

/*++

Routine Description

    Activates router discovery messages on an interface. The interface must 
    already be bound. 

Locks

    Called with the ICB_LIST lock held as WRITER
     
Arguments

    picb          The ICB of the interface to activate

Return Value

    NO_ERROR or some error code 

--*/

{    
    PMCAST_HBEAT_CB    pHbeatCb;
    DWORD              dwResult;

    TraceEnter("ActivateMHeartbeat");

    if((picb->dwAdminState isnot IF_ADMIN_STATUS_UP) or
       (picb->dwOperationalState < IF_OPER_STATUS_CONNECTING))
    {
        TraceLeave("ActivateMHeartbeat");
    
        return NO_ERROR;
    }
    
    pHbeatCb = &picb->mhcHeartbeatInfo;
    
    dwResult = CreateHbeatSocket(picb);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "ActivateMHeartbeat: Couldnt create socket for %S. Error %d",
               picb->pwszName,
               dwResult);

        TraceLeave("ActivateMHeartbeat");
    
        return dwResult;
    }

    //
    // Yes we are active
    //

    pHbeatCb->bActive = TRUE;

    TraceLeave("ActivateMHeartbeat");
    
    return NO_ERROR;
}



DWORD
CreateHbeatSocket(
    IN PICB picb
    )

/*++

Routine Description

    Creates a socket to listen to multicast hearbeat messages

Locks

    ICB_LIST lock must be held as WRITER

Arguments

    picb    The ICB of the interface for which the socket has to be created

Return Value

    NO_ERROR or some error code 

--*/

{
    PMCAST_HBEAT_CB  pHbeatCb;
    DWORD            i, dwResult, dwBytesReturned;
    struct linger    lingerOption;
    BOOL             bOption, bLoopback;
    SOCKADDR_IN      sinSockAddr;
    struct ip_mreq   imOption;
    
    TraceEnter("CreateHbeatSocket");
    
    if(picb->bBound)
    {
        Trace1(ERR,
               "CreateHbeatSocket: Can not activate heartbeat on %S as it is not bound",
               picb->pwszName);

        TraceLeave("CreateHbeatSocket");
        
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // Create the sockets for the interface
    //
    
    pHbeatCb = &(picb->mhcHeartbeatInfo);
    
    
    pHbeatCb->sHbeatSocket = INVALID_SOCKET;


    if(pHbeatCb->byProtocol is IPPROTO_RAW)
    {
        //
        // If we are raw proto, then the port number contains protocol
        //
        
        pHbeatCb->sHbeatSocket = WSASocket(AF_INET,
                                           SOCK_RAW,
                                           LOBYTE(pHbeatCb->wPort),
                                           NULL,
                                           0,
                                           MHBEAT_SOCKET_FLAGS);
    }
    else
    {
        IpRtAssert(pHbeatCb->byProtocol is IPPROTO_UDP);

        pHbeatCb->sHbeatSocket = WSASocket(AF_INET,
                                           SOCK_DGRAM,
                                           IPPROTO_UDP,
                                           NULL,
                                           0,
                                           MHBEAT_SOCKET_FLAGS);
        
    }
    
    if(pHbeatCb->sHbeatSocket is INVALID_SOCKET)
    {
        dwResult = WSAGetLastError();
        
        Trace2(ERR,
               "CreateHbeatSocket: Couldnt create socket on %S. Error %d",
               picb->pwszName,
               dwResult);
        
        TraceLeave("CreateHbeatSocket");
        
        return dwResult;
    }

#if 0
    
    //
    // Set to SO_DONTLINGER
    //
    
    bOption = TRUE;
    
    if(setsockopt(pHbeatCb->sHbeatSocket,
                  SOL_SOCKET,
                  SO_DONTLINGER,   
                  (const char FAR*)&bOption,
                  sizeof(BOOL)) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "CreateHbeatSocket: Couldnt set linger option - continuing. Error %d",
               WSAGetLastError());
    }
    
#endif
        
    //
    // Set to SO_REUSEADDR
    //
    
    bOption = TRUE;
    
    if(setsockopt(pHbeatCb->sHbeatSocket,
                  SOL_SOCKET,
                  SO_REUSEADDR,
                  (const char FAR*)&bOption,
                  sizeof(BOOL)) is SOCKET_ERROR)
    {
        Trace1(ERR,
               "CreateHbeatSocket: Couldnt set reuse option - continuing. Error %d",
               WSAGetLastError());
    }

    //
    // we are interested in READ events only and want the event to be set
    // for those
    //
    
    if(WSAEventSelect(pHbeatCb->sHbeatSocket,
                      g_hMHbeatSocketEvent,
                      FD_READ) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        Trace2(ERR,
               "CreateHbeatSocket: WSAEventSelect() failed for socket on %S.Error %d",
               picb->pwszName,
               dwResult);
        
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
    }
            

    //
    // Bind to one of the addresses on the interface. We just bind to the
    // first address (and the port if specified)
    //
    
    sinSockAddr.sin_family      = AF_INET;
    sinSockAddr.sin_addr.s_addr = picb->pibBindings[0].dwAddress;

    if(pHbeatCb->byProtocol is IPPROTO_UDP)
    {
        sinSockAddr.sin_port = pHbeatCb->wPort;
    }
    else
    {
        sinSockAddr.sin_port = 0;
    }
    
    if(bind(pHbeatCb->sHbeatSocket,
            (const struct sockaddr FAR*)&sinSockAddr,
            sizeof(SOCKADDR_IN)) is SOCKET_ERROR)
    {   
        dwResult = WSAGetLastError();
        
        Trace3(ERR,
               "CreateHbeatSocket: Couldnt bind to %s on interface %S. Error %d",
               inet_ntoa(*(PIN_ADDR)&(picb->pibBindings[0].dwAddress)),
               picb->pwszName,
               dwResult);
            
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
        
    }


#if 0
        
    //
    // Join the multicast session 
    //
    
    sinSockAddr.sin_family      = AF_INET;
    sinSockAddr.sin_addr.s_addr = pHbeatCb->dwGroup;
    sinSockAddr.sin_port        = 0;

    if(WSAJoinLeaf(pHbeatCb->sHbeatSocket,
                   (const struct sockaddr FAR*)&sinSockAddr,
                   sizeof(SOCKADDR_IN),
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   JL_BOTH) is INVALID_SOCKET)
    {
        dwResult = WSAGetLastError();
        
        Trace2(ERR,
               "CreateHbeatSocket: Couldnt join multicast group over %s on %S",
               inet_ntoa(*(PIN_ADDR)&(picb->pibBindings[i].dwAddress)),
               picb->pwszName);
            
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
    }

#else
    
    sinSockAddr.sin_addr.s_addr = picb->pibBindings[0].dwAddress;
    
    if(setsockopt(pHbeatCb->sHbeatSocket,
                  IPPROTO_IP, 
                  IP_MULTICAST_IF,
                  (PBYTE)&sinSockAddr.sin_addr, 
                  sizeof(IN_ADDR)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        Trace2(ERR,
               "CreateHbeatSocket: Couldnt enable mcast over %s on %S",
               inet_ntoa(*(PIN_ADDR)&(picb->pibBindings[0].dwAddress)),
               picb->pwszName);
            
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
    }

    imOption.imr_multiaddr.s_addr = pHbeatCb->dwGroup;
    imOption.imr_interface.s_addr = picb->pibBindings[0].dwAddress;

    if(setsockopt(pHbeatCb->sHbeatSocket,
                  IPPROTO_IP,
                  IP_ADD_MEMBERSHIP,
                  (PBYTE)&imOption,
                  sizeof(imOption)) is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();
        
        Trace3(ERR,
               "CreateHbeatSocket: Couldnt join %d.%d.%d.%d on socket over %s on %S",
               PRINT_IPADDR(pHbeatCb->dwGroup),
               inet_ntoa(*(PIN_ADDR)&(picb->pibBindings[0].dwAddress)),
               picb->pwszName);
        
        closesocket(pHbeatCb->sHbeatSocket);
        
        pHbeatCb->sHbeatSocket = INVALID_SOCKET;
        
        return dwResult;
    }

#endif
    
    TraceLeave("CreateHbeatSocket");
        
    return NO_ERROR;
}

VOID
DeleteHbeatSocket(
    IN PICB picb
    )

/*++

Routine Description

    Deletes the sockets (if any) created for running Router Discovery

Locks


Arguments
    
    picb   The interface whose sockets need to be deleted

Return Value

--*/

{
    PMCAST_HBEAT_CB     pHbeatCb;
    DWORD               i;

    
    pHbeatCb = &(picb->mhcHeartbeatInfo);

    if(pHbeatCb->sHbeatSocket isnot INVALID_SOCKET)
    {
        closesocket(pHbeatCb->sHbeatSocket);
    }

    pHbeatCb->sHbeatSocket = INVALID_SOCKET;
}



DWORD
DeActivateMHeartbeat(    
    IN PICB  picb
    )
{
    PMCAST_HBEAT_CB     pHbeatCb;

    
    TraceEnter("DeActivateMHeartbeat");
    
    pHbeatCb = &(picb->mhcHeartbeatInfo);

    if(!pHbeatCb->bActive)
    {
        return NO_ERROR;
    }

    DeleteHbeatSocket(picb);
    
    pHbeatCb->bActive = FALSE;
    
    TraceLeave("DeActivateMHeartbeat");
    
    return NO_ERROR;
}

VOID
HandleMHeartbeatMessages(
    VOID
    )

/*++

Routine Description
  

Locks


Arguments
      

Return Value
      
--*/

{
    PLIST_ENTRY         pleNode;
    PICB                picb;
    DWORD               i, dwResult, dwRcvAddrLen, dwSizeOfHeader;
    DWORD               dwBytesRead, dwFlags;
    WSANETWORKEVENTS    wsaNetworkEvents;
    SOCKADDR_IN         sinFrom;
    WSABUF              wsaRcvBuf;
    SYSTEMTIME          stSysTime;
    ULARGE_INTEGER      uliTime;
    
    wsaRcvBuf.len = 0;
    wsaRcvBuf.buf = NULL;

    GetSystemTime(&stSysTime);

    SystemTimeToFileTime(&stSysTime,
                         (PFILETIME)&uliTime);
    
    TraceEnter("HandleMHeartbeatMessages");
    
    for(pleNode = ICBList.Flink;
        pleNode isnot &ICBList;
        pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);
        
        //
        // If the interface has no bindings, or isnot involved in
        // multicast heartbeat detection, we wouldnt have
        // opened a socket on it so the FD_READ notification cant be for it
        //
        
        if((picb->bBound is FALSE) or
           (picb->mhcHeartbeatInfo.bActive is FALSE))
        {
            continue;
        }
        
        if(picb->mhcHeartbeatInfo.sHbeatSocket is INVALID_SOCKET)
        {
            continue;
        }
            
        if(WSAEnumNetworkEvents(picb->mhcHeartbeatInfo.sHbeatSocket,
                                NULL,
                                &wsaNetworkEvents) is SOCKET_ERROR)
        {
            dwResult = GetLastError();
            
            Trace1(ERR,
                   "HandleMHeartbeatMessages: WSAEnumNetworkEvents() returned %d",
                   dwResult);
                
            continue;
        }
            
        if(!(wsaNetworkEvents.lNetworkEvents & FD_READ))
        {
            //
            // Read bit isnot set and we arent interested in anything else
            //
            
            continue;
        }
            
        if(wsaNetworkEvents.iErrorCode[FD_READ_BIT] isnot NO_ERROR)
        {
            Trace2(ERR,
                   "HandleMHeartbeatMessages: Error %d associated with socket on %S for FD_READ",
                   wsaNetworkEvents.iErrorCode[FD_READ_BIT],
                   picb->pwszName);
                
            continue;
        }
            
        dwRcvAddrLen = sizeof(SOCKADDR_IN);
        dwFlags      = 0;

        //
        // We dont want the data, we just want to clear out the read
        // notification
        //

        dwResult = WSARecvFrom(picb->mhcHeartbeatInfo.sHbeatSocket,
                               &wsaRcvBuf,
                               1,
                               &dwBytesRead,
                               &dwFlags,
                               (struct sockaddr FAR*)&sinFrom,
                               &dwRcvAddrLen,
                               NULL,
                               NULL);

        if(dwResult is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            if(dwResult isnot WSAEMSGSIZE)
            {
                Trace3(ERR,
                       "HandleMHeartbeatMessages: Error %d in WSARecvFrom on %S. Bytes read %d",
                       dwResult,
                       picb->pwszName,
                       dwBytesRead);
            
                continue;
            }
        }
            
        //
        // If the message is on the group we need to hear from
        // then update the last heard time
        //

        picb->mhcHeartbeatInfo.ullLastHeard = uliTime.QuadPart;
        
    }

    TraceLeave("HandleMHeartbeatMessages");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\mcmisc.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mcmisc.c

Abstract:

    This module implements routines associated with mrinfo and mtrace
    functionality.  

Author:

    dthaler@microsoft.com   2-9-98

Revision History:

--*/

#include "allinc.h"
#include <iptypes.h>
#include <dsrole.h>
#pragma hdrstop

//
// Undefine this if we can't bind/set oif by IfIndex.
// This can be turned on if Bug #208359 gets fixed.
//

#define RAW_UNNUMBERED_SUPPORT

#undef UDP_UNNUMBERED_SUPPORT

// Miscellaneous IGMP socket used for mrinfo, mtrace, etc.

SOCKET McMiscSocket = INVALID_SOCKET;

// Miscellaneous UDP socket used for RAS advertisements, etc.
// Note that no event is currently associated with this socket,
// since it's currently only used for sending.

SOCKET g_UDPMiscSocket = INVALID_SOCKET;

//
// Set this to >0 to generate extra logging information
//

DWORD g_mcastDebugLevel = 0;

//
// This is an array mapping an error code in priority order
// (MFE_...) to the actual value which goes in a packet.
//


//
// MFE_NO_ERROR         0x00
// MFE_REACHED_CORE     0x08
// MFE_NOT_FORWARDING   0x07
// MFE_WRONG_IF         0x01
// MFE_PRUNED_UPSTREAM  0x02
// MFE_OIF_PRUNED       0x03
// MFE_BOUNDARY_REACHED 0x04
// MFE_NO_MULTICAST     0x0A
// MFE_IIF              0x09
// MFE_NO_ROUTE         0x05 - set by rtrmgr
// MFE_NOT_LAST_HOP     0x06 - set by rtrmgr
// MFE_OLD_ROUTER       0x82
// MFE_PROHIBITED       0x83
// MFE_NO_SPACE         0x81
//

static int mtraceErrCode[MFE_NO_SPACE+1] =
{
    0x00,
    0x08,
    0x07,
    0x01,
    0x02,
    0x03,
    0x04,
    0x0A,
    0x09,
    0x05,
    0x06,
    0x82,
    0x83,
    0x81
};

DWORD
MulticastOwner(
    PICB         picb,
    PPROTO_CB   *pcbOwner,
    PPROTO_CB   *pcbQuerier
    )


/*++

Routine Description:

    Looks up which protocol instance "owns" a given interface, and which
    is the IGMP querying instance.   

Locks:

    Assumes caller holds read lock on ICB list

Arguments:

    

Return Value:


--*/

{
    PLIST_ENTRY pleNode;
    PPROTO_CB pOwner = NULL,
        pQuerier = NULL;

    if (g_mcastDebugLevel > 0) {
        
        Trace1(MCAST, "MulticastOwner: Looking for owner of %x", picb);
        
        if ( picb->leProtocolList.Flink == &(picb->leProtocolList))
        {
            Trace0(MCAST, "MulticastOwner: Protocol list is empty.");
        }
    }

    for (pleNode = picb->leProtocolList.Flink;
         pleNode isnot &(picb->leProtocolList); 
         pleNode = pleNode->Flink) 
    { 
        PIF_PROTO  pProto;
        
        pProto = CONTAINING_RECORD(pleNode,
                                   IF_PROTO,
                                   leIfProtoLink);
        
        if (!(pProto->pActiveProto->fSupportedFunctionality & RF_MULTICAST)
            //|| pProto->bPromiscuous
            || !(pProto->pActiveProto->pfnGetNeighbors))
        {
            continue;
        }

        if (!pOwner || pOwner->dwProtocolId==MS_IP_IGMP)
        {
            pOwner = pProto->pActiveProto;
        }

        if (pProto->pActiveProto->dwProtocolId==MS_IP_IGMP)
        {
            pQuerier = pProto->pActiveProto;
        }
    }
    
    if (pcbOwner)
    {
        (*pcbOwner) = pOwner;
    }
    
    if (pcbQuerier)
    {
        (*pcbQuerier) = pQuerier;
    }
    
    return NO_ERROR;
}

IPV4_ADDRESS
defaultSourceAddress(
    PICB picb
    )

/*++

Routine Description:

    Look up the default source address for an interface
    For now, we need to special case IP-in-IP since at least
    the local address is available SOMEWHERE, unlike other 
    unnumbered interfaces!

Locks:

    

Arguments:

    

Return Value:


--*/

{
    if (picb->dwNumAddresses > 0)
    {
        //
        // report 1st binding
        //
        
        return picb->pibBindings[0].dwAddress;
    }
    else
    {
        if ((picb->ritType is ROUTER_IF_TYPE_TUNNEL1) && 
            (picb->pIpIpInfo->dwLocalAddress != 0))
        {
            return picb->pIpIpInfo->dwLocalAddress;
        }
        else
        {
            // XXX fill in 0.0.0.0 until this is fixed
            
            return 0;
        }
    }
}

BOOL
McIsMyAddress(
    IPV4_ADDRESS dwAddr
    )
{
    // XXX test whether dwAddr is bound to any interface.
    // If we return FALSE, then an mtrace with this destination address
    // will be reinjected to be forwarded.

    return FALSE;
}

DWORD
McSetRouterAlert(
    SOCKET       s, 
    BOOL         bEnabled
    )
{
    DWORD   dwErr = NO_ERROR;
    int     StartSnooping = bEnabled;
    int     cbReturnedBytes;
    
    if ( WSAIoctl( s,
                   SIO_ABSORB_RTRALERT,
                   (char *)&StartSnooping, 
                   sizeof(StartSnooping),
                   NULL,
                   0,
                   &cbReturnedBytes,
                   NULL,
                   NULL) ) 
    {
        dwErr = WSAGetLastError();
    }

    return dwErr;
}

DWORD 
StartMcMisc(
    VOID
    )
{
    DWORD           dwErr = NO_ERROR, dwRetval;
    SOCKADDR_IN     saLocalIf;

    Trace1(MCAST,
           "StartMcMisc() initiated with filever=%d",
           VER_PRODUCTBUILD);

    InitializeBoundaryTable();

    do
    {
        //
        // create input socket 
        //
        
        McMiscSocket = WSASocket(AF_INET,
                                 SOCK_RAW,
                                 IPPROTO_IGMP,
                                 NULL,
                                 0,
                                 0);

        if (McMiscSocket == INVALID_SOCKET)
        {
            dwErr = WSAGetLastError();
            
            Trace1(MCAST,
                   "error %d creating mrinfo/mtrace socket",
                   dwErr);
            
            // LogErr1(CREATE_SOCKET_FAILED_2, lpszAddr, dwErr);
            
            break;
        }

        //
        // bind socket to any interface and port 0 (0 => doesnt matter)
        //
        
        saLocalIf.sin_family        = PF_INET;
        saLocalIf.sin_addr.s_addr   = INADDR_ANY;
        saLocalIf.sin_port          = 0;

        //
        // bind the input socket
        //
        
        dwErr = bind(McMiscSocket,
                     (SOCKADDR FAR *)&saLocalIf,
                     sizeof(SOCKADDR));
        
        if (dwErr == SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();
            
            Trace1(MCAST,
                   "error %d binding on mrinfo/mtrace socket",
                   dwErr);
            
            // LogErr1(BIND_FAILED, lpszAddr, dwErr);
            
            break;
        }

        Trace0(MCAST, "StartMcMisc: bind succeeded");

        //
        // to respond to mrinfo, and unicast mtraces, we don't need the 
        // following.
        // To respond to mtrace queries which are multicast
        // (to the group being traced, to ALL-<proto>-ROUTERS, or
        // to ALL-ROUTERS), we do need this.
        //
        

#if 0
#ifdef SIO_RCVALL_HOST
        {
            //
            // put the socket in promiscuous igmp mode.
            // (no need to specify which protocol we want, as it's taken
            //  from the protocol we used in the WSASocket() call above)
            //
            {
                DWORD   dwEnable = 1;
                DWORD   dwNum;
                
                dwRetval = WSAIoctl(McMiscSocket, SIO_RCVALL_HOST, 
                                    (char *)&dwEnable, sizeof(dwEnable), NULL, 0, &dwNum, 
                                    NULL, NULL);
                                    
                if (dwRetval !=0) {
                    // LPSTR lpszAddr = "ANY";
                    dwRetval = WSAGetLastError();
                    Trace1(MCAST, 
                           "error %d setting mrinfo/mtrace socket as host-promiscuous IGMP",
                           dwRetval);
                    // LogErr1(SET_MCAST_IF_FAILED, lpszAddr, dwRetval);

                    // Don't set dwErr in this case, since we can still
                    // respond to unicast queries.
                    break;
                } else { 
                    Trace0(MCAST, "host-promiscuous IGMP enabled on mrinfo/mtrace socket");
                }
            }
        }
#endif
#endif

        // Tell the kernel to hand us IGMP packets with the RouterAlert 
        // option, even if they're not destined to us

        McSetRouterAlert( McMiscSocket, TRUE );

        //
        // Associate an event with the socket
        //
        
        if (WSAEventSelect(McMiscSocket,
                           g_hMcMiscSocketEvent,
                           FD_READ | FD_ADDRESS_LIST_CHANGE) == SOCKET_ERROR)
        {
            Trace1(MCAST, 
                   "StartMcMisc: WSAEventSelect() failed. Error %d",
                   WSAGetLastError());
            
            closesocket(McMiscSocket);
            
            McMiscSocket = INVALID_SOCKET;
            
            continue;
        }
        
    } while(0);

    if (dwErr!=NO_ERROR)
    {
        StopMcMisc();
    }

    return dwErr;
}

VOID 
StopMcMisc(
    VOID
    )
{
    Trace0(MCAST,
           "StopMcMisc() initiated");

    //
    // close input socket
    //
    
    if (McMiscSocket!=INVALID_SOCKET)
    {
        if (closesocket(McMiscSocket) == SOCKET_ERROR) {
            
            Trace1(MCAST,
                   "error %d closing socket",
                   WSAGetLastError());
        }

        McMiscSocket = INVALID_SOCKET;
    }

    Trace0(MCAST, "StopMcMisc() complete");
    
    return;
}

VOID
HandleMcMiscMessages(
    VOID
    )

/*++

Routine Description:

    Accepts mrinfo and mtrace messages and hands them off to the appropriate
    routine.
    Also called to handle address change notification

Locks:

    Acquires the ICB lock as reader if processing Mc messages    

Arguments:

    None 

Return Value:

    None

--*/

{
    DWORD            dwErr, dwNumBytes, dwFlags, dwAddrLen, dwSizeOfHeader;
    DWORD           dwDataLen;
    SOCKADDR_IN        sinFrom;
    PIGMP_HEADER    pIgmpMsg;
    PIP_HEADER      pIpHeader;
    BOOL            bSetIoctl, bUnlock;

    WSANETWORKEVENTS    NetworkEvents;

    bSetIoctl = FALSE;
    bUnlock = FALSE;

    do
    {
        //
        // Figure out if its an address change or read
        //

        dwErr = WSAEnumNetworkEvents(McMiscSocket,
                                     g_hMcMiscSocketEvent,
                                     &NetworkEvents);

        if(dwErr isnot NO_ERROR)
        {
            bSetIoctl = TRUE;

            Trace1(ERR,
                   "HandleMcMiscMessages: Error %d from WSAEnumNetworkEvents",
                   WSAGetLastError());

            break;
        }

        if(NetworkEvents.lNetworkEvents & FD_ADDRESS_LIST_CHANGE)
        {
            bSetIoctl = TRUE;

            dwErr = NetworkEvents.iErrorCode[FD_ADDRESS_LIST_CHANGE_BIT];

           Trace0(GLOBAL,
                  "HandleMcMiscMessages: Received Address change notification");

            if(dwErr isnot NO_ERROR)
            {
                Trace1(ERR,
                       "HandleMcMiscMessages: ErrorCode %d",
                       dwErr);

                break;
            }

            //
            // All's good, handle the binding change
            //

            HandleAddressChangeNotification();

            break;
        }

        ENTER_READER(ICB_LIST);

        bUnlock = TRUE;

        //
        // read the incoming packet
        //
       
        dwAddrLen  = sizeof(sinFrom);
        dwFlags    = 0;

        dwErr = WSARecvFrom(McMiscSocket,
                        &g_wsaMcRcvBuf,
                        1,
                        &dwNumBytes, 
                        &dwFlags,
                        (SOCKADDR FAR *)&sinFrom,
                        &dwAddrLen,
                        NULL,
                        NULL);

        //
        // check if any error in reading packet
        //
        
        if ((dwErr!=0) || (dwNumBytes==0))
        {
            // LPSTR lpszAddr = "ANY";

            dwErr = WSAGetLastError();

            Trace1(MCAST, 
               "HandleMcMiscMessages: Error %d receiving IGMP packet",
               dwErr);

            // LogErr1(RECVFROM_FAILED, lpszAddr, dwErr);

            break;
        }
   
        pIpHeader = (PIP_HEADER)g_wsaMcRcvBuf.buf;
        dwSizeOfHeader = ((pIpHeader->byVerLen)&0x0f)<<2;
        
        pIgmpMsg = (PIGMP_HEADER)(((PBYTE)pIpHeader) + dwSizeOfHeader);
   
        dwDataLen = ntohs(pIpHeader->wLength) - dwSizeOfHeader;
        
        if (g_mcastDebugLevel > 0)
        {
               Trace4(MCAST,
                   "HandleMcMiscMessages: Type is %d (0x%x), code %d (0x%x).",
                   (DWORD)pIgmpMsg->byType,
                   (DWORD)pIgmpMsg->byType,
                   (DWORD)pIgmpMsg->byCode,
                   (DWORD)pIgmpMsg->byCode);
            
               Trace2(MCAST,
                   "HandleMcMiscMessages: IP Length is %d. Header Length  %d",
                   ntohs(pIpHeader->wLength),
                   dwSizeOfHeader);
            
               Trace2(MCAST,
                   "HandleMcMiscMessages: Src: %d.%d.%d.%d dest: %d.%d.%d.%d",
                   PRINT_IPADDR(pIpHeader->dwSrc),
                   PRINT_IPADDR(pIpHeader->dwDest));

            TraceDump(TRACEID,(PBYTE)pIpHeader,dwNumBytes,2,FALSE,NULL);
        }

        //
        // Verify minimum length
        //
        
        if (dwNumBytes < MIN_IGMP_PACKET_SIZE)
        {
            Trace2(MCAST,
               "%d-byte packet from %d.%d.%d.%d is too small",
               dwNumBytes,
               PRINT_IPADDR(pIpHeader->dwSrc));

            break;
        }


        //
        // Check for mal-formed packets that might report bad lengths
        //

        if (dwDataLen > (dwNumBytes - dwSizeOfHeader))
        {
            Trace3(MCAST,
                "%d-byte packet from %d.%d.%d.%d is smaller than "
                "indicated length %d", dwNumBytes, 
                PRINT_IPADDR(pIpHeader->dwSrc),
                dwDataLen);

            break;
        }

        
        //
        // Verify IGMP checksum
        //
        
        if (Compute16BitXSum((PVOID)pIgmpMsg, dwDataLen) != 0)
        {
               Trace4( MCAST,
                    "Wrong IGMP checksum %d-byte packet received from %d.%d.%d.%d, type %d.%d",
                    dwDataLen,
                    PRINT_IPADDR(pIpHeader->dwSrc),
                    pIgmpMsg->byType, pIgmpMsg->byCode );
            
               break;
        }
   
        if (pIgmpMsg->byType is IGMP_DVMRP
            && pIgmpMsg->byCode is DVMRP_ASK_NEIGHBORS2)
        {
               SOCKADDR_IN sinDestAddr;
            
            sinDestAddr.sin_family      = PF_INET;
            sinDestAddr.sin_addr.s_addr = pIpHeader->dwSrc;
            sinDestAddr.sin_port        = 0;
            
               HandleMrinfoRequest((IPV4_ADDRESS)pIpHeader->dwDest, 
                                &sinDestAddr
                               );
            
        }
        else
        {
            if (pIgmpMsg->byType is IGMP_MTRACE_REQUEST)
            {
                HandleMtraceRequest(&g_wsaMcRcvBuf);
            }
        }
        
    } while (FALSE);

    if(bSetIoctl)
    {
        dwErr = WSAIoctl(McMiscSocket,
                         SIO_ADDRESS_LIST_CHANGE,
                         NULL,
                         0,
                         NULL,
                         0,
                         &dwNumBytes,
                         NULL,
                         NULL);

        if(dwErr is SOCKET_ERROR)
        {
            dwErr = WSAGetLastError();

            if((dwErr isnot WSAEWOULDBLOCK) and
               (dwErr isnot WSA_IO_PENDING) and
               (dwErr isnot NO_ERROR))
            {
                Trace1(ERR,
                       "HandleMcMiscMessages: Error %d from SIO_ADDRESS_LIST_CHANGE",
                       dwErr);
            }
        }
    }

    if(bUnlock)
    {
        EXIT_LOCK(ICB_LIST);
    }
}



DWORD
FindBindingWithLocalAddress(
    OUT PICB         *ppicb,
    OUT PIPV4_ADDRESS pdwIfAddress,
    IN  IPV4_ADDRESS  dwAddress
    )
{
    BOOL         bFound = FALSE;
    PLIST_ENTRY  pleNode;
    IPV4_ADDRESS ipFoundMask;
    
    //
    // Lock the ICBList for reading
    //
    
    ENTER_READER(ICB_LIST);

    for (pleNode = ICBList.Flink;
         pleNode isnot &ICBList && !bFound;
         pleNode = pleNode->Flink) 
    {
        DWORD dwIndex;
        PICB  picb;
        
        picb = CONTAINING_RECORD(pleNode,
                                 ICB,
                                 leIfLink);

        for (dwIndex=0;
             dwIndex<picb->dwNumAddresses && !bFound;
             dwIndex++)
        { 
            PICB_BINDING pb = &picb->pibBindings[dwIndex];
            
            if (dwAddress == pb->dwAddress)
            {
                *pdwIfAddress = pb->dwAddress;

                *ppicb = picb;
                
                bFound = TRUE;
            }
        }
    }

    EXIT_LOCK(ICB_LIST);
    
    if (bFound)
    {
        return NO_ERROR;
    }
    
    *ppicb = NULL;
    
    return ERROR_INVALID_PARAMETER;
}

BOOL
IsConnectedTo(
    IN  PICB          picb,
    IN  IPV4_ADDRESS  ipAddress,
    OUT PIPV4_ADDRESS pipLocalAddress   OPTIONAL,
    OUT PIPV4_ADDRESS pipMask           OPTIONAL
    )
{
    DWORD        dwIndex;
    BOOL         bFound = FALSE;
    IPV4_ADDRESS ipFoundMask = 0;

    if (picb->dwRemoteAddress is ipAddress)
    {
        if (pipLocalAddress)
        {
            *pipLocalAddress = defaultSourceAddress(picb);
        }
        if (pipMask)
        {
            *pipMask = ALL_ONES_MASK;
        }
        return TRUE;
    }

    // Find interface with longest match 

    for (dwIndex=0;
         dwIndex<picb->dwNumAddresses && !bFound;
         dwIndex++)
    {
        PICB_BINDING pb = &picb->pibBindings[dwIndex];

        if (((ipAddress & pb->dwMask) is (pb->dwAddress & pb->dwMask))
            && (!bFound || (pb->dwMask > ipFoundMask)))
        {
            if (pipLocalAddress) 
            {
                *pipLocalAddress = pb->dwAddress;
            }

            bFound = TRUE;

            ipFoundMask = pb->dwMask;
        }
    }

    if (pipMask)
    {
        *pipMask = ipFoundMask;
    }

    return bFound;
}

DWORD
FindBindingWithRemoteAddress(
    OUT PICB         *ppicb,
    OUT PIPV4_ADDRESS pdwIfAddress,
    IN  IPV4_ADDRESS  dwAddress
    )
{
    BOOL        bFound = FALSE;
    PLIST_ENTRY pleNode;
    IPV4_ADDRESS ipFoundMask, ipMask, ipLocalAddress;
    
    //
    // Lock the ICBList for reading
    //
    
    ENTER_READER(ICB_LIST);

    for (pleNode = ICBList.Flink;
         pleNode isnot &ICBList;
         pleNode = pleNode->Flink) 
    {
        DWORD dwIndex;
        PICB  picb;
        
        picb = CONTAINING_RECORD(pleNode,
                                 ICB,
                                 leIfLink);

        if (IsConnectedTo(picb, dwAddress, &ipLocalAddress, &ipMask)
         && (!bFound || (ipMask > ipFoundMask)))
        {
            *pdwIfAddress = ipLocalAddress;
            *ppicb        = picb;
            bFound        = TRUE;
            ipFoundMask   = ipMask;
        }
    }

    EXIT_LOCK(ICB_LIST);
    
    if (bFound)
    {
        return NO_ERROR;
    }
    
    *ppicb = NULL;
    
    return ERROR_INVALID_PARAMETER;
}

DWORD
FindBindingForPacket(
    IN  PIP_HEADER    pIpHeader,
    OUT PICB         *ppicb, 
    OUT IPV4_ADDRESS *pdwIfAddr
    )
{
    DWORD dwResult;
    
    dwResult = FindBindingWithRemoteAddress(ppicb,
                                            pdwIfAddr,
                                            pIpHeader->dwSrc);
    
    if (dwResult == NO_ERROR)
    {
        return dwResult;
    }
    
    dwResult = FindBindingWithRemoteAddress(ppicb,
                                            pdwIfAddr,
                                            pIpHeader->dwDest);
    
    return dwResult;
}

VOID
HandleMrinfoRequest(
    IPV4_ADDRESS dwLocalAddr,
    SOCKADDR_IN    *sinDestAddr
    )

/*++

Routine Description:

    Accepts an mrinfo request and sends a reply.    

Locks:

    

Arguments:

    

Return Value:


--*/

{
    DWORD          dwNumBytesSent, dwResult, dwSize = sizeof(MRINFO_HEADER);
    WSABUF         wsMrinfoBuffer;
    MRINFO_HEADER *mriHeader;
    DWORD          dwBufSize;
    IPV4_ADDRESS   dwIfAddr;
    PLIST_ENTRY    pleNode, pleNode2;
    PICB           picb;
    PBYTE          pb;
    BYTE           byIfFlags;
    BOOL           bForMe;

    //
    // If the query was not destined to me, drop it.
    //

    dwResult = FindBindingWithLocalAddress(&picb,
                                           &dwIfAddr, 
                                            dwLocalAddr);

    if (dwResult != NO_ERROR)
    {
        return;
    }

    //
    // Lock the ICBList for reading
    //
    
    ENTER_READER(ICB_LIST);
    
    do 
    {

        //
        // Calculate required size of response packet
        //
        
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList; 
             pleNode = pleNode->Flink) 
        {
            PPROTO_CB pOwner, pQuerier;

            picb = CONTAINING_RECORD(pleNode,
                                     ICB,
                                     leIfLink);
            
            dwResult = MulticastOwner(picb,
                                      &pOwner,
                                      &pQuerier);

            //
            // If we didn't find an owner, then we can skip this
            // interface, since we're not doing multicast routing on it.
            //
            
            if (!pOwner)
            {
                continue;
            }
            
            if (picb->dwNumAddresses > 0)
            {
                //
                // add iface size per address
                //
                
                dwSize += 8+4*picb->dwNumAddresses;
            }
            else
            {
                //
                // add single address size for unnumbered iface
                //
                
                dwSize += 12;
            }
  
            //
            // Call the owner's GetNeighbors() entrypoint
            // with a NULL buffer. This will cause it to tell us the size of
            // its neighbor set
            //
            
            dwBufSize = 0;
            byIfFlags = 0;

            //
            // mrouted doesn't report multiple subnets,
            // so neither do we.  Just group all neighbors
            // together on an interface.
            //
            
            dwResult = (pOwner->pfnGetNeighbors)(picb->dwIfIndex,
                                                 NULL,
                                                 &dwBufSize,
                                                 &byIfFlags);

            if ((dwResult isnot NO_ERROR) and
                (dwResult isnot ERROR_INSUFFICIENT_BUFFER))
            {
                //
                // The only errors which will tell us the size needed are
                // NO_ERROR and ERROR_INSUFFICIENT_BUFFER. Anything else
                // means we didn't get the right size
                //
                
                Trace2(MCAST, 
                       "HandleMrinfoRequest: Error %d in GetNeighbours for %S",
                       dwResult,
                       pOwner->pwszDisplayName);
                
                continue;
            }
            
            dwSize += dwBufSize;
        }

        //
        // We can now malloc a buffer and fill in the info
        //
        
        wsMrinfoBuffer.len = dwSize;
        
        wsMrinfoBuffer.buf = HeapAlloc(IPRouterHeap,
                                       0,
                                       dwSize);

        if(wsMrinfoBuffer.buf is NULL)
        {
            EXIT_LOCK(ICB_LIST);

            return;
        }
        
        mriHeader = (PMRINFO_HEADER)wsMrinfoBuffer.buf;
        
        mriHeader->byType         = IGMP_DVMRP;
        mriHeader->byCode         = DVMRP_NEIGHBORS2;
        mriHeader->wChecksum      = 0;
        mriHeader->byReserved     = 0;

        //
        // MRINFO_CAP_MTRACE - set if mtrace handler is available
        // MRINFO_CAP_SNMP   - set if public IP Multicast MIB is available
        // MRINFO_CAP_GENID  - set if DVMRP 3.255 is available
        // MRINFO_CAP_PRUNE  - set if DVMRP 3.255 is available
        //
        
        mriHeader->byCapabilities = MRINFO_CAP_MTRACE | MRINFO_CAP_SNMP;
        mriHeader->byMinor        = VER_PRODUCTBUILD % 100;
        mriHeader->byMajor        = VER_PRODUCTBUILD / 100;

        //
        // Need to get a list of interfaces, and a list of neighbors
        // (and their info) per interface, updating dwSize as we go.
        //
        
        pb = ((PBYTE) wsMrinfoBuffer.buf) + sizeof(MRINFO_HEADER);
        
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList; 
             pleNode = pleNode->Flink) 
        {
            PBYTE pbNbrCount, pfIfFlags;
            PPROTO_CB pOwner, pQuerier;

            picb = CONTAINING_RECORD(pleNode,
                                     ICB,
                                     leIfLink);
            
            dwResult = MulticastOwner(picb,
                                      &pOwner,
                                      &pQuerier);

            //
            // If we didn't find an owner, then we can skip this
            // interface, since we're not doing multicast routing on it.
            //
            
            if (!pOwner)
            {
                continue;
            }

            //
            // Fill in interface info
            //
            
            *(PIPV4_ADDRESS)pb = defaultSourceAddress(picb);

            pb += 4;
            *pb++ = 1;                      // currently metric must be 1
            *pb++ = (BYTE)picb->dwMcastTtl; // threshold
            *pb = 0;
            
            //
            // Right now, we only report IP-in-IP tunnels with the tunnel flag
            // In the future, a tunnel should have its own MIB-II ifType
            // value, which should be stored in the ICB structure so we can
            // get at it.
            //
            
            if (picb->ritType is ROUTER_IF_TYPE_TUNNEL1)
            {
                //
                // neighbor reached via tunnel
                //
                
                *pb |= MRINFO_TUNNEL_FLAG;
            }
            
            if (picb->dwOperationalState < IF_OPER_STATUS_CONNECTED)
            {
                //
                // operational status down
                //
                
                *pb |= MRINFO_DOWN_FLAG;
            }
            
            if (picb->dwAdminState is IF_ADMIN_STATUS_DOWN)
            {
                //
                // administrative status down
                //
                
                *pb |= MRINFO_DISABLED_FLAG;
            }

            pfIfFlags  = pb++; // save pointer for later updating
            pbNbrCount = pb++; // save pointer to neighbor count location
            *pbNbrCount = 0;

            //
            // Call the routing protocol's GetNeighbors() entrypoint
            // with a pointer into the middle of the current packet buffer.
            //
            
            dwBufSize = dwSize - (DWORD)(pb-(PBYTE)wsMrinfoBuffer.buf);
            
            byIfFlags = 0;
            
            dwResult = (pOwner->pfnGetNeighbors)(picb->dwIfIndex,
                                                 (PDWORD)pb,
                                                 &dwBufSize,
                                                 &byIfFlags);
            
            if (dwBufSize>0)
            {
                pb += dwBufSize;
                (*pbNbrCount)+= (BYTE)(dwBufSize / sizeof(DWORD));
                
            }
            else
            {
                //
                // If the protocol has no neighbors, we fill in 0.0.0.0
                // because the mrinfo client most people use
                // won't display the flags, metric, and threshold
                // unless the neighbors count is non-zero.  0.0.0.0
                // is legal according to the spec.
                //
                
                *(PDWORD)pb = 0;
                
                pb += sizeof(DWORD);
                
                (*pbNbrCount)++;
            }

            //
            // set pim/querier/whatever bits
            //
            
            *pfIfFlags |= byIfFlags;

            //
            // Get querier flag
            //
            
            if (pQuerier isnot NULL && pQuerier isnot pOwner)
            {
                byIfFlags = 0;
                dwBufSize = 0;
                
                dwResult = (pQuerier->pfnGetNeighbors)(picb->dwIfIndex,
                                                       NULL,
                                                       &dwBufSize, 
                                                       &byIfFlags);
                
                *pfIfFlags |= byIfFlags;
            }
        }
        
    } while (FALSE);
    
    EXIT_LOCK(ICB_LIST);

    //
    // Fill in Checksum
    //

    mriHeader->wChecksum = Compute16BitXSum(wsMrinfoBuffer.buf,
                                            dwSize);

    if (g_mcastDebugLevel > 0)
    {
        Trace2(MCAST,
               "HandleMrinfoRequest: sending reply to %d.%d.%d.%d. Len %d", 
               PRINT_IPADDR(sinDestAddr->sin_addr.s_addr),
               wsMrinfoBuffer.len);
    }

    //
    // Send it off
    //
    
    if(WSASendTo(McMiscSocket,
                 &wsMrinfoBuffer,
                 1,
                 &dwNumBytesSent,
                 0,
                 (const struct sockaddr *)sinDestAddr,
                 sizeof(SOCKADDR_IN),
                 NULL,
                 NULL) == SOCKET_ERROR) 
    {
        dwResult = WSAGetLastError();
        
        Trace2(MCAST, 
               "HandleMrinfoRequest: Err %d sending reply to %d.%d.%d.%d",
               dwResult,
               PRINT_IPADDR(sinDestAddr->sin_addr.s_addr));
    }

    //
    // Free the buffer
    //
    
    HeapFree(IPRouterHeap,
             0,
             wsMrinfoBuffer.buf);
}



//
// This function is derived from NTTimeToNTPTime() in 
// src\sockets\tcpcmd\iphlpapi\mscapis.cxx
//

DWORD
GetCurrentNTP32Time(
    VOID
    )


/*++

Routine Description:

   Get current 32-bit NTP timestamp.  The 32-bit form of an NTP timestamp
   consists of the middle 32 bits of the full 64-bit form; that is, the low
   16 bits of the integer part and the high 16 bits of the fractional part.    

Locks:

    

Arguments:

    

Return Value:


--*/

{
    static LARGE_INTEGER li1900 = {0xfde04000, 0x14f373b};
    LARGE_INTEGER liTime;
    DWORD  dwMs;
    ULONG  hi, lo;

    GetSystemTimeAsFileTime((LPFILETIME)&liTime);

    //
    // Seconds is simply the time difference
    //
    
    hi = htonl((ULONG)((liTime.QuadPart - li1900.QuadPart) / 10000000));

    //
    // Ms is the residue from the seconds calculation.
    //
    
    dwMs = (DWORD)(((liTime.QuadPart - li1900.QuadPart) % 10000000) / 10000);

    //
    // time base in the beginning of the year 1900
    //
    
    lo = htonl((unsigned long)(.5+0xFFFFFFFF*(double)(dwMs/1000.0)));

    return (hi << 16) | (lo >> 16);
}

IPV4_ADDRESS
IfIndexToIpAddress(
    DWORD dwIfIndex
    )
{
    // Locate picb
    PICB picb = InterfaceLookupByIfIndex(dwIfIndex);

    return (picb)? defaultSourceAddress(picb) : 0;
}

DWORD
McSetMulticastIfByIndex(
    SOCKET       s, 
    DWORD        dwSockType,
    DWORD        dwIfIndex
    )
{
    DWORD        dwNum, dwErr;
    IPV4_ADDRESS ipAddr;

#ifdef RAW_UNNUMBERED_SUPPORT
    if ((dwSockType is SOCK_RAW)
#ifdef UDP_UNNUMBERED_SUPPORT
     || (dwSockType is SOCK_DGRAM)
#endif 
       )
    {
        dwErr = WSAIoctl( s,
                          SIO_INDEX_MCASTIF,
                          (char*)&dwIfIndex,
                          sizeof(dwIfIndex),
                          NULL,
                          0,
                          &dwNum,
                          NULL,
                          NULL );
    
        return dwErr;
    }
#endif

    //
    // If we can't set oif to an ifIndex yet, then we
    // attempt to map it to some IP address
    //

    ipAddr = IfIndexToIpAddress(dwIfIndex);

    if (!ipAddr)
        return ERROR_INVALID_PARAMETER;

    return McSetMulticastIf( s, ipAddr );
}



DWORD
McSetMulticastIf( 
    SOCKET       s, 
    IPV4_ADDRESS ipAddr
    )
{
    SOCKADDR_IN saSrcAddr;

    saSrcAddr.sin_family      = AF_INET;
    saSrcAddr.sin_port        = 0;
    saSrcAddr.sin_addr.s_addr = ipAddr;
    
    return setsockopt( s,
                       IPPROTO_IP,
                       IP_MULTICAST_IF,
                       (char *)&saSrcAddr.sin_addr,
                       sizeof(IN_ADDR) );
}

DWORD
McSetMulticastTtl( 
    SOCKET  s, 
    DWORD   dwTtl 
    )
{
    return setsockopt( s,
                       IPPROTO_IP,
                       IP_MULTICAST_TTL,
                       (char *)&dwTtl,
                       sizeof(dwTtl) );
}

DWORD
McJoinGroupByIndex(
    IN SOCKET       s,
    IN DWORD        dwSockType,
    IN IPV4_ADDRESS ipGroup, 
    IN DWORD        dwIfIndex  
    )
{
    struct ip_mreq imOption;
    IPV4_ADDRESS   ipInterface;

#ifdef RAW_UNNUMBERED_SUPPORT
    if ((dwSockType is SOCK_RAW)
#ifdef UDP_UNNUMBERED_SUPPORT
     || (dwSockType is SOCK_DGRAM)
#endif
       )
    {
        DWORD dwNum, dwErr;

        imOption.imr_multiaddr.s_addr = ipGroup;
        imOption.imr_interface.s_addr = dwIfIndex;
    
        dwErr = WSAIoctl( s,
                          SIO_INDEX_ADD_MCAST,
                          (char*)&imOption,
                          sizeof(imOption),
                          NULL,
                          0,
                          &dwNum,
                          NULL,
                          NULL );
    
        return dwErr;
    }
#endif

    ipInterface = IfIndexToIpAddress(ntohl(dwIfIndex));

    if (!ipInterface)
    {
        Trace1(MCAST, "McJoinGroup: bad IfIndex 0x%x", ntohl(ipInterface));

        return ERROR_INVALID_PARAMETER;
    }

    return McJoinGroup( s, ipGroup, ipInterface );
}

DWORD
McJoinGroup(
    IN SOCKET       s,
    IN IPV4_ADDRESS ipGroup, 
    IN IPV4_ADDRESS ipInterface
    )
/*++
Description:
    Joins a group on a given interface.
Called by:
Locks:
    None
--*/
{
    struct ip_mreq imOption;

    imOption.imr_multiaddr.s_addr = ipGroup;
    imOption.imr_interface.s_addr = ipInterface;

    return setsockopt( s, 
                       IPPROTO_IP, 
                       IP_ADD_MEMBERSHIP, 
                       (PBYTE)&imOption, 
                       sizeof(imOption));
}

DWORD
McSendPacketTo( 
    SOCKET                      s,
    WSABUF                     *pWsabuf,
    IPV4_ADDRESS                dest
    )
{
    DWORD       dwSent, dwRet;
    int         iSetIp = 1;
    SOCKADDR_IN to;

    // Set header include

    setsockopt( s,
                IPPROTO_IP,
                IP_HDRINCL,
                (char *) &iSetIp,
                sizeof(int) );

    // Send the packet

    to.sin_family      = AF_INET;
    to.sin_port        = 0;
    to.sin_addr.s_addr = dest;

    dwRet = WSASendTo( s, 
                       pWsabuf, 
                       1, 
                       &dwSent, 
                       0, 
                       (const struct sockaddr FAR *)&to, 
                       sizeof(to), 
                       NULL, NULL );

    // Clear header include

    iSetIp = 0;
    setsockopt( s,
                IPPROTO_IP,
                IP_HDRINCL,
                (char *) &iSetIp,
                sizeof(int) );

    return dwRet;
}

DWORD
ForwardMtraceRequest(
    IPV4_ADDRESS   dwForwardDest,
    IPV4_ADDRESS   dwForwardSrc,
    PMTRACE_HEADER pMtraceMsg,
    DWORD          dwMessageLength
    )

/*++

Routine Description:

    Pass an mtrace request to the next router upstream

Locks:

    

Arguments:

    

Return Value:


--*/

{
    SOCKADDR_IN saDestAddr;
    INT         iLength;
    DWORD       dwErr = NO_ERROR;

    //
    // Recalculate Checksum
    //
    
    pMtraceMsg->wChecksum = 0;
    
    pMtraceMsg->wChecksum = Compute16BitXSum((PVOID)pMtraceMsg,
                                             dwMessageLength);

    if (dwForwardSrc && IN_MULTICAST(ntohl(dwForwardDest)))
    {
        dwErr = McSetMulticastIf( McMiscSocket, dwForwardSrc );

    }

    //
    // Send it off
    //
    
    saDestAddr.sin_family      = AF_INET;
    saDestAddr.sin_port        = 0;
    saDestAddr.sin_addr.s_addr = dwForwardDest;
    
    iLength = sendto(McMiscSocket,
                     (PBYTE)pMtraceMsg,
                     dwMessageLength,
                     0,
                     (PSOCKADDR) &saDestAddr,
                     sizeof(SOCKADDR_IN));

    return dwErr;
}

VOID
SendMtraceResponse(
    IPV4_ADDRESS   dwForwardDest,
    IPV4_ADDRESS   dwForwardSrc,
    PMTRACE_HEADER pMtraceMsg,
    DWORD          dwMessageLength
    )

/*++

Routine Description:

    Send a reply to the response address

Locks:

    

Arguments:

    

Return Value:


--*/

{
    SOCKADDR_IN saDestAddr;
    INT         iLength;

    //
    // Source Address can be any of our addresses, but should
    // be one which is in the multicast routing table if that
    // can be determined.
    // XXX
    //

    //
    // If the response address is multicast, use the TTL supplied in the header
    //
    
    if (IN_MULTICAST(ntohl(dwForwardDest)))
    {
        DWORD dwTtl, dwErr;
        
        //
        // Copy Response TTL from traceroute header into IP header
        //

        dwErr = McSetMulticastTtl( McMiscSocket, (DWORD)pMtraceMsg->byRespTtl );
    }

    //
    // Change message type to response
    //
    
    pMtraceMsg->byType = IGMP_MTRACE_RESPONSE;

    ForwardMtraceRequest(dwForwardDest,
                         dwForwardSrc,
                         pMtraceMsg,
                         dwMessageLength);
}

BYTE
MaskToMaskLen(
    IPV4_ADDRESS dwMask
    )
{
    register int i;

    dwMask = ntohl(dwMask);
    
    for (i=0; i<32 && !(dwMask & (1<<i)); i++);
    
    return 32-i;
}

//
// Test whether an interface is a p2p interface.
//

DWORD
IsPointToPoint(
    PICB  picb
    )
{
    // all tunnels are p2p
    if (picb->ritType == ROUTER_IF_TYPE_TUNNEL1)
        return 1;

    // all unnumbered interfaces are p2p
    if (! picb->dwNumAddresses)
        return 1;

    // a numbered interface with a /32 mask is p2p
    if (picb->pibBindings[0].dwMask == 0xFFFFFFFF)
        return 1;

    // everything else isn't
    return 0;
}

//
// Look up route to S or G ***in the M-RIB*** 
// XXX We actually need to query the MGM to get the right route
// from the routing protocol.  Since the MGM doesn't let us do
// this yet, we'll make a good guess for now.  This will work for 
// BGMP but not for PIM-SM (*,G) or CBT.
//
BOOL
McLookupRoute( 
    IN  IPV4_ADDRESS  ipAddress,
    IN  BOOL          bSkipFirst,
    OUT PBYTE         pbySrcMaskLength,
    OUT PIPV4_ADDRESS pipNextHopAddress, 
    OUT PDWORD        pdwNextHopIfIndex,
    OUT PDWORD        pdwNextHopProtocol 
    )
#ifdef HAVE_RTMV2
{
    RTM_DEST_INFO       rdi, rdi2;
    PRTM_ROUTE_INFO     pri;
    RTM_NEXTHOP_INFO    nhi;
    RTM_ENTITY_INFO     rei;
    RTM_NET_ADDRESS     naAddress;
    BOOL                bRouteFound = FALSE;
    DWORD               dwErr;

    pri = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if (pri == NULL)
    {
        return FALSE;
    }
            
    RTM_IPV4_MAKE_NET_ADDRESS(&naAddress, ipAddress, 32);

    dwErr = RtmGetMostSpecificDestination( g_hLocalRoute,
                                           &naAddress,
                                           RTM_BEST_PROTOCOL,
                                           RTM_VIEW_MASK_MCAST,
                                           &rdi );

    if (bSkipFirst)
    {
        dwErr = RtmGetLessSpecificDestination( g_hLocalRoute,
                                               rdi.DestHandle,
                                               RTM_BEST_PROTOCOL,
                                               RTM_VIEW_MASK_MCAST,
                                               &rdi2 );

        RtmReleaseDestInfo( g_hLocalRoute, &rdi);

        memcpy(&rdi, &rdi2, sizeof(rdi));
    }

    if (dwErr is NO_ERROR)
    {
        ASSERT( rdi.ViewInfo[0].ViewId is RTM_VIEW_ID_MCAST);

        dwErr = RtmGetRouteInfo( g_hLocalRoute,
                                 rdi.ViewInfo[0].Route,
                                 pri,
                                 NULL );

        if (dwErr is NO_ERROR)
        {
            ULONG ulNHopIdx;
            ULONG ulDummyLen;

            bRouteFound = TRUE;

            RtmGetEntityInfo( g_hLocalRoute,
                              pri->RouteOwner,
                              &rei );

            // XXX Use 1st next hop for now.  Should query MGM.
            ulNHopIdx = 0;
            
            if (RtmGetNextHopInfo( g_hLocalRoute,
                                   pri->NextHopsList.NextHops[ulNHopIdx],
                                   &nhi ) is NO_ERROR )
            {
                RTM_IPV4_GET_ADDR_AND_LEN( *pipNextHopAddress, 
                                           ulDummyLen, 
                                           &nhi.NextHopAddress );
                *pbySrcMaskLength  = (BYTE)rdi.DestAddress.NumBits;
                *pdwNextHopIfIndex = nhi.InterfaceIndex;
                *pdwNextHopProtocol= PROTO_FROM_PROTO_ID( 
                                      rei.EntityId.EntityProtocolId );

                RtmReleaseNextHopInfo( g_hLocalRoute, &nhi );
            }

            RtmReleaseRouteInfo( g_hLocalRoute, pri );
        }
            
        if (g_mcastDebugLevel > 0)
        {
            Trace6(MCAST,
                   "%d.%d.%d.%d matched %d.%d.%d.%d/%x", 
                   PRINT_IPADDR(ipAddress),
                   rdi.DestAddress.AddrBits[0],
                   rdi.DestAddress.AddrBits[1],
                   rdi.DestAddress.AddrBits[2],
                   rdi.DestAddress.AddrBits[3],
                   rdi.DestAddress.NumBits);

            // XXX Get and show next hop
        }

        RtmReleaseDestInfo( g_hLocalRoute, &rdi);
    }

    HeapFree(IPRouterHeap, 0, pri);
    
    return bRouteFound;
}
#else 
{
    // RTMV1 has no multicast RIB, and the unicast RIB may be wrong.

    return FALSE;
}
#endif

VOID
HandleMtraceRequest(
    WSABUF    *pWsabuf
    )
/*++
Locks:
    Assumes caller holds read lock on ICB list
--*/
{
    DWORD   dwSizeOfHeader, dwBlocks, dwOutBufferSize, dwSize;
    DWORD   dwProtocolGroup, dwResult, dwErr;
    IPV4_ADDRESS dwForwardDest = 0;
    BYTE    byStatusCode = MFE_NO_ERROR;
    BYTE    byProtoStatusCode = MFE_NO_ERROR;
    BYTE    byProtocol;
    PICB    picbIif, picbOif;
    IPV4_ADDRESS dwIifAddr, dwOifAddr;
    WSABUF  wsMtraceBuffer;
    BOOL    bRouteFound;

    MIB_IPMCAST_MFE     mimInMfe;
    PPROTO_CB           pOifOwner, pIifOwner;

    PMTRACE_HEADER              pMtraceMsg;
    PMTRACE_RESPONSE_BLOCK      pBlock;
    PMIB_IPMCAST_MFE_STATS      mfeStats;

    PIP_HEADER pIpHeader = (PIP_HEADER)pWsabuf->buf;

    //
    // Route fields independent of which version of RTM we're using
    //

    BYTE         bySrcMaskLength  = 0;
    IPV4_ADDRESS ipNextHopAddress = 0;
    DWORD        dwNextHopIfIndex = 0;
    DWORD        dwNextHopProtocol= 0;

    dwSizeOfHeader = ((pIpHeader->byVerLen)&0x0f)<<2;
    
    pMtraceMsg = (PMTRACE_HEADER)(((PBYTE)pIpHeader) + dwSizeOfHeader);
    
    dwBlocks = (ntohs(pIpHeader->wLength) - dwSizeOfHeader 
                - sizeof(MTRACE_HEADER)) / sizeof(MTRACE_RESPONSE_BLOCK);

    //
    // If Query (no response blocks) received via routeralert and we're 
    // not lasthop router, then silently drop it.
    //
    
    if (!dwBlocks)
    {
        BOOL isLastHop;

        //
        // Check whether we're the last-hop router by seeing if we
        // have a multicast-capable interface on the same subnet as
        // the destination address, and we are the router that would
        // forward traffic from the given source onto the oif.
        //
        
        dwResult = FindBindingWithRemoteAddress(&picbOif,
                                                &dwOifAddr, 
                                                pMtraceMsg->dwDestAddress);
        
        isLastHop = (dwResult == NO_ERROR);

        if (!isLastHop)
        {
            // If multicast, or if unicast but not to us, reinject

            if (IN_MULTICAST(ntohl(pIpHeader->dwDest))
             || !McIsMyAddress(pMtraceMsg->dwDestAddress))
            {
                Trace1(MCAST, "Mtrace: reinjecting packet to %d.%d.%d.%d",
                       PRINT_IPADDR(pIpHeader->dwDest));

                McSendPacketTo( McMiscSocket,
                                pWsabuf,
                                pMtraceMsg->dwDestAddress);

                return;
            }

            //
            // Ok, this was received via unicast to us, and we want to
            // trace starting from this router, but we don't
            // know what oif would be used, so we need to put
            // 0 in the message.
            //
            
            picbOif   = NULL;
            dwOifAddr = 0;

            //
            // note error code of 0x06
            //
            
            byStatusCode = MFE_NOT_LAST_HOP;
        }
    }
    else
    {
        //
        // If Request (response blocks exist) received via non-link-local 
        // multicast, drop it.
        //
        
        if (IN_MULTICAST(ntohl(pIpHeader->dwDest)) &&
            ((pIpHeader->dwDest & LOCAL_NET_MULTICAST_MASK) != LOCAL_NET_MULTICAST))
        {
            return;
        }
        
        //
        // Match interface on which request arrived
        //
        
        dwResult = FindBindingForPacket(pIpHeader,
                                        &picbOif,
                                        &dwOifAddr);
        
        if(dwResult != NO_ERROR)
        {
            //
            // Drop it if we couldn't find the interface.
            // Since it was received via link-local multicast,
            // this should never happen.
            //
            
            if (g_mcastDebugLevel > 0)
            {
                Trace0(MCAST, "Mtrace: no matching interface");
            }
            
            return; 
        }
    }

    //
    // 1) Insert a new response block into the packet and fill in the
    //    Query Arrival Time, Outgoing Interface Address, Output
    //    Packet Count, and FwdTTL.
    // if (XXX can insert)
    //
    
    {
        dwSize = sizeof(MTRACE_HEADER) + dwBlocks*sizeof(MTRACE_RESPONSE_BLOCK);
        wsMtraceBuffer.len = dwSize + sizeof(MTRACE_RESPONSE_BLOCK);
        wsMtraceBuffer.buf = HeapAlloc(IPRouterHeap, 0, wsMtraceBuffer.len);

        if (wsMtraceBuffer.buf == NULL)
        {
            Trace0( MCAST, "Couldn't allocate memory for mtrace response" );
            return;
        }

        CopyMemory(wsMtraceBuffer.buf, pMtraceMsg, dwSize);
        pBlock = (PMTRACE_RESPONSE_BLOCK)(((PBYTE)wsMtraceBuffer.buf) + dwSize);
        dwBlocks++;
        ZeroMemory(pBlock, sizeof(MTRACE_RESPONSE_BLOCK));

        pBlock->dwQueryArrivalTime = GetCurrentNTP32Time();
        pBlock->dwOifAddr          = dwOifAddr;
        if (picbOif) {
            IP_MCAST_COUNTER_INFO oifStats;
            GetInterfaceMcastCounters(picbOif, &oifStats);
            pBlock->dwOifPacketCount = htonl((ULONG)oifStats.OutMcastPkts);

            if (g_mcastDebugLevel > 0)
                Trace1(MCAST, "dwOifPacketCount = %d", oifStats.OutMcastPkts);

            pBlock->byOifThreshold   = (BYTE)picbOif->dwMcastTtl;
        } else {
            pBlock->dwOifPacketCount = 0;
            pBlock->byOifThreshold   = 0;
        }
    }
    // else {
    //    byStatusCode = MFE_NO_SPACE;
    // }

    //
    // 2) Attempt to determine the forwarding information for the
    //    source and group specified, using the same mechanisms as
    //    would be used when a packet is received from the source
    //    destined for the group.  (State need not be initiated.)
    //
    
    ZeroMemory( &mimInMfe, sizeof(mimInMfe) );
    
    mimInMfe.dwGroup   = pMtraceMsg->dwGroupAddress;
    mimInMfe.dwSource  = pMtraceMsg->dwSourceAddress;
    mimInMfe.dwSrcMask = 0xFFFFFFFF;
    
    dwOutBufferSize = 0;
    
    dwResult = MgmGetMfeStats(
                    &mimInMfe, &dwOutBufferSize, (PBYTE)NULL, 
                    MGM_MFE_STATS_0
                    );

    if (dwResult isnot NO_ERROR)
    {
        mfeStats = NULL; 
    }
    else
    {
        mfeStats = HeapAlloc(IPRouterHeap,
                             0,
                             dwOutBufferSize);
        
        dwResult = MgmGetMfeStats(
                        &mimInMfe,
                        &dwOutBufferSize,
                        (PBYTE)mfeStats,
                        MGM_MFE_STATS_0
                        );
    
        if (dwResult isnot NO_ERROR)
        {
            HeapFree(IPRouterHeap,
                     0,
                     mfeStats);

            mfeStats = NULL;
        }
    }
    
    if (mfeStats)
    {
        //
        // MFE was found...
        //

        dwNextHopProtocol  = mfeStats->dwRouteProtocol;
        dwNextHopIfIndex   = mfeStats->dwInIfIndex;
        ipNextHopAddress   = mfeStats->dwUpStrmNgbr;
        bySrcMaskLength    = MaskToMaskLen(mfeStats->dwRouteMask);

        bRouteFound = TRUE;
    }
    else
    {
        bRouteFound = FALSE;

        if (pMtraceMsg->dwSourceAddress == 0xFFFFFFFF)
        {
            //
            // G route
            //
            
            bRouteFound = McLookupRoute( pMtraceMsg->dwGroupAddress,
                                         FALSE,
                                         & bySrcMaskLength,
                                         & ipNextHopAddress, 
                                         & dwNextHopIfIndex,
                                         & dwNextHopProtocol );
    
            if (ipNextHopAddress is IP_LOOPBACK_ADDRESS)
            {
                // It's one of our addresses, so switch to the interface
                // route instead of the loopback one.

                bRouteFound = McLookupRoute( pMtraceMsg->dwGroupAddress,
                                             TRUE,
                                             & bySrcMaskLength,
                                             & ipNextHopAddress, 
                                             & dwNextHopIfIndex,
                                             & dwNextHopProtocol );
            }

            bySrcMaskLength = 0; // force source mask length to 0
        }
        else
        {
            //
            // S route
            //
            
            bRouteFound = McLookupRoute( pMtraceMsg->dwSourceAddress,
                                         FALSE,
                                         & bySrcMaskLength,
                                         & ipNextHopAddress, 
                                         & dwNextHopIfIndex,
                                         & dwNextHopProtocol );

            if (ipNextHopAddress is IP_LOOPBACK_ADDRESS)
            {
                // It's one of our addresses, so switch to the interface
                // route instead of the loopback one.
    
                bRouteFound = McLookupRoute( pMtraceMsg->dwSourceAddress,
                                             TRUE,
                                             & bySrcMaskLength,
                                             & ipNextHopAddress, 
                                             & dwNextHopIfIndex,
                                             & dwNextHopProtocol );
            }
        }
    }

    picbIif   = (dwNextHopIfIndex)? InterfaceLookupByIfIndex(dwNextHopIfIndex) : 0;
    dwIifAddr = (picbIif)? defaultSourceAddress(picbIif) : 0;

    // If the source is directly-connected, make sure the next hop
    // address is equal to the source.  Later on below, we'll set the 
    // forward destination to the response address

    if (picbIif 
     && (pMtraceMsg->dwSourceAddress isnot 0xFFFFFFFF)
     && IsConnectedTo(picbIif, pMtraceMsg->dwSourceAddress, NULL, NULL))
    {
        ipNextHopAddress = pMtraceMsg->dwSourceAddress;
    }

    // 
    // New Rule: if received via link-local multicast, then silently
    // drop requests if we know we're not the forwarder
    //

    if ((pIpHeader->dwDest & LOCAL_NET_MULTICAST_MASK) == LOCAL_NET_MULTICAST)

    {
        // If we don't have a route to another iface, we're not forwarder
        if (!picbIif || picbIif==picbOif)
        {
            return;
        }
    }

    //
    // Special case: if we matched a host route pointing back to us,
    // then we've actually reached the source.
    //
    
    if (dwIifAddr == IP_LOOPBACK_ADDRESS)
    {
        dwIifAddr = pMtraceMsg->dwSourceAddress;
    }

    //
    // Initialize all fields
    // spec doesn't say what value to use as "other"
    //
    
    byProtocol      = 0; 
    dwProtocolGroup = ALL_ROUTERS_MULTICAST_GROUP;

    //
    // 3) If no forwarding information can be determined, set error
    //    to MFE_NO_ROUTE, zero remaining fields, and forward to
    //    requester.
    //
    
    if (!picbIif)
    {
        if (byStatusCode < MFE_NO_ROUTE)
        {
            byStatusCode = MFE_NO_ROUTE;
        }
        
        dwForwardDest = pMtraceMsg->dwResponseAddress;
        
        pIifOwner = NULL;
        
    }
    else
    {
        //
        // Calculate Mtrace protocol ID and next hop group address
        // (Yes, the protocol ID field in the spec really is one big
        // hairy mess)
        //
        
        dwResult = MulticastOwner(picbIif,
                                  &pIifOwner,
                                  NULL);
        
        if(pIifOwner)
        {
            switch(PROTO_FROM_PROTO_ID(pIifOwner->dwProtocolId))
            {
                //
                // Fill this in for every new protocol added.
                //
                // We'll be nice and fill in code for protocols which aren't
                // implemented yet.
                //

#if defined(PROTO_IP_DVMRP) && defined(ALL_DVMRP_ROUTERS_MULTICAST_GROUP)
                case PROTO_IP_DVMRP:
                {
                    if (rir.RR_RoutingProtocol is PROTO_IP_LOCAL)
                    {
                        //
                        // Static route
                        //
                        
                        byProtocol   = 7;
                    }
                    else
                    {
                        //
                        // Non-static route
                        //
                        
                        byProtocol   = 1;
                    }
                    
                    dwProtocolGroup = ALL_DVMRP_ROUTERS_MULTICAST_GROUP;
                    
                    break;
                }
#endif
#if defined(PROTO_IP_MOSPF) && defined(ALL_MOSPF_ROUTERS_MULTICAST_GROUP)
                case PROTO_IP_MOSPF:
                {
                    byProtocol      = 2;
                    
                    dwProtocolGroup = ALL_MOSPF_ROUTERS_MULTICAST_GROUP;
                    
                    break;
                }
#endif
#if defined(PROTO_IP_PIM) && defined(ALL_PIM_ROUTERS_MULTICAST_GROUP)
                case PROTO_IP_PIM:
                {
                    if (rir.RR_RoutingProtocol is PROTO_IP_LOCAL)
                    {
                        //
                        // Static route
                        //
                        
                        byProtocol   = 6;
                    }
                    else
                    {
                        if (0)
                        {
                            //
                            // XXX Non-static, M-RIB route!=U-RIB route
                            //
                            
                            byProtocol   = 5;
                        }
                        else
                        {
                            //
                            // Non-static, PIM over M-RIB==U-RIB
                            //
                            
                            byProtocol   = 3;
                        }
                    }
                    
                    dwProtocolGroup = ALL_PIM_ROUTERS_MULTICAST_GROUP;
                    
                    break;
                }
#endif
#if defined(PROTO_IP_CBT) && defined(ALL_CBT_ROUTERS_MULTICAST_GROUP)
                case PROTO_IP_CBT:
                {
                    byProtocol      = 4;
                    
                    dwProtocolGroup = ALL_CBT_ROUTERS_MULTICAST_GROUP;
                    
                    break;
                }
#endif
                    
            }
        }

        //
        // 4) Fill in more information
        //

        //
        // Incoming Interface Address
        //
        
        pBlock->dwIifAddr = dwIifAddr;
        
        if (mfeStats)
        {
            //
            // Figure out Previous-Hop Router Address
            //
            
            dwForwardDest = mfeStats->dwUpStrmNgbr;
        }
        else
        {
            if ( IsPointToPoint(picbIif) && picbIif->dwRemoteAddress )
            {
                dwForwardDest = picbIif->dwRemoteAddress;
            }
            else if (bRouteFound && ipNextHopAddress)
            {
                dwForwardDest = ipNextHopAddress;
            }
            else
            {
                dwForwardDest = 0;
            }
        }
        
        pBlock->dwPrevHopAddr = dwForwardDest;

        // Okay, if the previous hop address is the source,
        // set the forward destination to the response address 

        if (dwForwardDest is pMtraceMsg->dwSourceAddress)
        {
            ipNextHopAddress = 0;
            dwForwardDest    = pMtraceMsg->dwResponseAddress;
        }
         
        if (picbIif)
        {
            IP_MCAST_COUNTER_INFO iifStats;
            
            GetInterfaceMcastCounters(picbIif, &iifStats); 
            
            pBlock->dwIifPacketCount = htonl((ULONG)iifStats.InMcastPkts);
        }
        else
        {
            pBlock->dwIifPacketCount = 0;
        }

        //
        // Total Number of Packets
        //
        
        pBlock->dwSGPacketCount  = (mfeStats)? htonl(mfeStats->ulInPkts) : 0; 
        pBlock->byIifProtocol    = byProtocol; // Routing Protocol

        //
        // length of source mask for S route
        //

        if (bRouteFound)
        {
            pBlock->bySrcMaskLength = bySrcMaskLength;
        }
        else
        {
            pBlock->bySrcMaskLength = 0;
        }

#if 0
        if (XXX starG or better forwarding state)
        {
            pBlock->bySrcMaskLength = 63; // Smask from forwarding info
        }

        //
        // Set S bit (64) if packet counts aren't (S,G)-specific
        //
        
        if (XXX)
        {
            pBlock->bySrcMaskLength |= 64;
        }
        
#endif

    }

    //
    // 5) Check if traceroute is administratively prohibited, or if
    //    previous hop router doesn't understand traceroute.  If so,
    //    forward to requester.
    //
    
#if 0
    if (XXX) {
        
        if (byStatusCode < MFE_PROHIBITED)
        {
            byStatusCode = MFE_PROHIBITED;
        }
        
        dwForwardDest = pMtraceMsg->dwResponseAddress;
    }
    
#endif

    //
    //    Check for MFE_OLD_ROUTER - set by routing protocol
    //
    // 6) If reception iface is non-multicast or iif, set appropriate error.
    //
    
    if (picbOif)
    {
        dwResult = MulticastOwner(picbOif,
                                  &pOifOwner,
                                  NULL);
        
        if (pOifOwner == NULL)
        {
            if (byStatusCode < MFE_NO_MULTICAST)
            {
                byStatusCode = MFE_NO_MULTICAST;
            }
            
        }
        else
        {
            if (picbOif == picbIif)
            {
                if (byStatusCode < MFE_IIF)
                {
                    byStatusCode = MFE_IIF;
                }
            }
        }
    }
    else
    {
        pOifOwner = NULL;
    }

    //
    // Check for MFE_WRONG_IF - set by routing protocol
    //
    // 7) Check for admin scoping on either iif or oif.
    //
    
    if ((picbIif 
         && RmHasBoundary(picbIif->dwIfIndex, pMtraceMsg->dwGroupAddress)) 
     || (picbOif 
         && RmHasBoundary(picbOif->dwIfIndex, pMtraceMsg->dwGroupAddress)))
    {
        if (byStatusCode < MFE_BOUNDARY_REACHED)
        {
            byStatusCode = MFE_BOUNDARY_REACHED;
        }
        
    }

    //
    // 8) Check for MFE_REACHED_CORE - set by routing protocol
    // 9) Check for MFE_PRUNED_UPSTREAM - set by routing protocol
    //    Check for MFE_OIF_PRUNED - set by routing protocol
    //    Check for MFE_NOT_FORWARDING:
    //       Search for picbOif->(index) and picbOifAddr in oiflist
    //
    
    if (mfeStats && picbOif)
    {
        DWORD oifIndex;
        
        for (oifIndex=0;
             oifIndex < mfeStats->ulNumOutIf;
             oifIndex++)
        {
            if (picbOif->dwIfIndex==mfeStats->rgmiosOutStats[oifIndex].dwOutIfIndex 
                && dwOifAddr == mfeStats->rgmiosOutStats[oifIndex].dwNextHopAddr)
            {
                break;
            }
        }
        
        if (oifIndex >= mfeStats->ulNumOutIf)
        {
            if (byStatusCode < MFE_NOT_FORWARDING)
            {
                byStatusCode = MFE_NOT_FORWARDING;
            }
        }
    }
    
    //
    // status code to add is highest value of what iif owner, oif owner,
    // and rtrmgr say.
    //
    
    if (pOifOwner && pOifOwner->pfnGetMfeStatus)
    {
        dwResult = (pOifOwner->pfnGetMfeStatus)(picbOif->dwIfIndex,
                                                pMtraceMsg->dwGroupAddress,
                                                pMtraceMsg->dwSourceAddress,
                                                &byProtoStatusCode);
        
        if (byStatusCode < byProtoStatusCode)
        {
            byStatusCode = byProtoStatusCode;
        }
    }
    
    if (pIifOwner && pIifOwner->pfnGetMfeStatus)
    {
        dwResult = (pIifOwner->pfnGetMfeStatus)(picbIif->dwIfIndex,
                                                pMtraceMsg->dwGroupAddress,
                                                pMtraceMsg->dwSourceAddress,
                                                &byProtoStatusCode);
        
        if (byStatusCode < byProtoStatusCode)
        {
            byStatusCode = byProtoStatusCode;
        }
    }
    
    pBlock->byStatusCode = (char)mtraceErrCode[byStatusCode];

    Trace5( MCAST,
            "Mtrace: err %d blks %d maxhops %d iif %d prevhop %d.%d.%d.%d",
            pBlock->byStatusCode,
            dwBlocks,
            pMtraceMsg->byHops,
            ((picbIif)? picbIif->dwIfIndex : 0),
            PRINT_IPADDR(pBlock->dwPrevHopAddr));

    //
    // 10) Send packet on to previous hop or to requester.
    //     If prev hop is not known, but iif is known, use a multicast group.
    //
    
    if (dwBlocks == pMtraceMsg->byHops)
    {
        dwForwardDest = pMtraceMsg->dwResponseAddress;
        
    }
    else
    {
        if (!dwForwardDest)
        {
            if (picbIif)
            {
                pBlock->dwPrevHopAddr = dwForwardDest = dwProtocolGroup;
                
            }
            else
            {
                dwForwardDest = pMtraceMsg->dwResponseAddress;
            }
        }   
    }

    if (g_mcastDebugLevel > 0) {
        Trace1(MCAST, " QueryArrivalTime = %08x", pBlock->dwQueryArrivalTime);
        Trace2(MCAST, " IifAddr          = %08x (%d.%d.%d.%d)", pBlock->dwIifAddr,
         PRINT_IPADDR(pBlock->dwIifAddr));
        Trace2(MCAST, " OifAddr          = %08x (%d.%d.%d.%d)", pBlock->dwOifAddr,
         PRINT_IPADDR(pBlock->dwOifAddr));
        Trace2(MCAST, " PrevHopAddr      = %08x (%d.%d.%d.%d)", pBlock->dwPrevHopAddr,
         PRINT_IPADDR(pBlock->dwPrevHopAddr));
        Trace1(MCAST, " IifPacketCount   = %08x", pBlock->dwIifPacketCount  );
        Trace1(MCAST, " OifPacketCount   = %08x", pBlock->dwOifPacketCount  );
        Trace1(MCAST, " SGPacketCount    = %08x", pBlock->dwSGPacketCount  );
        Trace1(MCAST, " IifProtocol      = %02x", pBlock->byIifProtocol  );
        Trace1(MCAST, " OifThreshold     = %02x", pBlock->byOifThreshold );
        Trace1(MCAST, " SrcMaskLength    = %02x", pBlock->bySrcMaskLength );
        Trace1(MCAST, " StatusCode       = %02x", pBlock->byStatusCode    );
    }
    
    if (dwForwardDest is pMtraceMsg->dwResponseAddress)
    {
        Trace2(MCAST,
               "Sending mtrace response to %d.%d.%d.%d from %d.%d.%d.%d",
               PRINT_IPADDR(dwForwardDest),
               PRINT_IPADDR(dwOifAddr));

        SendMtraceResponse(dwForwardDest,
                           dwOifAddr,
                           (PMTRACE_HEADER)wsMtraceBuffer.buf, 
                           dwSize + sizeof(MTRACE_RESPONSE_BLOCK));
        
    }
    else
    {
        Trace2(MCAST,
               "Forwarding mtrace request to %d.%d.%d.%d from %d.%d.%d.%d",
               PRINT_IPADDR(dwForwardDest),
               PRINT_IPADDR(dwIifAddr));

        ForwardMtraceRequest(dwForwardDest,
                             dwIifAddr,
                             (PMTRACE_HEADER)wsMtraceBuffer.buf,
                             dwSize + sizeof(MTRACE_RESPONSE_BLOCK));
    }

    //
    // Free the buffers
    //
    
    if (mfeStats)
    {
        HeapFree(IPRouterHeap,
                 0,
                 mfeStats);
    }
    
    HeapFree(IPRouterHeap,
             0,
             wsMtraceBuffer.buf);
}


///////////////////////////////////////////////////////////////////////////////
// Functions to deal with RAS Server advertisements
///////////////////////////////////////////////////////////////////////////////

static BOOL g_bRasAdvEnabled = FALSE;

DWORD
SetRasAdvEnable(
    BOOL bEnabled
    )
{
    LARGE_INTEGER liExpiryTime;
    DWORD         dwErr = NO_ERROR;

    if (bEnabled == g_bRasAdvEnabled)
        return dwErr;

    g_bRasAdvEnabled = bEnabled;

    if (bEnabled) 
    {
        //
        // create input socket 
        //
            
        g_UDPMiscSocket = WSASocket(AF_INET,
                                    SOCK_DGRAM,
                                    0,
                                    NULL,
                                    0,
                                    0);

        // Start timer
        liExpiryTime = RtlConvertUlongToLargeInteger(RASADV_STARTUP_DELAY);
        if (!SetWaitableTimer( g_hRasAdvTimer,
                               &liExpiryTime,
                               RASADV_PERIOD,
                               NULL,
                               NULL,
                               FALSE))
        {
            dwErr = GetLastError();

            Trace1(ERR,
                   "SetRasAdvEnable: Error %d setting waitable timer",
                   dwErr);
        }
    }
    else
    {
        // Stop timer
        dwErr = CancelWaitableTimer( g_hRasAdvTimer );
    }

    return dwErr;
}

VOID
HandleRasAdvTimer()
{
    BYTE        bHostName[MAX_HOSTNAME_LEN];
    BYTE        bMessage[MAX_HOSTNAME_LEN + 80], *p;
    SOCKADDR_IN sinAddr, srcAddr;
    PICB        picb = NULL;
    PLIST_ENTRY pleNode;
    DWORD       dwErr;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pGlobalDomainInfo = NULL;

    if (!g_bRasAdvEnabled)
        return;

    // Compose message
    gethostname(bHostName, sizeof(bHostName));
    sprintf(bMessage, "Hostname=%s\n", bHostName);
    p = bMessage + strlen(bMessage);

    // Get the name of the domain this machine is a member of
    dwErr = DsRoleGetPrimaryDomainInformation( 
                NULL,
                DsRolePrimaryDomainInfoBasic,
                (LPBYTE *) &pGlobalDomainInfo );

    if ((dwErr is NO_ERROR) and 
        (pGlobalDomainInfo->DomainNameDns isnot NULL))
    {
        char *pType;
        char buff[257];

        WideCharToMultiByte( CP_ACP,
                             0,
                             pGlobalDomainInfo->DomainNameDns,
                             wcslen(pGlobalDomainInfo->DomainNameDns)+1,
                             buff,
                             sizeof(buff),
                             NULL,
                             NULL );

        if (pGlobalDomainInfo->MachineRole is DsRole_RoleStandaloneWorkstation
         or pGlobalDomainInfo->MachineRole is DsRole_RoleStandaloneServer)
            pType = "Workgroup";
        else
            pType = "Domain";
 
        sprintf(p, "%s=%s\n", pType, buff);

        // Trace1(MCAST, "Sending !%s!", bMessage);
    }
        
    sinAddr.sin_family      = AF_INET;
    sinAddr.sin_port        = htons(RASADV_PORT);
    sinAddr.sin_addr.s_addr = inet_addr(RASADV_GROUP);

    dwErr = McSetMulticastTtl( g_UDPMiscSocket, RASADV_TTL );

    // Find a dedicated interface (if any)
    ENTER_READER(ICB_LIST);
    {
        for (pleNode = ICBList.Flink;
             pleNode isnot &ICBList;
             pleNode = pleNode->Flink) 
        {
            DWORD dwIndex;
            
            picb = CONTAINING_RECORD(pleNode,
                                     ICB,
                                     leIfLink);

            if (! picb->bBound)
                continue;
    
            if (picb->ritType == ROUTER_IF_TYPE_DEDICATED)
            {
                dwErr = McSetMulticastIfByIndex( g_UDPMiscSocket,
                                                 SOCK_DGRAM,
                                                 picb->dwIfIndex );

                // Send a Ras Adv message
        
                sendto(g_UDPMiscSocket, bMessage, strlen(bMessage)+1, 0,
                 (struct sockaddr *)&sinAddr, sizeof(sinAddr));

                // If multicast forwarding is enabled, then
                // a single send will get forwarded out all
                // interfaces, so we can stop after the first send

                if (McMiscSocket != INVALID_SOCKET)
                    break;
            }
        }
    }
    EXIT_LOCK(ICB_LIST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\mcmisc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\mcmisc.h

Abstract:

    Header file for mrinfo and mtrace-related stuff

Revision History:

    Dave Thaler       20th Apr 1998      Created

--*/

#ifndef __MCMISC_H__
#define __MCMISC_H__

#include <pshpack1.h>

//
// Identify all address variables by IPV4_ADDRESS to make it
// easier to port to IPv6.
//

typedef DWORD IPV4_ADDRESS, *PIPV4_ADDRESS;

typedef struct _IGMP_HEADER
{
    BYTE      byType;
    BYTE      byCode;
    WORD      wXSum;
    DWORD     dwReserved;
} IGMP_HEADER, *PIGMP_HEADER;


#define MIN_IGMP_PACKET_SIZE     sizeof(IGMP_HEADER)

//
// Format of an mrinfo message
//

typedef struct _MRINFO_HEADER
{
    BYTE	byType;
    BYTE	byCode;
    WORD	wChecksum;
    BYTE	byReserved;
    BYTE	byCapabilities;
    BYTE	byMinor;
    BYTE	byMajor;
}MRINFO_HEADER, *PMRINFO_HEADER;

//
// Format of an mtrace header
//

typedef struct _MTRACE_HEADER
{
    BYTE            byType;
    BYTE            byHops;
    WORD            wChecksum;
    IPV4_ADDRESS    dwGroupAddress;
    IPV4_ADDRESS    dwSourceAddress;
    IPV4_ADDRESS    dwDestAddress;
    IPV4_ADDRESS    dwResponseAddress;
    BYTE            byRespTtl;
    BYTE            byQueryID1;
    WORD            wQueryID2;
    
}MTRACE_HEADER, *PMTRACE_HEADER;

//
// Format of a response block inside an mtrace message
//

typedef struct _MTRACE_RESPONSE_BLOCK
{
    DWORD           dwQueryArrivalTime;
    IPV4_ADDRESS    dwIifAddr;
    IPV4_ADDRESS    dwOifAddr;
    IPV4_ADDRESS    dwPrevHopAddr;
    DWORD           dwIifPacketCount;
    DWORD           dwOifPacketCount;
    DWORD           dwSGPacketCount;
    BYTE            byIifProtocol;
    BYTE            byOifThreshold;
    BYTE            bySrcMaskLength;
    BYTE            byStatusCode;
    
}MTRACE_RESPONSE_BLOCK, *PMTRACE_RESPONSE_BLOCK;

#include <poppack.h>

//
// igmp type field
//

#define IGMP_DVMRP           0x13
#define IGMP_MTRACE_RESPONSE 0x1e
#define IGMP_MTRACE_REQUEST  0x1f

//
// dvmrp code field
//

#define DVMRP_ASK_NEIGHBORS2 0x05
#define DVMRP_NEIGHBORS2     0x06

// 
// mrinfo flags field
//

#define MRINFO_TUNNEL_FLAG   0x01
#define MRINFO_DOWN_FLAG     0x10
#define MRINFO_DISABLED_FLAG 0x20
#define MRINFO_QUERIER_FLAG  0x40
#define MRINFO_LEAF_FLAG     0x80

// 
// mrinfo capabilities field
//

#define MRINFO_CAP_LEAF     0x01
#define MRINFO_CAP_PRUNE    0x02
#define MRINFO_CAP_GENID    0x04
#define MRINFO_CAP_MTRACE   0x08
#define MRINFO_CAP_SNMP     0x10


//
// Function prototypes
//

DWORD
McSetMulticastTtl(
    SOCKET s,
    DWORD  dwTtl
    );

DWORD
McSetMulticastIfByIndex(
    SOCKET       s,
    DWORD        dwSockType,
    DWORD        dwIfIndex
    );

DWORD
McSetMulticastIf(
    SOCKET       s,
    IPV4_ADDRESS ipAddr
    );

DWORD
McJoinGroupByIndex(
    SOCKET       s,
    DWORD        dwSockType,
    IPV4_ADDRESS ipGroup,
    DWORD        dwIfIndex  
    );

DWORD
McJoinGroup(
    SOCKET       s,
    IPV4_ADDRESS ipGroup,
    IPV4_ADDRESS ipInterface
    );

DWORD
StartMcMisc(
    VOID
    );

VOID
StopMcMisc(
    VOID
    );

VOID
HandleMrinfoRequest(
    IPV4_ADDRESS dwLocalAddr,
    SOCKADDR_IN *sinDestAddr
    );

VOID
HandleMtraceRequest(
    WSABUF      *pWsabuf
    );

VOID
HandleMcMiscMessages(
    VOID
    );

DWORD
MulticastOwner(
    PICB         picb,      // IN: interface config block
    PPROTO_CB   *pcbOwner,  // OUT: owner
    PPROTO_CB   *pcbQuerier // OUT: IGMP
    );

BYTE
MaskToMaskLen(
    IPV4_ADDRESS dwMask
    );

IPV4_ADDRESS
defaultSourceAddress(
    PICB picb
    );

//
// RAS Server Advertisement constants
//

#define RASADV_GROUP  "239.255.2.2"
#define RASADV_PORT            9753
#define RASADV_PERIOD       3600000  // 1 hour (in milliseconds)
#define RASADV_STARTUP_DELAY      0  // immediately
#define RASADV_TTL               15

DWORD
SetRasAdvEnable(
    BOOL bEnabled
    );

VOID
HandleRasAdvTimer(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\nat.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\nat.h

Abstract:

    Header for nat.c

Revision History:

    Gurdeep Singh Pall          6/26/95  Created

--*/

DWORD
StartNat(
    PIP_NAT_GLOBAL_INFO     pNatGlobalInfo
    );

DWORD
StopNat(
    VOID
    );

DWORD
SetGlobalNatInfo(
    PRTR_INFO_BLOCK_HEADER   pRtrGlobalInfo
    );

DWORD
AddInterfaceToNat(
    PICB picb
    );

DWORD
SetNatInterfaceInfo(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    );

DWORD
BindNatInterface(
    PICB  picb
    );

DWORD
UnbindNatInterface(
    PICB    picb
    );

DWORD
DeleteInterfaceFromNat(
    PICB picb
    );

DWORD
SetNatContextToIpStack(
    PICB    picb
    );

DWORD
DeleteNatContextFromIpStack(
    PICB    picb
    );

DWORD
GetInterfaceNatInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdrAndBuffer,
    PDWORD                  pdwSize
    );

DWORD
GetNatMappings(
    PICB                                picb,
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS  pBuffer,
    DWORD                               dwSize
    );

DWORD
GetNumNatMappings(
    PICB    picb,
    PULONG  pulNatMappings
    );

DWORD
GetNatStatistics(
    PICB                            picb,
    PIP_NAT_INTERFACE_STATISTICS    pBuffer
    );
VOID
SetNatRangeForProxyArp(
    PICB    picb
    );
VOID
DeleteNatRangeFromProxyArp(
    PICB    picb
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\proto.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\proto.h

Abstract:

    IP Router Manager code prototypes

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/


#ifndef __PROTO_H__
#define __PROTO_H__

//* INIT.C
//
DWORD InitRouter(PRTR_INFO_BLOCK_HEADER pGlobalHdr);
DWORD LoadRoutingProtocols (PRTR_INFO_BLOCK_HEADER pGlobalHdr);
DWORD InitializeMibHandler();
DWORD OpenIPDriver();
DWORD StartDriverAndOpenHandle(PCHAR pszName, PWCHAR  pwszDriverName, PHANDLE phDevice);
DWORD OpenFilterDriver();
DWORD OpenMulticastDriver(VOID);
DWORD EnableNetbtBcastForwarding( DWORD dwEnable );
DWORD RestoreNetbtBcastForwardingMode();
DWORD ForceNetbtRegistryRead();

//
// CLOSE.C
//

VOID  RouterManagerCleanup();
VOID  UnloadRoutingProtocols() ;
VOID  CloseIPDriver();
DWORD 
StopDriverAndCloseHandle(
    PCHAR   pszServiceName,
    HANDLE  hDevice
    );
VOID  CloseMcastDriver();
DWORD CloseFilterDriver();
VOID  MIBCleanup();


//* WORKER.C
//
DWORD WorkerThread (LPVOID pGlobalInfo) ;
DWORD ProcessSaveGlobalConfigInfo() ;
DWORD ProcessSaveInterfaceConfigInfo() ;
DWORD ProcessUpdateComplete (PPROTO_CB proutprot, UPDATE_COMPLETE_MESSAGE *updateresult) ;
DWORD ProcessRouterStopped() ;
VOID  WaitForAPIsToExitBeforeStopping() ;
DWORD QueueUpdateEvent (DWORD interfaceindex, DWORD result) ;


// PROTODLL.C
//
DWORD HandleRoutingProtocolNotification () ;
VOID  NotifyRoutingProtocolsToStop() ;
BOOL  AllRoutingProtocolsStopped() ;

DWORD
LoadProtocol(
    IN MPR_PROTOCOL_0  *pmpProtocolInfo,
    IN PPROTO_CB       pProtocolCb,
    IN PVOID           pvInfo,
    IN ULONG           ulGlobalInfoVersion,
    IN ULONG           ulGlobalInfoSize,
    IN ULONG           ulGlobalInfoCount
    );

VOID  RemoveProtocolFromAllInterfaces(PPROTO_CB  pProtocolCB);
DWORD  StopRoutingProtocol(PPROTO_CB  pProtocolCB);

//* RTMOPS.C
//

DWORD
RtmEventCallback (
     IN     RTM_ENTITY_HANDLE               hRtmHandle,
     IN     RTM_EVENT_TYPE                  retEvent,
     IN     PVOID                           pContext1,
     IN     PVOID                           pContext2
     );

DWORD
WINAPI
ProcessDefaultRouteChanges(
    IN      HANDLE                          hNotifyHandle
    );

DWORD
WINAPI
AddNetmgmtDefaultRoutesToForwarder(
    PRTM_DEST_INFO                          pDestInfo
    );

DWORD
WINAPI
ProcessChanges (
    IN     HANDLE                           hNotifyHandle
    );

DWORD 
AddRtmRoute (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pIpForw,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwNextHopMask,
    IN      DWORD                           dwTimeToLive,
    OUT     HANDLE                         *phRtmRoute
    );

DWORD 
DeleteRtmRoute (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pIpForw
    );

DWORD
ConvertRouteInfoToRtm (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pIpForw, 
    IN      HANDLE                          hNextHopHandle,
    IN      DWORD                           dwRouteFlags,
    OUT     PRTM_NET_ADDRESS                pDestAddr,
    OUT     PRTM_ROUTE_INFO                 pRouteInfo
    );

VOID
ConvertRtmToRouteInfo (
    IN      DWORD                           ownerProtocol,
    IN      PRTM_NET_ADDRESS                pDestAddr,
    IN      PRTM_ROUTE_INFO                 pRoute,
    IN      PRTM_NEXTHOP_INFO               pNextHop,
    OUT     PINTERFACE_ROUTE_INFO           pIpForw
    );

PINTERFACE_ROUTE_INFO
ConvertMibRouteToRouteInfo(
    IN  PMIB_IPFORWARDROW pMibRow
    );

//#define ConvertRouteInfoToMibRoute(x) ((PMIB_IPFORWARDROW)(x))
PMIB_IPFORWARDROW
ConvertRouteInfoToMibRoute(
    IN  PINTERFACE_ROUTE_INFO pRouteInfo
    );

VOID
ConvertRouteNotifyOutputToRouteInfo(
    IN      PIPRouteNotifyOutput            pirno,
    OUT     PINTERFACE_ROUTE_INFO           pRtInfo
    );
    

DWORD
BlockConvertRoutesToStatic (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      DWORD                           dwProtocolId
    );


DWORD
DeleteRtmRoutes (
    IN      HANDLE                          ClientHandle,
    IN      DWORD                           dwIfIndex,
    IN      BOOL                            fDeleteAll
    );

#define DeleteRtmRoutesOnInterface(h, i)    DeleteRtmRoutes(h, i, FALSE)


DWORD
DeleteRtmNexthops (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      BOOL                            fDeleteAll
    );

#define DeleteRtmNexthopsOnInterface(h, i)  DeleteRtmNexthops(h, i, FALSE)

//* RTMIF.C
//
VOID IPRouteChange (DWORD Flags, PVOID CurBestRoute, PVOID PrevBestRoute) ;
INT  IPHash (PVOID Net) ;
BOOL IPCompareFamilySpecificData (PVOID Route1, PVOID Route2) ;
INT  IPCompareNextHopAddress (PVOID Route1, PVOID Route2) ;
INT  IPCompareNetworks (PVOID Net1, PVOID Net2) ;
INT  IPCompareMetrics(PVOID Route1, PVOID Route2);
DWORD IPValidateRoute(PVOID Route);

DWORD 
ChangeRouteWithForwarder(
    IN      PRTM_NET_ADDRESS                pDestAddr,
    IN      PRTM_ROUTE_INFO                 pRoute, 
    IN      BOOL                            bAddRoute,
    IN      BOOL                            bDelOld
    );

DWORD
WINAPI
ValidateRouteForProtocol(
    IN      DWORD                           dwProtoId,
    IN      PVOID                           pRouteInfo,
    IN      PVOID                           pDestAddr  OPTIONAL
    );
    
DWORD
WINAPI
ValidateRouteForProtocolEx(
    IN      DWORD                           dwProtoId,
    IN      PVOID                           pRouteInfo,
    IN      PVOID                           pDestAddr  OPTIONAL
    );

// Load.c Functions that load the caches from the stack or elsewhere

DWORD LoadIpAddrTable(VOID);
DWORD LoadIpForwardTable(VOID);
DWORD LoadIpNetTable(VOID);
DWORD LoadTcpTable(VOID);
DWORD LoadUdpTable(VOID);
DWORD LoadArpEntTable(VOID);


LONG  UdpCmp(DWORD dwAddr1, DWORD dwPort1, DWORD dwAddr2, DWORD dwPort2);
LONG  TcpCmp(DWORD dwLocalAddr1, DWORD dwLocalPort1, DWORD dwRemAddr1, DWORD dwRemPort1,
             DWORD dwLocalAddr2, DWORD dwLocalPort2, DWORD dwRemAddr2, DWORD dwRemPort2);
LONG  IpForwardCmp(DWORD dwIpDest1, DWORD dwProto1, DWORD dwPolicy1, 
                   DWORD dwIpNextHop1, DWORD dwIpDest2, DWORD dwProto2, 
                   DWORD dwPolicy2, DWORD dwIpNextHop2);
LONG  IpNetCmp(DWORD dwIfIndex1, DWORD dwAddr1, DWORD dwIfIndex2, DWORD dwAddr2);

PSZ   CacheToA(DWORD dwCache);
DWORD UpdateCache(DWORD dwCache,BOOL *fUpdate);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\route.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\route.h

Abstract:

    Header for route.c

Revision History:


--*/


#ifndef __RTRMGR_ROUTE_H__
#define __RTRMGR_ROUTE_H__

typedef struct _RTM_HANDLE_INFO
{
    DWORD   dwProtoId;
    BOOL    bStatic;
    HANDLE  hRouteHandle;
}RTM_HANDLE_INFO, *PRTM_HANDLE_INFO;

RTM_HANDLE_INFO g_rgRtmHandles[5];

typedef struct _ROUTE_CHANGE_INFO
{
    IO_STATUS_BLOCK         ioStatus;
    IPRouteNotifyOutput     ipNotifyOutput;
} ROUTE_CHANGE_INFO, *PROUTE_CHANGE_INFO;

DWORD
InitializeStaticRoutes(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    );

DWORD
CopyOutClientRoutes(
    PICB                     picb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    );

DWORD
AddSingleRoute(
    DWORD                   dwInterfaceIndex,
    PINTERFACE_ROUTE_INFO   pRoute,
    DWORD                   dwNextHopMask,
    WORD                    wRtmFlags,
    BOOL                    bValid,
    BOOL                    bAddToStack,
    BOOL                    bP2P,
    HANDLE                  *phRtmRoute OPTIONAL
    );

DWORD
DeleteSingleRoute(
    DWORD   dwInterfaceId,
    DWORD   dwDestAddr,
    DWORD   dwDestMask,
    DWORD   dwNexthop,
    DWORD   dwProtoId,
    BOOL    bP2P
    );

DWORD
DeleteAllRoutes(
    IN  DWORD   dwIfIndex,
    IN  BOOL    bStaticOnly
    );

VOID
DeleteAllClientRoutes(
    PICB    pIcb,
    DWORD   dwServerIfIndex
    );

VOID
AddAllClientRoutes(
    PICB    pIcb,
    DWORD   dwServerIfIndex
    );

DWORD
GetNumStaticRoutes(
    PICB picb
    );

DWORD
GetInterfaceRouteInfo(
    IN     PICB                   picb,
    IN     PRTR_TOC_ENTRY         pToc,
    IN     PBYTE                  pbDataPtr,
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    );

DWORD
ReadAllStaticRoutesIntoBuffer(
    PICB                 picb,
    PINTERFACE_ROUTE_INFO   pRoutes,
    DWORD                dwMaxRoutes
    );

DWORD
SetRouteInfo(
    PICB                    picb,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr
    );

DWORD
ConvertRoutesToAutoStatic(
    DWORD dwProtocolId,
    DWORD dwIfIndex
    );

VOID
ChangeAdapterIndexForDodRoutes (
    DWORD    dwInterfaceIndex
    );

VOID
AddAutomaticRoutes(
    PICB    picb,
    DWORD   dwAddress,
    DWORD   dwMask
    );

VOID
DeleteAutomaticRoutes(
    PICB    picb,
    DWORD   dwAddress,
    DWORD   dwMask
    );

VOID
ChangeDefaultRouteMetrics(
    IN  BOOL    bIncrement
    );

VOID
AddAllStackRoutes(
    PICB    pIcb
    );

VOID
UpdateDefaultRoutes(
    VOID
    );

NTSTATUS
PostIoctlForRouteChangeNotification(
    ULONG
    );

DWORD
HandleRouteChangeNotification(
    ULONG
    );

VOID
AddLoopbackRoute(
    DWORD       dwIfAddress,
    DWORD       dwIfMask
    );

VOID
UpdateStackRoutesToRestoreList(
    IN  PMIB_IPFORWARDROW   pirf,
    IN  DWORD               dwFlags
    );

BOOL
LookupStackRoutesToRestoreList(
    IN  PMIB_IPFORWARDROW   pmibRoute,
    OUT PROUTE_LIST_ENTRY   *pRoute
    );

#endif // __RTRMGR_ROUTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\mhrtbt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\mhrtbt.h

Abstract:

    Header for multicast heartbeat

Revision History:

    Amritansh Raghav  26th Dec 1997     Created

--*/


#define MHBEAT_SOCKET_FLAGS     \
    (WSA_FLAG_MULTIPOINT_C_LEAF|WSA_FLAG_MULTIPOINT_D_LEAF)

typedef struct _MCAST_HBEAT_CB
{
    BOOL        bActive;

    //
    // The name/address of group
    //

    WCHAR       pwszGroup[MAX_GROUP_LEN];

    //
    // The resolved address
    //

    DWORD       dwGroup;

    //
    // Port or protocol
    //

    WORD        wPort;
    
    //
    // Protocol or RAW
    //

    BYTE        byProtocol;

    //
    // Set to TRUE if a gethostbyname is in progress
    //

    BOOL        bResolutionInProgress;

    //
    // The socket for the interface
    //

    SOCKET      sHbeatSocket;

    //
    // The dead interval in system ticks
    //

    ULONGLONG   ullDeadInterval;

    ULONGLONG   ullLastHeard;

}MCAST_HBEAT_CB, *PMCAST_HBEAT_CB;


//
// Structure used to pass to worker function
//

typedef struct _HEARTBEAT_CONTEXT
{
    DWORD   dwIfIndex;
    PICB    picb;
    WCHAR   pwszGroup[MAX_GROUP_LEN];
}HEARTBEAT_CONTEXT, *PHEARTBEAT_CONTEXT;

//
// Forward function declarations
//

DWORD
SetMHeartbeatInfo(
    IN PICB                      picb,
    IN PRTR_INFO_BLOCK_HEADER    pInfoHdr
    );

DWORD
GetMHeartbeatInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr,
    PDWORD                  pdwSize
    );

DWORD
ActivateMHeartbeat(
    IN PICB  picb
    );

DWORD
StartMHeartbeat(
    IN PICB  picb
    );

DWORD
CreateHbeatSocket(
    IN PICB picb
    );

VOID
DeleteHbeatSocket(
    IN PICB picb
    );

DWORD
DeActivateMHeartbeat(
    IN PICB  picb
    );

VOID
HandleMHeartbeatMessages(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\nat.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\nat.c

Abstract:

    Based on filter.c
    Abstracts out the NAT functionality

Revision History:



--*/

#include "allinc.h"

DWORD
StartNat(
    PIP_NAT_GLOBAL_INFO     pNatGlobalInfo
    )
{
#if 1
return 0;
#else
    PLIST_ENTRY             pleNode;
    PICB                    picb;
    DWORD                   dwResult;
    NTSTATUS                ntStatus;
    IO_STATUS_BLOCK         IoStatusBlock;

    TraceEnter("StartNat");

    if(!g_bNatRunning)
    {
        if(StartDriverAndOpenHandle(IP_NAT_SERVICE_NAME,
                                    DD_IP_NAT_DEVICE_NAME,
                                    &g_hNatDevice) isnot NO_ERROR)
        {
            Trace0(ERR,
                   "StartNat: Couldnt open driver");

            TraceLeave("StartNat");

            return ERROR_OPEN_FAILED;
        }
       
        //
        // At this point NAT is running
        //

        ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         IOCTL_IP_NAT_SET_GLOBAL_INFO,
                                         (PVOID)pNatGlobalInfo,
                                         sizeof(IP_NAT_GLOBAL_INFO),
                                         NULL,
                                         0);

        if(ntStatus isnot STATUS_SUCCESS)
        {
            Trace1(ERR,
                   "StartNat: Status %X setting global info",
                   ntStatus);

            StopDriverAndCloseHandle(IP_NAT_SERVICE_NAME,
                                     g_hNatDevice);
            
            g_hNatDevice = NULL;

            TraceLeave("StartNat");

            return ERROR_OPEN_FAILED;
        }
 
        g_bNatRunning = TRUE;

        //
        // Just queue a worker to add the nat info and contexts
        //

        dwResult = QueueAsyncFunction(RestoreNatInfo,
                                      NULL,
                                      FALSE);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "StartNat: Error %d firing worker function to set nat info",
                   dwResult);
            
        }
    }
    
    TraceLeave("StartNat");

    return NO_ERROR;
#endif
}

DWORD
StopNat(
    VOID
    )
{
#if 1
return 0;
#else
    PLIST_ENTRY pleNode;
    PICB        picb;
    DWORD       dwResult;
 
    TraceEnter("StopNat");

    if(g_bNatRunning)
    {
        g_bNatRunning = FALSE;

        //
        // Set the NAT context in the ICBs to INVALID
        //
 
        for (pleNode = ICBList.Flink;
             pleNode != &ICBList;
             pleNode = pleNode->Flink)
        {
            picb = CONTAINING_RECORD (pleNode, ICB, leIfLink);
            
            if((picb->ritType is ROUTER_IF_TYPE_INTERNAL) or
               (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
               (picb->ritType is ROUTER_IF_TYPE_CLIENT))
            {
                //
                // The above types are not added to the NAT
                // or to the IP stack
                //
                
                continue;
            }
            
            if(picb->dwOperationalState >= MIB_IF_OPER_STATUS_CONNECTED)
            {
                IpRtAssert(picb->bBound);

                UnbindNatInterface(picb);
            }

            dwResult = DeleteInterfaceFromNat(picb);

            if(dwResult isnot NO_ERROR)
            {
                Trace2(ERR,
                       "StopNat: NtStatus %x deleting %S from NAT",
                       dwResult,
                       picb->pwszName);
            }
        }

        StopDriverAndCloseHandle(IP_NAT_SERVICE_NAME,
                                 g_hNatDevice);
    }

    TraceLeave("StopNat");

    return NO_ERROR;
#endif
}


DWORD
SetGlobalNatInfo(
    PRTR_INFO_BLOCK_HEADER   pRtrGlobalInfo
    )
{
#if 1
return 0;
#else
    PRTR_TOC_ENTRY          pToc;
    PIP_NAT_GLOBAL_INFO     pNatGlobalInfo;
    NTSTATUS                ntStatus;
    IO_STATUS_BLOCK         IoStatusBlock;
    DWORD                   dwResult;


    TraceEnter("SetGlobalNatInfo");
    
    pNatGlobalInfo = NULL;
    
    pToc = GetPointerToTocEntry(IP_NAT_INFO,
                                pRtrGlobalInfo);

   
    if(pToc)
    {
        pNatGlobalInfo = GetInfoFromTocEntry(pRtrGlobalInfo,
                                             pToc);
        if((pToc->InfoSize is 0) or (pNatGlobalInfo is NULL))
        {
            //
            // Means remove NAT
            //

            dwResult = StopNat();

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "SetGlobalNatInfo: Error %d stopping NAT (no info)",
                       dwResult);
            }

            TraceLeave("SetGlobalNatInfo");

            return dwResult;
        }
    }
    else
    {    
        Trace0(IF,
               "SetGlobalNatInfo: No NAT info, so leaving");

        TraceLeave("SetGlobalNatInfo");
        
        return NO_ERROR;
    }

    EnterCriticalSection(&g_csNatInfo);

    if(g_pNatGlobalInfo is NULL)
    {
        g_pNatGlobalInfo = HeapAlloc(IPRouterHeap,
                                     0,
                                     sizeof(IP_NAT_GLOBAL_INFO));

        if(g_pNatGlobalInfo is NULL)
        {
            Trace1(ERR,
                   "SetGlobalNatInfo: Error %d allocating memory for NAT info",
                   GetLastError());

            LeaveCriticalSection(&g_csNatInfo);

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Save a copy
    //

    CopyMemory(g_pNatGlobalInfo,
               pNatGlobalInfo,
               sizeof(IP_NAT_GLOBAL_INFO));

    if(g_bNatRunning)
    {
        //
        // NAT is running, if the user is asking us to stop it,
        // do so now an return
        //

        if(pNatGlobalInfo->NATEnabled is FALSE)
        {
            dwResult = StopNat();
            
            LeaveCriticalSection(&g_csNatInfo);

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "SetGlobalNatInfo: Error %d stopping NAT",
                       dwResult);
            }

            TraceLeave("SetGlobalNatInfo");
        
            return dwResult;
        }
    }
    else
    {
        if(pNatGlobalInfo->NATEnabled is TRUE)
        {
            dwResult = StartNat(pNatGlobalInfo);

            LeaveCriticalSection(&g_csNatInfo);

            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "SetGlobalNatInfo: Error %d starting NAT",
                       dwResult);
            }
            
            TraceLeave("SetGlobalNatInfo");
       
            //
            // Starting NAT causes us to also set the global info
            // so we can return from here
            //
 
            return dwResult;
        }
    }

    //
    // This is the case where NAT is already started and only its info is
    // being changed
    //

    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_SET_GLOBAL_INFO,
                                     (PVOID)pNatGlobalInfo,
                                     sizeof(IP_NAT_GLOBAL_INFO),
                                     NULL,
                                     0);
    if (!NT_SUCCESS(ntStatus))
    {
        Trace1(ERR,
               "SetGlobalNatInfo: NtStatus %x setting NAT info",
               ntStatus);

        TraceLeave("SetGlobalNatInfo");
    
        LeaveCriticalSection(&g_csNatInfo);

        return ERROR_CAN_NOT_COMPLETE;
    }

    LeaveCriticalSection(&g_csNatInfo);

    TraceLeave("SetGlobalNatInfo");
    
    return NO_ERROR;
#endif
}
        
        
DWORD
AddInterfaceToNat(
    PICB picb
    )

/*++
  
Routine Description

    Adds an interface to the nat driver and stores the context returned by
    the driver
    Can only be called if NAT is running

Locks

    
Arguments

    picb
          
Return Value

--*/

{
#if 1
return 0;
#else
    NTSTATUS                        ntStatus;
    IO_STATUS_BLOCK                 IoStatusBlock;
    IP_NAT_CREATE_INTERFACE         inBuffer;
    DWORD                           dwInBufLen;

    TraceEnter("AddInterfaceToNat");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    inBuffer.RtrMgrIndex         = picb->dwIfIndex;
    inBuffer.RtrMgrContext       = picb;
    inBuffer.NatInterfaceContext = NULL;
    
    dwInBufLen = sizeof(IP_NAT_CREATE_INTERFACE);

    picb->pvNatContext = NULL;
    
    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_CREATE_INTERFACE,
                                     (PVOID)&inBuffer,
                                     dwInBufLen,
                                     (PVOID)&inBuffer,
                                     dwInBufLen);
    
    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "AddInterfaceToNat: NtStatus %x adding %S to NAT",
               ntStatus,
               picb->pwszName);

        TraceLeave("AddInterfaceToNat");
    
        return ntStatus;
    }
    
    picb->pvNatContext = inBuffer.NatInterfaceContext;

    TraceLeave("AddInterfaceToNat");
    
    return NO_ERROR;    
#endif
}

DWORD
SetNatInterfaceInfo(
    PICB                     picb, 
    PRTR_INFO_BLOCK_HEADER   pInterfaceInfo
    )
{
#if 1
return 0;
#else
    NTSTATUS                    ntStatus;
    IO_STATUS_BLOCK             IoStatusBlock;
    DWORD                       i,dwInBufLen,dwResult;
    PRTR_TOC_ENTRY              pToc;
    PIP_NAT_INTERFACE_INFO      pNatInfo;
 
    if((picb->ritType is ROUTER_IF_TYPE_INTERNAL) or
       (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
       (picb->ritType is ROUTER_IF_TYPE_CLIENT))
    {
        return NO_ERROR;
    }

    if(!g_bNatRunning)
    {
        return NO_ERROR;
    }

    TraceEnter("SetNatInterfaceInfo");

    pToc  = GetPointerToTocEntry(IP_NAT_INFO,
                                 pInterfaceInfo);

    if(pToc is NULL)
    {
        //
        // NULL means we dont need to change anything
        //
        
        Trace1(IF,
               "SetNatInterfaceInfo: Nat info is  NULL for %S, so leaving",
               picb->pwszName);
       
        TraceLeave("SetNatInterfaceInfo");

        return NO_ERROR;
    }

    if(pToc->InfoSize is 0)
    {
        //
        // TOC present, but no info
        // This means, delete the interface
        //

        dwResult = UnbindNatInterface(picb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetNatInterfaceInfo: Error %d unbinding %S",
                   dwResult,
                   picb->pwszName);
        }
   
        dwResult = DeleteInterfaceFromNat(picb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetNatInterfaceInfo: Error %d deleting interface %S",
                   dwResult,
                   picb->pwszName);
        }
   
        TraceLeave("SetNatInterfaceInfo");
     
        return dwResult;
    }
   
    //
    // So we have NAT info
    //
 
    if(picb->pvNatContext is NULL)
    {
        //
        // Looks like this interface does not have NAT
        //

        Trace1(IF,
               "SetNatInterfaceInfo: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        //
        // Add the interface to NAT
        //

        dwResult = AddInterfaceToNat(picb);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetNatInterfaceInfo: Error %d adding interface %S",
                   dwResult,
                   picb->pwszName);

            TraceLeave("SetNatInterfaceInfo");

            return dwResult;
        }
    }

    if(picb->pvNatInfo)
    {
        //
        // If we are LAN and UP, then this info has been added for
        // proxy ARP. Remove it
        // An optimization would be to only remove those addresses that will
        // be going away by this set, and then only set those addresses
        // that will be coming new due to this set.
        // But like I said, that is an _optimization_
        //
        
        DeleteNatRangeFromProxyArp(picb);

        IpRtAssert(picb->ulNatInfoSize isnot 0);

        HeapFree(IPRouterHeap,
                 0,
                 picb->pvNatInfo);
    }

    picb->ulNatInfoSize = 0;
    
    dwInBufLen  = pToc->InfoSize;

    pNatInfo = (PIP_NAT_INTERFACE_INFO)GetInfoFromTocEntry(pInterfaceInfo,
                                                           pToc);

    //
    // Allocate space for nat info
    //

    picb->pvNatInfo = HeapAlloc(IPRouterHeap,
                                0,
                                dwInBufLen);

    if(picb->pvNatInfo is NULL)
    {
        Trace2(ERR,
               "SetNatInterfaceInfo: Error %d allocating memory for %S",
               GetLastError(),
               picb->pwszName);

        TraceLeave("SetNatInterfaceInfo");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Save a copy of the info
    //

    CopyMemory(picb->pvNatInfo,
               pNatInfo,
               dwInBufLen);

    picb->ulNatInfoSize = dwInBufLen;
    
    //
    // Fill in the context since that will not be in the info that is
    // passed to us
    //

    pNatInfo->NatInterfaceContext = picb->pvNatContext;

    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_SET_INTERFACE_INFO,
                                     (PVOID)pNatInfo,
                                     dwInBufLen,
                                     NULL,
                                     0);
    
    if (!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "SetNatInterfaceInfo: NtStatus %x adding NAT info for %S",
               ntStatus,
               picb->pwszName);

        TraceLeave("SetNatInterfaceInfo");

        return ERROR_CAN_NOT_COMPLETE;
    }

 
    TraceLeave("SetNatInterfaceInfo");
        
    return NO_ERROR;
#endif
}

DWORD
GetInterfaceNatInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdrAndBuffer,
    PDWORD                  pdwSize
    )

/*++

Routine Description

    This function copies out the saved NAT info to the buffer
    Can only be called if NAT is running
    
Locks

    ICB_LIST lock held as READER

Arguments

    picb
    pToc
    pbDataPtr
    pInfoHdrAndBuffer
    pdwSize

Return Value

    None    

--*/

{
#if 1
return 0;
#else
    TraceEnter("GetInterfaceNatInfo");

    if(*pdwSize < picb->ulNatInfoSize)
    {
        *pdwSize = picb->ulNatInfoSize;

        TraceLeave("GetInterfaceNatInfo");
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if(picb->pvNatInfo is NULL)
    {
        IpRtAssert(picb->ulNatInfoSize is 0);

        //
        // No data
        //

        *pdwSize = 0;

        TraceLeave("GetInterfaceNatInfo");
        
        return ERROR_NO_DATA;
    }

    IpRtAssert(picb->pvNatContext);

    pToc->InfoType  = IP_NAT_INFO;
    pToc->Count     = 1;
    pToc->InfoSize  = picb->ulNatInfoSize;
    pToc->Offset    = pbDataPtr - (PBYTE)pInfoHdrAndBuffer;

    CopyMemory(pbDataPtr,
               picb->pvNatInfo,
               picb->ulNatInfoSize);

    *pdwSize = picb->ulNatInfoSize;

    TraceLeave("GetInterfaceNatInfo");
    
    return NO_ERROR;
#endif
}


DWORD
BindNatInterface(
    PICB  picb
    )
{
#if 1
return 0;
#else
    PIP_NAT_BIND_INTERFACE      pnbiBindInfo;
    NTSTATUS                    ntStatus;
    IO_STATUS_BLOCK             IoStatusBlock;
    DWORD                       i, dwInBufLen, dwResult;
    PIP_ADAPTER_BINDING_INFO    pBinding;


    if((picb->ritType is ROUTER_IF_TYPE_INTERNAL) or
       (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) or
       (picb->ritType is ROUTER_IF_TYPE_CLIENT))
    {
        return NO_ERROR;
    }

    if(!g_bNatRunning)
    {
        return NO_ERROR;
    }

    TraceEnter("BindNatInterface");

    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "BindNatInterface: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        TraceLeave("SetAddressFromNat");

        return NO_ERROR;
    }

    //
    // Try and set the address to NAT
    //

    if(picb->dwNumAddresses > 0)
    {
        dwInBufLen = FIELD_OFFSET(IP_NAT_BIND_INTERFACE, BindingInfo[0]) + 
                     SIZEOF_IP_BINDING(picb->dwNumAddresses);

        pnbiBindInfo = HeapAlloc(IPRouterHeap,
                                 HEAP_ZERO_MEMORY,
                                 dwInBufLen);
       
        if(pnbiBindInfo is NULL)
        {
            dwResult = GetLastError();

            Trace2(ERR,
                   "BindNatInterface: Unable to allocate memory for binding for %S",
                   dwResult,
                   picb->pwszName);

            TraceLeave("BindNatInterface");

            return dwResult;
        }

        pnbiBindInfo->NatInterfaceContext = picb->pvNatContext;

        pBinding = (PIP_ADAPTER_BINDING_INFO)pnbiBindInfo->BindingInfo;

        pBinding->NumAddresses  = picb->dwNumAddresses;
        pBinding->RemoteAddress = picb->dwRemoteAddress;
    
        for(i = 0; i < picb->dwNumAddresses; i++)
        {
            pBinding->Address[i].IPAddress = picb->pibBindings[i].dwAddress;
            pBinding->Address[i].Mask      = picb->pibBindings[i].dwMask;
        }
    
        ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         IOCTL_IP_NAT_BIND_INTERFACE,
                                         (PVOID)pnbiBindInfo,
                                         dwInBufLen,
                                         NULL,
                                         0);

        if(!NT_SUCCESS(ntStatus))
        {
            Trace2(ERR,
                   "BindNatInterface: NtStatus %x setting binding  for %S",
                   ntStatus,
                   picb->pwszName);
        }
    }

    //
    // Set the proxy arp range
    // This requires that the NAT info already be part of the ICB
    //
    

    SetNatRangeForProxyArp(picb);
    
    //
    // Set the context to IP stack
    //

    dwResult = SetNatContextToIpStack(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "BindNatInterface: Error %d setting context for %S",
               dwResult,
               picb->pwszName);
    }
    
    TraceLeave("BindNatInterface");

    return ntStatus;
#endif
}

DWORD
UnbindNatInterface(
    PICB    picb
    )

/*++

Routine Description


Locks


Arguments


Return Value

    NO_ERROR

--*/

{
#if 1
return 0;
#else
    IP_NAT_UNBIND_INTERFACE     ubiUnbindInfo;
    NTSTATUS                    ntStatus;
    IO_STATUS_BLOCK             IoStatusBlock;
    DWORD                       dwResult;
    

    if((picb->ritType is ROUTER_IF_TYPE_INTERNAL) and
       (picb->ritType is ROUTER_IF_TYPE_LOOPBACK) and
       (picb->ritType is ROUTER_IF_TYPE_CLIENT))
    {
        return NO_ERROR;
    }

    if(!g_bNatRunning)
    {
        return NO_ERROR;
    }

    TraceEnter("UnbindNatInterface");
    
    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "ClearAddressToNat: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        TraceLeave("UnbindNatInterface");

        return NO_ERROR;
    }

    ubiUnbindInfo.NatInterfaceContext = picb->pvNatContext;

    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_UNBIND_INTERFACE,
                                     (PVOID)&ubiUnbindInfo,
                                     sizeof(IP_NAT_UNBIND_INTERFACE),
                                     NULL,
                                     0);

    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "UnbindNatInterface: NtStatus %x setting binding  for %S",
               ntStatus,
               picb->pwszName);
    }

    //
    // Blow away the proxy arp stuff
    //

    DeleteNatRangeFromProxyArp(picb);

    dwResult = DeleteNatContextFromIpStack(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "UnbindNatInterface: Error %d removing context for %S",
               dwResult,
               picb->pwszName);
    }
    
    TraceLeave("UnbindNatInterface");

    return ntStatus;
#endif
}
    
     
DWORD
DeleteInterfaceFromNat(
    PICB picb
    )
{
#if 1
return 0;
#else
    IP_NAT_DELETE_INTERFACE     DeleteInfo;
    NTSTATUS                    ntStatus;
    IO_STATUS_BLOCK             IoStatusBlock;
    DWORD                       dwResult;

    TraceEnter("DeleteInterfaceFromNat");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));


    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "DeleteInterfaceFromNat: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        TraceLeave("DeleteInterfaceFromNat");

        return NO_ERROR;
    }

    //
    // Non NULL pvContext means NAT must be running
    //

    IpRtAssert(g_bNatRunning);
    IpRtAssert(g_hNatDevice);

    //
    // Blow away any saved info
    //

    if(picb->pvNatInfo)
    {
        IpRtAssert(picb->ulNatInfoSize isnot 0);

        HeapFree(IPRouterHeap,
                 0,
                 picb->pvNatInfo);

        picb->pvNatInfo = NULL;
    }

    picb->ulNatInfoSize = 0;
    
    DeleteInfo.NatInterfaceContext = picb->pvNatContext;

    dwResult = NO_ERROR;

    ntStatus = NtDeviceIoControlFile(g_hNatDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_NAT_DELETE_INTERFACE,
                                     (PVOID)&DeleteInfo,
                                     sizeof(IP_NAT_DELETE_INTERFACE),
                                     NULL,
                                     0);

    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "DeleteInterfaceFromNat: NtStatus %x deleting %S",
               ntStatus,
               picb->pwszName);

        dwResult = ERROR_CAN_NOT_COMPLETE;
    }

    picb->pvNatContext = NULL;

    TraceLeave("DeleteInterfaceFromNat");

    return dwResult;
#endif
}

DWORD
SetNatContextToIpStack(
    PICB    picb
    )

/*++

Routine Description
   
    Sets the NAT context as the FIREWALL context in IP 
    Can only be called if NAT is running
    
Locks

    The ICB list should be held atleast as READER

Arguments

    picb    ICB for the interface

Return Value

    NO_ERROR

--*/

{
#if 1
return 0;
#else
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    IoStatusBlock;
    DWORD              dwResult;
    IP_SET_IF_CONTEXT_INFO info;

    TraceEnter("SetNatContextToIpStack");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "SetNatContextToIpStack: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        return NO_ERROR;
    }

    if(picb->bBound is FALSE)
    {
        Trace1(IF,
               "SetNatContextToIpStack: Not setting context for %S since it is not bound",
               picb->pwszName);


        TraceLeave("SetNatContextToIpStack");

        return NO_ERROR;
    }

    info.Index   = picb->dwAdapterId;
    info.Context = picb->pvNatContext;

    ntStatus = NtDeviceIoControlFile(g_hIpDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_SET_FIREWALL_IF,
                                     (PVOID)&info,
                                     sizeof(IP_SET_IF_CONTEXT_INFO),
                                     NULL,
                                     0);
    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "SetNatContextToIpStack: NtStatus %x while setting context for %S",
               ntStatus,
               picb->pwszName);

        TraceLeave("SetNatContextToIpStack");

        return ntStatus;
    }

    TraceLeave("SetNatContextToIpStack");

    return NO_ERROR;
#endif
}

DWORD
DeleteNatContextFromIpStack(
    PICB    picb
    )

/*++
Routine Description

    Deletes the the NAT context as the FIREWALL context in IP by setting it 
    to NULL
    Can only be called if NAT is running
    
Locks

    The ICB list should be held as WRITER

Arguments

    picb    ICB for the interface

Return Value

    NO_ERROR

--*/

{
#if 1
return 0;
#else
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    IoStatusBlock;
    DWORD              dwResult;
    IP_SET_IF_CONTEXT_INFO info;

    TraceEnter("DeleteNatContextFromIpStack");

    IpRtAssert((picb->ritType isnot ROUTER_IF_TYPE_INTERNAL) and
               (picb->ritType isnot ROUTER_IF_TYPE_LOOPBACK) and
               (picb->ritType isnot ROUTER_IF_TYPE_CLIENT));

    if(picb->pvNatContext is NULL)
    {
        Trace1(IF,
               "DeleteNatContextFromIpStack: No context, assuming interface %S not added to NAT",
               picb->pwszName);

        return NO_ERROR;
    }

    if(picb->bBound is FALSE)
    {
        Trace1(IF,
               "DeleteNatContextFromIpStack: Not deleting context for %S since it is not bound",
               picb->pwszName);

        TraceLeave("DeleteNatContextFromIpStack");

        return NO_ERROR;
    }

    info.Index   = picb->dwAdapterId;
    info.Context = NULL;

    ntStatus = NtDeviceIoControlFile(g_hIpDevice,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_IP_SET_FIREWALL_IF,
                                     (PVOID)&info,
                                     sizeof(IP_SET_IF_CONTEXT_INFO),
                                     NULL,
                                     0);
    if(!NT_SUCCESS(ntStatus))
    {
        Trace2(ERR,
               "DeleteNatContextFromIpStack: NtStatus %x while deleting context for %S",
               ntStatus,
               picb->pwszName);

        TraceLeave("DeleteNatContextFromIpStack");

        return ntStatus;
    }

    TraceLeave("DeleteNatContextFromIpStack");

    return NO_ERROR;
#endif
}

VOID
SetNatRangeForProxyArp(
    PICB    picb
    )

/*++

Routine Description

    This functions adds any address ranges in the NAT info as Proxy Arp
    addresses

Locks

    ICB_LIST locked as writer

Arguments

    picb    ICB of the interface whose nat info is being added

Return Value

    NONE    we log the errors, there isnt much to do with an error code

--*/

{
#if 1
return;
#else
    DWORD   dwResult, dwAddr, dwStartAddr, dwEndAddr, i;
   
    PIP_NAT_INTERFACE_INFO  pNatInfo; 
    PIP_NAT_ADDRESS_RANGE   pRange;

    
    //
    // Only do this if we have a valid adapter index and this is a LAN
    // interface
    //

    if((picb->dwOperationalState < MIB_IF_OPER_STATUS_CONNECTED) or
       (picb->ritType isnot ROUTER_IF_TYPE_DEDICATED))
    {
        return;
    }

    IpRtAssert(picb->bBound);
    IpRtAssert(picb->dwAdapterId isnot INVALID_ADAPTER_ID);

    pNatInfo = picb->pvNatInfo;

    //
    // Now, if we have ranges, we need to set the proxy arp addresses on them
    //

    for(i = 0; i < pNatInfo->Header.TocEntriesCount; i++)
    {
        if(pNatInfo->Header.TocEntry[i].InfoType isnot IP_NAT_ADDRESS_RANGE_TYPE)
        {
            continue;
        }

        if(pNatInfo->Header.TocEntry[i].InfoSize is 0)
        {
            continue;
        }

        //
        // Here we are adding potentially duplicate PARP entries.
        // Hopefully, IP knows how to handle it
        //
      
        pRange = GetInfoFromTocEntry(&(pNatInfo->Header),
                                     &(pNatInfo->Header.TocEntry[i]));

        //
        // Convert to little endian
        //

        dwStartAddr = ntohl(pRange->StartAddress);
        dwEndAddr   = ntohl(pRange->EndAddress);

        for(dwAddr = dwStartAddr;
            dwAddr <= dwEndAddr;
            dwAddr++)
        {
            DWORD   dwNetAddr, dwClassMask;

            dwNetAddr = htonl(dwAddr);

            //
            // Throw away useless addresses and then set proxy arp entries
            //

            dwClassMask = GetClassMask(dwNetAddr);

            if(((dwNetAddr & ~pRange->SubnetMask) is 0) or
               (dwNetAddr is (dwNetAddr & ~pRange->SubnetMask)) or
               ((dwNetAddr & ~dwClassMask) is 0) or
               (dwNetAddr is (dwNetAddr & ~dwClassMask)))
            {
                continue;
            }

            dwResult = SetProxyArpEntryToStack(dwNetAddr,
                                               0xFFFFFFFF,
                                               picb->dwAdapterId,
                                               TRUE,
                                               FALSE);

            if(dwResult isnot NO_ERROR)
            {
                Trace4(ERR,
                       "SetProxy: Error %x setting %d.%d.%d.%d over adapter %d (%S)",
                       dwResult,
                       PRINT_IPADDR(dwNetAddr),
                       picb->dwAdapterId,
                       picb->pwszName);
            }
        }
    }
#endif
}

VOID
DeleteNatRangeFromProxyArp(
    PICB    picb
    )

/*++

Routine Description

    This removes the previously added proxy arp addresses    

Locks

    ICB_LIST lock taken as writer

Arguments

    picb    The icb of the interface whose addr range info needs to be removed

Return Value

    NONE
    
--*/

{
#if 1
return;
#else
    DWORD   dwResult, dwAddr, dwStartAddr, dwEndAddr, i;
   
    PIP_NAT_INTERFACE_INFO  pNatInfo; 
    PIP_NAT_ADDRESS_RANGE   pRange;

    
    //
    // Only do this if we have a valid adapter index and this is a LAN
    // interface
    //

    if((picb->dwOperationalState < MIB_IF_OPER_STATUS_CONNECTED) or
       (picb->ritType isnot ROUTER_IF_TYPE_DEDICATED))
    {
        return;
    }

    IpRtAssert(picb->bBound);

    pNatInfo = picb->pvNatInfo;

    for(i = 0; i < pNatInfo->Header.TocEntriesCount; i++)
    {
        if(pNatInfo->Header.TocEntry[i].InfoType isnot IP_NAT_ADDRESS_RANGE_TYPE)
        {
            continue;
        }

        if(pNatInfo->Header.TocEntry[i].InfoSize is 0)
        {
            continue;
        }

        //
        // Here we are adding potentially duplicate PARP entries.
        // Hopefully, IP knows how to handle it
        //
      
        pRange = GetInfoFromTocEntry(&(pNatInfo->Header),
                                     &(pNatInfo->Header.TocEntry[i]));

        dwStartAddr = ntohl(pRange->StartAddress);
        dwEndAddr   = ntohl(pRange->EndAddress);

        for(dwAddr = dwStartAddr; 
            dwAddr <= dwEndAddr; 
            dwAddr++)
        {
            DWORD   dwNetAddr, dwClassMask;

            dwNetAddr = htonl(dwAddr);

            //
            // Throw away useless addresses and then set proxy arp entries
            //

            dwClassMask = GetClassMask(dwNetAddr);

            if(((dwNetAddr & ~pRange->SubnetMask) is 0) or
               (dwNetAddr is (dwNetAddr & ~pRange->SubnetMask)) or
               ((dwNetAddr & ~dwClassMask) is 0) or
               (dwNetAddr is (dwNetAddr & ~dwClassMask)))
            {
                continue;
            }

            dwResult = SetProxyArpEntryToStack(dwNetAddr,
                                               0xFFFFFFFF,
                                               picb->dwAdapterId,
                                               FALSE,
                                               FALSE);

            if(dwResult isnot NO_ERROR)
            {
                Trace4(ERR,
                       "DeleteProxy: Error %x removing %d.%d.%d.%d over adapter %d (%S)",
                       dwResult,
                       PRINT_IPADDR(dwNetAddr),
                       picb->dwAdapterId,
                       picb->pwszName);
            }
        }
    }
#endif
}

    
DWORD
GetNumNatMappings(
    PICB    picb,
    PULONG  pulNatMappings
    )

/*++

Routine Description

    This function queries the NAT with a minimum sized buffer to figure out
    the number of mappings
    Can only be called if NAT is running
    
Locks

    ICB_LIST lock held as READER

Arguments

    picb,           ICB of interface whose map count needs to be queried
    pulNatMappings  Number of mappings

Return Value

    NO_ERROR

--*/

{
#if 1
return 0;
#else
    DWORD       dwResult;

    IP_NAT_INTERFACE_STATISTICS stats;

    *pulNatMappings = 0;
    
    dwResult = GetNatStatistics(picb,
                                &stats);
    
    if(dwResult is NO_ERROR)
    {
        *pulNatMappings = stats.TotalMappings;
    }

    return dwResult;
#endif
}

DWORD
GetNatMappings(
    PICB                                picb,
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS  pBuffer,
    DWORD                               dwSize
    )

/*++

Routine Description

    This function gets the mappings on the interface
    Can only be called if NAT is running

Locks

    ICB_LIST held as READER

Arguments

    picb
    pBuffer
    pdwSize

Return Value

    None    

--*/

{
#if 1
return 0;
#else
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS        nStatus;

    if(picb->pvNatContext is NULL)
    {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    IpRtAssert(dwSize >= sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS));
    
    //
    // Zero out the context and stuff
    //
    
    ZeroMemory(pBuffer,
               sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS));

    pBuffer->NatInterfaceContext = picb->pvNatContext;

    nStatus = NtDeviceIoControlFile(g_hNatDevice,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_IP_NAT_ENUMERATE_SESSION_MAPPINGS,
                                    (PVOID)pBuffer,
                                    dwSize,
                                    (PVOID)pBuffer,
                                    dwSize);
    
    if(!NT_SUCCESS(nStatus))
    {
        Trace1(ERR,
               "GetNumNatMappings: NtStatus %x",
               nStatus);

        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
#endif
}

DWORD
GetNatStatistics(
    PICB                            picb,
    PIP_NAT_INTERFACE_STATISTICS    pBuffer
    )

/*++

Routine Description

    This function retrieves the nat interface statistics into the supplied
    buffer

Locks

    ICB_LIST lock held as READER

Arguments

    picb
    pBuffer

Return Value

    None    

--*/

{
#if 1
return 0;
#else
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS        nStatus;

    if(picb->pvNatContext is NULL)
    {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    pBuffer->NatInterfaceContext = picb->pvNatContext;
    
    nStatus = NtDeviceIoControlFile(g_hNatDevice,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    IOCTL_IP_NAT_GET_INTERFACE_STATISTICS,
                                    (PVOID)pBuffer,
                                    sizeof(IP_NAT_INTERFACE_STATISTICS),
                                    (PVOID)pBuffer,
                                    sizeof(IP_NAT_INTERFACE_STATISTICS));
   
    if(!NT_SUCCESS(nStatus))
    {
        Trace1(ERR,
               "GetNatStatistics: NtStatus %x",
               nStatus);

        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\route.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\route.c

Abstract:
    All routes related code lives here.

Revision History:

    Gurdeep Singh Pall          6/15/95  Created

--*/

#include "allinc.h"

DWORD
WINAPI
GetBestRoute(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSourceAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    );
    

DWORD
InitializeStaticRoutes(
    PICB                     pIcb, 
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    )

/*++

Routine Description:

    Adds static routes with RTM

Arguments:

    pIcb          The ICB of the interface for whom the routes are
    pInfoHdr      Pointer to info block containing IP_ROUTE_INFO

Return Value:

    NO_ERROR 

--*/

{
    DWORD               dwNumRoutes, dwResult;
    DWORD               i, j;
    PRTR_TOC_ENTRY      pToc;
    PINTERFACE_ROUTE_INFO   pRoutes;
    BOOL                bP2P;

    TraceEnter("IntializeStaticRoutes");
   
    //
    // If this is a client, only do the special client processing
    //

    if(pIcb->ritType is ROUTER_IF_TYPE_CLIENT)
    {
        CopyOutClientRoutes(pIcb,
                            pInfoHdr);
    
        return NO_ERROR;
    }
 
    //
    // We first go through the init route table and add any route going
    // over that interface that is
    //      (i)   not a local net route
    //      (ii)  not a subnet/net broadcast route
    //      (iii) not a Loopback route,
    //      (iv)  not a CLASS D or E route and not a 255.255.255.255 destination
    //      (vi)       a PROTO_IP_LOCAL or PROTO_IP_NETMGMT route
    //

    CheckBindingConsistency(pIcb);
   
    bP2P = IsIfP2P(pIcb->ritType);
 
    pToc = GetPointerToTocEntry(IP_ROUTE_INFO, 
                                pInfoHdr);
   
    if((pToc is NULL) or
       (pToc->InfoSize is 0))
    {
        Trace0(ROUTE,"IntializeStaticRoutes: No Routes found");
        
        TraceLeave("IntializeStaticRoutes");

        return NO_ERROR;
    }

    pRoutes = GetInfoFromTocEntry(pInfoHdr,
                                  pToc);

    if(pRoutes is NULL)
    {
        Trace0(ROUTE,"IntializeStaticRoutes: No Routes found");
        
        TraceLeave("IntializeStaticRoutes");

        return NO_ERROR;
    }

    dwNumRoutes = pToc->Count;
    
    for (i=0; i< dwNumRoutes; i++) 
    {
        DWORD dwMask;

        dwMask   = GetBestNextHopMaskGivenICB(pIcb,
                                              pRoutes[i].dwRtInfoNextHop);

        dwResult = AddSingleRoute(pIcb->dwIfIndex,
                                  (&pRoutes[i]),
                                  dwMask,
                                  0,     // RTM_ROUTE_INFO::Flags
                                  TRUE,  // Valid route
                                  TRUE,
                                  bP2P,
                                  NULL); // Add the route to stack, if need be

        if(dwResult isnot NO_ERROR)
        {
            Trace3(ERR,
                   "IntializeStaticRoutes: Error %d adding config route to %x over %S",
                   dwResult,
                   pRoutes[i].dwRtInfoDest,
                   pIcb->pwszName);
        }

    }
              
    TraceLeave("IntializeStaticRoutes");

    return NO_ERROR;
}

DWORD
CopyOutClientRoutes(
    PICB                     pIcb,
    PRTR_INFO_BLOCK_HEADER   pInfoHdr
    )

/*++

Routine Description:

    Stores a copy of the client static routes

Arguments:

    pIcb          The ICB of the interface for whom the routes are
    pInfoHdr      Pointer to info block containing IP_ROUTE_INFO

Return Value:

    NO_ERROR

--*/

{
    PINTERFACE_ROUTE_INFO   pRoutes;
    PINTERFACE_ROUTE_TABLE pStore;
    DWORD               i, dwNumRoutes;
    PRTR_TOC_ENTRY      pToc;

    pToc = GetPointerToTocEntry(IP_ROUTE_INFO,
                                pInfoHdr);

    if((pToc is NULL) or
       (pToc->InfoSize is 0))
    {
        return NO_ERROR;
    }

    pRoutes = GetInfoFromTocEntry(pInfoHdr,
                                  pToc);

    if (pRoutes is NULL)
    {
        return NO_ERROR;
    }
    
    dwNumRoutes = pToc->Count;

    if(dwNumRoutes is 0)
    {
        return NO_ERROR;
    }

    pStore = HeapAlloc(IPRouterHeap,
                       HEAP_ZERO_MEMORY,
                       SIZEOF_IPFORWARDTABLE(dwNumRoutes));

    if(pStore is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pStore->dwNumEntries = dwNumRoutes;

    for(i = 0; i < dwNumRoutes; i++)
    {
        pStore->table[i] = pRoutes[i];
    }

    pIcb->pStoredRoutes = pStore;

    return NO_ERROR;
}

    
DWORD
AddSingleRoute(
    DWORD                   dwIfIndex,
    PINTERFACE_ROUTE_INFO   pRtInfo,
    DWORD                   dwNextHopMask,
    WORD                    wRtmFlags,
    BOOL                    bValid,
    BOOL                    bAddToStack,
    BOOL                    bP2P,
    HANDLE                  *phRtmRoute OPTIONAL
    )

/*++

Routine Description

    Adds a route with RTM

Arguments

    pIcb          The ICB of the interface for whom the route is
    pIpForw       The route
    mask          Mask for destination

Return Value

    NO_ERROR or some code from RTM

--*/

{
    DWORD            i, dwResult, dwRouteFlags;
    HANDLE           hRtmHandle;
    DWORD            dwOldIfIndex;

    TraceEnter("AddSingleRoute");
   
    TraceRoute2(ROUTE,
            "route to %d.%d.%d.%d/%d.%d.%d.%d",
               PRINT_IPADDR(pRtInfo->dwRtInfoDest),
               PRINT_IPADDR(pRtInfo->dwRtInfoMask));

    TraceRoute4(ROUTE,
            "Flags 0x%x Valid %d Stack %d P2P %d",
            wRtmFlags, bValid, bAddToStack, bP2P
            );
            
    hRtmHandle = NULL;

    for(i = 0; 
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(pRtInfo->dwRtInfoProto is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }

    if(hRtmHandle is NULL)
    {    
        Trace1(ERR,
               "AddSingleRoute: Protocol %d not valid",
               pRtInfo->dwRtInfoProto);

        return ERROR_INVALID_PARAMETER;
    }

    if((pRtInfo->dwRtInfoDest & pRtInfo->dwRtInfoMask) isnot pRtInfo->dwRtInfoDest)
    {
        Trace2(ERR,
               "AddSingleRoute: Dest %d.%d.%d.%d and Mask %d.%d.%d.%d wrong",
               PRINT_IPADDR(pRtInfo->dwRtInfoDest),
               PRINT_IPADDR(pRtInfo->dwRtInfoMask));

        TraceLeave("AddSingleRoute");

        return ERROR_INVALID_PARAMETER;
    }

    if((((DWORD)(pRtInfo->dwRtInfoDest & 0x000000FF)) >= (DWORD)0x000000E0) and
       (pRtInfo->dwRtInfoDest isnot ALL_ONES_BROADCAST) and
       (pRtInfo->dwRtInfoDest isnot LOCAL_NET_MULTICAST))
    {
        //
        // This will catch the CLASS D/E
        //

        Trace1(ERR,
               "AddSingleRoute: Dest %d.%d.%d.%d is invalid",
               PRINT_IPADDR(pRtInfo->dwRtInfoDest));

        TraceLeave("AddSingleRoute");

        return ERROR_INVALID_PARAMETER;
    }

    // Special case to deal with weird utilities (legacy UI, etc):

    if (pRtInfo->dwRtInfoViewSet is 0)
    {
        pRtInfo->dwRtInfoViewSet = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;
    }

#if 0
    // Removed this check since a metric of 0 is legal, for example for
    // routes to the loopback interface.

    if(pRtInfo->dwRtInfoMetric1 is 0)
    {
        Trace0(ERR,
               "AddSingleRoute: Metric1 cant be 0");

        TraceLeave("AddSingleRoute");

        return ERROR_INVALID_PARAMETER;
    }
#endif

    if(bP2P)
    {
        dwNextHopMask = ALL_ONES_MASK;

        //pRtInfo->dwRtInfoNextHop = 0;
    }

    //
    // The route might not have the right index since config routes dont know
    // their interface id
    //

    dwOldIfIndex = pRtInfo->dwRtInfoIfIndex;
    
    pRtInfo->dwRtInfoIfIndex = dwIfIndex;
    
    //
    // Set the appropritate route flags
    //
    
    dwRouteFlags = 0;
   
    if(bValid)
    {
        dwRouteFlags |= IP_VALID_ROUTE;
    }
 
    if(bAddToStack)
    {
        dwRouteFlags |= IP_STACK_ROUTE;
    }

    if(bP2P)
    {
        dwRouteFlags |= IP_P2P_ROUTE;
    }

    // these flags correspond to RTM_ROUTE_INFO::Flags
    dwRouteFlags |= (wRtmFlags << 16);
    
    //
    // Add the forward route with RTM
    //

    dwResult = AddRtmRoute(hRtmHandle,
                           pRtInfo,
                           dwRouteFlags,
                           dwNextHopMask,
                           INFINITE,
                           phRtmRoute);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR, "AddSingleRoute: Could not add route to: %x",
               pRtInfo->dwRtInfoDest) ;
    }

    pRtInfo->dwRtInfoIfIndex = dwOldIfIndex;

    TraceLeave("AddSingleRoute");
    
    return dwResult;
}

DWORD 
DeleteSingleRoute(
    DWORD   dwIfIndex,
    DWORD   dwDestAddr,
    DWORD   dwDestMask,
    DWORD   dwNexthop,
    DWORD   dwProtoId,
    BOOL    bP2P
    )

/*++

Routine Description:

    Deletes a single route from RTM

Arguments:

    InterfaceID   Index of the interface
    dest          Destination address
    nexthop       Next hop address

Return Value:

    NO_ERROR or some code from RTM

--*/

{
    DWORD            i, dwResult;
    HANDLE           hRtmHandle;
    INTERFACE_ROUTE_INFO RtInfo;

    TraceEnter("DeleteSingleRoute");
    
    TraceRoute2(
        ROUTE, "DeleteSingleRoute: %d.%d.%d.%d/%d.%d.%d.%d",
        PRINT_IPADDR( dwDestAddr ),
        PRINT_IPADDR( dwDestMask )
        );

    hRtmHandle = NULL;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(dwProtoId is g_rgRtmHandles[i].dwProtoId)
        {
            hRtmHandle = g_rgRtmHandles[i].hRouteHandle;

            break;
        }
    }

    if(hRtmHandle is NULL)
    {
        Trace1(ERR,
               "DeleteSingleRoute: Protocol %d not valid",
               dwProtoId);

        return ERROR_INVALID_PARAMETER;
    }


    RtInfo.dwRtInfoNextHop = dwNexthop;

    /*
    if(bP2P)
    {
        RtInfo.dwRtInfoNextHop = 0;
    }
    else
    {
        RtInfo.dwRtInfoNextHop = dwNexthop;
    }
    */
    
    RtInfo.dwRtInfoDest     = dwDestAddr;
    RtInfo.dwRtInfoMask     = dwDestMask;
    RtInfo.dwRtInfoIfIndex  = dwIfIndex;
    RtInfo.dwRtInfoProto    = dwProtoId;

    //
    // Delete this forward route from RTM
    //

    dwResult = DeleteRtmRoute(hRtmHandle,
                              &RtInfo);
  
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "DeleteSingleRoute: Error %d deleting route in RTM.",
               dwResult);
    }

    TraceLeave("DeleteSingleRoute");
    
    return dwResult;
}

DWORD
DeleteAllRoutes(
    IN  DWORD   dwIfIndex,
    IN  BOOL    bStaticOnly
    )

/*++
  
Routine Description

    Deletes all the routes (owned by IP Router Manager) on the interface

Arguments

    dwIfIndex
    bStaticOnly

Return Value
  
    Error returned from RTM
    
--*/

{
    DWORD           i, dwResult = NO_ERROR;

    TraceEnter("DeleteAllRoutes");

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(bStaticOnly && !g_rgRtmHandles[i].bStatic)
        {
            continue;
        }

        dwResult = DeleteRtmRoutesOnInterface(g_rgRtmHandles[i].hRouteHandle,
                                              dwIfIndex);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAllRoutes: BlockDeleteRoutes returned %d for %d",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);

            continue;
        }

        dwResult = DeleteRtmNexthopsOnInterface(g_rgRtmHandles[i].hRouteHandle,
                                                dwIfIndex);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAllRoutes: BlockDeleteNextHops returned %d for %d",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);

            continue;
        }
    }

    TraceLeave("DeleteAllRoutes");

    return dwResult;
}

VOID
DeleteAllClientRoutes(
    PICB    pIcb,
    DWORD   dwServerIfIndex
    )

/*++

Routine Description

    Deletes all routes going to a client. Only needed for removal from
    RTM, stack removes them since the link has been deleted

Arguments

    pIcb
    dwServerIfIndex - ServerInterface's ifIndex

Return Value


--*/

{
    ULONG   i;

    TraceEnter("DeleteAllClientRoutes");

    IpRtAssert(pIcb->ritType is ROUTER_IF_TYPE_CLIENT);

    if((pIcb->pStoredRoutes is NULL) or
       (pIcb->pibBindings is NULL))
    {
        return; 
    }

    for(i = 0 ; i < pIcb->pStoredRoutes->dwNumEntries; i++)
    {
        DeleteSingleRoute(dwServerIfIndex,
                          pIcb->pStoredRoutes->table[i].dwRtInfoDest,
                          pIcb->pStoredRoutes->table[i].dwRtInfoMask,
                          pIcb->pibBindings[0].dwAddress,
                          PROTO_IP_NT_STATIC_NON_DOD,
                          FALSE);
    }
}

VOID
AddAllClientRoutes(
    PICB    pIcb,
    DWORD   dwServerIfIndex
    )

/*++

Routine Description

    Adds the stored routes over the server interface

Arguments

    pIcb
    dwServerIfIndex - ServerInterface's ifIndex

Return Value


--*/

{
    ULONG   i;

    TraceEnter("AddAllClientRoutes");

    IpRtAssert(pIcb->ritType is ROUTER_IF_TYPE_CLIENT);

    if((pIcb->pStoredRoutes is NULL) or
       (pIcb->pibBindings is NULL))
    {
        return;
    }

    for(i = 0; i < pIcb->pStoredRoutes->dwNumEntries; i++)
    {
        //
        // Fix the next hop since that is not known
        // Also fix someother fields which we know are not being set
        // correctly for client routes
        //

        pIcb->pStoredRoutes->table[i].dwRtInfoNextHop = 
            pIcb->pibBindings[0].dwAddress;

        pIcb->pStoredRoutes->table[i].dwRtInfoProto   = 
            PROTO_IP_NT_STATIC_NON_DOD;

        pIcb->pStoredRoutes->table[i].dwRtInfoMetric2 = 0;
        pIcb->pStoredRoutes->table[i].dwRtInfoMetric3 = 0;

        pIcb->pStoredRoutes->table[i].dwRtInfoPreference = 
                ComputeRouteMetric(MIB_IPPROTO_LOCAL);

        pIcb->pStoredRoutes->table[i].dwRtInfoViewSet    = 
                RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

        AddSingleRoute(dwServerIfIndex,
                       &(pIcb->pStoredRoutes->table[i]),
                       pIcb->pibBindings[0].dwMask,
                       0,       // RTM_ROUTE_INFO::Flags
                       TRUE,
                       TRUE,
                       FALSE,
                       NULL);
    }
}

DWORD
GetNumStaticRoutes(
    PICB pIcb
    )

/*++
  
Routine Description

    Figure out the number of static routes associated with an interface

Arguments

    pIcb          The ICB of the interface whose route count is needed

Return Value

    Number of routes associated with an interface
  
--*/

{
    HANDLE           hRtmHandle;
    HANDLE           hRtmEnum;
    PHANDLE          hRoutes;
    DWORD            dwHandles;
    DWORD            dwNumRoutes;
    DWORD            i, j;
    DWORD            dwResult;
    
    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(ERR,
               "GetNumStaticRoutes: Error allocating %d bytes for "
               "handles\n",
               g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
               );

        return 0;
    }
    
    dwNumRoutes = 0;

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(!g_rgRtmHandles[i].bStatic)
        {
            continue;
        }

        hRtmHandle = g_rgRtmHandles[i].hRouteHandle;
        
        dwResult = RtmCreateRouteEnum(hRtmHandle,
                                      NULL,
                                      RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST,
                                      RTM_ENUM_OWN_ROUTES,
                                      NULL,
                                      RTM_MATCH_INTERFACE,
                                      NULL,
                                      pIcb->dwIfIndex,
                                      &hRtmEnum);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "GetNumStaticRoutes: Error %d creating handle for %d\n",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);
            
            continue;
        }

        do
        {
            dwHandles = g_rtmProfile.MaxHandlesInEnum;
            
            dwResult = RtmGetEnumRoutes(hRtmHandle,
                                        hRtmEnum,
                                        &dwHandles,
                                        hRoutes);

            dwNumRoutes += dwHandles;

            RtmReleaseRoutes(hRtmHandle, dwHandles, hRoutes);
        }
        while (dwResult is NO_ERROR);

        RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);
    }

    HeapFree(IPRouterHeap, 0, hRoutes);
    
    return dwNumRoutes;
}


DWORD
GetInterfaceRouteInfo(
    IN     PICB                   pIcb, 
    IN     PRTR_TOC_ENTRY         pToc, 
    IN     PBYTE                  pbDataPtr, 
    IN OUT PRTR_INFO_BLOCK_HEADER pInfoHdr,
    IN OUT PDWORD                 pdwInfoSize
    )
/*++
  
Routine Description

    Gets the route info (static routes) associated with an interface

Arguments

    pIcb          The ICB of the interface for whom the info is requested
    pToc          Pointer to TOC for the total inforamtion
    pbDataPtr     Pointer to free space where info can be written
    pInfoHdr      Pointer to Info Hdr 
    pdwInfoSize   Size of free space

Return Value

    NO_ERROR or some code from RTM
    
--*/

{
    DWORD               dwNumRoutes;
    PINTERFACE_ROUTE_INFO  pRoutes = (PINTERFACE_ROUTE_INFO) pbDataPtr ;
    DWORD               dwMaxRoutes;

    TraceEnter("GetInterfaceRouteInfo");
    
    dwNumRoutes = GetNumStaticRoutes(pIcb);
   
    dwMaxRoutes = MAX_ROUTES_IN_BUFFER(*pdwInfoSize);
 
    if(dwNumRoutes > dwMaxRoutes)
    {
        *pdwInfoSize = SIZEOF_ROUTEINFO(dwNumRoutes);
        
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    dwNumRoutes     = ReadAllStaticRoutesIntoBuffer(pIcb,
                                                    pRoutes,
                                                    dwMaxRoutes);
    
    *pdwInfoSize    = SIZEOF_ROUTEINFO(dwNumRoutes);

    //pToc->InfoVersion  = sizeof(INTERFACE_ROUTE_INFO);
    pToc->InfoSize  = sizeof(INTERFACE_ROUTE_INFO);
    pToc->InfoType  = IP_ROUTE_INFO ;
    pToc->Count     = dwNumRoutes;
    pToc->Offset    = (ULONG)(pbDataPtr - (PBYTE) pInfoHdr) ;

    TraceLeave("GetInterfaceRouteInfo");
    
    return NO_ERROR;
}

DWORD
ReadAllStaticRoutesIntoBuffer(
    PICB                 pIcb, 
    PINTERFACE_ROUTE_INFO   pRoutes,
    DWORD                dwMaxRoutes
    )

/*++
  
Routine Description

    Reads out static routes from RTM

Arguments

    pIcb          The ICB of the interface for whom the route is
    routptr       Pointer to where info has to be written out
    dwMaxRoutes   Max routes the buffer can hold

Return Value

    Count of routes written out
    
--*/

{
    HANDLE           hRtmHandle;
    HANDLE           hRtmEnum;
    PHANDLE          hRoutes;
    PRTM_NET_ADDRESS pDestAddr;
    PRTM_ROUTE_INFO  pRoute;
    RTM_NEXTHOP_INFO nhiInfo;
    RTM_ENTITY_INFO  entityInfo;
    DWORD            dwNumRoutes;
    DWORD            dwHandles;
    DWORD            i, j;
    DWORD            dwResult;

    pRoute = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if (pRoute == NULL)
    {
        return 0;
    }
    
    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        HeapFree(IPRouterHeap, 0, pRoute);
        
        return 0;
    }

    pDestAddr = HeapAlloc(
                IPRouterHeap,
                0,
                sizeof(RTM_NET_ADDRESS)
                );

    if (pDestAddr == NULL)
    {
        HeapFree(IPRouterHeap, 0, pRoute);
        
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        return 0;
    }

    dwNumRoutes = 0;

    for(i = 0;
        (i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO)) and
        (dwNumRoutes < dwMaxRoutes);
        i++)
    {
        if(!g_rgRtmHandles[i].bStatic)
        {
            continue;
        }

        hRtmHandle = g_rgRtmHandles[i].hRouteHandle;
        
        dwResult = RtmCreateRouteEnum(hRtmHandle,
                                      NULL,
                                      RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST,
                                      RTM_ENUM_OWN_ROUTES,
                                      NULL,
                                      RTM_MATCH_INTERFACE,
                                      NULL,
                                      pIcb->dwIfIndex,
                                      &hRtmEnum);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "ReadAllStaticRoutesIntoBuffer: Error %d creating handle for %d\n",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);
            
            continue;
        }
        
        do
        {
            dwHandles = g_rtmProfile.MaxHandlesInEnum;
            
            dwResult = RtmGetEnumRoutes(hRtmHandle,
                                        hRtmEnum,
                                        &dwHandles,
                                        hRoutes);
                                        
            //
            // We pick up all that we can in the buffer. If things
            // change between the time the size of the buffer was
            // calculated and now,we discard the additional routes
            //
            // TBD: * Log an event if the buffer was too small *
            //

            for (j = 0; (j < dwHandles) && (dwNumRoutes < dwMaxRoutes); j++)
            {
                // Get the route info corr. to this handle
                
                if (RtmGetRouteInfo(hRtmHandle,
                                    hRoutes[j],
                                    pRoute,
                                    pDestAddr) is NO_ERROR)
                {
                    if (RtmGetEntityInfo(hRtmHandle,
                                         pRoute->RouteOwner,
                                         &entityInfo) is NO_ERROR)
                    {
                        if (RtmGetNextHopInfo(hRtmHandle,
                                              pRoute->NextHopsList.NextHops[0],
                                              &nhiInfo) is NO_ERROR)
                        {
                            // We assume that static routes have only 1 nexthop
                        
                            ConvertRtmToRouteInfo(entityInfo.EntityId.EntityProtocolId,
                                                     pDestAddr,
                                                     pRoute,
                                                     &nhiInfo,
                                                     &(pRoutes[dwNumRoutes++]));

                            RtmReleaseNextHopInfo(hRtmHandle, &nhiInfo);
                        }
                    }

                    RtmReleaseRouteInfo(hRtmHandle, pRoute);
                }
            }

            RtmReleaseRoutes(hRtmHandle, dwHandles, hRoutes);
        }
        while ((dwResult is NO_ERROR) && (dwNumRoutes < dwMaxRoutes));

        RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);
    }
    
    HeapFree(IPRouterHeap, 0, pRoute);
    
    HeapFree(IPRouterHeap, 0, hRoutes);

    HeapFree(IPRouterHeap, 0, pDestAddr);

    return dwNumRoutes;
}


DWORD
SetRouteInfo(
    PICB                    pIcb,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr
    )

/*++
  
Routine Description

    Sets the route info associated with an interface
    First we add the routes present in the route info. Then we enumerate
    the routes and delete those that we dont find in the route info
      
Arguments

    pIcb          The ICB of the interface for whom the route info is

Return Value

    NO_ERROR
    
--*/

{
    PINTERFACE_ROUTE_INFO   pRoutes;
    PRTR_TOC_ENTRY      pToc;
    BOOL                bP2P;
    HANDLE              hRtmHandle;
    HANDLE              hRtmEnum;
    PHANDLE             hAddedRoutes;
    DWORD               dwNumRoutes;
    PHANDLE             hRoutes;
    DWORD               dwHandles;
    DWORD               i, j, k;
    DWORD               dwFlags, dwResult;

    TraceEnter("SetRouteInfo");
   
    if(pIcb->dwOperationalState is UNREACHABLE)
    {
        Trace1(ROUTE,
               "SetRouteInfo: %S is unreachable, not setting routes",
               pIcb->pwszName);

        return NO_ERROR;
    }

    pToc = GetPointerToTocEntry(IP_ROUTE_INFO, pInfoHdr);

    if(pToc is NULL)
    {
        //
        // No TOC means no change
        //

        TraceLeave("SetRouteInfo");
        
        return NO_ERROR;
    }


    pRoutes = (PINTERFACE_ROUTE_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                         pToc);
    
    if((pToc->InfoSize is 0) or (pRoutes is NULL))
    {
        //
        // Delete all the static routes
        //

        DeleteAllRoutes(pIcb->dwIfIndex,
                        TRUE);
        
        TraceLeave("SetRouteInfo");
        
        return NO_ERROR;
    }
    
    dwResult = NO_ERROR;
    
    dwNumRoutes  = pToc->Count;

    // Handles to routes added are stored here
    hAddedRoutes = HeapAlloc(
                    IPRouterHeap,
                    0,
                    dwNumRoutes * sizeof(HANDLE)
                    );

    if (hAddedRoutes == NULL)
    {
        Trace1(ERR,
               "SetRouteInfo: Error allocating %d bytes for addded "
               "route handles",
               dwNumRoutes * sizeof(HANDLE));
        
        TraceLeave("SetRouteInfo");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(ERR,
               "SetRouteInfo: Error allocating %d bytes for route "
               "handles",
               dwNumRoutes * sizeof(HANDLE));
        
        HeapFree(IPRouterHeap, 0, hAddedRoutes);
        
        TraceLeave("SetRouteInfo");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    //
    // The route info is set in two phases. First, all the routes specified
    // are added, and then, the ones present, but not in the info are deleted
    //
   
    bP2P = IsIfP2P(pIcb->ritType);
 
    for(i = j = 0; i < dwNumRoutes; i++)
    {
        DWORD dwMask;
      
        //
        // If this will be a point to point interface,
        // ignore the next hop
        //

        if((pIcb->dwOperationalState is DISCONNECTED) and
           (pRoutes[i].dwRtInfoProto is PROTO_IP_NT_STATIC_NON_DOD))
        {
            continue;
        }
 
        if(bP2P)
        {
            pRoutes[i].dwRtInfoNextHop = pIcb->dwRemoteAddress;
            dwMask = ALL_ONES_MASK;
        }
        else
        {
            dwMask = GetBestNextHopMaskGivenIndex(pIcb->dwIfIndex,
                                                  pRoutes[i].dwRtInfoNextHop);
        }

        if (AddSingleRoute(pIcb->dwIfIndex,
                           &(pRoutes[i]),
                           dwMask,
                           0,       // RTM_ROUTE_INFO::Flags
                           TRUE,    // Valid route
                           TRUE,
                           bP2P,
                           &hAddedRoutes[j]) is NO_ERROR)
        {
            j++;
        }
    }

    dwNumRoutes = j;

    //
    // Now enumerate the static routes, deleting the routes that are
    // not in the new list.
    //

    for(i = 0;
        i < sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
        i++)
    {
        if(!g_rgRtmHandles[i].bStatic)
        {
            continue;
        }

        hRtmHandle = g_rgRtmHandles[i].hRouteHandle;
        
        dwResult = RtmCreateRouteEnum(hRtmHandle,
                                      NULL,
                                      RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST,
                                      RTM_ENUM_OWN_ROUTES,
                                      NULL,
                                      RTM_MATCH_INTERFACE,
                                      NULL,
                                      pIcb->dwIfIndex,
                                      &hRtmEnum);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "SetRouteInfo: Error %d creating enum handle for %d",
                   dwResult,
                   g_rgRtmHandles[i].dwProtoId);
            
            continue;
        }

        do
        {
            dwHandles = g_rtmProfile.MaxHandlesInEnum;
            
            dwResult = RtmGetEnumRoutes(hRtmHandle,
                                        hRtmEnum,
                                        &dwHandles,
                                        hRoutes);

            for (j = 0; j < dwHandles; j++)
            {
                BOOL  bFound = FALSE;
                
                for (k = 0; k < dwNumRoutes; k++) 
                {
                    if (hRoutes[j] == hAddedRoutes[k])
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                
                if(!bFound)
                {
                    if (RtmDeleteRouteToDest(g_rgRtmHandles[i].hRouteHandle,
                                             hRoutes[j],
                                             &dwFlags) is NO_ERROR)
                    {
                        continue;
                    }
                }

                RtmReleaseRoutes(g_rgRtmHandles[i].hRouteHandle,
                                 1,
                                 &hRoutes[j]);
            }
        }
        while (dwResult is NO_ERROR);
        
        RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);
    }

    // Release the array of handles for routes added

    RtmReleaseRoutes(g_hLocalRoute, dwNumRoutes, hAddedRoutes);
    
    HeapFree(IPRouterHeap, 0, hAddedRoutes);

    HeapFree(IPRouterHeap, 0, hRoutes);

    TraceLeave("SetRouteInfo");
    
    return NO_ERROR;
}

#if 0

DWORD
EnableAllStaticRoutes (
    DWORD    dwInterfaceIndex,
    BOOL     fenable
    )

/*++
  
Routine Description

    Enables or disables Static Routes for an interface

Locks

    Called with ICB_LIST lock held as READER

Arguments

    pIcb          The ICB of the interface
    fenable       TRUE if enable 

Return Value

    NO_ERROR
    
--*/

{
    RTM_IP_ROUTE route ;

    TraceEnter("EnableAllStaticRoutes");
    
    Trace1(ROUTE, "EnableAllStaticRoutes entered with fenable = %d\n",
           fenable) ;

    route.RR_InterfaceID        = dwInterfaceIndex;
    route.RR_RoutingProtocol    = PROTO_IP_LOCAL;
    
    RtmBlockSetRouteEnable(g_hRtmHandle,
                           RTM_ONLY_THIS_INTERFACE | RTM_ONLY_THIS_PROTOCOL,
                           &route,
                           fenable);

    route.RR_InterfaceID        = dwInterfaceIndex;
    route.RR_RoutingProtocol    = PROTO_IP_NT_AUTOSTATIC;

    RtmBlockSetRouteEnable(g_hAutoStaticHandle,
                           RTM_ONLY_THIS_INTERFACE | RTM_ONLY_THIS_PROTOCOL,
                           &route,
                           fenable);


    TraceLeave("EnableAllStaticRoutes");
    
    return NO_ERROR;
}

#endif

DWORD
ConvertRoutesToAutoStatic(
    DWORD dwProtocolId, 
    DWORD dwIfIndex
    )

/*++

Routine Description

    Called to convert routes from a protocol's ownership (IP_RIP) to static 
    (PROTO_IP_NT_AUTOSTATIC)
    Used for autostatic updates etc.

Arguments

    protocolid       Id of protocol whose routes are to be converted
    interfaceindex   Index of the interface whose routes are to be converted
      
Return Value

--*/

{
    DWORD           dwResult, dwFlags;
    
    TraceEnter("ConvertRoutesToAutoStatic");

#if 0

    //
    // We now do the delete before calling the protocols update
    // route
    //

    dwResult = DeleteRtmRoutesOnInterface(g_hAutoStaticHandle,
                                             dwIfIndex);
        
    if((dwResult isnot ERROR_NO_ROUTES) and
       (dwResult isnot NO_ERROR)) 
    {
        Trace1(ERR,
               "ConvertRoutesToAutoStatic: Error %d block deleting routes",
               dwResult);
    }

#endif

    if(((dwResult = BlockConvertRoutesToStatic(g_hAutoStaticRoute,
                                  dwIfIndex, 
                                  dwProtocolId)) isnot NO_ERROR))
    {
        dwResult = GetLastError();
        
        Trace1(ROUTE, 
               "ConvertRoutesToAutoStatic: Rtm returned error: %d", 
               dwResult);
    }

    TraceLeave("ConvertRoutesToAutoStatic");
    
    return dwResult;
}


VOID
ChangeAdapterIndexForDodRoutes (
    DWORD    dwInterfaceIndex
    )

/*++
  
Routine Description

    Changes the adapter index for static routes associated with an
    interface.  The adapter index can go from being valid (the index of a
    net card known to the stack) to INVALID_INDEX. This happens when an
    interface gets unmapped (say on disconnection).  The stack special
    cases the routes with index = 0xffffffff (invalid_index) and does demand
    dial call out for packets destined on such adapters.

    We only enumerate best routes, because this function short circuits
    the normal metric comparison of RTM. If we ran this on all the routes,
    we would be adding some routes to stack which were not meant to be there.
      
Arguments
  
    pIcb  The ICB of the interface 

Return Value

    None
    
--*/

{
    HANDLE           hRtmHandles[2];
    HANDLE           hRtmHandle;
    HANDLE           hRtmEnum;
    PHANDLE          hRoutes;
    PRTM_NET_ADDRESS pDestAddr;
    PRTM_ROUTE_INFO  pRoute;
    RTM_VIEW_SET     fBestInViews;
    DWORD            dwHandles;
    DWORD            i, j;
    DWORD            dwResult;

    pRoute = HeapAlloc(
                IPRouterHeap,
                0,
                RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                );

    if (pRoute == NULL)
    {
        Trace1(
            ERR, "ChangeAdapterIndexForDodRoutes : Error allocating %d "
            " bytes for route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        return;
    }

    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(
            ERR, "ChangeAdapterIndexForDodRoutes : Error allocating %d "
            " bytes for route handles",
            g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
            );
            
        HeapFree(IPRouterHeap, 0, pRoute);
        
        return;
    }
    
    pDestAddr = HeapAlloc(
                    IPRouterHeap,
                    0,
                    sizeof(RTM_NET_ADDRESS)
                    );

    if (pDestAddr == NULL)
    {
        Trace1(
            ERR, "ChangeAdapterIndexForDodRoutes : Error allocating %d "
            " bytes for dest. address",
            sizeof(RTM_NET_ADDRESS)
            );
            
        HeapFree(IPRouterHeap, 0, pRoute);
        
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        return;
    }
    

    hRtmHandles[0] = g_hStaticRoute;        // For all static (dod) routes..
    hRtmHandles[1] = g_hAutoStaticRoute;    // For all autostatic routes....

    for (i = 0; i < 2; i++)
    {
        hRtmHandle = hRtmHandles[i];
        
        dwResult = RtmCreateRouteEnum(hRtmHandle,
                                      NULL,
                                      RTM_VIEW_MASK_UCAST,
                                      RTM_ENUM_OWN_ROUTES,
                                      NULL,
                                      RTM_MATCH_INTERFACE,
                                      NULL,
                                      dwInterfaceIndex,
                                      &hRtmEnum);

        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "ChangeAdapterIndexForDodRoutes: Error %d creating enum handle for %s routes",
                   dwResult,
                   (i == 0) ? "static" : "autostatic");
        }
        else
        {        
            do
            {
                dwHandles = g_rtmProfile.MaxHandlesInEnum;
                
                dwResult = RtmGetEnumRoutes(hRtmHandle,
                                            hRtmEnum,
                                            &dwHandles,
                                            hRoutes);

                for (j = 0; j < dwHandles; j++)
                {
                    // Is this the best route in unicast view
                    
                    dwResult = RtmIsBestRoute(hRtmHandle,
                                              hRoutes[j],
                                              &fBestInViews);

                    if ((dwResult isnot NO_ERROR) or
                        (!(fBestInViews & RTM_VIEW_MASK_UCAST)))
                    {
                        continue;
                    }
                    
                    // Get the route info corr. to this handle
                    
                    if (RtmGetRouteInfo(hRtmHandle,
                                        hRoutes[j],
                                        pRoute,
                                        pDestAddr) is NO_ERROR)
                    {                    
                        //
                        // This call adds the same route with the forwarder - with
                        // the current adapter index
                        //
            /*       
                        pRoute->RR_FamilySpecificData.FSD_Metric += 
                            g_ulDisconnectedMetricIncrement;

                        RtmAddRoute(g_hStaticRoute,
                                    pRoute,
                                    INFINITE,
                                    &fFlags,
                                    NULL,
                                    NULL); 
            */

                        ChangeRouteWithForwarder(pDestAddr, 
                                                 pRoute, 
                                                 TRUE,
                                                 TRUE);

                        RtmReleaseRouteInfo(hRtmHandle, pRoute);
                    }
                }

                RtmReleaseRoutes(hRtmHandle, dwHandles, hRoutes);
            }
            while (dwResult is NO_ERROR);

            RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);
        }
    }
    
    HeapFree(IPRouterHeap, 0, pRoute);
    HeapFree(IPRouterHeap, 0, hRoutes);
    HeapFree(IPRouterHeap, 0, pDestAddr);
    
    return;
}

#if 0
DWORD
GetMaskForClientSubnet(
    DWORD    dwInternalAddress
    )
/*++
  Routine Description

  Arguments

  Return Value
--*/
{
    HANDLE          hEnum;
    RTM_IP_ROUTE    route;

    TraceEnter("IsRoutePresent");

    route.RR_RoutingProtocol    = PROTO_IP_LOCAL;

    hEnum = RtmCreateEnumerationHandle(RTM_PROTOCOL_FAMILY_IP,
                                       RTM_ONLY_THIS_PROTOCOL,
                                       &route);

    if(hEnum is NULL)
    {
        return GetClassMask(dwInternalAddress);
    }


    while(RtmEnumerateGetNextRoute(hEnum, &route) isnot ERROR_NO_MORE_ROUTES)
    {
        if(route.RR_Network.N_NetMask is 0x00000000)
        {
            //
            // Dont match default route
            //

            continue;
        }

        if((dwInternalAddress & route.RR_Network.N_NetMask) is route.RR_Network.N_NetNumber)
        {
            RtmCloseEnumerationHandle(hEnum);

            TraceLeave("IsRoutePresent");

            return route.RR_Network.N_NetMask;
        }
    }

    RtmCloseEnumerationHandle(hEnum);

    TraceLeave("IsRoutePresent");

    return GetClassMask(dwInternalAddress);
}

#endif

VOID
AddAutomaticRoutes(
    PICB    pIcb,
    DWORD   dwAddress,
    DWORD   dwMask
    )

/*++

Routine Description

    This function adds the routes that are otherwise generated by the
    stack. This is mainly done for consistency between RTM and kernel tables
    
    The routes added are:
        (i)   local loopback
        (ii)  local multicast
        (iii) local subnet -> if the dwMask is not 255.255.255.255
        (iv)  all subnets broadcast -> if the ClassMask and Mask are different
        (v)   all 1's broadcast
        
    Since some of the routes are added to the stack the interface to adapter
    index map must already be set before this function is called
    
    VERY IMPORTANT:
    
    One MUST add the local route before binding the interface because this
    route is not going to be added to stack. However it has higher
    priority than say an OSPF route. Now if we first bind the interface
    to OSPF, it will add a network route for this interface (which will
    get added to the stack since only Router Manager can add non
    stack routes). Now when we add the local route to RTM, we will find
    our route better because we are higher priority. So RTM will tell
    us to delete the OSPF route (which we will since its a stack route).
    Then he will tell us to add our route to the stack.  But we wont
    do this since its a non stack route. So we basically end up deleting
    network route from the routing table

Locks

    

Arguments

    

Return Value


--*/

{
    DWORD               dwClassMask, dwResult;
    INTERFACE_ROUTE_INFO    RtInfo;
    BOOL                bP2P;

    IpRtAssert(pIcb->bBound);
    IpRtAssert(dwAddress isnot INVALID_IP_ADDRESS);

    return;
    
    bP2P = IsIfP2P(pIcb->ritType);
 
    if(dwMask isnot ALL_ONES_MASK)
    {
        BOOL            bStack, bDontAdd;
        RTM_NET_ADDRESS DestAddr;
        PRTM_DEST_INFO  pDestInfo;
        DWORD           dwLen;

        //
        // We now add the subnet route to stack so that if race condition
        // had deleted the route on stopping, the restarting
        // fixes the problem
        //

        //
        // NOTE: For the RAS Server Interface we need to add the route to the
        // routing table only if such a route doesnt exist. We need to add it
        // because we want the pool advertised by the routing protocols
        // However, adding to the stack will fail since we dont have a valid
        // next hop (which is needed for p2mp)
        //

        bDontAdd = FALSE;

        if(pIcb->ritType is ROUTER_IF_TYPE_INTERNAL)
        {
            //
            // If a route to this virtual net exists, dont add it
            //

            __try
            {
                pDestInfo = 
                    _alloca(RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                IpRtAssert(FALSE);
            }

            RTM_IPV4_LEN_FROM_MASK(dwLen, dwMask);

            RTM_IPV4_MAKE_NET_ADDRESS(&DestAddr,  (dwAddress & dwMask), dwLen);

            if (RtmGetExactMatchDestination(g_hLocalRoute,
                                            &DestAddr,
                                            RTM_BEST_PROTOCOL,
                                            RTM_VIEW_MASK_UCAST,
                                            pDestInfo) is NO_ERROR)
            {
                RtmReleaseDestInfo(g_hLocalRoute, pDestInfo);

                Trace1(IF,
                       "AddAutomaticRoutes: Route to virtual LAN %d.%d.%d.%d already exists",
                       PRINT_IPADDR(dwAddress));

                bDontAdd = TRUE;
            }
        }

        if(!bDontAdd)
        {
            //
            // Add the network route
            //
        
            RtInfo.dwRtInfoDest          = (dwAddress & dwMask);
            RtInfo.dwRtInfoMask          = dwMask;
            RtInfo.dwRtInfoNextHop       = dwAddress;
            RtInfo.dwRtInfoIfIndex       = pIcb->dwIfIndex;
            RtInfo.dwRtInfoMetric1       = 1;
            RtInfo.dwRtInfoMetric2       = 1;
            RtInfo.dwRtInfoMetric3       = 1;
            RtInfo.dwRtInfoPreference    = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
            RtInfo.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST |
                                              RTM_VIEW_MASK_MCAST; // XXX config
            RtInfo.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
            RtInfo.dwRtInfoProto         = MIB_IPPROTO_LOCAL;
            RtInfo.dwRtInfoAge           = INFINITE;
            RtInfo.dwRtInfoNextHopAS     = 0;
            RtInfo.dwRtInfoPolicy        = 0;
        
            bStack = TRUE;
       
            IpRtAssert(bP2P is FALSE);
 
            dwResult = AddSingleRoute(pIcb->dwIfIndex,
                                      &RtInfo,
                                      dwMask,
                                      // RTM_ROUTE_INFO::Flags
                                      RTM_ROUTE_FLAGS_LOCAL,
                                      TRUE,     // Valid route
                                      bStack,
                                      bP2P,
                                      NULL);
        
            if(dwResult isnot NO_ERROR)
            {
                Trace1(ERR,
                       "AddAutoRoutes: Can't add subnet route for %d.%d.%d.%d",
                       PRINT_IPADDR(dwAddress));
            }
        }
    }
    
    if(g_pLoopbackInterfaceCb)
    {
        RtInfo.dwRtInfoDest      = dwAddress;
        RtInfo.dwRtInfoMask      = HOST_ROUTE_MASK;
        RtInfo.dwRtInfoNextHop   = IP_LOOPBACK_ADDRESS;
        RtInfo.dwRtInfoIfIndex   = g_pLoopbackInterfaceCb->dwIfIndex;
        RtInfo.dwRtInfoMetric1   = 1;
        RtInfo.dwRtInfoMetric2   = 1;
        RtInfo.dwRtInfoMetric3   = 1;
        RtInfo.dwRtInfoPreference= ComputeRouteMetric(MIB_IPPROTO_LOCAL);
        RtInfo.dwRtInfoViewSet   = RTM_VIEW_MASK_UCAST |
                                      RTM_VIEW_MASK_MCAST;
        RtInfo.dwRtInfoType      = MIB_IPROUTE_TYPE_DIRECT;
        RtInfo.dwRtInfoProto     = MIB_IPPROTO_LOCAL;
        RtInfo.dwRtInfoAge       = INFINITE;
        RtInfo.dwRtInfoNextHopAS = 0;
        RtInfo.dwRtInfoPolicy    = 0;

        dwResult = AddSingleRoute(g_pLoopbackInterfaceCb->dwIfIndex,
                                  &RtInfo,
                                  dwMask,
                                  // RTM_ROUTE_INFO::Flags
                                  RTM_ROUTE_FLAGS_MYSELF,
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  NULL);
            
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "AddAutoRoutes: Cant add 127.0.0.1 route for %d.%d.%d.%d",
                   PRINT_IPADDR(dwAddress));
        }
    }
    
    RtInfo.dwRtInfoDest          = LOCAL_NET_MULTICAST;
    RtInfo.dwRtInfoMask          = LOCAL_NET_MULTICAST_MASK;
    RtInfo.dwRtInfoNextHop       = dwAddress;
    RtInfo.dwRtInfoIfIndex       = pIcb->dwIfIndex;
    RtInfo.dwRtInfoMetric1       = 1;
    RtInfo.dwRtInfoMetric2       = 1;
    RtInfo.dwRtInfoMetric3       = 1;
    RtInfo.dwRtInfoPreference    = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
    RtInfo.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST;
    RtInfo.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
    RtInfo.dwRtInfoProto         = MIB_IPPROTO_LOCAL;
    RtInfo.dwRtInfoAge           = INFINITE;
    RtInfo.dwRtInfoNextHopAS     = 0;
    RtInfo.dwRtInfoPolicy        = 0;

    dwResult = AddSingleRoute(pIcb->dwIfIndex,
                              &RtInfo,
                              dwMask,
                              0,        // RTM_ROUTE_INFO::Flags
                              FALSE,    // Protocols dont like a mcast route
                              FALSE,    // No need to add to stack
                              bP2P,
                              NULL);
        
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AddAutoRoutes: Couldnt add 224.0.0.0 route for %d.%d.%d.%d",
               PRINT_IPADDR(dwAddress));
    }
        
    //
    // We add the All 1's Bcast route to all interfaces. This is
    // actually a BUG since we should see if the medium allows
    // broadcast (X.25 would be an example of one that didnt)
    //
    
    RtInfo.dwRtInfoDest          = ALL_ONES_BROADCAST;
    RtInfo.dwRtInfoMask          = HOST_ROUTE_MASK;
    RtInfo.dwRtInfoNextHop       = dwAddress;
    RtInfo.dwRtInfoIfIndex       = pIcb->dwIfIndex;
    RtInfo.dwRtInfoMetric1       = 1;
    RtInfo.dwRtInfoMetric2       = 1;
    RtInfo.dwRtInfoMetric3       = 1;
    RtInfo.dwRtInfoPreference    = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
    RtInfo.dwRtInfoViewSet       = RTM_VIEW_MASK_UCAST;
    RtInfo.dwRtInfoType          = MIB_IPROUTE_TYPE_DIRECT;
    RtInfo.dwRtInfoProto         = MIB_IPPROTO_LOCAL;
    RtInfo.dwRtInfoAge           = INFINITE;
    RtInfo.dwRtInfoNextHopAS     = 0;
    RtInfo.dwRtInfoPolicy        = 0;
        
    dwResult = AddSingleRoute(pIcb->dwIfIndex,
                              &RtInfo,
                              dwMask,
                              0,        // RTM_ROUTE_INFO::Flags
                              FALSE,    // Protocols dont like a bcast route
                              FALSE,    // No need to add to stack
                              bP2P,
                              NULL);                         
        
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "AddAutRoutes: Couldnt add all 1's bcast route for %d.%d.%d.%d",
               PRINT_IPADDR(dwAddress));
    }       
        
    //
    // We add the All Subnets Broadcast route if the class mask is different
    // from the subnet mask
    //

    dwClassMask = GetClassMask(dwAddress);

    if(dwClassMask isnot dwMask)
    {
        RtInfo.dwRtInfoDest      = (dwAddress | ~dwClassMask);
        RtInfo.dwRtInfoMask      = HOST_ROUTE_MASK;
        RtInfo.dwRtInfoNextHop   = dwAddress;
        RtInfo.dwRtInfoIfIndex   = pIcb->dwIfIndex;
        RtInfo.dwRtInfoMetric1   = 1;
        RtInfo.dwRtInfoMetric2   = 1;
        RtInfo.dwRtInfoMetric3   = 1;
        RtInfo.dwRtInfoPreference= ComputeRouteMetric(MIB_IPPROTO_LOCAL);
        RtInfo.dwRtInfoViewSet   = RTM_VIEW_MASK_UCAST |
                                      RTM_VIEW_MASK_MCAST; // XXX configurable
        RtInfo.dwRtInfoType      = MIB_IPROUTE_TYPE_DIRECT;
        RtInfo.dwRtInfoProto     = MIB_IPPROTO_LOCAL;
        RtInfo.dwRtInfoAge       = INFINITE;
        RtInfo.dwRtInfoNextHopAS = 0;
        RtInfo.dwRtInfoPolicy    = 0;
        
        dwResult = AddSingleRoute(pIcb->dwIfIndex,
                                  &RtInfo,
                                  dwMask,
                                  0,     // RTM_ROUTE_INFO::Flags
                                  FALSE, // Protocols dont like a bcast route
                                  FALSE, // No need to add to stack
                                  bP2P,
                                  NULL);
                       
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "AddAutoRoutes: Couldnt add all nets bcast route for %d.%d.%d.%d",
                   PRINT_IPADDR(dwAddress));
        }
    }
}


VOID
DeleteAutomaticRoutes(
    PICB    pIcb,
    DWORD   dwAddress,
    DWORD   dwMask
    )

/*++

Routine Description

    

Locks

    

Arguments

    

Return Value


--*/

{
    DWORD   dwClassMask, dwResult;
    BOOL    bP2P;

    
    if(dwAddress is INVALID_IP_ADDRESS)
    {
        IpRtAssert(FALSE);
    }

    return;
    
    bP2P = IsIfP2P(pIcb->ritType);
 
    //
    // Delete the loopback route we added
    //
    
    if(g_pLoopbackInterfaceCb)
    { 
        dwResult = DeleteSingleRoute(g_pLoopbackInterfaceCb->dwIfIndex, 
                                     dwAddress,
                                     HOST_ROUTE_MASK,    
                                     IP_LOOPBACK_ADDRESS,
                                     PROTO_IP_LOCAL,
                                     FALSE);
            
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAutoRoutes: Error %d deleting loopback route on %d.%d.%d.%d",
                   dwResult,
                   PRINT_IPADDR(dwAddress));
        }
    }

    //
    // Delete the multicast route
    //
    
    dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                 LOCAL_NET_MULTICAST,
                                 LOCAL_NET_MULTICAST_MASK,
                                 dwAddress,
                                 PROTO_IP_LOCAL,
                                 bP2P);
            
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "DeleteAutoRoutes: Error %d deleting 224.0.0.0 route on %d.%d.%d.%d",
               dwResult,
               PRINT_IPADDR(dwAddress));
    }

    if(dwMask isnot ALL_ONES_MASK)
    {
        //
        // Delete the network route we added
        //
           
        IpRtAssert(bP2P is FALSE);
 
        dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                     (dwAddress & dwMask),
                                     dwMask,
                                     dwAddress,
                                     PROTO_IP_LOCAL,
                                     bP2P);
            
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAutoRoutes: Error %d deleting subnet route for %d.%d.%d.%d",
                   dwResult,
                   PRINT_IPADDR(dwAddress));
        }
    }
    
    //
    // Delete the all nets bcast route
    //
    
    dwClassMask = GetClassMask(dwAddress);

    if(dwClassMask isnot dwMask)
    {
        dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                     (dwAddress | ~dwClassMask),
                                     HOST_ROUTE_MASK,
                                     dwAddress,
                                     PROTO_IP_LOCAL,
                                     bP2P);
            
        if(dwResult isnot NO_ERROR)
        {
            Trace2(ERR,
                   "DeleteAutoRoutes: Error %d deleting subnet bcast route on %x",
                   dwResult,
                   dwAddress);
        }

        //
        // Delete the all 1's bcast route
        //
    }

    dwResult = DeleteSingleRoute(pIcb->dwIfIndex,
                                 ALL_ONES_BROADCAST,
                                 HOST_ROUTE_MASK,
                                 dwAddress,
                                 PROTO_IP_LOCAL,
                                 bP2P);
            
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "DeleteAutoRoutes: Error %d deleting all 1's bcast route on %d.%d.%d.%d",
               dwResult,    
               PRINT_IPADDR(dwAddress));
    }
}

VOID
ChangeDefaultRouteMetrics(
    IN  BOOL    bIncrement
    )


/*++

Routine Description

    Increments or decrements the default route(s) metrics.
    For increment, it should be called BEFORE the default route for the
    dial out interface is added, and for decrement it should be called AFTER
    the dial out interface has been deleted

Locks

    Called with the ICB lock held. This ensures that two such operations
    are not being executed simultaneously (which would do the nasties to our
    route table)

Arguments

    bIncrement  TRUE if we need to increment the metric

Return Value

    None

--*/

{
    ULONG   i;
    DWORD   dwErr;

    RTM_NET_ADDRESS     NetAddress;
    PRTM_ROUTE_HANDLE   phRoutes;
    PRTM_ROUTE_INFO     pRouteInfo;
    RTM_DEST_INFO       DestInfo;
    RTM_ENUM_HANDLE     hEnum;

    ZeroMemory(&NetAddress,
               sizeof(NetAddress));

    __try
    {
        phRoutes   = 
            _alloca(sizeof(RTM_ROUTE_HANDLE) * g_rtmProfile.MaxHandlesInEnum);

        pRouteInfo = 
            _alloca(RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }
 
    //
    // Use any handle
    //

    dwErr = RtmGetExactMatchDestination(g_hLocalRoute,
                                        &NetAddress,
                                        RTM_BEST_PROTOCOL, // rather any
                                        RTM_VIEW_ID_UCAST,
                                        &DestInfo);

    if(dwErr isnot NO_ERROR)
    {
        return;
    }

    hEnum = NULL;

    dwErr =  RtmCreateRouteEnum(g_hLocalRoute,
                                DestInfo.DestHandle,
                                RTM_VIEW_ID_UCAST,
                                RTM_ENUM_ALL_ROUTES,
                                NULL,
                                RTM_MATCH_NONE,
                                NULL,
                                0,
                                &hEnum);

    if(dwErr isnot NO_ERROR)
    {
        RtmReleaseDestInfo(g_hLocalRoute,
                           &DestInfo);

        return;
    }

    do
    {
        RTM_ENTITY_HANDLE   hRtmHandle;
        ULONG               j, ulCount;

        ulCount = g_rtmProfile.MaxHandlesInEnum;

        dwErr = RtmGetEnumRoutes(g_hLocalRoute,
                                 hEnum,
                                 &ulCount,
                                 phRoutes);

        if(ulCount < 1)
        {
            break;
        }

        for(i = 0 ; i < ulCount; i++)
        {
            PRTM_ROUTE_INFO pRtmRoute;
            DWORD           dwFlags;
 
            dwErr = RtmGetRouteInfo(g_hLocalRoute,
                                    phRoutes[i],
                                    pRouteInfo,
                                    NULL);

            if(dwErr isnot NO_ERROR)
            {
                continue;
            }

            //
            // See if we are the owner of this route
            //

            hRtmHandle = NULL;

            for(j = 0; 
                j <  sizeof(g_rgRtmHandles)/sizeof(RTM_HANDLE_INFO);
                j++)
            {
                if(pRouteInfo->RouteOwner is g_rgRtmHandles[j].hRouteHandle)
                {
                    hRtmHandle = g_rgRtmHandles[j].hRouteHandle;

                    break;
                }
            }

            RtmReleaseRouteInfo(g_hLocalRoute,
                                pRouteInfo);

            if(hRtmHandle is NULL)
            {
                continue;
            }

            //
            // Lock the route (and re-read the info)
            //

            dwErr = RtmLockRoute(hRtmHandle,
                                 phRoutes[i],
                                 TRUE,
                                 TRUE,
                                 &pRtmRoute);

            if(dwErr isnot NO_ERROR)
            {
                continue;
            }
            
            //
            // If we have to decrease the metric and it is already 1,
            // let it be
            //

            if(!bIncrement)
            {
                if(pRtmRoute->PrefInfo.Metric <= 1)
                {
                    RtmLockRoute(hRtmHandle,
                                 phRoutes[i],
                                 TRUE,
                                 FALSE,
                                 NULL);
                    continue;
                }
            }

            //
            // Now update the route
            //

            if(bIncrement)
            {
                pRtmRoute->PrefInfo.Metric++;
            }
            else
            {
                pRtmRoute->PrefInfo.Metric--;
            }

            dwFlags = 0;

            dwErr = RtmUpdateAndUnlockRoute(hRtmHandle,
                                            phRoutes[i],
                                            INFINITE,
                                            NULL,
                                            0,
                                            NULL,
                                            &dwFlags);

            if(dwErr isnot NO_ERROR)
            {
                RtmLockRoute(hRtmHandle,
                             phRoutes[i],
                             TRUE,
                             FALSE,
                             NULL);
            }
        }

        RtmReleaseRoutes(g_hLocalRoute,
                         ulCount,
                         phRoutes);

    }while(TRUE);

    RtmDeleteEnumHandle(g_hLocalRoute,
                        hEnum);

    RtmReleaseDestInfo(g_hLocalRoute,
                       &DestInfo);

    return;
}

VOID
AddAllStackRoutes(
    PICB    pIcb
    )
    
/*++

Routine Description:

    This function picks up the default gateway and persistent routes
    that the stack may have added under the covers for this interface
    and adds them to RTM

Locks:

    ICB_LIST lock must be held as WRITER

Arguments:

    dwIfIndex   Interface index

Return Value:

    none

--*/

{
    DWORD   dwErr, dwMask, i;
    BOOL    bStack;
    
    PMIB_IPFORWARDTABLE pRouteTable;


    TraceEnter("AddAllStackRoutes");
    
    IpRtAssert(!IsIfP2P(pIcb->ritType));
    
    dwErr = AllocateAndGetIpForwardTableFromStack(&pRouteTable,
                                                  FALSE,
                                                  IPRouterHeap,
                                                  0);

    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "AddAllStackRoutes: Couldnt get initial routes. Error %d",
               dwErr);

        return;
    }

    for(i = 0; i < pRouteTable->dwNumEntries; i++)
    {
        if(pRouteTable->table[i].dwForwardIfIndex isnot pIcb->dwIfIndex)
        {
            //
            // Not going out over this interface
            //
            
            continue;
        }

#if 1

        //
        // Pick up only PROTO_IP_LOCAL and PROTO_IP_NETMGMT routes
        // from the IP stack
        //

        if((pRouteTable->table[i].dwForwardProto isnot PROTO_IP_LOCAL) and
           (pRouteTable->table[i].dwForwardProto isnot PROTO_IP_NETMGMT))
        {
            continue;
        }
        
#else
        if((pRouteTable->table[i].dwForwardProto isnot PROTO_IP_NT_STATIC_NON_DOD) and
           (pRouteTable->table[i].dwForwardDest isnot 0))
        {
            //
            // Only pick up default gateways and persistent routes
            //
            
            continue;
        }
#endif
        dwMask = GetBestNextHopMaskGivenICB(pIcb,
                                            pRouteTable->table[i].dwForwardDest);


        bStack = TRUE;
        
        if((pRouteTable->table[i].dwForwardProto is PROTO_IP_NETMGMT) &&
           (pRouteTable->table[i].dwForwardMask is HOST_ROUTE_MASK))
        {
            bStack = FALSE;
        }

        if(pRouteTable->table[i].dwForwardProto is PROTO_IP_LOCAL)
        {
            if((pRouteTable->table[i].dwForwardMask is HOST_ROUTE_MASK) 
                or
                ((pRouteTable->table[i].dwForwardDest &
                    ((DWORD) 0x000000FF)) >= ((DWORD) 0x000000E0))
                or
                (pRouteTable->table[i].dwForwardDest == 
                    (pRouteTable->table[i].dwForwardDest | 
                     ~pRouteTable->table[i].dwForwardMask)))
            {
                bStack = FALSE;
            }
        }
                    
        dwErr = AddSingleRoute(pIcb->dwIfIndex,
                               ConvertMibRouteToRouteInfo(&(pRouteTable->table[i])),
                               dwMask,
                               0,       // RTM_ROUTE_INFO::Flags
                               TRUE,    // Valid route
                               bStack,   // Do not add back to stack
                               FALSE,   // Only called for non P2P i/fs
                               NULL);
    }

    TraceLeave("AddAllStackRoutes");
    
    return;
}

VOID
UpdateDefaultRoutes(
    VOID
    )
{
    DWORD   dwErr, dwMask, i, j;
    BOOL    bFound;
    
    PMIB_IPFORWARDTABLE  pRouteTable;

    PINTERFACE_ROUTE_INFO pRtInfo;

    TraceEnter("UpdateDefaultRoutes");
    
    //
    // Get the routes in an ordered table
    //
    
    dwErr = AllocateAndGetIpForwardTableFromStack(&pRouteTable,
                                                  TRUE,
                                                  IPRouterHeap,
                                                  0);

    if(dwErr isnot NO_ERROR)
    {
        Trace1(ERR,
               "UpdateDefaultRoutes: Couldnt get routes. Error %d",
               dwErr);

        return;
    }

            
    //
    // Now add the dgs not already present
    //

    for(i = 0; i < pRouteTable->dwNumEntries; i++)
    {
        PICB    pIcb;

        TraceRoute2(
            ROUTE, "%d.%d.%d.%d/%d.%d.%d.%d",
            PRINT_IPADDR( pRouteTable-> table[i].dwForwardDest ),
            PRINT_IPADDR( pRouteTable-> table[i].dwForwardMask )
            );
        //
        // Once we get past the default routes, we are done
        //
        
        if(pRouteTable->table[i].dwForwardDest isnot 0)
        {
#if TRACE_DBG
            continue;
#else
            break;
#endif
        }

        if(pRouteTable->table[i].dwForwardIfIndex is INVALID_IF_INDEX)
        {
            continue;
        }

        if(pRouteTable->table[i].dwForwardProto isnot PROTO_IP_NETMGMT)
        {
            continue;
        }

        pIcb = InterfaceLookupByIfIndex(pRouteTable->table[i].dwForwardIfIndex);

        if(pIcb is NULL)
        {
            Trace1(ERR,
                   "UpdateDefaultRoutes: Couldnt get icb for %x",
                   pRouteTable->table[i].dwForwardIfIndex);

            continue;
        }

        //
        // Dont need to do this for p2p interfaces
        //

        if(IsIfP2P(pIcb->ritType))
        {
            continue;
        }

        dwMask = GetBestNextHopMaskGivenICB(pIcb,
                                            pRouteTable->table[i].dwForwardDest);
        Trace1(ROUTE,
               "UpdateDefaultRoutes: Adding default route over %S",
               pIcb->pwszName);

        dwErr = AddSingleRoute(pIcb->dwIfIndex,
                               ConvertMibRouteToRouteInfo(&(pRouteTable->table[i])),
                               dwMask,
                               0,       // RTM_ROUTE_INFO::Flags
                               TRUE,    // Valid route
                               TRUE,    // Add the route to stack
                               FALSE,   // Only called for non P2P i/fs
                               NULL);

        if(dwErr isnot NO_ERROR)
        {
            Trace3(ERR,
                   "UpdateDefaultRoutes: Error %d adding dg to %d.%d.%d.%d over %x",
                   dwErr,
                   PRINT_IPADDR(pRouteTable->table[i].dwForwardNextHop),
                   pRouteTable->table[i].dwForwardIfIndex);
        }
#if 0
        else
        {
            if(g_ulGatewayCount < g_ulGatewayMaxCount)
            {
                g_pGateways[g_ulGatewayCount].dwAddress =
                    pRouteTable->table[i].dwForwardNextHop;

                g_pGateways[g_ulGatewayCount].dwMetric =
                    pRouteTable->table[i].dwForwardMetric1;

                g_pGateways[g_ulGatewayCount].dwIfIndex =
                    pRouteTable->table[i].dwForwardIfIndex;

                g_ulGatewayCount++;
            }
            else
            {
                PGATEWAY_INFO   pNewGw;

                IpRtAssert(g_ulGatewayCount == g_ulGatewayMaxCount);

                pNewGw = HeapAlloc(IPRouterHeap,
                                   HEAP_ZERO_MEMORY,
                                   (g_ulGatewayMaxCount + 5) * sizeof(GATEWAY_INFO));

                if(pNewGw isnot NULL)
                {
                    g_ulGatewayMaxCount = g_ulGatewayMaxCount + 5;

                    for(j = 0; j < g_ulGatewayCount; j++)
                    {
                        pNewGw[j] = g_pGateways[j];
                    }

                    if(g_pGateways isnot NULL)
                    {
                        HeapFree(IPRouterHeap,
                                 0,
                                 g_pGateways);
                    }

                    g_pGateways = pNewGw;

                    g_pGateways[g_ulGatewayCount].dwAddress =
                        pRouteTable->table[i].dwForwardNextHop;

                    g_pGateways[g_ulGatewayCount].dwMetric =
                        pRouteTable->table[i].dwForwardMetric1;

                    g_pGateways[g_ulGatewayCount].dwIfIndex =
                        pRouteTable->table[i].dwForwardIfIndex;

                    g_ulGatewayCount++;
                }
            }
        }
#endif
    }

    HeapFree(IPRouterHeap,
             0,
             pRouteTable);

    TraceLeave("UpdateDefaultRoutes");
    
    return;
}


NTSTATUS
PostIoctlForRouteChangeNotification(
    DWORD   ulIndex
    )

/*++

Routine Description:

    This routine posts an IOCTL with the TCP/IP driver for route change
    notifications caused by addition of routes to the stack by entities
    other than Router Manager

Arguments:

    ulIndex -   Index into array of notifications indicating which one
                needs to be posted

Return Value

    STATUS_SUCCESS  -   Success

    NTSTATUS code   -   Otherwise

Environment:

--*/
{

    NTSTATUS    status;
    

    status = NtDeviceIoControlFile(
                g_hIpRouteChangeDevice,
                g_hRouteChangeEvents[ulIndex],
                NULL,
                NULL,
                &g_rgIpRouteNotifyOutput[ulIndex].ioStatus,
                IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX,
                &g_IpNotifyData,
                sizeof(IPNotifyData),
                &g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput,
                sizeof(IPRouteNotifyOutput)
                );
                
    if ((status isnot STATUS_SUCCESS) and
        (status isnot STATUS_PENDING))
    {
        Trace2(
            ERR,
            "Error 0x%x posting route change notification[%d]",
            status, ulIndex
            );
    }

    return status;
}


DWORD
HandleRouteChangeNotification(
    ULONG   ulIndex
    )
/*++

--*/
{
    DWORD   dwResult = NO_ERROR, dwFlags, dwClassMask;
    BOOL    bValid, bStack = FALSE;
    WORD    wRouteFlags = 0;
    INTERFACE_ROUTE_INFO RtInfo;
    PICB    pIcb;
    

    TraceEnter("HandleRouteChangeNotification");

    TraceRoute2(
        ROUTE, "Change for route to %d.%d.%d.%d/%d.%d.%d.%d",
        PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_dest),
        PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_mask)
        );        
        
    TraceRoute3(
        ROUTE, "Proto : %d, via i/f 0x%x, nexthop %d.%d.%d.%d",
        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_proto,
        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_ifindex,
        PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_nexthop)
        );

    TraceRoute2(
        ROUTE, "Metric : %d, Change : 0x%x",
        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_metric,
        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_flags
        );

    //
    // Update RTM route table as per route change indication
    //

    ENTER_READER(ICB_LIST);

    do
    {
        pIcb = InterfaceLookupByIfIndex(
                g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_ifindex
                );

        if (pIcb == NULL)
        {
            //
            // if there is no interface with the specified index in 
            // router manager, skip this route
            //
            
            Trace3(
                ERR,
                "Failed to add route to %d.%d.%d.%d/%d.%d.%d.%d."
                "Interface index %d not present with router manager",
                PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_dest),
                PRINT_IPADDR(g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_mask),
                g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_ifindex
                );

            break;
        }


        //
        // if route had been added to stack, add it to RTM
        //

        dwFlags = 
            g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_flags;

            
        ConvertRouteNotifyOutputToRouteInfo(
            &g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput,
            &RtInfo
            );

        if ((dwFlags is 0) or (dwFlags & IRNO_FLAG_ADD))
        {
            bValid = TRUE;
            
            if (RtInfo.dwRtInfoProto == PROTO_IP_LOCAL)
            {
                //
                // Set appropriate RTM flags for local routes
                //
                
                if (RtInfo.dwRtInfoNextHop == IP_LOOPBACK_ADDRESS)
                {
                    //
                    // Route over loopback.  Set MYSELF flag
                    //
                    
                    wRouteFlags = RTM_ROUTE_FLAGS_MYSELF;
                }

                else if ((RtInfo.dwRtInfoMask != HOST_ROUTE_MASK ) &&
                         ((RtInfo.dwRtInfoDest & RtInfo.dwRtInfoMask) < 
                            ((DWORD) 0x000000E0)))
                {
                    //
                    // RTM_ROUTE_FLAGS_LOCAL is set only for subnet 
                    // routes.  Not sure why this is so.  I am only
                    // preserving the semantics from AddAutomaticRoutes
                    // Either way the consequences are not drastic since
                    // this does not affect the IP forwarding table in 
                    // the stack.
                    //      - VRaman
                    //

                    //
                    // We arrive at the fact that this is a subnet route
                    // in a roundabout fashion by eliminating 
                    // PROTO_IP_LOCAL routes that are host routes and
                    // by eliminating any broadcast routes
                    //
                    // Since the host route check eliminates all routes
                    // with an all 1's mask, subnet/net broadcast routes
                    // are also eliminated.
                    //
                    
                    wRouteFlags = RTM_ROUTE_FLAGS_LOCAL;
                }


                //
                // mark mcast/bcast route as invalid so the protocols
                // do not advertize them
                //

                dwClassMask = GetClassMask(RtInfo.dwRtInfoDest);
                
                if ((RtInfo.dwRtInfoDest & (DWORD) 0x000000FF) >= 
                        ((DWORD) 0x000000E0) ||
                    (RtInfo.dwRtInfoDest == 
                        (RtInfo.dwRtInfoDest | ~dwClassMask)))
                {
                    bValid = FALSE;
                }

                else
                {
                    //
                    // For PROTO_IP_LOCAL we do not add them back to
                    // the stack since these are managed by the stack
                    // We add them to RTM only to keep the user mode 
                    // route table synchronized with the stack
                    //
                    //  On second thoughts, we do need to add them
                    //  back to the stack.  More accurately, we need to 
                    //  try and add them back to the stack.  This 
                    //  operation should fail, but as a side effect of 
                    //  this existing non PROTO_IP_LOCAL in the stack 
                    //  will be deleted.
                    //  This is required in case of local subnet 
                    //  routes.  It is possible that before an 
                    //  interface is enabled with IP, a route to the 
                    //  connected subnet may have been learnt over 
                    //  another interface via a routing protocol and
                    //  added to the stack.  When an interface is
                    //  enabled all previously added routes to the 
                    //  local subnet should be deleted if the 
                    //  PROTO_IP_LOCAL route is the best route (which
                    //  it should be unless you have a really wierd set 
                    //  of protocol preferences).  
                    //  Otherwise we run the risk of having non-best 
                    //  routes in the IP stack that are never deleted
                    //  when the user mode route corresponding to it is 
                    //  deleted since you do not get a route change 
                    //  notification for non-best routes.  The result is
                    //  that you end up with state routes in the stack
                    //

                    if (RtInfo.dwRtInfoMask != HOST_ROUTE_MASK)
                    {
                        bStack = TRUE;
                    }
                }
            }

            //
            // Routes learn't from the stack are normally not
            // added back to the stack.  Hence the bStack is
            // initialized to FALSE.
            //
            // PROTO_IP_NETMGT are not managed by the stack.  They
            // can be added/deleted/updated by user mode processes.
            // As consequence a NETMGT route learned from the stack
            // may be superseded by a route with a different protocol
            // ID e.g. static.  When the superseding route is deleted
            // the NETMGMT routes need to be restored to the stack.
            // Hence for NETMGMT routes we set bStack = true.
            //
            //  An exception the processing of NETMGMT routes are HOST routes 
            //  It is assumed by host routes added directly to the 
            //  stack are managed by the process adding/deleting them 
            //  e.g.RASIPCP
            //  They are added to RTM for sync. with the stack route table
            //  only.  So for these we set bStack = FALSE
            //
            //
            
            if ((RtInfo.dwRtInfoProto is PROTO_IP_NETMGMT) &&
                (RtInfo.dwRtInfoMask isnot HOST_ROUTE_MASK))
            {
                bStack = TRUE;
            }

            TraceRoute5(
                ROUTE, "NHOP mask %d.%d.%d.%d, Flag 0x%x, Valid %d, "
                "Stack %d, P2P %d", 
                PRINT_IPADDR(GetBestNextHopMaskGivenICB( 
                    pIcb, RtInfo.dwRtInfoNextHop)), 
                wRouteFlags,
                bValid,
                bStack,
                IsIfP2P(pIcb->ritType)
                );

            dwResult = AddSingleRoute(
                            RtInfo.dwRtInfoIfIndex,
                            &RtInfo,
                            GetBestNextHopMaskGivenICB(
                                pIcb, RtInfo.dwRtInfoNextHop
                                ),
                            wRouteFlags,
                            bValid,
                            bStack,
                            IsIfP2P(pIcb->ritType),
                            NULL
                            );
                            
            if (dwResult != NO_ERROR)
            {
                Trace2(
                    ERR, "HandleRouteChangeNotification: Failed to add "
                    "route %d.%d.%d.%d, error %d",
                    PRINT_IPADDR(RtInfo.dwRtInfoDest),
                    dwResult
                    );

                break;
            }
        }

        else if (dwFlags & IRNO_FLAG_DELETE)
        {
            dwResult = DeleteSingleRoute(
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_ifindex,
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_dest,
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_mask,
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_nexthop,
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_proto,
                        IsIfP2P(pIcb->ritType)
                        );
            
            if (dwResult != NO_ERROR)
            {
                Trace2(
                    ERR, "HandleRouteChangeNotification: Failed to" 
                    "delete route %d.%d.%d.%d, error %d",
                    PRINT_IPADDR(
                        g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_dest),
                    dwResult
                    );
                    
                break;
            }
        }

        else
        {
            Trace1(
                ERR, "HandleRouteChangeNotification: Invalid flags "
                "0x%x",
                g_rgIpRouteNotifyOutput[ulIndex].ipNotifyOutput.irno_flags
                );
                
            break;
        }
        
        if (RtInfo.dwRtInfoProto is PROTO_IP_NETMGMT)
        {
            UpdateStackRoutesToRestoreList( 
                ConvertRouteInfoToMibRoute( &RtInfo ),
                dwFlags 
                );
        }

    } while (FALSE);

    EXIT_LOCK(ICB_LIST);
    
    PostIoctlForRouteChangeNotification(ulIndex);
    
    TraceLeave("HandleRouteChangeNotification");

    return dwResult;
}


VOID
AddLoopbackRoute(
    DWORD       dwIfAddress,
    DWORD       dwIfMask
    )
{
    DWORD dwResult;
    INTERFACE_ROUTE_INFO rifRoute;
    MIB_IPFORWARDROW mibRoute;

    rifRoute.dwRtInfoMask       = HOST_ROUTE_MASK;
    rifRoute.dwRtInfoNextHop    = IP_LOOPBACK_ADDRESS;
    rifRoute.dwRtInfoDest       = dwIfAddress;
    rifRoute.dwRtInfoIfIndex    = g_pLoopbackInterfaceCb->dwIfIndex;
    rifRoute.dwRtInfoMetric2    = 0;
    rifRoute.dwRtInfoMetric3    = 0;
    rifRoute.dwRtInfoPreference = ComputeRouteMetric(MIB_IPPROTO_LOCAL);
    rifRoute.dwRtInfoViewSet    = RTM_VIEW_MASK_UCAST |
                                  RTM_VIEW_MASK_MCAST; // XXX config
    rifRoute.dwRtInfoType       = MIB_IPROUTE_TYPE_DIRECT;
    rifRoute.dwRtInfoProto      = MIB_IPPROTO_LOCAL;
    rifRoute.dwRtInfoAge        = 0;
    rifRoute.dwRtInfoNextHopAS  = 0;
    rifRoute.dwRtInfoPolicy     = 0;

    //
    // Query IP stack to verify for loopback route
    // corresponding to this binding
    //

    dwResult = GetBestRoute(
                    dwIfAddress,
                    0,
                    &mibRoute
                    );

    if(dwResult isnot NO_ERROR)
    {
        Trace2(
            ERR,
            "InitLoopIf: Stack query for loopback route" 
            " associated with %d.%d.%d.%d failed, error %d",
            PRINT_IPADDR(dwIfAddress),
            dwResult
            );

        return;
    }


    if (mibRoute.dwForwardIfIndex != 
            g_pLoopbackInterfaceCb->dwIfIndex)
    {
        //
        // There appears to be no loopback address 
        // very strange
        //
        
        Trace1(
            ERR,
            "InitLoopIf: No loopback route for %d.%d.%d.%d" 
            "in stack",
            PRINT_IPADDR(dwIfAddress)
            );

        return;
    }

    //
    // Use metric returned from stack.
    //
    
    rifRoute.dwRtInfoMetric1   = mibRoute.dwForwardMetric1;

    dwResult = AddSingleRoute(g_pLoopbackInterfaceCb->dwIfIndex,
                              &rifRoute,
                              dwIfMask,
                              0,    // RTM_ROUTE_INFO::Flags
                              TRUE,
                              FALSE,
                              FALSE,
                              NULL);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "InitLoopIf: Couldnt add 127.0.0.1 route associated with %x",
               dwIfAddress);
    }

    return;
}


VOID
UpdateStackRoutesToRestoreList(
    IN  PMIB_IPFORWARDROW   pmibRoute,
    IN  DWORD               dwFlags
    )
/*++

Routine Description:
    This routine adds/deletes PROTO_IP_NETMGMT routes to/from the global 
    list g_leStackRoutesToRestore.  This list is used by IP router 
    manager to restore routes these routes to the TCP/IP stack when it 
    is shutting down

Parameters
    pirf    - Route to be added or deleted
    dwFlags - Specifies whether the operation is add or delete

Return Value
    None

Context:
    Invoked from 
        HandleRouteChangeNotification 
        [Set/Delete]IpForwardRow
    
--*/
{
    BOOL                bFound;
    PROUTE_LIST_ENTRY   prl, prlNew;

    
    TraceEnter("UpdateStackRoutes");
    
    TraceRoute5(
        ROUTE,
        "UpdateStackRoutes : Route "
        "%d.%d.%d.%d/%d.%d.%d.%d via i/f 0x%x "
        "nexthop %d.%d.%d.%d is being 0x%x "
        "user mode",
        PRINT_IPADDR(pmibRoute->dwForwardDest),
        PRINT_IPADDR(pmibRoute->dwForwardMask),
        pmibRoute->dwForwardIfIndex,
        PRINT_IPADDR(pmibRoute->dwForwardNextHop),
        dwFlags
        );

    ENTER_WRITER(STACK_ROUTE_LIST);
    
    //
    // Locate route in list
    //

    bFound = LookupStackRoutesToRestoreList(
                pmibRoute,
                &prl
                );

    do
    {
        //
        // Is this a route update or add
        //
        
        if ((dwFlags is 0) or (dwFlags & IRNO_FLAG_ADD))
        {
            //
            //  if route is not found, add it
            //

            if (!bFound)
            {
                if (dwFlags is 0)
                {
                    //
                    // Strange that route is not around in
                    // user mode though it is present in the
                    // stack (update case).
                    //
                    // Print a trace to note this and add it
                    // anyway
                    //

                    Trace4(
                        ERR,
                        "UpdateStackRoutes : Route "
                        "%d.%d.%d.%d/%d.%d.%d.%d via i/f 0x%x "
                        "nexthop %d.%d.%d.%d not found in "
                        "user mode",
                        PRINT_IPADDR(pmibRoute->dwForwardDest),
                        PRINT_IPADDR(pmibRoute->dwForwardMask),
                        pmibRoute->dwForwardIfIndex,
                        PRINT_IPADDR(pmibRoute->dwForwardNextHop),
                        );
                }
                
                //
                // Allocate and store route in a linked list
                //

                prlNew = HeapAlloc(
                            IPRouterHeap, HEAP_ZERO_MEMORY, 
                            sizeof(ROUTE_LIST_ENTRY)
                            );

                if (prlNew is NULL)
                {
                    Trace2(
                        ERR, 
                        "UpdateStackRoutes : error %d allocating %d"
                        " bytes for stack route entry",
                        ERROR_NOT_ENOUGH_MEMORY,
                        sizeof(ROUTE_LIST_ENTRY)
                        );

                    break;
                }

                InitializeListHead( &prlNew->leRouteList );

                prlNew->mibRoute = *pmibRoute;

                InsertTailList( 
                    (prl is NULL) ? 
                        &g_leStackRoutesToRestore :
                        &prl->leRouteList, 
                    &prlNew->leRouteList 
                    );
                    
                break;
            }
            
            //
            // route is found, update it
            //

            prl->mibRoute = *pmibRoute;

            break;
        }


        //
        // Is this a route delete
        //

        if (dwFlags & IRNO_FLAG_DELETE)
        {
            if (bFound)
            {
                RemoveEntryList( &prl->leRouteList );
                HeapFree(IPRouterHeap, 0, prl);
            }
        }
        
    } while( FALSE );
    
    EXIT_LOCK(STACK_ROUTE_LIST);

    TraceLeave("UpdateStackRoutes");
}



BOOL
LookupStackRoutesToRestoreList(
    IN  PMIB_IPFORWARDROW   pmibRoute,
    OUT PROUTE_LIST_ENTRY   *pRoute
    )
/*++

Routine Description:
    This routine searches g_leStackRoutesToRestore to determine if the 
    route specified by pmibRoute is present.  If it is it returns TRUE 
    and a pointer to the specified route in pRoute.  If is not present 
    FALSE is returned along with a pointer to the next route in list.  
    If there are no routes, pRoute is NULL

Parameters
    pmibRoute   - Route to locate in g_leStackRoutesToRestore
    pRoute      - Pointer to the route entry if present
                - Pointer to the next route entry if not present
                  (save additional lookups in case of route entry 
                   additions)
                - NULL if list is empty

Return Value:
    TRUE    - if route found
    FALSE   - otherwise


Context:
    Should be called with the lock for g_leStackRoutesToRestore
--*/
{
    INT iCmp;
    BOOL bFound = FALSE;
    PLIST_ENTRY ple;
    PROUTE_LIST_ENTRY prl;

    *pRoute = NULL;
    
    if (IsListEmpty(&g_leStackRoutesToRestore))
    {
        return bFound;
    }
    
    for (ple = g_leStackRoutesToRestore.Flink;
         ple != &g_leStackRoutesToRestore;
         ple = ple->Flink)
    {
        prl = CONTAINING_RECORD( 
                ple, ROUTE_LIST_ENTRY, leRouteList
                );

        if (INET_CMP(
                prl->mibRoute.dwForwardDest &
                prl->mibRoute.dwForwardMask,
                pmibRoute->dwForwardDest &
                pmibRoute->dwForwardMask,
                iCmp
                ) < 0 )
        {
            continue;
        }

        else if (iCmp > 0)
        {
            //
            // we have gone past the possible location
            // of the specified route
            //

            break;
        }

        //
        // found a matching dest, check if the i/f is
        // the same.
        //

        if ((prl->mibRoute.dwForwardIfIndex is 
                pmibRoute->dwForwardIfIndex ) and
            (prl->mibRoute.dwForwardNextHop is
                pmibRoute->dwForwardNextHop))
        {
            bFound = TRUE;
            break;
        }
    }

    if (ple == &g_leStackRoutesToRestore)
    {
        *pRoute = (PROUTE_LIST_ENTRY)NULL;
    }

    else
    {
        *pRoute = prl;
    }
    
    return bFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\protodll.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\protodll.c

Abstract:
    Routines for managing protocol DLLs

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#include "allinc.h"


DWORD
LoadProtocol(
    IN MPR_PROTOCOL_0  *pmpProtocolInfo,
    IN PPROTO_CB       pProtocolCb,
    IN PVOID           pvInfo,
    IN ULONG           ulStructureVersion,
    IN ULONG           ulStructureSize,
    IN ULONG           ulStructureCount
    )

/*++

Routine Description:

    Loads the DLL for a routing protocol. Initializes the entry points in 
    the CB

Locks:

      
Arguments:

    pszDllName      Name of DLL of the routing protocol
    pProtocolCb     Pointer to CB to hold info for this protocol
    pGlobalInfo     GlobalInfo (from which the info for this protocol is 
                    extracted)
      
Return Value:

    NO_ERROR or some error code

--*/

{
    DWORD           dwResult,dwNumStructs, dwSupport;
    PVOID           pInfo;
    HINSTANCE       hModule;
    PRTR_TOC_ENTRY  pToc;

    PREGISTER_PROTOCOL          pfnRegisterProtocol;
    MPR_ROUTING_CHARACTERISTICS mrcRouting;
    MPR_SERVICE_CHARACTERISTICS mscService;

    TraceEnter("LoadProtocol");
    
    Trace1(GLOBAL,
           "LoadProtocol: Loading %S",
           pmpProtocolInfo->wszProtocol); 

#if IA64
    if ( pmpProtocolInfo-> dwProtocolId == PROTO_IP_OSPF )
    {
        Trace1(
            ERR,
            "Protocol %S not supported on 64 bit",
            pmpProtocolInfo-> wszProtocol
            );

        return ERROR_NOT_SUPPORTED;
    }

#endif 


    //
    // Loading all entrypoints
    //
    
    hModule = LoadLibraryW(pmpProtocolInfo->wszDLLName);
    
    if(hModule is NULL) 
    {
        dwResult = GetLastError();

        Trace2(ERR, "LoadProtocol: %S failed to load: %d\n", 
               pmpProtocolInfo->wszDLLName,
               dwResult);

        return dwResult;
    }
        
    pProtocolCb->hiHInstance  = hModule;
    pProtocolCb->dwProtocolId = pmpProtocolInfo->dwProtocolId;

    pfnRegisterProtocol = NULL;

    pfnRegisterProtocol =
        (PREGISTER_PROTOCOL)GetProcAddress(hModule,
                                           REGISTER_PROTOCOL_ENTRY_POINT_STRING);

    if(pfnRegisterProtocol is NULL)
    {
        //
        // Could not find the RegisterProtocol entry point
        // Nothing we can do - bail out
        //

        Sleep(0);
        
        FreeLibrary(hModule);

        Trace1(ERR, "LoadProtocol: Could not find RegisterProtocol for %S", 
               pmpProtocolInfo->wszDLLName);

        return ERROR_INVALID_FUNCTION;
    }
        
    //
    // Give a chance for the protocol to register itself
    //

    //
    // Zero out the memory so that protocols with older versions
    // still work
    //

    ZeroMemory(&mrcRouting,
               sizeof(MPR_ROUTING_CHARACTERISTICS));

    mrcRouting.dwVersion                = MS_ROUTER_VERSION;
    mrcRouting.dwProtocolId             = pmpProtocolInfo->dwProtocolId;

#define __CURRENT_FUNCTIONALITY         \
            RF_ROUTING |                \
            RF_DEMAND_UPDATE_ROUTES |   \
            RF_ADD_ALL_INTERFACES |     \
            RF_MULTICAST |              \
            RF_POWER

    mrcRouting.fSupportedFunctionality  = (__CURRENT_FUNCTIONALITY);

    //
    // We dont support any service related stuff
    //

    mscService.dwVersion                = MS_ROUTER_VERSION;
    mscService.dwProtocolId             = pmpProtocolInfo->dwProtocolId;
    mscService.fSupportedFunctionality  = 0;

    dwResult = pfnRegisterProtocol(&mrcRouting,
                                   &mscService);

    if(dwResult isnot NO_ERROR)
    {
        Sleep(0);
        
        FreeLibrary(hModule);

        pProtocolCb->hiHInstance = NULL;
        
        Trace2(ERR, "LoadProtocol: %S returned error %d while registering", 
               pmpProtocolInfo->wszDLLName,
               dwResult);

        return dwResult;
    }

    if(mrcRouting.dwVersion > MS_ROUTER_VERSION)
    {
        Trace3(ERR,
               "LoadProtocol: %S registered with version 0x%x. Our version is 0x%x\n", 
               pmpProtocolInfo->wszProtocol,
               mrcRouting.dwVersion,
               MS_ROUTER_VERSION);

        //
        // relenquish CPU to enable DLL threads to finish
        //

        Sleep(0);

        FreeLibrary(hModule);

        return ERROR_CAN_NOT_COMPLETE;
    }
    
    if(mrcRouting.dwProtocolId isnot pmpProtocolInfo->dwProtocolId)
    {
        //
        // protocol tried to change IDs on us
        //

        Trace3(ERR,
               "LoadProtocol: %S returned ID of %x when it should be %x",
               pmpProtocolInfo->wszProtocol,
               mrcRouting.dwProtocolId,
               pmpProtocolInfo->dwProtocolId);

        Sleep(0);

        FreeLibrary(hModule);

        return ERROR_CAN_NOT_COMPLETE;
    }


    if(mrcRouting.fSupportedFunctionality & ~(__CURRENT_FUNCTIONALITY))
    {
        //
        // Hmm, some functionality that we dont understand
        //

        Trace3(ERR,
               "LoadProtocol: %S wanted functionalitf %x when we have %x",
               pmpProtocolInfo->wszProtocol,
               mrcRouting.fSupportedFunctionality,
               (__CURRENT_FUNCTIONALITY));

        Sleep(0);

        FreeLibrary(hModule);

        return ERROR_CAN_NOT_COMPLETE;
    }

#undef __CURRENT_FUNCTIONALITY

    if(!(mrcRouting.fSupportedFunctionality & RF_ROUTING))
    {
        Trace1(ERR, 
               "LoadProtocol: %S doesnt support routing", 
               pmpProtocolInfo->wszProtocol);

        //
        // relenquish CPU to enable DLL threads to finish
        //
        
        Sleep(0);
        
        FreeLibrary(hModule);

        return ERROR_CAN_NOT_COMPLETE;
    }

    pProtocolCb->fSupportedFunctionality = mrcRouting.fSupportedFunctionality;

    pProtocolCb->pfnStartProtocol   = mrcRouting.pfnStartProtocol;
    pProtocolCb->pfnStartComplete   = mrcRouting.pfnStartComplete;
    pProtocolCb->pfnStopProtocol    = mrcRouting.pfnStopProtocol;
    pProtocolCb->pfnGetGlobalInfo   = mrcRouting.pfnGetGlobalInfo;
    pProtocolCb->pfnSetGlobalInfo   = mrcRouting.pfnSetGlobalInfo;
    pProtocolCb->pfnQueryPower      = mrcRouting.pfnQueryPower;
    pProtocolCb->pfnSetPower        = mrcRouting.pfnSetPower;

    pProtocolCb->pfnAddInterface      = mrcRouting.pfnAddInterface;
    pProtocolCb->pfnDeleteInterface   = mrcRouting.pfnDeleteInterface;
    pProtocolCb->pfnInterfaceStatus   = mrcRouting.pfnInterfaceStatus;
    pProtocolCb->pfnGetInterfaceInfo  = mrcRouting.pfnGetInterfaceInfo;
    pProtocolCb->pfnSetInterfaceInfo  = mrcRouting.pfnSetInterfaceInfo;

    pProtocolCb->pfnGetEventMessage   = mrcRouting.pfnGetEventMessage;

    pProtocolCb->pfnUpdateRoutes      = mrcRouting.pfnUpdateRoutes;

    pProtocolCb->pfnConnectClient     = mrcRouting.pfnConnectClient;
    pProtocolCb->pfnDisconnectClient  = mrcRouting.pfnDisconnectClient;

    pProtocolCb->pfnGetNeighbors      = mrcRouting.pfnGetNeighbors;
    pProtocolCb->pfnGetMfeStatus      = mrcRouting.pfnGetMfeStatus;

    pProtocolCb->pfnMibCreateEntry    = mrcRouting.pfnMibCreateEntry;
    pProtocolCb->pfnMibDeleteEntry    = mrcRouting.pfnMibDeleteEntry;
    pProtocolCb->pfnMibGetEntry       = mrcRouting.pfnMibGetEntry;
    pProtocolCb->pfnMibSetEntry       = mrcRouting.pfnMibSetEntry;
    pProtocolCb->pfnMibGetFirstEntry  = mrcRouting.pfnMibGetFirstEntry;
    pProtocolCb->pfnMibGetNextEntry   = mrcRouting.pfnMibGetNextEntry;



    if(!(pProtocolCb->pfnStartProtocol) or
       !(pProtocolCb->pfnStartComplete) or
       !(pProtocolCb->pfnStopProtocol) or
       !(pProtocolCb->pfnGetGlobalInfo) or
       !(pProtocolCb->pfnSetGlobalInfo) or
    //   !(pProtocolCb->pfnQueryPower) or
    //   !(pProtocolCb->pfnSetPower) or
       !(pProtocolCb->pfnAddInterface) or
       !(pProtocolCb->pfnDeleteInterface) or
       !(pProtocolCb->pfnInterfaceStatus) or
       !(pProtocolCb->pfnGetInterfaceInfo) or
       !(pProtocolCb->pfnSetInterfaceInfo) or
       !(pProtocolCb->pfnGetEventMessage) or
    //   !(pProtocolCb->pfnConnectClient) or
    //   !(pProtocolCb->pfnDisconnectClient) or
    //   !(pProtocolCb->pfnGetNeighbors) or
    //   !(pProtocolCb->pfnGetMfeStatus) or
       !(pProtocolCb->pfnMibCreateEntry) or
       !(pProtocolCb->pfnMibDeleteEntry) or
       !(pProtocolCb->pfnMibGetEntry) or
       !(pProtocolCb->pfnMibSetEntry) or
       !(pProtocolCb->pfnMibGetFirstEntry) or
       !(pProtocolCb->pfnMibGetNextEntry))
    {
        Trace1(ERR, 
               "LoadProtocol: %S failed to provide atleast one entrypoint\n", 
               pmpProtocolInfo->wszProtocol);

        //
        // relenquish CPU to enable DLL threads to finish
        //
        
        Sleep(0);
        
        FreeLibrary(hModule);

        pProtocolCb->hiHInstance = NULL;
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    if(mrcRouting.fSupportedFunctionality & RF_DEMAND_UPDATE_ROUTES)
    {
        if(!pProtocolCb->pfnUpdateRoutes)
        {
            Trace1(ERR, 
                   "LoadProtocol: %S supports DEMAND but has no entry point", 
                   pmpProtocolInfo->wszProtocol);

            //
            // relenquish CPU to enable DLL threads to finish
            //
        
            Sleep(0);
        
            FreeLibrary(hModule);

            pProtocolCb->hiHInstance = NULL;
        
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    if(mrcRouting.fSupportedFunctionality & RF_MULTICAST)
    {
        DWORD   dwType;

        //
        // Make sure it has a good ID
        //

        dwType = TYPE_FROM_PROTO_ID(mrcRouting.dwProtocolId);

        if(dwType isnot PROTO_TYPE_MCAST)
        {
           Trace2(ERR,
                  "LoadProtocol: %S supports MCAST but has an id of %x",
                  pmpProtocolInfo->wszProtocol,
                  mrcRouting.dwProtocolId);

           //
           // relenquish CPU to enable DLL threads to finish
           //

           Sleep(0);

           FreeLibrary(hModule);

           pProtocolCb->hiHInstance = NULL;

           return ERROR_CAN_NOT_COMPLETE;
        }
    }

    pProtocolCb->pwszDllName = (PWCHAR)((PBYTE)pProtocolCb + sizeof(PROTO_CB));
                
    CopyMemory(pProtocolCb->pwszDllName,
               pmpProtocolInfo->wszDLLName,
               (wcslen(pmpProtocolInfo->wszDLLName) * sizeof(WCHAR))) ;

    pProtocolCb->pwszDllName[wcslen(pmpProtocolInfo->wszDLLName)] = 
        UNICODE_NULL;
    
    //
    // The memory for display name starts after the DLL name storage
    //
    
    pProtocolCb->pwszDisplayName = 
        &(pProtocolCb->pwszDllName[wcslen(pmpProtocolInfo->wszDLLName) + 1]);
                
    CopyMemory(pProtocolCb->pwszDisplayName,
               pmpProtocolInfo->wszProtocol,
               (wcslen(pmpProtocolInfo->wszProtocol) * sizeof(WCHAR))) ;
    
    pProtocolCb->pwszDisplayName[wcslen(pmpProtocolInfo->wszProtocol)] = 
        UNICODE_NULL;


    dwResult = (pProtocolCb->pfnStartProtocol)(g_hRoutingProtocolEvent, 
                                               &g_sfnDimFunctions,
                                               pvInfo,
                                               ulStructureVersion,
                                               ulStructureSize,
                                               ulStructureCount);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR, 
               "LoadProtocol: %S failed to start: %d\n", 
               pmpProtocolInfo->wszProtocol,
               dwResult);

        //
        // relenquish CPU to enable DLL threads to finish
        //
        
        Sleep(0);
        
        FreeLibrary(hModule);

        return dwResult;
    } 

    Trace1(GLOBAL,
           "LoadProtocol: Loaded %S successfully",
           pmpProtocolInfo->wszProtocol);
    
    return NO_ERROR;
}

DWORD
HandleRoutingProtocolNotification(
    VOID
    )

/*++

Routine Description:     

    For all routing protocol initiated events - this routine calls the
    routing protocol to service the event.

Locks:


Arguments:

    None

Return Value:

    NO_ERROR or some error code

--*/

{
    ROUTING_PROTOCOL_EVENTS               routprotevent ;
    MESSAGE             result ;
    PPROTO_CB  protptr ;
    PLIST_ENTRY         currentlist ;

    TraceEnter("HandleRoutingProtocolNotification");

    //
    // We take the ICBListLock because we want to enforce the discipline of 
    // taking the ICB lock before the RoutingProtocol lock if both need to 
    // be taken. 
    // This is to avoid deadlocks.
    //
    
    //
    // TBD: Avoid calling out from our DLL while holding the locks exclusively
    //
    
    // *** Exclusion Begin ***
    ENTER_WRITER(ICB_LIST);

    // *** Exclusion Begin ***
    ENTER_WRITER(PROTOCOL_CB_LIST);
    
    currentlist = g_leProtoCbList.Flink;
    
    while(currentlist != &g_leProtoCbList)
    {
        protptr = CONTAINING_RECORD (currentlist, PROTO_CB, leList) ;
	
        //
        // drain all messages for this protocol
        //
        
        while ((protptr->pfnGetEventMessage) (&routprotevent, &result) == NO_ERROR) 
        {
            switch (routprotevent)  
            {
                case SAVE_GLOBAL_CONFIG_INFO:

                    ProcessSaveGlobalConfigInfo() ;
                    break ;
                
                case SAVE_INTERFACE_CONFIG_INFO:
                
                    ProcessSaveInterfaceConfigInfo (result.InterfaceIndex) ;
                    break ;
                
                case UPDATE_COMPLETE:
                
                    ProcessUpdateComplete(protptr, 
                                          &result.UpdateCompleteMessage) ;
                    break ;
                
                case ROUTER_STOPPED:
                
                    protptr->posOpState = RTR_STATE_STOPPED ;
                    break ;
                
                default:

                    // no event raised for this protocol.
                    break;
            }
        }
        
        //
        // Move to the next item before freeing this one. The most common 
        // error in the book
        //
        
        currentlist = currentlist->Flink;
        
        if(protptr->posOpState is RTR_STATE_STOPPED)
        {
            //
            // Something happened that caused the stopping of the protocol
            //
            
            RemoveProtocolFromAllInterfaces(protptr);
                
            //
            // relenquish CPU to enable DLL threads to finish
            //
        
            Sleep(0);
        
            FreeLibrary(protptr->hiHInstance);
            
            //
            // Move to the next entry before freeing this entry
            //
            
            RemoveEntryList(&(protptr->leList));
            
            HeapFree(IPRouterHeap, 
                     0, 
                     protptr);
            
            TotalRoutingProtocols--;
        }
    }

    // *** Exclusion End ***
    EXIT_LOCK(PROTOCOL_CB_LIST);

    // *** Exclusion End ***
    EXIT_LOCK(ICB_LIST);

    return NO_ERROR;
}

VOID
NotifyRoutingProtocolsToStop(
    VOID
    )

/*++

Routine Description:

    Notifies routing protocols to stop

Locks:

    Must be called with the ICB_LIST lock held as READER and PROTOCOL_CB_LIST
    held as WRITER
      
Arguments:

    None

Return Value:

    None

--*/

{
    PLIST_ENTRY currentlist ;
    PPROTO_CB  protptr ;
    DWORD       dwResult;
    
    TraceEnter("NotifyRoutingProtocolsToStop");

    //
    // Go thru the routing protocol list and call stopprotocol() for each 
    // of them
    //
    
    currentlist = g_leProtoCbList.Flink; 
    
    while(currentlist isnot &g_leProtoCbList)
    {
        protptr = CONTAINING_RECORD (currentlist, PROTO_CB, leList) ;
        
        if((protptr->posOpState is RTR_STATE_STOPPING) or
           (protptr->posOpState is RTR_STATE_STOPPED))
        {
            //
            // If its stopped or stopping, we dont tell it again
            //
            
            continue;
        }
        
        dwResult = StopRoutingProtocol(protptr);
        
        currentlist = currentlist->Flink;
        
        if(dwResult is NO_ERROR)
        {
            //
            // The routing protocol stopped synchronously and all references
            // to it in the interfaces have been removed
            //
            
            //
            // relenquish CPU to enable DLL threads to finish
            //
        
            Sleep(0);
        
            FreeLibrary(protptr->hiHInstance);
            
            RemoveEntryList(&(protptr->leList));
            
            HeapFree(IPRouterHeap, 
                     0, 
                     protptr);
            
            TotalRoutingProtocols--;
        }
    }
}

DWORD
StopRoutingProtocol(
    PPROTO_CB  pProtocolCB
    )

/*++

Routine Description:

    Stops a routing protocol

Arguments:

    pProtocolCB      The CB of the routing protocol to stop

Locks:



Return Value:

    NO_ERROR                     If the routing protocol stopped synchronously
    ERROR_PROTOCOL_STOP_PENDING  If the protocol is stopping asynchronously
    other WIN32 code

--*/ 

{
    DWORD dwResult;

    TraceEnter("StopRoutingProtocol");
    
    Trace1(GLOBAL,
           "StopRoutingProtocol: Stopping %S",
           pProtocolCB->pwszDllName);

    RemoveProtocolFromAllInterfaces(pProtocolCB);
    
    dwResult = (pProtocolCB->pfnStopProtocol)();
        
    if(dwResult is ERROR_PROTOCOL_STOP_PENDING)
    {
        //
        // If the protocol stops asynchronously then we dont do any clean up
        // right now. We it signals us that it has stopped, we will do the
        // necessary clean up
        //
        
        Trace1(GLOBAL,
               "StopRoutingProtocol: %S will stop asynchronously",
               pProtocolCB->pwszDllName);
        
        pProtocolCB->posOpState = RTR_STATE_STOPPING;
    }
    else
    {
        if(dwResult is NO_ERROR)
        {
            //
            // Great. So it stopped synchronously.
            //
            
            Trace1(GLOBAL,
                   "StopRoutingProtocol: %S stopped synchronously",
                   pProtocolCB->pwszDllName);
    
            pProtocolCB->posOpState = RTR_STATE_STOPPED ;
        }
        else
        {
            //
            // This is not good. Routing Protocol couldnt stop
            //
            
            Trace2(ERR,
                   "StopRoutingProtocol: %S returned error %d on calling StopProtocol().",
                   pProtocolCB->pwszDllName,
                   dwResult);
        }
    }

    return dwResult;
}

VOID
RemoveProtocolFromAllInterfaces(
    PPROTO_CB  pProtocolCB
    )

/*++

Routine Description:

    Each interface keeps a list of the protocols that are running on it. 
    This removes the given protocol from all the interfaces list

Locks:


Arguments:

    pProtocolCB      The CB of the routing protocol to remove

Return Value:

    None

--*/

{
    
    PLIST_ENTRY pleIfNode,pleProtoNode;
    PICB        pIcb;
    PIF_PROTO   pProto;

    TraceEnter("RemoveProtocolFromAllInterfaces");
    
    Trace1(GLOBAL,
           "RemoveProtocolFromAllInterfaces: Removing %S from all interfaces",
           pProtocolCB->pwszDllName);
    
    //
    // For each interface, we go through the list of protocols it is active
    // over. If the interface had been active over this protocol, we remove the
    // entry from the i/f's list
    //
    
    for(pleIfNode = ICBList.Flink;
        pleIfNode isnot &ICBList;
        pleIfNode = pleIfNode->Flink)
    {
        pIcb = CONTAINING_RECORD(pleIfNode, ICB, leIfLink);
        
        pleProtoNode = pIcb->leProtocolList.Flink;
        
        while(pleProtoNode isnot &(pIcb->leProtocolList))
        {
            pProto = CONTAINING_RECORD(pleProtoNode,IF_PROTO,leIfProtoLink);
            
            pleProtoNode = pleProtoNode->Flink;

            if(pProto->pActiveProto is pProtocolCB)
            {
                Trace2(GLOBAL,
                       "RemoveProtocolFromAllInterfaces: Removing %S from %S",
                       pProtocolCB->pwszDllName,
                       pIcb->pwszName);
               
                //
                // call the delete interface entry point
                //

                (pProto->pActiveProto->pfnDeleteInterface) (pIcb->dwIfIndex);
 
                RemoveEntryList(&(pProto->leIfProtoLink));
                
                break;
            }
        }
    }

}


BOOL
AllRoutingProtocolsStopped(
    VOID
    )

/*++

Routine Description:

    Walks thru all routing protocols to see if all have operational state 
    of STOPPED.

Locks:



Arguments:

    None

Return Value:

    TRUE if all stopped, otherwise FALSE

--*/

{
    DWORD       routprotevent ;
    PPROTO_CB  protptr ;
    PLIST_ENTRY  currentlist ;

    TraceEnter("AllRoutingProtocolsStopped");

    for (currentlist = g_leProtoCbList.Flink; 
         currentlist != &g_leProtoCbList; 
         currentlist = currentlist->Flink) 
    {
        
        protptr = CONTAINING_RECORD (currentlist, PROTO_CB, leList) ;

        if (protptr->posOpState != RTR_STATE_STOPPED)
        {
            Trace1(GLOBAL,
                   "AllRoutingProtocolsStopped: %S has not stopped as yet",
                   protptr->pwszDllName);
            
            return FALSE;
        }
    }

    return TRUE ;
}

DWORD
ProcessUpdateComplete (
    PPROTO_CB       proutprot, 
    UPDATE_COMPLETE_MESSAGE  *updateresult
    )
{
    PLIST_ENTRY  currentlist ;
    LPHANDLE     hDIMEventToSignal = NULL;
    PICB pIcb ;
    UpdateResultList *pupdateresultlist ;
    
    TraceEnter("ProcessUpdateComplete");
    
    //
    // If update is successful convert the protocol's routes to static routes.
    //
    
    if (updateresult->UpdateStatus == NO_ERROR)
    {
        ConvertRoutesToAutoStatic(proutprot->dwProtocolId, 
                                  updateresult->InterfaceIndex);

    }
    
    //
    // Figure out which event to signal and where to queue the event
    //
    
    for (currentlist = ICBList.Flink;
         currentlist != &ICBList; 
         currentlist = currentlist->Flink) 
    {
        pIcb = CONTAINING_RECORD (currentlist, ICB, leIfLink);
      
        if (pIcb->dwIfIndex is updateresult->InterfaceIndex)
        {
            hDIMEventToSignal = pIcb->hDIMNotificationEvent;
            
            pIcb->hDIMNotificationEvent = NULL;

            if(hDIMEventToSignal is NULL)
            {
                Trace0(ERR, "ProcessUpdateComplete: No DIM event found in ICB - ERROR");

                return ERROR_CAN_NOT_COMPLETE;
            }
            
            //
            // Queue the update event
            //
            
            pupdateresultlist = HeapAlloc(IPRouterHeap, 
                                          HEAP_ZERO_MEMORY, 
                                          sizeof(UpdateResultList));
           
            if(pupdateresultlist is NULL)
            {
                Trace1(ERR,
                       "ProcessUpdateComplete: Error allocating %d bytes",
                       sizeof(UpdateResultList));

                SetEvent(hDIMEventToSignal);

                CloseHandle(hDIMEventToSignal);

                return ERROR_NOT_ENOUGH_MEMORY;
            }
 
            pupdateresultlist->URL_UpdateStatus = updateresult->UpdateStatus;
            
            InsertTailList(&pIcb->lePendingResultList, 
                           &pupdateresultlist->URL_List) ;
            
            //
            // Save the routes in the registry
            //
           
            ProcessSaveInterfaceConfigInfo(pIcb->dwIfIndex);

            Trace0(GLOBAL, 
                   "ProcessUpdateComplete: Notifying DIM of update route completion");
            
            if(!SetEvent(hDIMEventToSignal))
            {
                Trace2(ERR,
                       "ProcessUpdateComplete: Error %d setting event for notifying completion of update routes for %S",
                       proutprot->pwszDllName,  
                       GetLastError());

                CloseHandle(hDIMEventToSignal);
 
                return ERROR_CAN_NOT_COMPLETE;
            }

            CloseHandle(hDIMEventToSignal);

            return NO_ERROR;
        }

    }
    
    //
    // If you reach till here you didnt find the ICB
    //
    
    Trace1(ERR,
           "ProcessUpdateComplete: Couldnt find the ICB for interface %d",
           updateresult->InterfaceIndex);

    return ERROR_INVALID_PARAMETER;
}

DWORD
ProcessSaveInterfaceConfigInfo(
    DWORD dwInterfaceindex
    )
{
    PICB            pIcb ;
    DWORD           infosize;
    PVOID           pinfobuffer ;
    PLIST_ENTRY     currentlist ;
    BOOL            bFound = FALSE;
    DWORD           dwNumInFilters, dwNumOutFilters;
    
    TraceEnter("ProcessSaveInterfaceConfigInfo");

    //
    // find the if.
    //
    
    for (currentlist = ICBList.Flink;
         currentlist != &ICBList;
         currentlist = currentlist->Flink)
    {

        pIcb = CONTAINING_RECORD (currentlist, ICB, leIfLink);

        if (pIcb->dwIfIndex is dwInterfaceindex)
        {
            bFound = TRUE;
            
            break;
        }
    }

    if(!bFound)
    {
        Trace1(ERR,
               "ProcessSaveInterfaceConfigInfo: Couldnt find ICB for interface %d",
               dwInterfaceindex);

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Interface info
    //
    
    infosize = GetSizeOfInterfaceConfig(pIcb);

    pinfobuffer  = HeapAlloc(IPRouterHeap, 
                             HEAP_ZERO_MEMORY, 
                             infosize);

    if(pinfobuffer is NULL)
    {
        Trace0(
            ERR, "ProcessSaveInterfaceConfigInfo: failed to allocate buffer");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    GetInterfaceConfiguration(pIcb, 
                              pinfobuffer, 
                              infosize);


    EXIT_LOCK(PROTOCOL_CB_LIST);
    EXIT_LOCK(ICB_LIST);

    SaveInterfaceInfo(pIcb->hDIMHandle,
                      PID_IP,
                      pinfobuffer,
                      infosize );

    ENTER_WRITER(ICB_LIST);
    ENTER_WRITER(PROTOCOL_CB_LIST);

    HeapFree (IPRouterHeap, 0, pinfobuffer) ;

    return NO_ERROR;
}

DWORD
ProcessSaveGlobalConfigInfo(
    VOID
    )
{
    PRTR_INFO_BLOCK_HEADER  pInfoHdrAndBuffer;
    DWORD                   dwSize,dwResult;

    TraceEnter("ProcessSaveGlobalConfigInfo");
    
    dwSize = GetSizeOfGlobalInfo();  

    pInfoHdrAndBuffer = HeapAlloc(IPRouterHeap,
                                  HEAP_ZERO_MEMORY,
                                  dwSize);

    if(pInfoHdrAndBuffer is NULL) 
    {
        Trace1(ERR,
               "ProcessSaveGlobalConfigInfo: Error allocating %d bytes",
               dwSize);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    dwResult = GetGlobalConfiguration(pInfoHdrAndBuffer,
                                      dwSize);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "ProcessSaveGlobalConfigInfo: Error %d getting global configuration",
               dwResult);
    }
    else
    {

        EXIT_LOCK(PROTOCOL_CB_LIST);
        EXIT_LOCK(ICB_LIST);

        dwResult = SaveGlobalInfo(PID_IP,
                                  (PVOID)pInfoHdrAndBuffer,
                                  dwSize);

        ENTER_WRITER(ICB_LIST);
        ENTER_WRITER(PROTOCOL_CB_LIST);

        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "ProcessSaveGlobalConfigInfo: Error %d saving global information",
                   dwResult);
        }
    }
    
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\rtmif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\init.c

Abstract:

    IP Router Manager code

Revision History:

    Gurdeep Singh Pall          6/14/95  Created

--*/

#include "allinc.h"


// ChangeRouteWithForwarder()
//
//  Function: If addroute is TRUE this function adds an IP route. If addroute is FALSE
//            this function deletes the given route with the forwarder.
//
//  Returns:  Nothing
//
//

DWORD
ChangeRouteWithForwarder(
    PRTM_NET_ADDRESS pDestAddr,
    PRTM_ROUTE_INFO  pRoute,
    BOOL             bAddRoute,
    BOOL             bDelOld
    )
{
    IPMultihopRouteEntry           *pMultiRouteEntry;
    IPRouteEntry                   *pRouteEntry;
    IPRouteNextHopEntry            *pNexthopEntry;
    RTM_ENTITY_INFO                 entityInfo;
    RTM_NEXTHOP_INFO                nhiInfo;
    PADAPTER_INFO                   pBinding;
    UINT                            numnexthops, i;
    ULONG                           numbytes;
    DWORD                           dwAddr, dwMask;
    UINT                            dwLen;
    ULONG                           ifindex, nexthop, type;
    BOOL                            bValidNHop;
    DWORD                           context;
    DWORD                           dwLocalNet, dwLocalMask;
    DWORD                           dwResult;

    TraceEnter("ChangeRouteWithForwarder");

    if(!g_bSetRoutesToStack)
    {
        Trace0(ROUTE,
               "ChangeRouteWithForwarder: SetRoutesToStack is FALSE");

        TraceLeave("ChangeRouteWithForwarder");
        
        return NO_ERROR;
    }


    if (bAddRoute)
    {
        //
        // Ensure that the stack bit is set
        //

        if (!pRoute || !IsRouteStack(pRoute))
        {
            if (!pRoute )
            {
                Trace0(ROUTE,
                    "Error adding route, route == NULL"
                    );
            }
            
            else 
            {
                Trace1(ROUTE,
                    "Error adding route, Stack bit == %d",
                    IsRouteStack(pRoute)
                    );
            }

            TraceLeave("ChangeRouteWithForwarder");
            
            return ERROR_INVALID_PARAMETER;
        }


        // We should have atleast one nexthop
        numnexthops = pRoute->NextHopsList.NumNextHops;
        if (numnexthops == 0)
        {
            Trace0(ROUTE,
                "Error adding route, no nexthops");

            TraceLeave("ChangeRouteWithForwarder");
            
            return ERROR_INVALID_PARAMETER;
        }

        numbytes = sizeof(IPMultihopRouteEntry) + 
                    (numnexthops - 1) * 
                    sizeof(IPRouteNextHopEntry);
    }
    else
    {
        //
        // for routes to be deleted, they should be stack
        // routes
        //

        // We do not have any next hops here
        numbytes = sizeof(IPMultihopRouteEntry);
    }

    __try
    {    
        pMultiRouteEntry = _alloca(numbytes);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRouteEntry = &pMultiRouteEntry->imre_routeinfo;

    //
    // Fill the dest and mask for the current route
    //

    RTM_IPV4_GET_ADDR_AND_LEN(pRouteEntry->ire_dest,
                              dwLen,
                              pDestAddr);
    
    pRouteEntry->ire_mask = RTM_IPV4_MASK_FROM_LEN(dwLen);

    TraceRoute2(ROUTE,
           "route to %d.%d.%d.%d/%d.%d.%d.%d",
               PRINT_IPADDR(pRouteEntry->ire_dest),
               PRINT_IPADDR(pRouteEntry->ire_mask));

    if (!bAddRoute)
    {    
        //
        // Prepare to delete old information on dest
        //
    
        pRouteEntry->ire_type = IRE_TYPE_INVALID;

        pMultiRouteEntry->imre_numnexthops = 0;

        Trace2(ROUTE,
               "ChangeRouteWithForwarder: Deleting all " \
               "routes to %d.%d.%d.%d/%d.%d.%d.%d",
               PRINT_IPADDR(pRouteEntry->ire_dest),
               PRINT_IPADDR(pRouteEntry->ire_mask));

        dwResult = SetIpMultihopRouteEntryToStack(pMultiRouteEntry);

        TraceLeave("ChangeRouteWithForwarder");
            
        return dwResult;
    }


    //
    // Get the routing protocol of the route's owner
    //
    
    dwResult = RtmGetEntityInfo(g_hLocalRoute,
                                pRoute->RouteOwner,
                                &entityInfo);

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ROUTE,
               "Error %d retrieving entity info from RTM",
               dwResult);
               
        TraceLeave("ChangeRouteWithForwarder");
        
        return dwResult;
    }

    //
    // Prepare to add a multihop route on this dest
    //

    // Prepare information common to all nexthops

    pRouteEntry->ire_proto = entityInfo.EntityId.EntityProtocolId;
    pRouteEntry->ire_metric1 = pRoute->PrefInfo.Metric;
    pRouteEntry->ire_metric2 = IRE_METRIC_UNUSED;
    pRouteEntry->ire_metric3 = IRE_METRIC_UNUSED;
    pRouteEntry->ire_metric4 = IRE_METRIC_UNUSED;
    pRouteEntry->ire_metric5 = IRE_METRIC_UNUSED;
    pRouteEntry->ire_age = 0;

    numnexthops = 0;
    
    for (i = 0; i < pRoute->NextHopsList.NumNextHops; i++)
    {
        // Get and release next hop info as we got a copy
    
        dwResult = RtmGetNextHopInfo(g_hLocalRoute,
                                     pRoute->NextHopsList.NextHops[i],
                                     &nhiInfo);

        if (dwResult isnot NO_ERROR)
        {
            Trace1(ROUTE,
                   "Error %d retrieving next hop info from RTM",
                    dwResult);
                    
            continue;
        }
        
        RtmReleaseNextHopInfo(g_hLocalRoute, &nhiInfo);

        // Get the next hop address from the nexthop info

        RTM_IPV4_GET_ADDR_AND_LEN(nexthop,
                                  dwLen,
                                  &nhiInfo.NextHopAddress);

        TraceRoute3(
            ROUTE, "Next Hop %d.%d.%d.%d, If 0x%x, handle is 0x%x", 
            PRINT_IPADDR(nexthop),
            nhiInfo.InterfaceIndex,
            pRoute->NextHopsList.NextHops[i]
            );
    
        ENTER_READER(BINDING_LIST);
    
        //
        // find the binding given the interface id
        //
    
        pBinding = GetInterfaceBinding(nhiInfo.InterfaceIndex);
    
        if(!(pBinding))
        {
            //
            // The interface was deleted so lets just get out
            //
        
            EXIT_LOCK(BINDING_LIST);
        
            TraceRoute2(ERR,
               "**Warning** tried to %s route with interface %d which "
               "is no longer present",
               bAddRoute?"add":"delete",
               nhiInfo.InterfaceIndex);

            continue;
        }

        //
        // set adapter index - this is 0xffffffff
        // if the nexthop interface is not MAPPED
        //

        ifindex = pBinding->bBound ? pBinding->dwIfIndex : INVALID_IF_INDEX;
       
        if(((pRouteEntry->ire_proto is PROTO_IP_NT_STATIC) or
            (pRouteEntry->ire_proto is PROTO_IP_NT_AUTOSTATIC)) and
           (pBinding->ritType is ROUTER_IF_TYPE_FULL_ROUTER))
        {
            context = pBinding->dwSeqNumber;

            TraceRoute1(ROUTE,
                   "route context : ICB == %d\n\n",
                   pBinding->dwSeqNumber);
        }
        else
        {
            context = 0;

            if(ifindex is INVALID_IF_INDEX)
            {
                Trace3(ERR,
                       "**Error** Tried to %s route to %d.%d.%d.%d over %d as DOD\n",
                        bAddRoute?"add":"delete",
                        PRINT_IPADDR(pRouteEntry->ire_dest),
                        pBinding->dwIfIndex);

                EXIT_LOCK(BINDING_LIST);

                continue;
            }
        }

        //
        // First we figure out the correct nexthop for p2p links
        // For all other links, we take the whatever is given to us
        //

        if(IsIfP2P(pBinding->ritType))
        {
            if(pBinding->bBound)
            {
                TraceRoute2(
                    ROUTE, "Next Hop %d.%d.%d.%d, remote address %d.%d.%d.%d, "
                    "bound p2p",
                    PRINT_IPADDR(nexthop),
                    PRINT_IPADDR(pBinding->dwRemoteAddress)
                    );
                    
                if (nexthop is 0)
                {
                    nexthop = pBinding->dwRemoteAddress;
                }
            }
            else
            {
                nexthop = 0;
            }
        }

        //
        // Now we figure out if the route is a direct route or indirect routes
        // Routes over unconnected demand dial routes are marked OTHER
        //

        //
        // For connected WAN interfaces (P2P with mask of 255.255.255.255) we 
        // do two checks:
        // The next hop should be local address or remote address.
        //      AR: We used to do the above check but removed it because when 
        //          we set a route over a disconnected interface, we dont
        //          know the address of the remote endpoint
        // If the dest is remote address, then the MASK must be all ONES
        // We mark all valid routes as DIRECT
        //
        
        //
        // For LAN interfaces and WAN with non all ones mask, we check the 
        // following:
        // A direct route to a host must have the Destination as the NextHop
        // A direct route to a network must have the the NextHop as one of the 
        // local interfaces
        // The next hop must be on the same subnet as one of the bindings
        //

        type = IRE_TYPE_OTHER;

        if(pBinding->bBound)
        {
            if((pBinding->dwNumAddresses is 1) and
               (pBinding->rgibBinding[0].dwMask is ALL_ONES_MASK))
            {
                //
                // route over P2P link or P2MP link, possibly unnumbered.
                //
         
                if(((pBinding->dwRemoteAddress isnot 0) and
                    (pRouteEntry->ire_dest is pBinding->dwRemoteAddress)) or
                   (pRouteEntry->ire_dest is nexthop))
                {
                    type = IRE_TYPE_DIRECT;
                }
                else
                {
                    type = IRE_TYPE_INDIRECT;
                }
            }
            else
            {
                //
                // A route over a non P2P link or a bay style p2p link which
                // has a /30 mask
                //

                bValidNHop = FALSE;
            
                type = IRE_TYPE_INDIRECT;

                for(i = 0; i < pBinding->dwNumAddresses; i++)
                {
                    dwLocalMask = pBinding->rgibBinding[i].dwMask;
                    
                    dwLocalNet = pBinding->rgibBinding[i].dwAddress & dwLocalMask;

                    if((dwLocalNet is (pRouteEntry->ire_dest & dwLocalMask)) or
                       (nexthop is IP_LOOPBACK_ADDRESS) or
                       (nexthop is pBinding->rgibBinding[i].dwAddress))
                    {
                        //
                        // Route to local net or over loopback
                        //
                    
                        type = IRE_TYPE_DIRECT;
                    }

                    if(((nexthop & dwLocalMask) is dwLocalNet) or
                       ((nexthop is IP_LOOPBACK_ADDRESS)))
                    {
                        //
                        // Next hop is on local net or loopback
                        // That is good
                        //

                        bValidNHop = TRUE;

                        break;                
                    }
                }
            
                if(!bValidNHop and 
                   (pBinding->dwNumAddresses isnot 0) and
                   (pBinding->ritType isnot ROUTER_IF_TYPE_INTERNAL))
                {
                    Trace0(ERR,
                       "ERROR - Nexthop not on same network");
                
                    for(i = 0; i < pBinding->dwNumAddresses; i ++)
                    {
                        Trace3(ROUTE,"AdapterId: %d, %d.%d.%d.%d/%d.%d.%d.%d",
                               pBinding->dwIfIndex,
                               PRINT_IPADDR(pBinding->rgibBinding[i].dwAddress),
                               PRINT_IPADDR(pBinding->rgibBinding[i].dwMask));
                    }

                    EXIT_LOCK(BINDING_LIST);
                

                    // PrintRoute(ERR, ipRoute);

                    continue;
                }
            }
        }

        EXIT_LOCK(BINDING_LIST);

#if 0
        // DGT workaround for bug where stack won't accept
        // nexthop of 0.0.0.0.  Until Chait fixes this, we'll
        // set nexthop to the ifindex.

        if (!nexthop) 
        {
            nexthop = ifindex;
        }
#endif

        //
        // Fill the current nexthop info into the route
        //
        
        if (numnexthops)
        {
            // Copy to the next posn in the route
            pNexthopEntry = 
                &pMultiRouteEntry->imre_morenexthops[numnexthops - 1];

            pNexthopEntry->ine_iretype = type;
            pNexthopEntry->ine_ifindex = ifindex;
            pNexthopEntry->ine_nexthop = nexthop;
            pNexthopEntry->ine_context = context;
        }
        else
        {
            // Copy to the first posn in the route
            pRouteEntry->ire_type    = type;
            pRouteEntry->ire_index   = ifindex;
            pRouteEntry->ire_nexthop = nexthop;
            pRouteEntry->ire_context = context;
        }

        numnexthops++;
    }

    pMultiRouteEntry->imre_numnexthops = numnexthops;
    pMultiRouteEntry->imre_flags = bDelOld ? IMRE_FLAG_DELETE_DEST : 0;
    
    if (numnexthops > 0)
    {
        dwResult = SetIpMultihopRouteEntryToStack(pMultiRouteEntry);

        if(dwResult isnot NO_ERROR) 
        {
            if(pRouteEntry->ire_nexthop != IP_LOOPBACK_ADDRESS)
            {
                Trace1(ERR, 
                       "Route addition failed with %x for", dwResult); 

                PrintRoute(ERR, pMultiRouteEntry);
            }

            Trace1(ERR, 
                   "Route addition failed with %x for local route", dwResult); 

            TraceLeave("ChangeRouteWithForwarder");

            return dwResult;
        }
        else
        {
            Trace0(ROUTE,
                   "Route addition succeeded for");

            PrintRoute(ROUTE, pMultiRouteEntry);
        }
    }

    else
    {
        Trace0(ERR, "Route not added since there are no next hops" );

        PrintRoute(ROUTE, pMultiRouteEntry);
    }

    TraceLeave("ChangeRouteWithForwarder");
    
    return NO_ERROR;
}


DWORD
WINAPI
ValidateRouteForProtocol(
    IN  DWORD   dwProtoId,
    IN  PVOID   pRouteInfo,
    IN  PVOID   pDestAddr  OPTIONAL
    )

/*++

Routine Description:

    This function is called by the router Manger (and indirectly by routing 
    protocols) to validate the route info. We set the preference and the 
    type of the route

Locks:

    Acquires the binding lock
    This function CAN NOT acquire the ICB lock

Arguments:

    dwProtoId   Protocols Id
    pRoute

Return Value:

    NO_ERROR
    RtmError code

--*/

{
    RTM_DEST_INFO    destInfo;
    PRTM_ROUTE_INFO  pRoute;
    RTM_NEXTHOP_INFO nextHop;
    PADAPTER_INFO    pBinding;
    HANDLE           hNextHop;
    BOOL             bValidNHop;
    DWORD            dwIfIndex;
    DWORD            dwLocalNet;
    DWORD            dwLocalMask;
    DWORD            destAddr;
    DWORD            destMask;
    DWORD            nexthop;
    DWORD            nhopMask;
    DWORD            dwType;
    DWORD            dwResult;
    UINT             i, j;

    pRoute = (PRTM_ROUTE_INFO)pRouteInfo;

    if (pRoute->PrefInfo.Preference is 0)
    {
        //
        // Map the metric weight based on the weight assigned by admin
        //
    
        pRoute->PrefInfo.Preference = ComputeRouteMetric(dwProtoId);
    }

    //
    // This validation applies to the unicast routes only.
    // [ This does not apply to INACTIVE routes and such ]
    //

    if (!(pRoute->BelongsToViews & RTM_VIEW_MASK_UCAST))
    {
        return NO_ERROR;
    }

    //
    // Get the destination address if it is not specified
    //
    
    if (!ARGUMENT_PRESENT(pDestAddr))
    {
        //
        // Get the destination information from the route
        //
    
        dwResult = RtmGetDestInfo(g_hLocalRoute,
                                  pRoute->DestHandle,
                                  RTM_BEST_PROTOCOL,
                                  RTM_VIEW_MASK_UCAST,
                                  &destInfo);

        if (dwResult != NO_ERROR)
        {
            Trace0(ERR,
                   "**ERROR:ValidateRoute: Invalid destination");
                   
            return dwResult;
        }

        pDestAddr = &destInfo.DestAddress;

        RtmReleaseDestInfo(g_hLocalRoute, &destInfo);
    }

    RTM_IPV4_GET_ADDR_AND_MASK(destAddr, 
                               destMask, 
                               (PRTM_NET_ADDRESS)pDestAddr);

    //
    // If the dest&Mask != dest then the stack will not set this route
    // Hence lets do the check here
    //

    if((destAddr & destMask) isnot destAddr)
    {

#if TRACE_DBG

        Trace2(ROUTE,
               "**ERROR:ValidateRoute: called with Dest %d.%d.%d.%d and Mask %d.%d.%d.%d - This will fail**",
               PRINT_IPADDR(destAddr),
               PRINT_IPADDR(destMask));

#endif // TRACE_DBG

        return ERROR_INVALID_PARAMETER;
    }
   
    if((((DWORD)(destAddr & 0x000000FF)) >= (DWORD)0x000000E0) and 
       (destAddr isnot ALL_ONES_BROADCAST) and
       (destAddr isnot LOCAL_NET_MULTICAST))
    {
        //
        // This will catch the CLASS D/E but allow all 1's bcast
        //

        Trace1(ERR,
               "**ERROR:ValidateRoute: Dest %d.%d.%d.%d is invalid",
               PRINT_IPADDR(destAddr));

        return ERROR_INVALID_PARAMETER;
    } 

#if 0
    // Removed this since metric=0 is legal for routes to the loopback
    // interface.
    if(pRoute->PrefInfo.Metric is 0)
    {
        Trace0(ERR,
               "**ERROR:ValidateRoute: Metric cant be 0");

        return ERROR_INVALID_PARAMETER;
    }
#endif

    if (pRoute->NextHopsList.NumNextHops == 0)
    {
        Trace0(ERR,
               "**ERROR:ValidateRoute: Zero next hops");

        return ERROR_INVALID_PARAMETER;
    }

    // Make sure each next hop on the route is a valid one

    for (i = 0; i < pRoute->NextHopsList.NumNextHops; i++)
    {
        hNextHop = pRoute->NextHopsList.NextHops[i];

        dwResult = RtmGetNextHopInfo(g_hLocalRoute,
                                     hNextHop,
                                     &nextHop);

        if (dwResult != NO_ERROR)
        {
            Trace0(ERR,
                   "**ERROR:ValidateRoute: Invalid next hop");
                   
            return dwResult;
        }

        dwIfIndex = nextHop.InterfaceIndex;

        RTM_IPV4_GET_ADDR_AND_MASK(nexthop, 
                                   nhopMask, 
                                   (PRTM_NET_ADDRESS)&nextHop.NextHopAddress);

        RtmReleaseNextHopInfo(g_hLocalRoute, &nextHop);
        
        // *** Exclusion Begin ***
        ENTER_READER(BINDING_LIST);
        
        //
        // find the interface given the interface id
        //
        
        pBinding = GetInterfaceBinding(dwIfIndex);
        
        if(!pBinding)
        {
            EXIT_LOCK(BINDING_LIST);

#if TRACE_DBG

            Trace0(ERR,
                   "**ERROR:ValidateRoute: Interface block doesnt exist");

#endif // TRACE_DBG

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Set whether the route is P2P
        //

        if(IsIfP2P(pBinding->ritType))
        {
            // Note that in the multihop case, we just overwrite value
            SetRouteP2P(pRoute);
            /*
            ipRoute->RR_NextHopAddress.N_NetNumber = 
                           RtlUlongByteSwap(pBinding->dwIfIndex);

            ipRoute->RR_NextHopAddress.N_NetMask = ALL_ONES_MASK;
            */
        }

        /*
        //
        // If the next hop mask is not set, we need to do so now.  Normally 
        // this shouldnt  happen
        //

#if ROUTE_DBG

        if(!(ipRoute->RR_NextHopAddress.N_NetMask))
        {
           Trace0(ERR,
                  "**WARNING:Route doesnt seem to have any next hop mask**");
        }

#endif  // ROUTE_DBG
        */

        //
        // Now we figure out if the route is a direct route or indirect routes
        // Routes over unconnected demand dial routes are marked OTHER
        //

        //
        // For connected WAN interfaces (P2P with mask of 255.255.255.255) we 
        // do two checks:
        // The next hop should be local address or remote address.
        //      AR: We used to do the above check but removed it because when 
        //          we set a route over a disconnected interface, we dont
        //          know the address of the remote endpoint
        // If the dest is remote address, then the MASK must be all ONES
        // We mark all valid routes as DIRECT
        //
        
        //
        // For LAN interfaces and WAN with non all ones mask, we check the 
        // following:
        // A direct route to a host to must have the Destination as the NextHop
        // A direct route to a network to must have the the NextHop as one of the 
        // local interfaces
        // The next hop must be on the same subnet as one of the bindings
        //

        dwType = IRE_TYPE_OTHER;
        
        if(pBinding->bBound and IsRouteValid(pRoute))
        {
            //
            // Comment this block out - as we validate this
            // next hop for the LAN case below, and dont care
            // what it is in the WAN case as we set it to 0.
            //
            /*
            //
            // So outgoing interface has a valid address
            // and next hop should have been plumbed in
            //
            if(nexthop && (destAddr is nexthop))
            {
                //
                // A direct host route
                //
                
                if(destMask isnot HOST_ROUTE_MASK)
                {
                    EXIT_LOCK(BINDING_LIST);
                    
                    Trace0(ERR,
                           "ValidateRoute: Host route with wrong mask");

                    return ERROR_INVALID_PARAMETER;
                }
            
                dwType = IRE_TYPE_DIRECT;
            }
            */

            if((pBinding->dwNumAddresses is 1) and
               (pBinding->rgibBinding[0].dwMask is ALL_ONES_MASK))
            {
                //
                // route over P2P link. 
                // Set it to indirect and mark it as a P2P route
                //
               
                dwType = IRE_TYPE_DIRECT;

                //IpRtAssert(IsRouteP2P(pRoute));
            }
            else
            {
                //
                // A route over a non P2P link possibly unnumbered
                //

                bValidNHop = FALSE;
                
                dwType = IRE_TYPE_INDIRECT;

                for(j = 0; j < pBinding->dwNumAddresses; j++)
                {
                    dwLocalMask = pBinding->rgibBinding[j].dwMask;

                    dwLocalNet = pBinding->rgibBinding[j].dwAddress & dwLocalMask;

                    if((dwLocalNet is (destAddr & dwLocalMask)) or
                       (nexthop is IP_LOOPBACK_ADDRESS) or
                       //(nexthop is dwLocalNet) or
                       (nexthop is pBinding->rgibBinding[i].dwAddress))
                    {
                        //
                        // Route to local net or over loopback
                        //
                    
                        dwType = IRE_TYPE_DIRECT;
                    }

                    if(((nexthop & dwLocalMask) is dwLocalNet) or
                       ((nexthop is IP_LOOPBACK_ADDRESS)))
                    {
                        //
                        // Next hop is on local net or loopback
                        // That is good
                        //

                        bValidNHop = TRUE;

                        break;
                        
                    }
                }
                
                if(!bValidNHop and 
                   pBinding->dwNumAddresses and
                   (pBinding->ritType isnot ROUTER_IF_TYPE_INTERNAL))
                {
                    Trace1(ERR,
                           "ValidateRoute: Nexthop %d.%d.%d.%d not on network",
                           PRINT_IPADDR(nexthop));
                    
                    for(j = 0; j < pBinding->dwNumAddresses; j++)
                    {
                        Trace3(ROUTE,"AdapterId: %d, %d.%d.%d.%d/%d.%d.%d.%d",
                               pBinding->dwIfIndex,
                               PRINT_IPADDR(pBinding->rgibBinding[j].dwAddress),
                               PRINT_IPADDR(pBinding->rgibBinding[j].dwMask));
                    }

                    EXIT_LOCK(BINDING_LIST);
                    
                    return ERROR_INVALID_PARAMETER;
                }
            }
        }

        /*
#if ROUTE_DBG

        if(ipRoute->RR_NextHopAddress.N_NetMask isnot dwLocalMask)
        {
            Trace0(ERR,
                   "**WARNING:Route doesnt seem to have the right next hop mask**");

            PrintRoute(ERR,ipRoute);

            ipRoute->RR_NextHopAddress.N_NetMask = dwLocalMask;
        }

#endif // ROUTE_DBG    
        */

        // *** Exclusion End ***
        EXIT_LOCK(BINDING_LIST);
    }

    //
    // Set the appropriate route flags in the route - stack flag etc.
    //

    // pRoute->Flags1 |= IP_STACK_ROUTE;

    g_LastUpdateTable[IPFORWARDCACHE] = 0;

    return NO_ERROR;
}


DWORD
WINAPI
ValidateRouteForProtocolEx(
    IN  DWORD   dwProtoId,
    IN  PVOID   pRouteInfo,
    IN  PVOID   pDestAddr  OPTIONAL
    )
    
/*++

Routine Description:

    This function is called by the router Manger (and indirectly by routing 
    protocols) to validate the route info. We set the preference and the 
    type of the route

Locks:

    Acquires the binding lock
    This function CAN NOT acquire the ICB lock

Arguments:

    dwProtoId   Protocols Id
    pRoute

Return Value:

    NO_ERROR
    RtmError code

--*/
{
    DWORD dwResult;

    dwResult = ValidateRouteForProtocol(
                    dwProtoId,
                    pRouteInfo,
                    pDestAddr
                    );

    if (dwResult is NO_ERROR)
    {
        ((PRTM_ROUTE_INFO)pRouteInfo)->Flags1 |= IP_STACK_ROUTE;
    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\rtmops.c ===
#include "allinc.h"

DWORD
RtmEventCallback (
     IN     RTM_ENTITY_HANDLE               hRtmHandle,
     IN     RTM_EVENT_TYPE                  retEvent,
     IN     PVOID                           pContext1,
     IN     PVOID                           pContext2
     )

/*++

Routine Description:

    This callback is given by RTM when we have changed dests
    to process. We just queue a work item to process changed
    destinations.

Arguments:

    hRtmHandle      -   Handle that we got during registration
    
    retEvent        -   Event type - we only handle events of
                        type "more changes available" for now
    
    pContext1       -   Notification handle on which changes
                        are available

    pContext2       -   Context supplied during notification
                        registration time
    
Return Value:

    Status of the operation.
    
--*/

{
    DWORD   dwResult;
    
    // Only "change notifications available" is supported
    
    if (retEvent != RTM_CHANGE_NOTIFICATION)
    {
        return ERROR_NOT_SUPPORTED;
    }

    return ((HANDLE) pContext1) == g_hNotification ?
            ProcessChanges(g_hNotification) :
            ProcessDefaultRouteChanges( g_hDefaultRouteNotification );
}


DWORD
WINAPI
ProcessChanges (
    IN      HANDLE                          hNotifyHandle
    )

/*++

Routine Description:

    Upon learning that  we have changed destinations to 
    process, this function gets called. We retrieve all
    destinations to process and take appropriate action.

Arguments:

    hRtmHandle      - RTM registration handle
    
    hNotifyHandle   - Handle correponding to the change notification 
                      that is being signalled
    
Return Value:

    Status of the operation.
    
--*/

{
    PRTM_DEST_INFO  pDestInfo;
    PRTM_ROUTE_INFO pRouteInfo;
    DWORD           dwDests;
    DWORD           dwResult;
    BOOL            bMark = FALSE;


    TraceEnter("ProcessChanges");

    pRouteInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );

    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR, "ProcessChanges : error allocating %d bytes for "
            "route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );

        TraceLeave("ProcessChanges");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    pDestInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                    );

    if (pDestInfo == NULL)
    {
        Trace1(
            ERR, "ProcessChanges : error allocating %d bytes for "
            "dest. info",
            RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
            );

        HeapFree(IPRouterHeap, 0, pRouteInfo);
        
        TraceLeave("ProcessChanges");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwDests = 1;
    
    // Get each changed dest from the table

    do
    {
        RtmGetChangedDests(g_hLocalRoute,
                           hNotifyHandle,
                           &dwDests,
                           pDestInfo);
        if (dwDests < 1)
        {
            break;
        }

        //
        // For default routes, mark the route so that future changes
        // are managed by ProcessDefaultRouteChanges.
        //
        // We need to do this here so that default routes added by
        // routing protocols RIP/OSPF are marked for change notification
        // These default routes are added by entities other than 
        // RouterManager.  Default routes added by RM i.e STATIC, 
        // AUTO-STATIC and NETMGMT default routes are already marked for
        // change notification when they are added by RM.
        //
        // By marking routing protocol default routes here we make sure
        // that all default routes are subsequently handled by marked changed 
        // mechanism (ProcessDefaultRouteChanges).
        //
        
        if (pDestInfo->DestAddress.NumBits is 0)
        {
            TraceRoute2(
                ROUTE, "Checking dest %d.%d.%d.%d/%d is marked", 
                PRINT_IPADDR(*(ULONG *)pDestInfo->DestAddress.AddrBits),
                PRINT_IPADDR(pDestInfo->DestAddress.NumBits)
                );

            dwResult = RtmIsMarkedForChangeNotification(
                        g_hNetMgmtRoute,
                        g_hDefaultRouteNotification,
                        pDestInfo->DestHandle,
                        &bMark
                        );

            if (dwResult is NO_ERROR)
            {
                if (bMark)
                {
                    //
                    // default route is already marked, nothing further
                    // to do here.  This default route change will be
                    // handled by ProcessDefaultRouteChanges
                    //

                    TraceRoute0( 
                        ROUTE, 
                        "ProcessChanges : Route 0/0 is already marked"
                        );

                    RtmReleaseChangedDests(g_hLocalRoute,
                                           hNotifyHandle,
                                           dwDests,
                                           pDestInfo);

                    continue;
                }

                //
                // Default route is not marked, mark it
                //

                dwResult = RtmMarkDestForChangeNotification(
                            g_hNetMgmtRoute,
                            g_hDefaultRouteNotification,
                            pDestInfo->DestHandle,
                            TRUE
                            );

                if (dwResult isnot NO_ERROR)
                {
                    //
                    // Failed to mark 0/0 route.  The consequence is that
                    // only best route changes are processed.  We will
                    // have to live with the fact that we cannot 
                    // install multiple NETMGMT default routes since 
                    // this is performed by the mark dest. change 
                    // processing (in ProcessDefaultRouteChanges)
                    //
                    
                    Trace1(
                        ERR, 
                        "ProcessChanges: error %d marking default route",
                        dwResult
                        );
                }
            }

            else
            {
                //
                // Failed to check is 0/0 destination has been
                // marked for change notification
                // - Refer previous comment
                //
                
                Trace1(
                    ERR, 
                    "ProcessChanges: error %d checking if default route "
                    "marked",
                    dwResult
                    );
            }
        }

        
        // Check if we have a route in Unicast view
        
        if (pDestInfo->BelongsToViews & RTM_VIEW_MASK_UCAST)
        {
            // This is either a new or update route

            // Update the same route in KM Frwder

            ASSERT(pDestInfo->ViewInfo[0].ViewId is RTM_VIEW_ID_UCAST);

            dwResult = RtmGetRouteInfo(g_hLocalRoute,
                                       pDestInfo->ViewInfo[0].Route,
                                       pRouteInfo,
                                       NULL);

            // An error mean route just got deleted
            // Ignore this change as it is obsolete

            if (dwResult is NO_ERROR)
            {
                ChangeRouteWithForwarder(&pDestInfo->DestAddress,
                                         pRouteInfo,
                                         TRUE,
                                         TRUE);

                RtmReleaseRouteInfo(g_hLocalRoute,
                                    pRouteInfo);
            }            
        }
        else
        {
            // The last UCAST route has been deleted

            // Delete the same route from KM Frwder

            ChangeRouteWithForwarder(&pDestInfo->DestAddress,
                                     NULL,
                                     FALSE,
                                     TRUE);
        }

        RtmReleaseChangedDests(g_hLocalRoute,
                               hNotifyHandle,
                               dwDests,
                               pDestInfo);
    }
    while (TRUE);

    HeapFree(IPRouterHeap, 0, pRouteInfo);

    HeapFree(IPRouterHeap, 0, pDestInfo);
    
    TraceLeave("ProcessChanges");

    return NO_ERROR;
}



DWORD
WINAPI
ProcessDefaultRouteChanges(
    IN      HANDLE                          hNotifyHandle
    )

/*++

Routine Description:

    This function is invoked in response to changes to
    the default route.  If the best default route is owned
    by protocol PROTO_IP_NETMGMT enumerate all PROTO_IP_NETMGMT
    routes for default route 0/0 and set them as one
    multihop route to the forwarder
    
Arguments:

    hRtmHandle      - RTM registration handle
    
    hNotifyHandle   - Handle correponding to the change notification 
                      that is being signalled
    

Return Value:

    NO_ERROR    - Success

    System error code - Otherwise
    
--*/
{
    PRTM_DEST_INFO  pDestInfo;
    PRTM_ROUTE_INFO pRouteInfo;
    DWORD           dwDests;
    DWORD           dwResult;


    TraceEnter("ProcessDefaultRouteChanges");
    
    pRouteInfo = HeapAlloc( 
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );
                    
    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR, "ProcessDefaultRouteChanges : error allocating %d bytes for "
            "route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );

        TraceLeave("ProcessDefaultRouteChanges");

        return ERROR_NOT_ENOUGH_MEMORY;
    }
                
    pDestInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
                    );

    if (pDestInfo == NULL)
    {
        Trace1(
            ERR, "ProcessDefaultRouteChanges : error allocating %d bytes for "
            "dest. info",
            RTM_SIZE_OF_DEST_INFO(g_rtmProfile.NumberOfViews)
            );

        HeapFree(IPRouterHeap, 0, pRouteInfo);
        
        TraceLeave("ProcessDefaultRouteChanges");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
        //
        // retreive changed dests
        //

        dwDests = 1;

        dwResult = RtmGetChangedDests(
                    g_hNetMgmtRoute,
                    hNotifyHandle,
                    &dwDests,
                    pDestInfo
                    );

        if ((dwResult isnot NO_ERROR) and 
            (dwResult isnot ERROR_NO_MORE_ITEMS))
        {
            Trace1(
                ERR, 
                "ProcessDefaultRouteChanges: error %d retrieving changed dests",
                dwResult
                );

            break;
        }

        if (dwDests < 1)
        {
            //
            // no more dests to enumerate
            //

            break;
        }


        do
        {
            //
            // Make sure this the default route 0/0.  This functions
            // only processes default route changes.
            //

            if ((pDestInfo->DestAddress.NumBits isnot 0) or
                (*((ULONG *)pDestInfo->DestAddress.AddrBits) isnot 0))
            {
                Trace2(
                    ERR,
                    "ProcessDefaultRouteChanges: Not default route %d.%d.%d.%d/%d",
                    PRINT_IPADDR(*((ULONG *)pDestInfo->DestAddress.AddrBits)),
                    pDestInfo->DestAddress.NumBits
                    );

                break;
            }

            //
            // If all routes to 0/0 have been deleted,
            // delete it from the forwarder too.
            //

            if (!(pDestInfo->BelongsToViews & RTM_VIEW_MASK_UCAST))
            {
                dwResult = ChangeRouteWithForwarder(
                                &(pDestInfo->DestAddress),
                                NULL,
                                FALSE,
                                TRUE
                                );

                break;
            }

            //
            // A route to 0/0 was added/updated
            //

            if (pDestInfo->ViewInfo[0].Owner isnot g_hNetMgmtRoute)
            {
                //
                // Default route is not owned by PROTO_IP_NETMGT
                // Add only the best route to forwarder
                //
                
                TraceRoute1(
                    ROUTE,
                    "ProcessDefaultRouteChanges: Adding non-NetMgmt"
                    " route to forwarder, owner RTM handle 0x%x",
                    pDestInfo->ViewInfo[0].Owner
                    );

                dwResult = RtmGetRouteInfo(
                            g_hNetMgmtRoute,
                            pDestInfo->ViewInfo[0].Route,
                            pRouteInfo,
                            NULL
                            );

                if (dwResult is NO_ERROR)
                {
                    ChangeRouteWithForwarder(
                        &pDestInfo->DestAddress,
                        pRouteInfo,
                        TRUE,
                        TRUE
                        );

                    dwResult = RtmReleaseRouteInfo(
                                g_hNetMgmtRoute,
                                pRouteInfo
                                );
                                
                    if (dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR, 
                            "ProcessDefaultRouteChanges: Failed "
                            "to release route info",
                            dwResult
                            );
                    }
                }
                
                break;
            }
            
            //
            // Default route owned by PROTO_IP_NETMGMT
            //

            //
            // First delete existing 0/0 from the TCP/IP forwarder
            //

            dwResult = ChangeRouteWithForwarder(
                            &(pDestInfo->DestAddress),
                            NULL,
                            FALSE,
                            TRUE
                            );

            if (dwResult isnot NO_ERROR)
            {
                Trace1(
                    ERR,
                    "ProcessDefaultRouteChanges: error %d deleting "
                    "old NetMgmt default routes from forwarder",
                    dwResult
                    );
                    
                // break;
            }

            //
            // Second add all NETMGMT 0/0 to the TCP/IP forwarder
            //
            
            AddNetmgmtDefaultRoutesToForwarder(pDestInfo);
                
        } while( FALSE );


        //
        // release handles to changed destinations
        //
        
        dwResult = RtmReleaseChangedDests(
                    g_hNetMgmtRoute,
                    hNotifyHandle,
                    dwDests,
                    pDestInfo
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "ProcessDefaultRouteChanges: error %d releasing dests ",
                dwResult
                );
        }

    } while ( TRUE );

    HeapFree(IPRouterHeap, 0, pRouteInfo);

    HeapFree(IPRouterHeap, 0, pDestInfo);
    
    TraceLeave("ProcessDefaultRouteChanges");

    return dwResult;
}


DWORD
WINAPI
AddNetmgmtDefaultRoutesToForwarder(
    PRTM_DEST_INFO                          pDestInfo
    )
/*++

Routine Description:

    This routine enumerates the routes to 0/0 added by protocol
    PROTO_IP_NETMGT and adds them to the forwarder.  This routine
    is invoked in response to any change to the default route
    If the best default route is owned by PROTO_IP_NETMGMT, all
    PROTO_IP_NETMGMT default routes are added to the TCP/IP
    forwarder.  

    This is required since the TCP/IP stack does dead gateway
    detection and that required multiple default routes if
    present to be installed in the stack.

    An implicit assumption here is that PROTO_IP_NETMGMT routes
    alone merit this treatment.  In case of static or other
    protocol generated 0/0 routes, only the best route is
    added to the stack.  It is assumed that in the later case(s)
    the administrator (for static routes) or the protocol has
    a better idea of routing and so the dead gateway detection
    is suppressed in the stack by the addition of the best route
    to 0/0 alone.

Arguments:

    pDestInfo - RTM destination info structure of 0/0 route


Return Value :

    NO_ERROR -  Sucess

    Win32 error code - Otherwise

--*/
{
    DWORD               dwResult, dwNumHandles = 0, i;
    BOOL                bRelEnum = FALSE, bRelRoutes = FALSE;
    PRTM_ROUTE_INFO     pRouteInfo;
    PRTM_ROUTE_HANDLE   pHandles;
    RTM_ENUM_HANDLE     hRouteEnum;


    dwNumHandles = pDestInfo->ViewInfo[0].NumRoutes;
    
    pHandles = HeapAlloc(
                IPRouterHeap,
                0,
                dwNumHandles * sizeof(RTM_ROUTE_HANDLE)
                );

    if (pHandles == NULL)
    {
        Trace1(
            ERR,
            "AddNetmgmtDefaultRoutesToForwarder: error allocating %d bytes"
            "for route handles",
            dwNumHandles * sizeof(RTM_ROUTE_HANDLE)
            );
            
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRouteInfo = HeapAlloc( 
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );
                    
    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR,
            "AddNetmgmtDefaultRoutesToForwarder: error allocating %d bytes"
            "for route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        HeapFree(IPRouterHeap, 0, pHandles);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    do
    {
        //
        // Enumerate and add all NETMGMT routes to the forwarder
        //

        dwResult = RtmCreateRouteEnum(
                    g_hNetMgmtRoute,
                    pDestInfo->DestHandle,
                    RTM_VIEW_MASK_UCAST,
                    RTM_ENUM_OWN_ROUTES,
                    NULL,
                    0,
                    NULL,
                    0,
                    &hRouteEnum
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "AddNetmgmtDefaultRoutesToForwarder: error %d creating route "
                "enumeration",
                dwResult
                );

            break;
        }

        bRelEnum = TRUE;
        
        dwResult = RtmGetEnumRoutes(
                    g_hNetMgmtRoute,
                    hRouteEnum,
                    &dwNumHandles,
                    pHandles
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "ProcessDefaultRouteChanges:error %d enumerating "
                "routes",
                dwResult
                );

            break;
        }

        bRelRoutes = TRUE;

        //
        // Change route with the forwarder
        //

        for (i = 0; i < dwNumHandles; i++)
        {
            dwResult = RtmGetRouteInfo(
                        g_hNetMgmtRoute,
                        pHandles[i],
                        pRouteInfo,
                        NULL
                        );

            if (dwResult is NO_ERROR)
            {
                ChangeRouteWithForwarder(
                    &(pDestInfo->DestAddress),
                    pRouteInfo,
                    TRUE,
                    FALSE
                    );

                dwResult = RtmReleaseRouteInfo(
                            g_hNetMgmtRoute,
                            pRouteInfo
                            );

                if (dwResult isnot NO_ERROR)
                {
                    Trace1(
                        ERR,
                        "ProcessDefaultRouteChanges: error %d releasing "
                        "route info ",
                        dwResult
                        );
                }
            }
            else
            {
                Trace2(
                    ERR,
                    "ProcessDefaultRouteChanges: error %d getting route "
                    "info for route %d",
                    dwResult, i
                    );
            }
        }
        
    } while( FALSE );

    //
    // Release handles
    //

    if (bRelRoutes)
    {
        Trace0(ROUTE, "Releasing routes to 0/0");

        dwResult = RtmReleaseRoutes(
                    g_hNetMgmtRoute,
                    dwNumHandles,
                    pHandles
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "ProcessDefaultRouteChanges: error %d deleting enum "
                "handle",
                dwResult
                );
        }
    }

    if (bRelEnum)
    {
        Trace0(ROUTE, "Releasing route enum for 0/0");
        
        dwResult = RtmDeleteEnumHandle(
                    g_hNetMgmtRoute,
                    hRouteEnum
                    );

        if (dwResult isnot NO_ERROR)
        {
            Trace1(
                ERR,
                "ProcessDefaultRouteChanges: error %d deleting enum "
                "handle",
                dwResult
                );
        }
    }

    HeapFree(IPRouterHeap, 0, pHandles);
    HeapFree(IPRouterHeap, 0, pRouteInfo);

    return dwResult;
}


DWORD 
AddRtmRoute (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pRtInfo,
    IN      DWORD                           dwRouteFlags,
    IN      DWORD                           dwNextHopMask,
    IN      DWORD                           dwTimeToLive,
    OUT     HANDLE                         *phRtmRoute
    )

/*++

Routine Description:

    Adds a route to RTM with the specified route information.

Arguments:

    hRtmHandle    - RTM registration handle used in RTM calls

    pRtInfo       - 

    dwNextHopMask - 

    dwTimeToLive  - Time for which the route is kept in RTM
                    before being deleted (value is seconds).

Return Value:

    Status of the operation.

--*/

{
    PRTM_NET_ADDRESS  pDestAddr;
    PRTM_ROUTE_INFO   pRouteInfo;
    RTM_NEXTHOP_INFO  rniInfo;
    DWORD             dwFlags;
    DWORD             dwResult;
    HANDLE            hNextHopHandle;
    PADAPTER_INFO     pBinding;

    // Initialize output before caling ops
    
    if (ARGUMENT_PRESENT(phRtmRoute))
    {
        *phRtmRoute = NULL;
    }
    
    pDestAddr = HeapAlloc(
                    IPRouterHeap,
                    0,
                    sizeof(RTM_NET_ADDRESS)
                    );

    if (pDestAddr == NULL)
    {
        Trace1(
            ERR,
            "AddRtmRoute : error allocating %d bytes"
            "for dest. address",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRouteInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );

    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR,
            "AddRtmRoute : error allocating %d bytes"
            "for route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        HeapFree(IPRouterHeap, 0, pDestAddr);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Add a next hop if not already present
    //

    RTM_IPV4_MAKE_NET_ADDRESS(&rniInfo.NextHopAddress,
                              pRtInfo->dwRtInfoNextHop,
                              32);
                              
    rniInfo.InterfaceIndex = pRtInfo->dwRtInfoIfIndex;
    rniInfo.EntitySpecificInfo = (PVOID) (ULONG_PTR)dwNextHopMask;
    rniInfo.Flags = 0;
    rniInfo.RemoteNextHop = NULL;

    hNextHopHandle = NULL;
    
    dwResult = RtmAddNextHop(hRtmHandle,
                             &rniInfo,
                             &hNextHopHandle,
                             &dwFlags);

    if (dwResult is NO_ERROR)
    {
        TraceRoute2(
            ROUTE, "Route to %d.%d.%d.%d/%d.%d.%d.%d",
            PRINT_IPADDR(pRtInfo->dwRtInfoDest),
            PRINT_IPADDR(pRtInfo->dwRtInfoMask)
            );
            
        TraceRoute4(
            ROUTE, "Next Hop %d.%d.%d.%d/%d.%d.%d.%d, If 0x%x, handle is 0x%x", 
            PRINT_IPADDR(pRtInfo->dwRtInfoNextHop),
            PRINT_IPADDR(dwNextHopMask),
            pRtInfo->dwRtInfoIfIndex,
            hNextHopHandle
            );

        dwResult = ConvertRouteInfoToRtm(hRtmHandle,
                                         pRtInfo,
                                         hNextHopHandle,
                                         dwRouteFlags,
                                         pDestAddr,
                                         pRouteInfo);
        if (dwResult is NO_ERROR)
        {
            //
            // If we are adding a non-dod route we should
            // adjust the state of the route to match
            // that of the interface it is being added on
            //

            if ((hRtmHandle == g_hNonDodRoute)  ||
                (hRtmHandle == g_hNetMgmtRoute))
            {
                //
                // Find the binding given the interface id
                //

                ENTER_READER(BINDING_LIST);

                pBinding = GetInterfaceBinding(pRtInfo->dwRtInfoIfIndex);

                if ((!pBinding) || (!pBinding->bBound))
                {
                    // Interface has been deleted meanwhile
                    // or is not bound at this point - quit
                    EXIT_LOCK(BINDING_LIST);
                    
                    return ERROR_INVALID_PARAMETER;
                }
            }
            
            //
            // Convert TimeToLive from secs to millisecs
            //

            if (dwTimeToLive != INFINITE)
            {
                if (dwTimeToLive < (INFINITE / 1000))
                {
                    dwTimeToLive *= 1000;
                }
                else
                {
                    dwTimeToLive = INFINITE;
                }
            }

            dwFlags = 0;

            //
            // Add the new route using the RTMv2 API call
            //
                
            dwResult = RtmAddRouteToDest(hRtmHandle,
                                         phRtmRoute,
                                         pDestAddr,
                                         pRouteInfo,
                                         dwTimeToLive,
                                         NULL,
                                         0,
                                         NULL,
                                         &dwFlags);

            if ((hRtmHandle == g_hNonDodRoute)  ||
                (hRtmHandle == g_hNetMgmtRoute))
            {
                EXIT_LOCK(BINDING_LIST);
            }


            //
            // check if route is 0/0 and route protocol is
            //  PROTO_IP_NETMGMT.  If so mark for change notification
            //

            if ((pRtInfo->dwRtInfoDest is 0) and
                (pRtInfo->dwRtInfoMask is 0))
            {
                RTM_DEST_INFO rdi;
                BOOL bMark;
                BOOL bRelDest = FALSE;
                
                do
                {
                    TraceRoute2(
                        ROUTE, "Checking dest %d.%d.%d.%d/%d for mark", 
                        PRINT_IPADDR(*(ULONG *)pDestAddr->AddrBits),
                        PRINT_IPADDR(pDestAddr->NumBits)
                        );

                    dwResult = RtmGetExactMatchDestination(
                                g_hNetMgmtRoute,
                                pDestAddr,
                                RTM_THIS_PROTOCOL,
                                RTM_VIEW_MASK_UCAST,
                                &rdi
                                );

                    if (dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR,
                            "AddRtmRoute: error %d failed to get "
                            "destination 0/0 for change notification",
                            dwResult
                            );

                        break;
                    }

                    bRelDest = TRUE;

                    dwResult = RtmIsMarkedForChangeNotification(
                                g_hNetMgmtRoute,
                                g_hDefaultRouteNotification,
                                rdi.DestHandle,
                                &bMark
                                );

                    if (dwResult isnot NO_ERROR)
                    {
                        Trace1(
                            ERR,
                            "AddRtmRoute: error %d failed to check "
                            "destination 0/0 for change notification",
                            dwResult
                            );

                        break;
                    }

                    if (!bMark)
                    {
                        dwResult = RtmMarkDestForChangeNotification(
                                    g_hNetMgmtRoute,
                                    g_hDefaultRouteNotification,
                                    rdi.DestHandle,
                                    TRUE
                                    );
                                    
                        if (dwResult isnot NO_ERROR)
                        {
                            Trace1(
                                ERR,
                                "AddRtmRoute: error %d failed to nark "
                                "destination 0/0 for change notification",
                                dwResult
                                );
                                
                             break;
                        }
                        
                        //
                        // Add route once more, to force marked dest
                        // change notifications to be issued for this 
                        // change
                        //

                        dwFlags  = 0;
                        
                        dwResult = RtmAddRouteToDest(
                                        hRtmHandle,
                                        phRtmRoute,
                                        pDestAddr,
                                        pRouteInfo,
                                        dwTimeToLive,
                                        NULL,
                                        0,
                                        NULL,
                                        &dwFlags
                                        );

                        if (dwResult isnot NO_ERROR)
                        {
                            Trace1(
                                ERR,
                                "AddRtmRoute: error %d added route after "
                                "marking destination",
                                dwResult
                                );

                            break;
                        }

                        TraceRoute2(
                            ROUTE, "Marked dest %d.%d.%d.%d/%d and added", 
                            PRINT_IPADDR(*(ULONG *)pDestAddr->AddrBits),
                            PRINT_IPADDR(pDestAddr->NumBits)
                            );

                    }
                    
                } while (FALSE);

                if (bRelDest)
                {
                    RtmReleaseDestInfo(
                        g_hNetMgmtRoute,
                        &rdi
                        );
                }
            }
        }
        
        // Release the next hop handle obtained above
        
        RtmReleaseNextHops(hRtmHandle, 
                           1, 
                           &hNextHopHandle);
    }

    HeapFree(IPRouterHeap, 0, pDestAddr);
    HeapFree(IPRouterHeap, 0, pRouteInfo);
        
    return dwResult;
}


DWORD 
DeleteRtmRoute (
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pRtInfo
    )

/*++

Routine Description:

    Deletes an  RTM route with the specified route information.

Arguments:

    hRtmHandle    - RTM registration handle used in RTM calls

    pRtInfo       - 

Return Value:

    Status of the operation.

--*/

{
    PRTM_NET_ADDRESS pDestAddr;
    PRTM_ROUTE_INFO  pRouteInfo;
    RTM_NEXTHOP_INFO rniInfo;
    DWORD            dwFlags;
    DWORD            dwResult;
    HANDLE           hRouteHandle;
    HANDLE           hNextHopHandle;
    
    pRouteInfo = HeapAlloc(
                    IPRouterHeap,
                    0,
                    RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
                    );

    if (pRouteInfo == NULL)
    {
        Trace1(
            ERR,
            "DeleteRtmRoute : error allocating %d bytes"
            "for route info",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pDestAddr = HeapAlloc(
                    IPRouterHeap,
                    0,
                    sizeof(RTM_NET_ADDRESS)
                    );

    if (pDestAddr == NULL)
    {
        Trace1(
            ERR,
            "AddRtmRoute : error allocating %d bytes"
            "for dest. address",
            RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute)
            );
            
        HeapFree(IPRouterHeap, 0, pRouteInfo);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Obtain a handle to the next hop in the route
    //

    RTM_IPV4_MAKE_NET_ADDRESS(&rniInfo.NextHopAddress,
                              pRtInfo->dwRtInfoNextHop,
                              32);
                              
    rniInfo.InterfaceIndex = pRtInfo->dwRtInfoIfIndex;

    rniInfo.NextHopOwner = hRtmHandle;
    
    dwResult = RtmFindNextHop(hRtmHandle,
                              &rniInfo,
                              &hNextHopHandle,
                              NULL);

    if (dwResult isnot NO_ERROR)
    {
        HeapFree(IPRouterHeap, 0, pDestAddr);
        HeapFree(IPRouterHeap, 0, pRouteInfo);
        return dwResult;
    }

    //
    // We can get this route by matching the route's
    // net addr, its owner and neighbour learnt from
    //

    ConvertRouteInfoToRtm(hRtmHandle,
                             pRtInfo,
                             hNextHopHandle,
                             0,
                             pDestAddr,
                             pRouteInfo);

    dwResult = RtmGetExactMatchRoute(hRtmHandle,
                                     pDestAddr,
                                     RTM_MATCH_OWNER | RTM_MATCH_NEIGHBOUR,
                                     pRouteInfo,
                                     0,
                                     0,
                                     &hRouteHandle);
    if (dwResult is NO_ERROR)
    {
        //
        // Delete the route found above using the handle
        //
        
        dwResult = RtmDeleteRouteToDest(hRtmHandle,
                                        hRouteHandle,
                                        &dwFlags);

        if (dwResult isnot NO_ERROR)
        {
            // If delete successful, deref is automatic

            RtmReleaseRoutes(hRtmHandle, 
                             1, 
                             &hRouteHandle);
        }

        // Release the route information obtained above

        RtmReleaseRouteInfo(hRtmHandle,
                            pRouteInfo);
    }

    // Release the next hop handle obtained above

    RtmReleaseNextHops(hRtmHandle, 
                       1, 
                       &hNextHopHandle);
    
    HeapFree(IPRouterHeap, 0, pDestAddr);
    HeapFree(IPRouterHeap, 0, pRouteInfo);

    return dwResult;
}


DWORD
ConvertRouteInfoToRtm(
    IN      HANDLE                          hRtmHandle,
    IN      PINTERFACE_ROUTE_INFO           pRtInfo,
    IN      HANDLE                          hNextHopHandle,
    IN      DWORD                           dwRouteFlags,
    OUT     PRTM_NET_ADDRESS                pDestAddr,
    OUT     PRTM_ROUTE_INFO                 pRouteInfo
    )
{
    DWORD         dwAddrLen;
    
    // Fill the destination addr structure

    RTM_IPV4_LEN_FROM_MASK(dwAddrLen, pRtInfo->dwRtInfoMask);

    RTM_IPV4_MAKE_NET_ADDRESS(pDestAddr, 
                              pRtInfo->dwRtInfoDest,
                              dwAddrLen);

    // Fill in the route information now

    ZeroMemory(pRouteInfo, sizeof(RTM_ROUTE_INFO));

    pRouteInfo->RouteOwner  = hRtmHandle;
    pRouteInfo->Neighbour   = hNextHopHandle;
    
    pRouteInfo->PrefInfo.Metric     = pRtInfo->dwRtInfoMetric1;
    pRouteInfo->PrefInfo.Preference = pRtInfo->dwRtInfoPreference;
    pRouteInfo->BelongsToViews      = pRtInfo->dwRtInfoViewSet;

    //
    // BUG BUG BUG BUG :
    //  This is broken for future references
    //

    if(g_pLoopbackInterfaceCb && 
       pRtInfo->dwRtInfoIfIndex is g_pLoopbackInterfaceCb->dwIfIndex)
    {
        pRouteInfo->BelongsToViews &= ~RTM_VIEW_MASK_MCAST;
    }

    pRouteInfo->NextHopsList.NumNextHops = 1;
    pRouteInfo->NextHopsList.NextHops[0] = hNextHopHandle;

    // an unsigned integer is converted to a shorter
    // unsigned integer by truncating the high-order bits!
    pRouteInfo->Flags1  = (UCHAR) dwRouteFlags;
    pRouteInfo->Flags   = (USHORT) (dwRouteFlags >> 16);
            
    // Get the preference for this route 
    
    return ValidateRouteForProtocol(pRtInfo->dwRtInfoProto, 
                                    pRouteInfo,
                                    pDestAddr);

    // The following information is lost
    //
    //  dwForwardMetric2,3
    //  dwForwardPolicy
    //  dwForwardType
    //  dwForwardAge
    //  dwForwardNextHopAS
}

VOID
ConvertRtmToRouteInfo (
    IN      DWORD                           ownerProtocol,
    IN      PRTM_NET_ADDRESS                pDestAddr,
    IN      PRTM_ROUTE_INFO                 pRouteInfo,
    IN      PRTM_NEXTHOP_INFO               pNextHop,
    OUT     PINTERFACE_ROUTE_INFO           pRtInfo
    )
{
    pRtInfo->dwRtInfoDest    = *(ULONG *)pDestAddr->AddrBits;
    pRtInfo->dwRtInfoMask    = RTM_IPV4_MASK_FROM_LEN(pDestAddr->NumBits);

    pRtInfo->dwRtInfoIfIndex = pNextHop->InterfaceIndex;
    pRtInfo->dwRtInfoNextHop = *(ULONG *)pNextHop->NextHopAddress.AddrBits;

    pRtInfo->dwRtInfoProto   = ownerProtocol;

    pRtInfo->dwRtInfoMetric1 =
    pRtInfo->dwRtInfoMetric2 =
    pRtInfo->dwRtInfoMetric3 = pRouteInfo->PrefInfo.Metric;
    pRtInfo->dwRtInfoPreference = pRouteInfo->PrefInfo.Preference;
    pRtInfo->dwRtInfoViewSet    = pRouteInfo->BelongsToViews;
    
    pRtInfo->dwRtInfoPolicy  = 0;
    pRtInfo->dwRtInfoType    = 0;
    pRtInfo->dwRtInfoAge     = 0;
    pRtInfo->dwRtInfoNextHopAS = 0;

    return;
}

PINTERFACE_ROUTE_INFO
ConvertMibRouteToRouteInfo(
    IN  PMIB_IPFORWARDROW pMibRow
    )
{
    PINTERFACE_ROUTE_INFO pRouteInfo = (PINTERFACE_ROUTE_INFO)pMibRow;

    pMibRow->dwForwardMetric2 = 0;
    pMibRow->dwForwardMetric3 = 0;
    pMibRow->dwForwardMetric4 = 0;
    pMibRow->dwForwardMetric5 = 0;

    // Make sure Metric1 isn't 0

    if (pRouteInfo->dwRtInfoMetric1 is 0)
    {
        pRouteInfo->dwRtInfoMetric1 = 1;
    }

    // By default put it in both views
    pRouteInfo->dwRtInfoViewSet = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

    return pRouteInfo;
}


PMIB_IPFORWARDROW
ConvertRouteInfoToMibRoute(
    IN  PINTERFACE_ROUTE_INFO pRouteInfo
    )
{
    PMIB_IPFORWARDROW pMibRoute = (PMIB_IPFORWARDROW) pRouteInfo;

    pMibRoute->dwForwardMetric2 =
    pMibRoute->dwForwardMetric3 =
    pMibRoute->dwForwardMetric4 =
    pMibRoute->dwForwardMetric5 = IRE_METRIC_UNUSED;

    pMibRoute->dwForwardAge = INFINITE;
    pMibRoute->dwForwardPolicy = 0;
    pMibRoute->dwForwardNextHopAS = 0;
    
    pMibRoute->dwForwardType = IRE_TYPE_INDIRECT;

    return pMibRoute;
}


VOID
ConvertRouteNotifyOutputToRouteInfo(
    IN      PIPRouteNotifyOutput            pirno,
    OUT     PINTERFACE_ROUTE_INFO           pRtInfo
    )
{

    ZeroMemory(pRtInfo, sizeof(INTERFACE_ROUTE_INFO));

    pRtInfo->dwRtInfoDest       = pirno->irno_dest;
    pRtInfo->dwRtInfoMask       = pirno->irno_mask;
    pRtInfo->dwRtInfoIfIndex    = pirno->irno_ifindex;
    pRtInfo->dwRtInfoNextHop    = pirno->irno_nexthop;

    pRtInfo->dwRtInfoProto      = pirno->irno_proto;

    pRtInfo->dwRtInfoMetric1    = 
    pRtInfo->dwRtInfoMetric2    =
    pRtInfo->dwRtInfoMetric3    = pirno->irno_metric;

    pRtInfo->dwRtInfoPreference = ComputeRouteMetric(pirno->irno_proto);

    pRtInfo->dwRtInfoViewSet    = RTM_VIEW_MASK_UCAST | 
                                  RTM_VIEW_MASK_MCAST;

    pRtInfo->dwRtInfoType       = (pirno->irno_proto == PROTO_IP_LOCAL) ?
                                  MIB_IPROUTE_TYPE_DIRECT : 0;

    pRtInfo->dwRtInfoAge        = INFINITE;
    pRtInfo->dwRtInfoNextHopAS  = 0;
    pRtInfo->dwRtInfoPolicy     = 0;


    return;
}


DWORD
BlockConvertRoutesToStatic (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      DWORD                           dwProtocolId
    )
{
    HANDLE             hRtmEnum;
    RTM_ENTITY_INFO    reiInfo;
    RTM_NET_ADDRESS    rnaDest;
    PRTM_ROUTE_INFO    pRouteInfo1;
    PRTM_ROUTE_INFO    pRouteInfo2;
    RTM_NEXTHOP_INFO   nhiInfo;
    RTM_NEXTHOP_HANDLE hNextHop;
    PHANDLE            hRoutes;
    DWORD              dwHandles;
    DWORD              dwFlags;
    DWORD              dwNumBytes;
    DWORD              i, j, k;
    BOOL               fDeleted;
    DWORD              dwResult;

    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(
            ERR,
            "BlockConvertRoutesToStatic : error allocating %d bytes"
            "for route handes",
            g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
            );
            
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    dwNumBytes = RTM_SIZE_OF_ROUTE_INFO(g_rtmProfile.MaxNextHopsInRoute);
    
    pRouteInfo1 = HeapAlloc(
                    IPRouterHeap,
                    0,
                    dwNumBytes
                    );

    if (pRouteInfo1 == NULL)
    {
        Trace1(
            ERR,
            "BlockConvertRoutesToStatic : error allocating %d bytes"
            "for route info",
            dwNumBytes
            );
            
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRouteInfo2 = HeapAlloc(
                    IPRouterHeap,
                    0,
                    dwNumBytes
                    );

    if (pRouteInfo2 == NULL)
    {
        Trace1(
            ERR,
            "BlockConvertRoutesToStatic : error allocating %d bytes"
            "for route info",
            dwNumBytes
            );
            
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        HeapFree(IPRouterHeap, 0, pRouteInfo1);
        
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    

    //
    // Enum all routes on the interface that we need
    //

    dwResult = RtmCreateRouteEnum(hRtmHandle,
                                  NULL,
                                  RTM_VIEW_MASK_ANY,
                                  RTM_ENUM_ALL_ROUTES,
                                  NULL,
                                  RTM_MATCH_INTERFACE,
                                  NULL,
                                  dwIfIndex,
                                  &hRtmEnum);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "BlockConvertRoutesToStatic: Error %d creating handle for %d\n",
               dwResult,
               hRtmHandle);
        
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        HeapFree(IPRouterHeap, 0, pRouteInfo1);

        HeapFree(IPRouterHeap, 0, pRouteInfo2);

        return dwResult;
    }

    do
    {
        dwHandles = g_rtmProfile.MaxHandlesInEnum;
        
        dwResult = RtmGetEnumRoutes(hRtmHandle,
                                    hRtmEnum,
                                    &dwHandles,
                                    hRoutes);

        for (i = 0; i < dwHandles; i++)
        {
            fDeleted = FALSE;
            
            // Get the route info from the handle

            if (RtmGetRouteInfo(hRtmHandle,
                                hRoutes[i],
                                pRouteInfo1,
                                &rnaDest) is NO_ERROR)
            {
                // Does this match the routing protocol we want ?
                
                if ((RtmGetEntityInfo(hRtmHandle,
                                      pRouteInfo1->RouteOwner,
                                      &reiInfo) is NO_ERROR) &&
                    (reiInfo.EntityId.EntityProtocolId is dwProtocolId))
                {
                    //
                    // Add new static route with same information
                    // 

                    CopyMemory(pRouteInfo2,
                               pRouteInfo1,
                               sizeof(RTM_ROUTE_INFO));

                    // Adjust the preference to confirm to protocol
                    pRouteInfo2->PrefInfo.Preference = 
                        ComputeRouteMetric(PROTO_IP_NT_AUTOSTATIC);

                    // Adjust the neighbour to corr to new protocol

                    if (pRouteInfo1->Neighbour)
                    {
                        // In case we cant get convert the neighbour
                        pRouteInfo2->Neighbour = NULL;
                        
                        if (RtmGetNextHopInfo(hRtmHandle,
                                              pRouteInfo1->Neighbour,
                                              &nhiInfo) is NO_ERROR)
                        {
                            // Add the same neigbour using new protocol

                            hNextHop = NULL;

                            if (RtmAddNextHop(hRtmHandle,
                                              &nhiInfo,
                                              &hNextHop,
                                              &dwFlags) is NO_ERROR)
                            {
                                pRouteInfo2->Neighbour = hNextHop;
                            }

                            RtmReleaseNextHopInfo(hRtmHandle, &nhiInfo);
                        }
                    }

                    // Adjust the next hops to corr to new protocol

                    for (j = k = 0;
                         j < pRouteInfo1->NextHopsList.NumNextHops;
                         j++)
                    {
                        if (RtmGetNextHopInfo(hRtmHandle,
                                              pRouteInfo1->NextHopsList.NextHops[j],
                                              &nhiInfo) is NO_ERROR)
                        {
                            // Add the same nexthop using new protocol

                            hNextHop = NULL;

                            if (RtmAddNextHop(hRtmHandle,
                                              &nhiInfo,
                                              &hNextHop,
                                              &dwFlags) is NO_ERROR)
                            {
                                pRouteInfo2->NextHopsList.NextHops[k++] = hNextHop;
                            }

                            RtmReleaseNextHopInfo(hRtmHandle, &nhiInfo);
                        }
                    }

                    pRouteInfo2->NextHopsList.NumNextHops = (USHORT) k;

                    // Add the new route with the next hop information

                    if (k > 0)
                    {
                        dwFlags = 0;
                        
                        if (RtmAddRouteToDest(hRtmHandle,
                                              NULL,
                                              &rnaDest,
                                              pRouteInfo2,
                                              INFINITE,
                                              NULL,
                                              0,
                                              NULL,
                                              &dwFlags) is NO_ERROR)
                        {
                            // Route add is successful - delete old route

                            if (RtmDeleteRouteToDest(pRouteInfo1->RouteOwner,
                                                     hRoutes[i],
                                                     &dwFlags) is NO_ERROR)
                            {
                                fDeleted = TRUE;
                            }
                        }

                        RtmReleaseNextHops(hRtmHandle,
                                           k,
                                           pRouteInfo2->NextHopsList.NextHops);
                    }
                }

                RtmReleaseRouteInfo(hRtmHandle, pRouteInfo1);
            }

            if (!fDeleted)
            {
                RtmReleaseRoutes(hRtmHandle, 1, &hRoutes[i]);
            }
        }
    }
    while (dwResult is NO_ERROR);

    RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);

    HeapFree(IPRouterHeap, 0, hRoutes);
    
    HeapFree(IPRouterHeap, 0, pRouteInfo1);

    HeapFree(IPRouterHeap, 0, pRouteInfo2);

    return NO_ERROR;
}


DWORD
DeleteRtmRoutes (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      BOOL                            fDeleteAll
    )
{
    HANDLE           hRtmEnum;
    PHANDLE          hRoutes;
    DWORD            dwHandles;
    DWORD            dwFlags;
    DWORD            i;
    DWORD            dwResult;

    hRoutes = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hRoutes == NULL)
    {
        Trace1(ERR,
               "DeleteRtmRoutes: Error allocating %d bytes",
               g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE));
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwFlags = fDeleteAll ? 0: RTM_MATCH_INTERFACE;
    
    dwResult = RtmCreateRouteEnum(hRtmHandle,
                                  NULL,
                                  RTM_VIEW_MASK_ANY,
                                  RTM_ENUM_OWN_ROUTES,
                                  NULL,
                                  dwFlags,
                                  NULL,
                                  dwIfIndex,
                                  &hRtmEnum);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "DeleteRtmRoutes: Error %d creating handle for %d\n",
               dwResult,
               hRtmHandle);
        
        HeapFree(IPRouterHeap, 0, hRoutes);
        
        return dwResult;
    }

    do
    {
        dwHandles = g_rtmProfile.MaxHandlesInEnum;
        
        dwResult = RtmGetEnumRoutes(hRtmHandle,
                                    hRtmEnum,
                                    &dwHandles,
                                    hRoutes);

        for (i = 0; i < dwHandles; i++)
        {
            if (RtmDeleteRouteToDest(hRtmHandle,
                                     hRoutes[i],
                                     &dwFlags) isnot NO_ERROR)
            {
                // If delete is successful, this is automatic
                RtmReleaseRoutes(hRtmHandle, 1, &hRoutes[i]);
            }
        }
    }
    while (dwResult is NO_ERROR);

    RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);

    HeapFree(IPRouterHeap, 0, hRoutes);
    
    return NO_ERROR;
}


DWORD
DeleteRtmNexthops (
    IN      HANDLE                          hRtmHandle,
    IN      DWORD                           dwIfIndex,
    IN      BOOL                            fDeleteAll
    )
{
    PRTM_NEXTHOP_INFO pNexthop;
    PHANDLE           hNexthops;
    HANDLE            hRtmEnum;
    DWORD             dwHandles;
    DWORD             i;
    DWORD             dwResult;

    hNexthops = HeapAlloc(
                IPRouterHeap,
                0,
                g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE)
                );

    if (hNexthops == NULL)
    {
        Trace1(ERR,
               "DeleteRtmNextHops: Error allocating %d bytes",
               g_rtmProfile.MaxHandlesInEnum * sizeof(HANDLE));
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwResult = RtmCreateNextHopEnum(hRtmHandle,
                                    0,
                                    NULL,
                                    &hRtmEnum);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "DeleteAllNexthops: Error %d creating handle for %d\n",
               dwResult,
               hRtmHandle);
        
        HeapFree(IPRouterHeap, 0, hNexthops);
        
        return dwResult;
    }

    do
    {
        dwHandles = g_rtmProfile.MaxHandlesInEnum;
        
        dwResult = RtmGetEnumNextHops(hRtmHandle,
                                      hRtmEnum,
                                      &dwHandles,
                                      hNexthops);

        for (i = 0; i < dwHandles; i++)
        {
            if (!fDeleteAll)
            {
                //
                // Make sure that the interface matches
                //
                
                if ((RtmGetNextHopPointer(hRtmHandle,
                                          hNexthops[i],
                                          &pNexthop) isnot NO_ERROR) ||
                    (pNexthop->InterfaceIndex != dwIfIndex))
                {
                    RtmReleaseNextHops(hRtmHandle, 1, &hNexthops[i]);
                    continue;
                }
            }

            // We need to delete this next hop here
            
            if (RtmDeleteNextHop(hRtmHandle,
                                 hNexthops[i],
                                 NULL) isnot NO_ERROR)
            {
                // If delete is successful, this is automatic
                RtmReleaseNextHops(hRtmHandle, 1, &hNexthops[i]);
            }
        }
    }
    while (dwResult is NO_ERROR);

    RtmDeleteEnumHandle(hRtmHandle, hRtmEnum);

    HeapFree(IPRouterHeap, 0, hNexthops);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\rtrdisc.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ip\rtrmgr\rtrdisc.c

Abstract:
    Router Discover code

Revision History:

    Amritansh Raghav  20th March 1996     Created

--*/

#include "allinc.h"

VOID
DeleteSockets(
    IN PICB picb
    );


VOID
InitializeRouterDiscoveryInfo(
    IN PICB                   picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    )

/*++

Routine Description

    Sets router discovery information passed in the ICB. If none is passed,
    sets to RFC 1256 defaults

Locks

    Must be called with ICB_LIST lock held as WRITER

Arguments

    picb        The ICB of the interface for whom the router discovery
                related variables have to be set

Return Value

    None

--*/

{
    PROUTER_DISC_CB pDiscCb;
    PRTR_DISC_INFO  pInfo = NULL;
    PRTR_TOC_ENTRY  pToc;
    LONG            lMilliSec;

    TraceEnter("InitializeRouterDiscovery");

    pToc = GetPointerToTocEntry(IP_ROUTER_DISC_INFO,
                                pInfoHdr);

    if(!pToc)
    {
        //
        // Leave things as they are
        //

        TraceLeave("InitializeRouterDiscoveryInfo");

        return;
    }

    pDiscCb = &picb->rdcRtrDiscInfo;

    //
    // First set everything to defaults, then if any info is valid, reset
    // those fields
    //

    pDiscCb->wMaxAdvtInterval = DEFAULT_MAX_ADVT_INTERVAL;

    pDiscCb->lPrefLevel       = DEFAULT_PREF_LEVEL;
    pDiscCb->dwNumAdvtsSent   = pDiscCb->dwNumSolicitationsSeen = 0;

    pDiscCb->liMaxMinDiff.HighPart   =
        pDiscCb->liMaxMinDiff.LowPart    = 0;

    pDiscCb->liMinAdvtIntervalInSysUnits.HighPart =
        pDiscCb->liMinAdvtIntervalInSysUnits.LowPart  = 0;

    pDiscCb->pRtrDiscSockets = NULL;

    //
    // RFC 1256 says default should be true, so there will be traffic on the
    // net if the user does not explicitly set this to false. We diverge from
    // the RFC and default to FALSE
    //

    pDiscCb->bAdvertise = FALSE;
    pDiscCb->bActive    = FALSE;

    if(pToc and (pToc->InfoSize > 0) and (pToc->Count > 0))
    {
        pInfo = (PRTR_DISC_INFO) GetInfoFromTocEntry(pInfoHdr,pToc);

        if(pInfo isnot NULL)
        {
            //
            // Ok, so we were passed some info
            //

            if((pInfo->wMaxAdvtInterval >= MIN_MAX_ADVT_INTERVAL) and
               (pInfo->wMaxAdvtInterval <= MAX_MAX_ADVT_INTERVAL))
            {
                pDiscCb->wMaxAdvtInterval = pInfo->wMaxAdvtInterval;
            }

            if((pInfo->wMinAdvtInterval >= MIN_MIN_ADVT_INTERVAL) and
               (pInfo->wMinAdvtInterval <= pDiscCb->wMaxAdvtInterval))
            {
                pDiscCb->liMinAdvtIntervalInSysUnits = SecsToSysUnits(pInfo->wMinAdvtInterval);
            }
            else
            {
                lMilliSec = (LONG)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * pDiscCb->wMaxAdvtInterval * 1000);

                pDiscCb->liMinAdvtIntervalInSysUnits = RtlEnlargedIntegerMultiply(lMilliSec,10000);
            }

            if((pInfo->wAdvtLifetime >= pDiscCb->wMaxAdvtInterval) and
               (pInfo->wAdvtLifetime <= MAX_ADVT_LIFETIME))
            {
                pDiscCb->wAdvtLifetime = pInfo->wAdvtLifetime;
            }
            else
            {
                pDiscCb->wAdvtLifetime = DEFAULT_ADVT_LIFETIME_RATIO * pDiscCb->wMaxAdvtInterval;
            }

            pDiscCb->bAdvertise = pInfo->bAdvertise;

            pDiscCb->lPrefLevel = pInfo->lPrefLevel;
        }
    }

    if(pInfo is NULL)
    {
        //
        // default case, in case no router disc. info. is specified.
        //
        
        lMilliSec = (LONG)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * pDiscCb->wMaxAdvtInterval * 1000);

        pDiscCb->liMinAdvtIntervalInSysUnits = RtlEnlargedIntegerMultiply(lMilliSec,10000);

        pDiscCb->wAdvtLifetime     = DEFAULT_ADVT_LIFETIME_RATIO * pDiscCb->wMaxAdvtInterval;
    }

    pDiscCb->liMaxMinDiff = RtlLargeIntegerSubtract(SecsToSysUnits(pDiscCb->wMaxAdvtInterval),
                                                    pDiscCb->liMinAdvtIntervalInSysUnits);

    TraceLeave("InitializeRouterDiscovery");
}

VOID
SetRouterDiscoveryInfo(
    IN PICB                      picb,
    IN PRTR_INFO_BLOCK_HEADER    pInfoHdr
    )

/*++

Routine Description

    Sets router discovery information passed in the ICB. If none is passed,
    sets to RFC 1256 defaults

Locks

    Must be called with ICB_LIST lock held as WRITER

Arguments

    picb        The ICB of the interface for whom the router discovery related
                variables have to be set
    pInfoHdr    Interface Info header

Return Value

    None

--*/

{
    PROUTER_DISC_CB  pDiscCb;
    PRTR_DISC_INFO   pInfo;
    PRTR_TOC_ENTRY   pToc;
    LONG             lMilliSec;
    BOOL             bOriginalStatus;

    TraceEnter("SetRouterDiscoveryInfo");

    pDiscCb = &picb->rdcRtrDiscInfo;

    pToc = GetPointerToTocEntry(IP_ROUTER_DISC_INFO,
                                pInfoHdr);

    if(!pToc)
    {
        //
        // Leave things as they are
        //

        TraceLeave("SetRouterDiscoveryInfo");

        return;
    }

    pInfo = (PRTR_DISC_INFO) GetInfoFromTocEntry(pInfoHdr,pToc);

    bOriginalStatus = pDiscCb->bAdvertise;

    if((pToc->InfoSize is 0) or (pInfo is NULL))
    {
        //
        // If the size is zero, stop advertising
        //

        DeActivateRouterDiscovery(picb);

        //
        // Instead of returning, we go through and set defaults so that the info
        // looks good when someone does a get info
        //
    }


    //
    // First set everything to defaults, then if any info is valid, reset
    // those fields
    //

    pDiscCb->wMaxAdvtInterval = DEFAULT_MAX_ADVT_INTERVAL;

    pDiscCb->lPrefLevel       = DEFAULT_PREF_LEVEL;

    //
    // We reset the counters
    //

    pDiscCb->dwNumAdvtsSent   = pDiscCb->dwNumSolicitationsSeen = 0;

    pDiscCb->liMaxMinDiff.HighPart  =
        pDiscCb->liMaxMinDiff.LowPart   = 0;

    pDiscCb->liMinAdvtIntervalInSysUnits.HighPart =
        pDiscCb->liMinAdvtIntervalInSysUnits.LowPart  = 0;

    //
    // We DONT mess with the sockets
    //


    if((pToc->InfoSize) and (pInfo isnot NULL))
    {
        if(!pInfo->bAdvertise)
        {
            DeActivateRouterDiscovery(picb);
        }

        if((pInfo->wMaxAdvtInterval > MIN_MAX_ADVT_INTERVAL) and
           (pInfo->wMaxAdvtInterval < MAX_MAX_ADVT_INTERVAL))
        {
            pDiscCb->wMaxAdvtInterval = pInfo->wMaxAdvtInterval;
        }

        if((pInfo->wMinAdvtInterval > MIN_MIN_ADVT_INTERVAL) and
           (pInfo->wMinAdvtInterval < pDiscCb->wMaxAdvtInterval))
        {
            pDiscCb->liMinAdvtIntervalInSysUnits =
                SecsToSysUnits(pInfo->wMinAdvtInterval);
        }
        else
        {
            lMilliSec = (LONG)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * pDiscCb->wMaxAdvtInterval * 1000);

            pDiscCb->liMinAdvtIntervalInSysUnits =
                RtlEnlargedIntegerMultiply(lMilliSec,10000);
        }

        if((pInfo->wAdvtLifetime > pDiscCb->wMaxAdvtInterval) and
           (pInfo->wAdvtLifetime < MAX_ADVT_LIFETIME))
        {
            pDiscCb->wAdvtLifetime = pInfo->wAdvtLifetime;
        }
        else
        {
            pDiscCb->wAdvtLifetime =
                DEFAULT_ADVT_LIFETIME_RATIO * pDiscCb->wMaxAdvtInterval;
        }

        pDiscCb->bAdvertise = pInfo->bAdvertise;

        pDiscCb->lPrefLevel = pInfo->lPrefLevel;
    }
    else
    {
        lMilliSec = (LONG)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * pDiscCb->wMaxAdvtInterval * 1000);

        pDiscCb->liMinAdvtIntervalInSysUnits =
            RtlEnlargedIntegerMultiply(lMilliSec,10000);

        pDiscCb->wAdvtLifetime =
            DEFAULT_ADVT_LIFETIME_RATIO * pDiscCb->wMaxAdvtInterval;
    }

    if(pDiscCb->bAdvertise is TRUE)
    {
        if(bOriginalStatus is FALSE)
        {
            //
            // If we were originally not advertising but are advertising now,
            // then start router discovery
            //

            ActivateRouterDiscovery(picb);
        }
        else
        {
            //
            // Else just update the fields in the advertisement
            //

            UpdateAdvertisement(picb);
        }
    }

    TraceLeave("SetRouterDiscoveryInfo");
}

DWORD
GetInterfaceRouterDiscoveryInfo(
    PICB                    picb,
    PRTR_TOC_ENTRY          pToc,
    PBYTE                   pbDataPtr,
    PRTR_INFO_BLOCK_HEADER  pInfoHdr,
    PDWORD                  pdwSize
    )

/*++

Routine Description

    Gets router discovery information related to an interface

Locks

    Called with ICB_LIST lock held as READER

Arguments

    picb        The ICB of the interface whose router discovery information is
                being retrieved
    pToc        Pointer to TOC for router discovery info
    pbDataPtr   Pointer to start of data buffer
    pInfoHdr    Pointer to the header of the whole info
    pdwSize     [IN]  Size of data buffer
                [OUT] Size of buffer consumed

Return Value

--*/

{
    PRTR_DISC_INFO  pInfo;
    DWORD           dwRem;
    LARGE_INTEGER   liQuotient;

    TraceEnter("GetInterfaceRouterDiscoveryInfo");

    if(*pdwSize < sizeof(RTR_DISC_INFO))
    {
        *pdwSize = sizeof(RTR_DISC_INFO);

        TraceLeave("GetInterfaceRouterDiscoveryInfo");

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pdwSize = pToc->InfoSize = sizeof(RTR_DISC_INFO);

    //pToc->InfoVersion  = IP_ROUTER_DISC_INFO;
    pToc->InfoType  = IP_ROUTER_DISC_INFO;
    pToc->Count     = 1;
    pToc->Offset    = (ULONG)(pbDataPtr - (PBYTE) pInfoHdr);

    pInfo = (PRTR_DISC_INFO)pbDataPtr;

    pInfo->wMaxAdvtInterval = picb->rdcRtrDiscInfo.wMaxAdvtInterval;

    liQuotient = RtlExtendedLargeIntegerDivide(picb->rdcRtrDiscInfo.liMinAdvtIntervalInSysUnits,
                                               SYS_UNITS_IN_1_SEC,
                                               &dwRem);

    pInfo->wMinAdvtInterval = LOWORD(liQuotient.LowPart);
    pInfo->wAdvtLifetime    = picb->rdcRtrDiscInfo.wAdvtLifetime;
    pInfo->bAdvertise       = picb->rdcRtrDiscInfo.bAdvertise;
    pInfo->lPrefLevel       = picb->rdcRtrDiscInfo.lPrefLevel;

    TraceLeave("GetInterfaceRouterDiscoveryInfo");

    return NO_ERROR;
}



DWORD
ActivateRouterDiscovery(
    IN PICB  picb
    )

/*++

Routine Description

    Activates router discovery messages on an interface. The interface must
    already be bound.

Locks

    Called with the ICB_LIST lock held as WRITER

Arguments

    picb          The ICB of the interface to activate

Return Value

    NO_ERROR or some error code

--*/

{
    PROUTER_DISC_CB    pDiscCb;
    PROUTER_DISC_CB    pDiscCb2;
    DWORD              dwResult,i,dwNumAddrs,dwNumOldAddrs,dwSize;
    LARGE_INTEGER      liTimer;
    PTIMER_QUEUE_ITEM  pTimer;
    BOOL               bReset;

    TraceEnter("ActivateRouterDiscovery");

    //
    // The SetInterfaceInfo call takes into account whether our
    // admin state is UP or down. Here we only check if our oper
    // state allows us to come up
    //

    if(picb->dwOperationalState < IF_OPER_STATUS_CONNECTING)
    {
        TraceLeave("ActivateRouterDiscovery");

        return NO_ERROR;
    }

    pDiscCb = &picb->rdcRtrDiscInfo;

    if(!pDiscCb->bAdvertise)
    {
        //
        // Since we dont have to advertise on this interface, we are done
        //

        TraceLeave("ActivateRouterDiscovery");

        return NO_ERROR;
    }

    dwResult = CreateSockets(picb);

    if(dwResult isnot NO_ERROR)
    {
        Trace2(ERR,
               "ActivateRouterDiscovery: Couldnt create sockets for interface %S. Error %d",
               picb->pwszName,
               dwResult);

        TraceLeave("ActivateRouterDiscovery");

        return dwResult;
    }

    dwResult    = UpdateAdvertisement(picb);

    if(dwResult isnot NO_ERROR)
    {
        DeleteSockets(picb);

        Trace1(ERR,
               "ActivateRouterDiscovery: Couldnt update Icmp Advt. Error %d",
               dwResult);

        TraceLeave("ActivateRouterDiscovery");

        return dwResult;
    }

    //
    // Ok so we have a valid CB and we have the sockets all set up.
    //

    bReset = SetFiringTimeForAdvt(picb);

    if(bReset)
    {
        if(!SetWaitableTimer(g_hRtrDiscTimer,
                             &(pDiscCb->tqiTimer.liFiringTime),
                             0,
                             NULL,
                             NULL,
                             FALSE))
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "ActivateRouterDiscovery: Error %d setting timer",
                   dwResult);

            DeleteSockets(picb);

            TraceLeave("ActivateRouterDiscovery");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    //
    // Yes we are active
    //

    pDiscCb->bActive = TRUE;

    TraceLeave("ActivateRouterDiscovery");

    return NO_ERROR;
}

DWORD
UpdateAdvertisement(
    IN PICB    picb
    )

/*++

Routine Description

    Updates the Router discovery advertisement. If none exists, creates one

Locks

    ICB lock as writer

Arguments

    picb      ICB to update

Return Value

    NO_ERROR

--*/

{
    DWORD               dwResult,i;
    PROUTER_DISC_CB     pDiscCb;


    TraceEnter("UpdateAdvertisement");

    pDiscCb = &picb->rdcRtrDiscInfo;

    if(picb->pRtrDiscAdvt)
    {
        //
        // If we have an old advertisement
        //

        if(picb->dwRtrDiscAdvtSize < SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses))
        {
            //
            // Too small, cannot reuse the old advert
            //

            HeapFree(IPRouterHeap,
                     0,
                     picb->pRtrDiscAdvt);

            picb->pRtrDiscAdvt = NULL;

            picb->dwRtrDiscAdvtSize   = 0;
        }
    }

    if(!picb->pRtrDiscAdvt)
    {
        picb->pRtrDiscAdvt = HeapAlloc(IPRouterHeap,
                                       HEAP_ZERO_MEMORY,
                                       SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses));

        if(picb->pRtrDiscAdvt is NULL)
        {
            //
            // Set advertise to FALSE so that no one uses the
            // NULL pointer by mistake
            //

            pDiscCb->bAdvertise         = FALSE;
            picb->dwRtrDiscAdvtSize   = 0;

            Trace1(ERR,
                   "UpdateAdvertisement: Cant allocate %d bytes for Icmp Msg",
                   SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses));

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        picb->dwRtrDiscAdvtSize   = SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses);
    }

    picb->pRtrDiscAdvt->byType           = ICMP_ROUTER_DISCOVERY_TYPE;
    picb->pRtrDiscAdvt->byCode           = ICMP_ROUTER_DISCOVERY_CODE;
    picb->pRtrDiscAdvt->wLifeTime        = htons(pDiscCb->wAdvtLifetime);
    picb->pRtrDiscAdvt->byAddrEntrySize  = ICMP_ROUTER_DISCOVERY_ADDR_SIZE;
    picb->pRtrDiscAdvt->wXSum            = 0;

    //
    // Add the interface's addresses to the advertisement.
    //

    picb->wsAdvtWSABuffer.buf = (PBYTE)picb->pRtrDiscAdvt;
    picb->wsAdvtWSABuffer.len = SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses);

    picb->pRtrDiscAdvt->byNumAddrs = LOBYTE(LOWORD(picb->dwNumAddresses));

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        picb->pRtrDiscAdvt->iaAdvt[i].dwRtrIpAddr = picb->pibBindings[i].dwAddress;
        picb->pRtrDiscAdvt->iaAdvt[i].lPrefLevel  =
            htonl(picb->rdcRtrDiscInfo.lPrefLevel);
    }

    picb->pRtrDiscAdvt->wXSum    = Compute16BitXSum((PVOID)picb->pRtrDiscAdvt,
                                                    SIZEOF_RTRDISC_ADVT(picb->dwNumAddresses));

    //
    // Note: TBD: If the advertising times have changed we should
    // change the timer queue. However we let the timer fire and the
    // next time we set the timer we will pick up the correct
    // time
    //

    TraceLeave("UpdateAdvertisement");

    return NO_ERROR;
}



BOOL
SetFiringTimeForAdvt(
    IN PICB   picb
    )

/*++

Routine Description



Locks

    ICB_LIST lock must be held as WRITER

Arguments

    picb    The ICB of the interface to activate

Return Value

    TRUE if calling the function caused the timer to be reset

--*/

{
    PROUTER_DISC_CB    pDiscCb;
    DWORD              dwResult;
    LARGE_INTEGER      liCurrentTime, liRandomTime;
    INT                iRand;
    ULONG              ulRem;
    PLIST_ENTRY        pleNode;
    PTIMER_QUEUE_ITEM  pOldTime;

    TraceEnter("SetFiringTimeForAdvt");

    //
    // Figure out the next time this interface should advertise
    //

    iRand = rand();

    pDiscCb = &picb->rdcRtrDiscInfo;

    liRandomTime = RtlExtendedLargeIntegerDivide(RtlExtendedIntegerMultiply(pDiscCb->liMaxMinDiff,
                                                                            iRand),
                                                 RAND_MAX,
                                                 &ulRem);

    liRandomTime = RtlLargeIntegerAdd(liRandomTime,
                                      pDiscCb->liMinAdvtIntervalInSysUnits);

    if((pDiscCb->dwNumAdvtsSent <= MAX_INITIAL_ADVTS) and
       RtlLargeIntegerGreaterThan(liRandomTime,SecsToSysUnits(MAX_INITIAL_ADVT_TIME)))
    {
        liRandomTime = SecsToSysUnits(MAX_INITIAL_ADVT_TIME);
    }

    NtQuerySystemTime(&liCurrentTime);

    picb->rdcRtrDiscInfo.tqiTimer.liFiringTime = RtlLargeIntegerAdd(liCurrentTime,liRandomTime);

    //
    // Insert into sorted list
    //

    for(pleNode = g_leTimerQueueHead.Flink;
        pleNode isnot &g_leTimerQueueHead;
        pleNode = pleNode->Flink)
    {
        pOldTime = CONTAINING_RECORD(pleNode,TIMER_QUEUE_ITEM,leTimerLink);

        if(RtlLargeIntegerGreaterThan(pOldTime->liFiringTime,
                                      picb->rdcRtrDiscInfo.tqiTimer.liFiringTime))
        {
            break;
        }
    }

    //
    // Now pleNode points to first Node whose time is greater than ours, so
    // we insert ourselves before pleNode. Since RTL doesnt supply us with
    // an InsertAfter function, we go back on and use the previous node as a
    // list head and call InsertHeadList
    //

    pleNode = pleNode->Blink;

    InsertHeadList(pleNode,
                   &(picb->rdcRtrDiscInfo.tqiTimer.leTimerLink));

    if(pleNode is &g_leTimerQueueHead)
    {
        //
        // We inserted ourselves at the head of the queue
        //

        TraceLeave("SetFiringTimeForAdvt");

        return TRUE;
    }

    TraceLeave("SetFiringTimeForAdvt");

    return FALSE;

}


DWORD
CreateSockets(
    IN PICB picb
    )

/*++

Routine Description

    Activates router discovery messages on an interface. The interface must
    already be bound

Locks

    ICB_LIST lock must be held as WRITER

Arguments

    picb    The ICB of the interface for which the sockets have to be created

Return Value

    NO_ERROR or some error code

--*/

{
    PROUTER_DISC_CB  pDiscCb;
    DWORD            i, dwResult, dwBytesReturned;
    struct linger    lingerOption;
    BOOL             bOption, bLoopback;
    SOCKADDR_IN      sinSockAddr;
    struct ip_mreq   imOption;
    INT              iScope;

    TraceEnter("CreateSockets");

    dwResult = NO_ERROR;

    if(picb->dwNumAddresses is 0)
    {
        Trace1(ERR,
               "CreateSockets: Can not activate router discovery on %S as it has no addresses",
               picb->pwszName);

        TraceLeave("CreateSockets");

        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Create the sockets for the interface
    //

    pDiscCb = &(picb->rdcRtrDiscInfo);

    pDiscCb->pRtrDiscSockets = HeapAlloc(IPRouterHeap,
                                         0,
                                         (picb->dwNumAddresses) * sizeof(SOCKET));

    if(pDiscCb->pRtrDiscSockets is NULL)
    {
        Trace1(ERR,
               "CreateSockets: Error allocating %d bytes for sockets",
               (picb->dwNumAddresses) * sizeof(SOCKET));

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;
    }

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        pDiscCb->pRtrDiscSockets[i] = WSASocket(AF_INET,
                                                SOCK_RAW,
                                                IPPROTO_ICMP,
                                                NULL,
                                                0,
                                                RTR_DISC_SOCKET_FLAGS);

        if(pDiscCb->pRtrDiscSockets[i] is INVALID_SOCKET)
        {
            dwResult = WSAGetLastError();

            Trace3(ERR,
                   "CreateSockets: Couldnt create socket number %d on %S. Error %d",
                   i,
                   picb->pwszName,
                   dwResult);

            continue;
        }

#if 0
        //
        // Set to SO_DONTLINGER
        //

        bOption = TRUE;

        if(setsockopt(pDiscCb->pRtrDiscSockets[i],
                      SOL_SOCKET,
                      SO_DONTLINGER,
                      (const char FAR*)&bOption,
                      sizeof(BOOL)) is SOCKET_ERROR)
        {
            Trace1(ERR,
                   "CreateSockets: Couldnt set linger option - continuing. Error %d",
                   WSAGetLastError());
        }
#endif

        //
        // Set to SO_REUSEADDR
        //

        bOption = TRUE;

        if(setsockopt(pDiscCb->pRtrDiscSockets[i],
                      SOL_SOCKET,
                      SO_REUSEADDR,
                      (const char FAR*)&bOption,
                      sizeof(BOOL)) is SOCKET_ERROR)
        {
            Trace1(ERR,
                   "CreateSockets: Couldnt set reuse option - continuing. Error %d",
                   WSAGetLastError());
        }

        if(WSAEventSelect(pDiscCb->pRtrDiscSockets[i],
                          g_hRtrDiscSocketEvent,
                          FD_READ) is SOCKET_ERROR)
        {
            Trace2(ERR,
                   "CreateSockets: WSAEventSelect() failed for socket on %S.Error %d",
                   picb->pwszName,
                   WSAGetLastError());

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }

        //
        // TBD: Set scope/TTL to 1 since we always multicast the responses
        // Also set Loopback to ignore self generated packets
        //

        //
        // Bind to the addresses on the interface
        //

        sinSockAddr.sin_family      = AF_INET;
        sinSockAddr.sin_addr.s_addr = picb->pibBindings[i].dwAddress;
        sinSockAddr.sin_port        = 0;

        if(bind(pDiscCb->pRtrDiscSockets[i],
                (const struct sockaddr FAR*)&sinSockAddr,
        sizeof(SOCKADDR_IN)) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            Trace3(ERR,
                   "CreateSockets: Couldnt bind to %d.%d.%d.%d on interface %S. Error %d",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName,
                   dwResult);

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }

        bLoopback   = FALSE;

        dwResult = WSAIoctl(pDiscCb->pRtrDiscSockets[i],
                            SIO_MULTIPOINT_LOOPBACK,
                            (PVOID)&bLoopback,
                            sizeof(BOOL),
                            NULL,
                            0,
                            &dwBytesReturned,
                            NULL,
                            NULL);

        if(dwResult is SOCKET_ERROR)
        {
            Trace1(ERR,
                   "CreateSockets: Error %d setting loopback to FALSE",
                   WSAGetLastError());
        }

        iScope  = 1;

        dwResult = WSAIoctl(pDiscCb->pRtrDiscSockets[i],
                            SIO_MULTICAST_SCOPE,
                            (PVOID)&iScope,
                            sizeof(INT),
                            NULL,
                            0,
                            &dwBytesReturned,
                            NULL,
                            NULL);

        if(dwResult is SOCKET_ERROR)
        {
            Trace1(ERR,
                   "CreateSockets: Error %d setting multicast scope to 1",
                   WSAGetLastError());
        }


#if 0

        //
        // Join the multicast session on ALL_ROUTERS_MULTICAST
        //

        sinSockAddr.sin_family      = AF_INET;
        sinSockAddr.sin_addr.s_addr = ALL_ROUTERS_MULTICAST_GROUP;
        sinSockAddr.sin_port        = 0;

        if(WSAJoinLeaf(pDiscCb->pRtrDiscSockets[i],
                       (const struct sockaddr FAR*)&sinSockAddr,
                       sizeof(SOCKADDR_IN),
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       JL_BOTH) is INVALID_SOCKET)
        {
            dwResult = WSAGetLastError();

            Trace2(ERR,
                   "CreateSockets: Couldnt join multicast group on socket for %d.%d.%d.%d on %S",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress)),
                   picb->pwszName);

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }

        //
        // Join the multicast session on ALL_SYSTEMS_MULTICAST
        //

        sinSockAddr.sin_family      = AF_INET;
        sinSockAddr.sin_addr.s_addr = ALL_SYSTEMS_MULTICAST_GROUP;
        sinSockAddr.sin_port        = 0;

        if(WSAJoinLeaf(pDiscCb->pRtrDiscSockets[i],
                       (const struct sockaddr FAR*)&sinSockAddr,
                       sizeof(SOCKADDR_IN),
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       JL_BOTH) is INVALID_SOCKET)
        {
            dwResult = WSAGetLastError();

            Trace2(ERR,
                   "CreateSockets: Couldnt join all systems multicast group on socket for %d.%d.%d.%d on %S",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName);
        }

#endif

        sinSockAddr.sin_addr.s_addr = picb->pibBindings[i].dwAddress;

        if(setsockopt(pDiscCb->pRtrDiscSockets[i],
                      IPPROTO_IP,
                      IP_MULTICAST_IF,
                      (PBYTE)&sinSockAddr.sin_addr,
                      sizeof(IN_ADDR)) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            Trace2(ERR,
                   "CreateSockets: Couldnt join multicast group on socket for %d.%d.%d.%d on %S",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName);

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }

        Trace2(RTRDISC,
               "CreateSockets: Joining ALL_ROUTERS on %d.%d.%d.%d over %S",
               PRINT_IPADDR(picb->pibBindings[i].dwAddress),
               picb->pwszName);

        imOption.imr_multiaddr.s_addr = ALL_ROUTERS_MULTICAST_GROUP;
        imOption.imr_interface.s_addr = picb->pibBindings[i].dwAddress;

        if(setsockopt(pDiscCb->pRtrDiscSockets[i],
                      IPPROTO_IP,
                      IP_ADD_MEMBERSHIP,
                      (PBYTE)&imOption,
                      sizeof(imOption)) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            Trace2(ERR,
                   "CreateSockets: Couldnt join multicast group on socket for %d.%d.%d.%d on %S",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName);

            closesocket(pDiscCb->pRtrDiscSockets[i]);

            pDiscCb->pRtrDiscSockets[i] = INVALID_SOCKET;

            continue;
        }


    }

    TraceLeave("CreateSockets");

    return dwResult;
}

VOID
DeleteSockets(
    IN PICB picb
    )

/*++

Routine Description

    Deletes the sockets (if any) created for running Router Discovery

Locks


Arguments

    picb   The interface whose sockets need to be deleted

Return Value

--*/

{
    PROUTER_DISC_CB     pDiscCb;
    DWORD               i;

    //
    // Cloese the sockets, free the memory
    //

    pDiscCb = &(picb->rdcRtrDiscInfo);

    for(i = 0; i < picb->dwNumAddresses; i++)
    {
        if(pDiscCb->pRtrDiscSockets[i] isnot INVALID_SOCKET)
        {
            closesocket(pDiscCb->pRtrDiscSockets[i]);
        }
    }

    HeapFree(IPRouterHeap,
             0,
             pDiscCb->pRtrDiscSockets);

    pDiscCb->pRtrDiscSockets = NULL;

}

VOID
HandleRtrDiscTimer(
    VOID
    )

/*++

Routine Description

    Processes the firing of the Router Discovery Timer for an interface

Locks

    Called with ICB_LIST held as WRITER. This is needed because ICB_LIST
    protects timer queue, etc. This may seem inefficient, but the Timer will
    go off once in 5 minutes or so, so its worth reducing Kernel Mode footprint
    by reusing the lock

Arguments

    None

Return Value

    None

--*/

{
    LARGE_INTEGER       liCurrentTime;
    PICB                picb;
    PLIST_ENTRY         pleNode;
    PTIMER_QUEUE_ITEM   pTimer;
    BOOL                bReset;
    DWORD               dwResult;
    PROUTER_DISC_CB     pInfo;

    TraceEnter("HandleRtrDiscTimer");

    while(!IsListEmpty(&g_leTimerQueueHead))
    {
        pleNode = g_leTimerQueueHead.Flink;

        pTimer = CONTAINING_RECORD(pleNode, TIMER_QUEUE_ITEM, leTimerLink);

        NtQuerySystemTime(&liCurrentTime);

        if(RtlLargeIntegerGreaterThan(pTimer->liFiringTime,liCurrentTime))
        {
            break;
        }

        RemoveHeadList(&g_leTimerQueueHead);

        //
        // We have the pointer to the timer element. From that
        // we get the pointer to the  Router Discovery Info container
        //

        pInfo   = CONTAINING_RECORD(pTimer, ROUTER_DISC_CB, tqiTimer);

        //
        // From the rtrdisc info we get to the ICB which contains it
        //

        picb    = CONTAINING_RECORD(pInfo, ICB, rdcRtrDiscInfo);

        //
        // Send advt for this interface
        //

        if((picb->rdcRtrDiscInfo.bAdvertise is FALSE) or
           (picb->dwAdminState is IF_ADMIN_STATUS_DOWN) or
           (picb->dwOperationalState < CONNECTED))
        {
            Trace3(ERR,
                   "HandleRtrDiscTimer: Router Discovery went off for interface %S, but current state (%d/%d) doesnt allow tx",
                   picb->pwszName,
                   picb->dwAdminState,
                   picb->dwOperationalState);

            continue;
        }

        IpRtAssert(picb->pRtrDiscAdvt);

        AdvertiseInterface(picb);

        //
        // Insert the next time this interface needs to advt into the queue.
        // Reset the timer
        //

        SetFiringTimeForAdvt(picb);

    }

    //
    // We have to reset the timer
    //

    if(!IsListEmpty(&g_leTimerQueueHead))
    {
        pleNode = g_leTimerQueueHead.Flink;

        pTimer = CONTAINING_RECORD(pleNode, TIMER_QUEUE_ITEM, leTimerLink);

        if(!SetWaitableTimer(g_hRtrDiscTimer,
                             &pTimer->liFiringTime,
                             0,
                             NULL,
                             NULL,
                             FALSE))
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "HandleRtrDiscTimer: Couldnt set waitable timer",
                   dwResult);
        }
    }

    TraceLeave("HandleRtrDiscTimer");
}

VOID
AdvertiseInterface(
    IN PICB picb
    )

/*++

Routine Description


Locks



Arguments

    picb    ICB of the interface on which to send out the advertisement


Return Value

    None

--*/

{
    DWORD i,dwResult,dwNumBytesSent;

    TraceEnter("AdvertiseInterface");

    //
    // If any replies were pending, they are deemed to be sent even if
    // the send fails
    //

    picb->rdcRtrDiscInfo.bReplyPending = FALSE;

    for(i = 0; i < picb->dwNumAddresses; i++)
    {

#if DBG

        Trace2(RTRDISC,
               "Advertising from %d.%d.%d.%d on %S",
               PRINT_IPADDR(picb->pibBindings[i].dwAddress),
               picb->pwszName);

        TraceDumpEx(TraceHandle,
                    IPRTRMGR_TRACE_RTRDISC,
                    picb->wsAdvtWSABuffer.buf,
                    picb->wsAdvtWSABuffer.len,
                    4,
                    FALSE,
                    "ICMP Advt");
#endif

        if(WSASendTo(picb->rdcRtrDiscInfo.pRtrDiscSockets[i],
                     &picb->wsAdvtWSABuffer,
                     1,
                     &dwNumBytesSent,
                     MSG_DONTROUTE,
                     (const struct sockaddr FAR*)&g_sinAllSystemsAddr,
                     sizeof(SOCKADDR_IN),
                     NULL,
                     NULL
            ) is SOCKET_ERROR)
        {
            dwResult = WSAGetLastError();

            Trace3(ERR,
                   "AdvertiseInterface: Couldnt send from %d.%d.%d.%d on %S. Error %d",
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                   picb->pwszName,
                   dwResult);
        }
        else
        {
            picb->rdcRtrDiscInfo.dwNumAdvtsSent++;
        }
    }

    TraceLeave("AdvertiseInterface");
}

DWORD
DeActivateRouterDiscovery(
    IN PICB  picb
    )
{
    PROUTER_DISC_CB     pDiscCb;
    DWORD               i;
    PTIMER_QUEUE_ITEM   pTimer;
    PLIST_ENTRY         pleNode;


    TraceEnter("DeActivateRouterDiscovery");

    pDiscCb = &(picb->rdcRtrDiscInfo);

    if(!pDiscCb->bActive)
    {
        return NO_ERROR;
    }

    DeleteSockets(picb);

    //
    // Check to see if our advertisement is in the front of the queue
    //

    if(&(pDiscCb->tqiTimer.leTimerLink) is &g_leTimerQueueHead)
    {
        RemoveHeadList(&g_leTimerQueueHead);

        if(!IsListEmpty(&g_leTimerQueueHead))
        {
            pleNode = g_leTimerQueueHead.Flink;

            pTimer = CONTAINING_RECORD(pleNode, TIMER_QUEUE_ITEM, leTimerLink);

            if(!SetWaitableTimer(g_hRtrDiscTimer,
                                 &pTimer->liFiringTime,
                                 0,
                                 NULL,
                                 NULL,
                                 FALSE))
            {
                Trace1(ERR,
                       "DeActivateRouterDiscovery: Couldnt set waitable timer",
                       GetLastError());
            }
        }
    }
    else
    {
        //
        // Just remove the timer element from the queue
        //

        RemoveEntryList(&(pDiscCb->tqiTimer.leTimerLink));
    }

    pDiscCb->bActive = FALSE;

    TraceLeave("DeActivateRouterDiscovery");

    return NO_ERROR;
}

VOID
HandleSolicitations(
    VOID
    )

/*++

Routine Description


Locks


Arguments


Return Value

--*/

{
    PLIST_ENTRY           pleNode;
    PICB                  picb;
    DWORD                 i, dwResult, dwRcvAddrLen, dwSizeOfHeader, dwBytesRead, dwFlags;
    WSANETWORKEVENTS      wsaNetworkEvents;
    SOCKADDR_IN           sinFrom;
    PICMP_ROUTER_SOL_MSG  pIcmpMsg;

    TraceEnter("HandleSolicitations");

    for(pleNode = ICBList.Flink;
        pleNode isnot &ICBList;
        pleNode = pleNode->Flink)
    {
        picb = CONTAINING_RECORD(pleNode, ICB, leIfLink);

        //
        // If the interface has no bindings, or isnot involved in Router Discovery, we wouldnt have
        // opened a socket on it so the FD_READ notification cant be for it
        //

        if((picb->dwNumAddresses is 0) or
           (picb->rdcRtrDiscInfo.bActive is FALSE))
        {
            continue;
        }

        for(i = 0; i < picb->dwNumAddresses; i++)
        {
            if(picb->rdcRtrDiscInfo.pRtrDiscSockets[i] is INVALID_SOCKET)
            {
                continue;
            }

            if(WSAEnumNetworkEvents(picb->rdcRtrDiscInfo.pRtrDiscSockets[i],
                                    NULL,
                                    &wsaNetworkEvents) is SOCKET_ERROR)
            {
                dwResult = GetLastError();

                Trace1(ERR,
                       "HandleSolicitations: WSAEnumNetworkEvents() returned %d",
                       dwResult);

                continue;
            }

            if(!(wsaNetworkEvents.lNetworkEvents & FD_READ))
            {
                //
                // Read bit isnot set and we arent interested in anything else
                //

                continue;
            }

            if(wsaNetworkEvents.iErrorCode[FD_READ_BIT] isnot NO_ERROR)
            {
                Trace3(ERR,
                       "HandleSolicitations: Error %d associated with socket %s on %S for FD_READ",
                       wsaNetworkEvents.iErrorCode[FD_READ_BIT],
                       PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                       picb->pwszName);

                continue;
            }

            dwRcvAddrLen = sizeof(SOCKADDR_IN);
            dwFlags = 0;

            dwResult = WSARecvFrom(picb->rdcRtrDiscInfo.pRtrDiscSockets[i],
                                   &g_wsaIpRcvBuf,
                                   1,
                                   &dwBytesRead,
                                   &dwFlags,
                                   (struct sockaddr FAR*)&sinFrom,
                                   &dwRcvAddrLen,
                                   NULL,
                                   NULL);

            if(dwResult is SOCKET_ERROR)
            {
                dwResult = WSAGetLastError();

                Trace4(ERR,
                       "HandleSolicitations: Error %d in WSARecvFrom on  socket %d.%d.%d.%d over %S. Bytes read %d",
                       dwResult,
                       PRINT_IPADDR(picb->pibBindings[i].dwAddress),
                       picb->pwszName,
                       dwBytesRead);

                continue;
            }

            Trace2(RTRDISC,
                   "HandleSolicitations: Received %d bytes on %d.%d.%d.%d",
                   dwBytesRead,
                   PRINT_IPADDR(picb->pibBindings[i].dwAddress));

            if(picb->rdcRtrDiscInfo.bReplyPending)
            {
                //
                // Well the reply is pending so we dont need to do anything other than go
                // through the sockets for this interface and do a recvfrom to clear out the
                // FD_READ bit
                //

                continue;
            }

            dwSizeOfHeader = ((g_pIpHeader->byVerLen)&0x0f)<<2;

            pIcmpMsg = (PICMP_ROUTER_SOL_MSG)(((PBYTE)g_pIpHeader) + dwSizeOfHeader);

#if DBG

            Trace6(RTRDISC,
                   "HandleSolicitations: Type is %d, code %d. IP Length is %d. \n\t\tHeader Length is %d Src is %d.%d.%d.%d dest is %d.%d.%d.%d",
                   (DWORD)pIcmpMsg->byType,
                   (DWORD)pIcmpMsg->byCode,
                   ntohs(g_pIpHeader->wLength),
                   (DWORD)dwSizeOfHeader,
                   PRINT_IPADDR(g_pIpHeader->dwSrc),
                   PRINT_IPADDR(g_pIpHeader->dwDest));
#endif

            if((pIcmpMsg->byType isnot 0xA) or
               (pIcmpMsg->byCode isnot 0x0))
            {
                //
                // Can not be a valid ICMP Router Solicitation packet
                //

                continue;
            }

            if((ntohs(g_pIpHeader->wLength) - dwSizeOfHeader) < 8)
            {
                Trace0(RTRDISC,
                       "HandleSolicitations: Received ICMP packet of length less than 8, discarding");

                continue;
            }

            if(Compute16BitXSum((PVOID)pIcmpMsg,
                                8) isnot 0x0000)
            {
                Trace0(ERR,
                       "HandleSolicitations: ICMP packet checksum wrong");

                continue;
            }

            //
            // Check for valid neighbour
            //

            if((g_pIpHeader->dwSrc isnot 0) and
               ((g_pIpHeader->dwSrc & picb->pibBindings[i].dwMask) isnot
                (picb->pibBindings[i].dwAddress & picb->pibBindings[i].dwMask)))
            {
                Trace1(ERR,
                       "HandleSolicitations: Received ICMP solicitation from invalid neigbour %d.%d.%d.%d",
                       PRINT_IPADDR(g_pIpHeader->dwDest));

                continue;
            }

            //
            // Since we always Multicast, if the destination addresses was a
            // broadcast, log an error
            //

            if((g_pIpHeader->dwDest is 0xFFFFFFFF) or
               (g_pIpHeader->dwDest is (picb->pibBindings[i].dwMask | ~picb->pibBindings[i].dwMask)))
            {
                Trace0(ERR,
                       "HandleSolicitations: Received a broadcast ICMP solicitation");
            }

            //
            // So insert a reply for this interface. We multicast the replies
            // too.
            //

            picb->rdcRtrDiscInfo.bReplyPending = TRUE;

            SetFiringTimeForReply(picb);
        }
    }

    TraceLeave("HandleSolicitations");
}


VOID
SetFiringTimeForReply(
    IN PICB picb
    )

/*++

Routine Description


Locks


Arguments


Return Value


--*/

{
    LARGE_INTEGER       liCurrentTime, liRandomTime;
    INT                 iRand;
    ULONG               ulRem;
    PLIST_ENTRY         pleNode;
    PTIMER_QUEUE_ITEM   pOldTime;
    BOOL                bReset = FALSE;
    DWORD               dwResult;

    TraceEnter("SetFiringTimeForReply");

    //
    // We remove the timer the interface has queued up
    //

    if(g_leTimerQueueHead.Flink is &(picb->rdcRtrDiscInfo.tqiTimer.leTimerLink))
    {
        //
        // Since this timer was the first one, it determined the firing time of the timer.
        //

        bReset = TRUE;
    }

    RemoveEntryList(&(picb->rdcRtrDiscInfo.tqiTimer.leTimerLink));

    iRand = rand();

    liRandomTime = RtlExtendedLargeIntegerDivide(SecsToSysUnits(RESPONSE_DELAY_INTERVAL * iRand),
                                                 RAND_MAX,
                                                 &ulRem);

    liRandomTime = RtlLargeIntegerAdd(liRandomTime,SecsToSysUnits(MIN_RESPONSE_DELAY));

    NtQuerySystemTime(&liCurrentTime);

    picb->rdcRtrDiscInfo.tqiTimer.liFiringTime = RtlLargeIntegerAdd(liCurrentTime,liRandomTime);

    //
    // Insert into sorted list
    //

    for(pleNode = g_leTimerQueueHead.Flink;
        pleNode isnot &g_leTimerQueueHead;
        pleNode = pleNode->Flink)
    {
        pOldTime = CONTAINING_RECORD(pleNode,TIMER_QUEUE_ITEM,leTimerLink);

        if(RtlLargeIntegerGreaterThan(pOldTime->liFiringTime,
                                      picb->rdcRtrDiscInfo.tqiTimer.liFiringTime))
        {
            break;
        }
    }

    pleNode = pleNode->Blink;

    InsertHeadList(pleNode,
                   &(picb->rdcRtrDiscInfo.tqiTimer.leTimerLink));

    if((pleNode is &g_leTimerQueueHead) or bReset)
    {
        //
        // We inserted ourselves at the head of the queue, or took the timer off the front of the
        // queue
        //

        pOldTime = CONTAINING_RECORD(g_leTimerQueueHead.Flink,TIMER_QUEUE_ITEM,leTimerLink);

        if(!SetWaitableTimer(g_hRtrDiscTimer,
                             &pOldTime->liFiringTime,
                             0,
                             NULL,
                             NULL,
                             FALSE))
        {
            dwResult = GetLastError();

            Trace1(ERR,
                   "SetFiringTimeForReply: Error %d setting waitable timer",
                   dwResult);
        }

    }
}

WORD
Compute16BitXSum(
    IN VOID UNALIGNED *pvData,
    IN DWORD dwNumBytes
    )

/*++

Routine Description


Locks


Arguments


Return Value

    16 Bit one's complement of the one's complement sum of dwNumBytes starting
    at pData

--*/

{
    REGISTER WORD  UNALIGNED *pwStart;
    REGISTER DWORD  dwNumWords,i;
    REGISTER DWORD  dwSum = 0;

    pwStart = (PWORD)pvData;

    //
    // If there are odd numbered bytes, that has to be handled differently
    // However we can never have odd numbered bytes in our case so we optimize.
    //


    dwNumWords = dwNumBytes/2;

    for(i = 0; i < dwNumWords; i++)
    {
        dwSum += pwStart[i];
    }

    //
    // Add any carry
    //

    dwSum = (dwSum & 0x0000FFFF) + (dwSum >> 16);
    dwSum = dwSum + (dwSum >> 16);

    return LOWORD((~(DWORD_PTR)dwSum));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\worker.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\worker.c

Abstract:
    IP Router Manager worker thread code

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#include "allinc.h"

extern SOCKET McMiscSocket;

//
// From iphlpapi.h
//

DWORD
NotifyRouteChangeEx(
    PHANDLE      pHandle,
    LPOVERLAPPED pOverLapped,
    BOOL         bExQueue
    );

DWORD
WINAPI
EnableRouter(
    HANDLE* pHandle,
    OVERLAPPED* pOverlapped
    );

DWORD
WINAPI
UnenableRouter(
    OVERLAPPED* pOverlapped,
    LPDWORD lpdwEnableCount OPTIONAL
    );

DWORD
WorkerThread (
    PVOID pGlobalInfo
    )
{
    DWORD       eventindex ;            // index of event notified
    HANDLE      workereventarray [NUMBER_OF_EVENTS] ;  // event array
    PPROTO_CB   protptr ;
    DWORD       dwTimeOut, dwResult, dwByteCount, dwEnableCount;
    OVERLAPPED  RouteChangeOverlapped, SetForwardingOverlapped;
    HANDLE      hTemp;

    TraceEnter("WorkerThread");

    //
    // Prepare list of events that WaitForMultipleObjects will wait on
    //

    workereventarray[EVENT_DEMANDDIAL]        = g_hDemandDialEvent;
    workereventarray[EVENT_IPINIP]            = g_hIpInIpEvent;
    workereventarray[EVENT_STOP_ROUTER]       = g_hStopRouterEvent;
    workereventarray[EVENT_SET_FORWARDING]    = g_hSetForwardingEvent;
    workereventarray[EVENT_FORWARDING_CHANGE] = g_hForwardingChangeEvent;
    workereventarray[EVENT_STACK_CHANGE]      = g_hStackChangeEvent;
    workereventarray[EVENT_ROUTINGPROTOCOL]   = g_hRoutingProtocolEvent ;
    workereventarray[EVENT_RTRDISCTIMER]      = g_hRtrDiscTimer;
    workereventarray[EVENT_RTRDISCSOCKET]     = g_hRtrDiscSocketEvent;
    workereventarray[EVENT_MCMISCSOCKET]      = g_hMcMiscSocketEvent;
    workereventarray[EVENT_MZAPTIMER]         = g_hMzapTimer;
    workereventarray[EVENT_MZAPSOCKET]        = g_hMzapSocketEvent;
    workereventarray[EVENT_RASADVTIMER]       = g_hRasAdvTimer;
    workereventarray[EVENT_MHBEAT]            = g_hMHbeatSocketEvent;
    workereventarray[EVENT_MCAST_0]           = g_hMcastEvents[0];
    workereventarray[EVENT_MCAST_1]           = g_hMcastEvents[1];
    workereventarray[EVENT_MCAST_2]           = g_hMcastEvents[2];
    workereventarray[EVENT_ROUTE_CHANGE_0]    = g_hRouteChangeEvents[0];
    workereventarray[EVENT_ROUTE_CHANGE_1]    = g_hRouteChangeEvents[1];
    workereventarray[EVENT_ROUTE_CHANGE_2]    = g_hRouteChangeEvents[2];


    dwTimeOut = INFINITE;

    //
    // Do a setsockopt to listen for address changes.
    // This must be done in the thread that will wait for the notifications
    //

    dwResult = WSAIoctl(McMiscSocket,
                        SIO_ADDRESS_LIST_CHANGE,
                        NULL,
                        0,
                        NULL,
                        0,
                        &dwByteCount,
                        NULL,
                        NULL);

    if(dwResult is SOCKET_ERROR)
    {
        dwResult = WSAGetLastError();

        if((dwResult isnot WSAEWOULDBLOCK) and
           (dwResult isnot WSA_IO_PENDING) and
           (dwResult isnot NO_ERROR))
        {

            Trace1(ERR,
                   "WorkerThread: Error %d from SIO_ADDRESS_LIST_CHANGE",
                   dwResult);
        }
    }


    ZeroMemory(&SetForwardingOverlapped,
               sizeof(SetForwardingOverlapped));

#if 1

    for (
        eventindex = 0; 
        eventindex < NUM_ROUTE_CHANGE_IRPS; 
        eventindex++
        )
    {
        PostIoctlForRouteChangeNotification(eventindex);
    }

#else
    ZeroMemory(&RouteChangeOverlapped,
               sizeof(RouteChangeOverlapped));

    RouteChangeOverlapped.hEvent = g_hStackChangeEvent;

    hTemp = NULL;

    dwResult = NotifyRouteChangeEx(&hTemp,
                                   &RouteChangeOverlapped,
                                   TRUE);

    if((dwResult isnot NO_ERROR) and
       (dwResult isnot ERROR_IO_PENDING))
    {
        Trace1(ERR,
               "WorkerThread: Error %d from NotifyRouteChange",
               dwResult);
    }
#endif

    __try
    {
        while(TRUE)
        {
            eventindex = WaitForMultipleObjectsEx(NUMBER_OF_EVENTS,
                                                  workereventarray, 
                                                  FALSE,
                                                  dwTimeOut,
                                                  TRUE);
        
            switch(eventindex) 
            {
                case WAIT_IO_COMPLETION:
                {
                    continue ;                  // handle alertable wait case
                }

                case EVENT_DEMANDDIAL:
                {
                    Trace0(DEMAND,
                           "WorkerThread: Demand Dial event received");
                    
                    HandleDemandDialEvent();
                    
                    break ;
                }

                case EVENT_IPINIP:
                {
                    Trace0(DEMAND,
                           "WorkerThread: IpInIp event received");

                    HandleIpInIpEvent();

                    break ;
                }

                case EVENT_STOP_ROUTER:
                case WAIT_TIMEOUT:
                {
                    Trace0(GLOBAL,
                           "WorkerThread: Stop router event received");
                    
                    // *** Exclusion Begin ***
                    ENTER_READER(ICB_LIST);

                    // *** Exclusion Begin ***
                    ENTER_WRITER(PROTOCOL_CB_LIST);

                    //
                    // If all interfaces havent been deleted we switch to 
                    // polling mode where we get up every 
                    // INTERFACE_DELETE_POLL_TIME and check
                    //
                    
                    if(!IsListEmpty(&ICBList))
                    {
                        //
                        // Now wakeup every two second to check
                        //
                        
                        dwTimeOut = INTERFACE_DELETE_POLL_TIME;
                        
                        EXIT_LOCK(PROTOCOL_CB_LIST);
                    
                        EXIT_LOCK(ICB_LIST);
                    
                        break ;
                    }
                    else
                    {
                        //
                        // Get out of polling mode
                        //

                        dwTimeOut = INFINITE;
                    }

                    //
                    // Since all interfaces are now gone, we can delete the 
                    // internal interface
                    //

                    if(g_pInternalInterfaceCb)
                    {
                        DeleteInternalInterface();
                    }

                    NotifyRoutingProtocolsToStop() ;    // tells routing protocols to stop.
                    //
                    // Well interfaces have been deleted, so what about 
                    // protocols?
                    //
                    
                    WaitForAPIsToExitBeforeStopping() ;     // returns when it is safe to stop router

                    if (AllRoutingProtocolsStopped())
                    {
                        //
                        // This check is done here since all routing protocols 
                        // may have stopped synchronously, in which case 
                        // we can safely stop
                        //

                        EXIT_LOCK(PROTOCOL_CB_LIST);

                        EXIT_LOCK(ICB_LIST);
                       
                        __leave;
                    }

                    //
                    // All interfaces have been deleted but some protocol is
                    // still running. We will get a EVENT_ROUTINGPROTOCOL
                    // notification
                    //
                    
                    EXIT_LOCK(PROTOCOL_CB_LIST);
                    
                    EXIT_LOCK(ICB_LIST);

                    // make sure mrinfo/mtrace service is stopped
                    StopMcMisc();

                    if ( g_bEnableNetbtBcastFrowarding )
                    {
                        RestoreNetbtBcastForwardingMode();
                        g_bEnableNetbtBcastFrowarding = FALSE;
                    }
                    
                    break ;
                }

                case EVENT_SET_FORWARDING:
                {
                    hTemp = NULL;

                    EnterCriticalSection(&g_csFwdState);

                    //
                    // If our current state matches the user's request
                    // just free the message and move on
                    //

                    if(g_bEnableFwdRequest is g_bFwdEnabled)
                    {
                        LeaveCriticalSection(&g_csFwdState);

                        break;
                    }

                    SetForwardingOverlapped.hEvent = g_hForwardingChangeEvent;

                    if(g_bEnableFwdRequest)
                    {
                        Trace0(GLOBAL,
                               "WorkerThread: **--Enabling forwarding--**\n\n");

                        dwResult = EnableRouter(&hTemp,
                                                &SetForwardingOverlapped);

                        g_bFwdEnabled = TRUE;
                    }
                    else
                    {
                        Trace0(GLOBAL,
                               "WorkerThread: **--Disabling forwarding--**\n\n");

                        dwResult = UnenableRouter(&SetForwardingOverlapped,
                                                  &dwEnableCount);

                        g_bFwdEnabled = FALSE;
                    }

                    if((dwResult isnot NO_ERROR) and
                       (dwResult isnot ERROR_IO_PENDING))
                    {
                        Trace1(ERR,
                               "WorkerThread: Error %d from call",
                               dwResult);
                    }

                    LeaveCriticalSection(&g_csFwdState);

                    break;
                }

                case EVENT_FORWARDING_CHANGE:
                {
                    Trace0(GLOBAL,
                           "WorkerThread: **--Forwarding change event--**\n\n");

                    break;
                }

                case EVENT_STACK_CHANGE:
                {
                    Trace0(GLOBAL,
                           "WorkerThread: Stack Change event received");


                    UpdateDefaultRoutes();

                    dwResult = NotifyRouteChangeEx(&hTemp,
                                                   &RouteChangeOverlapped,
                                                   TRUE);
                    
                    if((dwResult isnot NO_ERROR) and
                       (dwResult isnot ERROR_IO_PENDING))
                    {
                        Trace1(ERR,
                               "WorkerThread: Error %d from NotifyRouteChangeEx",
                               dwResult);

                        //
                        // If there was an error, try again
                        //

                        NotifyRouteChangeEx(&hTemp,
                                            &RouteChangeOverlapped,
                                            TRUE);
                    }

                    break;
                }
            
                case EVENT_ROUTINGPROTOCOL:
                {
                    Trace0(GLOBAL,
                           "WorkerThread: Routing protocol notification received");

                    HandleRoutingProtocolNotification() ;
                    
                    if((RouterState.IRS_State is RTR_STATE_STOPPING) and
                       IsListEmpty(&ICBList) and 
                       AllRoutingProtocolsStopped())
                    {
                        __leave;
                    }
                    
                    break ;
                }

                case EVENT_RASADVTIMER:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                        Trace0(IF,
                               "WorkerThread: Router discovery timer fired while shutting down. Ignoring");
                    
                        LeaveCriticalSection(&RouterStateLock);

                        break;
                    }

                    LeaveCriticalSection(&RouterStateLock);
 
                    Trace0(MCAST,
                           "WorkerThread: RasAdv Timer event received");
                    
                    HandleRasAdvTimer();
                    
                    break;
                }

                case EVENT_RTRDISCTIMER:
                {
                    PLIST_ENTRY      pleTimerNode;
                    PROUTER_DISC_CB  pDiscCb;

                                       
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                        Trace0(IF,
                               "WorkerThread: Router discovery timer fired while shutting down. Ignoring");
                    
                        LeaveCriticalSection(&RouterStateLock);

                        break;
                    }

                    LeaveCriticalSection(&RouterStateLock);
 

                    ENTER_WRITER(ICB_LIST);
                    
                    Trace0(RTRDISC,
                           "WorkerThread: Router Discovery Timer event received");
                    
                    if(IsListEmpty(&g_leTimerQueueHead))
                    {
                        //
                        // Someone removed the timer item from under us 
                        // and happened to empty the timer queue. Since we 
                        // are a non-periodic timer, we will not 
                        // fire again so no problem
                        //
                        
                        Trace0(RTRDISC,
                               "WorkerThread: Router Discovery Timer went off but no timer items");
                        
                        EXIT_LOCK(ICB_LIST);
                        
                        break;
                    }
                    
                    HandleRtrDiscTimer();
                    
                    EXIT_LOCK(ICB_LIST);
                    
                    break;
                }

                case EVENT_RTRDISCSOCKET:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                        Trace0(IF,
                               "WorkerThread: FD_READ while shutting down. Ignoring");
                    
                        LeaveCriticalSection(&RouterStateLock);

                        break;
                    }

                    LeaveCriticalSection(&RouterStateLock);
 

                    ENTER_WRITER(ICB_LIST);
                    
                    HandleSolicitations();
                    
                    EXIT_LOCK(ICB_LIST);
                    
                    break;
                }

                case EVENT_MCMISCSOCKET:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                       Trace0(IF,
                        "WorkerThread: FD_READ while shutting down. Ignoring");

                       LeaveCriticalSection(&RouterStateLock);

                       break;
                    }

                    LeaveCriticalSection(&RouterStateLock);


                    HandleMcMiscMessages();

                    break;
                }

                case EVENT_MZAPTIMER:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                        Trace0(IF,
                               "WorkerThread: Router discovery timer fired while shutting down. Ignoring");
                    
                        LeaveCriticalSection(&RouterStateLock);

                        break;
                    }

                    LeaveCriticalSection(&RouterStateLock);

                    HandleMzapTimer();
                    
                    break;
                }

                case EVENT_MZAPSOCKET:
                {
                    EnterCriticalSection(&RouterStateLock);

                    if(RouterState.IRS_State isnot RTR_STATE_RUNNING)
                    {
                       Trace0(IF,
                        "WorkerThread: FD_READ while shutting down. Ignoring");

                       LeaveCriticalSection(&RouterStateLock);

                       break;
                    }

                    LeaveCriticalSection(&RouterStateLock);

                    HandleMZAPMessages();

                    break;
                }

                case EVENT_MCAST_0:
                case EVENT_MCAST_1:
                case EVENT_MCAST_2:
                {
                    HandleMcastNotification(eventindex - EVENT_MCAST_0);

                    break;
                }

                case EVENT_ROUTE_CHANGE_0:
                case EVENT_ROUTE_CHANGE_1:
                case EVENT_ROUTE_CHANGE_2:
                {
                    HandleRouteChangeNotification(
                        eventindex - EVENT_ROUTE_CHANGE_0
                        );

                    break;
                }
                
                default:
                {
                    Trace1(ERR,
                           "WorkerThread: Wait failed with following error %d", 
                           GetLastError());
                    
                    break;
                }
            }
        }
    }
    __finally
    {
        Trace0(GLOBAL,
               "WorkerThread: Worker thread stopping");
        
        RouterManagerCleanup();

        RouterState.IRS_State = RTR_STATE_STOPPED;

        (RouterStopped) (PID_IP, 0);
    }

    FreeLibraryAndExitThread(g_hOwnModule,
                             NO_ERROR);

    return NO_ERROR;
}

VOID
WaitForAPIsToExitBeforeStopping(
    VOID
    )
{
    DWORD sleepcount = 0 ;

    TraceEnter("WaitForAPIsToExitBeforeStopping");
    
    //
    // Wait for refcount to trickle down to zero: this indicates that no
    // threads are in the router now
    //
    
    while(RouterState.IRS_RefCount != 0) 
    {
        if (sleepcount++ > 20)
        {
            Trace0(ERR,
                   "WaitForAPIsToExitBeforeStopping: RouterState.IRS_Refcount not decreasing");
        }
        
        Sleep (200L);
    }

    TraceLeave("WaitForAPIsToExitBeforeStopping");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\stack.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:

Revision History:

    Amritansh Raghav

--*/
#include "allinc.h"
//
// Definitions
//

//*****************************************************************************
//
// Name:        GetIpAddrTableFromStack
//
// Description:
//
// Parameters:  IPAddrEntry *lpipaeTable, LPDWORD lpdwNumEntries, BOOL bOrder
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetIpAddrTableFromStack(IPAddrEntry *lpipaeTable, LPDWORD lpdwNumEntries, 
                        BOOL bOrder, BOOL bMap)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    DWORD                              i,j;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    BYTE                             *Context;
    
    TraceEnter("GetIpAddrTableFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    
    dwOutBufLen = (*lpdwNumEntries) * sizeof( IPAddrEntry );
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (LPVOID)lpipaeTable,
                                     &dwOutBufLen );
    
    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIpAddrTableFromStack: NtStatus %x querying IpAddrTable from stack",
               dwResult);

        TraceLeave("GetIpAddrTableFromStack");
    
        return dwResult;
    }
    
    *lpdwNumEntries =(dwOutBufLen / sizeof(IPAddrEntry));
    
    //
    // Now sort the address table.  Key is IP address.
    //
    
    if(*lpdwNumEntries > 0)
    { 
        if(bMap)
        {
            for (i = 0; i < (*lpdwNumEntries); i++ )
            {
                lpipaeTable[i].iae_index = GetInterfaceFromAdapter(lpipaeTable[i].iae_index);
            }
        }
        
        if(bOrder)
        {
            for (i = 0; i < (*lpdwNumEntries) - 1; i++ )
            {
                IPAddrEntry tempEntry;
                DWORD min;
                LONG  lCompare; 
                min = i;
                
                for (j = i + 1; j < *lpdwNumEntries; j++ )
                {
                    if(InetCmp(lpipaeTable[min].iae_addr,lpipaeTable[j].iae_addr,lCompare) > 0)
                    {
                        min = j;
                    }
                }
                if(min isnot i)
                {
                    tempEntry = lpipaeTable[min];
                    lpipaeTable[min] = lpipaeTable[i];
                    lpipaeTable[i] = tempEntry;
                }
            }
        }
    }

    TraceLeave("GetIpAddrTableFromStack");
    
    return NO_ERROR;
}


//*****************************************************************************
//
// Name:        GetTcpConnTableFromStack
//
// Description: Reads and sorts the route table from the stack.
//
// Parameters:  TCPConnTableEntry *lptcteTable, LPDWORD lpdwNumEntries, BOOL bOrder
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetTcpTableFromStack(TCPConnTableEntry *lptcteTable, LPDWORD lpdwNumEntries, BOOL bOrder)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    DWORD                              i,j;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    BYTE                              *Context;
    TCPStats                           TcpInfo;
    DWORD                              NumConn;
    DWORD                              *IndTab;
    LONG                               CmpResult;
    
    
    TraceEnter("GetTcpTableFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = (*lpdwNumEntries) * sizeof(TCPConnTableEntry);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CO_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = TCP_MIB_TABLE_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (LPVOID)lptcteTable,
                                     &dwOutBufLen);
    
    if (dwResult isnot NO_ERROR )
    {
        Trace1(ERR,
               "GetTcpTableFromStack: NtStatus %x querying TcpConnTable from stack",
               dwResult);

        TraceLeave("GetTcpTableFromStack");
    
        return dwResult;
    }
    
    *lpdwNumEntries = (dwOutBufLen/sizeof(TCPConnTableEntry));

    //
    // Now sort the TCP connection table.  Keys are: local address, local
    // port, remote address, and remote port.
    //

    if((*lpdwNumEntries > 0) and bOrder)
    {
        for ( i = 0; i < (*lpdwNumEntries) - 1 ; i++ )
        {
            TCPConnTableEntry tempEntry;
            DWORD min;
            min = i;
            
            for ( j = i+1; j < *lpdwNumEntries ; j++ )
            {
                if(TcpCmp(lptcteTable[min].tct_localaddr,lptcteTable[min].tct_localport,
                          lptcteTable[min].tct_remoteaddr,lptcteTable[min].tct_remoteport,
                          lptcteTable[j].tct_localaddr,lptcteTable[j].tct_localport,
                          lptcteTable[j].tct_remoteaddr,lptcteTable[j].tct_remoteport) > 0)
                {
                    min = j;
                }
            }
            if(min isnot i)
            {
                tempEntry      = lptcteTable[min];
                lptcteTable[min] = lptcteTable[i];
                lptcteTable[i]   = tempEntry;
            }
        }
    }

    TraceLeave("GetTcpTableFromStack");
    
    return NO_ERROR;
}

DWORD 
SetTcpRowToStack(TCPConnTableEntry *tcpRow)
{
    TCP_REQUEST_SET_INFORMATION_EX    *lptrsiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    TCPConnTableEntry                 *copyInfo;
    DWORD                             dwInBufLen,dwOutBufLen,dwResult;

    TraceEnter("SetTcpRowToStack");

    dwInBufLen = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(TCPConnTableEntry) - 1;
    
    lptrsiInBuf = HeapAlloc(GetProcessHeap(),0,dwInBufLen);
    
    if(lptrsiInBuf is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,
               "SetTcpRowToStack: Error %d allocating memory",
               dwResult);

        TraceLeave("SetTcpRowToStack");

        return dwResult;
    }
    
    ID = &lptrsiInBuf->ID;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_entity.tei_entity = CO_TL_ENTITY;
    ID->toi_id = TCP_MIB_TABLE_ID;
    ID->toi_entity.tei_instance = 0;
   
    lptrsiInBuf->BufferSize = sizeof(TCPConnTableEntry);
 
    copyInfo = (TCPConnTableEntry*)lptrsiInBuf->Buffer;
    *copyInfo = *tcpRow;
    
    dwResult = TCPSetInformationEx(g_hTcpDevice,
                                   (LPVOID)lptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);
    
    HeapFree(GetProcessHeap(),0,lptrsiInBuf);

    TraceLeave("SetTcpRowToStack");

    return dwResult;
}


//*****************************************************************************
//
// Name:        GetUdpConnTableFromStack
//
// Description: Reads and sorts the route table from the stack.
//
// Parameters:  UDPEntry *lpueTable, LPDWORD lpdwNumEntries, BOOL bOrder
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetUdpTableFromStack(UDPEntry *lpueTable, LPDWORD lpdwNumEntries, BOOL bOrder)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    DWORD                              i,j;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;

    TraceEnter("GetUdpTableFromStack");

    //
    // Determine number of connections via the UDPStats structure
    //
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    dwOutBufLen = (*lpdwNumEntries) * sizeof(UDPEntry);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = UDP_MIB_TABLE_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (LPVOID)lpueTable,
                                     &dwOutBufLen );
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetUdpTableFromStack: NtStatus %x querying UdpTable from stack",
               dwResult);

        TraceLeave("GetUdpTableFromStack");
        
        return dwResult;
    }
    
    *lpdwNumEntries =(dwOutBufLen / sizeof(UDPEntry));

    //
    // Now sort the UDP connection table.  Keys are: local address, and local
    // port.
    //

    if((*lpdwNumEntries > 0) and bOrder)
    {
        for ( i = 0; i < (*lpdwNumEntries) - 1; i++ )
        {
            UDPEntry tempEntry;
            DWORD    min;
            min = i;
            
            for ( j = i + 1; j < (*lpdwNumEntries) ; j++ )
            {
                if(UdpCmp(lpueTable[min].ue_localaddr,
                          lpueTable[min].ue_localport,
                          lpueTable[j].ue_localaddr,
                          lpueTable[j].ue_localport) > 0)
                {
                    min = j;
                }
            }
            if(min isnot i)
            {
                tempEntry = lpueTable[min];
                lpueTable[min] = lpueTable[i];
                lpueTable[i] = tempEntry;
            }
        }
    }

    TraceLeave("GetUdpTableFromStack");
        
    return NO_ERROR;
}



//*****************************************************************************
//
// Name:        GetIpStatsFromStack
//
// Description: Read the IPSNMPInfo structure from the stack.
//
// Parameters:  IPSNMPInfo *IPSnmpInfo
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetIpStatsFromStack(IPSNMPInfo *IPSnmpInfo)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    BYTE                             *Context;

    TraceEnter("GetIpStatsFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(IPSNMPInfo);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_STATS_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory(Context, CONTEXT_SIZE);
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     IPSnmpInfo,
                                     &dwOutBufLen);
    
    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIpStatsFromStack: NtStatus %x querying IpStats from stack",
               dwResult);

        TraceLeave("GetIpStatsFromStack");

        return dwResult;
    }

    TraceLeave("GetIpStatsFromStack");

    return NO_ERROR;
}

DWORD 
SetIpInfoToStack(IPSNMPInfo *ipsiInfo)
{
    TCP_REQUEST_SET_INFORMATION_EX    *lptrsiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    IPSNMPInfo                        *copyInfo;
    DWORD                             dwInBufLen,dwOutBufLen,dwResult;

    TraceEnter("SetIpInfoToStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPSNMPInfo) - 1;
    
    lptrsiInBuf = HeapAlloc(GetProcessHeap(),0,dwInBufLen);
    
    if(lptrsiInBuf is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,
               "SetIpInfoToStack: Error %d allocating memory",
               dwResult);

        TraceLeave("SetIpInfoToStack");

        return dwResult;
    }
  
    ID = &lptrsiInBuf->ID;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_id = IP_MIB_STATS_ID;
    ID->toi_entity.tei_instance = 0;
    
    copyInfo = (IPSNMPInfo*)lptrsiInBuf->Buffer;
    *copyInfo = *ipsiInfo;
    
    dwResult = TCPSetInformationEx(g_hTcpDevice,
                                   (LPVOID)lptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);

    TraceLeave("SetIpInfoToStack");

    return dwResult;
}

//*****************************************************************************
//
// Name:        GetIcmpStatsFromStack
//
// Description: Read the ICMPSNMPInfo structure from the stack.
//
// Parameters:  ICMPSNMPInfo *ICMPSnmpInfo 
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetIcmpStatsFromStack( ICMPSNMPInfo *ICMPSnmpInfo )
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;

    TraceEnter("GetIcmpStatsFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(ICMPSNMPInfo);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = ER_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = ICMP_MIB_STATS_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory(Context,CONTEXT_SIZE);
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     ICMPSnmpInfo,
                                     &dwOutBufLen );

    if (dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIcmpStatsFromStack: NtStatus %x querying IcmpStats from stack",
               dwResult);

        TraceLeave("GetIcmpStatsFromStack");
        
        return dwResult;
    }

    TraceLeave("GetIcmpStatsFromStack");
        
    return NO_ERROR;
}


//*****************************************************************************
//
// Name:        GetUdpStatsFromStack
//
// Description: Read the UDPStats structure from the stack.
//
// Parameters:  UDPStats *UdpInfo
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetUdpStatsFromStack(UDPStats *UdpInfo)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                              *Context;

    TraceEnter("GetUdpStatsFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(UDPStats);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = UDP_MIB_STAT_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     UdpInfo,
                                     &dwOutBufLen );

    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetUdpStatsFromStack: NtStatus %x querying UdpStats from stack",
               dwResult);

        TraceLeave("GetUdpStatsFromStack");
    
        return dwResult;
    }

    TraceLeave("GetUdpStatsFromStack");
    
    return NO_ERROR;
}


//*****************************************************************************
//
// Name:        GetTCPStats
//
// Description: Read the TCPStats structure from the stack.
//
// Parameters:
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetTcpStatsFromStack(TCPStats *TcpInfo)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;

    TraceEnter("GetTcpStatsFromStack");
    
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    dwOutBufLen = sizeof( TCPStats );
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CO_TL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = TCP_MIB_STAT_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory(Context,CONTEXT_SIZE);
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     TcpInfo,
                                     &dwOutBufLen );
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetTcpStatsFromStack: NtStatus %x querying TcpStats from stack",
               dwResult);

        TraceLeave("GetTcpStatsFromStack");
    
        return dwResult;
    }

    TraceLeave("GetTcpStatsFromStack");
    
    return NO_ERROR;
}

//*****************************************************************************
//
// Name:        GetRouteTableFromStack
//
// Description: Reads all the routes from the stack. This is needed because the ICMP redirect
//                routes are only kept in the stack and cant be queried from RTM
//
// Parameters:
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************



DWORD 
GetIpRouteTableFromStack(IPRouteEntry *lpireTable,LPDWORD lpdwNumEntries, BOOL bOrder)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    UCHAR                              *Context;
    TDIObjectID                        *ID;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    IPSNMPInfo                         ipsiInfo;

    TraceEnter("GetIpRouteTableFromStack");
    
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    dwOutBufLen = *lpdwNumEntries * sizeof(IPRouteEntry);
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     (LPVOID)lpireTable,
                                     &dwOutBufLen );
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "GetIpRouteTableFromStack: NtStatus %x querying IpRouteTable from stack",
               dwResult);
        
        TraceLeave("GetIpRouteTableFromStack");
    
        return dwResult;
    }
    
    *lpdwNumEntries = (dwOutBufLen / sizeof( IPRouteEntry ));
    
    if((*lpdwNumEntries > 0) and bOrder)
    {
        DWORD i,j;
        for (i = 0; i < (*lpdwNumEntries) - 1; i++ )
        {
            IPRouteEntry tempEntry;
            DWORD min;
            LONG lCompare;
            min = i;
            
            for (j = i + 1; j < *lpdwNumEntries; j++ )
            {
                if(InetCmp(lpireTable[min].ire_dest,lpireTable[j].ire_dest,lCompare) > 0)
                {
                    min = j;
                }
            }
            if(min isnot i)
            {
                tempEntry = lpireTable[min];
                lpireTable[min] = lpireTable[i];
                lpireTable[i] = tempEntry;
            }
        }
    }

    TraceLeave("GetIpRouteTableFromStack");
    
    return NO_ERROR;
}

//*****************************************************************************
//
// Name:        GetARPEntityTable
//
// Description: Builds a list of AT entities. that support ARP. Keeps it in the global
//                 entity table
//
// Parameters:
//
// Returns:     DWORD: NO_ERROR or some error code.
//
// History:
//
//*****************************************************************************

DWORD 
GetArpEntTableFromStack(DWORD **lpArpEntTable,
                        LPDWORD lpdwSize, 
                        LPDWORD lpdwValid,
                        HANDLE hHeap)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    DWORD                              dwATType;
    UCHAR                              *Context;
    TDIObjectID                        *ID;
    LPVOID                             lpOutBuf;
    TDIEntityID                        *lpEntTable;
    DWORD                              dwNumEntities;
    DWORD                              i,dwCount ;

    TraceEnter("GetArpEntTableFromStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = MAX_TDI_ENTITIES * sizeof(TDIEntityID);
    
    lpOutBuf = HeapAlloc(GetProcessHeap(),0,dwOutBufLen);

    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = GENERIC_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_GENERIC;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = ENTITY_LIST_ID;
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory(Context, CONTEXT_SIZE);
    
    if(lpOutBuf is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,"GetArpEntTableFromStack: Error %d allocating memory",
               dwResult);
        
        TraceLeave("GetArpEntTableFromStack");
    
        return dwResult;
    }
    
    dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                     &trqiInBuf,
                                     &dwInBufLen,
                                     lpOutBuf,
                                     &dwOutBufLen);
    
    if ( dwResult != NO_ERROR )
    {
        Trace1(ERR,
               "GetArpEntTableFromStack: NtStatus %x querying TDI Entities from stack",
               dwResult);
        
        HeapFree(GetProcessHeap(),0,lpOutBuf);
        
        TraceLeave("GetArpEntTableFromStack");
    
        return dwResult;
    }

    //
    // Now we have all the entities
    //
    
    dwNumEntities = dwOutBufLen / sizeof( TDIEntityID );
    
    dwCount = 0;
    lpEntTable = (TDIEntityID*)lpOutBuf;
    
    for(i = 0; i < dwNumEntities; i++)
    {
        //
        // See which ones are AT
        //
        
        if(lpEntTable[i].tei_entity is AT_ENTITY)
        {
            //
            // Query the entity to see if it supports ARP
            //
            
            ID->toi_entity.tei_entity = AT_ENTITY;
            ID->toi_class = INFO_CLASS_GENERIC;
            ID->toi_type = INFO_TYPE_PROVIDER;
            ID->toi_id = ENTITY_TYPE_ID;
            ID->toi_entity.tei_instance = lpEntTable[i].tei_instance;
            dwOutBufLen = sizeof(dwATType);
            
            ZeroMemory(Context,CONTEXT_SIZE);

            dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                             &trqiInBuf,
                                             &dwInBufLen,
                                             (LPVOID)&dwATType,
                                             &dwOutBufLen );
            
            if(dwResult is STATUS_INVALID_DEVICE_REQUEST)
            {
                continue;
            }
            if(dwResult isnot NO_ERROR)
            {
                HeapFree(GetProcessHeap(),0,lpOutBuf);
                return dwResult;
            }
            
            if(dwATType is AT_ARP)
            {
                
                if(dwCount is *lpdwSize)
                {
                    //
                    // Realloc more memory
                    //

                    *lpArpEntTable = (LPDWORD)HeapReAlloc(hHeap,
                                                          0,
                                                          (LPVOID)*lpArpEntTable,
                                                          ((*lpdwSize)<<1)*sizeof(DWORD));
                    if(*lpArpEntTable is NULL)
                    {
                        dwResult = GetLastError();
                        
                        Trace1(ERR,
                               "GetArpEntTableFromStack: Error %d reallocating memory",
                               dwResult);
                        
                        TraceLeave("GetArpEntTableFromStack");
    
                        return dwResult;
                    }
                    
                    *lpdwSize = (*lpdwSize)<<1;
                }
                
                (*lpArpEntTable)[dwCount++] = lpEntTable[i].tei_instance;
            }
        }
    }
    
    *lpdwValid = dwCount;
    
    HeapFree(GetProcessHeap(),0,lpOutBuf);
    
    TraceLeave("GetArpEntTableFromStack");
    
    return NO_ERROR;
}

// Called only if you are a IPNET reader

DWORD 
UpdateAdapterToATInstanceMap()
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              i;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    DWORD                              dwSize;
    AddrXlatInfo                       AXI;

    TraceEnter("UpdateAdapterToATInstanceMap");
    
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    
    Context = &(trqiInBuf.Context[0]);
    ID = &(trqiInBuf.ID);

    //
    // Maybe we should first clear out all the mappings
    //
    
    for (i = 0; i < g_IpInfo.dwValidArpEntEntries; i++ )
    {
        
        ID->toi_entity.tei_entity = AT_ENTITY;
        ID->toi_type = INFO_TYPE_PROVIDER;
        ID->toi_class = INFO_CLASS_PROTOCOL;
        ID->toi_id = AT_MIB_ADDRXLAT_INFO_ID;
        ID->toi_entity.tei_instance = g_IpInfo.arpEntTable[i];
        
        dwSize = sizeof(AXI);
        ZeroMemory(Context, CONTEXT_SIZE);
        
        dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         &AXI,
                                         &dwSize );
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "UpdateAdapterToATInstanceMap: NtStatus %x querying ArpInfo from stack",
                   dwResult);

            TraceLeave("UpdateAdapterToATInstanceMap");
    
            return dwResult;
        }
        
        StoreAdapterToATInstanceMap(AXI.axi_index,g_IpInfo.arpEntTable[i]);
    }

    TraceLeave("UpdateAdapterToATInstanceMap");
    
    return NO_ERROR;
}

DWORD 
GetIpNetTableFromStackEx(LPDWORD arpEntTable,
                         DWORD dwValidArpEntEntries,
                         IPNetToMediaEntry **lpNetTable,
                         LPDWORD lpdwTotalEntries,
                         LPDWORD lpdwValidEntries,
                         BOOL bOrder,
                         HANDLE hHeap)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    DWORD                              i,j;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    DWORD                              dwNetEntryCount,dwNumAdded,dwValidNetEntries;
    DWORD                              dwSize,dwNeed;
    AddrXlatInfo                       AXI;
    IPNetToMediaEntry                  *lpOutBuf,tempEntry;
    
    dwInBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    
    Context = &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );
    
    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = AT_ENTITY;
    ID->toi_type = INFO_TYPE_PROVIDER;
    
    dwNetEntryCount = 0;
    
    for (i = 0; i < dwValidArpEntEntries; i++ )
    {
        // First add up the AXI counts
        ID->toi_class = INFO_CLASS_PROTOCOL;
        ID->toi_id = AT_MIB_ADDRXLAT_INFO_ID;
        ID->toi_entity.tei_instance = arpEntTable[i];
        dwSize = sizeof(AXI);
        ZeroMemory(Context, CONTEXT_SIZE);
        
        dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         &AXI,
                                         &dwSize );
        
        if(dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "GetIpNetTableFromStackEx: NtStatus %x querying information from stack",
                   dwResult);

            TraceLeave("GetIpNetTableFromStackEx");
            
            return dwResult;
        }

        //
        // At this point map the index to the instance - the index is the adapter 
        // index though the instance is not the same as IFInstance
        //
        
        StoreAdapterToATInstanceMap(AXI.axi_index,arpEntTable[i]);

        dwNetEntryCount += AXI.axi_count;
    }

    //
    // This is generally a memory hog
    //
    
    dwNeed = dwNetEntryCount + (dwValidArpEntEntries) * SPILLOVER;
    
    if(dwNeed > *lpdwTotalEntries) 
    {
        if(*lpdwTotalEntries)
        {
            HeapFree(hHeap,0,*lpNetTable);
        }
        
        dwNeed += MAX_DIFF;

        //
        // Serialize the heap ???
        //
        
        *lpNetTable = (IPNetToMediaEntry*)HeapAlloc(hHeap,0,
                                                    dwNeed*sizeof(IPNetToMediaEntry));
        if(*lpNetTable is NULL)
        {
            dwResult = GetLastError();
            
            Trace1(ERR,
                   "GetIpNetTableFromStackEx: Error %d allocating memory for IpNetTable",
                   dwResult);

            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        *lpdwTotalEntries = dwNeed;
    }
    else
    {
        dwNeed = *lpdwTotalEntries;
    }
    
    
    lpOutBuf = *lpNetTable;
    dwOutBufLen = dwNeed * sizeof(IPNetToMediaEntry);
    
    dwValidNetEntries = 0;
  
    for(i = 0; i < dwValidArpEntEntries; i++ )
    {
        ID->toi_class = INFO_CLASS_PROTOCOL;
        ID->toi_id = AT_MIB_ADDRXLAT_ENTRY_ID;
        ID->toi_entity.tei_instance = arpEntTable[i];
        ZeroMemory( Context, CONTEXT_SIZE );
        
        dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         (LPVOID)lpOutBuf,
                                         &dwOutBufLen);
        
        if ( dwResult isnot NO_ERROR )
        {
            Trace1(ERR,
                   "GetIpNetTableFromStackEx: Error %x getting AT Entry",
                   dwResult);
 
            continue;
        }
        
        dwNumAdded = dwOutBufLen/(sizeof(IPNetToMediaEntry));
        lpOutBuf += dwNumAdded;
        dwValidNetEntries += dwNumAdded;
        dwOutBufLen = (dwNeed - dwValidNetEntries) * sizeof(IPNetToMediaEntry);
    }
   
    dwResult = NO_ERROR;
 
    *lpdwValidEntries = dwValidNetEntries;

    //
    // Now sort the net table
    //
    
    if(dwValidNetEntries > 0)
    {
        for(i = 0; i < dwValidNetEntries; i++)
        {
            (*lpNetTable)[i].inme_index = GetInterfaceFromAdapter((*lpNetTable)[i].inme_index);
        }
        
        if(bOrder)
        {
            for(i = 0; i < dwValidNetEntries - 1; i++)
            {
                DWORD min = i;
                
                for(j =  i + 1; j < dwValidNetEntries; j++)
                {
                    if(IpNetCmp((*lpNetTable)[min].inme_index,(*lpNetTable)[min].inme_addr,
                                (*lpNetTable)[j].inme_index,(*lpNetTable)[j].inme_addr) > 0)
                    {
                        min = j;
                    }
                }
                if(min isnot i)
                {
                    tempEntry = (*lpNetTable)[min];
                    (*lpNetTable)[min] = (*lpNetTable)[i];
                    (*lpNetTable)[i] = tempEntry;
                }
            }
        }
    }

    TraceLeave("GetIpNetTableFromStackEx");
    
    return dwResult;
}

DWORD 
SetIpNetEntryToStack(IPNetToMediaEntry *inmeEntry, DWORD dwInstance)
{
    TCP_REQUEST_SET_INFORMATION_EX    *lptrsiInBuf;
    TDIObjectID                       *ID;
    UCHAR                             *Context;
    IPNetToMediaEntry                 *copyInfo;
    DWORD                             dwInBufLen,dwOutBufLen,dwResult;

    TraceEnter("SetIpNetEntryToStack");
    
    dwInBufLen = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPNetToMediaEntry) - 1;
    
    lptrsiInBuf = HeapAlloc(GetProcessHeap(),0,dwInBufLen);
    
    if(lptrsiInBuf is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,
               "SetIpNetEntryToStack: Error %d allocating memory",
               dwResult);
        
        return dwResult;
    }
    
    ID                          = &lptrsiInBuf->ID;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_entity.tei_entity   = AT_ENTITY;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = AT_MIB_ADDRXLAT_ENTRY_ID;
    ID->toi_entity.tei_instance = dwInstance;

    //
    // Since IPNetToMediaEntry is a fixed size structure
    //
    
    copyInfo = (IPNetToMediaEntry*)lptrsiInBuf->Buffer;
    *copyInfo = *inmeEntry;
    
    dwResult = TCPSetInformationEx(g_hTcpDevice,
                                   (LPVOID)lptrsiInBuf,
                                   &dwInBufLen,
                                   NULL,
                                   &dwOutBufLen);

    TraceLeave("SetIpNetEntryToStack");
    
    return dwResult;
}

DWORD 
UpdateAdapterToIFInstanceMap()
{
    IPSNMPInfo                         ipsiInfo;
    DWORD                              dwResult;
    DWORD                              dwOutBufLen;
    DWORD                              dwInBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    IFEntry                            *maxIfEntry;
    BYTE                               *Context;
    DWORD                              dwCount,i;

    TraceEnter("UpdateAdapterToIFInstanceMap");
    
    dwResult = GetIpStatsFromStack(&ipsiInfo);
    
    if(dwResult isnot NO_ERROR)
    {
        Trace1(ERR,
               "UpdateAdapterToIFInstanceMap: NtStatus %x querying IpSnmpInfo from stack to determine number if interface",
               dwResult);

        TraceLeave("UpdateAdapterToIFInstanceMap");
        
        return dwResult;
    }
    
    
    dwOutBufLen = sizeof(MIB_IFROW) - FIELD_OFFSET(MIB_IFROW, dwIndex);

    if((maxIfEntry = (IFEntry*)HeapAlloc(GetProcessHeap(),
                                         0,
                                         dwOutBufLen)) is NULL)
    {
        dwResult = GetLastError();
        
        Trace1(ERR,
               "UpdateAdapterToIFInstanceMap: Error %d allocating memory",
               dwResult);

        TraceLeave("UpdateAdapterToIFInstanceMap");
        
        return ERROR_NOT_ENOUGH_MEMORY; 
    }




    dwInBufLen                  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    ID                          = &(trqiInBuf.ID);
    Context                     = &(trqiInBuf.Context[0]);
    ID->toi_entity.tei_entity   = IF_ENTITY;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IF_MIB_STATS_ID;

    //
    // Read the interface entry items
    //

    for ( i = 0; i < ipsiInfo.ipsi_numif ; i++ )
    {
        dwOutBufLen = sizeof(MIB_IFROW) - FIELD_OFFSET(MIB_IFROW, dwIndex);

        ID->toi_entity.tei_instance = i;
        
        ZeroMemory(Context,CONTEXT_SIZE);

        dwResult = TCPQueryInformationEx(g_hTcpDevice,
                                         &trqiInBuf,
                                         &dwInBufLen,
                                         (LPVOID)maxIfEntry,
                                         &dwOutBufLen);
        if (dwResult isnot NO_ERROR)
        {
            Trace1(ERR,
                   "UpdateAdapterToIFInstanceMap: NtStatus %x getting IFRow from stack",
                   dwResult);
            
            continue;
        }
        
        StoreAdapterToIFInstanceMap(maxIfEntry->if_index,i);
    }
    
    HeapFree(GetProcessHeap(),0,maxIfEntry);

    TraceLeave("UpdateAdapterToIFInstanceMap");
        
    return NO_ERROR;
}


//* TCPQueryInformationEx
//
// Description: Get information from the stack.
//
// Parameters:  HANDLE hHandle: handle to the stack.
//              TDIObjectID *ID: pointer to TDIObjectID info.
//              void *Buffer: buffer to receive data from the stack.
//              ulong *Bufferlen: IN: tells stack size of available buffer,
//                                OUT: tells us how much data is available.
//              CONTEXT *Context: allows queries spanning more than one call.
//
// Returns:     int:
//
//*
int
TCPQueryInformationEx( HANDLE hHandle,
                       void *InBuf,
                       ulong *InBufLen,
                       void *OutBuf,
                       ulong *OutBufLen )
{
    NTSTATUS           Status;
    IO_STATUS_BLOCK    IoStatusBlock;

    TraceEnter("TCPQueryInformationEx");
    
    Status = NtDeviceIoControlFile( hHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_TCP_QUERY_INFORMATION_EX,
                                   InBuf,
                                   *InBufLen,
                                   OutBuf,
                                   *OutBufLen );
    
    if ( Status == STATUS_PENDING )
    {
        Status = NtWaitForSingleObject( hHandle, FALSE, NULL );
        Status = IoStatusBlock.Status;
    }
    
    if ( !NT_SUCCESS( Status ) )
    {
        Trace1(ERR,
               "TCPQueryInformationEx: NtStatus %x from NtDeviceIoControlFile",
               Status);
        
        *OutBufLen = 0;

        TraceLeave("TCPQueryInformationEx");
        
        return Status;
    }

    //
    // Tell caller how much was written
    //
    
    *OutBufLen = IoStatusBlock.Information;

    TraceLeave("TCPQueryInformationEx");
    
    return NO_ERROR;
    
}


//* TCPSetInformationEx()
//
// Description: Send information to the stack
//
// Parameters:  HANDLE hHandle: handle to the stack.
//              TDIObjectID *ID: pointer to TDIObjectID info.
//              void *Buffer: buffer to receive data from the stack.
//              ulong Bufferlen: tells stack size of available buffer,
//
// Returns:     int:
//
//*
int 
TCPSetInformationEx(HANDLE  hHandle,
                    void    *InBuf,
                    ULONG   *InBufLen,
                    void    *OutBuf,
                    ULONG   *OutBufLen )
{
    NTSTATUS           Status;
    IO_STATUS_BLOCK    IoStatusBlock;

    TraceEnter("TCPSetInformationEx");
    
    Status = NtDeviceIoControlFile(hHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_TCP_SET_INFORMATION_EX,
                                   InBuf,
                                   *InBufLen,
                                   OutBuf,
                                   *OutBufLen );
    
    
    if ( Status == STATUS_PENDING )
    {
        Status = NtWaitForSingleObject(hHandle, FALSE, NULL );
        Status = IoStatusBlock.Status;
    }
    
    if ( !NT_SUCCESS( Status ) )
    {
        Trace1(ERR,
               "TCPSetInformationEx: NtStatus %x from NtDeviceIoControlFile",
               Status);

        TraceLeave("TCPSetInformationEx");
        
        return Status;
    }

    TraceLeave("TCPSetInformationEx");
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rtrmgr\rtrdisc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\rtrmgr\rtrdisc.h

Abstract:

    Header file for router discover related stuff

Revision History:

    Amritansh Raghav  20th Mar 1996      Created

--*/

#ifndef __RTRDISC_H__
#define __RTRDISC_H__


typedef struct _ICB ICB, *PICB;

typedef struct _TIMER_QUEUE_ITEM
{
    LIST_ENTRY       leTimerLink;
    LARGE_INTEGER    liFiringTime;
}TIMER_QUEUE_ITEM, *PTIMER_QUEUE_ITEM;

typedef struct _ROUTER_DISC_CB
{
    WORD               wMaxAdvtInterval;
    WORD               wAdvtLifetime;
    BOOL               bAdvertise;
    BOOL               bActive;
    LONG               lPrefLevel;
    DWORD              dwNumAdvtsSent;
    DWORD              dwNumSolicitationsSeen;
    TIMER_QUEUE_ITEM   tqiTimer;
    BOOL               bReplyPending;
    LARGE_INTEGER      liMaxMinDiff;
    LARGE_INTEGER      liMinAdvtIntervalInSysUnits;
    SOCKET             *pRtrDiscSockets;
}ROUTER_DISC_CB, *PROUTER_DISC_CB;

//
// Blocking mode socket with IP Multicast capability
//

#define RTR_DISC_SOCKET_FLAGS (WSA_FLAG_MULTIPOINT_C_LEAF|WSA_FLAG_MULTIPOINT_D_LEAF)

#define ALL_ROUTERS_MULTICAST_GROUP     ((DWORD)0x020000E0) //inet_addr("224.0.0.2")

#define ALL_SYSTEMS_MULTICAST_GROUP     ((DWORD)0x010000E0) //inet_addr("224.0.0.1")

//#define ALL_SYSTEMS_MULTICAST_GROUP   ((DWORD)0xFFFFFFFF) //inet_addr("224.0.0.1")

#define ICMP_ROUTER_DISCOVERY_TYPE      ((BYTE) 0x9)

#define ICMP_ROUTER_DISCOVERY_CODE      ((BYTE) 0x0)

#define ICMP_ROUTER_DISCOVERY_ADDR_SIZE ((BYTE) 0x2)

#include <packon.h>

typedef struct _ICMP_ROUTER_SOL_MSG
{
    BYTE      byType;
    BYTE      byCode;
    WORD      wXSum;
    DWORD     dwReserved;
}ICMP_ROUTER_SOL_MSG, *PICMP_ROUTER_SOL_MSG;

typedef struct _ICMP_ADVT
{
    DWORD     dwRtrIpAddr;
    LONG      lPrefLevel;
}ICMP_ADVT, *PICMP_ADVT;

typedef struct _ICMP_ROUTER_ADVT_MSG
{
    BYTE       byType;
    BYTE       byCode;
    WORD       wXSum;
    BYTE       byNumAddrs;
    BYTE       byAddrEntrySize;
    WORD       wLifeTime;
    ICMP_ADVT  iaAdvt[1];
}ICMP_ROUTER_ADVT_MSG, *PICMP_ROUTER_ADVT_MSG;

#define SIZEOF_RTRDISC_ADVT(X)  \
    (FIELD_OFFSET(ICMP_ROUTER_ADVT_MSG, iaAdvt[0])   +      \
     ((X) * sizeof(ICMP_ADVT)))
 
typedef struct _IP_HEADER 
{
    BYTE      byVerLen;         // Version and length.
    BYTE      byTos;            // Type of service.
    WORD      wLength;          // Total length of datagram.
    WORD      wId;              // Identification.
    WORD      wFlagOff;         // Flags and fragment offset.
    BYTE      byTtl;            // Time to live.
    BYTE      byProtocol;       // Protocol.
    WORD      wXSum;            // Header checksum.
    DWORD     dwSrc;            // Source address.
    DWORD     dwDest;           // Destination address.
}IP_HEADER, *PIP_HEADER;

//
// Max size of the IP Header in DWORDs
//

#include <packoff.h>

#define MAX_LEN_HDR          15

//
// Take the largest ICMP packet that can be received to avoid getting 
// too many buffer size errors
//

#define ICMP_RCV_BUFFER_LEN  ((2*MAX_LEN_HDR) + 2 +2)

//
// Function prototypes
//

VOID  
SetRouterDiscoveryInfo(
    IN PICB picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );

VOID  
InitializeRouterDiscoveryInfo(
    IN PICB picb,
    IN PRTR_INFO_BLOCK_HEADER pInfoHdr
    );

DWORD
GetInterfaceRouterDiscoveryInfo(
    PICB picb,
    PRTR_TOC_ENTRY pToc,
    PBYTE dataptr,
    PRTR_INFO_BLOCK_HEADER pInfoHdr,
    PDWORD pdwSize
    );

DWORD 
ActivateRouterDiscovery(
    IN PICB  picb
    );

BOOL  
SetFiringTimeForAdvt(
    IN PICB picb
    );

DWORD 
CreateSockets(
    IN PICB picb
    );

DWORD 
UpdateAdvertisement(
    IN PICB picb
    );

VOID 
HandleRtrDiscTimer(
    VOID    
    );

VOID  
HandleSolicitations(
    VOID 
    );

VOID  
AdvertiseInterface(
    IN PICB picb
    );

WORD  
Compute16BitXSum(
    IN PVOID pvData,
    IN DWORD dwNumBytes
    );

DWORD 
DeActivateRouterDiscovery(
    IN PICB  picb
    );

VOID  
SetFiringTimeForReply(
    IN PICB picb
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\sample\configmgr.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\configurationmanager.c

Abstract:

    The file contains global configuration related functions,
    implementing the configuration manager.

--*/

#include "pchsample.h"
#pragma hdrstop

// global variables...

CONFIGURATION_ENTRY g_ce;



// functions...

BOOL
ValidateGlobalConfig (
    IN  PIPSAMPLE_GLOBAL_CONFIG pigc)
/*++

Routine Description
    Checks to see if the global configuration is OK. It is good practice to
    do this because a corrupt registry can change configuration causing all
    sorts of debugging headaches if it is not found early

Locks
    None

Arguments
    pigc                pointer to ip sample's global configuration

Return Value
    TRUE                if the configuration is good
    FALSE               o/w

--*/
{
    DWORD dwErr = NO_ERROR;
    
    do                          // breakout loop
    {
        if (pigc is NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE0(CONFIGURATION, "Error null global config");

            break;
        }

        // 
        // check range of each field
        // 

        // ensure that the logging level is within bounds
        if((pigc->dwLoggingLevel < IPSAMPLE_LOGGING_NONE) or
           (pigc->dwLoggingLevel > IPSAMPLE_LOGGING_INFO))
        {   
            dwErr = ERROR_INVALID_PARAMETER;
            TRACE0(CONFIGURATION, "Error log level out of range");

            break;
        }

        // add more here...
        
    } while (FALSE);

    if (!(dwErr is NO_ERROR))
    {
        TRACE0(CONFIGURATION, "Error corrupt global config");
        LOGERR0(CORRUPT_GLOBAL_CONFIG, dwErr);
        
        return FALSE;
    }

    return TRUE;
}



////////////////////////////////////////
// WORKERFUNCTIONS
////////////////////////////////////////

VOID
CM_WorkerFinishStopProtocol (
    IN      PVOID   pvContext)
/*++

Routine Description
    WORKERFUNCTION.  Queued by CM_StopProtocol.
    Waits for all active and queued threads to exit and cleans up
    configuration entry.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    pvContext           ulActivityCount

Return Value
    None

--*/
{
    DWORD           dwErr = NO_ERROR;
    MESSAGE         mMessage;
    
    ULONG           ulThreadCount = 0;
    
    ulThreadCount = (ULONG)pvContext;

    TRACE1(ENTER, "Entering WorkerFinishStopProtocol: active threads %u",
           ulThreadCount);
    
    // NOTE: since this is called while the router is stopping, there is no
    // need for it to use ENTER_SAMPLE_WORKER()/LEAVE_SAMPLE_WORKER()

    // waits for all threads to stop
    while (ulThreadCount-- > 0)
        WaitForSingleObject(g_ce.hActivitySemaphore, INFINITE);

    
   // acquire the lock and release it, just to be sure that all threads
   // have quit their calls to LeaveSampleWorker()

    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));
    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));

    // NOTE: there is no need to acquire g_ce.rwlLock for the call to
    // CE_Cleanup since there are no threads competing for access to the
    // fields being cleaned up.  new competing threads aren't created till
    // CE_Cleanup sets the protocol state to IPSAMPLE_STATUS_STOPPED, which
    // is the last thing it does.

    CE_Cleanup(&g_ce, TRUE);

    LOGINFO0(SAMPLE_STOPPED, NO_ERROR);
    
    // inform router manager that we are done
    ZeroMemory(&mMessage, sizeof(MESSAGE));
    if (EnqueueEvent(ROUTER_STOPPED, mMessage) is NO_ERROR)
        SetEvent(g_ce.hMgrNotificationEvent);

    TRACE0(LEAVE, "Leaving  WorkerFinishStopProtocol");
}



////////////////////////////////////////
// APIFUNCTIONS
////////////////////////////////////////

DWORD
CM_StartProtocol (
    IN  HANDLE                  hMgrNotificationEvent,
    IN  PSUPPORT_FUNCTIONS      psfSupportFunctions,
    IN  PVOID                   pvGlobalInfo)
/*++

Routine Description
    Called by StartProtocol.  Initializes configuration entry.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    hMgrNotificationEvent   event used to notify ip router manager
    psfSupportFunctions     functions exported by ip router manager
    pvGlobalInfo            global configuration set in registry

Return Value
    NO_ERROR            if successfully initiailzed
    Failure code        o/w

--*/
{
    DWORD dwErr = NO_ERROR;
    
    // NOTE: since this is called when SAMPLE is stopped, there is no need
    // for it to use ENTER_SAMPLE_API()/LEAVE_SAMPLE_API()

    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

    do                          // breakout loop
    {
        if (g_ce.iscStatus != IPSAMPLE_STATUS_STOPPED)
        {
            TRACE0(CONFIGURATION, "Error ip sample already installed");
            LOGWARN0(SAMPLE_ALREADY_STARTED, NO_ERROR);
            dwErr = ERROR_CAN_NOT_COMPLETE;
            
            break;
        }

        if (!ValidateGlobalConfig((PIPSAMPLE_GLOBAL_CONFIG) pvGlobalInfo))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        dwErr = CE_Initialize(&g_ce,
                              hMgrNotificationEvent,
                              psfSupportFunctions,
                              (PIPSAMPLE_GLOBAL_CONFIG) pvGlobalInfo);
    } while (FALSE);
    
    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));

    if (dwErr is NO_ERROR)
    {
        TRACE0(CONFIGURATION, "ip sample has successfully started");
        LOGINFO0(SAMPLE_STARTED, dwErr);
    }
    else
    {
        TRACE1(CONFIGURATION, "Error ip sample failed to start", dwErr);
        LOGERR0(SAMPLE_START_FAILED, dwErr);
    }

    return dwErr;
}



DWORD
CM_StopProtocol (
    )
/*++

Routine Description
    Called by StopProtocol.  It queues a WORKERFUNCTION which waits for all
    active threads to exit and then cleans up the configuration entry.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock

Arguments
    None

Return Value
    ERROR_PROTOCOL_STOP_PENDING     if successfully queued
    Failure code                    o/w

--*/
{
    DWORD dwErr         = NO_ERROR;
    BOOL  bSuccess      = FALSE;
    ULONG ulThreadCount = 0;
    
    // NOTE: no need to use ENTER_SAMPLE_API()/LEAVE_SAMPLE_API()
    // Does not use QueueSampleWorker
    
    ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

    do                          // breakout loop
    {
        // cannot stop if already stopped
        if (g_ce.iscStatus != IPSAMPLE_STATUS_RUNNING)
        {
            TRACE0(CONFIGURATION, "Error ip sample already stopped");
            LOGWARN0(SAMPLE_ALREADY_STOPPED, NO_ERROR);
            dwErr = ERROR_CAN_NOT_COMPLETE;
        
            break;
        }
    

        // set IPSAMPLE's status to STOPPING; this prevents any more
        // work-items from being queued, and it prevents the ones already
        // queued from executing
        g_ce.iscStatus = IPSAMPLE_STATUS_STOPPING;
        

        // find out how many threads are either queued or active in SAMPLE;
        // we will have to wait for this many threads to exit before we
        // clean up SAMPLE's resources
        ulThreadCount = g_ce.ulActivityCount;
        TRACE1(CONFIGURATION,
               "%u threads are active in SAMPLE", ulThreadCount);
    } while (FALSE);

    RELEASE_WRITE_LOCK(&(g_ce.rwlLock));


    if (dwErr is NO_ERROR)
    {
        bSuccess = QueueUserWorkItem(
            (LPTHREAD_START_ROUTINE)CM_WorkerFinishStopProtocol,
            (PVOID) ulThreadCount,
            0); // no flags

        dwErr = (bSuccess) ? ERROR_PROTOCOL_STOP_PENDING : GetLastError();
    }

    return dwErr;
}



DWORD
CM_GetGlobalInfo (
    IN      PVOID 	            pvGlobalInfo,
    IN OUT  PULONG              pulBufferSize,
    OUT     PULONG	            pulStructureVersion,
    OUT     PULONG              pulStructureSize,
    OUT     PULONG              pulStructureCount)
/*++

Routine Description
    See if there's space enough to return ip sample global config. If yes,
    we return it, otherwise return the size needed.

Locks
    Acquires shared g_ce.rwlLock
    Releases        g_ce.rwlLock
    
Arguments
    pvGlobalInfo        pointer to allocated buffer to store our config
    pulBufferSize       IN  size of buffer received
                        OUT size of our global config

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD                   dwErr = NO_ERROR;
    PIPSAMPLE_GLOBAL_CONFIG pigc;
    ULONG                   ulSize = sizeof(IPSAMPLE_GLOBAL_CONFIG);

    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }

    do                          // breakout loop
    {
        if((*pulBufferSize < ulSize) or (pvGlobalInfo is NULL))
        {
            // either the size was too small or there was no storage
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            TRACE1(CONFIGURATION,
                   "CM_GetGlobalInfo: *ulBufferSize %u",
                   *pulBufferSize);

            *pulBufferSize = ulSize;

            break;
        }

        *pulBufferSize = ulSize;

        if (pulStructureVersion)    *pulStructureVersion    = 1;
        if (pulStructureSize)       *pulStructureSize       = ulSize;
        if (pulStructureCount)      *pulStructureCount      = 1;
        

        // so we have a good buffer to write our info into...
        pigc = (PIPSAMPLE_GLOBAL_CONFIG) pvGlobalInfo;

        // copy out the global configuration
        ACQUIRE_READ_LOCK(&(g_ce.rwlLock));

        pigc->dwLoggingLevel = g_ce.dwLogLevel;

        RELEASE_READ_LOCK(&(g_ce.rwlLock));
    } while (FALSE);
    
    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
CM_SetGlobalInfo (
    IN      PVOID 	            pvGlobalInfo)
/*++

Routine Description
    Set ip sample's global configuration.

Locks
    Acquires exclusively g_ce.rwlLock
    Releases             g_ce.rwlLock
    
Arguments
    pvGlobalInfo        buffer with new global configuration

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD                   dwErr = NO_ERROR;
    PIPSAMPLE_GLOBAL_CONFIG pigc;

    if (!ENTER_SAMPLE_API()) { return ERROR_CAN_NOT_COMPLETE; }

    do                          // breakout loop
    {
        pigc = (PIPSAMPLE_GLOBAL_CONFIG) pvGlobalInfo;
        
        if (!ValidateGlobalConfig(pigc)) 
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        // copy in the global configuration
        ACQUIRE_WRITE_LOCK(&(g_ce.rwlLock));

        g_ce.dwLogLevel = pigc->dwLoggingLevel;

        RELEASE_WRITE_LOCK(&(g_ce.rwlLock));
    } while (FALSE);
    
    LEAVE_SAMPLE_API();

    return dwErr;
}



DWORD
CM_GetEventMessage (
    OUT ROUTING_PROTOCOL_EVENTS *prpeEvent,
    OUT MESSAGE                 *pmMessage)
/*++

Routine Description
    Get the next event in queue for the ip router manager.

Locks
    None
    
Arguments
    prpeEvent           routing protocol event type
    pmMessage           message associated with the event

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD           dwErr       = NO_ERROR;
    
    // NOTE: this can be called after the protocol is stopped, as in when
    // the ip router manager is retrieving the ROUTER_STOPPED message, so
    // we do not call ENTER_SAMPLE_API()/LEAVE_SAMPLE_API()

    dwErr = DequeueEvent(prpeEvent, pmMessage);
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\sample\configentry.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\configurationentry.c

Abstract:

    The file contains functions to deal with the configuration entry.

--*/

#include "pchsample.h"
#pragma hdrstop

static
VOID
DisplayEventEntry (
    IN  PQUEUE_ENTRY        pqeEntry)
/*++

Routine Description
    Displays an EVENT_ENTRY object.

Locks
    None

Arguments

    pqeEntry            address of the 'leEventQueueLink' field

Return Value
    None

--*/
{
    EE_Display(CONTAINING_RECORD(pqeEntry, EVENT_ENTRY, qeEventQueueLink));
}
               


static
VOID
FreeEventEntry (
    IN  PQUEUE_ENTRY        pqeEntry)
/*++

Routine Description
    Frees an EVENT_ENTRY object.

Locks
    None

Arguments

    pqeEntry            address of the 'leEventQueueLink' field

Return Value
    None

--*/
{
    EE_Destroy(CONTAINING_RECORD(pqeEntry, EVENT_ENTRY, qeEventQueueLink));
}
               


DWORD
EE_Create (
    IN  ROUTING_PROTOCOL_EVENTS rpeEvent,
    IN  MESSAGE                 mMessage,
    OUT PEVENT_ENTRY            *ppeeEventEntry)
/*++

Routine Description
    Creates an event entry.

Locks
    None

Arguments
    rpeEvent
    mMessage
    ppEventEntry        pointer to the event entry address

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD               dwErr = NO_ERROR;
    PEVENT_ENTRY        peeEntry; // scratch

    // validate parameters
    if (!ppeeEventEntry)
        return ERROR_INVALID_PARAMETER;

    *ppeeEventEntry = NULL;

    // allocate the interface entry structure
    MALLOC(&peeEntry, sizeof(EVENT_ENTRY), &dwErr);
    if (dwErr != NO_ERROR)
        return dwErr;

    // initialize various fields
    InitializeQueueHead(&(peeEntry->qeEventQueueLink));
    
    peeEntry->rpeEvent = rpeEvent;
    peeEntry->mMessage = mMessage;

    *ppeeEventEntry = peeEntry;
    return dwErr;
}



DWORD
EE_Destroy (
    IN  PEVENT_ENTRY            peeEventEntry)
/*++

Routine Description
    Destroys an event entry.

Locks
    None.

Arguments
    peeEventEntry       pointer to the event entry

Return Value
    NO_ERROR            always

--*/
{
    if (!peeEventEntry)
        return NO_ERROR;

    FREE(peeEventEntry);
    
    return NO_ERROR;
}



#ifdef DEBUG
DWORD
EE_Display (
    IN  PEVENT_ENTRY            peeEventEntry)
/*++

Routine Description
    Displays an event entry.

Locks
    None.

Arguments
    peeEventEntry       pointer to the event entry

Return Value
    NO_ERROR            always

--*/
{
    if (!peeEventEntry)
        return NO_ERROR;

    TRACE1(CONFIGURATION,
           "Event %u",
           peeEventEntry->rpeEvent);

    if (peeEventEntry->rpeEvent is SAVE_INTERFACE_CONFIG_INFO)
        TRACE1(CONFIGURATION,
               "Index %u",
               (peeEventEntry->mMessage).InterfaceIndex);

    return NO_ERROR;
}
#endif // DEBUG



DWORD
EnqueueEvent(
    IN  ROUTING_PROTOCOL_EVENTS rpeEvent,
    IN  MESSAGE                 mMessage)
/*++

Routine Description
    Queues an event entry in g_ce.lqEventQueue.

Locks
    Locks and unlocks the locked queue g_ce.lqEventQueue.

Arguments
    rpeEvent
    mMessage

Return Value
    NO_ERROR            success
    Error Code          o/w

--*/    
{
    DWORD           dwErr = NO_ERROR;
    PEVENT_ENTRY    peeEntry = NULL;

    dwErr = EE_Create(rpeEvent, mMessage, &peeEntry); 
    // destroyed in EE_DequeueEvent
    
    if (dwErr is NO_ERROR)
    {
        ACQUIRE_QUEUE_LOCK(&(g_ce.lqEventQueue));
        
        Enqueue(&(g_ce.lqEventQueue.head), &(peeEntry->qeEventQueueLink));

        RELEASE_QUEUE_LOCK(&(g_ce.lqEventQueue));
    }
    
    return dwErr;
}


     
DWORD
DequeueEvent(
    OUT ROUTING_PROTOCOL_EVENTS  *prpeEvent,
    OUT MESSAGE                  *pmMessage)
/*++

Routine Description
    Dequeues an event entry from g_ce.lqEventQueue.

Locks
    Locks and unlocks the locked queue g_ce.lqEventQueue.

Arguments
    prpeEvent
    pmMessage

Return Value
    NO_ERROR            success
    ERROR_NO_MORE_ITEMS o/w

--*/  
{
    DWORD           dwErr   = NO_ERROR;
    PQUEUE_ENTRY    pqe     = NULL;
    PEVENT_ENTRY    pee     = NULL;

    ACQUIRE_QUEUE_LOCK(&(g_ce.lqEventQueue));

    do                          // breakout loop
    {
        if (IsQueueEmpty(&(g_ce.lqEventQueue.head)))
        {
            dwErr = ERROR_NO_MORE_ITEMS;
            TRACE0(CONFIGURATION, "Error no events in the queue");
            LOGWARN0(EVENT_QUEUE_EMPTY, dwErr);
            break;
        }

        pqe = Dequeue(&(g_ce.lqEventQueue.head));

        pee = CONTAINING_RECORD(pqe, EVENT_ENTRY, qeEventQueueLink);
        *(prpeEvent) = pee->rpeEvent;
        *(pmMessage) = pee->mMessage;

        // created in EE_EnqueueEvent
        EE_Destroy(pee);
        pee = NULL;
    } while (FALSE);

    RELEASE_QUEUE_LOCK(&(g_ce.lqEventQueue));
        
    return dwErr;
}   



DWORD
CE_Create (
    IN  PCONFIGURATION_ENTRY    pce)
/*++

Routine Description
    Creates a configuration entry on DLL_PROCESS_ATTACH.

Locks
    None

Arguments
    pce                 pointer to the configuration entry

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    DWORD dwErr = NO_ERROR;

    // initialize to default values
    ZeroMemory(pce, sizeof(CONFIGURATION_ENTRY));
    pce->dwTraceID = INVALID_TRACEID;
    
    do                          // breakout loop
    {
        // initialize the read-write lock
        CREATE_READ_WRITE_LOCK(&(pce->rwlLock));
        if (!READ_WRITE_LOCK_CREATED(&(pce->rwlLock)))
        {
            dwErr = GetLastError();
            
            TRACE1(CONFIGURATION, "Error %u creating read-write-lock", dwErr);
            LOGERR0(CREATE_RWL_FAILED, dwErr);

            break;
        }

        // initialize the global heap
        pce->hGlobalHeap = HeapCreate(0, 0, 0);
        if (pce->hGlobalHeap is NULL)
        {
            dwErr = GetLastError();
            TRACE1(CONFIGURATION, "Error %u creating global heap", dwErr);
            LOGERR0(HEAP_CREATE_FAILED, dwErr);

            break;
        }

        //
        // initialize the count of threads that are active in IPSAMPLE
        // create the semaphore released by each thread when it is done
        // required for clean stop to the protocol
        // 
        pce->ulActivityCount = 0;
        pce->hActivitySemaphore = CreateSemaphore(NULL, 0, 0xfffffff, NULL);
        if (pce->hActivitySemaphore is NULL)
        {
            dwErr = GetLastError();
            TRACE1(CONFIGURATION, "Error %u creating semaphore", dwErr);
            LOGERR0(CREATE_SEMAPHORE_FAILED, dwErr);
            break;
        }

        // Logging & Tracing Information
        pce->dwLogLevel = IPSAMPLE_LOGGING_INFO;
        pce->hLogHandle = RouterLogRegister("IPSAMPLE");
        pce->dwTraceID  = TraceRegister("IPSAMPLE");

        // Event Queue
        INITIALIZE_LOCKED_QUEUE(&(pce->lqEventQueue));
        if (!LOCKED_QUEUE_INITIALIZED(&(pce->lqEventQueue)))
        {
            dwErr = GetLastError();
            TRACE1(CONFIGURATION, "Error %u initializing locked queue", dwErr);
            LOGERR0(INIT_CRITSEC_FAILED, dwErr);
            break;
        }

        // Protocol State
        pce->iscStatus = IPSAMPLE_STATUS_STOPPED;
        

        // Store of Dynamic Locks
        // pce->dlsDynamicLocksStore    zero'ed out

        // Timer Entry
        // pce->hTimerQueue             = NULL;

        // Router Manager Information (later)
        // pce->hMgrNotificationEvent   = NULL
        // pce->sfSupportFunctions      zero'ed out

        // RTMv2 Information
        // pce->reiRtmEntity            zero'ed out
        // pce->rrpRtmProfile           zero'ed out
        // pce->hRtmHandle              = NULL
        // pce->hRtmNotificationHandle  = NULL

        // MGM Information
        // pce->hMgmHandle              = NULL

        // Network Entry
        // pce->pneNetworkEntry         = NULL;

        // Global Statistics
        // pce->igsStats                zero'ed out

    } while (FALSE);

    if (dwErr != NO_ERROR)
    {
        // something went wrong, so cleanup.
        TRACE0(CONFIGURATION, "Failed to create configuration entry");
        CE_Destroy(pce);
    }
    
    return dwErr;
}



DWORD
CE_Destroy (
    IN  PCONFIGURATION_ENTRY    pce)
/*++

Routine Description
    Destroys a configuration entry on DLL_PROCESS_DEATTACH

Locks
    Assumes exclusive access to rwlLock with no waiting thread.

Arguments
    pce                 pointer to the configuration entry

Return Value
    NO_ERROR            always

--*/
{
    // Network Entry
    
    // MGM Information
    
    // RTMv2 Information
    
    // Router Manager Information

    // Timer Entry

    // Store of Dynamic Locks
    
    // protocol state should be such...
    RTASSERT(pce->iscStatus is IPSAMPLE_STATUS_STOPPED);

    // Event Queue
    if (LOCKED_QUEUE_INITIALIZED(&(pce->lqEventQueue)))
        DELETE_LOCKED_QUEUE((&(pce->lqEventQueue)), FreeEventEntry);
    
    // Logging & Tracing Information
    if (pce->dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(pce->dwTraceID);
        pce->dwTraceID = INVALID_TRACEID;
    }
    if (pce->hLogHandle != NULL)
    {
        RouterLogDeregister(pce->hLogHandle);
        pce->hLogHandle = NULL;
    }

    // destroy the semaphore released by each thread when it is done
    if (pce->hActivitySemaphore != NULL)
    {
        CloseHandle(pce->hActivitySemaphore);
        pce->hActivitySemaphore = NULL;
    }

    if (pce->hGlobalHeap != NULL)
    {
        HeapDestroy(pce->hGlobalHeap);
        pce->hGlobalHeap = NULL;
    }

    // delete the read-write lock
    if (READ_WRITE_LOCK_CREATED(&(pce->rwlLock)))
        DELETE_READ_WRITE_LOCK(&(pce->rwlLock));

    return NO_ERROR;
}



DWORD
CE_Initialize (
    IN  PCONFIGURATION_ENTRY    pce,
    IN  HANDLE                  hMgrNotificationEvent,
    IN  PSUPPORT_FUNCTIONS      psfSupportFunctions,
    IN  PIPSAMPLE_GLOBAL_CONFIG pigc)
/*++

Routine Description
    Initializes a configuration entry on StartProtocol.

Locks
    Assumes exclusive access to pce->rwlLock

Arguments
    pce                     pointer to the configuration entry
    hMgrNotificationEvent   event used to notify ip router manager
    psfSupportFunctions     functions exported by ip router manager
    pigc                    global configuration set in registry
    
Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    WORD    wVersionRequested   = MAKEWORD(1,1);
    WSADATA wsaData;
    BOOL    bCleanupWinsock     = FALSE;
    
    DWORD   dwErr               = NO_ERROR;

    // validate environment
    RTASSERT(pce->ulActivityCount is 0);
    RTASSERT(pce->iscStatus is IPSAMPLE_STATUS_STOPPED);
    
    do                          // breakout loop
    {
        pce->ulActivityCount    = 0;
        pce->dwLogLevel         = pigc->dwLoggingLevel;


        dwErr = (DWORD) WSAStartup(wVersionRequested, &wsaData);
        if (dwErr != 0)
        {
            TRACE1(CONFIGURATION, "Error %u starting windows sockets", dwErr);
            LOGERR0(WSASTARTUP_FAILED, dwErr);
            break;
        }
        bCleanupWinsock = TRUE;

        // Store of Dynamic Locks
        dwErr = InitializeDynamicLocksStore(&(pce->dlsDynamicLocksStore),
                                            GLOBAL_HEAP);
        if (dwErr != NO_ERROR)
        {
            TRACE1(CONFIGURATION, "Error %u initializing locks store", dwErr);
            LOGERR0(INIT_CRITSEC_FAILED, dwErr);
            break;
        }

        // Timer Entry
        pce->hTimerQueue = CreateTimerQueue();
        if (!pce->hTimerQueue)
        {
            dwErr = GetLastError();
            TRACE1(CONFIGURATION, "Error %u registering timer queue", dwErr);
            LOGERR0(CREATE_TIMER_QUEUE_FAILED, dwErr);
            break;
        }

        
        // Router Manager Information
        pce->hMgrNotificationEvent   = hMgrNotificationEvent;
        if (psfSupportFunctions)
            pce->sfSupportFunctions      = *psfSupportFunctions;

        
        // RTMv2 Information
        pce->reiRtmEntity.RtmInstanceId = 0;
        pce->reiRtmEntity.AddressFamily = AF_INET;
        pce->reiRtmEntity.EntityId.EntityProtocolId = PROTO_IP_SAMPLE;
        pce->reiRtmEntity.EntityId.EntityInstanceId = 0;

        dwErr = RTM_RegisterEntity(
            &pce->reiRtmEntity,     // IN   my RTM_ENTITY_INFO
            NULL,                   // IN   my exported methods
            RTM_CallbackEvent,      // IN   my callback function 
            TRUE,                   // IN   reserve opaque pointer?
            &pce->rrpRtmProfile,    // OUT  my RTM_REGN_PROFILE
            &pce->hRtmHandle);      // OUT  my RTMv2 handle 
        if (dwErr != NO_ERROR)
        {
            TRACE1(CONFIGURATION, "Error %u registering with RTM", dwErr);
            LOGERR0(RTM_REGISTER_FAILED, dwErr);
            break;
        }

        dwErr = RTM_RegisterForChangeNotification(
            pce->hRtmHandle,        // IN   my RTMv2 handle 
            RTM_VIEW_MASK_MCAST,    // IN   route table views relevant to moi 
            RTM_CHANGE_TYPE_BEST,   // IN   change types interesting to moi
            NULL,                   // IN   context in callback function
            &pce->hRtmNotificationHandle); // OUT   my notification handle
        if (dwErr != NO_ERROR)
        {
            TRACE1(CONFIGURATION,
                   "Error %u registering for change with RTM", dwErr);
            LOGERR0(RTM_REGISTER_FAILED, dwErr);
            break;
        }


        // MGM Information
        // pce->hMgmHandle (later)


        // Network Entry
        dwErr = NE_Create(&(pce->pneNetworkEntry));
        if (dwErr != NO_ERROR)
            break;        


        // Global Statistics
        ZeroMemory(&(pce->igsStats), sizeof(IPSAMPLE_GLOBAL_STATS));
        

        pce->iscStatus = IPSAMPLE_STATUS_RUNNING;
    } while (FALSE);

    // something went wrong, cleanup
    if (dwErr != NO_ERROR)
        CE_Cleanup(pce, bCleanupWinsock);

    return dwErr;
}



DWORD
CE_Cleanup (
    IN  PCONFIGURATION_ENTRY    pce,
    IN  BOOL                    bCleanupWinsock)
/*++

Routine Description
    Cleans up a configuration entry on StopProtocol.

Locks
    Exclusive access to pce->rwlLock by virtue of no competing threads.

    NOTE: However, pce->rwlLock should NOT actually be held!  The call to
    DeleteTimerQueueEx blocks till all queued callbacks finish execution.
    These callbacks may acquire pce->rwlLock, causing deadlock.
    
Arguments
    pce                 pointer to the configuration entry
    bCleanupWinsock     
Return Value
    NO_ERROR            always

--*/
{
    DWORD dwErr = NO_ERROR;

    
    // Network Entry
    NE_Destroy(pce->pneNetworkEntry);
    pce->pneNetworkEntry        = NULL;
     

    // MGM Information (later)
    pce->hMgmHandle = NULL;
    

    // RTMv2 Information
    if (pce->hRtmNotificationHandle)
    {
        dwErr = RTM_DeregisterFromChangeNotification(
            pce->hRtmHandle,
            pce->hRtmNotificationHandle);

        if (dwErr != NO_ERROR)
            TRACE1(CONFIGURATION,
                   "Error %u deregistering for change from RTM", dwErr);
    }
    pce->hRtmNotificationHandle = NULL;

    if (pce->hRtmHandle)
    {
        dwErr = RTM_DeregisterEntity(pce->hRtmHandle);

        if (dwErr != NO_ERROR)
            TRACE1(CONFIGURATION,
                   "Error %u deregistering from RTM", dwErr);
    }
    pce->hRtmHandle             = NULL;

    
    // Router Manager Information
    // valid till overwritten, needed to signal the ip router manager
    //     pce->hMgrNotificationEvent
    //     pce->sfSupportFunctions
    

    // Timer Entry
    if (pce->hTimerQueue)
        DeleteTimerQueueEx(pce->hTimerQueue, INVALID_HANDLE_VALUE);
    pce->hTimerQueue            = NULL;
    

    // Store of Dynamic Locks
    if (DYNAMIC_LOCKS_STORE_INITIALIZED(&(pce->dlsDynamicLocksStore)))
    {
        dwErr = DeInitializeDynamicLocksStore(&(pce->dlsDynamicLocksStore));

        // all dynamic locks should have been free
        RTASSERT(dwErr is NO_ERROR);
    }

    if (bCleanupWinsock)
        WSACleanup();
    
    // protocol state
    pce->iscStatus = IPSAMPLE_STATUS_STOPPED;

    return NO_ERROR;
}



#ifdef DEBUG
DWORD
CE_Display (
    IN  PCONFIGURATION_ENTRY    pce)
/*++

Routine Description
    Displays a configuration entry.

Locks
    Acquires shared pce->rwlLock
    Releases        pce->rwlLock

Arguments
    pce                 pointer to the configuration entry to be displayed

Return Value
    NO_ERROR            always

--*/
{
    if (!pce)
        return NO_ERROR;

    
    ACQUIRE_READ_LOCK(&(pce->rwlLock));
    
    TRACE0(CONFIGURATION, "Configuration Entry...");

    TRACE3(CONFIGURATION,
           "ActivityCount %u, LogLevel %u, NumInterfaces %u",
           pce->ulActivityCount,
           pce->dwLogLevel,
           pce->igsStats.ulNumInterfaces);

    NE_Display(pce->pneNetworkEntry);

    RELEASE_READ_LOCK(&(pce->rwlLock));

    TRACE0(CONFIGURATION, "EventQueue...");
    ACQUIRE_QUEUE_LOCK(&(pce->lqEventQueue));
    MapCarQueue(&((pce->lqEventQueue).head), DisplayEventEntry);
    RELEASE_QUEUE_LOCK(&(pce->lqEventQueue));


    return NO_ERROR;
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\sample\defs.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\defs.h

Abstract:

    The file contains various...
    . constants
    . definitions
    . macros
      - memory-allocation
      - logging
      - tracing

--*/

#ifndef _DEFS_H_
#define _DEFS_H_


// constants

#define INTERFACE_TABLE_BUCKETS     29 // # buckets in the interface hash table

#define NOW                         0
#define INFINITE_INTERVAL           0x7fffffff    
#define PERIODIC_INTERVAL           5   // # seconds

#define MAX_PACKET_LENGTH           512
    


// definitions

#define is                          ==
#define and                         &&
#define or                          ||

#define GLOBAL_HEAP                 g_ce.hGlobalHeap
#define TRACEID                     g_ce.dwTraceID
#define LOGLEVEL                    g_ce.dwLogLevel
#define LOGHANDLE                   g_ce.hLogHandle
#define LOCKSTORE                   g_ce.dlsDynamicLocksStore

// invoked when entering API or worker functions
#define ENTER_SAMPLE_API()          EnterSampleAPI()
#define ENTER_SAMPLE_WORKER()       EnterSampleWorker()

// invoked when leaving API or worker functions
#define LEAVE_SAMPLE_API()          LeaveSampleWorker()
#define LEAVE_SAMPLE_WORKER()       LeaveSampleWorker()

// dynamic locks
#define ACQUIRE_READ_DLOCK(pLock)                                   \
    AcquireDynamicReadwriteLock(&pLock, READ_MODE, LOCKSTORE)
#define RELEASE_READ_DLOCK(pLock)                                   \
    ReleaseDynamicReadwriteLock(pLock, READ_MODE, LOCKSTORE)
#define ACQUIRE_WRITE_DLOCK(pLock)                                  \
    AcquireDynamicReadwriteLock(&pLock, WRITE_MODE, LOCKSTORE)
#define RELEASE_WRITE_DLOCK(pLock)                                  \
    ReleaseDynamicReadwriteLock(pLock, WRITE_MODE, LOCKSTORE)



// macros

#define SECTOMILLISEC(x)            ((x) * 1000)
#define MAX(a, b)                   (((a) >= (b)) ? (a) : (b))
#define MIN(a, b)                   (((a) <= (b)) ? (a) : (b))



// IP ADDRESS

// type
typedef DWORD   IPADDRESS, *PIPADDRESS;


// definitions
#define IP_LOWEST                   0x00000000
#define IP_HIGHEST                  0xffffffff
#define STAR                        0x00000000


// macros

// compare a and b
#define IP_COMPARE(a, b)            (((a) < (b)) ? -1       \
                                                 : (((a) is (b)) ? 0 : 1)) 

// assign b to a 
#define IP_ASSIGN(pip, ip)          *(pip) = (ip)

// verify whether an ip address is valid
#define IP_VALID(ip)                (IP_COMPARE(ip, IP_HIGHEST) is -1)

// returns the string representation of an ip address in a static buffer
#define INET_NTOA(x)                (inet_ntoa(*(struct in_addr*)&(x)))
    


// TIMER

// macros

#define CREATE_TIMER(phHandle, pfnCallback, pvContext, ulWhen, pdwErr)      \
{                                                                           \
    if (CreateTimerQueueTimer((phHandle),                                   \
                              g_ce.hTimerQueue,                             \
                              (pfnCallback),                                \
                              (pvContext),                                  \
                              SECTOMILLISEC(ulWhen),                        \
                              INFINITE_INTERVAL,                            \
                              0))                                           \
    {                                                                       \
        *(pdwErr) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwErr) = GetLastError();                                         \
        TRACE1(ANY, "Error %u creating timer", *(pdwErr));                  \
        LOGERR0(CREATE_TIMER_FAILED, *(pdwErr));                            \
    }                                                                       \
}

// it is safe to hold locks while making this call since
// it is non blocking (NULL for hCompletionEvent).
#define DELETE_TIMER(hHandle, pdwErr)                                       \
{                                                                           \
    if (DeleteTimerQueueTimer(g_ce.hTimerQueue,                             \
                              (hHandle),                                    \
                              NULL))                                        \
    {                                                                       \
        *(pdwErr) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwErr) = GetLastError();                                         \
        TRACE1(ANY, "Error %u deleting timer, continuing...", *(pdwErr));   \
    }                                                                       \
}

#define RESTART_TIMER(hHandle, ulWhen, pdwErr)                              \
{                                                                           \
    if (ChangeTimerQueueTimer(g_ce.hTimerQueue,                             \
                              (hHandle),                                    \
                              SECTOMILLISEC(ulWhen),                        \
                              INFINITE_INTERVAL))                           \
    {                                                                       \
        *(pdwErr) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwErr) = GetLastError();                                         \
        TRACE1(ANY, "Error %u restarting timer, continuing...", *(pdwErr)); \
    }                                                                       \
}



// MEMORY ALLOCATION

// macros
#define MALLOC(ppPointer, ulSize, pdwErr)                                   \
{                                                                           \
    if (*(ppPointer) = HeapAlloc(GLOBAL_HEAP, HEAP_ZERO_MEMORY, (ulSize)))  \
    {                                                                       \
        *(pdwErr) = NO_ERROR;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(pdwErr) = ERROR_NOT_ENOUGH_MEMORY;                                \
        TRACE1(ANY, "Error allocating %u bytes", (ulSize));                 \
        LOGERR0(HEAP_ALLOC_FAILED, *(pdwErr));                              \
    }                                                                       \
}
#define REALLOC(ptr, size)          HeapReAlloc(GLOBAL_HEAP, 0, ptr, size)
#define FREE(ptr)                                           \
{                                                           \
     HeapFree(GLOBAL_HEAP, 0, (ptr));                       \
     (ptr) = NULL;                                          \
}
         
#define FREE_NOT_NULL(ptr)                                  \
{                                                           \
     if (!(ptr)) HeapFree(GLOBAL_HEAP, 0, (ptr));           \
     (ptr) = NULL;                                          \
}



// TRACING

// definitions...
#define IPSAMPLE_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_ENTER           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_DEBUG           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_CONFIGURATION   ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_NETWORK         ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_PACKET          ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_TIMER           ((DWORD)0x00800000 | TRACE_USE_MASK)
#define IPSAMPLE_TRACE_MIB             ((DWORD)0x01000000 | TRACE_USE_MASK)


// macros...
#define TRACE0(l,a)                                                     \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a)
#define TRACE1(l,a,b)                                                   \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)                                                 \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)                                               \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)                                             \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)                                           \
    if (TRACEID != INVALID_TRACEID)                                     \
        TracePrintfEx(TRACEID, IPSAMPLE_TRACE_ ## l, a, b, c, d, e, f)

        

// EVENT LOGGING

// definitions...
#define LOGERR              RouterLogError
#define LOGWARN             RouterLogWarning
#define LOGINFO             RouterLogInformation
#define LOGWARNDATA         RouterLogWarningData


// macros...

//      ERRORS
#define LOGERR0(msg,err)                                                \
        if (LOGLEVEL >= IPSAMPLE_LOGGING_ERROR)                         \
            LOGERR(LOGHANDLE,IPSAMPLELOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err)                                              \
