     ddeServer->PostAdvise(hszGameNumber);
    }

    ResetHandInfo(-1);

    ::srand(m_gamenumber);

    {
        CScoreDlg score(this);
        score.ResetScore();
    }                           // destruct score

    TRACE1("\n\ngame number is %d\n\n", m_gamenumber);
    DUMP();
    TRACE0("\n\n");

    Shuffle();
}


/****************************************************************************

CMainWindow::OnOptions -- user requests options dialog from menu

****************************************************************************/

void CMainWindow::OnOptions()
{
    COptionsDlg optionsdlg(this);
    optionsdlg.DoModal();
}


/****************************************************************************

CMainWindow::OnPaint

****************************************************************************/

void CMainWindow::OnPaint()
{
    CPaintDC dc( this );
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif

    // players must be painted in order starting with playerled so that
    // cards in centre overlap correctly

    if (bConstructed)
    {
        int start = Id2Pos(handinfo.playerled % 4);

        // check that someone has started

        if (start >= 0)
        {
            for (int i = start; i < (MAXPLAYER+start); i++)
            {
                int pos = i % 4;
                if (p[pos])
                {
                    if (p[pos]->GetMode() == SCORING)
                    {
                        p[pos]->DisplayHeartsWon(dc);
                    }
                    else
                    {
                        p[pos]->Draw(dc, bCheating);
                        p[pos]->MarkSelectedCards(dc);
                    }
                }
            }
        }
    }
}


/****************************************************************************

CMainWindow::OnPass

This function handles the local human pressing the button either to
pass selected cards or to accept cards passed.

****************************************************************************/

void CMainWindow::OnPass()
{
    if (p[0]->GetMode() == ACCEPTING)       // OK (accepting passed cards)
    {
        m_Button.ShowWindow(SW_HIDE);
        m_Button.SetWindowText(TEXT(""));
        p[0]->SetMode(WAITING);             // local human pushed the button

        CRect rect;
        p[0]->GetCoverRect(rect);

        for (SLOT s = 0; s < MAXSLOT; s++)
            p[0]->Select(s, FALSE);

        InvalidateRect(&rect, TRUE);
        UpdateWindow();

        FirstMove();

        for (int i = 0; i < ::cQdMoves; i++)
            HandleMove(::moveq[i]);

        ::cQdMoves = 0;
        ::cQdPasses = 0;

        return;
    }

    m_Button.EnableWindow(FALSE);
    p[0]->SetMode(DONE_SELECTING);

    BOOL bReady = TRUE;

    for (int i = 1; i < MAXPLAYER; i++)
        if (p[i]->GetMode() != DONE_SELECTING)
            bReady = FALSE;

    if (!bReady)
        p[0]->UpdateStatus(IDS_PASSWAIT);

    if (role == GAMEMEISTER)
    {
        ddeServer->PostAdvise(hszPass);     // let other players know
    }
    else
    {
        PASS3   pass3;

        pass3.id = m_myid;
        pass3.passdir = passdir;
        p[0]->ReturnSelectedCards(pass3.cardid);
        ddeClient->Poke(hszPass, &pass3, sizeof(pass3));
    }

    if (bReady)
        HandlePassing();
}


/****************************************************************************

CMainWindow::OnRef

After a human or a computer plays a card, they must
PostMessage(WM_COMMAND, IDM_REF)
which causes this routine (the referee) to be called.

Ref does the following:
    - updates handinfo data struct
    - calls HeartsPlaySound() if appropriate
    - determines if the hand is over or, if not, whose turn is next

****************************************************************************/

void CMainWindow::OnRef()
{
    card *c = handinfo.cardplayed[handinfo.turn];

    if (!handinfo.bHeartsBroken)
    {
        if (c->Suit() == HEARTS)
        {
            handinfo.bHeartsBroken = TRUE;
            HeartsPlaySound(SND_BREAK);
        }
    }

    if (c->ID() == BLACKLADY)
    {
        handinfo.bQSPlayed = TRUE;
        HeartsPlaySound(SND_QUEEN);
    }

/* ------------------------------------------------
#if defined(_DEBUG)
    TRACE("[%d] ", m_myid);
    TRACE("h.turn %d, ", handinfo.turn);
    TRACE("led %d, ", handinfo.playerled);
    for (int i = 0; i < 4; i++)
    {
        if (handinfo.cardplayed[i])
            { CDNAME(handinfo.cardplayed[i]); }
        else
            { TRACE("-- "); }
    }
    TRACE("\n",);
#endif
------------------------------------------------ */

    int pos = Id2Pos(handinfo.turn);
    SLOT slot = p[pos]->GetSlot(handinfo.cardplayed[handinfo.turn]->ID());

#if defined(_DEBUG)
    if (p[pos]->IsHuman())
        ((human *)p[pos])->DebugMove(slot);
#endif

    p[pos]->GlideToCentre(slot, pos==0 ? TRUE : bCheating);

    handinfo.turn++;
    handinfo.turn %= 4;

    int newpos = Id2Pos(handinfo.turn);

    if (handinfo.turn == handinfo.playerled)
    {
        EndHand();
    }
    else
    {
        p[newpos]->SelectCardToPlay(handinfo, bCheating);

        if (newpos != 0)
            ((local_human *)p[0])->WaitMessage(p[newpos]->GetName());
    }
}


/****************************************************************************

CMainWindow::OnScore -- user requests score dialog from menu

****************************************************************************/

void CMainWindow::OnScore()
{
    CScoreDlg scoredlg(this);       // this constructor does not add new info
    scoredlg.DoModal();
}


/****************************************************************************

CMainWindow::DoSort

****************************************************************************/

void CMainWindow::DoSort()
{
    for (int i = 0; i < (bCheating ? MAXPLAYER : 1); i++)
    {
        CRect   rect;
        int     id;             // card in play for this player

        if (handinfo.cardplayed[i] == NULL)
            id = EMPTY;
        else
            id = handinfo.cardplayed[i]->ID();

        p[i]->Sort();

        if (id != EMPTY)    // if this player has a card in play, restore it
        {
            for (SLOT s = 0; s < MAXSLOT; s++)
            {
                if (p[i]->GetID(s) == id)
                {
                    handinfo.cardplayed[i] = p[i]->Card(s);
                    break;
                }
            }
        }

        p[i]->GetCoverRect(rect);
        InvalidateRect(&rect, TRUE);
    }
}


/****************************************************************************

CMainWindow::OnSound()

request sound on or off from menu.

****************************************************************************/

void CMainWindow::OnSound()
{
    RegEntry    Reg(szRegPath);

    bSoundOn = !bSoundOn;

    CMenu *pMenu = GetMenu();
    pMenu->CheckMenuItem(IDM_SOUND, bSoundOn ? MF_CHECKED : MF_UNCHECKED);

    if (bSoundOn)
        Reg.SetValue(regvalSound, 1);
    else
        Reg.DeleteValue(regvalSound);
}


/****************************************************************************

CMainWindow::OnPrintClient()

Draw background into the specified HDC.  This is used when drawing
the "Pass" button in the Luna style.

****************************************************************************/

LRESULT CMainWindow::OnPrintClient(WPARAM wParam, LPARAM lParam)
{
    CDC dc;
    CRect rect;

    dc.Attach((HDC)wParam);
    GetClientRect(&rect);
    dc.FillRect(&rect, &m_BgndBrush);
    dc.Detach();
   
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\main2.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

main2.cpp

Aug 92, JimH
May 93, JimH    chico port

Additional member functions for CMainWindow are here.

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "resource.h"
#include "debug.h"


/****************************************************************************

CMainWindow::Shuffle -- user requests shuffle from menu

****************************************************************************/

void CMainWindow::Shuffle()
{
    static  int offset[MAXPLAYER] = { 1, 3, 2, 0 };     // passdir order

    // fill temp array with consecutive values

    int temp[52];                   // array of card values
    for (int i = 0; i < 52; i++)
        temp[i] = i;

    //  Sort cards

    int nLeft = 52;
    for (i = 0; i < 52; i++)
    {
        int j = ::rand() % nLeft;
        int id = i/13;
        int pos = Id2Pos(id);               // convert id to position
        p[pos]->SetID(i%13, temp[j]);
        p[pos]->Select(i%13, FALSE);
        temp[j] = temp[--nLeft];
    }

    // display PASS button

    if (passdir != NOPASS)
    {
        CString text;
        text.LoadString(IDS_PASSLEFT + passdir);
        m_Button.SetWindowText(text);
        m_Button.EnableWindow(FALSE);
        m_Button.ShowWindow(SW_SHOW);
    }

    // set card locs and ask players to select cards to pass

    for (i = 0; i < MAXPLAYER; i++)
    {
        p[i]->ResetLoc();

        if (passdir != NOPASS)
            p[i]->SelectCardsToPass();
    }

    // Make sure everyone gets appropriate little white dots

    if (passdir != NOPASS)
    {
        if (role == PLAYER)
            ddeClient->Poke(hszPassUpdate, TEXT(""));     // ask for update
        else
            ddeServer->PostAdvise(hszPass);         // inform players
    }

    //  Paint main window.  This is done manually instead of just
    //  invalidating the rectangle so that the cards are drawn in
    //  order as if they are dealt, instead of a player at a time.

    CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    CRect       rect;
    GetClientRect(rect);
    dc.FillRect(&rect, &m_BgndBrush);

    for (SLOT s = 0; s < MAXSLOT; s++)
        for (i = 0; i < MAXPLAYER; i++)
            p[i]->Draw(dc, bCheating, s);

    for (i = 0; i < MAXPLAYER; i++)
    {
        if (passdir == NOPASS)
            p[i]->NotifyNewRound();
        else
        {
            p[i]->MarkSelectedCards(dc);
            CString sSelect;
            sSelect.LoadString(IDS_SELECT);
            CString sName;
            int passto = (i + offset[passdir]) % 4;
            sName = p[passto]->GetName();
            TCHAR string[100];
            wsprintf(string, sSelect, sName);
            p[i]->UpdateStatus(string);
        }
    }

    DoSort();
}


/****************************************************************************

CMainWindow::HandlePassing()

This function first checks to make sure each player is DONE_SELECTING,
and then transfers the cards from hand to hand.

This function is called by the gamemeister when he presses the pass
button, or when notification arrives that a remote human has selected
cards to pass.

It returns FALSE if cards were not passed (because a remote human was
still selecting) and TRUE if cards were successfully passed.

****************************************************************************/

BOOL CMainWindow::HandlePassing()
{
    int     passto[MAXPLAYER];
    int     temp[MAXPLAYER][3];

    static  int offset[MAXPLAYER] = { 1, 3, 2, 0 };

    for (int pos = 0; pos < MAXPLAYER; pos++)
        if (p[pos]->GetMode() != DONE_SELECTING)
            return FALSE;

    for (pos = 0; pos < MAXPLAYER; pos++)
    {
        passto[pos] = ((pos + offset[passdir]) % 4);
        p[pos]->ReturnSelectedCards(temp[pos]);
    }

    for (pos = 0; pos < MAXPLAYER; pos++)
        p[passto[pos]]->ReceiveSelectedCards(temp[pos]);

    for (pos = 0; pos < MAXPLAYER; pos++)
        if (bCheating || (pos == 0))
            p[pos]->Sort();

    tricksleft = MAXSLOT;

    passdir++;
    if (passdir > NOPASS)
        passdir = LEFT;

    for (pos = 0; pos < MAXPLAYER; pos++)
        p[pos]->NotifyNewRound();           // notify players cards are passed

    CString s;
    s.LoadString(IDS_OK);
    m_Button.SetWindowText(s);
    OnShowButton();

    for (pos = 0; pos < MAXPLAYER; pos++)
    {
        CRect   rect;

        if (pos == 0 || bCheating)
            p[pos]->GetCoverRect(rect);
        else
            p[pos]->GetMarkingRect(rect);

        InvalidateRect(&rect, TRUE);
    }

    UpdateWindow();
    return TRUE;
}


/****************************************************************************

CMainWindow::FirstMove

resets cardswon[] and tells owner of two of clubs to start hand

****************************************************************************/

void CMainWindow::FirstMove()
{
    for (int pos = 0; pos < MAXPLAYER; pos++)
    {
        p[pos]->SetMode(WAITING);
        p[pos]->ResetCardsWon();
    }

    for (pos = 0; pos < MAXPLAYER; pos++)
    {
        for (SLOT s = 0; s < MAXSLOT; s++)
        {
            if (p[pos]->GetID(s) == TWOCLUBS)
            {
                int id = Pos2Id(pos);
                ResetHandInfo(id);
                handinfo.bHeartsBroken = FALSE;
                handinfo.bQSPlayed = FALSE;
                handinfo.bShootingRisk = TRUE;
                handinfo.nMoonShooter = EMPTY;
                handinfo.bHumanShooter = FALSE;
                p[pos]->SelectCardToPlay(handinfo, bCheating);

                if (pos != 0)
                    ((local_human *)p[0])->WaitMessage(p[pos]->GetName());

                return;
            }
        }
    }
}


/****************************************************************************

CMainWindow::EndHand
TimerDispatch
CMainWindow::DispatchCards

The Ref calls this routine at the end of each hand.  It is logically
a single routine, but is broken up so that there is a delay before the
cards are zipped off the screen.

EndHand() calculates who won the hand (trick) and starts a timer.

TimerDispatch() receives the time message and calls DispatchCards().

DispatchCards()

****************************************************************************/

void CMainWindow::EndHand()
{
    /* determine suit led */

    int  playerled = handinfo.playerled;
    card *cardled  = handinfo.cardplayed[playerled];
    int  suitled   = cardled->Suit();
    int  value     = cardled->Value2();

    trickwinner = playerled;               //  by default

    //  Let players update tables, etc.

    for (int i = 0; i < 4; i++)
        p[i]->NotifyEndHand(handinfo);

    // check if anyone else played a higher card of the same suit

    for (i = playerled; i < (playerled+4); i++)
    {
        int j = i % 4;
        card *c = handinfo.cardplayed[j];
        if (c->Suit() == suitled)
        {
            int v = c->Value2();

            if (v > value)
            {
                value = v;
                trickwinner = j;
            }
        }
    }

    TRACE0("\n");

    // Update moonshoot portion of handinfo

    if (handinfo.bShootingRisk)
    {
        BOOL bPoints = FALSE;               // point cards this hand?

        for (i = 0; i < 4; i++)
        {
            card *c = handinfo.cardplayed[i];
            if ((c->Suit() == HEARTS) || (c->ID() == BLACKLADY))
                bPoints = TRUE;
        }

        if (bPoints)
        {
            if (handinfo.nMoonShooter == EMPTY)
            {
                handinfo.nMoonShooter = trickwinner;  // first points this round
                handinfo.bHumanShooter = p[trickwinner]->IsHuman();
                TRACE2("First points to p[%d] (%s)\n", trickwinner,
                    handinfo.bHumanShooter ? TEXT("human") : TEXT("computer"));
            }

            else if (handinfo.nMoonShooter != trickwinner)   // new point earner
            {
                handinfo.bShootingRisk = FALSE;
                TRACE0("Moon shot risk over\n");
            }
        }
    }

    // Start a timer so there is a delay between when the last card of
    // the trick is played, and when the cards are whisked off toward
    // the trick winner (dispatched.)  If the timer fails, just call
    // DispatchCards() directly.  The timer id is m_myid instead of a
    // constant so there's no conflict if you run multiple instances on
    // a single machine using local DDE, which is useful for testing.

    if (SetTimer(m_myid, 1000, TimerDispatch))
        bTimerOn = TRUE;
    else
    {
        bTimerOn = FALSE;
        DispatchCards();
    }
}


// for MFC1, this would return UINT and 3rd parameter would be int
// for MFC2, this would return VOID and 3rd parameter would be UINT

#if defined (MFC1)

inline UINT FAR PASCAL EXPORT
    TimerDispatch(HWND hWnd, UINT nMsg, int nIDEvent, DWORD dwTime)
{
    ::pMainWnd->DispatchCards();  // sneak back into a CMainWindow member func.
    return 0;
}

#else

inline VOID FAR PASCAL EXPORT
    TimerDispatch(HWND hWnd, UINT nMsg, UINT_PTR nIDEvent, DWORD dwTime)
{
    ::pMainWnd->DispatchCards();  // sneak back into a CMainWindow member func.
}

#endif



void CMainWindow::DispatchCards()
{
    KillTimer(m_myid);

    bTimerOn = FALSE;
    int score[MAXPLAYER];

    int poswinner = Id2Pos(trickwinner);

    // Determine who led so cards can be removed in reverse order.

    int  playerled = handinfo.playerled;
    card *cardled  = handinfo.cardplayed[playerled];

    // build up background bitmap for Glide()

    for (int i = (playerled + 3); i >= playerled; i--)
    {
        CDC *memdc = new CDC;
        CClientDC dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
        memdc->CreateCompatibleDC(&dc);
        memdc->SelectObject(&card::m_bmBgnd);
        memdc->SelectObject(&m_BgndBrush);
        memdc->PatBlt(0, 0, card::dxCrd, card::dyCrd, PATCOPY);
        card *c = handinfo.cardplayed[i % 4];

        // If cards overlap, there is some extra work to do because the cards
        // still in player 0's or 2's hands may overlap cards that have been
        // played, so they have to get blted in first.

        if (TRUE)  // bugbug should be able to check for overlap here
        {
            for (int pos = 0; pos < MAXPLAYER; pos += 2)
            {
                int mode = ((pos == 0 || bCheating) ? FACEUP : FACEDOWN);

                for (SLOT s = 0; s < MAXSLOT; s++)
                {
                    card *c2 = p[pos]->Card(s);
                    int x = c2->GetX() - c->GetX();
                    int y = c2->GetY() - c->GetY();
                    if (!c2->IsPlayed())
                        c2->Draw(*memdc, x, y, mode, FALSE);
                }
            }
        }

        // Everyone needs to check for overlap of played cards.

        for (int j = playerled; j < i; j++)
        {
            card *c2 = handinfo.cardplayed[j % 4];
            int x = c2->GetX() - c->GetX();
            int y = c2->GetY() - c->GetY();
            c2->Draw(*memdc, x, y, FACEUP, FALSE);
        }

        delete memdc;

        p[poswinner]->WinCard(dc, c);
        c->Remove();
    }

    ResetHandInfo(trickwinner);

    // If there are more tricks left before we need to reshuffle,
    // ask the winner of this trick to start next hand, and we're done.

    if (--tricksleft)
    {
        p[poswinner]->SelectCardToPlay(handinfo, bCheating);

        if (poswinner != 0)
            ((local_human *)p[0])->WaitMessage(p[poswinner]->GetName());

        if (::cQdMoves > 0)
        {
            for (int i = 0; i < ::cQdMoves; i++)
                HandleMove(::moveq[i]);

            ::cQdMoves = 0;
        }

        return;
    }

    // Make sure sound buffer is freed up.

    HeartsPlaySound(OFF);

    // Display hearts (and queen of spades) next to whoever "won" them.

    int nMoonShot = EMPTY;                  // assume nobody shot moon
    for (i = 0; i < MAXPLAYER; i++)
    {
        BOOL bMoonShot;
        score[i] = p[i]->EvaluateScore(bMoonShot);
        if (bMoonShot)
            nMoonShot = i;                  // scores need to be adjusted

        CClientDC dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
        p[i]->DisplayHeartsWon(dc);
        p[i]->SetMode(SCORING);
    }

    // adjust scores if someone collected all hearts AND queen of spades

    if (nMoonShot != EMPTY)
    {
        for (i = 0; i < MAXPLAYER; i++)
        {
            if (i == nMoonShot)
                score[i] -= 26;
            else
                score[i] += 26;

            p[i]->SetScore(score[i]);       // adjust player score manually
        }
    }

    // Show score

    p[0]->UpdateStatus(IDS_SCORE);
    p[0]->SetMode(SCORING);
    CScoreDlg scoredlg(this, score, m_myid);    // update scores in scoredlg

    player *pold = p[0];

    scoredlg.DoModal();                         // display scores

    // If there has been a request to shut down while the score dialog
    // is displayed, m_FatalErrno will be non-zero.

    if (m_FatalErrno != 0)
    {
        p[0]->SetMode(PLAYING);         // something other than SCORING...
        FatalError(m_FatalErrno);       // so FatalError will accept it.
        return;
    }

    // It's possible for another player to have quit the game while
    // the score dialog was showing, so check that we're still
    // alive and well.

    if (p[0] != pold)
        return;

    // replace quit remote humans with computer players

    for (i = 1; i < MAXPLAYER; i++)
    {
        if (p[i]->HasQuit())
        {
            CString name = p[i]->GetName();
            int scoreLocal = p[i]->GetScore();
            delete p[i];
            p[i] = new computer(i);             // check for failure
            CClientDC dc(this);
            p[i]->SetName(name, dc);
            p[i]->SetScore(scoreLocal);
        }
    }

    p[0]->SetMode(passdir == NOPASS ? DONE_SELECTING : SELECTING);

    if (scoredlg.IsGameOver())
    {
        GameOver();
        return;
    }

    Shuffle();

    // If there is no passing for upcoming round, we must make the changes
    // that HandlePassing() would normally do to start the next round.

    if (passdir == NOPASS)
    {
        for (i = 0; i < MAXPLAYER; i++)         // everyone's DONE_SELECTING
            p[i]->SetMode(DONE_SELECTING);

        passdir = LEFT;                         // NEXT hand passes left
        tricksleft = MAXSLOT;                   // reset # of hands
        FirstMove();                            // start next trick
    }

    for (i = 0; i < ::cQdMoves; i++)
        HandleMove(::moveq[i]);

    ::cQdMoves = 0;

    for (i = 0; i < ::cQdPasses; i++)
        HandlePass(::passq[i]);

    ::cQdPasses = 0;
}


/****************************************************************************

CMainWindow::ResetHandInfo

Note that handinfo.bHeartsBroken is not reset here -- it applies to
the entire hand and is set only in FirstMove()

Same with handinfo.bQSPlayed and moonshoot variables.

****************************************************************************/

void CMainWindow::ResetHandInfo(int playernumber)
{
    handinfo.playerled = playernumber;
    handinfo.turn      = playernumber;
    for (int i = 0; i < MAXPLAYER; i++)
        handinfo.cardplayed[i] = NULL;
}


/****************************************************************************

CMainWindow::CountClients()

Count of number of clients active (including computer players)
Only the GameMeister calls this, so potential clients are pos 1 to 3.

****************************************************************************/

int CMainWindow::CountClients()
{
    ASSERT(role == GAMEMEISTER);

    int cb = 0;

    for (int pos = 1; pos < MAXPLAYER; pos++)
        if (p[pos])
            cb++;

    return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\regentry.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991-1994                    **/
/***************************************************************************/


/****************************************************************************

regentry.h

Mar. 94     JimH

Wrapper for registry access


Construct a RegEntry object by specifying the subkey (under
HKEY_CURRENT_USER by default, but can be overridden.)

All member functions are inline so there is minimal overhead.

All member functions (except the destructor) set an internal
error state which can be retrieved with GetError().
Zero indicates no error.

RegEntry works only with strings and DWORDS which are both set
using the overloaded function SetValue()

    SetValue("valuename", "string");
    SetValue("valuename", 42);
    
Values are retrieved with GetString() and GetNumber().  GetNumber()
allows you to specificy a default if the valuename doesn't exist.

DeleteValue() removes the valuename and value pair.

****************************************************************************/

#ifndef REGENTRY_INC
#define REGENTRY_INC

#ifndef STRICT
#define STRICT
#endif

#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS   0
#endif

#include <windows.h>

class RegEntry
{
    public:
        RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~RegEntry()         { if (_bConstructed) RegCloseKey(_hkey); }
        
        long    GetError()  { return _error; }
        long    SetValue(const TCHAR *pszValue, const TCHAR *string);
        long    SetValue(const TCHAR *pszValue, long dwNumber);
        TCHAR * GetString(const TCHAR *pszValue, TCHAR *string, DWORD length);
        long    GetNumber(const TCHAR *pszValue, long dwDefault = 0);
        long    DeleteValue(const TCHAR *pszValue);
        long    FlushKey()  { if (_bConstructed) return RegFlushKey(_hkey);
                              else return NULL; }

    private:
        HKEY    _hkey;
        long    _error;
        long    _bConstructed;

};

inline RegEntry::RegEntry(const TCHAR *pszSubKey, HKEY hkey)
{
    _error = RegCreateKey(hkey, pszSubKey, &_hkey);
    _bConstructed = (_error == ERROR_SUCCESS);
}


inline long RegEntry::SetValue(const TCHAR *pszValue, const TCHAR *string)
{
    if (_bConstructed)
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
                    (BYTE *)string, sizeof(TCHAR) * (lstrlen(string)+1));

    return _error;
}

inline long RegEntry::SetValue(const TCHAR *pszValue, long dwNumber)
{
    if (_bConstructed)
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
                    (BYTE *)&dwNumber, sizeof(dwNumber));

    return _error;
}

inline TCHAR *RegEntry::GetString(const TCHAR *pszValue, TCHAR *string, DWORD length)
{
    DWORD    dwType = REG_SZ;
    
    if (!_bConstructed)
        return NULL;

    _error = RegQueryValueEx(_hkey, pszValue, 0, &dwType, (LPBYTE)string,
                &length);

    if (_error)
        *string = '\0';

    return string;
}

inline long RegEntry::GetNumber(const TCHAR *pszValue, long dwDefault)
{
    DWORD    dwType = REG_BINARY;
    long    dwNumber;
    DWORD    dwSize = sizeof(dwNumber);

    if (!_bConstructed)
        return 0;

    _error = RegQueryValueEx(_hkey, pszValue, 0, &dwType, (LPBYTE)&dwNumber,
                &dwSize);
    
    if (_error)
        dwNumber = dwDefault;
    
    return dwNumber;
}

inline long RegEntry::DeleteValue(const TCHAR *pszValue)
{
    if (_bConstructed)
        _error = RegDeleteValue(_hkey, pszValue);
    
    return _error;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\sound.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

sound.cpp

Aug 92, JimH
May 93, JimH    chico port

SoundInit() just verifies that a wave driver is loaded.
HeartsPlaySound() plays the sound given a resource id.

****************************************************************************/


#include "hearts.h"
#include <mmsystem.h>

#include "main.h"
#include "resource.h"
#include "debug.h"


/****************************************************************************

SoundInit()

returns TRUE if sound is enabled.

****************************************************************************/

BOOL CMainWindow::SoundInit()
{
    return (::waveOutGetNumDevs() > 0);
}


/****************************************************************************

CMainWindow::HeartsPlaySound(id)

Plays the specified sound from the resource file.

The static variable hRes is used as a flag to know if memory has been
allocated and locked for the sound.  If hRes is non-zero, a sound is
still playing, or at least the memory for the sound has not been unlocked
and freed.  The application must call HeartsPlaySound(NULL, 0) to free this
memory before exiting.  (The game destructor does this.  It also
happens at the end of each hand.)

****************************************************************************/

BOOL CMainWindow::HeartsPlaySound(int id)
{
    static  HRSRC  hRes = 0;

    if (!bHasSound)                 // check for sound capability
        return TRUE;

    if (id == OFF)                  // request to turn off sound
    {
        if (hRes == 0)              // hRes != 0 if a sound has been played...
            return TRUE;            // and not freed.

        sndPlaySound(NULL, 0);      // make sure sound is stopped
        UnlockResource(hRes);
        FreeResource(hRes);
        hRes = 0;
        return TRUE;
    }

    if (!bSoundOn)                  // has user toggled sound off?
        return TRUE;

    // User has requested a sound.  Check if previous sound was freed.

    if (hRes != 0)
        HeartsPlaySound(OFF);

    BOOL bReturn;

    HINSTANCE hInst = AfxGetInstanceHandle();
    HRSRC  hResInfo = FindResource(hInst, MAKEINTRESOURCE(id), TEXT("WAVE"));
    if (!hResInfo)
        return FALSE;

    hRes = (HRSRC) ::LoadResource(hInst, hResInfo);
    if (!hRes)
        return FALSE;

    LPTSTR lpRes = (LPTSTR) ::LockResource(hRes);
    if (lpRes)
        bReturn = ::sndPlaySound(lpRes, SND_MEMORY | SND_ASYNC | SND_NODEFAULT);
    else
        bReturn = FALSE;

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\resource.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


#define IDM_ABOUT       101
#define IDM_NEWGAME     102
#define IDM_EXIT        103
#define IDM_HELP        106
#define IDM_SEARCH      110
#define IDM_HELPONHELP  112
#define IDM_BOSSKEY     114
#define IDM_BUTTON      115
#define IDM_SHOWBUTTON  116
#define IDM_HIDEBUTTON  117
#define IDM_STATUS      118
#define IDM_REPAINTMSG  119
#define IDM_ALLPASSED   120
#define IDM_CHEAT       121
#define IDM_MENU        122
#define IDM_REF         123
#define IDM_SOUND       124
#define IDM_SCORE       125
#define IDM_WELCOME     126
#define IDM_QUOTE       127
#define IDM_OPTIONS     128

#define IDC_YOURNAME    201
#define IDC_JOIN        202
#define IDC_MEISTER     203
#define IDC_SERVERNAME  204
#define IDC_WELCOMEHELP 205
#define IDC_BLOOD       208
#define IDC_SCORE       209
#define IDC_PLAYER1     210
#define IDC_PLAYER2     211
#define IDC_PLAYER3     212
#define IDC_OPHELP      213
#define IDC_GROUP       214
#define IDC_SLOW        215
#define IDC_NORMAL      216
#define IDC_FAST        217
#define IDC_NAME1       218
#define IDC_NAME2       219
#define IDC_NAME3       220
#define IDC_AUTO        221
#define IDC_AUTOGROUP   222
#define IDC_BROWSE      223
#define IDC_LOCATEHELP  224

#define IDS_MEMORY      301
#define IDS_APPNAME     AFX_IDS_APP_TITLE
#define IDS_P1NAME      303             // P1, P2, & P3NAME must be consecutive
#define IDS_P2NAME      304
#define IDS_P3NAME      305
#define IDS_INTRO       306
#define IDS_SELECT      307
#define IDS_CONNECTING  308
#define IDS_PASSWAIT    309
#define IDS_WAIT        310
#define IDS_GO          311
#define IDS_BADMOVE     312
#define IDS_LEADHEARTS  313
#define IDS_LEAD2C      314
#define IDS_ACCEPT      315
#define IDS_OK          316
#define IDS_SCORE       317
#define IDS_SCORESHEET  318
#define IDS_PLACE1      319
#define IDS_PLACE2      320
#define IDS_PLACE3      321
#define IDS_PLACE4      322

#define IDS_DISCONNECT  323
#define IDS_NOSERVER    324
#define IDS_SERVERFAIL  325
#define IDS_CARDSDLL    326
#define IDS_VERSION     327
#define IDS_PWAIT       328
#define IDS_GMWAIT      329
#define IDS_BUSY        330
#define IDS_TIMEOUT     331
#define IDS_UNKNOWNERR  332
#define IDS_GAMEOVER    333
#define IDS_GAMEOVERWIN 334
#define IDS_NETWORK     335
#define IDS_NOTREADY    336
#define IDS_AGAIN       337
#define IDS_BADBLOOD    338
#define IDS_UNKNOWN     339
#define IDS_DEALER      340

#define IDS_CREDITS     399

#define IDS_SUIT0       401             // these MUST be consecutive values!
#define IDS_SUIT1       402
#define IDS_SUIT2       403
#define IDS_SUIT3       404

#define IDS_PASSLEFT    405             // these MUST be consecutive values!
#define IDS_PASSRIGHT   406
#define IDS_PASSACROSS  407

#define IDS_FONTFACE 	410
#define IDS_CHARSET     411
#define IDS_FONTSIZE    412
#define IDS_STARTMENUNAME 413
#define IDS_INFOTIP     414

#define SND_BREAK       401
#define SND_QUEEN       402
#define SND_QUOTE       403

#define DLG_QUOTE       501
#define DLG_SCORE       502
#define DLG_WELCOME     503
#define DLG_OPTIONS     505
#define DLG_LOCATE      506
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\reversi\reversi.h ===
#define BoardSize           100 
#define edge                0
#define empty               1
#define human               2
#define computer            3
#define infin               32767
#define win                 32000
#define loss                (-32000)
#define max_depth           6

#define PASS                20
#define NEW                 25
#define BSkill              40
#define EASY                41
#define MEDIUM              42
#define HARD                44
#define VHARD               46
#define HINT                50
#define EXIT                52


/* Menu ID's */

#define MN_HELP_INDEX       30
#define MN_HELP_KEYBOARD    31
#define MN_HELP_COMMANDS    32
#define MN_HELP_PLAYING     33
#define MN_HELP_RULES       34
#define MN_HELP_USINGHELP   35
#define MN_HELP_ABOUT       36
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\welcome.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

welcome.cpp

Aug 92, JimH
May 93, JimH    chico port

more CMainWindow member functions


CTheApp::InitInstance() posts a IDM_WELCOME message as soon as it has
constructed and shown the main window.  This file includes that message's
handler (OnWelcome) and some support routines.

****************************************************************************/

#include "hearts.h"
#include <nddeapi.h>

#include "main.h"
#include "resource.h"
#include "debug.h"

extern "C" {
HINSTANCE FAR PASCAL WNetGetCaps(WORD);     // winnet.h equivalent prototype
}

static const TCHAR *szServerName = TEXT("MSHearts");   // don't translate
static const TCHAR *szTopicName  = TEXT("Hearts");

//  Typedefs for NDdeShareGetInfo (SGIPROC) and NDdeShareAdd (SAPROC)

typedef UINT (WINAPI *SGIPROC)(LPSTR, LPCSTR, UINT, LPBYTE, DWORD, LPDWORD, LPWORD);
typedef UINT (WINAPI *SAPROC)(LPSTR, UINT, LPBYTE, DWORD );

/****************************************************************************

CMainWindow::OnWelcome()

Pop up the Welcome dialog.  If we're gamemeister, set up dde handles and
name.  If we're a player, try to do the dde connection, set up advise loops,
and create other player objects as remote humans.  (They all look like
remote humans to a PLAYER regardless of whether or not there is any flesh
and blood at the other end.)

****************************************************************************/

void CMainWindow::OnWelcome()
{
    // bugbug -- what should "hearts" string really be?

    BOOL    bCmdLine     = (*m_lpCmdLine != '\0');

    bAutostarted = (lstrcmpi(m_lpCmdLine, TEXT("hearts")) == 0);

    if (bAutostarted)
        HeartsPlaySound(SND_QUEEN);       // tell new dealer someone wants to play
    else
        CheckNddeShare();

    CWelcomeDlg welcome(this);

  again:                            // cancel from Browse returns here

    if (!bAutostarted && !bCmdLine)
    {
        if (IDCANCEL == welcome.DoModal())  // display Welcome dialog
        {
            PostMessage(WM_CLOSE);
            return;
        }
    }

    bNetDdeActive = welcome.IsNetDdeActive();

    if (bAutostarted || welcome.IsGameMeister())    // if Gamemeister
    {
        CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
        role = GAMEMEISTER;
        m_myid = 0;
        ddeServer = new DDEServer(szServerName, szTopicName,
                                    (DDECALLBACK)DdeServerCallBack);
        if (!ddeServer || !ddeServer->GetResult())
        {
            FatalError(IDS_SERVERFAIL);
            return;
        }
        dde = ddeServer;
        CreateStrHandles();

        // Don't show message if netdde not found

        if (bNetDdeActive)
            p[0]->UpdateStatus(IDS_GMWAIT); // wait for others to connect
        else
            p[0]->SetStatus(IDS_GMWAIT);

        CString name = welcome.GetMyName();

        if (name.IsEmpty())
            name.LoadString(IDS_DEALER);

        p[0]->SetName(name, dc);
        p[0]->DisplayName(dc);

        // If no netdde, no point waiting around for others to join

        if (!bNetDdeActive)
            PostMessage(WM_COMMAND, IDM_NEWGAME);

        return;
    }

    // At this point, we know we're not a gamemeister

    role = PLAYER;

    CString server, name;

    if (!bCmdLine)
    {
//      char        buf[MAXCOMPUTERNAME+10];    // handle slashes, etc.
//      BROWSEPROC  m_pWNetServerBrowseDialog;
//      HINSTANCE   hmodNetDriver = WNetGetCaps(0xFFFF);

//      m_pWNetServerBrowseDialog =
//          (BROWSEPROC)GetProcAddress(hmodNetDriver, MAKEINTRESOURCE(146));

//      WORD res = (*m_pWNetServerBrowseDialog)( m_hWnd,
//                                "MRU_MSHearts",
//                                buf,
//                                MAXCOMPUTERNAME+10,
//                                0L );

//      if (res != WN_SUCCESS)
//          goto again;

//      server = buf;

        CLocateDlg  locate(this);

        if (IDCANCEL == locate.DoModal())       // display locate dialog
            goto again;

        server = locate.GetServer();
    }
    else
        server = m_lpCmdLine;

    if (server[0] != '\\')
    {
        CString  sSlashes("\\\\");
        server = sSlashes + server;
    }

    name = welcome.GetMyName();

    if (name.IsEmpty())
        name.LoadString(IDS_UNKNOWN);

    ClientConnect(server, name);
}

void CMainWindow::ClientConnect(CString& server, CString& myname)
{
    GAMESTATUS  gs;

    // A blank server name is legal.  It means try to do a local DDE
    // connection to a server running on the same machine.  A non-blank
    // server name means we must construct the app name \\server\NDDE$
    // and the topic name has to end with $.

    if (server.IsEmpty())               // local connection
    {
        ddeClient =
              new DDEClient(szServerName, szTopicName,
                                (DDECALLBACK)DdeClientCallBack);
    }
    else
    {
        CString prefix;
        if (server.GetAt(0) == '\\')    // did string come back with \\s
            prefix = "";
        else
            prefix = "\\\\";            // if not, got to add them

        CString postfix  =  "\\NDDE$";
        CString nettopic = szTopicName;
        nettopic += "$";
        ddeClient = new DDEClient(prefix+server+postfix, nettopic,
                                    (DDECALLBACK)DdeClientCallBack);
    }

    // For invalid local dde session attempts, the following GetResult()
    // will fail.  Since netdde connections always succeed, you can't tell if
    // a server is really there until after the Poke() later on.

    if (!ddeClient->GetResult())
    {
        TRACE1("GetResult last error is %x\n", ddeClient->GetLastError());
        FatalError(IDS_NOSERVER);
        return;
    }

    dde = ddeClient;
    CreateStrHandles();
    CMenu *pMenu = GetMenu();
    pMenu->EnableMenuItem(IDM_NEWGAME, MF_GRAYED);
    p[0]->UpdateStatus(IDS_CONNECTING);

    // Tell the server your name.  This is done as a synchronous Poke()
    // (most others in hearts are asynch) with a 5 second timeout.  If
    // that fails, we finally can be sure the server is not there.

  tryagain:

    if (!(ddeClient->Poke(hszJoin, myname, 5000)))
    {
        UINT err = ddeClient->GetLastError();

        if (err == DMLERR_BUSY)             // game in progress
        {
            CString caption, text;

            text.LoadString(IDS_NOTREADY);
            caption.LoadString(IDS_APPNAME);

            if (bSoundOn)
                MessageBeep(MB_ICONINFORMATION);

#if defined (WINDOWS_ME) && ! defined (USE_MIRRORING)
         if (meSystem)
         {
            if (IDRETRY == ::MessageBoxEx(GetSafeHwnd(), text, caption,
                                      MB_ICONINFORMATION | MB_RETRYCANCEL |
                                      meMsgBox, 0))
                goto tryagain;
         }
         else
         {
            if (IDRETRY == MessageBox(text, caption,
                                      MB_ICONINFORMATION | MB_RETRYCANCEL))
                goto tryagain;
         }
#else
            if (IDRETRY == MessageBox(text, caption,
                                      MB_ICONINFORMATION | MB_RETRYCANCEL))
                goto tryagain;
#endif

            FatalError();
        }
        else
            FatalError(IDS_NOSERVER);

        return;
    }

    // Ask the server for the list of current player names

    HDDEDATA hData = ddeClient->RequestData(hszStatus, 5000);
    if (!hData)
    {
        FatalError(IDS_UNKNOWNERR);
        return;
    }
    else
    {
        ddeClient->GetData(hData, (PBYTE)&gs, sizeof(gs));
        UINT err = ddeClient->GetLastError();
        if (err != DMLERR_NO_ERROR)
        {
            TRACE1("Get Data last error is %x\n", err);
            FatalError(IDS_UNKNOWNERR);
            return;
        }

        m_myid = gs.id;
    }

    // When p[0] got created, it was assumed to be a gamemeister, i.e.
    // its id was assumed to be 0.  Now we know it's not true, so fix
    // it with a call to SetPlayerId().

    ((local_human *)p[0])->SetPlayerId(m_myid);

    p[0]->UpdateStatus(IDS_PWAIT);
    CClientDC dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    p[0]->SetName(myname, dc);
    p[0]->DisplayName(dc);

    // Create the other player objects as remote humans.  A white lie,
    // but they look like remote humans to us.

    for (int pos = 1; pos < MAXPLAYER; pos++)
    {
        int remoteid = Pos2Id(pos);
        p[pos] = new remote_human(remoteid, pos, 0);

        if (p[pos] == NULL)
        {
            FatalError(IDS_MEMORY);
            return;
        }
    }

    UpdateStatusNames(gs);

    ddeClient->StartAdviseLoop(hszStatus);      // player names and ids
    ddeClient->StartAdviseLoop(hszPass);        // cards passed
    ddeClient->StartAdviseLoop(hszMove);        // cards played
    ddeClient->StartAdviseLoop(hszGameNumber);  // should be last in list
}


/****************************************************************************

CMainWindow::CreateStrHandles()
CMainWindow::DestroyStrHandles()

All the dde string handles are created and cleaned up here except for the
server name and topic name which the DDE class handles.

****************************************************************************/

BOOL CMainWindow::CreateStrHandles()
{
    hszJoin = dde->CreateStrHandle(TEXT("Join"));
    hszPass = dde->CreateStrHandle(TEXT("Pass"));
    hszMove = dde->CreateStrHandle(TEXT("Move"));
    hszStatus = dde->CreateStrHandle(TEXT("Status"));
    hszGameNumber = dde->CreateStrHandle(TEXT("GameNumber"));
    hszPassUpdate = dde->CreateStrHandle(TEXT("PassUpdate"));

    return (hszJoin && hszPass && hszMove && hszStatus && hszGameNumber
            && hszPassUpdate);
}

void CMainWindow::DestroyStrHandles()
{
    if (!dde)
        return;

    dde->DestroyStrHandle(hszJoin);
    dde->DestroyStrHandle(hszPass);
    dde->DestroyStrHandle(hszMove);
    dde->DestroyStrHandle(hszStatus);
    dde->DestroyStrHandle(hszGameNumber);
    dde->DestroyStrHandle(hszPassUpdate);
}


/****************************************************************************

CMainWindow::FatalError()

A static BOOL prevents this function from being called reentrantly.  One is
enough, and more than one leaves things in bad states.  The parameter is
the IDS_X constant that identifies the string to display.

There is also a check that we don't try to shut down while the score dialog
is displayed.  This avoids some nasty debug traps when the score dialog
doesn't shut down properly.  The same problems can happen if, say, a dealer
quits when a client is looking at the quote.  Oh well.

****************************************************************************/

void CMainWindow::FatalError(int errorno)
{
    if (p[0]->GetMode() == SCORING)
    {
        m_FatalErrno = errorno;
        return;
    }

    static BOOL bClosing = FALSE;

    if (bClosing)
        return;

    bClosing = TRUE;

    if (errno != -1)                        // if not default
    {
        CString s1, s2;
        s1.LoadString(errno);
        s2.LoadString(IDS_APPNAME);

        if (bSoundOn)
            MessageBeep(MB_ICONSTOP);

#if defined (WINDOWS_ME) && ! defined (USE_MIRRORING)
       if (meSystem)
        ::MessageBoxEx(GetSafeHwnd(), s1, s2, MB_ICONSTOP | meMsgBox, 0);    // potential reentrancy problem
       else
#endif
        MessageBox(s1, s2, MB_ICONSTOP);    // potential reentrancy problem
    }

    PostMessage(WM_CLOSE);
}


/****************************************************************************

CMainWindow::UpdateStatusNames()        client only

Called after server advises that status has changed.

****************************************************************************/

void CMainWindow::UpdateStatusNames(GAMESTATUS& gs)
{
    ASSERT(role == PLAYER);

    if (gs.id != m_myid)
    {
        TRACE1("gs.id is %d ", gs.id);
        TRACE1("and m_myid is %d\n", m_myid);
        return;
    }

    CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif

    for (int pos = 0; pos < MAXPLAYER; pos++)
    {
        int id = Pos2Id(pos);
        if (gs.name[id][0])
        {
            CString s;
            s = gs.name[id];
            p[pos]->SetName(s, dc);
            p[pos]->DisplayName(dc);
        }
    }
}


/****************************************************************************

CMainWindow::GameOver

****************************************************************************/

void CMainWindow::GameOver()
{
    CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif

    InvalidateRect(NULL, TRUE);
    p[0]->SetMode(STARTING);
    p[0]->SetScore(0);

    for (int i = 1; i < MAXPLAYER; i++)
    {
        delete p[i];
        p[i] = NULL;
    }

    if (role == GAMEMEISTER)
    {
        if (bNetDdeActive)
            p[0]->UpdateStatus(IDS_GMWAIT);
        else
            p[0]->SetStatus(IDS_GMWAIT);

        p[0]->DisplayName(dc);
        CMenu *pMenu = GetMenu();
        pMenu->EnableMenuItem(IDM_NEWGAME, MF_ENABLED);

        if (!bNetDdeActive)
            PostMessage(WM_COMMAND, IDM_NEWGAME);

        return;
    }

    CString myname = p[0]->GetName();

    delete ddeClient;
    ddeClient = NULL;
    dde = NULL;

    CString text, caption;

    text.LoadString(IDS_AGAIN);         // wanna play again?
    caption.LoadString(IDS_APPNAME);

    if (bSoundOn)
        MessageBeep(MB_ICONQUESTION);

#if defined (WINDOWS_ME) && ! defined (USE_MIRRORING)
   if (meSystem)
   {
    if (IDNO == ::MessageBoxEx(GetSafeHwnd(), text, caption,
                             MB_ICONQUESTION | MB_YESNO | meMsgBox, 0))
    {
        FatalError();
        return;
    }
   }
   else
#endif
    if (IDNO == MessageBox(text, caption, MB_ICONQUESTION | MB_YESNO))
    {
        FatalError();
        return;
    }

    CString server;
    RegEntry Reg(szRegPath);
    TCHAR *pserver = server.GetBuffer(MAXCOMPUTERNAME+1);
    Reg.GetString(regvalServer, pserver, MAXCOMPUTERNAME+1);
    server.ReleaseBuffer();
    ClientConnect(server, myname);
}


/****************************************************************************

CMainWindow::CheckNddeShare

Check that NDDE share exists, and add it if not.

****************************************************************************/

void CMainWindow::CheckNddeShare()
{
/*
    DWORD           dwAvail;
    WORD            wItems;
    BYTE            buffer[200];

    SetErrorMode(SEM_NOOPENFILEERRORBOX);
    HINSTANCE hinstNDDEAPI = LoadLibrary("NDDEAPI.DLL");

    if (hinstNDDEAPI <= (HINSTANCE)HINSTANCE_ERROR)
        return;

    SGIPROC lpfnNDdeShareGetInfo =
        (SGIPROC) GetProcAddress(hinstNDDEAPI, "NDdeShareGetInfo");

    if (lpfnNDdeShareGetInfo == NULL)
    {
        FreeLibrary(hinstNDDEAPI);
        return;
    }

    UINT res = (*lpfnNDdeShareGetInfo)(NULL, szShareName, 2,
                    buffer, sizeof(buffer), &dwAvail, &wItems);

    if (res != NDDE_SHARE_NOT_EXIST)
        return;

    NDDESHAREINFO *pnddeInfo = (NDDESHAREINFO *)buffer;

    SAPROC lpfnNDdeShareAdd =
        (SAPROC) GetProcAddress(hinstNDDEAPI, "NDdeShareAdd");

    if (lpfnNDdeShareAdd == NULL)
    {
        FreeLibrary(hinstNDDEAPI);
        return;
    }

    lstrcpy(pnddeInfo->szShareName, szShareName);
    pnddeInfo->lpszTargetApp    = "mshearts";       // non-const szServerName
    pnddeInfo->lpszTargetTopic  = "Hearts";         // non-const szTopicName
    pnddeInfo->lpbPassword1     = (LPBYTE) "";
    pnddeInfo->cbPassword1      = 0;
    pnddeInfo->dwPermissions1   = 15;
    pnddeInfo->lpbPassword2     = (LPBYTE) "";
    pnddeInfo->cbPassword2      = 0;
    pnddeInfo->dwPermissions2   = 0;
    pnddeInfo->lpszItem         = "";
    pnddeInfo->cAddItems        = 0;
    pnddeInfo->lpNDdeShareItemInfo = NULL;

    res = (*lpfnNDdeShareAdd)(NULL, 2, buffer, sizeof(buffer));

    TRACE("NDdeShareAdd returns %u\n", res);

    FreeLibrary(hinstNDDEAPI);
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\cdt.h ===
#define CLOADMAX	5

/* Command ids */
#define IDACLUBS	 1
#define ID2CLUBS	 2
#define ID3CLUBS	 3
#define ID4CLUBS	 4
#define ID5CLUBS	 5
#define ID6CLUBS	 6
#define ID7CLUBS	 7
#define ID8CLUBS	 8
#define ID9CLUBS	 9
#define IDTCLUBS	 10
#define IDJCLUBS	 11
#define IDQCLUBS	 12
#define IDKCLUBS	 13

#define IDADIAMONDS	 14
#define ID2DIAMONDS	 15
#define ID3DIAMONDS	 16
#define ID4DIAMONDS	 17
#define ID5DIAMONDS	 18
#define ID6DIAMONDS	 19
#define ID7DIAMONDS	 20
#define ID8DIAMONDS	 21
#define ID9DIAMONDS	 22
#define IDTDIAMONDS	 23
#define IDJDIAMONDS	 24
#define IDQDIAMONDS	 25
#define IDKDIAMONDS	 26

#define IDAHEARTS	 27
#define ID2HEARTS	 28
#define ID3HEARTS	 29
#define ID4HEARTS	 30
#define ID5HEARTS	 31
#define ID6HEARTS	 32
#define ID7HEARTS	 33
#define ID8HEARTS	 34
#define ID9HEARTS	 35
#define IDTHEARTS	 36
#define IDJHEARTS	 37
#define IDQHEARTS	 38
#define IDKHEARTS	 39

#define IDASPADES	 40
#define ID2SPADES	 41
#define ID3SPADES	 42
#define ID4SPADES	 43
#define ID5SPADES	 44
#define ID6SPADES	 45
#define ID7SPADES	 46
#define ID8SPADES	 47
#define ID9SPADES	 48
#define IDTSPADES	 49
#define IDJSPADES	 50
#define IDQSPADES	 51
#define IDKSPADES	 52

#define IDGHOST	53

#define IDFACEDOWN1 	54
#define IDFACEDOWN2 	55
#define IDFACEDOWN3 	56
#define IDFACEDOWN4 	57
#define IDFACEDOWN5 	58
#define IDFACEDOWN6 	59
#define IDFACEDOWN7 	60
#define IDFACEDOWN8 	61
#define IDFACEDOWN9 	62
#define IDFACEDOWN10 	63
#define IDFACEDOWN11 	64
#define IDFACEDOWN12	   65

#define IDFACEDOWNFIRST IDFACEDOWN1
#define IDFACEDOWNLAST IDFACEDOWN12

#define IDX 67
#define IDO 68
#define IDMAX IDDECK



/* internal ID's for animation */

#define IDASLIME1 678
#define IDASLIME2 679

#define IDAKASTL1 680

#define IDAFLIPE1 681
#define IDAFLIPE2 682


#define IDABROBOT1 683
#define IDABROBOT2 684


/* Red non-face card frame */
#define IDFRAME 999


#define FACEUP		0
#define FACEDOWN	1   /* for compatibility with old apps, use IDFACEDOWNFIRST..IDFACEDOWNLAST */
#define HILITE		2
#define GHOST		3
#define REMOVE		4
#define INVISIBLEGHOST 5
#define DECKX		6
#define DECKO		7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\reversi\rev.c ===
#include <windows.h>
#include <port1632.h>
#include <process.h>
#include <stdlib.h>
#include "reversi.h"

VOID NEAR PASCAL paintmove(BYTE b[BoardSize], INT move, INT friendly,
        INT enemy);
BOOL NEAR PASCAL msgcheck(VOID);

extern INT     moves[61];
extern INT     BestMove[max_depth+2];
extern HWND    hWin;
extern HDC     hDisp;
extern INT     depth;
extern INT     direc[];


/*       Indexes for computing scores and whether or not a player has       */
/*       any pieces on the board.  Very order dependant.                    */

BYTE PieceFlags[] = {   0x00 ,      /* Ignore sides */
                        0x00 ,      /* Ignore blanks */
                        0x01 ,      /* Human has a piece */
                        0x02 ,      /* Computer has a piece */
                    };

                    
INT Scores[] = { 0, 0 };
INT humanScore = 0;
INT compScroe = 0;

 

BYTE FinalComp[] = {0, 0, -1, 1 };   /* Table for compute # computer pieces */

BYTE FinalHuman[] = {0, 0, 1, -1};   /* Table for compute # human pieces    */

/*
 *       The scoring tables are used to evaluate the board
 *       position.  The corners of the board change value
 *       according to whether a given square is occupied or
 *       not.  This can be done dynamically, saving ~ 1K
 *       worth of data space but costing an as of yet
 *       undetermined performance hit.
 */

#define B11     11    /* Offsets to particular squares */
#define B18     18 
#define B81     81 
#define B88     88 

#define maskb11     0x08    /* Masks used for indexing into Scoring tables. */
#define maskb18     0x04
#define maskb81     0x02
#define maskb88     0x01


INT NEAR PASCAL finalscore(
BYTE b[],
BYTE friendly,
BYTE enemy)
{
    INT i;
    INT count=0;

    for (i=11 ; i<=88 ; i++) {
        if (b[i] == friendly) count++;
        else if (b[i] == enemy) count--;
    }
    if (count > 0)
        return(win +  count);
    else if (count < 0)
        return(loss + count);
    else
        return(0);
}



INT NEAR PASCAL legalcheck(
BYTE b[],
INT move,
BYTE friendly,
BYTE enemy)
{
   INT sq,d;
   INT *p;

   if (b[move] == empty) {
      p=direc;
      while ((d = *p++) != 0) {
          sq=move;
          if (b[sq += d] == enemy) {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == friendly) return(1);
          }
      }
   }
   return(0);
}


VOID NEAR PASCAL makemove(
BYTE b[],
INT move,
BYTE friendly,
BYTE enemy)
{
   INT sq,d;
   INT *p;

   if (move != PASS) {
      p=direc;
      while ((d = *p++) != 0) {
          sq=move;
          if (b[sq += d] == enemy) {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == friendly)
                while(b[sq -= d] == enemy)
                   b[sq]=friendly;
          }
      }
      b[move]=friendly;
   }
}


/*

   calculate the value of board

*/
INT NEAR PASCAL score(
BYTE b[],
BYTE friendly,
BYTE enemy)
{
    INT *pvalue;
    BYTE *pb;
    INT fpoints=0;
    INT epoints=0;
    INT ecount=0;
    BYTE bv;
    INT v,b11,b18,b81,b88;

    static INT value[79] = {     99, -8,  8,  6,  6,  8, -8, 99,000,
                                000, -8,-24, -4, -3, -3, -4,-24, -8,000,
                                000,  8, -4,  7,  4,  4,  7, -4,  8,000,
                                000,  6, -3,  4,  0,  0,  4, -3,  6,000,
                                000,  6, -3,  4,  0,  0,  4, -3,  6,000,
                                000,  8, -4,  7,  4,  4,  7, -4,  8,000,
                                000, -8,-24, -4, -3, -3, -4,-24, -8,000,
                                000, 99, -8,  8,  6,  6,  8, -8, 99,infin};

    static INT value2[79]= {     99, -8,  8,  6,  6,  8, -8, 99,000,
                                000, -8,-24,  0,  1,  1,  0,-24, -8,000,
                                000,  8,  0,  7,  4,  4,  7,  0,  8,000,
                                000,  6,  1,  4,  1,  1,  4,  1,  6,000,
                                000,  6,  1,  4,  1,  1,  4,  1,  6,000,
                                000,  8,  0,  7,  4,  4,  7,  0,  8,000,
                                000, -8,-24,  0,  1,  1,  1,-24, -8,000,
                                000, 99, -8,  8,  6,  6,  8, -8, 99,infin};

    pb = &b[11];
    b11 = *pb;
    b18 = b[18];
    b81 = b[81];
    b88 = b[88];

    if ((b11 != empty) || (b18 != empty) || (b81 != empty) || (b88 != empty)) {
        pvalue = value2;

        if (b11 == empty) {
                value2[12-11] = -8;  value2[21-11] = -8;  value2[22-11] = -24;
        } else {
                value2[12-11] = 12;  value2[21-11] = 12;  value2[22-11] = 8;
        }

        if (b18 == empty) {
                value2[17-11] = -8;  value2[28-11] = -8;  value2[27-11] = -24;
        } else {
                value2[17-11] = 12;  value2[28-11] = 12;  value2[27-11] = 8;
        }

        if (b81 == empty) {
                value2[82-11] = -8;  value2[71-11] = -8;  value2[72-11] = -24;
        } else {
                value2[82-11] = 12;  value2[71-11] = 12;  value2[72-11] = 8;
        }

        if (b88 == empty) {
                value2[87-11] = -8;  value2[78-11] = -8;  value2[77-11] = -24;
        } else {
                value2[87-11] = 12;  value2[78-11] = 12;  value2[77-11] = 8;
        }
    } else {
        pvalue = value;
    }

    while((v=*pvalue++) != infin) {
       bv = *pb++;
       if (bv == friendly)
           fpoints += v;
       else if (bv == enemy) {
                   epoints += v;
           ecount++;
       }

    }
    if (!ecount)          /* any enemy pieces on the board? */
       return(win);       /* if not, we just won!                 */
    else
       return(fpoints-epoints);
}



INT NEAR PASCAL minmax(
BYTE b[max_depth + 2][100],
INT move,
BYTE friendly,
BYTE enemy,
INT ply,
INT vmin,
INT vmax)
{
    BYTE *pCurrent, *pPrevious, *pSource, *pDest;
    INT *pMoves;
    INT *pBestMove;
    INT i;
    INT sq, value, cur_move;

    pPrevious = &b[ply][0];
    pCurrent =  &b[ply+1][0];

    pSource = &b[ply][11];
    pDest =   &b[ply+1][11];
    for (i=11 ; i<=88 ; i++) *pDest++=*pSource++;

    pBestMove = &BestMove[ply];
    if (move == PASS) {
        if (ply == depth) {
            pMoves = moves;
            while((sq = *pMoves++) != 0) {
                if (legalcheck(pCurrent,sq,enemy,friendly))
                    return(score(pCurrent,friendly,enemy));
            }
            return(finalscore(pCurrent,friendly,enemy));
        }
    }
    else {
        if (ply == 0) {
	    hDisp = GetDC(hWin);
            paintmove(pCurrent,move,friendly,enemy);
            ReleaseDC(hWin, hDisp);
        }
        else {
            makemove(pCurrent,move,friendly,enemy);
            if (ply == depth) return(score(pCurrent,friendly,enemy));
        }
    }
    pMoves = moves;
    cur_move = PASS;
    *pBestMove = PASS;
    while((sq = *pMoves++) != 0) {
        if (legalcheck(pCurrent,sq,enemy,friendly)) {
           cur_move = sq;
           value = minmax(b,cur_move,enemy,friendly,ply+1,-vmax,-vmin);
           if (value > vmin) {
              vmin = value;
              *pBestMove = cur_move;
              if (value >= vmax) goto cutoff;   /* alpha-beta cutoff */
           }
        }
    }
    if (cur_move == PASS) {
       if (move == PASS)        /* two passes in a row mean game is over */
          return(finalscore(pCurrent,friendly,enemy));
       else {
          value = minmax(b,PASS,enemy,friendly,ply+1,-vmax,-vmin);
          if (value > vmin) vmin = value;
       }
    }
cutoff:
    return(-vmin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\back.c ===
#include "sol.h"
VSZASSERT


/* flags for _lseek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define cbBand 8192

BGND bgnd;


BOOL _FValidBm(BMP *pbm)
{
    return((pbm->biBitCount == 1 || pbm->biBitCount == 4)
        && pbm->biPlanes == 1 && pbm->biSize == sizeof(BMP));
}




BOOL FInitBgnd(TCHAR *szFile)
{
    INT fh;
    BOOL fResult;
    LONG lcbBm;
    LONG dwBmSize;

    fResult = fFalse;
    bgnd.fUseBitmap = fFalse;
    if((fh = OpenFile(szFile, &bgnd.of, OF_CANCEL|OF_READ)) == -1)
        return fFalse;

    if(!FReadDibBitmapInfo(fh, &bgnd.bm))    
        goto ReturnClose;
    bgnd.dwOfsBits = M_llseek( fh, 0L, SEEK_CUR);

    if(!_FValidBm(&bgnd.bm))
        goto ReturnClose;

        
    /* BUG: check if bitmap is ok */
    bgnd.cbLine = (((INT) bgnd.bm.biWidth * bgnd.bm.biBitCount+31)/32)*4;
    lcbBm = (LONG) bgnd.cbLine * DyBmp(bgnd.bm);
    bgnd.ibndMac = (INT) ((lcbBm+cbBand-1) / cbBand);
    if((bgnd.rghbnd = PAlloc(bgnd.ibndMac*sizeof(HANDLE))) == NULL)
        goto ReturnClose;
    bgnd.dyBand = (INT) ((LONG) DyBmp(bgnd.bm) * cbBand / lcbBm);
    bgnd.fUseBitmap = fTrue;
    SetBgndOrg();
    fResult = fTrue;
ReturnClose:
    M_lclose(fh);
    return fResult;
}




BOOL FDestroyBgnd()
{
    INT ibnd;
    HANDLE *phbnd;

    if(bgnd.fUseBitmap)
    {
        for(ibnd = 0; ibnd < bgnd.ibndMac; ibnd++)
        {
            if(*(phbnd = &bgnd.rghbnd[ibnd]) != NULL)
            {
                GlobalFree(*phbnd);
                *phbnd = NULL;
            }
        }
        FreeP(bgnd.rghbnd);
    }
    return fTrue;
}



BOOL FGetBgndFile(TCHAR *sz)
{
    if(bgnd.fUseBitmap)
        PszCopy(bgnd.of.szPathName, sz);
    else
        sz[0] = TEXT('\000');
    return fTrue;
}




BOOL _FLoadBand(INT ibnd, Y y)
{
    HANDLE hbnd;
    BYTE[     ]*FAR[     ]**lpb;
    INT ipln;
    INT fh;
    LONG lcbpln;
    HANDLE *phbnd;
    DY dy;

    phbnd = &bgnd.rghbnd[ibnd];

    if(*phbnd != NULL)
        GlobalFree(*phbnd);
    hbnd = GlobalAlloc(GMEM_MOVEABLE|GMEM_DISCARDABLE, (LONG) cbBand);
    lpb = GlobalLock(hbnd);
    if(lpb == NULL)
        return fFalse;
    fh = OpenFile("", &bgnd.of, OF_REOPEN|OF_READ );

    lcbpln = 0L;
    dy = WMin(bgnd.dyBand, DyBmp(bgnd.bm)-y);
    for(ipln = 0; ipln < CplnBmp(bgnd.bm); ipln++)
    {
        M_llseek( fh, (LONG)OfsBits(bgnd)+ipln*lcbpln+(y)*CbLine(bgnd), 0);
        M_lread( fh, (LPSTR) lpb+ipln*CbLine(bgnd)*bgnd.dyBand, dy * CbLine(bgnd));
    }

    GlobalUnlock(hbnd);
    *phbnd = hbnd;
    M_lclose(fh);
    return fTrue;
}




Y _YDrawBand(HDC hdcMem, HBITMAP hbm, X xLeft, Y yTop, X xRight, Y yBot)
{
    HBITMAP hbmSav;
    HANDLE hbnd;
    BYTE[     ]*FAR[     ]**lpb;
    Y y;
    INT ibnd;

    /* round yTop to nearest band */
    y = ((yTop-bgnd.ptOrg.y)/bgnd.dyBand)*bgnd.dyBand;
    
    ibnd = y/bgnd.dyBand;
    if(ibnd < 0)
        return bgnd.ptOrg.y;
    if(ibnd >= bgnd.ibndMac)
        return yBot+1;
    ibnd = bgnd.ibndMac-ibnd-1;
     Assert(ibnd >= 0);
    Assert(ibnd < bgnd.ibndMac);
    while((hbnd = bgnd.rghbnd[ibnd]) == NULL ||
        (lpb = (BYTE[     ]*FAR[     ]**) GlobalLock(hbnd)) == NULL)
    {
        if(!_FLoadBand(ibnd, y))
            /* KLUDGE:, should back out gracefully */
            return yBot;
    }
        
    Assert(lpb != NULL);
    SetDIBitsToDevice(hdcCur, xLeft-xOrgCur, yTop-yOrgCur, 
        WMin(xRight-xLeft, DyBmp(bgnd.bm)-xLeft+bgnd.ptOrg.x), 
        WMin(WMin(bgnd.dyBand, yBot-yTop), DyBmp(bgnd.bm)-yTop+bgnd.ptOrg.y),
        0,    0,
        y-bgnd.ptOrg.y,
        bgnd.dyBand,
        
//        xLeft-bgnd.ptOrg.x, yTop-y-bgnd.ptOrg.y, 
//        0,
//        WMin(WMin(bgnd.dyBand, yBot-yTop), DyBmp(bgnd.bm)-yTop+bgnd.ptOrg.y),
        lpb,
        (BITMAPINFO FAR *)&bgnd.bm,
        DIB_RGB_COLORS);
    
    GlobalUnlock(hbnd);
    return y+bgnd.dyBand+bgnd.ptOrg.y;
}


VOID DrawBgnd(X xLeft, Y yTop, X xRight, Y yBot)
{
    INT dy;
    Y y;
    HDC hdcMem;
    HBITMAP hbm;
    HBRUSH hbr;

    if(bgnd.fUseBitmap)
    {

        for(y = yTop; y <= yBot; )
        {
            y = _YDrawBand(hdcMem, hbm, xLeft, y, xRight, yBot);
        }
        ExcludeClipRect(hdcCur, bgnd.ptOrg.x-xOrgCur, bgnd.ptOrg.y-yOrgCur, bgnd.ptOrg.x+DxBmp(bgnd.bm)-xOrgCur, bgnd.ptOrg.y+DyBmp(bgnd.bm)-yOrgCur);
    }

    MSetBrushOrg(hdcCur, xOrgCur, yOrgCur);
    MUnrealizeObject( hbrTable );
    hbr = SelectObject(hdcCur, hbrTable);
    Assert(xRight >= xLeft);
    Assert(yBot >= yTop);
    PatBlt(hdcCur, xLeft-xOrgCur, yTop-yOrgCur, xRight-xLeft, yBot-yTop, PATCOPY);
    SelectObject(hdcCur, hbr);

    if(bgnd.fUseBitmap)
        SelectClipRgn(hdcCur, NULL);
}



VOID SetBgndOrg()    
{
    bgnd.ptOrg.x = (rcClient.xRight - DxBmp(bgnd.bm))/2;
    bgnd.ptOrg.y = (rcClient.yBot -  DyBmp(bgnd.bm))/2;
}




/*
 *  ReadDibBitmapInfo()
 *
 *  Will read a file in DIB format and return a global HANDLE to it's
 *  BITMAPINFO.  This function will work with both "old" and "new"
 *  bitmap formats, but will allways return a "new" BITMAPINFO
 *
 */
BOOL FReadDibBitmapInfo(INT fh, BITMAPINFO *pbi)
{
    DWORD     off;
    HANDLE    hbi = NULL;
    INT       size;
    INT       i;
    WORD      nNumColors;

    RGBQUAD FAR       *pRgb;
    BITMAPINFOHEADER   bi;
    BITMAPCOREHEADER   bc;
    LPBITMAPINFOHEADER lpbi;
    BITMAPFILEHEADER   bf;

    if (fh == -1)
        return NULL;

    off = M_llseek( fh, 0L, SEEK_CUR);

    if (sizeof(bf) != M_lread( fh, (LPSTR)&bf, sizeof(bf)) )
        return fFalse;

    /*
     *  do we have a RC HEADER?
     */
    if (!ISDIB(bf.bfType))
    {
        bf.bfOffBits = 0L;
        M_llseek( fh, off, SEEK_SET );
    }

    if (sizeof(bi) != M_lread( fh, (LPSTR)&bi, sizeof(bi)) )
        return fFalse;

    nNumColors = DibNumColors(&bi);

    /*
     *  what type of bitmap info is this?
     */
    switch (size = (INT)bi.biSize)
    {
        case sizeof(BITMAPINFOHEADER):
            break;

        case sizeof(BITMAPCOREHEADER):
            bc = *(BITMAPCOREHEADER*)&bi;
            bi.biSize               = sizeof(BITMAPINFOHEADER);
            bi.biWidth              = (DWORD)bc.bcWidth;
            bi.biHeight             = (DWORD)bc.bcHeight;
            bi.biPlanes             =  (WORD)bc.bcPlanes;
            bi.biBitCount           =  (WORD)bc.bcBitCount;
               bi.biStyle               	= 0;
            bi.biSizeImage          = 0;
            bi.biXPelsPerMeter      = 0;
            bi.biYPelsPerMeter      = 0;
            bi.biClrUsed            = nNumColors;
            bi.biClrImportant       = nNumColors;

            M_llseek(fh, (LONG)sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER), SEEK_CUR);

            break;

        default:
            return fFalse;       /* not a DIB */
    }

    /*
     *    fill in some default values!
     */
    if (bi.biSizeImage == 0)
    {
        bi.biSizeImage = WIDTHBYTES((DWORD)bi.biWidth * bi.biBitCount)
             * bi.biHeight;
    }

    if (bi.biXPelsPerMeter == 0)
    {
        bi.biXPelsPerMeter = 0;     // ??????????????
    }

    if (bi.biYPelsPerMeter == 0)
    {
        bi.biYPelsPerMeter = 0;     // ??????????????
    }

    if (bi.biClrUsed == 0)
    {
        bi.biClrUsed = DibNumColors(&bi);
    }


    lpbi = (VOID FAR *)pbi;
    *lpbi = bi;

    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + bi.biSize);

    if (nNumColors)
    {
        if (size == sizeof(BITMAPCOREHEADER))
        {
            /*
             * convert a old color table (3 byte entries) to a new
             * color table (4 byte entries)
             */
            M_lread( fh, (LPSTR)pRgb, nNumColors * sizeof(RGBTRIPLE) );

            for (i=nNumColors-1; i>=0; i--)
            {
                RGBQUAD rgb;

                rgb.rgbRed      = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed;
                rgb.rgbBlue     = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue;
                rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen;
                rgb.rgbReserved = (BYTE)0;

                pRgb[i] = rgb;  // BUG, this is wrong!!!!
            }
        }
        else
        {
            M_lread(fh, (LPSTR)pRgb, nNumColors * sizeof(RGBQUAD));
        }
        }

    if (bf.bfOffBits != 0L)
        M_llseek( fh, off + bf.bfOffBits, SEEK_SET );

    return fTrue;
}







/*  How Many colors does this DIB have?
 *  this will work on both PM and Windows bitmap info structures.
 */
WORD DibNumColors(VOID FAR * pv)
{
    INT bits;

    /*
     *  with the new format headers, the size of the palette is in biClrUsed
     *  else is dependent on bits per pixel
     */
    if (((LPBITMAPINFOHEADER)pv)->biSize != sizeof(BITMAPCOREHEADER))
    {
        if (((LPBITMAPINFOHEADER)pv)->biClrUsed != 0)
            return (WORD)((LPBITMAPINFOHEADER)pv)->biClrUsed;

        bits = ((LPBITMAPINFOHEADER)pv)->biBitCount;
    }
    else
    {
        bits = ((LPBITMAPCOREHEADER)pv)->bcBitCount;
    }

    switch (bits)
    {
        case 1:
            return 2;
        case 4:
            return 16;
        case 8:
            Assert(fFalse);  // NYI
            return 256;
        default:
            return 0;
    }

    
}





#ifdef LATER

HDC HdcCreateImage(HDC hdcApp, INT idbMask, INT idbImage, LONG rgb, DX *pdx, DY *pdy)
{
    HDC hdcMem, hdcMem1;
    HBITMAP hbmT, hbmTT, hbmMask;
    HBRUSH hbr;
    BITMAP bm;

    hdcMem = CreateCompatibleDC(hdcApp);
    hbmMask = LoadBitmap(hinstApp, MAKEINTRESOURCE(idbMask));
    GetObject(hbmMask, sizeof(BITMAP), (LPSTR) &bm);

    /* enlarge the size of hdc */
    hbmT = SelectObject(hdcMem, CreateCompatibleBitmap(hdcApp, bm.bmWidth, bm.bmHeight));
    hbr = SelectObject(hdcMem, hbrTable);
    PatBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, PATCOPY);
    SelectObject(hdcMem, hbr);

    hdcMem1 = CreateCompatibleDC(hdcApp);
    hbmTT = SelectObject(hdcMem1, hbmMask);
    BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCAND);
    /* load image and delete hbmMask */
    DeleteObject(SelectObject(hdcMem1, LoadBitmap(hinstApp, MAKEINTRESOURCE(idbImage))));
    /* load brush to color image */
    hbr = SelectObject(hdcMem, CreateSolidBrush(rgb));

#define ropDPSao 0x00EA02E9   /* (Source & Pattern) | Dest */
    BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, ropDPSao);
    DeleteObject(SelectObject(hdcMem, hbr));
    DeleteObject(SelectObject(hdcMem1, hbmTT));
    DeleteDC(hdcMem1);
    *pdx = bm.bmWidth;
    *pdy = bm.bmHeight;
    return hdcMem;
}

Marquee(RC *prc)
{
    HDC hdc;
    HDC hdcObj;
    X x;
    Y y;
    DX dxObj;
    DY dyObj;
    DX dx;
    DY dy;
    INT dobjX, dobjY;  /* # of objects per dir */
    INT iobj;
    INT iSlice, iSlice1;

    hdc = GetDC(hwndApp);
    hdcObj = HdcCreateImage(hdc, idbBlackBear, idbWhiteBear, RGB(255, 0, 0), &dxObj, &dyObj);
    dobjX = (prc->xRight-prc->xLeft)/dxObj;
    dobjY = (prc->yBot-prc->yTop)/dyObj;
    dx = dxObj*2;
    dy = 0;
    y = prc->yTop-dyObj;
    x = prc->xLeft-dxObj+iSlice%dxObj;
    for(iobj = 0; iobj < 2*dobjX+2*dobjY; iobj++)
        {
        BitBlt(hdc, x, y, dxObj, dyObj, hdcObj, 0, 0, SRCCOPY);
        if(dy == 0)
            {
            if(x > prc->xRight+dxObj)
                {
                dy = dyObj*2;
                dx = 0;
                }    
            else if(x < prc->xLeft-dxObj)
                {
                dy = -dyObj*2;
                dx = 0;
                }
            }
        else if(dx == 0)
            {
            if(y > prc->yBot+dyObj)
                {
                dx = -dxObj*2;
                dy = 0;
                }
            }
        x+=dx;
        y+=dy;
        }
    for(iSlice = 0; iSlice < 5; iSlice++)
        {
        for(iSlice1 = 0; iSlice1 < dxObj; iSlice1++)
            {
            BitBlt(hdc, prc->xLeft-dxObj+iSlice1+1, prc->yTop-dyObj, prc->xRight-prc->xLeft+dxObj, dyObj,
                     hdc, prc->xLeft-dxObj+iSlice1, prc->yTop-dyObj, SRCCOPY);
            BitBlt(hdc, prc->xRight+dxObj, prc->yTop-dyObj+iSlice1+1, dxObj, prc->yBot-prc->yTop+dyObj,
                     hdc, prc->xRight+dxObj, prc->yTop-dyObj+iSlice1, SRCCOPY);
            }
        }


    DeleteDC(hdcObj);
    ReleaseDC(hwndApp, hdc);
    return fTrue;
}











Animation()
{
    INT iX, iY, ihdc;
    DX dx;
    DY dy;
    HDC hdc;
    HDC rghdc[3];

    RC rc;


    rc.xLeft = 100; rc.xRight = 300;
    rc.yTop = 100; rc.yBot = 200;
    Marquee(&rc);
    return fTrue;

}


#endif /* LATER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\reversi\reversi.c ===
/****************************************************************************/
/*                                                                          */
/*  Windows Reversi -                                                       */
/*                                                                          */
/*      Originally written by Chris Peters                                  */
/*                                                                          */
/****************************************************************************/

#include "windows.h"
#include <port1632.h>
#include <process.h>
#include <stdlib.h>
#include "reversi.h"

/* Exported procedures called from other modules */
LRESULT APIENTRY ReversiWndProc(HWND, UINT, WPARAM, LPARAM);
VOID APIENTRY InverseMessage(HWND, UINT, UINT_PTR, DWORD);
INT_PTR APIENTRY AboutDlgProc(HWND, UINT, WPARAM, LPARAM);

PSTR    pDisplayMessage;
HBRUSH  hbrBlack;
HBRUSH  hbrPat;
HBRUSH  hbrWhite;
HBRUSH  hbrRed;
HBRUSH  hbrGreen;
HBRUSH  hbrBlue;
HBRUSH  hbrHuman;
HBRUSH  hbrComputer;


HANDLE  hInst;
HANDLE  curIllegal;
HANDLE  curLegal;
HANDLE  curThink;
HANDLE  curBlank;
BOOL    fThinking = FALSE;
BOOL    fCheated = FALSE;
INT     direc[9] = {9, 10, 11, 1, -1, -9, -10, -11, 0};
WORD     prevCheck;
BYTE    board[max_depth+2][BoardSize];
INT     fPass;
INT     flashtimes;
INT     count;
INT     MessageOn;
INT     charheight;
INT     charwidth;
INT     xscr;
CHAR    strBuf[80];
BOOL    bMouseDownInReversi = FALSE;
INT     xExt;
INT     yExt;
INT     Bx;
INT     By;
INT     ASPECT;
INT     COLOR;
INT     TXMIN;
INT     TYMIN = 45;
INT     dimension;
BOOL    ffirstmove;

CHAR    szReversi[20];
CHAR    szReversiPractice[40];
CHAR    szPass[30];
CHAR    szMustPass[30];
CHAR    szTie[30];
CHAR    szLoss[30];
CHAR    szWon[30];
CHAR    szWonPost[30];
CHAR    szLossPost[30];
CHAR    szAbout[20];
CHAR    szIllegal[70];
CHAR    szNoPass[70];
CHAR    szHelpFile[15];

HANDLE  hAccel;

POINT   MousePos;

INT     depth;
INT     BestMove[max_depth+2];
HDC     hDisp;
HWND    hWin;
INT     moves[61] = {11,18,81,88, 13,31,16,61,
                     38,83,68,86, 14,41,15,51,
                     48,84,58,85, 33,36,63,66,
                     34,35,43,46, 53,56,64,65,
                     24,25,42,47, 52,57,74,75,
                     23,26,32,37, 62,67,73,76,
                     12,17,21,28, 71,78,82,87,
                     22,27,72,77,
              0};


INT NEAR PASCAL minmax(BYTE b[max_depth + 2][100], INT move, INT friendly,
    INT enemy, INT ply, INT vmin, INT vmax);
VOID NEAR PASCAL makemove(BYTE b[], INT move, INT friendly, INT enemy);
INT NEAR PASCAL legalcheck(BYTE b[], INT move, INT friendly, INT enemy);


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  UpdateCursor() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* To use UpdateCursor,  set the global var MousePos.x and MousePos.y and make
 * the call.  The cursor will appear at the new position
 */

VOID NEAR PASCAL UpdateCursor(
HWND    hwnd)
{
  POINT curpoint;

  curpoint.x = MousePos.x;
  curpoint.y = MousePos.y;
  ClientToScreen(hwnd, (LPPOINT)&curpoint);
  SetCursorPos(curpoint.x, curpoint.y);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  checkdepth() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL checkdepth(
HWND hWindow,
WORD  d)
{
  HMENU hMenu;

  hMenu = GetMenu(hWindow);
  CheckMenuItem(hMenu, prevCheck, MF_UNCHECKED);
  CheckMenuItem(hMenu, d, MF_CHECKED);
  prevCheck = d;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  clearboard() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL clearboard(
BYTE b[max_depth+2][BoardSize])
{
  register INT  i,j;
  INT           k;

  for (i=0; i<=max_depth ; i++)
      for (j=0 ; j<=99 ; j++)
          b[i][j] = edge;

    for (i=0 ; i<=max_depth ; i++)
      {
        for (j=11 ; j<=81 ; j=j+10)
            for (k=j ; k<j+8 ; k++)
                b[i][k] = empty;

        b[i][45]=computer;
        b[i][54]=computer;
        b[i][44]=human;
        b[i][55]=human;
      }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevCreate() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_CREATE messages. */

VOID NEAR PASCAL RevCreate(
register HWND   hWindow)

{
  register HDC  hDC;
  TEXTMETRIC    charsize;           /* characteristics of the characters */

  MessageOn   = FALSE;
  hDC = GetDC(hWindow);
  GetTextMetrics(hDC, (LPTEXTMETRIC)&charsize);

  charheight = charsize.tmHeight;
  charwidth = charsize.tmAveCharWidth;

  ReleaseDC(hWindow, hDC);

  if (COLOR == TRUE)
    {
      hbrComputer = hbrBlue;
      hbrHuman = hbrRed;
    }
  else
    {
      hbrComputer = hbrBlack;
      hbrHuman = hbrWhite;
    }

  TXMIN = 45 * ASPECT;

  clearboard(board);

  /* Okay to pass on first move */
  fPass = PASS;
  depth = 1;
  prevCheck = EASY;
  ffirstmove = TRUE;
  checkdepth(hWindow, prevCheck);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  printboard() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL printboard(
BYTE b[max_depth+2][BoardSize])

{
  register INT  i,j;
  INT sq;

  for (i=0; i < 8; i++)
    {
      for (j=0; j < 8; j++)
        {
          if ((sq = (INT)b[0][i*10+j+11]) != empty)
            {
              if (sq == computer)
                  SelectObject(hDisp, hbrComputer);
              else
                  SelectObject(hDisp, hbrHuman);

              Ellipse(hDisp,
                      Bx+2*ASPECT+i*xExt,
                      By+2+j*yExt,
                      Bx+2*ASPECT + i*xExt + xExt-4*ASPECT,
                      By+2+j*yExt + yExt-4);
            }
        }
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ClearMessageTop() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ClearMessageTop(
HDC     hDC)

{
  if (MessageOn == TRUE)
    {
      flashtimes = count + 1;
      SelectObject(hDC, (COLOR) ? hbrGreen : hbrWhite);
      PatBlt(hDC, 0, 0, xscr, charheight, PATCOPY);
      MessageOn = FALSE;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowMessageTop() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowMessageTop(
HDC     hDC,
PSTR    string)

{
  INT   dx;

  pDisplayMessage = string;
  ClearMessageTop(hDC);
  SelectObject(hDC, hbrWhite);
  PatBlt(hDC, 0, 0, xscr, charheight, PATCOPY);
  SetBkMode(hDC, TRANSPARENT);
  MGetTextExtent(hDC, (LPSTR)string, lstrlen(string), &dx, NULL);
  TextOut(hDC, (INT)(xscr - dx)/2, 0, (LPSTR)string, lstrlen(string));
  MessageOn = TRUE;
  SetBkMode(hDC, OPAQUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  drawboard() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL drawboard(
BYTE b[max_depth+2][BoardSize])
{
  register INT  i;
  INT           lcx,lcy;
  register INT  xdimension;
  INT           xLineExt,yLineExt;

  yLineExt = 8 * yExt;
  xLineExt = 8 * xExt;
  xdimension = dimension * ASPECT;

  SelectObject(hDisp, hbrBlack);
  PatBlt(hDisp, Bx+2*xdimension, By+2*dimension, xLineExt, yLineExt, PATCOPY);
  MUnrealizeObject(hbrPat);
  SelectObject(hDisp, hbrPat);
  PatBlt(hDisp, Bx, By, xLineExt, yLineExt, PATCOPY);

  SelectObject(hDisp, hbrBlack);
  for (i=Bx; i <= Bx + xLineExt; i += xExt)
      PatBlt(hDisp, i, By, ASPECT, yLineExt, PATCOPY);

  for (i=By; i <= By + yLineExt; i += yExt)
      PatBlt(hDisp, Bx, i, xLineExt, 1, PATCOPY);

  lcx = Bx+xLineExt;
  lcy = By+yLineExt;

  MUnrealizeObject(hbrPat);
  SelectObject(hDisp, hbrPat);

  for (i=1; i < xdimension; ++i)
      PatBlt(hDisp, lcx+i, By+i/ASPECT, 1, yLineExt, PATCOPY);

  /* Fill in bottom edge of puzzle. */
  for (i=1; i < dimension; ++i)
      PatBlt(hDisp, Bx+i*ASPECT, lcy+i, xLineExt, 1, PATCOPY);

  SelectObject(hDisp, hbrBlack);

  MMoveTo(hDisp, lcx, By);
  LineTo(hDisp, lcx+xdimension, By+dimension);
  LineTo(hDisp, lcx+xdimension, lcy+dimension);
  LineTo(hDisp, Bx+xdimension, lcy+dimension);
  LineTo(hDisp, Bx, lcy);
  MMoveTo(hDisp, lcx+xdimension, lcy+dimension);
  LineTo(hDisp, lcx, lcy);

  printboard(b);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevPaint() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_PAINT messages. */

VOID NEAR PASCAL RevPaint(
HWND    hWindow,
HDC     hDC)

{
  register INT  Tx, Ty;
  INT           xLineExt, yLineExt;
  RECT          lpSize;

  /* Since it is easy to resize we'll do it on every repaint */
  hDisp = hDC;
  hWin  = hWindow;
  SetBkMode(hDisp, OPAQUE);
  GetClientRect(hWindow, (LPRECT)&lpSize);
  xscr = Tx = lpSize.right - lpSize.left;
  Ty = lpSize.bottom - lpSize.top;

  /* Dont go below minimum size */
  if (Tx < Ty*ASPECT)
    {
      if (Tx < TXMIN)
          Tx = TXMIN;
      xExt = Tx / (9 + 1);
      yExt = xExt / ASPECT;
    }
  else
    {
      if (Ty < TYMIN)
          Ty = TYMIN;
      yExt = Ty / (9 + 1);
      xExt = yExt * ASPECT;
    }
  yLineExt = 8 * yExt;
  xLineExt = 8 * xExt;
  dimension = yLineExt/30;

  Bx = (Tx > xLineExt) ? (Tx - xLineExt) / 2 : 0;
  By = (Ty > yLineExt) ? (Ty - yLineExt) / 2 : 0;

  drawboard(board);

  if (MessageOn)
    {
      ShowMessageTop(hDisp, pDisplayMessage);
      PatBlt(hDC, 0, 0, xscr, charheight, DSTINVERT);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FlashMessageTop() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL FlashMessageTop(
HWND    hWindow)
{
  flashtimes = 0;
  count = 4;
  SetTimer(hWindow, 666, 200, InverseMessage);    /* Timer ID is 666 */
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMessage() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMessage(
HWND            hWindow,
HDC             hDC,
register CHAR   *pS,
INT             n,
CHAR            *pchPostStr)
{
  register CHAR *pch;

  pch = strBuf;
  while (*pS)
      *pch++ = *pS++;

  if (n)
    {
      if (n / 10)
          *pch++ = (CHAR)(n / 10 + '0');
      *pch++ = (CHAR)(n % 10 + '0');
    }

  if (pchPostStr)
    {
      while (*pchPostStr)
          *pch++ = *pchPostStr++;
    }
  *pch = TEXT('\0');

  ShowMessageTop(hDC, strBuf);
  FlashMessageTop(hWindow);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  flashsqr() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL flashsqr(
register HDC    hDC,
INT             x1,
INT             y1,
INT             Ex,
INT             Ey,
INT             color,
BOOL            fBlankSquare,
INT             n)

{
  register INT  i;

  if (fBlankSquare)
      SelectObject(hDC, GetStockObject(NULL_PEN));

  SetCursor(curBlank);

  for (i=0; i < n; ++i)
    {
      if (color == 1)
          color = 2;
      else
          color = 1;

      if (color == 1)
          SelectObject(hDC,hbrComputer);
      else
          SelectObject(hDC, hbrHuman);

      SetBkMode(hDC, OPAQUE);
      Ellipse(hDC, x1, y1, x1+Ex, y1+Ey);
    }

  if (fBlankSquare)
    {
      MUnrealizeObject(hbrPat);
      SelectObject(hDC, hbrPat);
      Ellipse(hDC, x1, y1, x1+Ex, y1+Ey);
    }
  else
      SetCursor(curThink);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMouseMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMouseMove(
POINT   point)

{
  INT     move;
  INT     Si, Sj;
  INT     yLineExt = 8 * yExt;
  INT     xLineExt = 8 * xExt;
  HANDLE  cur;

  MousePos.x = point.x;
  MousePos.y = point.y;

  if(xExt ==0 || yExt == 0)
      return;

  cur = curIllegal;

  if ((point.x > Bx) && (point.x < (Bx+xLineExt)) && (point.y > By) && (point.y < (By+yLineExt)))
    {
      Si = (point.x - Bx) / xExt;
      Sj = (point.y - By) / yExt;
      move = Si * 10 + Sj + 11;
      if (legalcheck(board[0], move, human, computer))
          cur = curLegal;
    }
  SetCursor(cur);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowBestMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowBestMove(
HWND hwnd)

{
  HDC           hdc;
  INT           sq;
  register INT  x, y;
  INT           *pMoves;
  BOOL          bDone;

  if (fPass == PASS && !ffirstmove)
      return;

  if (!fCheated)
      SetWindowText(hwnd, (LPSTR)szReversiPractice);

  fCheated = TRUE;
  SetCursor(curThink);
  fThinking = TRUE;

  if (ffirstmove)
    {
      /* HACK: Hardcode the first move hint. */
      x = 4;
      y = 2;
    }
  else
    {
      if (depth == 1)
        {
          bDone = FALSE;
          pMoves = moves;
          sq = *pMoves;
          while (!bDone)
            {
              sq = *pMoves;
              if (legalcheck(board[0], sq, human, computer))
                  bDone = TRUE;
              else
                  pMoves++;
            }
          y = (sq - 11) % 10;
          x = (sq - 11) / 10;
        }
      else
        {
          minmax(board, BestMove[0],  computer, human, 1, -infin, infin);
          y = (BestMove[1] - 11) % 10;
          x = (BestMove[1] - 11) / 10;
        }
    }

  MousePos.x = (x * xExt) + Bx + xExt/2;
  MousePos.y = (y * yExt) + By + yExt/2;

  UpdateCursor(hwnd);

  hdc = GetDC(hwnd);

  x = x * xExt + Bx + 2 * ASPECT;
  y = y * yExt + By + 2;

  flashsqr(hdc, x, y, xExt - 4 * ASPECT, yExt - 4, computer, TRUE, 3);

  fThinking = FALSE;

  ReleaseDC(hwnd, hdc);

  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  gameover() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Find a human reply to the computers move.
 * As a side effect set flag fPass if the human
 * has a legal move.
 */

VOID NEAR PASCAL gameover(
register HWND   hWindow,
HDC             hDC,
BYTE            b[max_depth + 2][BoardSize],
INT             r)

{
  register INT  i;
  INT           cc;
  INT           hc;
  INT           sq;
  INT           reply2;
  INT           *pMoves;

  pMoves = moves;
  fPass = PASS;
  reply2 = PASS;
  while ((sq = *pMoves++) != 0)
    {
      if (legalcheck(b[0], sq, human, computer))
          fPass = sq;
      else if (legalcheck(b[0], sq, computer, human))
          reply2 = sq;
    }

  if (fPass == PASS)
    {
      if ((r == PASS) || (reply2 == PASS))
        {
          hc = 0;
          cc = 0;
          for (i=11; i <= 88; i++)
            {
              if (b[0][i] == human)
                  hc++;
              else if (b[0][i] == computer)
                  cc++;
            }

          if (hc > cc)
              RevMessage(hWindow, hDC, szWon, hc-cc, szWonPost);
          else if (hc < cc)
              RevMessage(hWindow, hDC, szLoss, cc-hc, szLossPost);
          else
              RevMessage(hWindow, hDC, szTie, 0, NULL);
        }
      else
        {
          RevMessage(hWindow, hDC, szMustPass, 0, NULL);
        }
    }
  else if (r == PASS)
    {
      RevMessage(hWindow, hDC, szPass, 0, NULL);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  paintmove() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Make a move and show the results. */

VOID NEAR PASCAL paintmove(
BYTE    b[BoardSize],
INT     move,
BYTE    friendly,
BYTE    enemy)
{
  INT           d;
  INT           sq;
  INT           *p;
  register INT  i,j;
  INT           color;

  if (move != PASS)
    {
      if (friendly == computer)
        {
          SelectObject(hDisp, hbrComputer);
          color = 1;
        }
      else
        {
          SelectObject(hDisp, hbrHuman);
          color = 2;
        }

      i = ((move - 11) / 10) * xExt + Bx + 2 * ASPECT;
      j = ((move - 11) % 10) * yExt + By + 2;
      Ellipse(hDisp, i, j, i + xExt - 4 * ASPECT, j + yExt - 4);
      flashsqr(hDisp, i, j, xExt - 4 * ASPECT, yExt - 4, color, FALSE, 4);

      p = direc;
      while ((d = *p++) != 0)
        {
          sq=move;
          if (b[sq += d] == enemy)
           {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == (BYTE)friendly)
               {
                 while(b[sq -= d] == enemy)
                   {
                     board[0][sq] = b[sq] = friendly;
                     i = ((sq - 11)/10)*xExt+Bx+2*ASPECT;
                     j = ((sq - 11)%10)*yExt+By+2;
                     Ellipse(hDisp, i, j, i + xExt-4*ASPECT, j + yExt-4);
                   }
               }
           }
        }
      b[move]=friendly;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMenu() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_COMMAND messages. */

VOID NEAR PASCAL RevMenu(
register HWND   hWindow,
INT             idval)

{
  HDC           hDC;
  register INT  cmd;

  if (fThinking)
      return;

  hWin = hWindow;

  switch (idval)
    {
      case EXIT:
          PostMessage(hWindow, WM_CLOSE, 0, 0L);
          break;

      case MN_HELP_ABOUT:
          DialogBox(hInst, MAKEINTRESOURCE(3), hWindow, AboutDlgProc);
          break;

      case MN_HELP_INDEX:
          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_INDEX, 0L);
          break;

      case MN_HELP_USINGHELP:
          //TEMPFIX WinHelp(hWindow, (LPSTR)NULL, HELP_HELPONHELP, 0L);
          break;

      case MN_HELP_KEYBOARD:
          cmd = 0x1e;
          goto HelpCommon;

      case MN_HELP_COMMANDS:
          cmd = 0x20;
          goto HelpCommon;

      case MN_HELP_PLAYING:
          cmd = 0x21;
          goto HelpCommon;

      case MN_HELP_RULES:
          cmd = 0x22;
HelpCommon:
          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_CONTEXT, (DWORD)cmd);
          break;

      case HINT:
          ShowBestMove(hWindow);
          return;
          break;

      case NEW:
          SetWindowText(hWindow , (LPSTR)szReversi);
          ffirstmove = TRUE;
          hDisp = hDC = GetDC(hWindow);
          fCheated = FALSE;
          SetBkMode(hDisp, OPAQUE);
          ClearMessageTop(hDC);
          fPass = PASS;
          clearboard(board);
          drawboard(board);
          ReleaseDC(hWindow, hDC);
          hDisp = 0;
          break;

      case EASY:
          depth = 1;                      /* MUST BE AT LEAST 1.  */
          checkdepth(hWindow, EASY);      /* KEEP HANDS OFF!      */
          break;

      case MEDIUM:
          depth = 2;
          checkdepth(hWindow, MEDIUM);
          break;

      case HARD:
          depth = 4;
          checkdepth(hWindow, HARD);
          break;

      case VHARD:
          depth = 6;
          checkdepth(hWindow, VHARD);
          break;

      case PASS:
          if (fPass == PASS)
            {
              hDisp = hDC = GetDC(hWindow);
              SetBkMode(hDisp, OPAQUE);
              fThinking = TRUE;
              ClearMessageTop(hDC);
              SetCursor(curThink);
              ReleaseDC(hWindow, hDC);
              hDisp = 0;
              minmax(board, PASS, human, computer, 0, -infin, infin);
              hDisp = hDC = GetDC(hWindow);
              paintmove(board[0], BestMove[0], (BYTE)computer, (BYTE)human);
              gameover(hWindow, hDC, board, BestMove[0]);
              SetCursor(curIllegal);
              fThinking = FALSE;
              ReleaseDC(hWindow, hDC);
              hDisp = 0;
            }
          else
              MessageBox(hWindow, (LPSTR)szNoPass, (LPSTR)szReversi, MB_OK | MB_ICONASTERISK);
          break;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  msgcheck() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called by ASM routine to allow other tasks to run. */

BOOL NEAR PASCAL msgcheck()
{
  MSG msg;

  if (PeekMessage((LPMSG)&msg, NULL, 0, 0, TRUE))
    {
      if (msg.message == WM_QUIT)
        exit(0);

      if (TranslateAccelerator(msg.hwnd, hAccel, (LPMSG)&msg) == 0)
        {
          TranslateMessage((LPMSG)&msg);
          DispatchMessage((LPMSG)&msg);
        }

      return(TRUE);
    }
  return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevInit() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL RevInit(
HANDLE hInstance)

{
  register PWNDCLASS    pRevClass;
  HANDLE                hbmdel;
  HDC                   hdc;
  static INT rgpat[] = { 170, 85, 170, 85, 170, 85, 170, 85 };

  hbrWhite = GetStockObject(WHITE_BRUSH);
  hbrBlack = GetStockObject(BLACK_BRUSH);
  hbmdel   = CreateBitmap(8, 8, 1, 1, (LPSTR)rgpat);
  hbrPat   = CreatePatternBrush(hbmdel);

  if (!hbrPat)
      return(FALSE);
  if (hbmdel)
      DeleteObject(hbmdel);
  ffirstmove = TRUE;
  hdc = GetDC((HWND)NULL);

  COLOR = GetDeviceCaps(hdc, NUMCOLORS) > 2;

  if (GetDeviceCaps(hdc, VERTRES) == 200)
      ASPECT = 2;
  else
      ASPECT = 1;
  ReleaseDC((HWND)NULL, hdc);

  hbrRed        = (HBRUSH)CreateSolidBrush(RGB(0xFF,0,0));
  hbrGreen      = (HBRUSH)CreateSolidBrush(RGB(0,0xFF,0));
  hbrBlue       = (HBRUSH)CreateSolidBrush(RGB(0,0,0xFF));

  if (!hbrRed || !hbrGreen || !hbrBlue)
      return(FALSE);

  LoadString(hInstance, 3,  (LPSTR)szReversi, 20);
  LoadString(hInstance, 4,  (LPSTR)szReversiPractice, 40);
  LoadString(hInstance, 5,  (LPSTR)szPass, 30);
  LoadString(hInstance, 6,  (LPSTR)szMustPass, 30);
  LoadString(hInstance, 7,  (LPSTR)szTie, 30);
  LoadString(hInstance, 8,  (LPSTR)szLoss, 30);
  LoadString(hInstance, 9,  (LPSTR)szWon, 30);
  LoadString(hInstance, 10, (LPSTR)szAbout, 20);
  LoadString(hInstance, 11, (LPSTR)szLossPost, 30);
  LoadString(hInstance, 12, (LPSTR)szWonPost, 30);
  LoadString(hInstance, 13, (LPSTR)szIllegal, 70);
  LoadString(hInstance, 14, (LPSTR)szNoPass, 70);
  LoadString(hInstance, 15, (LPSTR)szHelpFile, 15);

  hAccel = LoadAccelerators(hInstance, (LPSTR)"MAINACC");
  pRevClass = (PWNDCLASS)((CHAR *)LocalAlloc(LMEM_ZEROINIT, sizeof(WNDCLASS)));
  if (!pRevClass)
      return(FALSE);

  curLegal   = LoadCursor(NULL, IDC_CROSS);
  curIllegal = LoadCursor(NULL, IDC_ARROW);
  curThink   = LoadCursor(NULL, IDC_WAIT);
  curBlank   = LoadCursor(hInstance, MAKEINTRESOURCE(1));
  if (!curLegal || !curIllegal || !curThink || !curBlank)
      return(FALSE);
  pRevClass->hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(3));

  pRevClass->lpszClassName = (LPSTR)"Reversi";
  pRevClass->hbrBackground = ((COLOR) ? hbrGreen : hbrWhite);
  pRevClass->lpfnWndProc   = ReversiWndProc;
  pRevClass->lpszMenuName  = MAKEINTRESOURCE(1);
  pRevClass->hInstance    = hInstance;
  pRevClass->style         = CS_VREDRAW | CS_HREDRAW | CS_BYTEALIGNCLIENT;

  if (!RegisterClass((LPWNDCLASS)pRevClass))
    {
      LocalFree((HANDLE)pRevClass);
      return(FALSE);
    }
  LocalFree((HANDLE)pRevClass);

  return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMouseClick() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMouseClick(
HWND  hWnd,
POINT point)
{
  INT     move;
  INT     Si, Sj;
  INT     yLineExt = 8 * yExt;
  INT     xLineExt = 8 * xExt;
  HDC     hDC;

  MousePos.x = point.x;
  MousePos.y = point.y;

  if (xExt == 0 || yExt == 0)
      return;

  if ((point.x > Bx) && (point.x < (Bx+xLineExt)) && (point.y > By) && (point.y < (By+yLineExt)))
    {
      Si = (point.x - Bx) / xExt;
      Sj = (point.y - By) / yExt;
      move = Si * 10 + Sj + 11;
      if (legalcheck(board[0], move, human, computer))
        {
          board[0][move] = human;
          ffirstmove = FALSE;
          fThinking = TRUE;
          SetCursor(curThink);

          hDisp = hDC = GetDC(hWnd);
          ClearMessageTop(hDC);

          minmax(board, move, human, computer, 0, -infin, infin);
          makemove(board[0], move, human, computer);

          hDisp = hDC;

          paintmove(board[0], BestMove[0], computer, human);
          gameover(hWnd, hDC, board, BestMove[0]);

          ReleaseDC(hWnd, hDC);
          hDisp = 0;

          SetCursor(curIllegal);
          fThinking = FALSE;
        }
      else
          MessageBox(hWnd, (LPSTR)szIllegal, (LPSTR)szReversi, MB_OK | MB_ICONASTERISK);
   }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Next() -                                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL Next(
register INT *px,
register INT *py)

{
  (*px)++;
  if (*px > 7)
    {
      *px = 0;
      (*py)++;
      if (*py > 7)
          *py = 0;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Previous() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL Previous(
register INT *px,
register INT *py)
{
  (*px)--;
  if (*px < 0)
    {
      *px = 7;
      (*py)--;
      if (*py < 0)
          *py = 7;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowNextMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowNextMove(
HWND    hwnd,
BOOL    fforward)
{
  INT       x, y;
  INT       potentialmove;
  BOOL      done;

  /* What out for infinite loops. */
  if (fPass == PASS && !ffirstmove)
      return;

  x = (MousePos.x - Bx) / xExt;
  y = (MousePos.y - By) / yExt;

  done = FALSE;
  while (!done)
    {
      do
        {
          if (fforward)
              Next(&x, &y);
          else
              Previous(&x, &y);
        }
      while ((board[0][potentialmove = (x * 10 + y + 11)]) != empty);

      fThinking = TRUE;
      if (legalcheck(board[0], potentialmove, human, computer))
          done = TRUE;

      fThinking = FALSE;
    }

  MousePos.x = x * xExt + Bx + xExt / 2;
  MousePos.y = y * yExt + By + yExt / 2;

  UpdateCursor(hwnd);
  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevChar() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevChar(
HWND            hwnd,
register WORD   code)
{
  INT   a;
  POINT curpoint;

  curpoint.x = curpoint.y = 1;
  switch (code)
    {
      case 0x27:
          MousePos.x += xExt;
          break;

      case 0x28:
          MousePos.y += yExt;
          break;

      case 0x25:
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.x -= xExt;
          break;

      case 0x26:
          curpoint.y = (MousePos.y - By)/yExt;
          MousePos.y -= yExt;
          break;

      case 0x24:
          curpoint.y = (MousePos.y - By)/yExt;
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.y -= yExt;
          MousePos.x -= xExt;
          break;

      case 0x21:
          curpoint.y = (MousePos.y - By)/yExt;
          MousePos.y -= yExt;
          MousePos.x += xExt;
          break;

      case 0x23:
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.y += yExt;
          MousePos.x -= xExt;
          break;

      case 0x22:
          MousePos.y += yExt;
          MousePos.x += xExt;
          break;

      case 0x0020:
      case 0x000D:
          if (!fThinking)
              RevMouseClick(hwnd, MousePos);
          return;

      case 0x0009:
          if (fThinking)
              break;
          if (GetKeyState(VK_SHIFT) < 0)
              ShowNextMove(hwnd, FALSE);    /* look backwards */
          else
              ShowNextMove(hwnd, TRUE);     /* look forwards */
          return;

      default:
          return;
    }

  if (((a = ((MousePos.x - Bx) / xExt)) >7) || a <= 0)
      MousePos.x = Bx + xExt / 2;             /* wrap around horizontally */

  if (a > 8 || (curpoint.x == 0 && a == 0))
      MousePos.x = (7*xExt) + Bx + xExt / 2 ;

  if ( ((a = ((MousePos.y - By) / yExt)) >7) || a <= 0)
      MousePos.y = By + yExt / 2;

  if ( a > 8 || (curpoint.y == 0 && a == 0))
      MousePos.y = (7*yExt) + By + yExt / 2;

  MousePos.x = ((MousePos.x - Bx) / xExt) * xExt + Bx + xExt / 2;
  MousePos.y = ((MousePos.y - By) / yExt) * yExt + By + yExt / 2;
  UpdateCursor(hwnd);
  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InverseMessage() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID APIENTRY InverseMessage(
register HWND   hWindow,
UINT            message,
UINT_PTR        wParam,
DWORD           lParam)
{
  HDC   hDC;

  message;
  wParam;
  lParam;

  if (flashtimes <= count)
    {
      hDC = GetDC(hWindow);
      PatBlt(hDC, 0, 0, xscr, charheight, DSTINVERT);
      flashtimes++;
      ReleaseDC(hWindow, hDC);
    }
  else
      KillTimer(hWindow, 666);

  return;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReversiWndProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LRESULT APIENTRY ReversiWndProc(
HWND            hWnd,
register UINT   message,
WPARAM          wParam,
LPARAM          lParam)
{
  HMENU         hm;
  PAINTSTRUCT   ps;
  POINT         curpoint;

  switch (message)
    {
      case WM_COMMAND:
          RevMenu(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
          break;

      case WM_INITMENU:                 /* disable the menu if thinking */
          hm = GetMenu(hWnd);
          if (fThinking)
            {
              EnableMenuItem(hm, 0, MF_DISABLED | MF_BYPOSITION);
              EnableMenuItem(hm, 1, MF_DISABLED | MF_BYPOSITION);
            }
          else
            {
              EnableMenuItem(hm, 0, MF_ENABLED | MF_BYPOSITION);
              EnableMenuItem(hm, 1, MF_ENABLED | MF_BYPOSITION);
            }
          break;

      case WM_CREATE:
          RevCreate(hWnd);
          hWin = hWnd;
          break;

      case WM_CLOSE:
          if (hDisp)
              ReleaseDC(hWnd, hDisp);
          return(DefWindowProc(hWnd, message, wParam, lParam));

      case WM_DESTROY:
          if (MGetModuleUsage(hInst) == 1)
            {
              DeleteObject(hbrGreen);
              DeleteObject(hbrPat);
              DeleteObject(hbrRed);
              DeleteObject(hbrBlue);
            }

          /* In case WinHelp keys off hWindow, we need to do the HELP_QUIT
           * here instead of when there is just one instance of help...
           */
          //TEMPFIX WinHelp(hWnd, (LPSTR)szHelpFile, HELP_QUIT, 0L);

          PostQuitMessage(0);
          break;

      case WM_KEYDOWN:
          if (IsIconic(hWnd))
              return 0L;
          RevChar(hWnd, (WORD)wParam);
          break;

      case WM_ACTIVATE:
          if (!GetSystemMetrics(SM_MOUSEPRESENT))
            {
              if (GET_WM_ACTIVATE_STATE(wParam, lParam))
                {
                  if (GET_WM_ACTIVATE_HWND(wParam, lParam) != hWnd)
                    {
                      curpoint.x = MousePos.x;
                      curpoint.y = MousePos.y;
                      ClientToScreen(hWnd, (LPPOINT)&curpoint);
                      SetCursorPos(curpoint.x, curpoint.y);
                      RevMouseMove(MousePos);
                      ShowCursor(GET_WM_ACTIVATE_STATE(wParam, lParam));
                    }
                }
              else
                  ShowCursor((BOOL) wParam);
            }
          if (wParam && (!HIWORD(lParam)))
              SetFocus(hWnd);
          break;

      case WM_PAINT:
          BeginPaint(hWnd, (LPPAINTSTRUCT)&ps);
          RevPaint(hWnd, ps.hdc);
          EndPaint(hWnd, (LPPAINTSTRUCT)&ps);
          break;

      case WM_MOUSEMOVE:
		  {
		  POINT pt;

		  LONG2POINT(lParam, pt);		/* convert LONG lParam to POINT structure*/
          if (!fThinking)
#ifdef ORGCODE		
              RevMouseMove(MAKEPOINT(lParam));
#else
              RevMouseMove(pt);
#endif
          else
              SetCursor(curThink);
          break;
		  }
      case WM_LBUTTONDOWN:
          SetCapture(hWnd);
          bMouseDownInReversi = TRUE;
          break;

      case WM_LBUTTONUP:
		  {
		  POINT pt;

		  LONG2POINT(lParam, pt);		/* convert LONG lParam to POINT structure*/

          ReleaseCapture();
          if (!fThinking && bMouseDownInReversi)
#ifdef ORGCODE
              RevMouseClick(hWnd, MAKEMPOINT(lParam));
#else
              RevMouseClick(hWnd, pt);
#endif
          bMouseDownInReversi = FALSE;
          break;
		  }
      case WM_TIMER:
          /* This should never be called. */
          break;

      case WM_VSCROLL:
      case WM_HSCROLL:
              break;

      default:
          return(DefWindowProc(hWnd, message, wParam, lParam));
          break;
      }
  return(0L);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AboutDlgProc()                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR APIENTRY AboutDlgProc(
HWND          hDlg,
UINT          message,
WPARAM        wParam,
LPARAM        lParam)

{
  if (message == WM_COMMAND)
    {
      EndDialog(hDlg, TRUE);
      return(TRUE);
    }
  if (message == WM_INITDIALOG)
      return(TRUE);
  else
      return(FALSE);
  UNREFERENCED_PARAMETER(wParam);	
  UNREFERENCED_PARAMETER(lParam);	
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WinMain() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

MMain(hInstance, hPrev, lpszCmdLine, cmdShow) /* { */
  HWND hWnd;
  MSG   msg;

  _argc;
  _argv;

  hInst = hInstance;
  if (!hPrev)
    {
      if (!RevInit(hInstance))
          return(FALSE);
    }
  else
    {
      if (fThinking)
          return FALSE;
#ifdef WIN16
      GetInstanceData(hPrev, (PSTR)&hbrBlack,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrPat,             sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrWhite,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrRed,             sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrBlue,            sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrGreen,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrComputer,        sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrHuman,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&curIllegal,         sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curLegal,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curThink,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curBlank,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&prevCheck,          sizeof(prevCheck));
      GetInstanceData(hPrev, (PSTR)&depth,              sizeof(depth));
      GetInstanceData(hPrev, (PSTR)direc,               sizeof(direc));
      GetInstanceData(hPrev, (PSTR)moves,               sizeof(moves));
      GetInstanceData(hPrev, (PSTR)szReversi,           20);
      GetInstanceData(hPrev, (PSTR)szReversiPractice,   40);
      GetInstanceData(hPrev, (PSTR)szPass,              10);
      GetInstanceData(hPrev, (PSTR)szMustPass,          20);
      GetInstanceData(hPrev, (PSTR)szTie,               15);
      GetInstanceData(hPrev, (PSTR)szLoss,              15);
      GetInstanceData(hPrev, (PSTR)szWon,               15);
      GetInstanceData(hPrev, (PSTR)szAbout,             20);
      GetInstanceData(hPrev, (PSTR)&COLOR,              sizeof(INT));
      GetInstanceData(hPrev, (PSTR)&ASPECT,             sizeof(INT));
      GetInstanceData(hPrev, (PSTR)&hAccel,             2);
      GetInstanceData(hPrev, (PSTR)szIllegal,           70);
      GetInstanceData(hPrev, (PSTR)szNoPass,            70);
      GetInstanceData(hPrev, (PSTR)szHelpFile,          15);
#endif /* WIN16 */
    }

  TYMIN = 45;
  fThinking = FALSE;

  hWnd = CreateWindow((LPSTR) "Reversi",
                fCheated ? (LPSTR)szReversiPractice : (LPSTR)szReversi,
                WS_TILEDWINDOW,
                CW_USEDEFAULT,
                0,
                (GetSystemMetrics(SM_CXSCREEN) >> 1),
                (GetSystemMetrics(SM_CYSCREEN) * 4 / 5),
                (HANDLE)NULL,
                (HANDLE)NULL,
                (HANDLE)hInstance,
                NULL);

  if (!hWnd)
      return(FALSE);

  ShowWindow(hWnd, cmdShow);
  UpdateWindow(hWnd);

  /* Messaging Loop. */
  while (GetMessage((LPMSG)&msg, NULL, 0, 0))
    {
      if (!TranslateAccelerator(msg.hwnd, hAccel, (LPMSG)&msg))
        {
          TranslateMessage((LPMSG)&msg);
          DispatchMessage((LPMSG)&msg);
        }
    }
  return(0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\back.h ===
typedef BITMAPINFOHEADER BMP;

#define DyBmp(bmp) ((int) bmp.biHeight)
#define DxBmp(bmp) ((int) bmp.biWidth)
#define CplnBmp(bmp) 1
#define OfsBits(bgnd) (bgnd.dwOfsBits)
#define CbLine(bgnd) (bgnd.cbLine)

typedef BITMAPFILEHEADER BMPHDR;

typedef struct _bgnd
{
	PT ptOrg;
	OFSTRUCT of;
	BMP bm;
	/* must folow a bm  */
	BYTE rgRGB[64];  /* bug: wont work with >16 color bmps  */
	INT cbLine;
	LONG dwOfsBits;
	BOOL fUseBitmap;
	DY dyBand;
	INT ibndMac;
	HANDLE *rghbnd;
} BGND;


/* PUBLIC routines */

BOOL FInitBgnd(TCHAR *szFile);
BOOL FDestroyBgnd();
BOOL FGetBgndFile(TCHAR *sz);
VOID DrawBgnd(X xLeft, Y yTop, X xRight, Y yBot);
VOID SetBgndOrg();



/* Macros */

extern BGND bgnd;

#define FUseBitmapBgnd() (bgnd.fUseBitmap)


#define BFT_BITMAP 0x4d42   /* 'BM' */
#define ISDIB(bft) ((bft) == BFT_BITMAP)
#define WIDTHBYTES(i)   ((i+31)/32*4)      /* ULONG aligned ! */
WORD DibNumColors(VOID FAR * pv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\assert.h ===
#define ASSERTFAILED   999
#define EXIT           2
#define FILE           200
#define GAMENO         203
#define LINE           201
#define OK             1
#define SOLVERSION     202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\col.c ===
#include "sol.h"
VSZASSERT

BOOL fMegaDiscardHack = fFalse;   /* See klond.c's DiscardMove  */


MOVE move = {0};	   /* move data, pointed to by current pcol->pmove  */



COLCLS *PcolclsCreate(INT tcls, INT (FAR *lpfnColProc)(),
							DX dxUp, DY dyUp, DX dxDn, DY dyDn,
							INT dcrdUp, INT dcrdDn)
{
	COLCLS *pcolcls;

	if((pcolcls = PAlloc(sizeof(COLCLS)))==NULL)
		return NULL;

	Assert(lpfnColProc != NULL);
	pcolcls->tcls = tcls;
	pcolcls->lpfnColProc = lpfnColProc;
	pcolcls->ccolDep = 0;
	pcolcls->dxUp = dxUp;
	pcolcls->dyUp = dyUp;
	pcolcls->dxDn = dxDn;
	pcolcls->dyDn = dyDn;
	pcolcls->dcrdUp = dcrdUp;
	pcolcls->dcrdDn = dcrdDn;
	return pcolcls;
}


COL *PcolCreate(COLCLS *pcolcls, X xLeft, Y yTop, X xRight, Y yBot, INT icrdMax)
{
	COL *pcol;


	if((pcol = PAlloc(sizeof(COL) + (icrdMax-1)*sizeof(CRD)))==NULL)
		return NULL;
	
	if( (pcol->pcolcls = pcolcls) != NULL )
		pcol->lpfnColProc = pcolcls->lpfnColProc;
	
	pcol->rc.xLeft = xLeft;
	pcol->rc.yTop = yTop;
	pcol->rc.xRight = xRight;
	pcol->rc.yBot = yBot;
	pcol->icrdMax = icrdMax;
	pcol->icrdMac = 0;
	pcol->pmove = NULL;
	if(pcol->pcolcls != NULL)
		pcol->pcolcls->ccolDep++;
	return pcol;
}


#ifdef DEBUG
INT SendColMsg(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{
	INT imdbg;
	INT wResult;

	Assert(pcol != NULL);
	imdbg = ILogMsg(pcol, msgc, wp1, wp2, fFalse);

	wResult = (*(pcol->lpfnColProc))(pcol, msgc, wp1, wp2);
	LogMsgResult(imdbg, wResult);
	return wResult;
}
#endif


VOID DrawBackExcl(COL *pcol, PT *ppt)
{
	COLCLS *pcolcls;

	pcolcls = pcol->pcolcls;

	if(pcolcls->dxUp != 0 || pcolcls->dxDn != 0)
		DrawBackground(ppt->x+dxCrd, pcol->rc.yTop, pcol->rc.xRight, pcol->rc.yBot);
	if(pcolcls->dyUp != 0 || pcolcls->dyDn != 0)
		DrawBackground(pcol->rc.xLeft, ppt->y+dyCrd, pcol->rc.xRight, pcol->rc.yBot);
}



BOOL DefFreeCol(COL *pcol)
{
	COLCLS *pcolcls;

	if((pcolcls = pcol->pcolcls) != NULL)
		{
		pcolcls = pcol->pcolcls;
		Assert(pcolcls->ccolDep > 0);
		if(--pcolcls->ccolDep == 0)
			{
			FreeP(pcol->pcolcls);
			}
		}
	FreeP(pcol);
	return fTrue;
}


	
INT DefHit(COL *pcol, PT *ppt, INT icrdMin)
{
	INT icrd;
	CRD *pcrd;
	HDC hdc, hdcCurSav;
	PT ptCrd;
	RC rc;
	INT OldusehdcCur;

	if(!PtInRect((LPRECT)&pcol->rc, *(POINT *)ppt) || pcol->icrdMac == 0)
		return icrdNil;
	for(icrd = pcol->icrdMac-1; icrd >= icrdMin && (pcrd = &pcol->rgcrd[icrd])->fUp; icrd--)
		{
	 	if(FPtInCrd(pcrd, *ppt))
			{
			move.ccrdSel = pcol->icrdMac-icrd;
			/* save where mouse hit card */
			ptCrd = pcol->rgcrd[icrd].pt;
			move.delHit.dx = ptCrd.x - ppt->x;
			move.delHit.dy = ptCrd.y - ppt->y;

			if(fOutlineDrag)
				goto Return;

			hdc = GetDC(hwndApp);
			if(hdc == NULL)

				{
// No longer referenced label.
//
//OOM0:
				OOM();
				return icrdNil;
				}
				
			move.hdcScreen = hdc;
			move.dyCol = dyCrd+(move.ccrdSel-1)*pcol->pcolcls->dyUp;

			rc.xRight = (rc.xLeft = ptCrd.x) + dxCrd;
			rc.yTop = ptCrd.y;
			rc.yBot = rc.yTop+move.dyCol;

			/* optimization:  if column already drawn and visible on screen */
			/* then blt it to col image right here. */
			if(FRectAllVisible(hdc, &rc))
				{
				BitBlt(move.hdcCol, 0, 0, dxCrd, move.dyCol, hdc, ptCrd.x, ptCrd.y, SRCCOPY);	
				}
			else
				{
				OldusehdcCur = usehdcCur;
				usehdcCur = 1;
				hdcCurSav = HdcSet(move.hdcCol, ptCrd.x, ptCrd.y);
				DrawBackground(ptCrd.x, ptCrd.y, pcol->rc.xRight, pcol->rc.yBot);
				SendColMsg(pcol, msgcRender, icrd, pcol->icrdMac);
				HdcSet(hdcCurSav, 0, 0);
				usehdcCur = OldusehdcCur;
				}
				
			OldusehdcCur = usehdcCur;
			usehdcCur = 1;
			hdcCurSav = HdcSet(move.hdcScreenSave, ptCrd.x, ptCrd.y);
			DrawBackground(ptCrd.x, ptCrd.y, pcol->rc.xRight, pcol->rc.yBot);
			SendColMsg(pcol, msgcRender, icrd-1, WMax(0, icrd));
			HdcSet(hdcCurSav, 0, 0);
			usehdcCur = OldusehdcCur;

Return:
			pcol->pmove = &move;
			move.icrdSel = icrd;
			return icrd;				
			}
		}
	return icrdNil;
}



BOOL DefMouseUp(COL *pcol, PT *pptPrev, BOOL fRender)
{
	MOVE *pmove;
	VOID DrawOutline();

	if(fRender)
		SendColMsg(pcol, msgcZip, 0, 0);

	if(fOutlineDrag)
		{
		if(pptPrev->x != ptNil.x)
			SendColMsg(pcol, msgcDrawOutline, (INT_PTR) pptPrev, (INT_PTR) &ptNil);
		return fTrue;
		}

	pmove = pcol->pmove;
	if (pcol->pmove == NULL)
		return fTrue;

	if(pmove->fHdc)
		{
		if(pptPrev->x != ptNil.x)	
			{
			BitBlt(pmove->hdcScreen, pptPrev->x+pmove->delHit.dx, pptPrev->y+pmove->delHit.dy,
				dxCrd, pmove->dyCol, pmove->hdcScreenSave, 0, 0, SRCCOPY);
			}

		if(fRender)
			{
			SendColMsg(pcol, msgcRender, pmove->icrdSel-1, icrdToEnd);
			}

		ReleaseDC(hwndApp, pmove->hdcScreen);
		pmove->hdcScreen = NULL;
			
		}
	return fTrue;
}



/* Removes cards from pcol and puts them into pcolTemp */
/* ccrdSel and icrdSel must be set in pcol->pmove */
BOOL DefRemove(COL *pcol, COL *pcolTemp)
{
    INT icrdSel;
    INT ccrdSel;
    INT ccrdShiftDown;     /* amount left over in pcol */

    Assert(pcol->pmove != NULL);
    if (pcol->pmove == NULL)
	return fTrue;

    icrdSel = pcol->pmove->icrdSel;
    ccrdSel = pcol->pmove->ccrdSel;
    Assert(ccrdSel <= pcolTemp->icrdMax);
    /* save the cards to remove in pcolTemp */
    bltb(&pcol->rgcrd[icrdSel], &pcolTemp->rgcrd[0], sizeof(CRD) * ccrdSel);
    pcolTemp->icrdMac = ccrdSel;

    /* remove the cards from pcol */
    Assert(icrdSel+ccrdSel <= pcol->icrdMax);
    ccrdShiftDown = pcol->icrdMac - (icrdSel+ccrdSel);

    /* copy down any left over above the deleted cards */
    if (ccrdShiftDown > 0)
    {
        bltb(&pcol->rgcrd[icrdSel+ccrdSel], &pcol->rgcrd[icrdSel],
                sizeof(CRD) * ccrdShiftDown);
    }
    pcol->icrdMac -= ccrdSel;     /* no longer have this many cards */
/*  pcol->pmove = NULL;  Done in DefEndSel.. */
    return fTrue;
}

/* insert cards from pcolTemp into pcol at icrd */

BOOL DefInsert(COL *pcol, COL *pcolTemp, INT icrd)
{
	INT icrdT;

	icrdT = icrd == icrdToEnd ? pcol->icrdMac : icrd;

	Assert(icrdT <= pcol->icrdMac);
	Assert(pcol->icrdMac+pcolTemp->icrdMac <= pcol->icrdMax);
	/* is it the hard case of inserting in the middle of a col? */
	/* if so, expand pcol->rgcrd */
	if(icrd != icrdToEnd)
		bltb(&pcol->rgcrd[icrdT], &pcol->rgcrd[icrdT+pcolTemp->icrdMac],
			sizeof(CRD) * pcolTemp->icrdMac);
	else
		icrd = pcol->icrdMac;

	/* Insert the cards from pcolTemp to pcol */
	bltb(&pcolTemp->rgcrd[0], &pcol->rgcrd[icrdT], sizeof(CRD) * pcolTemp->icrdMac);

	pcol->icrdMac += pcolTemp->icrdMac;
	pcolTemp->icrdMac = 0;
	return fTrue;
}


BOOL DefMove(COL *pcolDest, COL *pcolSrc, INT icrd)
{
	INT icrdMacDestSav, icrdSelSav;
	COL *pcolTemp;
	BOOL fResult;
	BOOL fZip;

	fZip = icrd & bitFZip;
	icrd &= icrdMask;
	Assert(pcolSrc->pmove != NULL);
	if (pcolSrc->pmove == NULL)
		return fTrue;

	icrdSelSav = WMax(pcolSrc->pmove->icrdSel-1, 0);
	icrdMacDestSav = (icrd == icrdToEnd) ? pcolDest->icrdMac : icrd;
	if((pcolTemp = PcolCreate(NULL, 0, 0, 0, 0, pcolSrc->pmove->ccrdSel)) == NULL)
		return fFalse;

	fResult = SendColMsg(pcolSrc, msgcRemove, (INT_PTR)pcolTemp, 0) &&
		SendColMsg(pcolDest, msgcInsert, (INT_PTR) pcolTemp, icrd) &&
		SendColMsg(pcolDest, msgcComputeCrdPos, icrdMacDestSav, fFalse) &&
		(!fZip || SendColMsg(pcolSrc, msgcZip, 0, 0)) &&
		(!fOutlineDrag || SendColMsg(pcolSrc, msgcRender, icrdSelSav, icrdToEnd)) &&
		SendColMsg(pcolDest, msgcRender, icrdMacDestSav, icrdToEnd) &&
	  	SendColMsg(pcolSrc, msgcEndSel, fFalse, 0);
	FreeP(pcolTemp);
	return fResult;
}



BOOL DefCopy(COL *pcolDest, COL *pcolSrc, BOOL fAll)
{
	Assert(pcolSrc->icrdMac <= pcolDest->icrdMax);
	if(fAll)
		bltb(pcolSrc, pcolDest, sizeof(COL)+(pcolSrc->icrdMac-1)*sizeof(CRD));
	else
		{
		bltb(pcolSrc->rgcrd, pcolDest->rgcrd, pcolSrc->icrdMac*sizeof(CRD));
		pcolDest->icrdMac = pcolSrc->icrdMac;
		}
	return(SendColMsg(pcolDest, msgcRender, 0, icrdToEnd));
}




BOOL DefRender(COL *pcol, INT icrdFirst, INT icrdLast)
{
	INT icrd;
	INT icrdMac;
	CRD *pcrd, *pcrdPrev;
	COLCLS *pcolcls;

	icrdFirst = WMax(icrdFirst, 0);
	Assert(icrdLast >= 0);
	if(!FGetHdc())
		return fFalse;
	if(pcol->icrdMac == 0 || icrdLast == 0)
		{
		DrawBackground(pcol->rc.xLeft, pcol->rc.yTop, pcol->rc.xRight, pcol->rc.yBot);
		if(icrdLast == 0)
			goto EraseExtra;
		}
	else
		{
		Assert(icrdToEnd >= 0);
		Assert(icrdToEnd > pcol->icrdMac);
		Assert(icrdLast == icrdToEnd || icrdLast <= pcol->icrdMac);
		icrdMac = WMin(pcol->icrdMac, icrdLast);

		for(icrd = icrdFirst; icrd < icrdMac; icrd++)
			{
			pcrd = &pcol->rgcrd[icrd];
			if(icrd == icrdFirst ||
					pcrd->pt.x != pcrdPrev->pt.x || pcrd->pt.y != pcrdPrev->pt.y ||
					pcrd->fUp)
				DrawCard(pcrd);
			pcrdPrev = pcrd;
			}
EraseExtra:
		/* hack to make dealing quicker  */
		if(pgmCur->fDealt || pcol->pcolcls->tcls == tclsDeck)
			{
			pcolcls = pcol->pcolcls;
			pcrd = &pcol->rgcrd[icrdLast == 0 ? 0 : icrdMac-1];
			DrawBackExcl(pcol, &pcrd->pt);
			}
		}

	ReleaseHdc();
	return fTrue;
}


BOOL DefPaint(COL *pcol, PAINTSTRUCT *ppaint)
{
	INT icrd;

	if(ppaint == NULL)
		icrd = 0;
	else
		{
		if(!FRectIsect(&pcol->rc, (RC *)&ppaint->rcPaint))
			return fFalse;

		if(pcol->icrdMac == 0)
			icrd = 0;
		else
			{
			for(icrd = 0; icrd < pcol->icrdMac ;icrd++)
				if(FCrdRectIsect(&pcol->rgcrd[icrd], (RC *)&ppaint->rcPaint))
					break;
			if(icrd == pcol->icrdMac)
				return fFalse;
			}
		}

	return SendColMsg(pcol, msgcRender, icrd, icrdToEnd);
}


/* New super cool dragging, does five blts, but no clippin' */

BOOL DefDrawOutline(COL *pcol, PT *ppt, PT *pptPrev)
{
	HDC hdc, hdcT;
	HBITMAP hbmT;
	MOVE *pmove;
	PT pt, ptPrev;
	DEL del;
	COLCLS *pcolcls;

	Assert(pcol->pmove != NULL);
	pmove = pcol->pmove;
	if (pcol->pmove == NULL)
		return fTrue;

	OffsetPt(ppt, &pmove->delHit, &pt);
	if(pptPrev->x != ptNil.x)	
		OffsetPt(pptPrev, &pmove->delHit, &ptPrev);

	if(fOutlineDrag)
		{
		pcolcls = pcol->pcolcls;
		DrawOutline(&pt, pmove->ccrdSel, 0, pcolcls->dyUp);
		if(pptPrev->x != ptNil.x)
			{
			DrawOutline(&ptPrev, pmove->ccrdSel, 0, pcolcls->dyUp);
			}
		return fTrue;
		}
	
	hdc = pmove->hdcScreen;
	Assert(hdc != NULL);

	hdcT = pmove->hdcT;
	Assert(hdcT != NULL);

	hbmT = pmove->hbmT;
	Assert(hbmT != NULL);

	/* screen to save hdc */
	BitBlt(hdcT, 0, 0, dxCrd, pmove->dyCol, hdc, pt.x, pt.y, SRCCOPY);
	/* if not the first time */
	if(pptPrev->x != ptNil.x)
		{
		del.dx = pptPrev->x - ppt->x;
		del.dy = pptPrev->y - ppt->y;
		/* save old screen to save hdc */
		BitBlt(hdcT, del.dx, del.dy, dxCrd, pmove->dyCol, pmove->hdcScreenSave, 0, 0, SRCCOPY);
		BitBlt(pmove->hdcScreenSave, -del.dx, -del.dy, dxCrd, pmove->dyCol,  pmove->hdcCol, 0, 0, SRCCOPY);
		}

	BitBlt(hdc, pt.x, pt.y, dxCrd, pmove->dyCol, pmove->hdcCol, 0, 0, SRCCOPY);
	
	if(pptPrev->x != ptNil.x)
		{
		BitBlt(hdc, ptPrev.x, ptPrev.y, dxCrd, pmove->dyCol, pmove->hdcScreenSave, 0, 0, SRCCOPY);
		}

	/* swap pmove->hdcT and pmove->hdcScreenSave */
	hdcT = pmove->hdcScreenSave;
	pmove->hdcScreenSave = pmove->hdcT;
	pmove->hdcT = hdcT;

	/* swap pmove->hbmT and pmove->hbmScreenSaveOld */
	hbmT = pmove->hbmScreenSaveOld;
	pmove->hbmScreenSaveOld = pmove->hbmT;
	pmove->hbmT = hbmT;

	return fTrue;
}





BOOL DefComputeCrdPos(COL *pcol, INT icrdFirst, BOOL fAssumeDown)
{
	INT icrd;
	CRD *pcrd;
	COLCLS *pcolcls;
	PT pt;

	Assert(icrdFirst >= 0);
	if(icrdFirst == 0)
		{
		pt.x = pcol->rc.xLeft;
		pt.y = pcol->rc.yTop;
		}
	else
		{
		Assert(icrdFirst < pcol->icrdMac);
		pt = pcol->rgcrd[--icrdFirst].pt;
		/* Used by discard, because discard piles are handled differently  */
		if(fMegaDiscardHack)
			icrdFirst++;
		}

	pcolcls = pcol->pcolcls;
	for(icrd = icrdFirst; icrd < pcol->icrdMac; icrd++)
		{
		pcrd = &pcol->rgcrd[icrd];
		pcrd->pt = pt;
		if(pcrd->fUp && !fAssumeDown)
			{
		  	if(icrd % pcolcls->dcrdUp == pcolcls->dcrdUp-1)
				{
				pt.x += pcolcls->dxUp;
				pt.y += pcolcls->dyUp;
				}
			}
		else if(icrd % pcolcls->dcrdDn == pcolcls->dcrdDn-1)
			{
			pt.x += pcolcls->dxDn;
			pt.y += pcolcls->dyDn;
			}
		}
	return fTrue;
}


VOID InvertCardPt(PT *ppt)
{
	RC rc;

	rc.xRight = (rc.xLeft = ppt->x) + dxCrd;
	rc.yBot = (rc.yTop = ppt->y) + dyCrd;
	
	InvertRc(&rc);
}



INT DefValidMovePt(COL *pcolDest, COL *pcolSrc, PT *ppt)
{
	RC rc;

	Assert(pcolSrc->pmove != NULL);	
	if (pcolSrc->pmove == NULL)
		return fTrue;

	Assert((X *)&(((RC *)(0))->xLeft) == (X *)&(((PT *)(0))->x));
	Assert((Y *)&(((RC *)(0))->yTop) == (Y *)&(((PT *)(0))->y));

	OffsetPt(ppt, &pcolSrc->pmove->delHit, (PT *)&rc);
	rc.xRight = rc.xLeft+dxCrd;
	rc.yBot = rc.yTop+dyCrd;
	if(pcolDest->icrdMac == 0)
		{
		if(!FRectIsect(&rc, &pcolDest->rc))
			return icrdNil;
		}
	else if(!(FCrdRectIsect(&pcolDest->rgcrd[pcolDest->icrdMac-1], &rc)))
		return icrdNil;

	return SendColMsg(pcolDest, msgcValidMove, (INT_PTR) pcolSrc, 0) ? pcolDest->icrdMac : icrdNil;
}	



BOOL DefSel(COL *pcol, INT icrdFirst, INT ccrd)
{
#ifdef DEBUG
	INT icol;

	for(icol = 0; icol < pgmCur->icolMac; icol++)
		Assert(pgmCur->rgpcol[icol]->pmove == NULL);
#endif

	move.delHit.dx = move.delHit.dy = 0;
	if(icrdFirst == icrdEnd)
		{
		if(pcol->icrdMac > 0)
			{
			move.icrdSel = pcol->icrdMac-1;
			move.ccrdSel = 1;
			goto Return;
			}
		else
			return icrdNil;
		}
	if(ccrd == ccrdToEnd)
		ccrd = pcol->icrdMac-icrdFirst;
	Assert(icrdFirst < pcol->icrdMac);
	Assert(icrdFirst+ccrd <= pcol->icrdMac);
	move.icrdSel = icrdFirst;
	move.ccrdSel = ccrd;
Return:	
	pcol->pmove = &move;
	return move.icrdSel;
}



BOOL DefEndSel(COL *pcol, BOOL fReleaseDC)
{
	pcol->pmove = NULL;
	return fTrue;
}


BOOL DefFlip(COL *pcol, BOOL fUp)
{
	INT icrd;
	MOVE *pmove;
	INT icrdMac;
	
	Assert(pcol->pmove != NULL);
	if (pcol->pmove == NULL)
		return fTrue;

	pmove = pcol->pmove;

	icrdMac = pmove->icrdSel+pmove->ccrdSel;
	for(icrd = pmove->icrdSel; icrd < icrdMac; icrd++)
		pcol->rgcrd[icrd].fUp = (short)fUp;
	return fTrue;
}


BOOL DefInvert(COL *pcol)
{
	INT icrdSel, ccrdSel;
	INT icrd, icrdMid;

	Assert(pcol->pmove != NULL);
	if (pcol->pmove == NULL)
		return fTrue;

	icrdSel = pcol->pmove->icrdSel;
	ccrdSel = pcol->pmove->ccrdSel;

	icrdMid = icrdSel+ccrdSel/2;
	for(icrd = icrdSel; icrd < icrdMid; icrd++)
		SwapCards(&pcol->rgcrd[icrd], &pcol->rgcrd[2*icrdSel+ccrdSel-1-icrd]);

	return fTrue;
}


BOOL DefDragInvert(COL *pcol)
{

	if(fOutlineDrag)
		{
		if(!FGetHdc())
			return fFalse;
		Assert((X *)&((RC *)(0))->xLeft == (X *)&((PT *)(0))->x);
		Assert((Y *)&((RC *)(0))->yTop == (Y *)&((PT *)(0))->y);
		InvertCardPt(pcol->icrdMac > 0 ? &pcol->rgcrd[pcol->icrdMac-1].pt : (PT *)&pcol->rc);
		ReleaseHdc();
		}
	return fTrue;
}

INT DefNumCards(COL *pcol, BOOL fUpOnly)
{
	INT icrd;

	if(fUpOnly)
		{
		for(icrd = pcol->icrdMac-1; icrd >= 0 && pcol->rgcrd[icrd].fUp; icrd--)
			;
		Assert(pcol->icrdMac-1-icrd >= 0);
		return pcol->icrdMac-1-icrd;
		}
	else
		return pcol->icrdMac;
}



BOOL DefGetPtInCrd(COL *pcol, INT icrd, PT *ppt)
{
	PT *pptT;
	if(icrd == 0)
		pptT = (PT *)&pcol->rc;
	else
		{
		pptT = &pcol->rgcrd[icrd].pt;
		Assert(icrd < pcol->icrdMac);
		}
	ppt->x = pptT->x+dxCrd/2;
	ppt->y = pptT->y;
	return fTrue;
}





BOOL DefShuffle(COL *pcol)
{
	INT iSwitch;
	CRD crdT;
	INT icrd;
	CRD *pcrdS;
//	INT cdecl rand();

#define iSwitchMax 5

	for(iSwitch = 0; iSwitch < iSwitchMax; iSwitch++)
		{
		for(icrd = 0; icrd < pcol->icrdMac; icrd++)
			{
			pcrdS = &pcol->rgcrd[rand() % pcol->icrdMac];
			crdT = pcol->rgcrd[icrd];
			pcol->rgcrd[icrd] = *pcrdS;
			*pcrdS = crdT;
			}
		}
	return fTrue;
}

#define izipMax 35

VOID APIENTRY DdaProc(INT x, INT y, LPARAM lpextra)
{
	COL *pcol;
	PT pt;

	pcol = (COL *)lpextra;
	if (pcol->pmove == NULL)
		return;

	if(pcol->pmove->izip++ < izipMax)
		return;
	pcol->pmove->izip = 0;
	pt.x = x;
	pt.y = y;
	SendColMsg(pcol, msgcDrawOutline, (INT_PTR) &pt, (INT_PTR) &pgmCur->ptMousePrev);
	pgmCur->ptMousePrev = pt;
}


INT DefZip(COL *pcol)
{
	PT ptDest;
	MOVE *pmove;

	/* When outline-dragging is checked, that starting point can be ptNil and
	 * in this case we draw a line starting from (7FFF, 7FFF) and this
	 * causes the temporary hang! So, avoid the LineDDA() call when the
	 * prev point is ptNil;
	 * Fix for Bug #8182 --SANKAR-- 01-23-90
	 */
	if(pgmCur->ptMousePrev.x == ptNil.x)
	    return(fTrue);

	pmove = pcol->pmove;
	if (pcol->pmove == NULL)
		return fTrue;

	/* Don't use OffsetPt here, it's sense is wrong */
	ptDest = pcol->rgcrd[pmove->icrdSel].pt;
	ptDest.x -= pmove->delHit.dx;
	ptDest.y -= pmove->delHit.dy;

	pmove->izip = 0;
	LineDDA(pgmCur->ptMousePrev.x, pgmCur->ptMousePrev.y, ptDest.x, ptDest.y, DdaProc, (LPARAM) pcol );
	return fTrue;
}


INT DefColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{	
	switch(msgc)
		{
	case msgcInit:
		return fTrue;

	case msgcEnd:
		return DefFreeCol(pcol);

	case msgcClearCol:
		pcol->pmove = NULL;
		pcol->icrdMac = 0;
		/* more? */
		return fTrue;

	case msgcHit:	/* wp1 = ppt, return icrdHit/icrdNil */
		return DefHit(pcol, (PT *)wp1, (INT)wp2);

	case msgcMouseUp:
		return DefMouseUp(pcol, (PT *) wp1, (INT)wp2);

	case msgcDblClk:
		return fFalse;

	case msgcSel:  /* wp1 = icrdSel, icrdEnd if last card, wp2 = ccrdSel, ccrdToEnd if all to end */
		return DefSel(pcol, (INT)wp1, (INT)wp2);

	case msgcEndSel:
		return DefEndSel(pcol, (BOOL)wp1);

	case msgcNumCards:
		return DefNumCards(pcol, (BOOL)wp1);

	case msgcFlip: /* wp1 = fUp */
		return DefFlip(pcol, (BOOL)wp1);

	case msgcInvert:
		return DefInvert(pcol);

	case msgcRemove: 	/* wp1 = pcolTemp, return fTrue/fFalse */
		return DefRemove(pcol, (COL *) wp1);

	case msgcInsert:	/* wp1 = pcolTemp, */
							/* wp2 = icrd to insert after, icrdToEnd if at end*/
		return DefInsert(pcol, (COL *)wp1, (INT)wp2);

	case msgcMove:	 	/* wp1 = pcolSrc, wp2 = icrd, (icrdToEnd = to endcrd) */
			 				/* return fTrue/fFalse */
		return DefMove(pcol, (COL *) wp1, (INT)wp2);

	case msgcCopy:  /* wp1 = pcolSrc, wp2 = fAll (if true then copy all of col struct)*/
		return DefCopy(pcol, (COL *) wp1, (BOOL)wp2);

	case msgcValidMove: /* wp1 = pcolSrc, wp2 = icrd, (icrdToEnd = to endcrd) */
		/* this must be supplied by game */
		return fFalse;

	case msgcValidMovePt:
		return DefValidMovePt(pcol, (COL *) wp1, (PT *)wp2);

	case msgcRender:	/* wp1 = icrdFirst, return fTrue/fFalse*/
		return DefRender(pcol, (INT)wp1, (INT)wp2);
	
	case msgcPaint:	/* wp1 = ppaint, if NULL then paint all */
		return DefPaint(pcol, (PAINTSTRUCT *) wp1);

	case msgcDrawOutline: /* wp1 = ppt , wp2 = pptPrev*/
		return DefDrawOutline(pcol, (PT *) wp1, (PT *) wp2);

	case msgcComputeCrdPos: /* wp1 = icrdFirst */
		return DefComputeCrdPos(pcol, (INT)wp1, (BOOL)wp2);

	case msgcDragInvert:
		return DefDragInvert(pcol);

	case msgcGetPtInCrd:
		return DefGetPtInCrd(pcol, (INT)wp1, (PT *)wp2);

	case msgcValidKbdColSel:
		return fTrue;

	case msgcValidKbdCrdSel:
		return fTrue;

	case msgcShuffle:
		return DefShuffle(pcol);


	case msgcAnimate:
		return fFalse;

	case msgcZip:
		return DefZip(pcol);
		}

	Assert(fFalse);
    return fFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\col.h ===
/* COLumn CLaSs struct */
typedef struct _colcls
{
    INT tcls;                   /* class type  */
    INT (FAR *lpfnColProc)();
    INT ccolDep;                /* # of dependent columns */
    DX  dxUp;                   /* up card offsets */
    DY  dyUp;
    DX  dxDn;                   /* down card offsets */
    DY  dyDn;
    INT dcrdUp;                 /* up # of cards between ofsetting */
    INT dcrdDn;                 /* down # of cards between ofsetting */
} COLCLS;


/* MOVE struct, only set up while dragging */
typedef struct _move
{
    INT     icrdSel;          /* current card sel */
    INT     ccrdSel;          /* # of cards selected */
    DEL     delHit;           /* negative of offset from card where mouse hit */
    BOOL    fHdc;             /* TRUE if hdc's are allocated */
    DY      dyCol;            /* height of col (BUG: can only drag vert cols) */
    HDC     hdcScreen;

    HDC     hdcCol;           /*  the column */
    HBITMAP hbmColOld;        /* original hbm in hdcCol */

    HDC     hdcScreenSave;    /* save buffer for screen */
    HBITMAP hbmScreenSaveOld; /* original hbm in hdcScreenSave */
    
    HDC     hdcT;
    HBITMAP hbmT;
    INT     izip;
} MOVE;




/* COL struct, this is what a column o' cards is */
typedef struct _col
{
    COLCLS *pcolcls;          /* class of this instance */
    INT (FAR *lpfnColProc)(); /* duplicate of fn in colcls struct (for efficiency) */
    RC rc;                    /* bounding rectangle of this col */
    MOVE *pmove;              /* move info, only valid while draggin */
    INT icrdMac;                
    INT icrdMax;
    CRD rgcrd[1];
} COL;

/* SCOre */
typedef INT SCO;

// Constants - earlier they were generated in the col.msg file.

#define icolNil             -1
#define msgcNil             0		  
#define msgcInit            1		  
#define msgcEnd             2		  
#define msgcClearCol        3	   
#define msgcNumCards        4     
#define msgcHit             5		  
#define msgcSel             6		  
#define msgcEndSel          7	  
#define msgcFlip            8		  
#define msgcInvert          9	  
#define msgcMouseUp         10	  
#define msgcDblClk          11	  
#define msgcRemove          12	  
#define msgcInsert          13	  
#define msgcMove            14		  
#define msgcCopy            15		  
#define msgcValidMove       16  
#define msgcValidMovePt     17  
#define msgcRender          18	  
#define msgcPaint           19		  
#define msgcDrawOutline     20  
#define msgcComputeCrdPos   21
#define msgcDragInvert      22  
#define msgcGetPtInCrd      23  
#define msgcValidKbdColSel  24
#define msgcValidKbdCrdSel  25
#define msgcShuffle         26
#define msgcAnimate         27
#define msgcZip             28



#ifdef DEBUG
INT SendColMsg(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
#else
#define SendColMsg(pcol, msgc, wp1, wp2) \
    (*((pcol)->lpfnColProc))((pcol), (msgc), (wp1), (wp2))    
#endif
INT DefColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
VOID OOM( VOID );
VOID DrawOutline( PT *, INT, DX, DY );

/*---------------------------------------------------------------------------
     --------------------> Message explanations <---------------------

    // WARNING: probably totally out-o-date

msgcNil:
    Nil Message, not used 
    wp1:         N/A
    wp2:        N/A
    returns:    TRUE

msgcInit:
    Sent when a column in created.  (currently not used)
    wp1:        N/A
    wp2:       N/A
    returns    TRUE

msgcEnd:
    Sent when a column is destroyed.  Frees pcol
    wp1:        N/A
    wp2:       N/A
    returns     TRUE
    
msgcClearCol:
    Sent to clear a column of it's cards
    wp1:        N/A
    wp2:       N/A
    returns     TRUE

msgcHit:
    Checks if a card is hit by the mouse.  pcol->delHit is set to the
    point where the mouse hit the card relative to the upper right
    corner of the card.  Sets pcol->icrdSel and pcol->ccrdSel
    wp1:        ppt
    wp2:        N/A
    returns: icrd if hit, icrdNil if no hit.  May return icrdEmpty if hit
                an empty column

msgcSel:
    Selects cards in the column for future moves.  Sets pcol->icrdSel and
    pcol->ccrdSel;
    wp1:        icrdFirst, first card to select; icrdEnd selects last card
    wp2:        ccrdSel, # of cards to select; ccrdToEnd selects to end of col
    returns:    TRUE/FALSE

msgcFlip:
    Flips cards to fUp
    wp1:        fUp, TRUE if to flip cards up, FALSE to flip down
    wp2:        N/A
    returns:    TRUE/FALSE

msgcInvert:
    Inverts order of cards selected in pcol
    Often used for dealing to discard.
    wp1:        N/A
    wp2:        N/A
    returns: TRUE/FALSE

msgcRemove:
    Removes cards from pcol and places them in pcolTemp (wp1)
    pcolTemp must be larger than the number of cards selected
    wp1:        pcolTemp, must be of class tcls == tclsTemp
    wp2:        N/A
    returns:    TRUE/FALSE

msgcInsert:
    Inserts all cards from pcolSrc into pcol at icrdInsAfter (wp2)  
    pcol must be large enough to accomodate the cards.
    wp1:        pcolTemp, must be of class tcls == tclsTemp
    wp2:        icrdInsAfter, card to insert after.  icrdToEnd if append to end of col
    returns:    TRUE/FALSE

msgcMove:
    Combines msgcRemove, msgcInsert, and rendering.
    Moves cards from pcolSrc into pcolDest at icrdInsAfter.  Computes new
    card positions and sends render messages to both columns
    wp1:        pcolSrc
    wp2:        icrdInsAfter, card to insert after. may be '|'ed with flags:
                    icrdInvert : Inverts order of cards
    returns:    TRUE/FALSE

msgcCopy:
    Copies pcolSrc into pcol.  pcol must be large enough
    wp1:        pcolSrc
    wp2:        fAll,  If true then entire structure is copied, else just the cards
    returns:    TRUE/FALSE

msgcValidMove:  ***** MUST BE SUPPLIED BY GAME, NO DEFAULT ACTION ******
    Determines if a move is valid.
    wp1:        pcolSrc
    wp2:        N/A
    returns:    TRUE/FALSE


msgcValidMovePt:
    Determines if a card being dragged over a column is a valid move.
    Sends msgcValidMove if card overlaps
    wp1:        pcolSrc
    wp2:        pptMouse
    returns:    icrdHit/icrdNil

msgcRender
    Renders the column starting at icrdFirst
    wp1:        icrdFirst
    wp2:        N/A
    return:    TRUE/FALSE

msgcPaint:
    Renders column if it intersects the paint update rect
    wp1:        ppaint, if NULL then renders entire column
    wp2:        N/A
    returns: TRUE/FALSE


msgcDrawOutline:
    Draws outline of cards when being dragged by mouse
    wp1:        pptMouse
    wp2:        N/A
    returns: TRUE/FALSE

msgcComputeCrdPos:
    Computes position of cards based on colcls.{dxcrdUp|dxcrdDn|dycrdUp|dycrdDn}
    wp1:        icrdFirst, first card to compute
    wp2:        N/A
    returns:    TRUE

msgcDragInvert:
    Inverts the topmost card in the pile
    wp1:        N/A
    wp2:        N/A
    returns: TRUE/FALSE

-----------------------------------------------------------------------------*/




#define icrdNil       0x1fff
#define icrdEmpty     0x1ffe

#define icrdToEnd     0x1ffd
#define ccrdToEnd     -2

#define icrdEnd       0x1ffc


/* special flags |'d with icrd for msgcMove */
#define bitFZip       0x2000
#define icrdMask      0x1fff
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\cards.c ===
#include "sol.h"
#ifndef DLL
VSZASSERT
#else
#ifdef DEBUG
#undef Assert
#define Assert(f) { if (!(f)) { ExitWindows(0L); } }
#endif
#endif


#define COOLCARD


#ifdef COOLCARD
void SaveCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy);
void RestoreCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy);
#endif

VOID APIENTRY cdtTerm(VOID);
VOID MyDeleteHbm(HBITMAP hbm);
static HBITMAP HbmFromCd(INT, HDC);
static BOOL FLoadBack(INT);


// we removed the older card decks that required Animation. The new
// card deck doesn't involve any animation.


#ifdef UNUSEDCODE

typedef struct
        {
        INT id;
        DX  dx;
        DY       dy;
        } SPR;

#define isprMax 4

typedef struct
        {
        INT cdBase;
        DX dxspr;
        DY dyspr;
        INT isprMac;
        SPR rgspr[isprMax];
        } ANI;

#define ianiMax 4
static ANI rgani[ianiMax] =
        { IDFACEDOWN12, 32, 22, 4,
                {IDASLIME1, 32, 32,
                 IDASLIME2, 32, 32,
                 IDASLIME1, 32, 32,
                 IDFACEDOWN12, 32, 32
                },
          IDFACEDOWN10, 36, 12, 2,
                {IDAKASTL1, 42, 12,
                 IDFACEDOWN10, 42, 12,
                 0, 0, 0,
                 0, 0, 0
                },
          IDFACEDOWN11, 14, 12, 4,
                {
                IDAFLIPE1, 47, 1,
                IDAFLIPE2, 47, 1,
                IDAFLIPE1, 47, 1,
                IDFACEDOWN11, 47, 1
                },
          IDFACEDOWN3, 24, 7, 4,
                {
                IDABROBOT1, 24, 40,
                IDABROBOT2, 24, 40,
                IDABROBOT1, 24, 40,
                IDFACEDOWN3, 24, 40
                }
        /* remember to inc ianiMax */
        };

#endif

static HBITMAP  hbmCard[52] =
        {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
         NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
         NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
         NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

static HBITMAP hbmGhost = NULL;
static HBITMAP hbmBack = NULL;
static HBITMAP hbmDeckX = NULL;
static HBITMAP hbmDeckO = NULL;
static INT idback = 0;
static INT dxCard, dyCard;
static INT cInits = 0;


#ifdef DLL
HANDLE hinstApp;
#else
extern HANDLE  hinstApp;
#endif

BOOL APIENTRY cdtInit(INT FAR *pdxCard, INT FAR *pdyCard)
/*
 * Parameters:
 *      pdxCard, pdyCard
 *                      Far pointers to ints where card size will be placed
 *
 * Returns:
 *      True when successful, False when it can't find one of the standard
 *      bitmaps.
 */
        {

        BITMAP bmCard;
        HDC hdc = NULL;
        HBITMAP hbmDstBitmap;
        HANDLE hDstOld;
        HANDLE hSrcOld;
        HDC hdcDstMemory;
        HDC hdcSrcMemory;

#ifdef DLL
        if (cInits++ != 0)
                {
                *pdxCard = dxCard;
                *pdyCard = dyCard;
                return fTrue;
                }
#endif

        hbmGhost = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDGHOST));
        hbmDeckX = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDX));
        hbmDeckO = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDO));
        if(hbmGhost == NULL || hbmDeckX == NULL || hbmDeckO == NULL) {
                goto Fail;
        }

        GetObject( hbmGhost, sizeof( BITMAP), (LPSTR)&bmCard);
        dxCard = *pdxCard = bmCard.bmWidth;
        dyCard = *pdyCard = bmCard.bmHeight;

        //
        // Create two compatible memory DCs for bitmap conversion.
        //

        hdc = GetDC(NULL);
        hdcSrcMemory = CreateCompatibleDC(hdc);
        hdcDstMemory = CreateCompatibleDC(hdc);
        if ((hdcSrcMemory == NULL) || (hdcDstMemory == NULL)) {
            goto Fail;
        }

        //
        // Create a compatible bitmap for the conversion of the Ghost
        // bitmap, blt the loaded bitmap to the compatible bitmap, and
        // delete the original bitmap.
        //

        hbmDstBitmap = CreateCompatibleBitmap(hdc, dxCard, dyCard);
        if (hbmDstBitmap == NULL) {
            goto Fail;
        }

        hSrcOld = SelectObject(hdcSrcMemory, hbmGhost);
        hDstOld = SelectObject(hdcDstMemory, hbmDstBitmap);
        BitBlt(hdcDstMemory, 0, 0, dxCard, dyCard, hdcSrcMemory, 0, 0, SRCCOPY);
        SelectObject(hdcSrcMemory, hSrcOld);
        SelectObject(hdcDstMemory, hDstOld);
        DeleteObject(hbmGhost);
        hbmGhost = hbmDstBitmap;

        //
        // Create a compatible bitmap for the conversion of the DeckX
        // bitmap, blt the loaded bitmap to the compatible bitmap, and
        // delete the original bitmap.
        //

        hbmDstBitmap = CreateCompatibleBitmap(hdc, dxCard, dyCard);
        if (hbmDstBitmap == NULL) {
            goto Fail;
        }

        hSrcOld = SelectObject(hdcSrcMemory, hbmDeckX);
        hDstOld = SelectObject(hdcDstMemory, hbmDstBitmap);
        BitBlt(hdcDstMemory, 0, 0, dxCard, dyCard, hdcSrcMemory, 0, 0, SRCCOPY);
        SelectObject(hdcSrcMemory, hSrcOld);
        SelectObject(hdcDstMemory, hDstOld);
        DeleteObject(hbmDeckX);
        hbmDeckX = hbmDstBitmap;

        //
        // Create a compatible bitmap for the conversion of the DeckO
        // bitmap, blt the loaded bitmap to the compatible bitmap, and
        // delete the original bitmap.
        //

        hbmDstBitmap = CreateCompatibleBitmap(hdc, dxCard, dyCard);
        if (hbmDstBitmap == NULL) {
        }

        hSrcOld = SelectObject(hdcSrcMemory, hbmDeckO);
        hDstOld = SelectObject(hdcDstMemory, hbmDstBitmap);
        BitBlt(hdcDstMemory, 0, 0, dxCard, dyCard, hdcSrcMemory, 0, 0, SRCCOPY);
        SelectObject(hdcSrcMemory, hSrcOld);
        SelectObject(hdcDstMemory, hDstOld);
        DeleteObject(hbmDeckO);
        hbmDeckO = hbmDstBitmap;

        //
        // Delete the compatible DCs.
        //

        DeleteDC(hdcDstMemory);
        DeleteDC(hdcSrcMemory);
        ReleaseDC(NULL, hdc);
        return fTrue;

Fail:
        if (hdc != NULL) {
            ReleaseDC(NULL, hdc);
        }

        cdtTerm();
        return fFalse;
        }




BOOL APIENTRY cdtDrawExt(HDC hdc, INT x, INT y, INT dx, INT dy, INT cd, INT mode, DWORD rgbBgnd)
/*
 * Parameters:
 *      hdc     HDC to window to draw cards on
 *      x, y    Where you'd like them
 * dx,dy card extents
 *      cd              Card to be drawn
 *      mode    Way you want it drawn
 *
 * Returns:
 *      True if card successfully drawn, False otherwise
 */
{

        HBITMAP  hbmSav;
        HDC      hdcMemory;
        DWORD    dwRop;
        HBRUSH   hbr;
#ifdef COOLCARD
        LONG     rgRGB[12];
#endif

        Assert(hdc != NULL);
                switch (mode)
                        {
                default:
                        Assert(fFalse);
                        break;
                case FACEUP:
                        hbmSav = HbmFromCd(cd, hdc);
                        dwRop = SRCCOPY;
                        break;
                case FACEDOWN:
                        if(!FLoadBack(cd))
                                return fFalse;
                        hbmSav = hbmBack;
                        dwRop = SRCCOPY;
                        break;
                case REMOVE:
                case GHOST:
                        hbr = CreateSolidBrush( rgbBgnd);
                        if(hbr == NULL)
                                return fFalse;

                        MUnrealizeObject( hbr);
                        if((hbr = SelectObject( hdc, hbr)) != NULL)
                                {
                        PatBlt(hdc, x, y, dx, dy, PATCOPY);
                                hbr = SelectObject( hdc, hbr);
                                }
                        DeleteObject( hbr);
                        if(mode == REMOVE)
                                return fTrue;
                        Assert(mode == GHOST);
                        /* default: fall thru */

                case INVISIBLEGHOST:
                        hbmSav = hbmGhost;
                        dwRop = SRCAND;
                        break;

                case DECKX:
                        hbmSav = hbmDeckX;
                        dwRop = SRCCOPY;
                        break;
                case DECKO:
                        hbmSav = hbmDeckO;
                        dwRop = SRCCOPY;
                        break;

                case HILITE:
                        hbmSav = HbmFromCd(cd, hdc);
                        dwRop = NOTSRCCOPY;
                        break;
                        }
        if (hbmSav == NULL)
                return fFalse;
        else
                {
        hdcMemory = CreateCompatibleDC( hdc);
                if(hdcMemory == NULL)
                        return fFalse;

                if((hbmSav = SelectObject( hdcMemory, hbmSav)) != NULL)
                        {
#ifdef COOLCARD
                        if( !fKlondWinner )
							SaveCorners(hdc, rgRGB, x, y, dx, dy);
#endif
                        if(dx != dxCard || dy != dyCard)
                                StretchBlt(hdc, x, y, dx, dy, hdcMemory, 0, 0, dxCard, dyCard, dwRop);
                        else
                                BitBlt( hdc, x, y, dxCard, dyCard, hdcMemory, 0, 0, dwRop);

                SelectObject( hdcMemory, hbmSav);
                        /* draw the border for the red cards */
                        if(mode == FACEUP)
                                {
                                INT icd;

                                icd = RaFromCd(cd) % 13 + SuFromCd(cd) * 13+1;
                                if((icd >= IDADIAMONDS && icd <= IDTDIAMONDS) ||
                                        (icd >= IDAHEARTS && icd <= IDTHEARTS))
                                        {
                                        PatBlt(hdc, x+2, y, dx-4, 1, BLACKNESS);  /* top */
                                        PatBlt(hdc, x+dx-1, y+2, 1, dy-4, BLACKNESS); /* right */
                                        PatBlt(hdc, x+2, y+dy-1, dx-4, 1, BLACKNESS); /* bottom */
                                        PatBlt(hdc, x, y+2, 1, dy-4, BLACKNESS); /* left */
                                        SetPixel(hdc, x+1, y+1, 0L); /* top left */
                                        SetPixel(hdc, x+dx-2, y+1, 0L); /*  top right */
                                        SetPixel(hdc, x+dx-2, y+dy-2, 0L); /* bot right */
                                        SetPixel(hdc, x+1, y+dy-2, 0L); /* bot left */
                                        }
                                }
#ifdef COOLCARD
                        if( !fKlondWinner )
							RestoreCorners(hdc, rgRGB, x, y, dx, dy);
#endif
                        }
        DeleteDC( hdcMemory);
                return fTrue;
                }
        }






BOOL APIENTRY cdtDraw(HDC hdc, INT x, INT y, INT cd, INT mode, DWORD rgbBgnd)
/*
 * Parameters:
 *      hdc             HDC to window to draw cards on
 *      x, y    Where you'd like them
 *      cd              Card to be drawn
 *      mode    Way you want it drawn
 *
 * Returns:
 *      True if card successfully drawn, False otherwise
 */
        {

        return cdtDrawExt(hdc, x, y, dxCard, dyCard, cd, mode, rgbBgnd);
        }


#ifdef COOLCARD

void SaveCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy)
        {
        if(dx != dxCard || dy != dyCard)
                return;

        /* Upper Left */
        rgRGB[0] = GetPixel(hdc, x, y);
        rgRGB[1] = GetPixel(hdc, x+1, y);
        rgRGB[2] = GetPixel(hdc, x, y+1);

        /* Upper Right */
        x += dx -1;
        rgRGB[3] = GetPixel(hdc, x, y);
        rgRGB[4] = GetPixel(hdc, x-1, y);
        rgRGB[5] = GetPixel(hdc, x, y+1);

        /* Lower Right */
        y += dy-1;
        rgRGB[6] = GetPixel(hdc, x, y);
        rgRGB[7] = GetPixel(hdc, x, y-1);
        rgRGB[8] = GetPixel(hdc, x-1, y);

        /* Lower Left */
        x -= dx-1;
        rgRGB[9] = GetPixel(hdc, x, y);
        rgRGB[10] = GetPixel(hdc, x+1, y);
        rgRGB[11] = GetPixel(hdc, x, y-1);

        }



void RestoreCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy)
        {
        if(dx != dxCard || dy != dyCard)
                return;

        /* Upper Left */
        SetPixel(hdc, x, y, rgRGB[0]);
        SetPixel(hdc, x+1, y, rgRGB[1]);
        SetPixel(hdc, x, y+1, rgRGB[2]);

        /* Upper Right */
        x += dx-1;
        SetPixel(hdc, x, y, rgRGB[3]);
        SetPixel(hdc, x-1, y, rgRGB[4]);
        SetPixel(hdc, x, y+1, rgRGB[5]);

        /* Lower Right */
        y += dy-1;
        SetPixel(hdc, x, y, rgRGB[6]);
        SetPixel(hdc, x, y-1, rgRGB[7]);
        SetPixel(hdc, x-1, y, rgRGB[8]);

        /* Lower Left */
        x -= dx-1;
        SetPixel(hdc, x, y, rgRGB[9]);
        SetPixel(hdc, x+1, y, rgRGB[10]);
        SetPixel(hdc, x, y-1, rgRGB[11]);
        }
#endif






BOOL APIENTRY cdtAnimate(HDC hdc, INT cd, INT x, INT y, INT ispr)
        {
        INT iani;
        ANI *pani;
        SPR *pspr;
        HBITMAP hbm;
        HDC hdcMem;
        X xSrc;
        Y ySrc;

        if(ispr < 0)
                return fFalse;
        Assert(hdc != NULL);
        for(iani = 0; iani < ianiMax; iani++)
                {
                if(cd == rgani[iani].cdBase)
                        {
                        pani = &rgani[iani];
                        if(ispr < pani->isprMac)
                                {
                                pspr = &pani->rgspr[ispr];
                                Assert(pspr->id != 0);
                                if(pspr->id == cd)
                                        {
                                        xSrc = pspr->dx;
                                        ySrc = pspr->dy;
                                        }
                                else
                                        xSrc = ySrc = 0;

                                hbm = LoadBitmap(hinstApp, MAKEINTRESOURCE(pspr->id));
                                if(hbm == NULL)
                                        return fFalse;

                        hdcMem = CreateCompatibleDC(hdc);
                                if(hdcMem == NULL)
                                        {
                                        DeleteObject(hbm);
                                        return fFalse;
                                        }

                                if((hbm = SelectObject(hdcMem, hbm)) != NULL)
                                        {
                                        BitBlt(hdc, x+pspr->dx, y+pspr->dy, pani->dxspr, pani->dyspr,
                                                hdcMem, xSrc, ySrc, SRCCOPY);
                                        DeleteObject(SelectObject(hdcMem, hbm));
                                        }
                                DeleteDC(hdcMem);
                                return fTrue;
                                }
                        }
                }
        return fFalse;
        }



/* loads global bitmap hbmBack */
BOOL FLoadBack(INT idbackNew)
        {

        Assert(FInRange(idbackNew, IDFACEDOWNFIRST, IDFACEDOWNLAST));

        if(idback != idbackNew)
                {
                MyDeleteHbm(hbmBack);
                if((hbmBack = LoadBitmap(hinstApp, MAKEINTRESOURCE(idbackNew))) != NULL)
                        idback = idbackNew;
                else
                        idback = 0;
                }
        return idback != 0;
        }



static HBITMAP HbmFromCd(INT cd, HDC hdc)

{

    INT icd;
    HBITMAP hbmDstBitmap;
    HANDLE hDstOld;
    HANDLE hSrcOld;
    HDC hdcDstMemory;
    HDC hdcSrcMemory;

    if (hbmCard[cd] == NULL) {
        icd = RaFromCd(cd) % 13 + SuFromCd(cd) * 13;
        if ((hbmCard[cd] = LoadBitmap(hinstApp,MAKEINTRESOURCE(icd+1))) == NULL) {
            return NULL;
        }

        //
        // Create two compatible memory DCs for bitmap conversion.
        //

        hdcSrcMemory = CreateCompatibleDC(hdc);
        hdcDstMemory = CreateCompatibleDC(hdc);
        if ((hdcSrcMemory == NULL) || (hdcDstMemory == NULL)) {
            goto Finish;
        }

        //
        // Create a compatible bitmap for the conversion of the card
        // bitmap, blt the loaded bitmap to the compatible bitmap, and
        // delete the original bitmap.
        //

        hbmDstBitmap = CreateCompatibleBitmap(hdc, dxCard, dyCard);
        if (hbmDstBitmap == NULL) {
            goto Finish;
        }

        hSrcOld = SelectObject(hdcSrcMemory, hbmCard[cd]);
        hDstOld = SelectObject(hdcDstMemory, hbmDstBitmap);
        BitBlt(hdcDstMemory, 0, 0, dxCard, dyCard, hdcSrcMemory, 0, 0, SRCCOPY);
        SelectObject(hdcSrcMemory, hSrcOld);
        SelectObject(hdcDstMemory, hDstOld);
        DeleteObject(hbmCard[cd]);
        hbmCard[cd] = hbmDstBitmap;

        //
        // Delete the compatible DCs.
        //

        DeleteDC(hdcDstMemory);
        DeleteDC(hdcSrcMemory);
    }

Finish:
    return hbmCard[cd];
}


VOID MyDeleteHbm(HBITMAP hbm)
        {
        if(hbm != NULL)
                DeleteObject(hbm);
        }

VOID APIENTRY cdtTerm()
/*
 * Free up space if it's time to do so.
 *
 * Parameters:
 *      none
 *
 * Returns:
 *      nothing
 */
        {
        INT     i;
#ifdef DLL
        if (--cInits > 0) return;
#endif

        for (i = 0; i < 52; i++) {
            MyDeleteHbm(hbmCard[i]);
            hbmCard[i] = NULL;
        }

        MyDeleteHbm(hbmGhost);
        MyDeleteHbm(hbmBack);
        MyDeleteHbm(hbmDeckX);
        MyDeleteHbm(hbmDeckO);
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\crd.h ===
#include "cdt.h"


typedef INT CD;

/* CaRD struct, this is what a card be */
typedef struct _crd
	{
	WORD cd  : 15;		/* card # (1..52) */
	WORD fUp : 1;		/* is this card up/down */
	PT pt;					/* upper-left corner of card */
	} CRD;




/* WARNING: Order of su's is assumed */
#define suClub 0
#define suDiamond 1
#define suHeart 2
#define suSpade 3
#define suMax 4
#define suFirst suClub

#define raAce 0
#define raDeuce 1
#define raTres 2
#define raFour 3
#define raFive 4
#define raSix 5
#define raSeven 6
#define raEight 7
#define raNine 8
#define raTen 9
#define raJack 10
#define raQueen 11
#define raKing 12
#define raMax 13
#define raNil 15
#define raFirst raAce

typedef INT RA;
typedef INT SU;

#define cdNil 0x3c


#define cIDFACEDOWN (IDFACEDOWNLAST-IDFACEDOWNFIRST+1)

#define SuFromCd(cd) ((cd)&0x03)
#define RaFromCd(cd) ((cd)>>2)
#define Cd(ra, su) (((ra)<<2)|(su))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\debug.h ===
#include <stdlib.h>

typedef struct
	{
	VOID *pgmcol;
	WORD lvl;
	INT msg;
	WPARAM wp1;
	LPARAM wp2;
	LRESULT wResult;
	} MDBG;



#define imdbgMax 500

VOID PrintCardMacs( GM * );
BOOL FSetGameNo( VOID );
VOID InitDebug( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\game.c ===
#include "sol.h"
VSZASSERT




VOID FreeGm(GM *pgm)
{
    INT icol;
    COL *pcol;

    if(pgm != NULL)
    {
        for(icol = pgm->icolMac-1; icol >= 0; icol--)
            if((pcol = pgm->rgpcol[icol]) != NULL)
                SendColMsg(pcol, msgcEnd, 0, 0);
        if(pgm == pgmCur)
            pgmCur = NULL;
        FreeUndo(&pgm->udr);
        FreeP(pgm);
    }
}


BOOL FCreateDCBM(HDC hdc, HDC *phdc, HBITMAP *phbmOld, DY dyCol)
{
    HDC hdcT;
    HBITMAP hbm;

    if((hdcT = CreateCompatibleDC(hdc)) == NULL)
        return fFalse;

    if((hbm = CreateCompatibleBitmap(hdc, dxCrd, dyCol)) == NULL)
    {
        Error:
        DeleteDC(hdcT);
        return fFalse;
    }

    if((*phbmOld = SelectObject(hdcT, hbm)) == NULL)
    {
        /* Delete the bitmap */
        DeleteObject(hbm);
        goto Error;
    }
    *phdc = hdcT;

    return fTrue;
}


BOOL FSetDrag(BOOL fOutline)
    {
    HDC hdc;

    fOutlineDrag = fOutline;

    if(fOutline && move.fHdc)
    {
        Assert(move.hdcScreenSave);
        Assert(move.hdcCol);
        Assert(move.hbmScreenSaveOld);
        Assert(move.hbmColOld);
        Assert(move.hdcT);

        DeleteObject(SelectObject(move.hdcCol, move.hbmColOld));
        DeleteDC(move.hdcCol);

        DeleteObject(SelectObject(move.hdcScreenSave, move.hbmScreenSaveOld));
        DeleteDC(move.hdcScreenSave);

        DeleteObject(SelectObject(move.hdcT, move.hbmT));
        DeleteDC(move.hdcT);
        move.fHdc = fFalse;
    }


    if(!fOutline && !move.fHdc)
    {
        hdc = GetDC(hwndApp);
        if(hdc == NULL)
        {
            OOM:
            ErrorIds(idsNoFullDrag);
            fOutlineDrag = fFalse;
            move.fHdc = fFalse;
            return fFalse;
        }

        move.hdcScreen = NULL;

        if(!FCreateDCBM(hdc, &move.hdcScreenSave, &move.hbmScreenSaveOld, pgmCur->dyDragMax))
        {
            ReleaseDC(hwndApp,hdc);
            goto OOM;
        }

        if(!FCreateDCBM(hdc, &move.hdcT, &move.hbmT, pgmCur->dyDragMax))
        {
            OOM1:

            ReleaseDC(hwndApp,hdc);
            DeleteObject(SelectObject(move.hdcScreenSave, move.hbmScreenSaveOld));
            DeleteDC(move.hdcScreenSave);
            goto OOM;
        }

        if(!FCreateDCBM(hdc, &move.hdcCol, &move.hbmColOld, pgmCur->dyDragMax))
        {
            DeleteObject(SelectObject(move.hdcT, move.hbmT));
            DeleteDC(move.hdcT);
            goto OOM1;
        }

        move.fHdc = fTrue;
        ReleaseDC(hwndApp, hdc);
    }
    return fTrue;
}




BOOL FInitGm()
{
    BOOL FInitKlondGm();

    return FInitKlondGm();
}


#ifdef DEBUG
LRESULT SendGmMsg(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2)
{
    INT imdbg;
    LRESULT wResult;

    Assert(pgm != NULL);
    imdbg = ILogMsg(pgm, msgg, wp1, wp2, fTrue);

    wResult =(*(pgm->lpfnGmProc))(pgm, msgg, wp1, wp2);
    LogMsgResult(imdbg, wResult);
    return wResult;
}

#endif


BOOL DefGmInit(GM *pgm, BOOL fResetScore)
{

    pgm->fDealt = fFalse;
    if(fResetScore)
        pgm->sco = 0;
    pgm->iqsecScore = 0;
    pgm->irep = 0;
    pgm->icolHilight = pgm->icolSel = icolNil;
    pgm->icolKbd = 0;
    pgm->icrdKbd = 0;
    pgm->fInput = fFalse;
    pgm->fWon = fFalse;
    pgm->ccrdDeal = ccrdDeal;
    return fTrue;
}



BOOL DefGmMouseDown(GM *pgm, PT *ppt, INT icolFirst)
{
    INT icol;

    /* sel already in effect */
    if(FSelOfGm(pgm))
        return fFalse;
    if(!pgm->fDealt)
        return fFalse;
    pgm->fInput = fTrue;
    pgm->fButtonDown = fTrue;
    for(icol = icolFirst; icol < pgm->icolMac; icol++)
    {
        if(SendColMsg(pgm->rgpcol[icol], msgcHit, (INT_PTR) ppt, 0) != icrdNil)
        {
            pgm->icolSel = icol;
            pgm->ptMousePrev = ptNil;

            /* KLUDGE:  in col render, we redraw the column after a selection
               is made.  if the mouse isn't moved, no image of the selected
               card shows up.
            */
            if(!fOutlineDrag)
            {
                /* SendGmMsg(pgm, msggMouseMove, (INT_PTR) ppt, 0); */
                pgm->ptMousePrev = *ppt;
            }
            return fTrue;
        }
    }
    return fFalse;
}

BOOL DefGmMouseUp(GM *pgm, PT *pptBogus, BOOL fNoMove)
{
    COL *pcolSel, *pcolHilight;
    BOOL fResult = fFalse;

    pgm->fButtonDown = fFalse;
    if(FSelOfGm(pgm))
    {
        pcolSel = pgm->rgpcol[pgm->icolSel];
        if(FHilightOfGm(pgm))
        {
            pcolHilight = pgm->rgpcol[pgm->icolHilight];
            SendGmMsg(pgm, msggSaveUndo, pgm->icolHilight, pgm->icolSel);
            SendColMsg(pcolHilight, msgcDragInvert, 0, 0);
            if(fNoMove)
            {
                SendColMsg(pcolSel, msgcMouseUp, (INT_PTR) &pgm->ptMousePrev, fTrue);
                fResult = fTrue;
                goto Return;
            }
            SendColMsg(pcolSel, msgcMouseUp, (INT_PTR) &pgm->ptMousePrev, fFalse);
            fResult = SendColMsg(pcolHilight, msgcMove, (INT_PTR) pcolSel, icrdToEnd) &&
                SendGmMsg(pgm, msggScore, (INT_PTR) pcolHilight, (INT_PTR) pcolSel);
            pgm->icolHilight = icolNil;
            if(SendGmMsg(pgm, msggIsWinner, 0, 0))
                SendGmMsg(pgm, msggWinner, 0, 0);
        }
        else
            SendColMsg(pcolSel, msgcMouseUp, (INT_PTR) &pgm->ptMousePrev, fTrue);

        Return:
        SendColMsg(pcolSel, msgcEndSel, fFalse, 0);
        }
    pgm->icolSel = icolNil;
    return fResult;
}



BOOL DefGmMouseDblClk(GM *pgm, PT * ppt)
{
    INT icol;

    for(icol = 0; icol < pgm->icolMac; icol++)
        if(SendColMsg(pgm->rgpcol[icol], msgcDblClk, (INT_PTR) ppt, icol))
            return fTrue;
    return fFalse;
}



// This routine moves all the "playable" cards
// to the four suit stacks.
// It's invoked when the user right-clicks or
// presses Ctrl-A.


BOOL DefGmMouseRightClk(GM *pgm, PT * ppt)
{
    INT icol;
    CRD *pcrd;
    INT icolDest;
    COL *pcolDest;
    BOOL fResult;
    COL *pcol;
    INT  iContinue;

    fResult = fFalse;

    // Keep doing this as long as in every iteration
    // we move one card to the suit stack.
    do
    {
        iContinue = 0;
        for(icol = 0; icol < pgm->icolMac; icol++)
        {
            // We don't want to move cards from one suit stack
            // to another.
            if (icol >= icolFoundFirst && icol < icolFoundFirst+ccolFound)
                continue;

            // Now the column we have is one of the 7 columns
            // or the deck.
            pcol = pgm->rgpcol[icol];

            // If this column contains cards and the top one faces up
            if(pcol->icrdMac > 0 && (pcrd=&pcol->rgcrd[pcol->icrdMac-1])->fUp)
            {
                if(pcol->pmove == NULL)
                    SendColMsg(pcol, msgcSel, icrdEnd, ccrdToEnd);
                Assert(pcol->pmove != NULL);

                // Check if it can be moved to any of the suit stacks.
                for(icolDest = icolFoundFirst; icolDest < icolFoundFirst+ccolFound; icolDest++)
                {
                    pcolDest = pgmCur->rgpcol[icolDest];
                    if(SendColMsg(pcolDest, msgcValidMove, (INT_PTR)pcol, 0))
                    {
                        SendGmMsg(pgmCur, msggSaveUndo, icolDest, icol);
                        fResult = SendColMsg(pcolDest, msgcMove, (INT_PTR) pcol, icrdToEnd) &&
                        (fOutlineDrag || SendColMsg(pcol, msgcRender, pcol->icrdMac-1, icrdToEnd)) &&
                            SendGmMsg(pgmCur, msggScore, (INT_PTR) pcolDest, (INT_PTR) pcol);

                        iContinue ++;

                        if(SendGmMsg(pgmCur, msggIsWinner, 0, 0))
                            SendGmMsg(pgmCur, msggWinner, 0, 0);
                        break;
                    }
                }
            }

            SendColMsg(pcol, msgcEndSel, fFalse, 0);
        }
    } while (iContinue > 0);

    return fResult;
}





BOOL DefGmMouseMove(GM *pgm, PT *ppt)
{
    COL *pcol;
    INT icol;

    if(FSelOfGm(pgm))
    {
        Assert(pgm->icolSel < pgm->icolMac);
        /* draw new outline */
        pcol = pgm->rgpcol[pgm->icolSel];
        SendColMsg(pcol, msgcDrawOutline, (INT_PTR) ppt, (INT_PTR) &pgm->ptMousePrev);
        pgm->ptMousePrev = *ppt;
        for(icol = 0; icol < pgm->icolMac; icol++)
            if(SendColMsg(pgm->rgpcol[icol], msgcValidMovePt, (INT_PTR)pgm->rgpcol[pgm->icolSel], (INT_PTR) ppt) != icrdNil)
            {
                 if(icol != pgm->icolHilight)
                 {
                    if(FHilightOfGm(pgm))
                        SendColMsg(pgm->rgpcol[pgm->icolHilight], msgcDragInvert, 0, 0);
                     pgm->icolHilight = icol;
                     return SendColMsg(pgm->rgpcol[icol], msgcDragInvert, 0, 0);
                 }
                 else
                     return fTrue;
            }
        /* nothing to hilight */
        if(FHilightOfGm(pgm))
        {
            SendColMsg(pgm->rgpcol[pgm->icolHilight], msgcDragInvert, 0, 0);
            pgm->icolHilight = icolNil;
            return fTrue;
        }
    }
    return fFalse;
}


BOOL DefGmPaint(GM *pgm, PAINTSTRUCT *ppaint)
{
    INT icol;
    HDC hdc;

    hdc = HdcSet(ppaint->hdc, 0, 0);

    if(!pgm->fDealt)
        goto Return;
    for(icol = 0; icol < pgm->icolMac; icol++)
        SendColMsg(pgm->rgpcol[icol], msgcPaint, (INT_PTR) ppaint, 0);
Return:
    HdcSet(hdc, 0, 0);
    return fTrue;
}


BOOL DefGmUndo(GM *pgm)
{
    UDR *pudr;

    Assert(!FSelOfGm(pgm));
    pudr = &pgm->udr;
    if(!pudr->fAvail)
        return fFalse;
    Assert(pudr->icol1 != icolNil);
    Assert(pudr->icol2 != icolNil);

    Assert(pudr->icol1 < pgm->icolMax);
    Assert(pudr->icol2 < pgm->icolMax);

    pgm->sco  = pudr->sco;
    pgm->irep = pudr->irep;

    SendGmMsg(pgm, msggChangeScore, 0, 0);


    SendColMsg(pgm->rgpcol[pudr->icol1], msgcCopy, (INT_PTR) pudr->rgpcol[0], fTrue);
    SendColMsg(pgm->rgpcol[pudr->icol2], msgcCopy, (INT_PTR) pudr->rgpcol[1], fTrue);
    /* end any selectons if we had 'em */
    SendColMsg(pgm->rgpcol[pudr->icol1], msgcEndSel, 0, 0);
    SendColMsg(pgm->rgpcol[pudr->icol2], msgcEndSel, 0, 0);

    SendGmMsg(pgm, msggKillUndo, 0, 0);
    return fTrue;
}



/* in future: may want to alloc columns */
BOOL DefGmSaveUndo(GM *pgm, INT icol1, INT icol2)
{
    Assert(icol1 != icolNil);
    Assert(icol2 != icolNil);
    Assert(icol1 < pgm->icolMac);
    Assert(icol2 < pgm->icolMac);
    Assert(icol1 != icol2);

    /* should use msgcCopy, but undo colcls's may not be set correctly */
    bltb(pgm->rgpcol[icol1], pgm->udr.rgpcol[0], sizeof(COL)+(pgm->rgpcol[icol1]->icrdMac-1)*sizeof(CRD));
    bltb(pgm->rgpcol[icol2], pgm->udr.rgpcol[1], sizeof(COL)+(pgm->rgpcol[icol2]->icrdMac-1)*sizeof(CRD));
    pgm->udr.icol1  = icol1;
    pgm->udr.icol2  = icol2;
    pgm->udr.fAvail = fTrue;
    pgm->udr.sco    = pgm->sco;
    pgm->udr.irep   = pgm->irep;

    if(pgm->udr.fEndDeck)
    {
        pgm->udr.fEndDeck = FALSE;
        pgm->udr.irep--;
    }

    return fTrue;
}



#ifdef DEBUG
VOID DisplayKbdSel(GM *pgm)
{
    HDC hdc;
    TCHAR sz[20];
    INT cch;

    hdc = GetDC(hwndApp);
    PszCopy(TEXT("      "), sz);
    cch = CchDecodeInt(sz, pgm->icolKbd);
    TextOut(hdc, 0, 10, sz, 5);
    PszCopy(TEXT("      "), sz);
    cch = CchDecodeInt(sz, pgm->icrdKbd);
    TextOut(hdc, 0, 20, sz, 5);
    PszCopy(TEXT("      "), sz);
    cch = CchDecodeInt(sz, pgm->icolSel);
    TextOut(hdc, 0, 30, sz, 5);
    ReleaseDC(hwndApp, hdc);
}
#endif



VOID NewKbdColAbs(GM *pgm, INT icol)
{
    Assert(icol >= 0);
    Assert(icol < pgm->icolMac);

    if(!SendColMsg(pgm->rgpcol[icol], msgcValidKbdColSel, FSelOfGm(pgm), 0))
        /* beep? */
        return;

    pgm->icolKbd = icol;
    pgm->icrdKbd = SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcNumCards, fFalse, 0)-1;
    if(pgm->icrdKbd < 0)
        pgm->icrdKbd = 0;
}


VOID NewKbdCol(GM *pgm, INT dcol, BOOL fNextGroup)
{
    INT icolNew;

    icolNew = pgm->icolKbd;
    if(icolNew == icolNil)
        icolNew = 0;
    if(dcol != 0)
    {
        do
        {
            icolNew += dcol;
            if(icolNew < 0)
                icolNew = pgm->icolMac-1;
            else if(icolNew >= pgm->icolMac)
                icolNew = 0;

            /* only one col class and looped through all col's */
            if(icolNew == pgm->icolKbd)
                break;
        }
        while (!SendColMsg(pgm->rgpcol[icolNew], msgcValidKbdColSel, FSelOfGm(pgm), 0) ||
                (fNextGroup &&
                    pgm->rgpcol[icolNew]->pcolcls->tcls ==
                       pgm->rgpcol[pgm->icolKbd]->pcolcls->tcls));

    }

    NewKbdColAbs(pgm, icolNew);
}




VOID NewKbdCrd(GM *pgm, INT dcrd)
{
    INT icrdUpMac, icrdMac;
    INT icrdKbdNew;

    icrdUpMac = SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcNumCards, fTrue, 0);
    icrdMac = SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcNumCards, fFalse, 0);

    if(icrdMac == 0)
        icrdKbdNew = 0;
    else
    {
        if(icrdUpMac == 0)
            icrdKbdNew = icrdMac-1;
        else
            icrdKbdNew = PegRange(pgm->icrdKbd+dcrd, icrdMac-icrdUpMac, icrdMac-1);
    }
    if(SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcValidKbdCrdSel, icrdKbdNew, 0))
        pgm->icrdKbd = icrdKbdNew;
}





BOOL DefGmKeyHit(GM *pgm, INT vk)
{
    PT pt, ptCurs;
    COLCLS *pcolcls;

    /* cancel any mouse selections */

    switch(vk)
    {
    case VK_SPACE:
    case VK_RETURN:
        if(!FSelOfGm(pgm))
            {
            /* begin a selection */
            NewKbdCrd(pgm, 0);  /* !!! */
            SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcGetPtInCrd, pgm->icrdKbd, (INT_PTR) &pt);
            if(!SendGmMsg(pgm, msggMouseDown, (INT_PTR) &pt, 0))
                return fFalse;
            NewKbdCol(pgm, 0, fFalse);
            goto Display;
            }
        else
            {
            /* possibly make a move */
            SendGmMsg(pgm, msggMouseUp, 0, fFalse);
            NewKbdCol(pgm, 0, fFalse);
            return fTrue;
            }

    case VK_ESCAPE:
        SendGmMsg(pgm, msggMouseUp, 0, fTrue);
        return fTrue;

    case VK_A:
        if (GetKeyState(VK_CONTROL) < 0)
            SendGmMsg(pgm, msggMouseRightClk, 0, fTrue);
        return fTrue;

    case VK_LEFT:
        /* Should these be VK_CONTROL??? */
        NewKbdCol(pgm, -1, GetKeyState(VK_SHIFT) < 0);
        goto Display;

    case VK_RIGHT:
        NewKbdCol(pgm, 1, GetKeyState(VK_SHIFT) < 0);
        goto Display;

    case VK_UP:
        NewKbdCrd(pgm, -1);
        goto Display;

    case VK_DOWN:
        NewKbdCrd(pgm, 1);
        goto Display;

    case VK_HOME:
        NewKbdColAbs(pgm, 0);
        goto Display;

    case VK_END:
        NewKbdColAbs(pgm, pgm->icolMac-1);
        goto Display;

    case VK_TAB:
        NewKbdCol(pgm, GetKeyState(VK_SHIFT) < 0 ? -1 : 1, fTrue);
Display:
        SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcGetPtInCrd, pgm->icrdKbd, (INT_PTR) &pt);
        ptCurs = pt;
        ClientToScreen(hwndApp, (LPPOINT) &ptCurs);
        if(FSelOfGm(pgm))
        {
            if(SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcNumCards, fFalse, 0) > 0)
            {
                pcolcls = pgm->rgpcol[pgm->icolKbd]->pcolcls;
                ptCurs.y += pcolcls->dyUp;
                /* dxUp ? */
            }
        }

        /* SetCursorPos will cause WM_MOUSEMOVE to be sent */
        SetCursorPos(ptCurs.x, ptCurs.y);
        return fTrue;
    }
    return fFalse;
}



BOOL DefGmChangeScore(GM *pgm, INT cs, INT sco)
{

    if(smd == smdNone)
        return fTrue;
    switch(cs)
        {
    default:
        return fTrue;
    case csAbs:
        pgm->sco = sco;
        break;
    case csDel:
        pgm->sco += sco;
        break;
    case csDelPos:
        pgm->sco = WMax(pgm->sco+sco, 0);
        break;
        }
    StatUpdate();

    return fTrue;
}


BOOL DefGmWinner(GM *pgm)
{
    pgm->fWon = fFalse;
    if(FYesNoAlert(idsDealAgain))
        PostMessage(hwndApp, WM_COMMAND, idsInitiate, 0L);
    return fTrue;
}


INT DefGmProc(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2)
{

    switch(msgg)
    {
    case msggInit:
        return DefGmInit(pgm, (BOOL)wp1);
    case msggEnd:
        FreeGm(pgm);
        break;

    case msggKeyHit:
        return DefGmKeyHit(pgm, (INT)wp1);

    case msggMouseRightClk:
        return DefGmMouseRightClk(pgm, (PT *)wp1);

    case msggMouseDown: /* wp1 == ppt, wp2 = icolFirst (normally 0) */
        return DefGmMouseDown(pgm, (PT *)wp1, (INT)wp2);

    case msggMouseUp:
        return DefGmMouseUp(pgm, (PT *)wp1, (BOOL)wp2);

    case msggMouseMove:
        return DefGmMouseMove(pgm, (PT *)wp1);

    case msggMouseDblClk:
        return DefGmMouseDblClk(pgm, (PT *)wp1);

    case msggPaint:
        return DefGmPaint(pgm, (PAINTSTRUCT *)wp1);

    case msggDeal:
        Assert(fFalse);
        break;

    case msggUndo:
        return DefGmUndo(pgm);

    case msggSaveUndo:

        return DefGmSaveUndo(pgm, (INT)wp1, (INT)wp2);

    case msggKillUndo:
        /* in future may want to free columns */
        pgm->udr.fAvail = fFalse;
        break;
    case msggIsWinner:
        return fFalse;
    case msggWinner:
        return DefGmWinner(pgm);
    case msggForceWin:
        NYI();
        break;
    case msggTimer:
        return fFalse;
    case msggScore:
        return fTrue;
    case msggChangeScore:
        return DefGmChangeScore(pgm, (INT)wp1, (INT)wp2);

    }

    return fFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\debug.c ===
#include "sol.h"
#include <io.h>
#include <string.h>
#include "assert.h"
VSZASSERT

#ifdef DEBUG

MDBG rgmdbg[imdbgMax];
WORD lvl = 0;
INT imdbgCur = 0;


VOID InitDebug()
{
    INT imdbg;
    MDBG *pmdbg;

    for(imdbg = 0; imdbg < imdbgMax; imdbg++)
    {
        pmdbg = &rgmdbg[imdbg];
        pmdbg->pgmcol = NULL;
        pmdbg->lvl = 0;
        pmdbg->msg = 0xcccc;
        pmdbg->wp1 = 0xcccc;
        pmdbg->wp2 = 0xcccc;
        pmdbg->wResult = 0xcccc;
    }

    imdbgCur = 0;
    lvl = 0;
}



WORD ILogMsg(VOID *pgmcol, INT msg, WPARAM wp1, LPARAM wp2, BOOL fGm)
{
    MDBG *pmdbg;
    WORD imdbgRet;

    Assert(FInRange(imdbgCur, 0, imdbgMax-1));
    pmdbg = &rgmdbg[imdbgCur];

    Assert(fGm == 0 || fGm == 1);
    pmdbg->pgmcol = pgmcol;
    pmdbg->msg = msg + (fGm << 15);
    pmdbg->wp1 = wp1;
    pmdbg->wp2 = wp2;
    pmdbg->wResult = 0xcccc;
    pmdbg->lvl = lvl;
    lvl++;
    imdbgRet = imdbgCur++;
    imdbgCur %= imdbgMax;
    Assert(FInRange(imdbgCur, 0, imdbgMax-1));
    return imdbgRet;
}



VOID LogMsgResult(INT imdbg, LRESULT wResult)
{
    lvl--;

    Assert(FInRange(imdbg, 0, imdbgMax-1));
    rgmdbg[imdbg].wResult = wResult;
}

VOID WriteCrlf(INT fh)
{
    _write(fh, TEXT("\x0d\n"), sizeof(TCHAR) * 2);
}


VOID WriteSz(INT fh, TCHAR *sz)
{
    _write(fh, sz, lstrlen(sz));
    WriteCrlf(fh);
}

VOID WriteIField(INT fh, TCHAR *szField, INT_PTR ifld)
{
    TCHAR szBuf[128];
    INT cch;

    _write(fh, szField, lstrlen(szField));
    _write(fh, TEXT(" = "), sizeof(TCHAR) *3);
    cch = CchDecodeInt(szBuf, ifld);
    _write(fh, szBuf, cch);
    WriteCrlf(fh);
}




VOID DumpCol(INT fh, COL *pcol)
{
    INT icrd;
    MOVE *pmove;

    WriteCrlf(fh);
    WriteIField(fh, TEXT(">>> *pcol"), (INT_PTR) pcol);
    WriteIField(fh, TEXT("pcolcls->tcls"), pcol->pcolcls->tcls);
    WriteIField(fh, TEXT("icrdMac"), pcol->icrdMac);
    WriteIField(fh, TEXT("pmove"), (INT_PTR) pcol->pmove);
    if(pcol->pmove != NULL)
    {
        pmove = pcol->pmove;
        WriteIField(fh, TEXT("pmove->icrdSel"), pmove->icrdSel);
        WriteIField(fh, TEXT("pmove->ccrdSel"), pmove->ccrdSel);
        WriteIField(fh, TEXT("pmove->delHit.x"), pmove->delHit.dx);
        WriteIField(fh, TEXT("pmove->delHit.y"), pmove->delHit.dy);
        WriteIField(fh, TEXT("pmove->fHdc"), pmove->fHdc);
        WriteIField(fh, TEXT("pmove->dyCol"), pmove->dyCol);
        WriteIField(fh, TEXT("pmove->hdcScreen"), (INT_PTR)pmove->hdcScreen);

        WriteIField(fh, TEXT("pmove->hdcCol"), (INT_PTR)pmove->hdcCol);
        WriteIField(fh, TEXT("pmove->hbmColOld"), (INT_PTR)pmove->hbmColOld);

        WriteIField(fh, TEXT("pmove->hdcScreenSave"), (INT_PTR)pmove->hdcScreenSave);
        WriteIField(fh, TEXT("pmove->hbmScreenSaveOld"), (INT_PTR)pmove->hbmScreenSaveOld);

        WriteIField(fh, TEXT("pmove->hdcT"), (INT_PTR)pmove->hdcT);
        WriteIField(fh, TEXT("pmove->hbmT"), (INT_PTR)pmove->hbmT);
    }
    for(icrd = 0; icrd < pcol->icrdMac; icrd++)
    {
        WriteIField(fh, TEXT("\t-card "), icrd);
        WriteIField(fh, TEXT("\t    cd"), pcol->rgcrd[icrd].cd);
        WriteIField(fh, TEXT("\t   fUp"), pcol->rgcrd[icrd].fUp);
        WriteIField(fh, TEXT("\t  pt.x"), pcol->rgcrd[icrd].pt.x);
        WriteIField(fh, TEXT("\t  pt.y"), pcol->rgcrd[icrd].pt.y);
    }
}


VOID DumpGm(INT fh, GM *pgm)
{
    INT icol;

    WriteIField(fh, TEXT("pgm"), (INT_PTR) pgm);
    WriteIField(fh, TEXT("udr.fAvail"), pgm->udr.fAvail);
    WriteIField(fh, TEXT("udr.sco"), pgm->udr.sco);
    WriteIField(fh, TEXT("udr.icol1"), pgm->udr.icol1);
    WriteIField(fh, TEXT("udr.icol2"), pgm->udr.icol2);
    WriteIField(fh, TEXT("udr.rgpcol[1]"), (INT_PTR) pgm->udr.rgpcol[1]);
    WriteIField(fh, TEXT("udr.rgpcol[2]"), (INT_PTR) pgm->udr.rgpcol[2]);
    WriteIField(fh, TEXT("fDealt"), pgm->fDealt);
    WriteIField(fh, TEXT("fWon"), pgm->fWon);
    WriteIField(fh, TEXT("fInput"), pgm->fInput);
    WriteIField(fh, TEXT("sco"), pgm->sco);
    WriteIField(fh, TEXT("iqsecScore"), pgm->iqsecScore);
    WriteIField(fh, TEXT("dqsecScore"), pgm->dqsecScore);
    WriteIField(fh, TEXT("ccrdDeal"), pgm->ccrdDeal);
    WriteIField(fh, TEXT("irep"), pgm->irep);
    WriteIField(fh, TEXT("ptMousePrev->x"), pgm->ptMousePrev.x);
    WriteIField(fh, TEXT("ptMousePrev->y"), pgm->ptMousePrev.y);
    WriteIField(fh, TEXT("fButtonDown"), pgm->fButtonDown);
    WriteIField(fh, TEXT("icolKbd"), pgm->icolKbd);
    WriteIField(fh, TEXT("icrdKbd"), pgm->icrdKbd);
    WriteIField(fh, TEXT("icolSel"), pgm->icolSel);
    WriteIField(fh, TEXT("icolHilight"), pgm->icolHilight);
    WriteIField(fh, TEXT("icolMac"), pgm->icolMac);
    WriteIField(fh, TEXT("icolMax"), pgm->icolMax);
    for(icol = 0; icol < pgm->icolMac; icol++)
        DumpCol(fh, pgm->rgpcol[icol]);
}

TCHAR *PchDecodeWp(TCHAR *pch, INT_PTR wp)
{
    INT icol;

    if(pgmCur == NULL)
            return pch;
    if((GM *) wp == pgmCur)
            return PszCopy(TEXT("(pgmCur)"), pch);

    for(icol = 0; icol < pgmCur->icolMac; icol++)
    {
        if((struct _col *) wp == pgmCur->rgpcol[icol])
        {
            pch = PszCopy(TEXT("(col "), pch);
            pch += CchDecodeInt(pch, icol);
            *pch++ = TEXT(')');
            break;
        }
    }
    return pch;
}


VOID DumpRgmdbg(TCHAR *szFile, INT li)
{
    OFSTRUCT of;
    INT fh;
    INT imdbg;
    USHORT lvl;
    MDBG *pmdbg;
    TCHAR szBuf[128];
    TCHAR *pch;


    if((fh = (OpenFile("sol.dbg", &of, OF_CREATE|OF_WRITE))) == -1)
            return;

    WriteSz(fh, TEXT("Assertion Failure"));
    WriteIField(fh, szFile, li);
    WriteSz(fh, szVer);
    WriteIField(fh, TEXT("Game #"), igmCur);
    WriteCrlf(fh);



    /* write game and col structs */
    if(pgmCur != NULL)
            DumpGm(fh, pgmCur);

    imdbg = imdbgCur;
    do
    {
        Assert(FInRange(imdbgCur, 0, imdbgMax-1));
        pmdbg = &rgmdbg[imdbg];
        Assert(pmdbg->lvl < 60);
        for(lvl = 0; lvl < pmdbg->lvl; lvl++)
                _write(fh, TEXT("\t"), 1);
        pch = PchDecodeWp(szBuf, (INT_PTR) pmdbg->pgmcol);
        pmdbg->msg &= 0x7fff;
        *pch++ = TEXT(' ');
        pch += CchDecodeInt(pch, pmdbg->msg);
        *pch++ = TEXT(',');
        *pch++ = TEXT(' ');
        pch += CchDecodeInt(pch, pmdbg->wp1);
        pch = PchDecodeWp(pch, pmdbg->wp1);
        *pch++ = TEXT(',');
        *pch++ = TEXT(' ');
        pch += CchDecodeInt(pch, pmdbg->wp2);
        pch = PchDecodeWp(pch, pmdbg->wp2);
        *pch++ = TEXT(' ');
        *pch++ = TEXT('-');
        *pch++ = TEXT('>');
        *pch++ = TEXT(' ');
        pch += CchDecodeInt(pch, pmdbg->wResult);
        _write(fh, szBuf, (int)(pch-szBuf));
        WriteCrlf(fh);

        imdbg--;
        if(imdbg < 0)
            imdbg = imdbgMax-1;
        Assert(FInRange(imdbg, 0, imdbgMax-1));
    } while(imdbg != imdbgCur);

    _close(fh);
}





/* Puts msg on bottom of screen.  Useful because I don't have a debug console now */
VOID DisplayMsg(TCHAR *sz, INT msgc, INT wp1, INT wp2)
{

    INT y;
    INT x;
    HDC hdc;
    INT cch;
    TCHAR szInt[20];
    TEXTMETRIC tm;

    if(fScreenShots)
        return;

    x = 0;

    hdc = GetDC(hwndApp);
    GetTextMetrics(hdc, (LPTEXTMETRIC)&tm);
    y = 0;/*        dyScreen - tm.tmHeight; */

    TextOut(hdc, x, y, TEXT("                         "), 24);
    TextOut(hdc, x, y, sz, cch = lstrlen(sz));
    x += (cch+1) * tm.tmMaxCharWidth;

    cch = CchDecodeInt(szInt, msgc);
    TextOut(hdc, x, y, szInt, cch);
    x += (cch+1) * tm.tmAveCharWidth;

    cch = CchDecodeInt(szInt, wp1);
    TextOut(hdc, x, y, szInt, cch);
    x += (cch+1) * tm.tmAveCharWidth;

    cch = CchDecodeInt(szInt, wp2);
    TextOut(hdc, x, y, szInt, cch);
    x += (cch+1) * tm.tmAveCharWidth;

    ReleaseDC(hwndApp, hdc);
}

VOID PrintCardMacs(GM *pgm)
{
    INT icol;
    TCHAR sz[20];
    INT cch;
    HDC hdc;

    hdc = GetDC(hwndApp);
    for(icol = 0; icol < pgm->icolMac; icol++)
    {
        cch = CchDecodeInt(sz, pgm->rgpcol[icol]->icrdMac);
        TextOut(hdc, 30 * icol, 10, sz, cch);
    }
    ReleaseDC(hwndApp, hdc);
}



INT_PTR APIENTRY GameNo(HWND hdlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL fTranslated;
    INT igmNext;

    if (iMessage == WM_COMMAND)
    {
        if( GET_WM_COMMAND_ID( wParam, lParam ) == IDOK )
        {
            igmNext = GetDlgItemInt(hdlg, ideGameNoEdit, &fTranslated, fFalse);
            if(fTranslated && igmNext >= 0)
                igmCur = igmNext;
            else
            {
                Error(TEXT("Invalid game number"));
                return fFalse;
            }
        }
        if(wParam == IDOK || wParam == IDCANCEL)
            EndDialog(hdlg, wParam == IDOK);
        return fTrue;
    }
    else if (iMessage == WM_INITDIALOG)
    {
        SetDlgItemInt(hdlg, ideGameNoEdit, igmCur, fFalse);
        return fTrue;
    }
    else
        return fFalse;
}



BOOL FSetGameNo()
{
    BOOL fResult;

    if(fResult = (BOOL)DialogBox(hinstApp,
                                 MAKEINTRESOURCE(iddGameNo),
                                 hwndApp,
                                 GameNo))

        srand(igmCur);
    return fResult;
}






BOOL FValidCol(COL *pcol)
{
    INT icol;

    if(pcol == NULL)
        return fFalse;

    for(icol = 0; icol < pgmCur->icolMax; icol++)
    {
        if(pcol == pgmCur->rgpcol[icol])
        {
            if(pcol->pcolcls == NULL)
                return fFalse;
            if(pcol->icrdMac > pcol->icrdMax)
                return fFalse;

            return fTrue;
        }
    }
    return fFalse;
}


TCHAR *vszFile;
INT vli;

TCHAR vszLi[32];

INT_PTR APIENTRY AssertDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{

    switch(wm)
    {
        case WM_INITDIALOG:
            SetWindowText(GetDlgItem(hdlg, FILE), vszFile);
            CchDecodeInt(vszLi, vli);
            SetWindowText(GetDlgItem(hdlg, LINE), vszLi);
            CchDecodeInt(vszLi, igmCur);
            SetWindowText(GetDlgItem(hdlg, GAMENO), vszLi);
         /* SetWindowText(GetDlgItem(hdlg, SOLVERSION), szVer); */
            break;
        case WM_COMMAND:
            switch( GET_WM_COMMAND_ID( wParam, lParam ))
            {
                default:
                    return fFalse;
                case IDOK:
                    EndDialog(hdlg, 0);
                    break;
                case EXIT:
                    EndDialog(hdlg, 1);
                    break;
             }
            break;

        default:
                return fFalse;
    }

    return fTrue;
}


VOID AssertFailed(TCHAR *szFile, INT li)
{
    INT f;

    vszFile = szFile;
    vli = li;

    f = (INT)DialogBox(hinstApp,
                       MAKEINTRESOURCE(ASSERTFAILED),
                       hwndApp,
                       AssertDlgProc);


    DumpRgmdbg(szFile, li);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\klond.h ===
/* Klondike info */

/* Col classes  */
#define tclsDeck 1
#define tclsDiscard 2
#define tclsFound 3
#define tclsTab 4


/* indexes of columns */
#define icolDeck 			0
#define icolDiscard 		1
#define icolFoundFirst	2
#define ccolFound 		4
#define icolTabFirst	   6
#define ccolTab			7


/* BUG! this should be placed in a game descriptor table */
#define icrdDeckMax 52
#define icrdDiscardMax (icrdDeckMax-(1+2+3+4+5+6+7))
#define icrdFoundMax 13
#define icrdTabMax 19





/* Change Score notification codes */
/* WARNING: order is assumed by mpscdsco* in klond.c */
#define csKlondTime			0		/* decrement score with time */
#define csKlondDeckFlip		1		/* deck gone thru 1 or 3 times  */
#define csKlondFound		2		/* new card on foundation */
#define csKlondTab			3		/* card from Deck to tab */
#define csKlondTabFlip		4		/* exposure of new foundation card */
#define csKlondFoundTab		5		/* card from foundation to tab (- pts) */
#define csKlondDeal			6		/* cost of a deal */
#define csKlondWin			7		/* win bonus */

#define csKlondMax csKlondWin+1

VOID OOM( VOID );
VOID DrawCardExt( PT *, INT, INT );
BOOL APIENTRY cdtAnimate( HDC, INT, INT, INT, INT );
VOID NewKbdColAbs( GM *, INT );
BOOL FValidCol( COL * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\game.h ===
/* game stuff */

/* GaMe struct  */
typedef struct _gm
{
	LRESULT (FAR *lpfnGmProc)(GM, INT, WPARAM, LPARAM); /* our illustrious gameproc  */
	UDR  udr;          /* undo record  */
	BOOL fDealt;       /* TRUE if cards have been dealt  */
	BOOL fInput;       /* TRUE if input has been recieved after dealing */
	BOOL fWon;         /* TRUE if game is won (and in win sequence)  */
	INT  sco;          /* da sco  */
	INT  iqsecScore;   /* # of quarter seconds since first input  */
	INT  dqsecScore;   /* # of quarter seconds betweeen decrementing score  */
	INT  ccrdDeal;     /* # of cards to deal from deck  */
	INT  irep;         /* # of times thru the deck */
	PT   ptMousePrev;  /* cache of previous mouse position */
	BOOL fButtonDown;  /* TRUE if mouse button down or kbd sel */
	INT  icolKbd;      /* Current cursor position via kbd */
	INT  icrdKbd;					
	INT  icolSel;      /* Current selection  */
	INT  icolHilight;  /* Column currently hilighted (while draggin)  */
	DY	 dyDragMax;    /* maximum height of column (for dragging)  */
	INT  icolMac;
	INT  icolMax;
	COL  *rgpcol[1];
} GM;


// Constants - earlier they were generated in the game.msg file.

#define icolNil             -1
#define msggInit            0		
#define msggEnd             1		
#define msggKeyHit          2	
#define msggMouseDown       3
#define msggMouseUp         4	
#define msggMouseMove       5
#define msggMouseDblClk     6
#define msggPaint           7		
#define msggDeal            8		
#define msggUndo            9		
#define msggSaveUndo        10	
#define msggKillUndo        11	
#define msggIsWinner        12	
#define msggWinner          13	
#define msggScore           14		
#define msggChangeScore     15
#define msggDrawStatus      16
#define msggTimer           17
#define msggForceWin        18	
#define msggMouseRightClk   19


#define ID_ICON_MAIN        500

HICON   hIconMain;              // the main freecell icon.
HICON   hImageMain;             // the main freecell image.

/* Score MoDe  */
typedef INT SMD;
#define smdStandard   ideScoreStandard
#define smdVegas      ideScoreVegas
#define smdNone       ideScoreNone


#define FSelOfGm(pgm)      ((pgm)->icolSel != icolNil)
#define FHilightOfGm(pgm)  ((pgm)->icolHilight != icolNil)



BOOL FInitKlondGm( VOID );
VOID FreeGm(GM *pgm);

#ifdef DEBUG
LRESULT SendGmMsg(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2);
#else
#define SendGmMsg(pgm, msgg, wp1, wp2) \
	(*((pgm)->lpfnGmProc))((pgm), (msgg), (wp1), (wp2))
#endif	
INT DefGmProc(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2);


/* standard change score notification codes */
/* instance specific codes should be positive  */
#define csNil     -1  /* no score change  */
#define csAbs     -2  /* change score to an absolute #  */
#define csDel     -3  /* change score by an absolute #  */
#define csDelPos  -4  /* change score by an absolute #, but don't let it get negative */


// define the virtual key constant for key a
#define  VK_A     (INT) 'A'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\klond.c ===
#include "sol.h"
VSZASSERT


/* Klondike init stuff */
LRESULT KlondGmProc(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2);
LRESULT DeckColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
LRESULT DiscardColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
LRESULT TabColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
LRESULT FoundColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);



// Imported from Win3.1
BOOL FInitKlondGm()
{
    COLCLS *pcolcls;
    GM *pgm;
    DX dxCrdOffUp;
    DX dyCrdOffUp;
    DX dyCrdOffDn;
    int icol;
    int icrdMax;

    /* KLUDGE to get klondike going */
    FreeGm(pgmCur);

    if((pgm = pgmCur = PAlloc(sizeof(GM)+(13-1)*sizeof(COL *))) == NULL)
        return fFalse;

    pgm->lpfnGmProc = KlondGmProc;
    SendGmMsg(pgm, msggInit, fTrue, 0);
    pgm->icolMax = 13;
    pgm->dqsecScore = 10*4;

    if(!FInitUndo(&pgm->udr))
        goto OOM;

    /* Initialize all the column types but don't position yet */
    for(icol = 0; icol < pgm->icolMax; icol++)
    {
        switch(icol)
        {
        case icolDeck:
            pcolcls = PcolclsCreate(tclsDeck, (COLCLSCREATEFUNC)DeckColProc,
                            0, 0, 2, 1, 1, 10);
            icrdMax = icrdDeckMax;
            break;

        case icolDiscard:
            dxCrdOffUp = dxCrd / 5;
            pcolcls = PcolclsCreate(tclsDiscard, (COLCLSCREATEFUNC)DiscardColProc,
                            dxCrdOffUp, 1, 2, 1, 1, 10);
            icrdMax = icrdDiscardMax;
            break;

        case icolFoundFirst:
            pcolcls = PcolclsCreate(tclsFound, (COLCLSCREATEFUNC)FoundColProc,
                            2, 1, 0, 0, 4, 1);
            Assert(icol - 1 == icolDiscard);
            icrdMax = icrdFoundMax;
            break;

        case icolTabFirst:
            Assert(fHalfCards == 1 || fHalfCards == 0);
            dyCrdOffUp = dyCrd * 4 / 25 - fHalfCards;
            dyCrdOffDn = dyCrd / 25;
            pgm->dyDragMax = dyCrd + 12 * dyCrdOffUp;
            pcolcls = PcolclsCreate(tclsTab, (COLCLSCREATEFUNC)TabColProc,
                        0, dyCrdOffUp, 0, dyCrdOffDn, 1, 1);
            icrdMax = icrdTabMax;
            break;
        }

        if(pcolcls == NULL)
        {
OOM:
            OOM();
            FreeGm(pgmCur);
            Assert(pgmCur == NULL);
            return fFalse;
        }

        if((pgm->rgpcol[icol] = PcolCreate(pcolcls, 0, 0, 0, 0, icrdMax))
            == NULL)
        {
            FreeP(pcolcls);
            goto OOM;
        }
        pgm->icolMac++;
    }

    /* Return without positioning the cards.  This will be done at
     *  WM_SIZE message time.
     */
    return TRUE;
}


/*  PositionCols
 *      Positions the card columns.  Note that this has been revised to
 *      allow card positioning at times other than at the start of the
 *      game.
 */

BOOL PositionCols(void)
{
    DX dxMarg;
    DY dyMarg;
    DX dx;
    X xLeft;
    X xRight;
    Y yTop;
    Y yBot;
    int icol;
    DY dyCrdOffUp;
    DY dyCrdOffDn;
    COL *pcol;
    GM *pgm;
    WORD i;

    /* The game we're using is always the current one */
    pgm = pgmCur;

    /* Before doing the column classes, replace all card X coordinates with
     *  offsets from the column class.
     */
    for (icol = 0 ; icol < 13 ; ++icol)
    {
        /* Get a pointer to this COL structure */
        pcol = pgm->rgpcol[icol];

        /* Loop through all the cards in this column */
        for (i = 0 ; i < pcol->icrdMax ; ++i)
            pcol->rgcrd[i].pt.x -= pcol->rc.xLeft;
    }

    /* Set the card margins.  Note that xCardMargin is computed in SOL.C
     *  at the time the original window is created and is changed on
     *  WM_SIZE messages.
     */
    dxMarg = xCardMargin;
    dyMarg = MulDiv(dyCrd, 5, 100);

    /* Loop through all column types */
    for(icol = 0 ; icol < 13 ; icol++)
    {
        switch(icol)
        {
        case icolDeck:
            xLeft = dxMarg;
            yTop = dyMarg;
            xRight = xLeft + dxCrd + icrdDeckMax / 10 * 2;
            yBot = yTop + dyCrd + icrdDeckMax / 10;
            dx = 0;
            break;

        case icolDiscard:
            xLeft += dxMarg + dxCrd;
            xRight = xLeft + 7 * dxCrd / 5 + icrdDiscardMax / 10 * 2;
            break;

        case icolFoundFirst:
            xLeft = 4 * dxMarg + 3 * dxCrd;
            xRight = xLeft + dxCrd + icrdFoundMax / 4 * 2;
            dx = dxMarg + dxCrd;
            break;

        case icolTabFirst:
            dyCrdOffUp = dyCrd * 4 / 25 - fHalfCards;
            dyCrdOffDn = dyCrd / 25;
            xLeft = dxMarg;
            xRight = xLeft + dxCrd;
            yTop = yBot + 1;
            yBot = yTop + 12 * dyCrdOffUp + dyCrd + 6 * dyCrdOffDn;
            break;
        }

        /* Set this information into the structure */
        pcol = pgm->rgpcol[icol];
        pcol->rc.xLeft = xLeft;
        pcol->rc.yTop = yTop;
        pcol->rc.xRight = xRight;
        pcol->rc.yBot = yBot;

        /* Prepare for the next loop */
        xLeft += dx;
        xRight += dx;
    }

    /* Now that the column offsets are correct, move the cards back */
    for (icol = 0 ; icol < 13 ; ++icol)
    {
        /* Get a pointer to this COL structure */
        pcol = pgm->rgpcol[icol];

        /* Loop through all the cards in this column */
        for (i = 0 ; i < pcol->icrdMax ; ++i)
            pcol->rgcrd[i].pt.x += pcol->rc.xLeft;
    }

    return TRUE;
}




/* TABLEAU col Proc stuff */


BOOL FTabValidMove(COL *pcolDest, COL *pcolSrc)
{
    RA raSrc, raDest;
    SU suSrc, suDest;
    INT icrdSel;
    CD cd;

    Assert(pcolSrc->pmove != NULL);
    icrdSel = pcolSrc->pmove->icrdSel;

    Assert(icrdSel < pcolSrc->icrdMac);
    Assert(pcolSrc->icrdMac > 0);
    cd = pcolSrc->rgcrd[icrdSel].cd;
    raSrc = RaFromCd(cd);
    suSrc = SuFromCd(cd);
    if(raSrc == raKing)
        return (pcolDest->icrdMac == 0);
    if(pcolDest->icrdMac == 0)
        return fFalse;
    if(!pcolDest->rgcrd[pcolDest->icrdMac-1].fUp)
        return fFalse;
    cd = pcolDest->rgcrd[pcolDest->icrdMac-1].cd;
    raDest = RaFromCd(cd);
    suDest = SuFromCd(cd);
    /* invalid moves */
    Assert((suClub ^ suSpade) == 0x03);
    Assert((suHeart ^ suDiamond) == 0x03);
    /* valid moves */
    Assert((suClub ^ suDiamond) < 0x03);
    Assert((suClub ^ suHeart) < 0x03);
    Assert((suSpade ^ suDiamond) < 0x03);
    Assert((suSpade ^ suHeart) < 0x03);

    return (((suSrc ^ suDest) < 0x03) && suSrc != suDest && raSrc+1 == raDest);
}


INT TabHit(COL *pcol, PT *ppt, INT icrdMin)
{
    CRD *pcrd;

    if(pcol->icrdMac > 0 && !(pcrd=&pcol->rgcrd[pcol->icrdMac-1])->fUp && FPtInCrd(pcrd, *ppt))
    {
        SendGmMsg(pgmCur, msggKillUndo, 0, 0);
        SendColMsg(pcol, msgcSel, icrdEnd, 1);
        SendColMsg(pcol, msgcFlip, fTrue, 0);
        SendColMsg(pcol, msgcComputeCrdPos, pcol->icrdMac-1, fFalse);
        SendColMsg(pcol, msgcRender, pcol->icrdMac-1, icrdToEnd);
        SendGmMsg(pgmCur, msggChangeScore, csKlondTabFlip, 0);
        SendColMsg(pcol, msgcEndSel, fFalse, 0);
        /* should I return this? */
        return icrdNil;
    }
    return DefColProc(pcol, msgcHit, (INT_PTR) ppt, icrdMin);
}


BOOL TabDiscardDblClk(COL *pcol, PT *ppt, INT icol)
{
    CRD *pcrd;
    INT icolDest;
    COL *pcolDest;
    BOOL fResult;

    fResult = fFalse;
    if(pcol->icrdMac > 0 && (pcrd=&pcol->rgcrd[pcol->icrdMac-1])->fUp && FPtInCrd(pcrd, *ppt))
    {
        if(pcol->pmove == NULL)
            SendColMsg(pcol, msgcSel, icrdEnd, ccrdToEnd);
        Assert(pcol->pmove != NULL);
        for(icolDest = icolFoundFirst; icolDest < icolFoundFirst+ccolFound; icolDest++)
        {
            pcolDest = pgmCur->rgpcol[icolDest];
            if(SendColMsg(pcolDest, msgcValidMove, (INT_PTR)pcol, 0))
            {
                SendGmMsg(pgmCur, msggSaveUndo, icolDest, icol);
                fResult = SendColMsg(pcolDest, msgcMove, (INT_PTR) pcol, icrdToEnd) &&
                    (fOutlineDrag || SendColMsg(pcol, msgcRender, pcol->icrdMac-1, icrdToEnd)) &&
                    SendGmMsg(pgmCur, msggScore, (INT_PTR) pcolDest, (INT_PTR) pcol);
                if(SendGmMsg(pgmCur, msggIsWinner, 0, 0))
                    SendGmMsg(pgmCur, msggWinner, 0, 0);
                goto Return;
            }
        }
        SendColMsg(pcol, msgcEndSel, fFalse, 0);
    }

Return:
    return fResult;
}



LRESULT TabColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{

    switch(msgc)
    {
        case msgcHit:
        /* should this go in DefProc? */
            return TabHit(pcol, (PT *)wp1, (INT)wp2);

        case msgcDblClk:
            return TabDiscardDblClk(pcol, (PT *)wp1, (INT)wp2);

        case msgcValidMove:
            return FTabValidMove(pcol, (COL *) wp1);
    }
    return DefColProc(pcol, msgc, wp1, wp2);
}



BOOL FFoundRender(COL *pcol, INT icrdFirst, INT icrdLast)
{
#define dxFoundDn 2
#define dyFoundDn 1

    if(pcol->icrdMac == 0 || icrdLast == 0)
        {
        if(!FGetHdc())
            return fFalse;
        DrawCardExt((PT *)(&pcol->rc.xLeft), 0, GHOST);
        DrawBackExcl(pcol, (PT *) &pcol->rc);
        ReleaseHdc();
        return fTrue;
        }
    else
        return DefColProc(pcol, msgcRender, icrdFirst, icrdLast);
}





BOOL FFoundValidMove(COL *pcolDest, COL *pcolSrc)
{
    RA raSrc;
    SU suSrc;
    INT icrdSel;

    Assert(pcolSrc->pmove != NULL);
    icrdSel = pcolSrc->pmove->icrdSel;
    Assert(icrdSel < pcolSrc->icrdMac);
    Assert(pcolSrc->icrdMac > 0);
    if(pcolSrc->pmove->ccrdSel != 1)
        return fFalse;
    raSrc = RaFromCd(pcolSrc->rgcrd[icrdSel].cd);
    suSrc = SuFromCd(pcolSrc->rgcrd[icrdSel].cd);
    if(pcolDest->icrdMac == 0)
        return(raSrc == raAce);
    return (raSrc == RaFromCd(pcolDest->rgcrd[pcolDest->icrdMac-1].cd)+1 &&
                 suSrc == SuFromCd(pcolDest->rgcrd[pcolDest->icrdMac-1].cd));

}



/* Foundation stuff */
LRESULT FoundColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{
        switch(msgc)
        {
        case msgcValidMove:
            return FFoundValidMove(pcol, (COL *) wp1);

        case msgcRender:
            return FFoundRender(pcol, (INT)wp1, (INT)wp2);
        }
    return DefColProc(pcol, msgc, wp1, wp2);
}




/* DeckStuff */


BOOL DeckInit(COL *pcol)
{
    CRD *pcrd;
    INT icrd;

    Assert(pcol->icrdMax == icrdDeckMax);
    for(icrd = 0; icrd < icrdDeckMax; icrd++)
        {
        pcrd = &pcol->rgcrd[icrd];
        pcrd->cd = (unsigned short)icrd;
        pcrd->pt = *(PT *)&pcol->rc;
        pcrd->fUp = fFalse;
        }
    pcol->icrdMac = icrdDeckMax;
    SendColMsg(pcol, msgcShuffle, 0, 0);
    SendColMsg(pcol, msgcComputeCrdPos, 0, fFalse);
    return fTrue;
}







INT DeckHit(COL *pcol, PT *ppt, INT icrdMin)
{
    RC rc;
    INT ccrd;

    if(pcol->icrdMac == 0)
    {
        CrdRcFromPt((PT *) &pcol->rc, &rc);
        if(PtInRect((LPRECT) &rc, *(POINT *)ppt))
            return icrdEmpty;
        else
            return icrdNil;
    }
    else
        if(!FPtInCrd(&pcol->rgcrd[pcol->icrdMac-1], *ppt))
            return icrdNil;

    ccrd = ((GetKeyState(VK_SHIFT) & GetKeyState(VK_CONTROL) & GetKeyState(VK_MENU)) < 0) ? 1 : pgmCur->ccrdDeal;

    move.icrdSel = WMax(pcol->icrdMac-ccrd, 0);
    move.ccrdSel = pcol->icrdMac - move.icrdSel;
    Assert(pcol->pmove == NULL);
    pcol->pmove = &move;
    return move.icrdSel;
}


BOOL FDeckRender(COL *pcol, INT icrdFirst, INT icrdLast)
{
    INT mode;
    BOOL f;
    PT pt;

    /* to avoid redrawing the deck multiple times during dealing */
    if(!pgmCur->fDealt && pcol->icrdMac%10 != 9)
        return fTrue;
    if(!FGetHdc())
        return fFalse;
    if(pcol->icrdMac == 0)
        {
        mode = (smd == smdVegas && pgmCur->irep == ccrdDeal-1) ? DECKX : DECKO;
        DrawCardExt((PT *) &pcol->rc, 0, mode);
        DrawBackExcl(pcol, (PT *) &pcol->rc);
        f = fTrue;
        }
    else
        {
        f = DefColProc(pcol, msgcRender, icrdFirst, icrdLast);
        if((icrdLast == pcol->icrdMac || icrdLast == icrdToEnd) && !fHalfCards)
            {
            pt.x = pcol->rgcrd[pcol->icrdMac-1].pt.x+dxCrd-1;
            pt.y = pcol->rgcrd[pcol->icrdMac-1].pt.y+dyCrd-1;
            SetPixel(hdcCur, pt.x-xOrgCur, pt.y-yOrgCur, rgbTable);
            SetPixel(hdcCur, pt.x-1-xOrgCur, pt.y-yOrgCur, rgbTable);
            SetPixel(hdcCur, pt.x-xOrgCur, pt.y-1-yOrgCur, rgbTable);
            }
        }
    ReleaseHdc();
    return f;
}


VOID DrawAnimate(INT cd, PT *ppt, INT iani)
{

    if(!FGetHdc())
        return;
    cdtAnimate(hdcCur, cd, ppt->x, ppt->y, iani);
    ReleaseHdc();
}


BOOL DeckAnimate(COL *pcol, INT iqsec)
{
    INT iani;
    PT pt;

// we removed the older card decks that required Animation. The new
// card deck doesn't involve any animation.

#ifdef UNUSEDCODE

    if(pcol->icrdMac > 0 && !fHalfCards)
        {
        pt = pcol->rgcrd[pcol->icrdMac-1].pt;
        switch(modeFaceDown)
            {
        case IDFACEDOWN3:
            DrawAnimate(IDFACEDOWN3, &pt, iqsec % 4);
            break;
        case IDFACEDOWN10:  /* krazy kastle  */
            DrawAnimate(IDFACEDOWN10, &pt, iqsec % 2);
            break;

        case IDFACEDOWN11:  /* sanflipe */
            if((iani = (iqsec+4) % (50*4)) < 4)
                DrawAnimate(IDFACEDOWN11, &pt, iani);
            else
                /* if a menu overlapps an ani while it is ani'ing, leaves deck
                 bitmap in inconsistent state...  */
                if(iani % 6 == 0)
                    DrawAnimate(IDFACEDOWN11, &pt, 3);
            break;
        case IDFACEDOWN12:  /* SLIME  */
            if((iani = (iqsec+4) % (15*4)) < 4)
                DrawAnimate(IDFACEDOWN12, &pt, iani);
            else
                /* if a menu overlapps an ani while it is ani'ing, leaves deck
                 bitmap in inconsistent state... */
                if(iani % 6 == 0)
                    DrawAnimate(IDFACEDOWN12, &pt, 3);
            break;
            }
        }

#endif

    return fTrue;
}





LRESULT DeckColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{

    switch(msgc)
        {
    case msgcInit:
        return DeckInit(pcol);
    case msgcValidMove:
    case msgcDrawOutline:
        return fFalse;
    case msgcValidMovePt:
        return icrdNil;
    case msgcHit:                    									
        return DeckHit(pcol, (PT *) wp1, (INT)wp2);
    case msgcRender:
        return FDeckRender(pcol, (INT) wp1, (INT) wp2);
    case msgcValidKbdColSel:
        return !wp1;
    case msgcValidKbdCrdSel:
        return pcol->icrdMac == 0 || wp1 == (WPARAM) pcol->icrdMac-1;
    case msgcAnimate:
        return DeckAnimate(pcol, (INT)wp1);
        }
    return DefColProc(pcol, msgc, wp1, wp2);
}


BOOL DiscardRemove(COL *pcol, COL *pcolDest, LPARAM wp2)
{
        return DefColProc(pcol, msgcRemove, (INT_PTR) pcolDest, wp2);
}


BOOL DiscardMove(COL *pcolDest, COL *pcolSrc, INT icrd)
{
    BOOL fResult;

    SendColMsg(pcolDest, msgcComputeCrdPos, WMax(0, pcolDest->icrdMac-3), fTrue);

    /* YUCK: Default ComputeCrdPos doesn't quite work for discard because
        up cards are handled specially for Discard piles.  To keep
        code size down we have this global hack variable which DefComputeCrdPos
        uses.
    */
    fMegaDiscardHack = fTrue;
    fResult = DefColProc(pcolDest, msgcMove, (INT_PTR) pcolSrc, icrd);
    fMegaDiscardHack = fFalse;
    return fResult;
}



INT DiscardHit(COL *pcol, PT *ppt, INT icrdMin)
{
    return DefColProc(pcol, msgcHit, (INT_PTR) ppt, WMax(0, pcol->icrdMac-1));
}


BOOL DiscardRender(COL *pcol, INT icrdFirst, INT icrdLast)
{
    PT pt;
    INT icrd;
    COLCLS *pcolcls;

    if(DefColProc(pcol, msgcRender, icrdFirst, icrdLast))
        {
        if(FGetHdc())
            {
            pcolcls = pcol->pcolcls;
            for(icrd = pcol->icrdMac-1; icrd >= 0 && icrd >= pcol->icrdMac-2; icrd--)
                {
                pt = pcol->rgcrd[icrd].pt;
                /* 3 is a kludge value here */
                DrawBackground(pt.x+dxCrd-pcolcls->dxUp, pt.y-pcolcls->dyUp*3,
                        			pt.x+dxCrd, pt.y);
                }
            ReleaseHdc();
            }
        return fTrue;
        }
    return fFalse;
}



/* Discard Stuff */
LRESULT DiscardColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{
    switch(msgc)
        {
    case msgcDblClk:
        return TabDiscardDblClk(pcol, (PT *)wp1, (INT)wp2);
    case msgcHit:
        return DiscardHit(pcol, (PT *)wp1, (INT)wp2);
    case msgcMove:
        return DiscardMove(pcol, (COL *) wp1, (INT)wp2);
    case msgcRemove:
        return DiscardRemove(pcol, (COL *) wp1, wp2);
    case msgcValidMovePt:
        return icrdNil;
    case msgcValidKbdColSel:
        return !wp1;
    case msgcRender:
        return DiscardRender(pcol, (INT)wp1, (INT)wp2);
    case msgcValidKbdCrdSel:
        return pcol->icrdMac == 0 || wp1 == (WPARAM) pcol->icrdMac-1;
        }

    return DefColProc(pcol, msgc, wp1, wp2);
}




/* GAME stuff */

BOOL KlondDeal(GM *pgm, BOOL fZeroScore)
{
    INT icrdSel;
    INT icol;
    INT irw;
    COL *pcolDeck;
    VOID StatString();

    if(!FGetHdc())
        {
        OOM();
        return fFalse;
        }

    EraseScreen();
    for(icol = 0; icol < pgm->icolMac; icol++)
        SendColMsg(pgm->rgpcol[icol], msgcClearCol, 0, 0);

    pcolDeck = pgm->rgpcol[icolDeck];
    SendColMsg(pcolDeck, msgcInit, 0, 0);

    SendGmMsg(pgm, msggKillUndo, 0, 0);
    SendGmMsg(pgm, msggInit, !(smd == smdVegas && fKeepScore) || fZeroScore, 0);

    StatString(idsNil);
    pgm->fDealt = fTrue;
    SendGmMsg(pgm, msggChangeScore, csKlondDeal, 0);
    SendColMsg(pcolDeck, msgcRender, 0, icrdToEnd);
    pgm->fDealt = fFalse;
    for(icol = icolFoundFirst; icol < icolFoundFirst+ccolFound; icol++)
        SendColMsg(pgm->rgpcol[icol], msgcRender, 0, icrdToEnd);

// BabakJ: What the %@!&$* is this?! irw is always less than irw + ccolTab!!!
//         Note: ccolTab if #ifdef'ed as 7
//    for(irw = 0; irw < irw+ccolTab; irw++)

    for(irw = 0; irw < ccolTab; irw++)
        for(icol = irw; icol < ccolTab; icol++)
            {
            icrdSel = SendColMsg(pcolDeck, msgcSel, icrdEnd, 0);
            if(icol == irw)
                SendColMsg(pcolDeck, msgcFlip, fTrue, 0);
            SendColMsg(pgm->rgpcol[icol+icolTabFirst], msgcMove, (INT_PTR) pcolDeck, icrdToEnd);
            SendColMsg(pcolDeck, msgcRender, icrdSel-1, icrdToEnd);
            }
    NewKbdColAbs(pgm, 0);
    pgm->fDealt = fTrue;
    ReleaseHdc();
    return fTrue;
}




BOOL KlondMouseDown(GM *pgm, PT *ppt)
{
    INT icrdSel;
    INT icrd;
    COL *pcolDeck, *pcolDiscard;

    /* Kbd sel already in effect */
    if(FSelOfGm(pgm) || !pgm->fDealt)
        return fFalse;
    /* place the next cards on discard pile */
    if((icrd = SendColMsg(pgm->rgpcol[icolDeck], msgcHit, (INT_PTR) ppt, 0)) != icrdNil)
        {
        pgm->fInput = fTrue;
        pcolDeck = pgm->rgpcol[icolDeck];
        pcolDiscard = pgm->rgpcol[icolDiscard];
        if(icrd == icrdEmpty)
            {
            /* repeat */
            if(SendColMsg(pcolDiscard, msgcNumCards, 0, 0) == 0)
                {
                /* both deck and discard are empty */
                Assert(pcolDeck->pmove == NULL);
                return fFalse;
                }
            if(smd == smdVegas && pgm->irep == ccrdDeal-1)
                return fFalse;

            pgm->irep++;
            pgm->udr.fEndDeck = TRUE;

            return SendGmMsg(pgm, msggSaveUndo, icolDiscard, icolDeck) &&
                SendColMsg(pcolDiscard, msgcSel, 0, ccrdToEnd) != icrdNil &&
                SendColMsg(pcolDiscard, msgcFlip, fFalse, 0) &&
                SendColMsg(pcolDiscard, msgcInvert, 0, 0) &&
                SendGmMsg(pgm, msggScore, (INT_PTR) pcolDeck, (INT_PTR) pcolDiscard) &&
                SendColMsg(pcolDeck, msgcMove, (INT_PTR) pcolDiscard, icrdToEnd) &&
                SendColMsg(pcolDiscard, msgcRender, 0, icrdToEnd);
            }
        else
            {
            icrdSel = pcolDeck->pmove->icrdSel-1;
            /* deal next cards to discard */
            return SendGmMsg(pgm, msggSaveUndo, icolDiscard, icolDeck) &&
                SendColMsg(pcolDeck, msgcFlip, fTrue, 0) &&
                SendColMsg(pcolDeck, msgcInvert, 0, 0) &&
                SendColMsg(pcolDiscard, msgcMove, (INT_PTR)pcolDeck, icrdToEnd) &&
                SendColMsg(pcolDeck, msgcRender, icrdSel, icrdToEnd);
            }
        }
    return DefGmProc(pgm, msggMouseDown, (INT_PTR) ppt, icolDiscard);
}


BOOL KlondIsWinner(GM *pgm)
{
    INT icol;

    for(icol = icolFoundFirst; icol < icolFoundFirst+ccolFound; icol++)
        if(pgm->rgpcol[icol]->icrdMac != icrdFoundMax)
            return fFalse;
    return fTrue;
}


BOOL FAbort()
{
    MSG msg;

    if (MsgWaitForMultipleObjects(0, NULL, FALSE, 5, QS_ALLINPUT) != WAIT_OBJECT_0)
        return FALSE;

    if(PeekMessage(&msg, hwndApp, 0, 0, PM_NOREMOVE))
        {
        switch(msg.message)
            {
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
        case WM_MENUSELECT:
        case WM_NCLBUTTONDOWN:
        case WM_NCMBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
            return fTrue;
            }

        PeekMessage(&msg, hwndApp, 0, 0, PM_REMOVE);
        TranslateMessage((LPMSG)&msg);
        DispatchMessage((LPMSG)&msg);
        }
    return fFalse;
}



// Hack for making winning animation faster:
// At cascading time we have: KlondWinner -> DrawCardPt ->cdtDrawExt
// so we set a flag so cdtDrawExt knows it is cascading and does not need
// to round up corners.
BOOL fKlondWinner = FALSE;

BOOL KlondWinner(GM *pgm)
{
    INT icol;
    INT icrd;
    CRD *pcrd;
    PT pt;
    PT ptV;
    INT dxp;
    INT dyp;
    RC rcT;
    INT dsco;
    TCHAR *pch;
    TCHAR szBonus[84];
    VOID StatString();
    UINT cchUsed, cchTmp;

    fKlondWinner = TRUE;

    dsco = (INT)SendGmMsg(pgmCur, msggChangeScore, csKlondWin, 0);
    pgm->udr.fAvail = fFalse;
    pgm->fDealt = fFalse;
    pgm->fWon = fTrue;

    if(smd == smdStandard)
    {
        cchUsed = CchString(szBonus, idsBonus, ARRAYSIZE(szBonus));
        pch =    &szBonus[cchUsed];

        cchTmp = CchDecodeInt(pch, dsco);
        pch += cchTmp;
        cchUsed += cchTmp;

        *pch++ = TEXT(' ');
        cchUsed++;

        *pch++ = TEXT(' ');
        cchUsed++;
    }
    else
    {
        pch = szBonus;
        cchUsed = 0;
    }
    if (cchUsed < ARRAYSIZE(szBonus))
    {
        CchString(pch, idsEndWinner, ARRAYSIZE(szBonus) - cchUsed);
    }

    StatStringSz(szBonus);
    if(!FGetHdc())
        goto ByeNoRel;
    Assert(xOrgCur == 0);
    Assert(yOrgCur == 0);
    GetClientRect(hwndApp, (RECT *)&rcT);
    dxp = rcT.xRight;
    dyp = rcT.yBot - dyCrd;

    for(icrd = icrdFoundMax-1; icrd >= 0; icrd--)
    {
        for(icol = icolFoundFirst; icol < icolFoundFirst+ccolFound; icol++)
        {
            ptV.x = rand() % 110 - 65;  /* favor up and to left */
            if(abs(ptV.x) < 15)  /* kludge so doesn't bounce forever */
                ptV.x = -20;
            ptV.y = rand() % 110 - 75;
            pt = (pcrd = &pgm->rgpcol[icol]->rgcrd[icrd])->pt;

            while(pt.x > -dxCrd && pt.x < dxp)
            {
                DrawCardPt(pcrd, &pt);
                pt.x += ptV.x/10;
                pt.y += ptV.y/10;
                ptV.y+= 3;
                if(pt.y > dyp && ptV.y > 0)
                    ptV.y = -(ptV.y*8)/10;
                if(FAbort())
                    goto ByeBye;
            }

       }
    }
ByeBye:
    ReleaseHdc();
ByeNoRel:
    StatString(idsNil);
    EraseScreen();

    fKlondWinner = FALSE;

    return DefGmProc(pgm, msggWinner, 0, 0);
}

BOOL KlondForceWin(GM *pgm)
{
    INT icol;
    CRD *pcrd;
    COL *pcol;
    RA ra;
    SU su;

    for(icol = 0; icol < pgm->icolMac; icol++)
        SendColMsg(pgm->rgpcol[icol], msgcClearCol, 0, 0);
    for(su = suFirst, icol = icolFoundFirst; icol < icolFoundFirst+ccolFound; icol++, su++)
    {
        Assert(raFirst == 0);
        for(ra = raFirst; ra < raMax; ra++)
        {
            pcol = pgm->rgpcol[icol];
            pcrd = &pcol->rgcrd[ra];
            pcrd->cd = Cd(ra, su);
            pcrd->pt.x = pcol->rc.xLeft;
            pcrd->pt.y = pcol->rc.yTop;
            pcrd->fUp = fTrue;
        }
        pgm->rgpcol[icol]->icrdMac = icrdFoundMax;
    }
    Assert(SendGmMsg(pgm, msggIsWinner, 0, 0));
    return (BOOL)SendGmMsg(pgm, msggWinner, 0, 0);
}


/* Note: assumes is called once a second */
/* if pcolDest == pcolSrc == NULL, then is a timer msg */
BOOL KlondScore(GM *pgm, COL *pcolDest, COL *pcolSrc)
{
    INT cs;
    INT tclsSrc, tclsDest;


    if(smd == smdNone)
        return fTrue;
    cs = csNil;

    Assert(FValidCol(pcolSrc));
    Assert(FValidCol(pcolDest));


    tclsSrc = pcolSrc->pcolcls->tcls;
    tclsDest = pcolDest->pcolcls->tcls;

    switch(tclsDest)
        {
    default:
        return fTrue;
    case tclsDeck:
        if(tclsSrc == tclsDiscard)
            cs = csKlondDeckFlip;
        break;
    case tclsFound:
        switch(tclsSrc)
            {
        default:
            return fTrue;
        case tclsDiscard:
        case tclsTab:
            cs = csKlondFound;
            break;
            }
        break;
    case tclsTab:
        switch(tclsSrc)
            {
        default:
            return fTrue;
        case tclsDiscard:
            cs = csKlondTab;
            break;
        case tclsFound:
            cs = csKlondFoundTab;
            break;
            }
        break;
         }

    SendGmMsg(pgm, msggChangeScore, cs, 0);
    return fTrue;
}

INT mpcsdscoStd[] = { -2, -20, 10, 5, 5, -15,   0,  0};
INT mpcsdscoVegas[] = {0,   0,  5, 0, 0,  -5, -52,  0};


BOOL KlondChangeScore(GM *pgm, INT cs, INT sco)
{
    INT dsco;
    INT csNew;
    INT *pmpcsdsco;
    INT ret;

    if(cs < 0)
        return DefGmProc(pgm, msggChangeScore, cs, sco);
    Assert(FInRange(cs, 0, csKlondMax-1));
    switch(smd)
    {
        default:
            Assert(smd == smdNone);
            return fTrue;
        case smdVegas:
            pmpcsdsco = mpcsdscoVegas;
            break;

        case smdStandard:
            pmpcsdsco = mpcsdscoStd;
            if(cs == csKlondWin && fTimedGame)
            {
    #ifdef DEBUG
                pgm->iqsecScore = WMax(120, pgm->iqsecScore);
    #endif
                /* check if timer set properly */
                if(pgm->iqsecScore >= 120)
                    dsco = (20000/(pgm->iqsecScore>>2))*(350/10);
                else
                    dsco = 0;
                goto DoScore;
            }
            if(cs == csKlondDeckFlip)
            {
                if(ccrdDeal == 1 && pgm->irep >= 1)
                {
                    dsco = -100;
                    goto DoScore;
                }
                else if(ccrdDeal == 3 && pgm->irep > 3)
                    break;
                else
                    return fTrue;
            }
            break;
    }

    dsco = pmpcsdsco[cs];
DoScore:
    csNew = smd == smdVegas ? csDel : csDelPos;
    ret = DefGmProc(pgm, msggChangeScore, csNew, dsco);
    if(cs == csKlondWin)
        return dsco;
    else
        return ret;
}



BOOL KlondTimer(GM *pgm, INT wp1, INT wp2)
{

    if(fTimedGame && pgm->fDealt && pgm->fInput && !fIconic)
    {
        pgm->iqsecScore = WMin(pgm->iqsecScore+1, 0x7ffe);
        if(pgm->icolSel == icolNil)
            SendColMsg(pgm->rgpcol[icolDeck], msgcAnimate, pgm->iqsecScore, 0);
        if(pgm->dqsecScore != 0 && (pgm->iqsecScore)%pgm->dqsecScore == 0)
        {
            SendGmMsg(pgm, msggChangeScore, csKlondTime, 0);
        }
        else
        {
            /* update status bar once as second */
            if(~(pgm->iqsecScore & 0x03))
                StatUpdate();
            return fTrue;
        }
   }
   return fFalse;
}

BOOL KlondDrawStatus(GM *pgm, RC *prc)
{
    TCHAR *pch;
    TCHAR sz[80];
    RC rc;
    LONG rgb;
    BOOL fNegSco;
    SIZE   iSize;
    extern INT iCurrency;
    extern TCHAR szCurrency[];
    HFONT  hFontOld = NULL;
    HFONT  hStatusFont = NULL;


    // store the old font and replace the status font by MS Shell Dlg
    // as it supports FE characters as well as euro characters.

    hStatusFont = CreateFont(-MulDiv(9, GetDeviceCaps(hdcCur, LOGPIXELSY), 72), 0, 0, 0, FW_BOLD, 0, 0, 0, 
                             DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, 
                             DEFAULT_PITCH, TEXT("MS Shell Dlg")); 

    if (hStatusFont && hdcCur);
        hFontOld = SelectObject(hdcCur, hStatusFont);

    pch = sz;
    if(fTimedGame)
    {
        pch += CchString(pch, idsTime, ARRAYSIZE(sz));
        pch += CchDecodeInt(pch, (pgm->iqsecScore>>2));
    }
#ifdef DEBUG
    if(!fScreenShots)
    {
        *pch++ = TEXT(' ');
        pch = PszCopy(TEXT("Game # "), pch);
        pch += CchDecodeInt(pch, igmCur);
    }
#endif
    if(pch != sz)
    {
        DrawText(hdcCur, sz, (INT)(pch-sz), (LPRECT) prc, DT_RIGHT|DT_NOCLIP|DT_SINGLELINE);
    }

    if(smd != smdNone)
    {
        rc = *prc;
        GetTextExtentPoint32(hdcCur, sz, (INT)(pch-sz), &iSize);
        rc.xRight -= iSize.cx;
        pch = sz;
        if(fNegSco = pgm->sco < 0)
            *pch++ = TEXT('-');
        if(smd == smdVegas)
        {
            if(!(iCurrency&1))
            {
                pch = PszCopy(szCurrency, pch);
                if(iCurrency == 2)
                    *pch++ = TEXT(' ');
            }
        }
        pch += CchDecodeInt(pch, fNegSco ? -pgm->sco : pgm->sco);
        if(smd == smdVegas)
        {
            if(iCurrency&1)
            {
                if(iCurrency == 3)
                    *pch++ = TEXT(' ');
                pch = PszCopy(szCurrency, pch);
            }
        }
        *pch++ = TEXT(' ');
        rgb = SetTextColor(hdcCur, (!fBW && fNegSco) ? RGB(0xff, 0, 0) : RGB(0, 0, 0));
        DrawText(hdcCur, sz, (INT)(pch-sz), (LPRECT) &rc, DT_RIGHT|DT_NOCLIP|DT_SINGLELINE);
        SetTextColor(hdcCur, rgb);

        GetTextExtentPoint32(hdcCur, sz, (INT)(pch-sz), &iSize);
        rc.xRight -= iSize.cx;
        pch = PszCopy(szScore, sz);
        DrawText(hdcCur, sz, (INT)(pch-sz), (LPRECT) &rc, DT_RIGHT|DT_NOCLIP|DT_SINGLELINE);
        GetTextExtentPoint32(hdcCur, sz, (INT)(pch-sz), &iSize);
        rc.xRight -= iSize.cx;
        rc.xLeft = rc.xRight - 4 * dxChar;
        PatBlt(hdcCur, rc.xLeft, rc.yTop, rc.xRight-rc.xLeft, rc.yBot-rc.yTop, PATCOPY);
        }


    // restore the font
    if (hFontOld);
        SelectObject(hdcCur, hFontOld);

    // close the created font handle
    if (hStatusFont)
        DeleteObject(hStatusFont);

    return fTrue;
}




LRESULT KlondGmProc(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2)
{
    switch(msgg)
        {
    case msggMouseDblClk:
        if(DefGmProc(pgm, msggMouseDblClk, wp1, wp2))
            return fTrue;
        /* fall thru so works for deck double clicks */
    case msggMouseDown:
        return KlondMouseDown(pgm, (PT *)wp1);

    case msggDeal:
        return KlondDeal(pgm, (BOOL)wp1);

    case msggIsWinner:
        return KlondIsWinner(pgm);

    case msggWinner:
        return KlondWinner(pgm);

    case msggForceWin:
        return KlondForceWin(pgm);

    case msggScore:
        return KlondScore(pgm, (COL *) wp1, (COL *)wp2);

    case msggChangeScore:
        return KlondChangeScore(pgm, (INT)wp1, (INT)wp2);

    case msggTimer:
        return KlondTimer(pgm, (INT)wp1, (INT)wp2);


    case msggDrawStatus:
        return KlondDrawStatus(pgm, (RC *) wp1);
        }
    return DefGmProc(pgm, msgg, wp1, wp2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\marq.c ===
#include "sol.h"
#include <htmlhelp.h>
VSZASSERT

#define dxBord 3
#define dyBord 3

INT_PTR APIENTRY OptionsDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    BOOL fNewGame;
    static INT ccrdDealNew;
    static SMD smdNew;

    BOOL FDestroyStat();

    // Used for context sensitive help.
    static DWORD aIds[] = {
        ideDrawOne,       IDH_OPTIONS_DRAW,
        ideDrawThree,     IDH_OPTIONS_DRAW,
        ideScoreStandard, IDH_OPTIONS_SCORING,
        ideScoreVegas,    IDH_OPTIONS_SCORING,
        ideScoreNone,     IDH_OPTIONS_SCORING,
        ideTimedGame,     IDH_OPTIONS_TIMED_GAME,
        ideStatusBar,     IDH_OPTIONS_STATUS_BAR,
        ideOutlineDrag,   IDH_OPTIONS_OUTLINE_DRAGGING,
        ideKeepScore,     IDH_OPTIONS_CUMULATIVE_SCORE,
        ideScore,         IDH_OPTIONS_CUMULATIVE_SCORE,
        0,0 };

    switch(wm)
    {
        default:
            return fFalse;

        case WM_INITDIALOG:
            CheckRadioButton(hdlg, ideScoreStandard, ideScoreNone, smdNew = smd);
            ccrdDealNew = ccrdDeal;
            CheckRadioButton(hdlg, ideDrawOne, ideDrawThree, ccrdDeal == 1 ? ideDrawOne : ideDrawThree);
            CheckDlgButton(hdlg, ideStatusBar, (WORD)fStatusBar);
            CheckDlgButton(hdlg, ideTimedGame, (WORD)fTimedGame);
            CheckDlgButton(hdlg, ideOutlineDrag, (WORD)fOutlineDrag);
            CheckDlgButton(hdlg, ideKeepScore, (WORD)fKeepScore);
            EnableWindow(GetDlgItem(hdlg, ideKeepScore), smd == smdVegas);
            EnableWindow(GetDlgItem(hdlg, ideScore), smd == smdVegas);
            break;
        case WM_COMMAND:
            switch( GET_WM_COMMAND_ID( wParam, lParam) )
            {
                default:
                    return fFalse;
                case ideDrawOne:
                case ideDrawThree:
                    ccrdDealNew = GET_WM_COMMAND_ID( wParam, lParam) == ideDrawOne ? 1 : 3;
                    CheckRadioButton(hdlg, ideDrawOne, ideDrawThree, GET_WM_COMMAND_ID( wParam, lParam));
                    break;
                case ideScoreStandard:
                case ideScoreVegas:
                case ideScoreNone:
                    smdNew = GET_WM_COMMAND_ID( wParam, lParam );
                    CheckRadioButton(hdlg, ideScoreStandard, ideScoreNone, GET_WM_COMMAND_ID( wParam, lParam ));
                    EnableWindow(GetDlgItem(hdlg, ideKeepScore), smdNew == smdVegas);
                    EnableWindow(GetDlgItem(hdlg, ideScore), smdNew == smdVegas);
                    break;
                case IDOK:
                    fNewGame = fFalse;
                    if(IsDlgButtonChecked(hdlg, ideStatusBar) != (WORD)fStatusBar)
                    {
                        if(fStatusBar ^= 1)
                            FCreateStat();
                        else
                            FDestroyStat();
                    }
                    if(ccrdDealNew != ccrdDeal)
                    {
                        ccrdDeal = ccrdDealNew;
                        FInitGm();
                        PositionCols();
                        fNewGame = fTrue;
                    }
                    if(IsDlgButtonChecked(hdlg, ideTimedGame) != (WORD)fTimedGame)
                    {
                        fTimedGame ^= 1;
                        fNewGame = fTrue;
                    }
                    if(smd != smdNew)
                    {
                        smd = smdNew;
                        fNewGame = fTrue;
                    }
                    if(IsDlgButtonChecked(hdlg, ideOutlineDrag) != (WORD)fOutlineDrag)
                    {
                        FSetDrag(fOutlineDrag^1);
                    }

                    fKeepScore = IsDlgButtonChecked(hdlg, ideKeepScore);

                    WriteIniFlags(wifOpts|wifBitmap);
                    /* fall thru */
            case IDCANCEL:
                    EndDialog(hdlg, GET_WM_COMMAND_ID( wParam, lParam ) == IDOK && fNewGame);
                    break;
            }
            break;

        // context sensitive help.
         case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("sol.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("sol.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   
    }
    return fTrue;
}



VOID DoOptions()
{
    BOOL fNewGame;

    if(fNewGame = (BOOL)DialogBox(hinstApp,
                                  MAKEINTRESOURCE(iddOptions),
                                  hwndApp,
                                  OptionsDlgProc))

            NewGame(fTrue, fTrue);
}



BOOL FDrawFocus(HDC hdc, RC *prc, BOOL fFocus)
{
    HBRUSH hbr;
    RC rc;
    hbr = CreateSolidBrush(GetSysColor(fFocus ? COLOR_HIGHLIGHT : COLOR_3DFACE));
    if(hbr == NULL)
            return fFalse;
    rc = *prc;
    FrameRect(hdc, (LPRECT) &rc, hbr);
    InflateRect((LPRECT) &rc, -1, -1);
    FrameRect(hdc, (LPRECT) &rc, hbr);
    DeleteObject(hbr);
    return fTrue;
}




INT_PTR APIENTRY BackDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    static INT modeNew;
    MEASUREITEMSTRUCT FAR *lpmi;
    DRAWITEMSTRUCT FAR *lpdi;
    RC rc, rcCrd;
    HDC hdc;

    // Used for context sensitive help.
    static DWORD aIds[] = {
        IDFACEDOWN1,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN2,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN3,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN4,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN5,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN6,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN7,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN8,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN9,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN10,      IDH_SELECT_CARD_BACK,
        IDFACEDOWN11,      IDH_SELECT_CARD_BACK,
        IDFACEDOWN12,      IDH_SELECT_CARD_BACK,
        0,0 };

    switch(wm)
    {
        case WM_INITDIALOG:
            modeNew = modeFaceDown;
            SetFocus(GetDlgItem(hdlg, modeFaceDown));
            return fFalse;

        case WM_COMMAND:
            if( GET_WM_COMMAND_CMD( wParam, lParam )==BN_CLICKED )
                if( GET_WM_COMMAND_ID( wParam, lParam ) >= IDFACEDOWNFIRST && GET_WM_COMMAND_ID( wParam, lParam ) <= IDFACEDOWN12) {
                modeNew = (INT) wParam;
            break;
            }
            if( GET_WM_COMMAND_CMD( wParam, lParam )==BN_DOUBLECLICKED )
                if( GET_WM_COMMAND_ID( wParam, lParam ) >= IDFACEDOWNFIRST && GET_WM_COMMAND_ID( wParam, lParam ) <= IDFACEDOWN12 )
// BabakJ: On Win32, we are destroying wNotifyCode, but is not used later!
                wParam=IDOK;
            // slimy fall through hack of doom (no dupe code or goto)
            switch( GET_WM_COMMAND_ID( wParam, lParam )) {
                case IDOK:
                    ChangeBack(modeNew);
                    WriteIniFlags(wifBack);
                    // fall thru

                case IDCANCEL:
                    EndDialog(hdlg, 0);
                    break;
            }
            break;

    case WM_MEASUREITEM:
            lpmi = (MEASUREITEMSTRUCT FAR *)lParam;
            lpmi->CtlType = ODT_BUTTON;
            lpmi->itemWidth = 32;
            lpmi->itemHeight = 54;
            break;
    case WM_DRAWITEM:
            lpdi = (DRAWITEMSTRUCT FAR *)lParam;

            CopyRect((LPRECT) &rc, &lpdi->rcItem);
            rcCrd = rc;
            InflateRect((LPRECT) &rcCrd, -dxBord, -dyBord);
            hdc = lpdi->hDC;

            if (lpdi->itemAction == ODA_DRAWENTIRE)
            {
                cdtDrawExt(hdc, rcCrd.xLeft, rcCrd.yTop,
                        rcCrd.xRight-rcCrd.xLeft, rcCrd.yBot-rcCrd.yTop,
                        lpdi->CtlID, FACEDOWN, 0L);
                FDrawFocus(hdc, &rc, lpdi->itemState & ODS_FOCUS);
                break;
            }
            if (lpdi->itemAction == ODA_SELECT)
                InvertRect(hdc, (LPRECT)&rcCrd);

            if (lpdi->itemAction == ODA_FOCUS) {
                // Set the new mode when we get focus
                if (lpdi->itemState & ODS_FOCUS)
                    modeNew = lpdi->CtlID;
                FDrawFocus(hdc, &rc, lpdi->itemState & ODS_FOCUS);
            }

            break;

           // context sensitive help.
         case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("sol.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("sol.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   
 

    default:
            return fFalse;
            }
    return fTrue;
}


LRESULT APIENTRY BackPushProc(HWND hwnd, INT wm, WPARAM wParam, LPARAM lParam)
{
    return 0L;
}

VOID DoBacks()
{

    DialogBox(hinstApp,
              MAKEINTRESOURCE(iddBacks),
              hwndApp,
              BackDlgProc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\soldraw.h ===
/* CarDDRaw structure  */
typedef struct _cddr
{
	HDC hdc;
	INT x;
	INT y;
	INT cd;
	INT mode;
	DWORD rgbBgnd;
} CDDR;



#define drwInit 		1
#define drwDrawCard 	2
#define drwClose 		3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\sol.h ===
//#ifdef WIN

/* BabakJ: The stuff in this ifdef is hack for using \\popcorn env */
//#define NOCOMM
/* #define _NTDEF_  to get NT defs, i.e. WORD unsigned short, not int */

#include <windows.h>
#include <port1632.h>


// Babakj: Set DEBUG based on DBG (1 or 0) to do FREE or CHECKED builds of Solitaire
#if DBG
#define DEBUG
#endif


/* #include <winkrnl.h>   To define OFSTRUCT */
/* OpenFile() Structure */
//typedef struct tagOFSTRUCT
//  {
//    BYTE        cBytes;
//    BYTE        fFixedDisk;
//    WORD        nErrCode;
//    BYTE        reserved[4];
//    BYTE        szPathName[128];
//  } OFSTRUCT;
//typedef OFSTRUCT            *POFSTRUCT;
//typedef OFSTRUCT NEAR       *NPOFSTRUCT;
//typedef OFSTRUCT FAR        *LPOFSTRUCT;
//#define OF_CREATE           0x1000
//#define OF_WRITE            0x0001
/* End if stuff taken from Winkrnl.h */
//#endif

#include <stdlib.h>
#include <time.h>
#include "std.h"
#include "crd.h"
#include "col.h"
#include "undo.h"
#include "solid.h"
#include "game.h"
#include "soldraw.h"
#include "back.h"
#include "stat.h"
#include "klond.h"
#include "debug.h"


// key in the registry to store the solitaire settings.
#define SOLKEYNAME TEXT("Software\\Microsoft\\Solitaire")


VOID ChangeBack( INT );
VOID WriteIniFlags( INT );
BOOL FYesNoAlert( INT );
VOID DoOptions( VOID );
VOID DoBacks( VOID );
VOID NewGame( BOOL, BOOL );
BOOL APIENTRY cdtDraw( HDC, INT, INT, INT, INT, DWORD );
BOOL APIENTRY cdtDrawExt(HDC, INT, INT, INT, INT, INT, INT, DWORD);
BOOL FCreateStat( VOID );
BOOL FSetDrag( BOOL );
BOOL FInitGm( VOID );
BOOL APIENTRY cdtInit( INT FAR *, INT FAR * );
typedef INT (*COLCLSCREATEFUNC)();
COLCLS *PcolclsCreate(INT tcls, COLCLSCREATEFUNC lpfnColProc,
							DX dxUp, DY dyUp, DX dxDn, DY dyDn,
							INT dcrdUp, INT dcrdDn);
COL *PcolCreate(COLCLS *pcolcls, X xLeft, Y yTop, X xRight, Y yBot, INT icrdMax);
VOID SwapCards(CRD *pcrd1, CRD *pcrd2);
BOOL FCrdRectIsect(CRD *pcrd, RC *prc);
BOOL FRectIsect(RC *prc1, RC *prc2);
BOOL FPtInCrd(CRD *pcrd, PT pt);

VOID DrawCard(CRD *pcrd);
VOID DrawCardPt(CRD *pcrd, PT *ppt);
VOID DrawBackground(X xLeft, Y yTop, X xRight, Y yBot);
VOID DrawBackExcl(COL *pcol, PT *ppt);
VOID EraseScreen(VOID);
VOID OOM( VOID );

HDC HdcSet(HDC hdc, X xOrg, Y yOrg);
extern X xOrgCur;
extern Y yOrgCur;


#define AssertHdcCur() Assert(hdcCur != NULL)


BOOL FGetHdc( VOID );
VOID ReleaseHdc( VOID );

typedef union
	{
	struct _ini
		{
		BOOL fStatusBar : 1;
		BOOL fTimedGame : 1;
		BOOL fOutlineDrag : 1;
		BOOL fDrawThree : 1;
		unsigned fSMD: 2;
		BOOL fKeepScore : 1;
		BOOL unused:8;
		} grbit;
	DWORD w;
	} INI;


/* WriteIniFlags flags */

#define wifOpts   0x01
#define wifBitmap 0x02
#define wifBack   0x04

#define wifAll wifOpts|wifBitmap|wifBack




/* externals    */
/* sol.c        */
extern TCHAR   szAppName[]; // name of this application (solitaire)
extern TCHAR   szScore[];   // title 'score:' for internationalization
extern HWND   hwndApp;      // handle to main window of app
extern HANDLE hinstApp;     // handle to instance of app
extern BOOL   fBW;          // true if on monochrome video (not NT!)
extern HBRUSH hbrTable;     // handle to brush of table top
extern LONG   rgbTable;     // RGB value of table top
extern INT    modeFaceDown; // back of cards bmp id
extern BOOL   fIconic;      // true if app is iconic
extern INT    dyChar;       // tmHeight for textout
extern INT    dxChar;       // tmMaxCharWidth for textout
extern GM*    pgmCur;       // current game
extern DEL    delCrd;
extern DEL    delScreen;
extern PT     ptNil;        // no previous pt (nil)

#define dxCrd delCrd.dx
#define dyCrd delCrd.dy
#define dxScreen delScreen.dx
#define dyScreen delScreen.dy

extern RC     rcClient;     // client rectangle after resize
extern INT    igmCur;       // the current game #, srand seeded with this
#ifdef DEBUG
extern BOOL   fScreenShots;  // ???
#endif
extern HDC    hdcCur;       // current HDC to draw on (!)
extern INT    usehdcCur;    // hdcCur use count
extern X      xOrgCur;
extern Y      yOrgCur;

extern TCHAR   szOOM[50];   // "out of memory" error message

extern BOOL   fStatusBar;   // true if we are to show status
extern BOOL   fTimedGame;   // true if we are to time game
extern BOOL   fKeepScore;   // true if keeping score (vegas only)
extern SMD    smd;          // Score MoDe (std, vegas, none)
extern INT    ccrdDeal;
extern BOOL   fOutlineDrag;

extern BOOL   fHalfCards;
extern int    xCardMargin;


/* stat.c         */
extern HWND  hwndStat;      // hwnd of status window

/* col.c          */
extern BOOL  fMegaDiscardHack;  // true if called from DiscardMove
extern MOVE  move;              // move data

/* klond.c        */
BOOL PositionCols(void);
extern BOOL fKlondWinner;       // true if we needn't round card corners


#ifdef DEBUG
WORD ILogMsg( VOID *, INT, WPARAM, LPARAM, BOOL );
VOID LogMsgResult( INT, LRESULT );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\stat.h ===
/* PUBLICs */
BOOL FRegisterStat(BOOL fFirstInst);
BOOL FDestroyStat( VOID );
VOID StatRender( VOID );
VOID StatUpdate( VOID );
VOID StatMove( VOID );
VOID StatString(INT ids);
VOID StatStringSz(TCHAR *sz);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\sol.c ===
#include "sol.h"
#include <shellapi.h>  // To pick up ShellAbout()
#include <htmlhelp.h>
#include <commctrl.h>   // for fusion classes.

VSZASSERT


#define rgbGreen RGB(0x00,0x80,0x00)
#define rgbWhite RGB(0xff,0xff,0xff)

PT   ptNil = {0x7fff, 0x7fff};
TCHAR szAppName[10];      // name of this app: 'solitaire'
TCHAR szScore[50];        // 'score:' for internationalization

/* Instance info */
static HANDLE  hAccel; // accelerators handle

HWND    hwndApp;       // window handle to this app
HANDLE  hinstApp;      // instance handle to this app
BOOL    fBW=FALSE;     // true if on true monochrome video! (never true on NT)
HBRUSH  hbrTable;      // brush for background of table top
LONG    rgbTable;      // RGB value of table top

BOOL fIconic = fFalse; // true if app is 'iconic'

INT  dyChar;           // tmHeight of font in hdc
INT  dxChar;           // tmMaxCharWidth of font in hdc


#define modeNil -1
INT modeFaceDown = modeNil;  // back of cards ID


GM *pgmCur = NULL;           // current game

/* card extent info */
DEL delCrd;
DEL delScreen;

RC rcClient;                 // client rectangle

INT igmCur;   /* the current game #, srand seeded with this */
#ifdef DEBUG
BOOL fScreenShots = fFalse;
#endif

/* window messages for external app drawing */
static UINT wmCardDraw;


HDC hdcCur = NULL;   // current hdc to draw on
INT usehdcCur = 0;   // hdcCur use count
X xOrgCur = 0;
Y yOrgCur = 0;

static TCHAR szClass[] = TEXT("Solitaire");

TCHAR szOOM[50];

// BUG: some of these should go in gm struct
//
BOOL fStatusBar   = fTrue;
BOOL fTimedGame   = fTrue;
BOOL fKeepScore   = fFalse;
SMD  smd          = smdStandard;  /* Score MoDe */
INT  ccrdDeal     = 3;
BOOL fOutlineDrag = fFalse;

BOOL fHalfCards = fFalse;


INT  xCardMargin;
#define MIN_MARGIN  (dxCrd / 8 + 3)


/********************  Internal Functions ****************/
BOOL FSolInit( HANDLE, HANDLE, LPTSTR, INT );
VOID GetIniFlags( BOOL * );
VOID APIENTRY cdtTerm( VOID );
VOID DoHelp( INT );

LRESULT APIENTRY SolWndProc(HWND, UINT, WPARAM, LPARAM);

// International stuff
//
INT  iCurrency;
TCHAR szCurrency[5];


/******************************************************************************
 * WINMAIN/ENTRY POINT
 *   This is the main entry-point for the application.  It uses the porting
 *   macro MMain() since it was ported from 16bit Windows.
 *
 *   The accelerator-table was added from demo-purposes.
 *
 *
 *****************************************************************************/
MMain( hinst, hinstPrev, lpstrCmdLine, sw )

    MSG msg;
    LPTSTR  lpszCmdLine = GetCommandLine();


    // Initialize the application.
    //
    if (!FSolInit(hinst, hinstPrev, lpszCmdLine, sw))
            return(0);


    // Message-Polling loop.
    //
    msg.wParam = 1;
    while (GetMessage((LPMSG)&msg, NULL, 0, 0))
    {
        if( !TranslateAccelerator( hwndApp, hAccel, &msg ))
        {
            TranslateMessage((LPMSG)&msg);
            DispatchMessage((LPMSG)&msg);
        }
    }

    return ((int)(msg.wParam ? 1 : 0));

    // Eliminate unreferenced-variable warnings from
    // porting macro.
    //
    (void)_argv;
    (void)_argc;
}


/******************************************************************************
 *      FSolInit
 *
 *      Main program initialization.
 *
 *      Arguments:
 *              hinst - instance of this task
 *              hinstPrev - previous instance, or NULL if this is the
 *                      first instance
 *              lpszCmdLine - command line argument string
 *              sw - show window command
 *
 *      Returns:
 *              fFalse on failure.
 *
 *****************************************************************************/
BOOL FSolInit(HANDLE hinst, HANDLE hinstPrev, LPTSTR lpszCmdLine, INT sw)
{
    WNDCLASSEX cls;
    HDC        hdc;
    TEXTMETRIC tm;
    HANDLE     hcrsArrow;
    BOOL       fStartIconic;
    TCHAR FAR  *lpch;
    BOOL       fOutline;
    TCHAR      szT[20];
    RECT       rect;
    INITCOMMONCONTROLSEX icc;   // common control registration.
    WORD APIENTRY TimerProc(HWND, UINT, UINT_PTR, DWORD);

    hinstApp = hinst;

    /* create stock objects */

    CchString(szOOM, idsOOM, ARRAYSIZE(szOOM));
    if(!cdtInit((INT FAR *)&dxCrd, (INT FAR *)&dyCrd))
    {
        goto OOMError;
    }
    hcrsArrow = LoadCursor(NULL, IDC_ARROW);
    hdc = GetDC(NULL);
    if(hdc == NULL)
    {
        OOMError:
        OOM();
        return fFalse;
    }

    GetTextMetrics(hdc, (LPTEXTMETRIC)&tm);
    dyChar = tm.tmHeight;
    dxChar = tm.tmMaxCharWidth;
    if (GetDeviceCaps(hdc, NUMCOLORS) == 2)
        fBW = fTrue;

/* BUG:  if HORZRES not big enough, have to call cdtDrawExt & shrink dxCrd */
/* BUG:  Need to check VERTRES and divide dxCrd by 2 (esp w/ lores ega) */
    dxScreen = GetDeviceCaps(hdc, HORZRES);
    dyScreen = GetDeviceCaps(hdc, VERTRES);
    if(fHalfCards = dyScreen < 300)
        dyCrd /= 2;
    ReleaseDC(NULL, hdc);
    rgbTable = fBW ? rgbWhite : rgbGreen;
    hbrTable = CreateSolidBrush(rgbTable);

    srand((WORD) time(NULL));

    /* load strings */
    CchString(szAppName, idsAppName, ARRAYSIZE(szAppName));
    CchString(szScore, idsScore, ARRAYSIZE(szScore));

    CchString(szT, idsCardDraw, ARRAYSIZE(szT));
    wmCardDraw = RegisterWindowMessage(szT);

    /* scan cmd line to see if should come up iconic */
    /* this may be unnecessary with win3.0 (function may be provided to */
    /* do it automatically */

    fStartIconic = fFalse;
    for(lpch = lpszCmdLine; *lpch != TEXT('\000'); lpch++)
    {
        if(*lpch == TEXT('/') && *(lpch+1) == TEXT('I'))
        {
            fStartIconic = fTrue;
            break;
        }
    }


    // Register the common controls.
    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC  = ICC_ANIMATE_CLASS | ICC_BAR_CLASSES | ICC_COOL_CLASSES | ICC_HOTKEY_CLASS | ICC_LISTVIEW_CLASSES | 
                 ICC_PAGESCROLLER_CLASS | ICC_PROGRESS_CLASS | ICC_TAB_CLASSES | ICC_UPDOWN_CLASS | ICC_USEREX_CLASSES;
    InitCommonControlsEx(&icc);

    /* Load the solitaire icon */

    hIconMain = LoadIcon(hinstApp, MAKEINTRESOURCE(ID_ICON_MAIN));

    /* Load the solitaire icon image */

    hImageMain = LoadImage(hinstApp, MAKEINTRESOURCE(ID_ICON_MAIN),
                         IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);


    /* register window classes */

    if (hinstPrev == NULL)
    {
        ZeroMemory( &cls, sizeof(cls) );
        cls.cbSize= sizeof(cls);
        cls.style = CS_BYTEALIGNWINDOW | CS_DBLCLKS,
        cls.lpfnWndProc = SolWndProc;
        cls.hInstance = hinstApp;
        cls.hIcon =  hIconMain;
        cls.hIconSm= hImageMain;
        cls.hCursor = hcrsArrow;
        cls.hbrBackground = hbrTable;
        cls.lpszMenuName = MAKEINTRESOURCE(idmSol);
        cls.lpszClassName = (LPTSTR)szClass;
        if (!RegisterClassEx(&cls))
        {
            goto OOMError;
        }
     }

	/* Determine the proper starting size for the window */

	/* Card margin is just a little bigger than 1/8 of a card */
	xCardMargin = MIN_MARGIN;
	
	/* We need 7 card widths and 8 margins */
	rect.right = dxCrd * 7 + 8 * xCardMargin;

	/* Compute the window size we need for a client area this big */
	rect.bottom = dyCrd * 4;
	rect.left = rect.top = 0;
	AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, TRUE);
	rect.right -= rect.left;
	rect.bottom -= rect.top;

	/* Make sure it's not too big */
	if (rect.bottom > dyScreen)
	    rect.bottom = dyScreen;

    /* create our windows */
    if (!
    (hwndApp = CreateWindow( (LPTSTR)szClass, (LPTSTR)szAppName,
                    fStartIconic ? WS_OVERLAPPEDWINDOW | WS_MINIMIZE | WS_CLIPCHILDREN:
                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                    CW_USEDEFAULT, 0,
			rect.right, rect.bottom,
                        (HWND)NULL, (HMENU)NULL, hinstApp, (LPTSTR)NULL)))
        {
        goto OOMError;
        }

    GetIniFlags(&fOutline);


    if(SetTimer(hwndApp, 666, 250, TimerProc) == 0)
    {
        goto OOMError;
    }

    FInitGm();
    FSetDrag(fOutline);

    ShowWindow(hwndApp, sw);
    UpdateWindow(hwndApp);

    hAccel = LoadAccelerators( hinst, TEXT("HiddenAccel") );

    FRegisterStat(hinstPrev == NULL);
    if(fStatusBar)
        FCreateStat();

    Assert(pgmCur != NULL);
    if(sw != SW_SHOWMINNOACTIVE && sw != SW_MINIMIZE)
        PostMessage(hwndApp, WM_COMMAND, idsInitiate, 0L);

    return(fTrue);
}



VOID DoPaint(HWND hwnd)
{
    PAINTSTRUCT paint;

    BeginPaint(hwnd, (LPPAINTSTRUCT) &paint);
    if(pgmCur)
        SendGmMsg(pgmCur, msggPaint, (INT_PTR) &paint, 0);
    EndPaint(hwnd, (LPPAINTSTRUCT) &paint);
}


/*      SolWndProc
 *
 *      Window procedure for main Sol window.
 *
 *      Arguments:
 *              hwnd - window handle receiving the message - should
 *                      be hwndSol
 *              wm - window message
 *              wParam, lParam - more info as required by wm
 *
 *      Returns:
 *              depends on the message
 */
LRESULT APIENTRY SolWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    HMENU hmenu;
    PT pt;
    INT msgg;
    VOID NewGame();
    VOID StatString();

    switch (wm)
    {
        default:
            if(wm == wmCardDraw)
            {
                switch(wParam)
                {
                    case drwInit:
                        return MAKELONG(dxCrd, dyCrd);

                    case drwDrawCard:
                        #define lpcddr ((CDDR FAR *)lParam)
                        return cdtDraw(lpcddr->hdc, lpcddr->x, lpcddr->y, lpcddr->cd, lpcddr->mode, lpcddr->rgbBgnd);
                        #undef lpcddr

                    case drwClose:
                        PostMessage(hwndApp, WM_SYSCOMMAND, SC_CLOSE, 0L);
                        return fTrue;
                }
            }
            break;

    case WM_HELP:
        DoHelp( idsHelpIndex );
        break;

    case WM_DESTROY:
        KillTimer(hwndApp, 666);
        SendGmMsg(pgmCur, msggEnd, 0, 0);
        FSetDrag(fTrue);    /* Free up screen bitmaps if we made em */
        cdtTerm();
        DeleteObject(hbrTable);
        PostQuitMessage(0);
        break;

    case WM_ACTIVATE:
        if( GET_WM_ACTIVATE_STATE(wParam, lParam) &&
		   !GET_WM_ACTIVATE_FMINIMIZED(wParam, lParam) )
            DoPaint(hwnd);
        break;

    case WM_KILLFOCUS:
        if(pgmCur->fButtonDown)
            SendGmMsg(pgmCur, msggMouseUp, 0, fTrue);
        /* Fall through. */
    case WM_SETFOCUS:
        ShowCursor(wm == WM_SETFOCUS);
        break;


    case WM_SIZE:
    {
	    int nNewMargin;
	    int nMinMargin;

	    fIconic = IsIconic(hwnd);
	    GetClientRect(hwnd, (LPRECT) &rcClient);

	    /* Compute the new margin size if any and if necessary, redraw */
	    nNewMargin = ((short)lParam - 7 * (short)dxCrd) / 8;
	    nMinMargin = MIN_MARGIN;
	    if (nNewMargin < nMinMargin && xCardMargin != nMinMargin)
		nNewMargin = nMinMargin;
	    if (nNewMargin >= nMinMargin)
	    {
            xCardMargin = nNewMargin;
            PositionCols();
            InvalidateRect(hwnd, NULL, TRUE);
	    }

	    /* Code always falls through here */
    }


    case WM_MOVE:
        StatMove();
        break;


    case WM_MENUSELECT:
	    // Don't send in garbage if not a menu item
	    if( GET_WM_MENUSELECT_FLAGS( wParam, lParam ) & MF_POPUP     ||
		    GET_WM_MENUSELECT_FLAGS( wParam, lParam ) & MF_SYSMENU   ||
		    GET_WM_MENUSELECT_FLAGS( wParam, lParam ) & MF_SEPARATOR ) {

		    StatString(idsNil);
		}
		else {
		    StatString( GET_WM_MENUSELECT_CMD( wParam, lParam ));
		}
        break;

    case WM_KEYDOWN:
        Assert(pgmCur);
        SendGmMsg(pgmCur, msggKeyHit, wParam, 0);
        break;

    case WM_LBUTTONDOWN:
        /*              ProfStart(); */
        SetCapture(hwnd);
        if(pgmCur->fButtonDown)
            break;
        msgg = msggMouseDown;
        goto DoMouse;

    case WM_LBUTTONDBLCLK:
        msgg = msggMouseDblClk;
        if(pgmCur->fButtonDown)
            break;
        goto DoMouse;

    case WM_RBUTTONDOWN:
        // If the left mousebutton is down, ignore the right click.
        if (GetCapture())
            break;
        msgg = msggMouseRightClk;
        goto DoMouse;

    case WM_LBUTTONUP:
        /*              ProfStop(); */
        ReleaseCapture();
        msgg = msggMouseUp;
        if(!pgmCur->fButtonDown)
            break;
        goto DoMouse;

    case WM_MOUSEMOVE:
        msgg = msggMouseMove;
        if(!pgmCur->fButtonDown)
            break;
DoMouse:
            Assert(pgmCur != NULL);
            LONG2POINT( lParam, pt );
            Assert(pgmCur);
            SendGmMsg(pgmCur, msgg, (INT_PTR) &pt, 0);
            break;


    case WM_COMMAND:
        switch( GET_WM_COMMAND_ID( wParam, lParam ))
        {
            /* Game menu */
            case idsInitiate:
                NewGame(fTrue, fFalse);
                break;
            case idsUndo:
                Assert(pgmCur);
                SendGmMsg(pgmCur, msggUndo, 0, 0);
                break;
            case idsBacks:
                DoBacks();
                break;
            case idsOptions:
                DoOptions();
                break;
            case idsExit:
                PostMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                break;
            /* Help Menu */
            case (WORD)idsHelpIndex:
            case (WORD)idsHelpSearch:
            case (WORD)idsHelpUsing:
                DoHelp( (INT)(SHORT)GET_WM_COMMAND_ID( wParam, lParam ));
                break;
            case idsAbout:
            {
                TCHAR szExtraInfo[100];
                CchString(szExtraInfo, idsExtraInfo, ARRAYSIZE(szExtraInfo));
#ifndef _GAMBIT_
                ShellAbout(hwnd, szAppName, szExtraInfo, hIconMain);
#endif
                break;
            }
            case idsForceWin:
                SendGmMsg(pgmCur, msggForceWin, 0, 0);
                break;
#ifdef DEBUG
            case idsGameNo:
                if(FSetGameNo())
                    NewGame(fFalse, fFalse);
                break;

            case idsCardMacs:
                PrintCardMacs(pgmCur);
                break;
            case idsAssertFail:
                Assert(fFalse);
                break;
            case idsMarquee:
                break;

            case idsScreenShots:
                fScreenShots ^= 1;
                CheckMenuItem(GetMenu(hwnd), idsScreenShots, fScreenShots ? MF_CHECKED|MF_BYCOMMAND : MF_UNCHECKED|MF_BYCOMMAND);
                InvalidateRect(hwndStat, NULL, fTrue);
                if(fScreenShots)
                    InvalidateRect(hwnd, NULL, fTrue);
                break;
#endif
            default:
                break;
            }
            break;

    case WM_INITMENU:
            hmenu = GetMenu(hwnd);
            Assert(pgmCur);
            EnableMenuItem(hmenu, idsUndo,
                    pgmCur->udr.fAvail && !FSelOfGm(pgmCur) ? MF_ENABLED : MF_DISABLED|MF_GRAYED);
            EnableMenuItem(hmenu, idsInitiate, FSelOfGm(pgmCur) ? MF_DISABLED|MF_GRAYED : MF_ENABLED);
            EnableMenuItem(hmenu, idsBacks,    FSelOfGm(pgmCur) ? MF_DISABLED|MF_GRAYED : MF_ENABLED);
            EnableMenuItem(hmenu, idsAbout,    FSelOfGm(pgmCur) ? MF_DISABLED|MF_GRAYED : MF_ENABLED);
            break;

    case WM_PAINT:
        if(!fIconic)
        {
            DoPaint(hwnd);
            return(0L);
        }
        break;    
    }

    return(DefWindowProc(hwnd, wm, wParam, lParam));
}



HDC HdcSet(HDC hdc, X xOrg, Y yOrg)
{
    HDC hdcT = hdcCur;
    hdcCur = hdc;
    xOrgCur = xOrg;
    yOrgCur = yOrg;
    return hdcT;
}



BOOL FGetHdc()
{
    HDC hdc;

    Assert(hwndApp);
    if(hdcCur != NULL)
    {
        usehdcCur++;
        return fTrue;
    }

    hdc = GetDC(hwndApp);
    if(hdc == NULL)
        return fFalse;
    HdcSet(hdc, 0, 0);
    usehdcCur = 1;
    return fTrue;
}


VOID ReleaseHdc()
{
    if(hdcCur == NULL)
        return;
    if(--usehdcCur == 0)
    {
        ReleaseDC(hwndApp, hdcCur);
        hdcCur = NULL;
    }
}


WORD APIENTRY TimerProc(HWND hwnd, UINT wm, UINT_PTR id, DWORD dwTime)
{

    if(pgmCur != NULL)
		SendGmMsg(pgmCur, msggTimer, 0, 0);
    return fTrue;
}





VOID ChangeBack(INT mode)
{

    if(mode == modeFaceDown)
        return;
    modeFaceDown = mode;
    InvalidateRect(hwndApp, NULL, fTrue);
}


VOID NewGame(BOOL fNewSeed, BOOL fZeroScore)
{

#ifdef DEBUG
    InitDebug();
#endif
    if(fNewSeed)
    {
        static INT lastrnd= -1;     // previous rand() value
        INT rnd1;                   // trial rand() value
        INT Param;

        // It was reported that games never changed.
        // We could not repro it so see if it happens
        // and output a message to the debugger.
        //

        Param= (INT) time(NULL);
        srand( igmCur = ((WORD) Param) & 0x7fff);

#ifdef DEBUG
        rnd1= rand();

        if( lastrnd == rnd1 )
        {
            TCHAR szText[100];
            wsprintf(szText,TEXT("Games repeat: time= %d  GetLastError= %d\n"),
                     Param, GetLastError());
            OutputDebugString(szText);
        }

        lastrnd= rnd1;
#endif

    }

#ifdef DEBUG
    SendGmMsg(pgmCur, msggChangeScore, 0, 0);
#endif
    SendGmMsg(pgmCur, msggDeal, fZeroScore, 0);
}



INT_PTR APIENTRY About(HWND hdlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
    if (iMessage == WM_COMMAND)
    {
        EndDialog(hdlg,fTrue);
        return fTrue;
    }
    else if (iMessage == WM_INITDIALOG)
        return fTrue;
    else
        return fFalse;
}


VOID DoHelp(INT idContext)
{
    CHAR sz[100];
    HWND hwndResult;

    LoadStringA(hinstApp, (WORD)idsHelpFile, (LPSTR)sz, 100);

#ifndef _GAMBIT_
    switch(idContext)
    {
        case idsHelpUsing:
            hwndResult = HtmlHelpA(GetDesktopWindow(), "NTHelp.chm", HH_DISPLAY_TOPIC, 0);
            break;
        case idsHelpIndex:
            hwndResult = HtmlHelpA(GetDesktopWindow(), sz, HH_DISPLAY_TOPIC, 0);
            break;
        case idsHelpSearch:
            hwndResult = HtmlHelpA(GetDesktopWindow(), sz, HH_DISPLAY_INDEX, 0);
            break;
    }
    if(!hwndResult)
        ErrorIds(idsNoHelp);
#endif
}


VOID GetIniFlags(BOOL *pfOutline)
{
    INI    ini;
    INT    mode;

    ini.w = 0;
    ini.grbit.fStatusBar = fStatusBar;
    ini.grbit.fTimedGame = fTimedGame;
    ini.grbit.fOutlineDrag = fOutlineDrag;
    ini.grbit.fDrawThree = ccrdDeal == 3;
    ini.grbit.fKeepScore = fKeepScore;
    ini.grbit.fSMD = 0;

    ini.w = GetIniInt(idsAppName, idsOpts, ini.w);

    fStatusBar = ini.grbit.fStatusBar ? 1 : 0;
    fTimedGame = ini.grbit.fTimedGame ? 1 : 0;
    *pfOutline = ini.grbit.fOutlineDrag ? 1 : 0;
    ccrdDeal = ini.grbit.fDrawThree ? 3 : 1;
    fKeepScore = ini.grbit.fKeepScore ? 1 : 0;
    switch(ini.grbit.fSMD)
    {
        default:
            smd = smdStandard;
            break;
        case 1:
            smd = smdVegas;
            break;
        case 2:
            smd = smdNone;
            break;
    }

    mode = GetIniInt(idsAppName, idsBack, rand() % cIDFACEDOWN) + IDFACEDOWNFIRST-1;
    ChangeBack(PegRange(mode, IDFACEDOWNFIRST, IDFACEDOWN12));

    iCurrency = GetIniInt(idsIntl, idsiCurrency, 0);
    FGetIniString(idsIntl, idssCurrency, szCurrency, TEXT("$"), sizeof(szCurrency));
}


VOID WriteIniFlags(INT wif)
{
    INI ini;

    if(wif & wifOpts)
    {
        ini.w = 0;
        ini.grbit.fStatusBar = fStatusBar;
        ini.grbit.fTimedGame = fTimedGame;
        ini.grbit.fOutlineDrag = fOutlineDrag;
        ini.grbit.fDrawThree = ccrdDeal == 3;
        ini.grbit.fKeepScore = fKeepScore;
        switch(smd)
        {
            default:
                Assert(fFalse);
                break;
            case smdStandard:
                ini.grbit.fSMD = 0;
                break;
            case smdVegas:
                ini.grbit.fSMD = 1;
                break;
            case smdNone:
                ini.grbit.fSMD = 2;
                break;
        }

        FWriteIniInt(idsAppName, idsOpts, ini.w);
    }
    if(wif & wifBack)
            FWriteIniInt(idsAppName, idsBack, modeFaceDown-IDFACEDOWNFIRST+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\solid.h ===
#define szVer TEXT("Version 3.0")


/* ------ Strings ------ */
#define idsNil          0x1fff
#define idsAppName		100
#define idsScore		101
#define idsTime		    102
#define idsCardDraw		103
#define idsDealAgain	104
#define idsHelpFile		105
#define idsEndWinner	106
#define idsBonus		107
#define idsExtraInfo	108
	

/* ini strings */
#define idsBack		    200
#define idsOpts		    201
#define idsBitmap		202
/* DON'T internationalize iCurrency, sCurrency and intl */
#define idsiCurrency	203
#define idssCurrency	204
#define idsIntl		    205

/* error strings */
#define idsOOM		    300
#define idsNoHelp		301
#define idsNoBitmap		302
#define idsNoFullDrag	303

/* status line strings */
#define idsInitiate		1000
#define idsUndo		    1001
#define idsBacks		1002
#define idsOptions		1003
#define idsExit		    1004

/* Debug               */
#define idsGameNo		1005
#define idsCardMacs		1006
#define idsAssertFail	1007
#define idsMarquee		1008
#define idsScreenShots	1009
#define idsForceWin		1010


/* Help menu */
/* BabakJ: Win3.1 help merge */
#define idsHelpIndex		-30
#define idsHelpSearch		-29
#define idsHelpUsing		-28
#define idsAbout		2000

/* INTERNATIONAL: Ignore the stuff below */

#define idmSol		        1

/* ------ Dialog Boxes ----- */
#define iddAbout		    100
#define iddBacks		    101
#define iddGameNo		    102
#define iddOptions		    103

#define ideGameNoEdit		200

/* Options */
#define ideDrawOne		    300
#define ideDrawThree		301
#define ideScoreStandard	302
#define ideScoreVegas		303
#define ideScoreNone		304
#define ideTimedGame		305
#define ideStatusBar		306
#define ideOutlineDrag		307
#define ideKeepScore		308
#define ideBitmap		    309
#define ideScore		    310


#define idsStatLast         idsAbout


// CS help for the two dialogs in Solitaire--Deck and Options //

//Deck (Card Back)
#define IDH_SELECT_CARD_BACK            100

//Options//
#define IDH_OPTIONS_DRAW                101
#define IDH_OPTIONS_SCORING             102
#define IDH_OPTIONS_TIMED_GAME          103
#define IDH_OPTIONS_STATUS_BAR          104
#define IDH_OPTIONS_OUTLINE_DRAGGING    105
#define IDH_OPTIONS_CUMULATIVE_SCORE    106
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\std.h ===
#include <memory.h>


typedef INT X;
typedef INT Y;
typedef INT DX;
typedef INT DY;


#define fTrue  1
#define fFalse 0

/* PoinT structure */
typedef struct _pt
{
    X x;
    Y y;
} PT;



/* DEL structure */
typedef struct _del
{
    DX dx;
    DY dy;
} DEL;


/* ReCt structure  */
typedef struct _rc
{
    X xLeft;
    Y yTop;
    X xRight;
    Y yBot;
} RC;


#ifdef DEBUG
#define VSZASSERT static TCHAR *vszAssert = TEXT(__FILE__);
#define Assert(f) { if (!(f)) { AssertFailed(vszAssert, __LINE__); } }
#define SideAssert(f) { if (!(f)) { AssertFailed(vszAssert, __LINE__); } }
#else
#define Assert(f)
#define SideAssert(f) (f)
#define VSZASSERT
#endif

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

VOID *PAlloc(INT cb);
VOID FreeP( VOID * );

TCHAR *PszCopy(TCHAR *pszFrom, TCHAR *rgchTo);
INT CchDecodeInt(TCHAR *rgch, INT_PTR w);
VOID Error(TCHAR *sz);
VOID ErrorIds(INT ids);
INT WMin(INT w1, INT w2);
INT WMax(INT w1, INT w2);
// INT WParseLpch(TCHAR[ 	]*FAR[ 	]***plpch);
BOOL FInRange(INT w, INT wFirst, INT wLast);
INT PegRange(INT w, INT wFirst, INT wLast);
VOID NYI( VOID );
INT CchString(TCHAR *sz, INT ids, UINT cchBuf);
VOID InvertRc(RC *prc);
VOID OffsetPt(PT *ppt, DEL *pdel, PT *pptDest);
BOOL FRectAllVisible(HDC hdc, RC *prc);

// Removed so it will build on NT...<chriswil>
//
// INT APIENTRY MulDiv( INT, INT, INT );


#ifdef DEBUG
VOID AssertFailed(TCHAR *szFile, INT li);
#endif

#define bltb(pb1, pb2, cb) memcpy(pb2, pb1, cb)


extern HWND hwndApp;
extern HANDLE hinstApp;



BOOL FWriteIniString(INT idsTopic, INT idsItem, TCHAR *szValue);
BOOL FWriteIniInt(INT idsTopic, INT idsItem, DWORD w);
BOOL FGetIniString(INT idsTopic, INT idsItem, TCHAR *sz, TCHAR *szDefault, INT cchMax);
DWORD GetIniInt(INT idsTopic, INT idsItem, DWORD wDefault);



VOID CrdRcFromPt(PT *ppt, RC *prc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\stat.c ===
#include "sol.h"
VSZASSERT

#define dyStatMarg 1
#define dxStatMarg 4

static TCHAR szStatClass[] = TEXT("Stat");    // class name

HWND hwndStat = NULL;      // window to status area
static INT dyStat;         // height of status window


BOOL FRegisterStat(BOOL fFirstInst)
{
    WNDCLASS cls;
    LRESULT APIENTRY StatWndProc(HWND, UINT, WPARAM, LPARAM );

    /* ?? can I use static class? */
    if(fFirstInst)
    {
        cls.style = 0,
        cls.lpfnWndProc = StatWndProc;
        cls.cbClsExtra = cls.cbWndExtra = 0;
        cls.hInstance = hinstApp;
        cls.hIcon = NULL;
        cls.hCursor = LoadCursor(NULL, IDC_ARROW);
        cls.hbrBackground = GetStockObject(WHITE_BRUSH);
        cls.lpszMenuName = NULL;
        cls.lpszClassName = (LPTSTR)szStatClass;
        if (!RegisterClass((LPWNDCLASS)&cls))
            return(fFalse);
    }
    return fTrue;
}


BOOL FCreateStat()
{
    RC rc;

    dyStat = dyChar+2*dyStatMarg;
    GetClientRect(hwndApp, (LPRECT) &rc);
    hwndStat = CreateWindow((LPTSTR) szStatClass, TEXT(""),
                WS_BORDER|WS_CHILD|CS_HREDRAW|CS_VREDRAW,
                rc.xLeft-1, rc.yBot-dyStat+1, rc.xRight-rc.xLeft+2, dyStat, hwndApp,
                NULL, hinstApp, NULL);


    ShowWindow(hwndStat, SW_SHOWNOACTIVATE);
    UpdateWindow(hwndStat);
    return fTrue;
}



BOOL FDestroyStat()
{
    if(hwndStat)
    {
        DestroyWindow(hwndStat);
        hwndStat = NULL;
    }
    return fTrue;
}


LRESULT APIENTRY StatWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT paint;
    HDC hdc;
    VOID StatRender();

    switch(wm)
    {
        case WM_PAINT:
            BeginPaint(hwnd, (LPPAINTSTRUCT) &paint);
            hdc = HdcSet(paint.hdc, 0, 0);
            StatRender();
            HdcSet(hdc, 0, 0);
            EndPaint(hwnd, (LPPAINTSTRUCT) &paint);
            return(0L);
    }

    return(DefWindowProc(hwnd, wm, wParam, lParam));
}


VOID StatRender()
{
    RC rc;

    if(pgmCur != NULL && hwndStat != NULL)
    {
        GetClientRect(hwndStat, (LPRECT) &rc);
        rc.xRight -= dxStatMarg;
        SendGmMsg(pgmCur, msggDrawStatus, (INT_PTR) &rc, 0);
    }
}


VOID StatUpdate()
{
    HDC hdc;
    HDC hdcSav;

    if(hwndStat == NULL)
        return;
    if((hdc = GetDC(hwndStat)) != NULL)
    {
        hdcSav = HdcSet(hdc, 0, 0);
        StatRender();
        HdcSet(hdcSav, 0, 0);
        ReleaseDC(hwndStat, hdc);
    }
}


VOID StatMove()
{
    RC rc;

    if(hwndStat != NULL)
    {
        GetClientRect(hwndApp, (LPRECT) &rc);
        MoveWindow(hwndStat, rc.xLeft-1, rc.yBot-dyStat+1, rc.xRight-rc.xLeft+2, dyStat, fTrue);
        InvalidateRect(hwndStat, NULL, fTrue);
    }
}


VOID StatStringSz(TCHAR *sz)
{
    HDC hdc, hdcSav;
    RC rc;

    if(hwndStat == NULL)
            return;
    hdc = GetDC(hwndStat);
    if(hdc == NULL)
            return;
    hdcSav =        HdcSet(hdc, 0, 0);
    GetClientRect(hwndStat, (LPRECT) &rc);
    PatBlt(hdcCur, rc.xLeft, rc.yTop, rc.xRight-rc.xLeft, rc.yBot-rc.yTop, PATCOPY);
    TextOut(hdcCur, dxStatMarg, 0, sz, lstrlen(sz));
    StatRender();
    HdcSet(hdcSav, 0, 0);
   ReleaseDC(hwndStat, hdc);
}


VOID StatString(INT ids)
{
    TCHAR sz[60];

    if(ids != idsNil)
        CchString(sz, ids, ARRAYSIZE(sz));
    else
        sz[0] = TEXT('\000');

    StatStringSz(sz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\undo.c ===
#include "sol.h"
VSZASSERT



BOOL FInitUndo(UDR *pudr)
{
    INT icol;

    pudr->fAvail = fFalse;

    for(icol = 0; icol < 2; icol++)
         if((pudr->rgpcol[icol] = PcolCreate(NULL, 0, 0, 0, 0, icrdUndoMax)) == NULL)
        {
            if(icol != 0)
                FreeP(pudr->rgpcol[0]);
            return fFalse;
        }
    return fTrue;
}
    

VOID FreeUndo(UDR *pudr)
{
    INT icol;

    for(icol = 0; icol < 2; icol++)
        FreeP(pudr->rgpcol[icol]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\undo.h ===
/* UnDo Record  */
typedef struct _udr
{
	BOOL fAvail;
    BOOL fEndDeck;
	INT sco;
	INT icol1, icol2;
    INT irep;
	COL *rgpcol[2];
} UDR;


BOOL FInitUndo(UDR *pudr);
VOID FreeUndo(UDR *pudr);



#define icrdUndoMax 52
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\sol\util.c ===
#include "sol.h"
VSZASSERT




VOID *PAlloc(INT cb)
{
    TCHAR *p;

    // KLUDGE: solve overwriting memory by allocating more
    #define MEMORYPAD 200
    p = (TCHAR *)LocalAlloc(LPTR, cb+MEMORYPAD);
    Assert(p != NULL);
    return (VOID *)p;
}


VOID FreeP(VOID *p)
{
    LocalFree((HANDLE) p);
}



VOID InvertRc(RC *prc)
{
    Assert(xOrgCur == 0);
    Assert(yOrgCur == 0);
    AssertHdcCur();

    InvertRect(hdcCur, (LPRECT) prc);
}


VOID DrawCard(CRD *pcrd)
{
    AssertHdcCur();
    cdtDrawExt( hdcCur,
                pcrd->pt.x-xOrgCur,
                pcrd->pt.y-yOrgCur,
                dxCrd,
                dyCrd,
                pcrd->fUp ? pcrd->cd : modeFaceDown,
                pcrd->fUp ? FACEUP : FACEDOWN,
                rgbTable);
}


VOID DrawOutline(PT *ppt, INT ccrd, DX dx, DY dy)
{
    Y y;
    PT pt;
    INT rop2;
    if(!FGetHdc())
        return;

    pt = *ppt;

    rop2 = SetROP2(hdcCur, R2_NOT);
    MMoveTo(hdcCur, pt.x, pt.y);
    LineTo(hdcCur, pt.x+dxCrd, pt.y);
    LineTo(hdcCur, pt.x+dxCrd, y = pt.y+dyCrd+(ccrd-1) * dy);
    LineTo(hdcCur, pt.x, y);
    LineTo(hdcCur, pt.x, pt.y);
    y = pt.y;
    while(--ccrd)
    {
        y += dy;
        MMoveTo(hdcCur, pt.x, y);
        LineTo(hdcCur, pt.x+dxCrd, y);
    }
    SetROP2(hdcCur, rop2);
    ReleaseHdc();
}

VOID DrawCardPt(CRD *pcrd, PT *ppt)
{
    DWORD dwModeExt=0;     // turn on sign bit if moving fast
                           // cdtDrawExt must support this!

    if( fKlondWinner )
    {
        dwModeExt= MINLONG;
    }

    AssertHdcCur();
    cdtDrawExt(hdcCur,
               ppt->x-xOrgCur,
               ppt->y-yOrgCur,
               dxCrd,
               dyCrd,
               pcrd->fUp ? pcrd->cd : modeFaceDown,
               (pcrd->fUp ? FACEUP : FACEDOWN ) | dwModeExt,
               rgbTable);
}

VOID DrawCardExt(PT *ppt, INT cd, INT mode)
{
    VOID DrawBackground();

    AssertHdcCur();

    cdtDrawExt( hdcCur,
                ppt->x-xOrgCur,
                ppt->y-yOrgCur,
                dxCrd,
                dyCrd,
                cd,
                mode,
                rgbTable);
}


VOID DrawBackground(X xLeft, Y yTop, X xRight, Y yBot)
{
    HBRUSH hbr;


    AssertHdcCur();
    MSetBrushOrg(hdcCur, xOrgCur, yOrgCur);
    MUnrealizeObject(hbrTable);
    if((hbr = SelectObject(hdcCur, hbrTable)) != NULL)
    {
        Assert(xRight >= xLeft);
        Assert(yBot >= yTop);
        PatBlt( hdcCur,
                xLeft-xOrgCur,
                yTop-yOrgCur,
                xRight-xLeft,
                yBot-yTop,
                PATCOPY);
        SelectObject(hdcCur, hbr);
    }
}


VOID EraseScreen(VOID)
{
    RC rc;
    HDC HdcSet();

    if(!FGetHdc())
        return;
    GetClientRect(hwndApp, (LPRECT) &rc);
    DrawBackground(rc.xLeft, rc.yTop, rc.xRight, rc.yBot);
    ReleaseHdc();
}





BOOL FPtInCrd(CRD *pcrd, PT pt)
{

    return(pt.x >= pcrd->pt.x && pt.x < pcrd->pt.x+dxCrd &&
             pt.y >= pcrd->pt.y && pt.y < pcrd->pt.y+dyCrd);
}




BOOL FRectIsect(RC *prc1, RC *prc2)
{
    RC rcDummy;

    return(IntersectRect((LPRECT) &rcDummy, (LPRECT) prc1, (LPRECT) prc2));
}


VOID CrdRcFromPt(PT *ppt, RC *prc)
{
    prc->xRight = (prc->xLeft = ppt->x) + dxCrd;
    prc->yBot = (prc->yTop = ppt->y) + dyCrd;
}


BOOL FCrdRectIsect(CRD *pcrd, RC *prc)
{
    RC rcDummy;
    RC rcCrd;

    CrdRcFromPt(&pcrd->pt, &rcCrd);
    return(IntersectRect((LPRECT) &rcDummy, (LPRECT) &rcCrd, (LPRECT) prc));
}

/* BUG: only considers upper left and lower right corners */
/* this is ok for my purposes now, but beware... */
BOOL FRectAllVisible(HDC hdc, RC *prc)
{
    return PtVisible(hdc, prc->xLeft, prc->yTop) && PtVisible(hdc, prc->xRight, prc->yBot);
}


VOID OffsetPt(PT *ppt, DEL *pdel, PT *pptDest)
{
    pptDest->x = ppt->x + pdel->dx;
    pptDest->y = ppt->y + pdel->dy;
}


VOID SwapCards(CRD *pcrd1, CRD *pcrd2)
{
    CRD crdT;

    crdT = *pcrd1;
    *pcrd1 = *pcrd2;
    *pcrd2 = crdT;
}





TCHAR *PszCopy(TCHAR *pszFrom, TCHAR *rgchTo)
{
    while (*rgchTo++ = *pszFrom++)
        ;
    return(rgchTo-1);
}



INT CchDecodeInt(TCHAR *rgch, INT_PTR w)
{
    INT fNeg;
    TCHAR *pch, *pchT;
    TCHAR rgchT[20];

    if (fNeg = w<0)
        w = -w;

    pchT = rgchT;
    do
    {
        *pchT++ = (TCHAR)(TEXT('0') + (TCHAR) (w % 10));
        w /= 10;
    }
    while (w);
    pch = rgch;
    if (fNeg)
        *pch++ = TEXT('-');
    do
        *pch++ = *--pchT;
    while (pchT > rgchT);
    *pch = TEXT('\000');
    return((INT)(pch - rgch));
}

VOID Error(TCHAR *sz)
{

    MessageBox(hwndApp, (LPTSTR)sz, (LPTSTR)szAppName, MB_OK|MB_ICONEXCLAMATION);
}

/* returns fTrue if yes is clicked  */
BOOL FYesNoAlert( INT ids )
{
    TCHAR sz[128];
    INT id;

    CchString(sz, ids, ARRAYSIZE(sz));
    id = MessageBox(hwndApp, sz, szAppName, MB_YESNO|MB_ICONEXCLAMATION);
    return id == IDYES || id == IDOK;
}


VOID ErrorIds(INT ids)
{
    TCHAR sz[128];

    CchString(sz, ids, ARRAYSIZE(sz));
    Error(sz);
}

INT WMin(INT w1, INT w2)
{
    return(w1 < w2 ? w1 : w2);
}


INT WMax(INT w1, INT w2)
{
    return(w1 > w2 ? w1 : w2);
}


BOOL FInRange(INT w, INT wFirst, INT wLast)
{
    Assert(wFirst <= wLast);
    return(w >= wFirst && w <= wLast);
}


INT PegRange(INT w, INT wFirst, INT wLast)
{
    Assert(wFirst <= wLast);
    if(w < wFirst)
        return wFirst;
    else if(w > wLast)
        return wLast;
    else
        return w;
}


VOID OOM()
{
    Error(szOOM);
}

VOID NYI()
{
    Error(TEXT("Not Yet Implemented"));
}

INT CchString(TCHAR *sz, INT ids, UINT cchBuf)
{
    return LoadString(hinstApp, (WORD)ids, (LPTSTR)sz, cchBuf);
}



BOOL FWriteIniString(INT idsTopic, INT idsItem, TCHAR *szValue)
{
    TCHAR szItem[32];
    HKEY  hKey;          // key to our registry root
    LONG  lStatus;       // status from RegCreateKey
    INT   iLen;
    BOOL  fRet = FALSE;

    // create the key
    lStatus = RegCreateKeyEx(HKEY_CURRENT_USER, SOLKEYNAME, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lStatus != ERROR_SUCCESS)
    {
        return FALSE;         // just return quietly
    }

    CchString(szItem, idsItem, ARRAYSIZE(szItem));
    iLen = (lstrlen(szValue)+1) * sizeof(TCHAR);

    // write the key and value to the registry
    if (RegSetValueEx(hKey, szItem, 0, REG_SZ, (BYTE*)szValue, iLen) == ERROR_SUCCESS)    
        fRet = TRUE;
    else
        fRet = FALSE;

    RegCloseKey(hKey);
    return fRet;
}

BOOL FWriteIniInt(INT idsTopic, INT idsItem, DWORD w)
{
    TCHAR szItem[32];
    HKEY  hKey;          // key to our registry root
    LONG  lStatus;       // status from RegCreateKey
    BOOL  fRet = FALSE;

    // create the key
    lStatus = RegCreateKeyEx(HKEY_CURRENT_USER, SOLKEYNAME, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lStatus != ERROR_SUCCESS)
    {
        return FALSE;         // just return quietly
    }

    CchString(szItem, idsItem, ARRAYSIZE(szItem));

    // write the key and value to the registry
    if (RegSetValueEx(hKey, szItem, 0, REG_DWORD, (BYTE*) &w, sizeof(DWORD)) == ERROR_SUCCESS)
       fRet = TRUE;
    else
        fRet = FALSE;

    RegCloseKey(hKey);
    return fRet;

}


BOOL FGetIniString(INT idsTopic, INT idsItem, TCHAR *sz, TCHAR *szDefault, INT cchMax)
{
    TCHAR szItem[32];
    HKEY  hKey;          // key to our registry root
    LONG  lStatus;
    DWORD dwType;

    // open the key 
    lStatus = RegCreateKeyEx(HKEY_CURRENT_USER, SOLKEYNAME, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lStatus != ERROR_SUCCESS)
    {
        CopyMemory(sz, szDefault, min(cchMax, lstrlen(szDefault)+1));
        return TRUE;
    }

    CchString(szItem, idsItem, ARRAYSIZE(szItem));

    if(hKey)
    {
        lStatus= RegQueryValueEx(hKey, szItem, NULL, &dwType, (BYTE*) szDefault, &cchMax);
        RegCloseKey(hKey);

        if(lStatus != ERROR_SUCCESS || dwType != REG_SZ)
        {
            CopyMemory(sz, szDefault, min(cchMax, lstrlen(szDefault)+1));
        }
    }

    return TRUE;
}


DWORD GetIniInt(INT idsTopic, INT idsItem, DWORD wDefault)
{
    TCHAR szItem[32];
    HKEY  hKey;          // key to our registry root
    LONG  lStatus;
    DWORD dwResult = wDefault;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    lStatus = RegCreateKeyEx(HKEY_CURRENT_USER, SOLKEYNAME, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lStatus != ERROR_SUCCESS)
    {
        return wDefault;
    }

    CchString(szItem, idsItem, ARRAYSIZE(szItem));

    if(hKey)
    {
        lStatus = RegQueryValueEx(hKey, szItem, NULL, &dwType, (BYTE*) &dwResult, &dwSize);
        RegCloseKey(hKey);

        if(lStatus != ERROR_SUCCESS || dwType != REG_DWORD)
        {
            dwResult = wDefault;
        }
    }

    return(dwResult);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\grptoreg\sec.h ===
/****************************** Module Header ******************************\
* Module Name: winlogon.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Main header file for winlogon
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winuserp.h>

//
// Include individual module header files
//
#include "secdesc.h"
#include "security.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\grptoreg\grptoreg.c ===
/****************************************************************************

    PROGRAM: grptoreg

    PURPOSE: Move the Program Manager's group files (*.GRP) to the
             registry. Also updates the Program Manager's settings that are
             in progman.ini.

             This program needs to be run in the directory where the .grp
             and progman.ini files reside. It uses progman.ini to update the
             registry, only the group files named in progman.ini will
             be entered into the registry.

             Once this program is run, all that needs to be done is:
             Logoff, then logon again.

    FUNCTIONS:

    COMMENTS:
             Most of the functions were extracted from the Program Manager.
             If the group fromat changes in the Progam Manager, the same
             changes must be done here (and in grptoreg.h). Same thing
             applies where in the registry this information is to be
             stored/read.


    MODIFICATION HISTORY
        Created:  4/10/92       JohanneC

****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "grptoreg.h"

BOOL SaveGroupInRegistry(PGROUP pGroup, BOOL bCommonGrp, BOOL bOverwriteGroup);

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyDwordAlign() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT MyDwordAlign(INT wStrLen)
{
    return ((wStrLen + 3) & ~3);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SizeofGroup_U() - for unicode groups                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
DWORD PASCAL SizeofGroup_U(LPGROUPDEF_U lpgd)
{
    LPPMTAG lptag;
    DWORD cbSeg;
    DWORD cb;

    cbSeg = GlobalSize(lpgd);

    lptag = (LPPMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((DWORD)((PCHAR)lptag - (PCHAR)lpgd +MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb))+4) <= cbSeg
        && lptag->wID == ID_MAGIC
        && lptag->wItem == (int)0xFFFF
        && lptag->cb == (WORD)(MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) + 4)
        && *(PLONG)lptag->rgb == TAG_MAGIC)
      {
        while ((cb = (DWORD)((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)))) <= cbSeg)
          {
            if (lptag->wID == ID_LASTTAG)
                return cb;
            (LPSTR)lptag += lptag->cb;
          }
      }
    return lpgd->cbGroup;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SizeofGroup() - for ansi groups                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/
DWORD SizeofGroup(LPGROUPDEF lpgd)
{
    LPPMTAG lptag;
    WORD cbSeg;
    WORD cb;

    cbSeg = (WORD)GlobalSize(lpgd);

    lptag = (LPPMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((WORD)((PCHAR)lptag - (PCHAR)lpgd +MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb))+4) <= cbSeg
            && lptag->wID == ID_MAGIC
            && lptag->wItem == (int)0xFFFF
            && lptag->cb == (WORD)(MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) + 4)
            && *(PLONG)lptag->rgb == TAG_MAGIC) {

        while ((cb = (WORD)((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)))) <= cbSeg) {
            if (lptag->wID == ID_LASTTAG)
                return (DWORD)cb;
            (LPSTR)lptag += lptag->cb;
        }
    }
    return lpgd->cbGroup;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsGroup() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL PASCAL IsGroup(PSTR p)
{
    if (_strnicmp(p, "GROUP", CCHGROUP) != 0) {;
        return FALSE;
    }

    /*
     * Can't have 0 for first digit
     */
    if (p[5] == '0') {
        return FALSE;
    }

    /*
     * Everything else must be a number
     */
    for (p += CCHGROUP; *p; p++) {
        if (*p < '0' || *p > '9') {
            return FALSE;
        }
    }

    return TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RemoveString() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/
VOID APIENTRY RemoveString(PSTR pString)
{

    PSTR pT = pString + lstrlen(pString) + 1;

    while (*pT)
      {
        while (*pString++ = *pT++)
            ;
      }
    *pString = 0;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StringToEnd() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/
VOID APIENTRY StringToEnd(PSTR pString)
{
    char *pT,*pTT;

    for (pT = pString; *pT; )
        while (*pT++)
            ;
    for (pTT = pString; *pT++ = *pTT++;)
        ;
    *pT = 0;

    RemoveString(pString);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetGroupList() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/
VOID PASCAL GetGroupList(PSTR szList)
{
    char szT[20];
    PSTR pT, pTT, pS;
    INT cGroups;         // The number of Groups= lines.

    GetPrivateProfileString(szGroups, NULL, szNULL, szList, (CGROUPSMAX+1)*8, szINIFile);

    cGroups = 0;

    /*
     * Filter out anything that isn't group#.
     */
    for (pT = szList; *pT; ) {
        AnsiUpper(pT);

        if (IsGroup(pT)) {
            pT += lstrlen(pT) + 1;
            cGroups++;
        } else {
            RemoveString(pT);
        }
    }

    /*
     * Sort the groups
     */
    lstrcpy(szT, "Group");
    for (pT = szGroupsOrder; *pT; ) {
        while (*pT == ' ') {
            pT++;
        }

        if (*pT < '0' || *pT > '9') {
            break;
        }

        pTT = szT + CCHGROUP;
        while (*pT >= '0' && *pT <= '9') {
            *pTT++ = *pT++;
        }
        *pTT=0;

        for (pS = szList; *pS; pS += lstrlen(pS) + 1) {
            if (!lstrcmpi(pS,szT)) {
                StringToEnd(pS);
                cGroups--;
                break;
            }
        }
    }

    /*
     * Move any remaining groups to the end of the list so that they load
     * last and appear on top of everything else - keeps DOS based install
     * programs happy.
     */
    while (cGroups>0) {
        StringToEnd(szList);
        cGroups--;
    }

}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateGroupHandle() -                                                   */
/*                                                                          */
/* Creates a discarded handle for use as a group handle... on the first     */
/* LockGroup() the file will be loaded.                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HANDLE PASCAL CreateGroupHandle(void)
{
  HANDLE hGroup;

  if (hGroup = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE, 1L))
      GlobalDiscard(hGroup);

  return(hGroup);
}

/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  LockGroup() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/
LPGROUPDEF PASCAL LockGroup(PGROUP pGroup)

{
  LPGROUPDEF lpgd;
  int        cbGroup;
  int        fh;
  PSTR       psz;

  psz = pGroup->lpKey;

  /* Find and open the group file. */
  fh = _open(pGroup->lpKey, O_RDONLY | O_BINARY);
  if (fh == -1) {
      goto LGError1;
  }

  /* Find the size of the file by seeking to the end. */
  cbGroup = (WORD)_lseek(fh, 0L, SEEK_END);
  if (cbGroup < sizeof(GROUPDEF)) {
      goto LGError2;
  }

  _lseek(fh, 0L, SEEK_SET);

  /* Allocate some memory for the thing. */
  if (!(pGroup->hGroup = GlobalReAlloc(pGroup->hGroup, (DWORD)cbGroup, GMEM_MOVEABLE))) {
      psz = NULL;
      goto LGError2;
  }

  lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

  /* Read the whole group file into memory. */
  if (_read(fh, (PSTR)lpgd, cbGroup) != cbGroup)
      goto LGError3;

  if (lpgd->dwMagic == GROUP_MAGIC) {
      /* Validate the group file by checking the magic bytes and the checksum. */
      if (lpgd->cbGroup > (WORD)cbGroup)
          goto LGError3;
  }
  else if (lpgd->dwMagic == GROUP_UNICODE) {
      LPGROUPDEF_U lpgd_U;

      lpgd_U = (LPGROUPDEF_U)lpgd;
      if (lpgd_U->cbGroup > (DWORD)cbGroup) {
          goto LGError3;
      }
  }
  else {
      goto LGError3;
  }

  /* Now return the pointer. */
  _close(fh);
  return(lpgd);

LGError3:
  GlobalUnlock(pGroup->hGroup);
  GlobalDiscard(pGroup->hGroup);

LGError2:
  _close(fh);

LGError1:
  return(NULL);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  UnlockGroup() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/
void PASCAL UnlockGroup(PGROUP pGroup)
{
    GlobalUnlock(pGroup->hGroup);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindFreeIndex() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/
WORD FindFreeIndex(BOOL bCommonGrp)
{
    WORD wIndex;
    LPSTR pszT;
    WORD i;
    static BOOL bFirstTime = TRUE;
    DWORD cbData;

    if (!*szGroupsOrder) {
        cbData = sizeof(szGroupsOrder);
        if (RegQueryValueEx(hkeyPMSettings, szOrder, 0, 0, szGroupsOrder, &cbData))
            if (!GetPrivateProfileString(szSettings, szOrder, szNULL, szGroupsOrder, sizeof(szGroupsOrder), szINIFile)) {
                pGroupIndexes[1] = 1;
                return(1);
            }
    }

    if (bFirstTime) {
        bFirstTime = FALSE;

        /* Initialize the array to zero since we are 1 based */
        for (i = 1; i <= CGROUPSMAX; i++) {
             pGroupIndexes[i] = 0;
        }

        pszT = szGroupsOrder;
        while(*pszT) {

            /* Skip blanks */
            while (*pszT == ' ')
                pszT++;

            /* Check for NULL */
            if (!(*pszT))
                break;

            if ( (bCommonGrp && *pszT == 'C') ||
                 (!bCommonGrp && *pszT != 'C') ) {

                if (bCommonGrp)
                    pszT++;

                wIndex = 0;

                for (; *pszT && *pszT!=' '; pszT++) {
                    wIndex *= 10;
                    wIndex += *pszT - '0';
                }
                pGroupIndexes[wIndex] = wIndex;

            } else {
                /* Skip to next entry */
                while (*pszT && *pszT != ' ')
                    pszT++;
            }
        }
    }
    for (i = 1; i <= CGROUPSMAX; i++) {
        if (pGroupIndexes[i] != i) {
            pGroupIndexes[i] = i;
            return(i);
        }
    }

    if (i > CGROUPSMAX) { // too many groups
        return((WORD)-1);
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RemoveBackslashFromKeyName() -                                          */
/*                                                                          */
/*  replace the invalid characters for a key name by some valid charater.   */
/*  the same characters that are invalid for a file name are invalid for a  */
/*  key name.                                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void RemoveBackslashFromKeyName(LPSTR lpKeyName)
{
    LPSTR lpt;

    for (lpt = lpKeyName; *lpt; lpt++) {
        if ((*lpt == '\\') || (*lpt == ':') || (*lpt == '>') || (*lpt == '<') ||
             (*lpt == '*') || (*lpt == '?') ){
            *lpt = '.';
        }
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  LoadGroup() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

PGROUP PASCAL LoadGroup(PSTR pGroupFile, WORD wIndex, BOOL bCommonGrp)
{
    PGROUP pGroup;
    LPGROUPDEF lpgd;
    char szFmt[] = " %d";
    char szCFmt[] = " C%d";
    char szIndex[5];
    BOOL bNewOrder = FALSE;

    if (!wIndex) {
        wIndex = FindFreeIndex(bCommonGrp);
        bNewOrder = TRUE;
    }

    pGroup = (PGROUP)LocalAlloc(LPTR,sizeof(GROUP));
    if (!pGroup) {
        return NULL;
    }

    pGroup->hGroup = CreateGroupHandle();
    pGroup->pItems = NULL;
    pGroup->hbm    = NULL;
    pGroup->wIndex = wIndex;

    pGroup->lpKey = (PSTR)LocalAlloc(LPTR, lstrlen(pGroupFile) + 1);
    pGroup->fLoaded = FALSE;

    if (!pGroup->lpKey) {
        GlobalFree(pGroup->hGroup);
        LocalFree((HANDLE)pGroup);
        return NULL;
    }

    lstrcpy(pGroup->lpKey, pGroupFile);

    /*
     * Note that we're about to load a group for the first time.
     * NB Stting this tells LockGroup that the caller can handle the errors.
     */
    lpgd = LockGroup(pGroup);

    /*
     * The group has been loaded or at least we tried.
     */
    if (!lpgd) {
LoadFail:
        LocalFree((HANDLE)pGroup->lpKey);
        GlobalFree(pGroup->hGroup);
        LocalFree((HANDLE)pGroup);
        return NULL;
    }

    /*
     * test if it is a Windows 3.1 group file format. If so it is not
     * valid in WIN32. In Windows 3.1 RECT and POINT are WORD instead of LONG.
     */

    if ( lpgd->dwMagic == GROUP_MAGIC &&
         ((lpgd->rcNormal.left != (INT)(SHORT)lpgd->rcNormal.left) ||
         (lpgd->rcNormal.right != (INT)(SHORT)lpgd->rcNormal.right) ||
         (lpgd->rcNormal.top != (INT)(SHORT)lpgd->rcNormal.top) ||
         (lpgd->rcNormal.bottom != (INT)(SHORT)lpgd->rcNormal.bottom) )){
        /* The group file is invalid. */
        UnlockGroup(pGroup);
        goto LoadFail;
    }

    /*
     * In the registry, the group's key is it's title.
     */
    if (lpgd->dwMagic == GROUP_MAGIC) {
        LocalFree(pGroup->lpKey);
        if (pGroup->lpKey = (PSTR)LocalAlloc(LPTR, lstrlen(PTR(lpgd, lpgd->pName)) + 1))
            lstrcpy(pGroup->lpKey, PTR(lpgd, lpgd->pName));
        RemoveBackslashFromKeyName(pGroup->lpKey);
    }
    else if (lpgd->dwMagic == GROUP_UNICODE){
        LPGROUPDEF_U lpgd_U;
        ANSI_STRING AnsiString;
        UNICODE_STRING UniString;

        lpgd_U = (LPGROUPDEF_U)lpgd;

        RtlInitUnicodeString(&UniString, (LPWSTR)(PTR(lpgd_U, lpgd_U->pName)));
        RtlUnicodeStringToAnsiString(&AnsiString, &UniString, TRUE);

        LocalFree(pGroup->lpKey);
        if (pGroup->lpKey = (PSTR)LocalAlloc(LPTR, lstrlen(AnsiString.Buffer) + 1))
            lstrcpy(pGroup->lpKey, AnsiString.Buffer);
        RemoveBackslashFromKeyName(pGroup->lpKey);
        RtlFreeAnsiString(&AnsiString);
    }

    UnlockGroup(pGroup);

    if (bNewOrder) {
        if (bCommonGrp)
            wsprintf(szIndex, szCFmt, wIndex);
        else
            wsprintf(szIndex, szFmt, wIndex);
        lstrcat(szGroupsOrder, szIndex);
        RegSetValueEx(hkeyPMSettings, szOrder, 0, REG_SZ, szGroupsOrder,
                                lstrlen(szGroupsOrder)+1);
    }
    return(pGroup);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  UnloadGroup() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void PASCAL UnloadGroup(PGROUP pGroup)
{
    PITEM pItem, pItemNext;

    // Free the group segment.
    GlobalFree(pGroup->hGroup);

    // Free the local stuff.
    LocalFree((HANDLE)pGroup->lpKey);

    // The item data.
    for (pItem = pGroup->pItems; pItem; pItem = pItemNext) {
        pItemNext = pItem->pNext;
        LocalFree((HANDLE) pItem);
    }

    // Lastly, free the group structure itself.
    LocalFree((HANDLE)pGroup);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  LoadAllGroups() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/
VOID PASCAL LoadAllGroups()
{
    PSTR pT, pszT;
    char szGroupList[(CGROUPSMAX+1)*8];
    WORD wIndex;
    char szPath[120];
    PGROUP pGroup;

    pT = szGroupList;
    for (GetGroupList(pT); *pT; pT += (lstrlen(pT) + 1)) {
        if (!GetPrivateProfileString(szGroups, pT, szNULL, szPath,
                sizeof(szPath), szINIFile)) {
            continue;
        }

        wIndex = 0;
        for (pszT = pT + CCHGROUP; *pszT; pszT++) {
            wIndex *= 10;
            wIndex += *pszT - '0';
        }

        pGroup = LoadGroup(szPath, wIndex, FALSE);
        if (pGroup) {
            SaveGroupInRegistry(pGroup, FALSE, FALSE);
            UnloadGroup(pGroup);
        }
        else {
            bNoError = FALSE;
            wsprintf(szMessage, "An error has occurred reading group file %s, no registry update.\n",
                     szPath);
            printf(szMessage);
        }
    }
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SaveGroupInRegistry() -                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL SaveGroupInRegistry(PGROUP pGroup, BOOL bCommonGrp, BOOL bOverwriteGroup)
{
    LPGROUPDEF lpgd;
    int cb;
    int err;
    char szT[66];
    static char szFmt[] = "Group%d";
    HKEY hkey;
    HKEY hkeyGroups;
    PSECURITY_ATTRIBUTES pSecAttr;
    DWORD dwDisposition;
    HANDLE hEvent;


    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
    if (!lpgd)
        return FALSE;

    if (bCommonGrp) {
        hkeyGroups = hkeyCommonGroups;
        pSecAttr = pCGrpSecAttr;
    }
    else {
        hkeyGroups = hkeyProgramGroups;
        pSecAttr = pPGrpSecAttr;
    }

    while(1) {
        if (err = RegCreateKeyEx(hkeyGroups, pGroup->lpKey, 0, 0, 0,
                                  DELETE | KEY_READ | KEY_WRITE, pSecAttr,
                                  &hkey, &dwDisposition)) {
            goto Exit1;
        }
        if (dwDisposition == REG_CREATED_NEW_KEY) {
            break;
        }
        if (dwDisposition == REG_OPENED_EXISTING_KEY) {
            if (!bOverwriteGroup) {
                RegCloseKey(hkey);
                wsprintf(szMessage, "Could not save the group %s in the registry. The group already exists.", pGroup->lpKey);
                printf(szMessage);
                return(FALSE);
            }
            else {
                RegCloseKey(hkey);
                if (RegDeleteKey(hkeyGroups, pGroup->lpKey) != ERROR_SUCCESS) {
                    wsprintf(szMessage, "Could not save the group %s in the registry. The group already exists.", pGroup->lpKey);
                    printf(szMessage);
                    return(FALSE);
                }
            }
        }
    }


    /* update groups section. */
    wsprintf(szT, szFmt, pGroup->wIndex);
    RegSetValueEx(hkeyPMGroups, szT, 0, REG_SZ, (LPBYTE)pGroup->lpKey, lstrlen(pGroup->lpKey)+1);

    if (lpgd->dwMagic == GROUP_MAGIC) {
        cb = SizeofGroup(lpgd);
    }
    else {
        cb = SizeofGroup_U((LPGROUPDEF_U)lpgd);
    }

    err = RegSetValueEx(hkey, NULL, 0, REG_BINARY, (LPTSTR)lpgd, cb);

    hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, "Progman.GroupValueSet");
    if (hEvent) {
        SetEvent(hEvent);
    }

    RegFlushKey(hkey);
    RegCloseKey(hkey);

Exit1:
    GlobalUnlock(pGroup->hGroup);

    if (err) {
        bNoError = FALSE;
        wsprintf(szMessage, "Could not save the group %s in the registry.", pGroup->lpKey);
        printf(szMessage);
    }
    GlobalDiscard(pGroup->hGroup);
    return(!err);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadSettings() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL ReadSettings()
{

  OFSTRUCT of;
  CHAR szT[MAX_PATH];

  lstrcpy(szT, ".\\");
  lstrcat(szT, szINIFile);
  if (OpenFile(szT, &of, OF_EXIST) == -1) {
      // set the current directory to the windows directory
      GetWindowsDirectory(szT, MAX_PATH);
      SetCurrentDirectory(szT);
  }
  if (OpenFile(szINIFile, &of, OF_EXIST) == -1) {
      return(FALSE);
  }
  bMinOnRun = GetPrivateProfileInt(szSettings, szMinOnRun, bMinOnRun, szINIFile);
  bAutoArrange = GetPrivateProfileInt(szSettings, szAutoArrange, bAutoArrange, szINIFile);
  bSaveSettings = GetPrivateProfileInt(szSettings, szSaveSettings, bSaveSettings, szINIFile);
  GetPrivateProfileString(szSettings, szWindow, szNULL, szPMWindowSetting, sizeof(szPMWindowSetting), szINIFile);
  GetPrivateProfileString(szSettings, szStartup, szNULL, szStartupGroup, sizeof(szStartupGroup), szINIFile);

  fNoRun = GetPrivateProfileInt(szRestrict, szNoRun, FALSE, szINIFile);
  fNoClose = GetPrivateProfileInt(szRestrict, szNoClose, FALSE, szINIFile);
  fNoSave = GetPrivateProfileInt(szRestrict, szNoSave, FALSE, szINIFile);
  fNoFileMenu = GetPrivateProfileInt(szRestrict, szNoFileMenu, FALSE, szINIFile);
  dwEditLevel = GetPrivateProfileInt(szRestrict, szEditLevel, (WORD)0, szINIFile);

  GetPrivateProfileString(szSettings, szOrder, szNULL, szGroupsOrder, sizeof(szGroupsOrder), szINIFile);
  return(TRUE);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SaveSettingsToRegistry() -                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL SaveSettingsToRegistry()
{
    int err;

    if (hkeyPMSettings) {
        err = RegSetValueEx(hkeyPMSettings, szWindow, 0, REG_SZ, szPMWindowSetting,
                                lstrlen(szPMWindowSetting)+1);
        err |= RegSetValueEx(hkeyPMSettings, szOrder, 0, REG_SZ, szGroupsOrder,
                                lstrlen(szGroupsOrder)+1);
        if (*szStartupGroup)
            err |= RegSetValueEx(hkeyPMSettings, szStartup, 0, REG_SZ, szStartupGroup,
                                lstrlen(szStartupGroup)+1);
        err |= RegSetValueEx(hkeyPMSettings, szMinOnRun, 0, REG_DWORD,
                               (LPBYTE)&bMinOnRun, sizeof(bMinOnRun));
        err |= RegSetValueEx(hkeyPMSettings, szAutoArrange, 0, REG_DWORD,
                               (LPBYTE)&bAutoArrange, sizeof(bAutoArrange));
        err |= RegSetValueEx(hkeyPMSettings, szSaveSettings, 0, REG_DWORD,
                               (LPBYTE)&bSaveSettings, sizeof(bSaveSettings));
    }
    if (hkeyPMRestrict) {
        err = RegSetValueEx(hkeyPMRestrict, szNoRun, 0, REG_DWORD,
                               (LPBYTE)&fNoRun, sizeof(fNoRun));
        err |= RegSetValueEx(hkeyPMRestrict, szNoClose, 0, REG_DWORD,
                               (LPBYTE)&fNoClose, sizeof(fNoClose));
        err |= RegSetValueEx(hkeyPMRestrict, szNoSave, 0, REG_DWORD,
                               (LPBYTE)&fNoSave, sizeof(fNoSave));
        err |= RegSetValueEx(hkeyPMRestrict, szNoFileMenu, 0, REG_DWORD,
                               (LPBYTE)&fNoFileMenu, sizeof(fNoFileMenu));
        err |= RegSetValueEx(hkeyPMRestrict, szEditLevel, 0, REG_DWORD,
                               (LPBYTE)&dwEditLevel, sizeof(dwEditLevel));
    }
    return(!err);
}

BOOL AccessToPersonalGroups()
{
    //
    // Initialize security attributes for Personal Groups.
    //
    pPGrpSecAttr = &PGrpSecAttr;
    if (!InitializeSecurityAttributes(pPGrpSecAttr, FALSE))
        pPGrpSecAttr = NULL;

    /*
     * Create/Open the registry keys corresponding to progman.ini sections.
     */
    if (RegCreateKeyEx(HKEY_CURRENT_USER, szProgramManager, 0, szProgramManager, 0,
                         KEY_READ | KEY_WRITE,
                         pPGrpSecAttr, &hkeyProgramManager, NULL)) {
        return(FALSE);
    }

    RegCreateKeyEx(hkeyProgramManager, szSettings, 0, szProgramManager, 0,
                         KEY_READ | KEY_WRITE,
                         pPGrpSecAttr, &hkeyPMSettings, NULL);

    RegCreateKeyEx(hkeyProgramManager, szRestrict, 0, szProgramManager, 0,
                         KEY_READ,
                         pPGrpSecAttr, &hkeyPMRestrict, NULL);

    RegCreateKeyEx(hkeyProgramManager, szGroups, 0, szProgramManager, 0,
                         KEY_READ | KEY_WRITE,
                         pPGrpSecAttr, &hkeyPMGroups, NULL);

    if (RegCreateKeyEx(HKEY_CURRENT_USER, szProgramGroups, 0, szProgramGroups, 0,
                         KEY_READ | KEY_WRITE,
                         pPGrpSecAttr, &hkeyProgramGroups, NULL) ){
        return(FALSE);
    }
    return(TRUE);
}

BOOL AccessToCommonGroups()
{
    //
    // Initialize security attributes for Common Groups.
    //
    pCGrpSecAttr = &CGrpSecAttr;
    if (!InitializeSecurityAttributes(pCGrpSecAttr, TRUE)) {
        pCGrpSecAttr = NULL;
        return(FALSE);
    }

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szCommonGroups, 0, szProgramGroups, 0,
                         KEY_READ | KEY_WRITE | DELETE,
                         pCGrpSecAttr, &hkeyCommonGroups, NULL) ){
        return(FALSE);
    }

    return(TRUE);
}

void Usage()
{
                printf("\nConverts a Windows NT compatible .GRP file into the Registry for use by\n\
Windows NT.  Note that the .GRP file must have been created using REGTOGRP.\n\
GRPTOREG will not accept MS-DOS Windows .GRP files.\n\n\
GRPTOREG [/o] [/c] groupfiles \n\n\
groupfiles   Path to a .GRP file created by REGTOGRP. If more than one file,\n\
             separate by spaces.\n\
/o           If a Program Manager group already exists with the same name as\n\
             groupfile, overwrite it.\n\
/c           Will create a Common group from the groupfile (must have \n\
             administrative privileges), otherwise a personal group is created.\n");

}

int __cdecl
main( argc, argv )
int argc;
char *argv[];
{
    INT i;
    CHAR *cp;
    LPSTR pGroupFile;
    PGROUP pGroup;
    BOOL bCommonGrp = FALSE;
    BOOL bOverwriteGroup = FALSE;

    if (argc > 1) {  // just update specified groups.

        for(i = 1; i < argc && (argv[i][0] == '/' || argv[i][0] == '-'); ++i) {
            for(cp = &argv[i][1]; *cp != '\0'; ++cp) {
            switch(*cp) {
            case 'c':
                //
                // The user wants common groups.
                // First check if the user has permission to create common groups.
                //
                if (AccessToCommonGroups()) {
                    bCommonGrp = TRUE;
                }
                else {
                    wsprintf(szMessage, "You do not have write access to Common Groups. No Groups will be created.");
                    printf(szMessage);
                    goto Exit;
                }
                break;
            case 'o':
                bOverwriteGroup = TRUE;
                break;
            case '?':
            default:
                Usage();
                goto Exit;

            }
            }
       }

       if (!bCommonGrp) {
            //
            // The user wants personal groups.
            // First check if the user has access to the registry to
            // create personal groups in Progman.
            //
            if (!AccessToPersonalGroups()) {
                wsprintf(szMessage, "You do not have write access to the registry. No updates will take place.");
                printf(szMessage);
                goto Exit;
            }

        }

        for (; i < argc; i++) {
            pGroupFile = argv[i];
            pGroup = LoadGroup(pGroupFile, 0, bCommonGrp);
            if (pGroup) {
                SaveGroupInRegistry(pGroup, bCommonGrp, bOverwriteGroup);
                UnloadGroup(pGroup);
            }
            else {
                bNoError = FALSE;
                wsprintf(szMessage, "An error has occurred reading group file %s, no registry update.",
                         pGroupFile);
                printf(szMessage);
            }
        }
    }
    else
        { // update all groups thru progman.ini
        if (hkeyProgramManager) {
            if (!ReadSettings()) {
                bNoError = FALSE;
                wsprintf(szMessage, "The file PROGMAN.INI is not in this directory.");
                printf(szMessage);
            }
            if (bNoError && !SaveSettingsToRegistry()) {
//                wsprintf(szMessage, "An error occured while saving settings to the registry.");
            }
        }
        if (hkeyProgramGroups) {
            bNoError = TRUE;
            LoadAllGroups();
            if (bNoError) {
                wsprintf(szMessage, "Groups were updated successfully to the registry.");
                printf(szMessage);
            }
        }
    }

Exit:

    if (hkeyProgramManager) {
        RegFlushKey(hkeyProgramManager);
        if (hkeyPMSettings)
            RegCloseKey(hkeyPMSettings);
        if (hkeyPMRestrict)
            RegCloseKey(hkeyPMRestrict);
        if (hkeyPMGroups)
            RegCloseKey(hkeyPMGroups);
        if (hkeyProgramManager)
            RegCloseKey(hkeyProgramManager);
    }

    if (hkeyProgramGroups) {
        RegFlushKey(hkeyProgramGroups);
        RegCloseKey(hkeyProgramGroups);
    }

    if (hkeyCommonGroups) {
        RegFlushKey(hkeyCommonGroups);
        RegCloseKey(hkeyCommonGroups);
    }


    //
    // Free up the security descriptor
    //

    if (pPGrpSecAttr) {
        DeleteSecurityDescriptor(pPGrpSecAttr->lpSecurityDescriptor);
    }

    if (pCGrpSecAttr) {
        DeleteSecurityDescriptor(pCGrpSecAttr->lpSecurityDescriptor);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\grptoreg\grptoreg.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

/****************************************************************************/
/*                                                                          */
/*  GRPTOREG.H -                                                            */
/*                                                                          */
/*      Include for the conversion of group files (.grp) to the registry.   */
/*      Extracted from progman.h.                                           */
/*                                                                          */
/*        Created:  4/10/92       JohanneC                                  */
/*                                                                          */
/****************************************************************************/

#include <setjmp.h>
#include <windows.h>

#ifndef RC_INVOKED
#include <port1632.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Typedefs                                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

typedef struct tagITEM {
    struct tagITEM *pNext;              /* link to next item */
    int             iItem;              /* index in group */
    DWORD           dwDDEId;            /* id used for Apps querying Progman */
                                        /* for its properties via DDE */
    RECT            rcIcon;             /* icon rectangle */
    HICON           hIcon;              /* the actual icon */
    RECT            rcTitle;            /* title rectangle */
} ITEM, *PITEM;

typedef struct tagGROUP {
    struct tagGROUP *pNext;               /* link to next group            */
    HWND            hwnd;                 /* hwnd of group window          */
    HANDLE          hGroup;               /* global handle of group object */
    PITEM           pItems;               /* pointer to first item         */
    LPSTR           lpKey;                /* name of group key             */
    WORD            wIndex;               /* index in PROGMAN.INI of group */
    BOOL            fRO;                  /* group file is readonly        */
    FILETIME        ftLastWriteTime;
    HBITMAP         hbm;                  /* bitmap 'o icons               */
    WORD            fLoaded;
} GROUP, *PGROUP;

/*
 * .GRP File format structures -
 */
typedef struct tagGROUPDEF {
    DWORD   dwMagic;        /* magical bytes 'PMCC' */
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    cbGroup;        /* length of group segment */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    nCmdShow;       /* min, max, or normal state */
    WORD    pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */

    WORD    cItems;         /* number of items in group */
    WORD    rgiItems[1];    /* array of ITEMDEF offsets */
} GROUPDEF, *PGROUPDEF;
typedef GROUPDEF *LPGROUPDEF;

//
// New format for UNICODE groups for Windows NT 1.0a
//
typedef struct tagGROUPDEF_U {
    DWORD   dwMagic;        /* magical bytes 'PMCC' */
    DWORD   cbGroup;        /* length of group segment */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    nCmdShow;       /* min, max, or normal state */
    DWORD   pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */

    WORD    cItems;         /* number of items in group */
    WORD    Reserved1;
    DWORD   Reserved2;
    DWORD   rgiItems[1];    /* array of ITEMDEF offsets */
} GROUPDEF_U, *PGROUPDEF_U;
typedef GROUPDEF_U *LPGROUPDEF_U;

/* the pointers in the above structures are short pointers relative to the
 * beginning of the segments.  This macro converts the short pointer into
 * a long pointer including the proper segment/selector value.        It assumes
 * that its argument is an lvalue somewhere in a group segment, for example,
 * PTR(lpgd->pName) returns a pointer to the group name, but k=lpgd->pName;
 * PTR(k) is obviously wrong as it will use either SS or DS for its segment,
 * depending on the storage class of k.
 */
#define PTR(base, offset) (LPSTR)((PBYTE)base + offset)


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Tag Stuff                                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

typedef struct _tag
  {
    WORD wID;                   // tag identifier
    WORD dummy1;                // need this for alignment!
    int wItem;                  // (unde the covers 32 bit point!)item the tag belongs to
    WORD cb;                    // size of record, including id and count
    WORD dummy2;                // need this for alignment!
    BYTE rgb[1];
  } PMTAG, FAR * LPPMTAG;

#define TAG_MAGIC GROUP_MAGIC

    /* range 8000 - 80FF > global
     * range 8100 - 81FF > per item
     * all others reserved
     */

#define ID_MAGIC                0x8000
    /* data: the string 'TAGS'
     */

#define ID_LASTTAG              0xFFFF
    /* the last tag in the file
     */


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Defines                                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* magic number for .GRP file validation
 */
#define GROUP_MAGIC             0x43434D50L  /* 'PMCC' */
#define GROUP_UNICODE           0x43554D50L  /* 'PMUC' */

#define CCHGROUP                5 // length of the string "Group"

#define CGROUPSMAX              40      // The max number of groups allowed.
#define MAXGROUPNAMELEN         30

#define MAX_MESSAGE_LENGTH      100

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Globals                                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL        bMinOnRun           = FALSE;
BOOL        bArranging          = FALSE;
BOOL        bAutoArrange        = FALSE;
BOOL        bSaveSettings       = TRUE;
BOOL        fNoRun              = FALSE;
BOOL        fNoClose            = FALSE;
BOOL        fNoSave             = FALSE;
BOOL        fNoFileMenu         = FALSE;
DWORD       dwEditLevel         = 0;

char        szINIFile[]         = "PROGMAN.INI";
char        szNULL[]            = "";
char        szStartup[]         = "startup";
char        szGroups[]          = "UNICODE Groups";
char        szOrder[]           = "UNICODE Order";
char        szWindow[]          = "Window";
char        szAutoArrange[]     = "AutoArrange";
char        szSaveSettings[]    = "SaveSettings";
char        szMinOnRun[]        = "MinOnRun";
char        szSettings[]        = "Settings";
char        szNoRun[]           = "NoRun";
char        szNoClose[]         = "NoClose";
char        szEditLevel[]       = "EditLevel";
char        szRestrict[]        = "Restrictions";
char        szNoFileMenu[]      = "NoFileMenu";
char        szNoSave[]          = "NoSaveSettings";
char        szSystemBoot[]      = "Boot";
char        szSystemDisplay[]   = "display.drv";
char        szPMWindowSetting[160];
char        szStartupGroup[MAXGROUPNAMELEN+1];
char        szGroupsOrder[CGROUPSMAX*3+7];
WORD        pGroupIndexes[CGROUPSMAX+1];

CHAR        szProgramManager[]  = "Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager";   // registry key for groups
CHAR        szProgramGroups[]   = "UNICODE Program Groups";   // registry key for groups
CHAR        szCommonGroups[]    = "SOFTWARE\\Program Groups";   // registry key for common groups

CHAR        szMessage[MAX_MESSAGE_LENGTH];
BOOL        bNoError            = TRUE;

HKEY hkeyCommonGroups = NULL;
HKEY hkeyProgramGroups = NULL;
HKEY hkeyProgramManager = NULL;
HKEY hkeyPMSettings = NULL;
HKEY hkeyPMRestrict = NULL;
HKEY hkeyPMGroups = NULL;

SECURITY_ATTRIBUTES PGrpSecAttr;                  // for personal groups
PSECURITY_ATTRIBUTES pPGrpSecAttr = NULL;
SECURITY_ATTRIBUTES CGrpSecAttr;                  // for common groups
PSECURITY_ATTRIBUTES pCGrpSecAttr = NULL;

#include "secdesc.h"
#include "security.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\grptoreg\security.c ===
/****************************** Module Header ******************************\
* Module Name: security.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Handles security aspects of winlogon operation.
*
* History:
* 12-05-91 Davidc       Created - mostly taken from old winlogon.c
\***************************************************************************/

#include "sec.h"
#include <winuserp.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>
#include <stdio.h>


/***************************************************************************\
* SetMyAce
*
* Helper routine that fills in a MYACE structure.
*
* History:
* 02-06-92 Davidc       Created
\***************************************************************************/
VOID
SetMyAce(
    PMYACE MyAce,
    PSID Sid,
    ACCESS_MASK Mask,
    UCHAR InheritFlags
    )
{
    MyAce->Sid = Sid;
    MyAce->AccessMask= Mask;
    MyAce->InheritFlags = InheritFlags;
}


/***************************************************************************\
* SetWorldSecurity
*
* Sets the security given the logon sid passed.
*
* If the UserSid = NULL, no access is given to anyone other than world
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
BOOL
SetWorldSecurity(
    PSID    UserSid,
    PSECURITY_DESCRIPTOR *pSecDesc,
    BOOL bCommonGroupAccess
    )
{
    MYACE   Ace[4];
    ACEINDEX AceCount = 0;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSID    WorldSid = NULL;
    PSID    AdminAliasSid = NULL;
    PSID    PowerUserAliasSid = NULL;
    PSID    SystemOpsAliasSid = NULL;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    ACCESS_MASK AccessMask;

    // Create the world Sid
    Status = RtlAllocateAndInitializeSid(
                         &WorldSidAuthority,
                         1,                   // Sub authority count
                         SECURITY_WORLD_RID,  // Sub authorities
                         0, 0, 0, 0, 0, 0, 0,
                         &WorldSid);

    if (!NT_SUCCESS(Status)) {
        DbgOnlyPrint("progman failed to allocate memory for world sid\n");
        return(FALSE);
    }

    Status = RtlAllocateAndInitializeSid(
                         &NtAuthority,
                         2,                            // Sub authority count
                         SECURITY_BUILTIN_DOMAIN_RID,  // Sub authority[0]
                         DOMAIN_ALIAS_RID_ADMINS,      // Sub authority[1]
                         0, 0, 0, 0, 0, 0,
                         &AdminAliasSid);

    Status = RtlAllocateAndInitializeSid(
                         &NtAuthority,
                         2,                            // Sub authority count
                         SECURITY_BUILTIN_DOMAIN_RID,  // Sub authority[0]
                         DOMAIN_ALIAS_RID_POWER_USERS, // Sub authority[1]
                         0, 0, 0, 0, 0, 0,
                         &PowerUserAliasSid);

    Status = RtlAllocateAndInitializeSid(
                         &NtAuthority,
                         2,                            // Sub authority count
                         SECURITY_BUILTIN_DOMAIN_RID,  // Sub authority[0]
                         DOMAIN_ALIAS_RID_SYSTEM_OPS,  // Sub authority[1]
                         0, 0, 0, 0, 0, 0,
                         &SystemOpsAliasSid);


    if (!NT_SUCCESS(Status)) {
        DbgOnlyPrint("progman failed to allocate memory for admin sid\n");
        return(FALSE);
    }



    //
    // Define the World ACEs
    //

    if (bCommonGroupAccess) {
        AccessMask = KEY_READ;
    }
    else {
        AccessMask = KEY_READ | KEY_WRITE | DELETE;
    }

    SetMyAce(&(Ace[AceCount++]),
             WorldSid,
	          AccessMask,
             NO_PROPAGATE_INHERIT_ACE
             );

    //
    // Define the Admins ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             AdminAliasSid,
             GENERIC_ALL,
             NO_PROPAGATE_INHERIT_ACE
             );

    //
    // Define the Power Users ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             PowerUserAliasSid,
             GENERIC_ALL,
             NO_PROPAGATE_INHERIT_ACE
             );

    //
    // Define the System Operators ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             SystemOpsAliasSid,
             GENERIC_ALL,
             NO_PROPAGATE_INHERIT_ACE
             );

    // Check we didn't goof
    ASSERT((sizeof(Ace) / sizeof(MYACE)) >= AceCount);

    //
    // Create the security descriptor
    //

    SecurityDescriptor = CreateSecurityDescriptor(Ace, AceCount);
    if (SecurityDescriptor == NULL) {
        DbgOnlyPrint("Progman failed to create security descriptor\n\r");
        return(FALSE);
    }

#if 0
// Keep security descriptor global
// delete only when exiting the program

    //
    // Free up the security descriptor
    //

    DeleteSecurityDescriptor(SecurityDescriptor);
#endif

    //
    // Return success status
    //

    *pSecDesc = SecurityDescriptor;
    return(TRUE);
}

/***************************************************************************\
* InitializeSecurityAttributes
*
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 04-14092 JohanneC       Created
\***************************************************************************/
BOOL InitializeSecurityAttributes
    (
    PSECURITY_ATTRIBUTES pSecurityAttributes,
    BOOL bCommonGroupAccess
    )
{
    PSECURITY_DESCRIPTOR pSecDesc;

    if (!SetWorldSecurity(NULL, &pSecDesc, bCommonGroupAccess)) {
        return(FALSE);
    }

    pSecurityAttributes->nLength = sizeof(SECURITY_ATTRIBUTES);
    pSecurityAttributes->lpSecurityDescriptor = pSecDesc;
    pSecurityAttributes->bInheritHandle = TRUE;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\grptoreg\secdesc.c ===
/****************************** Module Header ******************************\
* Module Name: secdesc.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Routines that support creation and deletion of security descriptors
*
* History:
* 02-06-92 Davidc       Created.
\***************************************************************************/

#include "sec.h"

//
// Private prototypes
//

PVOID
CreateAccessAllowedAce(
    PSID  Sid,
    ACCESS_MASK AccessMask,
    UCHAR AceFlags,
    UCHAR InheritFlags
    );

VOID
DestroyAce(
    PVOID   Ace
    );



/***************************************************************************\
* CreateSecurityDescriptor
*
* Creates a security descriptor containing an ACL containing the specified ACEs
*
* A SD created with this routine should be destroyed using
* DeleteSecurityDescriptor
*
* Returns a pointer to the security descriptor or NULL on failure.
*
* 02-06-92 Davidc       Created.
\***************************************************************************/

PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    PMYACE  MyAce,
    ACEINDEX AceCount
    )
{
    NTSTATUS Status;
    ACEINDEX AceIndex;
    PACCESS_ALLOWED_ACE *Ace;
    PACL    Acl = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG   LengthAces;
    ULONG   LengthAcl;
    ULONG   LengthSd;

    //
    // Allocate space for the ACE pointer array
    //

    Ace = (PACCESS_ALLOWED_ACE *)Alloc(sizeof(PACCESS_ALLOWED_ACE) * AceCount);
    if (Ace == NULL) {
        DbgOnlyPrint("grptoreg failed to allocated ACE array\n\r");
        return(NULL);
    }

    //
    // Create the ACEs and calculate total ACE size
    //

    LengthAces = 0;
    for (AceIndex=0; AceIndex < AceCount; AceIndex ++) {
        Ace[AceIndex] = CreateAccessAllowedAce(MyAce[AceIndex].Sid,
                                               MyAce[AceIndex].AccessMask,
                                               0,
                                               MyAce[AceIndex].InheritFlags);
        if (Ace[AceIndex] == NULL) {
            DbgOnlyPrint("grptoreg : Failed to allocate ace\n\r");
        } else {
            LengthAces += Ace[AceIndex]->Header.AceSize;
        }
    }

    //
    // Calculate ACL and SD sizes
    //

    LengthAcl = sizeof(ACL) + LengthAces;
    LengthSd  = SECURITY_DESCRIPTOR_MIN_LENGTH;

    //
    // Create the ACL
    //

    Acl = Alloc(LengthAcl);

    if (Acl != NULL) {

        Status = RtlCreateAcl(Acl, LengthAcl, ACL_REVISION);
        ASSERT(NT_SUCCESS(Status));

        //
        // Add the ACES to the ACL and destroy the ACEs
        //

        for (AceIndex = 0; AceIndex < AceCount; AceIndex ++) {

            if (Ace[AceIndex] != NULL) {

                Status = RtlAddAce(Acl, ACL_REVISION, 0, Ace[AceIndex],
                                   Ace[AceIndex]->Header.AceSize);

                if (!NT_SUCCESS(Status)) {
                    DbgOnlyPrint("grptoreg : AddAce failed, status = 0x%lx\n\r", Status);
                }

                DestroyAce(Ace[AceIndex]);
            }
        }

    } else {
        DbgOnlyPrint("grptoreg : Failed to allocate ACL\n\r");
    }

    //
    // Free the ACE pointer array
    //
    Free(Ace);

    //
    // Create the security descriptor
    //

    SecurityDescriptor = Alloc(LengthSd);

    if (SecurityDescriptor != NULL) {

        Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
        ASSERT(NT_SUCCESS(Status));

        //
        // Set the DACL on the security descriptor
        //
        Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor, TRUE, Acl, FALSE);
        if (!NT_SUCCESS(Status)) {
            DbgOnlyPrint("grptoreg : SetDACLSD failed, status = 0x%lx\n\r", Status);
        }
    } else {
        DbgOnlyPrint("grptoreg : Failed to allocate security descriptor\n\r");
    }

    //
    // Return with our spoils
    //
    return(SecurityDescriptor);
}


/***************************************************************************\
* DeleteSecurityDescriptor
*
* Deletes a security descriptor created using CreateSecurityDescriptor
*
* Returns TRUE on success, FALSE on failure
*
* 02-06-92 Davidc       Created.
\***************************************************************************/

BOOL
DeleteSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    NTSTATUS Status;
    PACL    Acl;
    BOOLEAN Present;
    BOOLEAN Defaulted;

    ASSERT(SecurityDescriptor != NULL);

    //
    // Get the ACL
    //
    Status = RtlGetDaclSecurityDescriptor(SecurityDescriptor,
                                          &Present, &Acl, &Defaulted);
    if (NT_SUCCESS(Status)) {

        //
        // Destroy the ACL
        //
        if (Present && (Acl != NULL)) {
            Free(Acl);
        }
    } else {
        DbgOnlyPrint("grptoreg : Failed to get DACL from security descriptor being destroyed, Status = 0x%lx\n\r", Status);
    }

    //
    // Destroy the Security Descriptor
    //
    Free(SecurityDescriptor);

    return(TRUE);
}


/***************************************************************************\
* CreateAccessAllowedAce
*
* Allocates memory for an ACCESS_ALLOWED_ACE and fills it in.
* The memory should be freed by calling DestroyACE.
*
* Returns pointer to ACE on success, NULL on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PVOID
CreateAccessAllowedAce(
    PSID  Sid,
    ACCESS_MASK AccessMask,
    UCHAR AceFlags,
    UCHAR InheritFlags
    )
{
    ULONG   LengthSid = RtlLengthSid(Sid);
    ULONG   LengthACE = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + LengthSid;
    PACCESS_ALLOWED_ACE Ace;

    Ace = (PACCESS_ALLOWED_ACE)Alloc(LengthACE);
    if (Ace == NULL) {
        DbgOnlyPrint("grptoreg : CreateAccessAllowedAce : Failed to allocate ace\n\r");
        return NULL;
    }

    Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize = (USHORT)LengthACE;
    Ace->Header.AceFlags = AceFlags | InheritFlags;
    Ace->Mask = AccessMask;
    RtlCopySid(LengthSid, (PSID)(&(Ace->SidStart)), Sid );

    return(Ace);
}


/***************************************************************************\
* DestroyAce
*
* Frees the memory allocate for an ACE
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
VOID
DestroyAce(
    PVOID   Ace
    )
{
    Free(Ace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\grptoreg\secdesc.h ===
/****************************** Module Header ******************************\
* Module Name: secdesc.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines apis and types used to implement security descriptor helper routines
*
* History:
* 02-06-92 Davidc       Created.
\***************************************************************************/

//
// Types used by security descriptor helper routines
//

typedef LONG    ACEINDEX;
typedef ACEINDEX *PACEINDEX;

typedef struct _MYACE {
    PSID    Sid;
    ACCESS_MASK AccessMask;
    UCHAR   InheritFlags;
} MYACE;
typedef MYACE *PMYACE;


//
// Exported function prototypes
//

PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    PMYACE  MyAce,
    ACEINDEX AceCount
    );

BOOL
DeleteSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\grptoreg\security.h ===
/****************************** Module Header ******************************\
* Module Name: security.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define various winlogon security-related routines
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


BOOL
SetWorldSecurity(
    PSID    UserSid,
    PSECURITY_DESCRIPTOR *pSecDesc,
    BOOL bCommonGroupAccess
    );

BOOL InitializeSecurityAttributes(
    PSECURITY_ATTRIBUTES pSecurityAttributes,
    BOOL bCommonGroupAccess
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\grptoreg\util.h ===
/****************************** Module Header ******************************\
* Module Name: winutil.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define windows utility functions
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//


PVOID
Alloc(
    ULONG
    );

ULONG
GetAllocSize(
    PVOID
    );

BOOL
Free(
    PVOID
    );
//
// Define a print routine that only prints on a debug system
//
#if DBG
#define DbgOnlyPrint    DbgPrint
#else
#define DbgOnlyPrint
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\inc\apwizhlp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1994
*
*  TITLE:	APWIZHLP.H
*
*  VERSION:	1.0
*
*  AUTHOR:	RAL
*
*  DATE:	11/8/94
*
*  Help IDs for Add/Remove Programs.
*  NOTE:  These IDs are reserved in the HELP.H file.  The IDs refer to entries
*	  in the main windows help file.
*
*******************************************************************************/


#ifndef _INC_APWIZHLP
#define _INC_APWIZHLP

//  Net install page
#define IDH_APPWIZ_NETINSTALL_INSTRUCT	5600
#define IDH_APPWIZ_NETINSTALL_LIST	5601
#define IDH_APPWIZ_NETINTALLL_BUTTON	5602

// Install/Uninstall Page
#define IDH_APPWIZ_DISKINSTALL_INSTRUCT 5610
#define IDH_APPWIZ_DISKINTALLL_BUTTON	5611
#define IDH_APPWIZ_UNINSTALL_INSTRUCT	5612
#define IDH_APPWIZ_UNINSTALL_LIST	5613
#define IDH_APPWIZ_UNINSTALL_BUTTON	5614

// Windows Setup page
#define IDH_APPWIZ_WINSETUP_INSTRUCT	5620
#define IDH_APPWIZ_WINSETUP_LIST	5621

// Startup Disk page
#define IDH_APPWIZ_STARTDISK_INSTRUCT	5630
#define IDH_APPWIZ_STARTDISK_BUTTON	5631

#endif // _INC_APWIZHLP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\grptoreg\util.c ===
/****************************** Module Header ******************************\
* Module Name: winutil.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implements windows specific utility functions
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

#include "sec.h"
#include <string.h>
#include <stdio.h>


/****************************************************************************

   FUNCTION: Alloc

   PURPOSE: Allocates memory to hold the specified number of bytes

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID Alloc(
    ULONG   Bytes)
{
    HANDLE  hMem;
    PVOID   Buffer;

    hMem = LocalAlloc(LMEM_MOVEABLE, Bytes + sizeof(hMem));

    if (hMem == NULL) {
        return(NULL);
    }

    // Lock down the memory
    //
    Buffer = LocalLock(hMem);
    if (Buffer == NULL) {
        LocalFree(hMem);
        return(NULL);
    }

    //
    // Store the handle at the start of the memory block and return
    // a pointer to just beyond it.
    //

    *((PHANDLE)Buffer) = hMem;

    return (PVOID)(((PHANDLE)Buffer)+1);
}


/****************************************************************************

   FUNCTION:  GetAllocSize

   PURPOSE: Returns the allocated size of the specified memory block.
            The block must have been previously allocated using Alloc

   RETURNS : Size of memory block in bytes or 0 on error

****************************************************************************/

ULONG GetAllocSize(
    PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    return(LocalSize(hMem) - sizeof(hMem));
}


/****************************************************************************

   FUNCTION: Free

   PURPOSE: Frees the memory previously allocated with Alloc

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL Free(
    PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    LocalUnlock(hMem);

    return(LocalFree(hMem) == NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\inc\oledbshl.h ===
//+-------------------------------------------------------------------------
//
//  OLEDBSHL
//  Copyright (C) Microsoft, 1995
//
//  File:       oledbshl.h
//
//  Contents:   External exports of functions and types, in C style
//              for consumers like shell32.dll
//
//  History:    6-26-95  Davepl  Created
//
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {            
#endif                  

HRESULT COFSFolder_CreateFromIDList(LPCITEMIDLIST pidl, REFIID riid, LPVOID * ppvOut);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\inc\apperr.h ===
// Help IDs for Windows 95 incompatibility errors.

#define IDH_HDC			1000
#define IDH_DOIT		1001
#define IDH_SCREENCAM		1002
#define IDH_PEACHTREE		1003
#define IDH_PHOTOSHOP		1004
//#define IDH_UNUSED		1005
//#define IDH_SIMPLYMONEY	1006
#define IDH_STAC		1007
#define IDH_CRYSTALWALLS	1008
#define IDH_GEN_DISKUTIL	1009
#define IDH_GEN_VIRUS		1010
#define IDH_ADT20		1011
#define IDH_VBSETUP		1012
// #define IDH_UNUSED		1013
#define IDH_MPCWIZ20		1014
#define IDH_WIN31SHELL		1015
#define IDH_WINNT		1016
#define IDH_WSS20SETUP		1017
#define IDH_TABWORKS		1018
#define IDH_CPANTIVIRUS         1019
#define IDH_DAVINCI             1020
#define IDH_DIRECTORLAB         1021
#define IDH_FAMILYTREE          1022
#define IDH_ICONHEARIT          1023
#define IDH_MAXTIME             1024
#define IDH_MSMAIL              1025
#define IDH_NTNETTOOL           1026
// no longer used #define IDH_OUTPOST             1027 
#define IDH_PCANYWHERE          1028
#define IDH_PCXWARE             1029
#define IDH_PFSWW               1030
#define IDH_PRINTCACHE          1031
#define IDH_TDWIN               1032
#define IDH_TRUEEFFECTS         1033
#define IDH_UNCPRINT            1034
#define IDH_WIRED               1035
#define IDH_WORDVIEW            1036
#define IDH_THUMBELINA		1037
#define IDH_APPMAN		1038
#define	IDH_REMINDME		1039
#define	IDH_ACROREAD		1040
#define	IDH_BSTONE		1041
#define	IDH_RACKMNT		1042
#define	IDH_REBEL2		1043
#define	IDH_SECURE		1044
#define	IDH_SPACEMAN		1045
#define	IDH_SUPERPCK		1046
#define	IDH_TYPESTRY		1047
#define	IDH_WINPROBE		1048
#define	IDH_PCTOOLS		1049
#define IDH_SSTOR		1050
#define IDH_DBLTOOLS		1051
#define IDH_WINHOST		1052
#define IDH_RAVEN		1053
#define IDH_ADOBEVUE		1054
#define CHANGE_VIDEO_DRIVER	1055
#define IDH_EARTHC		1056
#define EARTH_CARE_RUN_COMMAND	1057
#define EARTH_CARE_PROGRAMS_MENU	1058
// no longer used #define IDH_ADMINWIN		1059
#define IDH_3DHOME		1060
#define IDH_MSFONT		1061
#define IDH_TIMELINE		1062
#define IDH_CINSTALL		1063
// no longer used #define IDH_ALDSETUP            1064
#define IDH_HUMONGOUS           1065
#define IDH_SCW                 1066
#define IDH_UPFRONT             1067
#define IDH_PROXY               1068
#define IDH_WANDERLINK          1069
#define IDH_PIM                 1070
#define IDH_WFSOUND             1071
#define IDH_PERFORMPRO          1072
#define IDH_RPSHOST             1073
#define IDH_AMIPRO              1074
#define IDH_STACOPTM            1075
#define IDH_BOUNDS              1076
#define IDH_CLWORKS             1077
#define IDH_NORTONAVIRUS        1078
#define IDH_NDESKTOPW           1079
#define IDH_NORTUTIL            1080
#define IDH_NORTONCMDR          1081
#define IDH_GENSAVEWORK        1082
#define IDH_GENPRINTWIZ         1083
#define IDH_GENBROKEN           1084
#define IDH_GENHIGHCOLOR        1085
#define IDH_GENHIGHRESOLUTION   1086
#define IDH_GENREALMODENET      1087
#define IDH_GENOLDDRIVER        1088
#define IDH_GENOLDCONFIGUTIL    1089
#define IDH_GENRELNOTES         1090
#define IDH_GENMSDOSMODE        1091
#define IDH_GENUNSTABLE         1092
#define IDH_GENLONGPRINTERNAME  1093
#define IDH_GENEMSMEMORY        1094
#define IDH_FAMOUSPLACES        1095
#define IDH_TREKMANUALINSTALL   1096
#define IDH_LANDSOFLOREINSTALL  1097
#define IDH_MARTIANMEMORANDUM   1098
#define IDH_GUARDIANSOFEDEN     1099
#define IDH_CAMERAMAN           1100
#define IDH_DRAGONSLAIRCD       1101
#define IDH_SHADOWCASTER        1102
#define IDH_TIMEACTIVATORINSTALL 1103
#define IDH_ALISTAIRINSTALL     1104
#define IDH_INTELPROSHARE       1105
#define IDH_IBMWINSETUP         1106
#define IDH_SOUNDSET            1107
#define IDH_SIERRA              1108
#define IDH_CCMail              1109
#define IDH_CLICKBOOKS          1110
#define IDH_LIGHTNING           1111
#define IDH_MSMOUSE             1112
#define IDH_DBWDEBUG            1113
#define IDH_RIBBIT              1114
#define IDH_PPOCR               1115
#define IDH_FORTRAN77           1116
#define IDH_EXECUVOICE          1117
#define IDH_AYS                 1118
// no longer used #define IDH_MOREPCXWARE         1119
#define IDH_GROUPWISE           1120
#define IDH_LANDESK             1121
#define IDH_NOVELL_NETWARE_USER_TOOLS             1122
#define IDH_QUICKTIME           1123
#define IDH_EXCEL               1124
#define IDH_PLACE_HOLDER_ONE    1125
#define IDH_PLACE_HOLDER_TWO    1126
#define IDH_PLACE_HOLDER_THREE  1127
#define IDH_PLACE_HOLDER_FOUR   1128
#define IDH_PLACE_HOLDER_FIVE   1129
#define IDH_PLACE_HOLDER_SIX    1130
#define IDH_PLACE_HOLDER_SEVEN  1131
#define IDH_PLACE_HOLDER_EIGHT  1132
#define IDH_PLACE_HOLDER_NINE   1133
#define IDH_PLACE_HOLDER_TEN    1134
#define IDH_PLACE_HOLDER_ELEVEN 1135
#define IDH_PLACE_HOLDER_TWELVE 1136
#define IDH_PLACE_HOLDER_THIRTEEN                1137
#define IDH_PLACE_HOLDER_FOURTEEN                1138
#define IDH_PLACE_HOLDER_FIFTEEN                 1139
#define IDH_PLACE_HOLDER_SIXTEEN                 1140
#define IDH_PLACE_HOLDER_SEVENTEEN               1141
#define IDH_PLACE_HOLDER_EIGHTEEN                1142
#define IDH_PLACE_HOLDER_NINETEEN                1143
#define IDH_PLACE_HOLDER_TWENTY                  1144
#define IDH_PLACE_HOLDER_TWENTYONE               1145
#define IDH_PLACE_HOLDER_TWENTYTWO               1146
#define IDH_GENPRINTERDRIVER                     1147
#define IDH_LD_CP_EXE                            1148
#define IDH_LAPLINK				 1149
#define IDH_GENTRAY				 1150
#define IDH_PROSHARE				 1151
#define IDH_GENNOPIF				 1152
#define IDH_GEN_BACKUP				 1153
#define IDH_CPBACKUP				 1154
#define IDH_QUICKBOOKS                           1155
#define IDH_GENNOPIF                             1156
#define IDH_FORTRANPS                            1157
#define IDH_GEN_DSHELL                           1158
#define IDH_GEN_DSHELL	                         1159
#define	IDH_NAVIGATOR	                         1160
#define IDH_REFLECTION_X                         1161
#define IDH_POINTER_EXE                          1162
#define IDH_QUALITYPE                            1163
#define IDH_MS_SOUND_SYS_20C                     1164
#define IDH_UNINSTALLER	                         1165
#define IDH_WINMODE                              1166
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\inc\uconvert.h ===
/***************************************************************
*
*  UCONVERT - Unicode File conversion
*
*
*  Author: Asmus Freytag
*
*  Copyright (C) 1991, Microsoft Corporation
*-----------------------------------------------------
* header file for Uconvert */

#ifdef UNICODE

#define BUFFER_TOO_SMALL                0x0005

#define ISUNICODE_ASCII16               0x0001
#define ISUNICODE_REVERSE_ASCII16       0x0010
#define ISUNICODE_STATISTICS            0x0002
#define ISUNICODE_REVERSE_STATISTICS    0x0020
#define ISUNICODE_CONTROLS              0x0004
#define ISUNICODE_REVERSE_CONTROLS      0x0040

#define ISUNICODE_SIGNATURE             0x0008
#define ISUNICODE_REVERSE_SIGNATURE     0x0080

#define ISUNICODE_ILLEGAL_CHARS         0x0100
#define ISUNICODE_ODD_LENGTH            0x0200

#define ISUNICODE_NULL_BYTES            0x1000

#define ISUNICODE_UNICODE_MASK          0x000F
#define ISUNICODE_REVERSE_MASK          0x00F0
#define ISUNICODE_NOT_UNICODE_MASK      0x0F00
#define ISUNICODE_NOT_ASCII_MASK        0xF000

#define UNICODE_FFFF              0xFFFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

#define PARAGRAPH_SEPARATOR       0x2029
#define LINE_SEPARATOR            0x2028


#define UNICODE_TAB               0x0009
#define UNICODE_LF                0x000A
#define UNICODE_CR                0x000D
#define UNICODE_SPACE             0x0020
#define UNICODE_CJK_SPACE         0x3000

#define UNICODE_R_TAB             0x0900
#define UNICODE_R_LF              0x0A00
#define UNICODE_R_CR              0x0D00
#define UNICODE_R_SPACE           0x2000
#define UNICODE_R_CJK_SPACE       0x0030  /* Ambiguous - same as ASCII '0' */

#define ASCII_CRLF                0x0A0D


BOOL IsUnicode  (LPTSTR lpBuff, int iSize, LPINT lpiResult);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\inc\uniconv.h ===
/****************************************************************************/
/*                                                                          */
/*  UNICONV.H -                                                             */
/*                                                                          */
/*       My special Unicode workaround file                                 */
/*                                                                          */
/*       Created by      :       Diane K. Oh                                */
/*       On Date         :       June 11, 1992                              */
/*                                                                          */
/*       File was created to Unicode enable special function calls of       */
/*       WIN32 Shell applications.                                          */
/*                                                                          */
/****************************************************************************/

#include <string.h>
#include <tchar.h>
#ifdef UNICODE
#include <wchar.h>
#else
#include <ctype.h>
#endif


/*--------------------------------------------------------------------------*/
/*  Macros                                                                  */
/*--------------------------------------------------------------------------*/

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

/*--------------------------------------------------------------------------*/
/*  Constants                                                               */
/*--------------------------------------------------------------------------*/

#define   UNICODE_FONT_NAME        TEXT("Lucida Sans Unicode")
#define   UNICODE_FIXED_FONT_NAME  TEXT("Lucida Console")

/*--------------------------------------------------------------------------*/
/*  Function Templates                                                      */
/*--------------------------------------------------------------------------*/

INT      MyAtoi          (LPTSTR string);
LONG     MyAtol          (LPTSTR  string);
LPTSTR   MyItoa          (INT value, LPTSTR string, INT radix);
LPTSTR   MyUltoa         (unsigned long value, LPTSTR string, INT radix);
VOID     MySplitpath     (LPTSTR path, LPTSTR drive, LPTSTR dir,
                          LPTSTR fname, LPTSTR ext);

LPTSTR   SkipProgramName (LPTSTR lpCmdLine);


HANDLE   MyOpenFile      (LPTSTR lpszFile, TCHAR * lpszPath, DWORD fuMode);
BOOL     MyCloseFile     (HANDLE hFile);
BOOL     MyAnsiReadFile  (HANDLE hFile, UINT uCodePage, LPVOID lpBuffer, DWORD nChars);
BOOL     MyByteReadFile  (HANDLE hFile, LPVOID lpBuffer, DWORD nBytes);
BOOL     MyAnsiWriteFile (HANDLE hFile, UINT uCodePage, LPVOID lpBuffer, DWORD nChars);
BOOL     MyByteWriteFile (HANDLE hFile, LPVOID lpBuffer, DWORD nBytes);
LONG     MyFileSeek      (HANDLE hFile, LONG lDistanceToMove, DWORD dwMoveMethod);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\debug\debug.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       debug.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//				following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//				 7-Oct-94   BruceFo		Stole and ripped out everything except
//                                      debug prints and asserts.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)


#if DBG == 1

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif


// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF void APINOT
   InitializeDebugging(
	   void);

#ifdef __cplusplus
}
#endif // __cplusplus

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Win4Verify(x) Win4Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif


# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char* comp##InfoLevelString = #comp;


# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
# define Win4Verify(x)  (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\guids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       guids.h
//
//  Contents:   Guids local to this directory
//
//  History:    26-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#ifndef __GUIDS_H__
#define __GUIDS_H__

DEFINE_GUID(CLSID_CNetObj, 0x59be4990, 0xf85c, 0x11ce, 0xaf, 0xf7, 0x00, 0xaa, 0x00, 0x3c, 0xa9, 0xf6);

#endif // __GUIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\dllmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       dllmain.cxx
//
//  Contents:   DLL initialization entrypoint and global variables
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//--------------------------------------------------------------------------
// Globals used elsewhere

UINT        g_NonOLEDLLRefs = 0;
HINSTANCE   g_hInstance = NULL;

//--------------------------------------------------------------------------
// Debugging

DECLARE_INFOLEVEL(NetObjectsUI)

//--------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Win32 DLL initialization function
//
//  Arguments:  [hInstance] - Handle to this dll
//              [dwReason]  - Reason this function was called.  Can be
//                            Process/Thread Attach/Detach.
//
//  Returns:    BOOL    - TRUE if no error.  FALSE otherwise
//
//  History:    4-Apr-95 BruceFo  Created
//
//---------------------------------------------------------------------------

extern "C"
BOOL
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
#if DBG == 1
        InitializeDebugging();
//         NetObjectsUIInfoLevel = DEB_ERROR | DEB_TRACE;
        NetObjectsUIInfoLevel = DEB_ERROR;
        SetWin4AssertLevel(ASSRT_BREAK | ASSRT_MESSAGE);
#endif // DBG == 1

        appDebugOut((DEB_TRACE, "ntlanui2.dll: DllMain enter\n"));

        // Disable thread notification from OS
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance;
        InitCommonControls();
        break;
    }

    case DLL_PROCESS_DETACH:
        appDebugOut((DEB_TRACE, "ntlanui2.dll: DllMain leave\n"));
        break;
    }

    return TRUE;
}

extern HRESULT PropDummyFunction();
HRESULT Linkage()
{
    return PropDummyFunction();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\debug\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//
//----------------------------------------------------------------------------

#if DBG == 1

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

//////////////////////////////////////////////////////////////////////////////

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//////////////////////////////////////////////////////////////////////////////

static int _cdecl w4dprintf(const char *format, ...);
static int _cdecl w4vdprintf(const char *format, va_list arglist);

//////////////////////////////////////////////////////////////////////////////

static CRITICAL_SECTION s_csMessageBuf;
static char g_szMessageBuf[500];		// this is the message buffer

static int _cdecl w4dprintf(const char *format, ...)
{
	int ret;

    va_list va;
    va_start(va, format);
	ret = w4vdprintf(format, va);
    va_end(va);

	return ret;
}


static int _cdecl w4vdprintf(const char *format, va_list arglist)
{
	int ret;

	EnterCriticalSection(&s_csMessageBuf);
	ret = vsprintf(g_szMessageBuf, format, arglist);
	OutputDebugStringA(g_szMessageBuf);
	LeaveCriticalSection(&s_csMessageBuf);
	return ret;
}

//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   Win4AssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

EXPORTIMP void APINOT
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

		_asdprintf("%s File: %s Line: %u, thread id %d\n",
            szMessage, szFile, iLine, tid);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

EXPORTIMP int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{
    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);

    id = MessageBoxA(NULL,
                     szMsg,
                     szAssertCaption,
                     MB_SETFOREGROUND
						| MB_DEFAULT_DESKTOP_ONLY
						| MB_TASKMODAL
						| MB_ICONEXCLAMATION
						| MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(NULL,
                             szMsg,
                             szAssertCaption,
                             MB_SETFOREGROUND
								| MB_SERVICE_NOTIFICATION
								| MB_TASKMODAL
								| MB_ICONEXCLAMATION
								| MB_OKCANCEL);
        }
    }

    return id;
}


//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

static CRITICAL_SECTION s_csDebugPrint;

EXPORTIMP void APINOT
vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
		EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                printf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            vprintf(ppszfmt, pargs);
        }

		LeaveCriticalSection(&s_csDebugPrint);
    }
}

void APINOT InitializeDebugging(void)
{
	InitializeCriticalSection(&s_csMessageBuf);
	InitializeCriticalSection(&s_csDebugPrint);
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\helpids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define IDH_NET_NETWORK                    100
#define IDH_NET_SERVER                     101
#define IDH_NET_COMMENT                    102
#define IDH_NET_WORKGROUP_OR_DOMAIN_NAME   103
#define IDH_NET_TYPE                       104
#define IDH_NET_SHARE                      105

#define IDH_NET_WORKGROUP_OR_DOMAIN_NAME_2 IDH_NET_WORKGROUP_OR_DOMAIN_NAME
#define IDH_NET_WRKGRP_TYPE                IDH_NET_NETWORK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\makefile.inc ===
app.rc: $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        resource.h \
        $(O)\messages.h \
        $(O)\messages.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\ext.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ext.cxx
//
//  Contents:   Shell extension handler for network objects
//
//  Classes:    CNetObj
//
//  History:    26-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <pages.hxx>

#define DONT_WANT_SHELLDEBUG
#include <shlobjp.h>

#include "resource.h"
#include "ext.hxx"
#include "util.hxx"

//--------------------------------------------------------------------------
//
// Shell DLL communication
//

typedef
UINT
(WINAPI *SHELLGETNETRESOURCE)(
    HNRES hnres,
    UINT iItem,
    LPNETRESOURCE pnresOut,
    UINT cbMax
    );

HINSTANCE g_hShellLibrary = NULL;
SHELLGETNETRESOURCE g_pFuncGNR = NULL;
UINT g_cfNetResource = 0;

BOOL LoadShellDllEntries(VOID);

//--------------------------------------------------------------------------


/*
 * Helper functions used to communicate with shell32.dll
 */

BOOL LoadShellDllEntries(VOID)
{
    if (g_hShellLibrary)
    {
        return TRUE;
    }

    g_hShellLibrary = LoadLibrary(TEXT("shell32.dll"));
    if (NULL == g_hShellLibrary)
    {
        return FALSE;
    }

    g_pFuncGNR = (SHELLGETNETRESOURCE)GetProcAddress(g_hShellLibrary, (LPSTR)IntToPtr(SHGetNetResourceORD));
    if (NULL == g_pFuncGNR)
    {
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::CNetObj
//
//  Synopsis:   Constructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CNetObj::CNetObj(
    VOID
    )
    :
    _uRefs(0),
    _pDataObject(NULL),
    _hkeyProgID(NULL)
{
    INIT_SIG(CNetObj);

    AddRef(); // give it the correct initial reference count. add to the DLL reference count
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::~CNetObj
//
//  Synopsis:   Destructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CNetObj::~CNetObj()
{
    CHECK_SIG(CNetObj);

    if (_pDataObject)
    {
        _pDataObject->Release();
    }

    if (_hkeyProgID)
    {
        LONG l = RegCloseKey(_hkeyProgID);
        if (l != ERROR_SUCCESS)
        {
            appDebugOut((DEB_ERROR, "CNetObj::destructor. Error closing registry key, 0x%08lx\n", l));
        }
        _hkeyProgID = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::Initialize
//
//  Derivation: IShellExtInit
//
//  Synopsis:   Initialize the shell extension. Stashes away the argument data.
//
//  History:    4-Apr-95    BruceFo  Created
//
//  Notes:      This method can be called more than once.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CNetObj::Initialize(
    LPCITEMIDLIST   pidlFolder,
    LPDATAOBJECT    pDataObject,
    HKEY            hkeyProgID
    )
{
    CHECK_SIG(CNetObj);

    CNetObj::~CNetObj();

    if (!LoadShellDllEntries())
    {
        return E_FAIL;
    }

    // Duplicate the pDataObject pointer
    _pDataObject = pDataObject;
    if (pDataObject)
    {
        pDataObject->AddRef();
    }

    // Duplicate the handle
    if (hkeyProgID)
    {
        LONG l = RegOpenKeyEx(hkeyProgID, NULL, 0L, MAXIMUM_ALLOWED, &_hkeyProgID);
        if (l != ERROR_SUCCESS)
        {
            appDebugOut((DEB_ERROR, "CNetObj::Initialize. Error duplicating registry key, 0x%08lx\n", l));
        }
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::AddPages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (from shlobj.h)
//              "The explorer calls this member function when it finds a
//              registered property sheet extension for a particular type
//              of object. For each additional page, the extension creates
//              a page object by calling CreatePropertySheetPage API and
//              calls lpfnAddPage.
//
//  Arguments:  lpfnAddPage -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CNetObj::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam
    )
{
    CHECK_SIG(CNetObj);

    //
    // Call IDataObject::GetData asking for a g_cfNetResource (i.e., HNRES).
    //
    STGMEDIUM medium;
    FORMATETC fmte =
    {
        g_cfNetResource
            ? g_cfNetResource
            : (g_cfNetResource = RegisterClipboardFormat(CFSTR_NETRESOURCES)),
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };
    appAssert(NULL != _pDataObject);
    HRESULT hr = _pDataObject->GetData(&fmte, &medium);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        return hr;
    }

    ///////////////// Now I have a 'medium' to release

    hr = S_OK;

    HNRES hnres = medium.hGlobal;

    // Get number of selected items
    if (NULL != g_pFuncGNR)
    {
        UINT cItems = (*g_pFuncGNR)(hnres, (UINT)-1, NULL, 0);
        if (cItems > 0)
        {
            // Retrieve NETRESOURCE object from clipboard
            LPNETRESOURCE pNetRes = (LPNETRESOURCE)_bufNetResource;
            UINT ret = (*g_pFuncGNR)(hnres, 0, pNetRes, MAX_ONE_RESOURCE); // Get first item
            if (ret == 0)
            {
                // bad hnres?
                appDebugOut((DEB_TRACE, "CNetObj::AddPages. SHGetNetResource returned 0\n"));
                // NOTE: this is really error
            }
            else if (ret > MAX_ONE_RESOURCE)
            {
                // FEATURE: Resize the buf and try again
                appDebugOut((DEB_TRACE, "CNetObj::AddPages. buffer too small, needs to be %d\n", ret));
            }
            else
            {
                LPTSTR pszTemplate = NULL;

                if (RESOURCEDISPLAYTYPE_NETWORK == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_NETWORK_SUMMARYINFO);
                }
                else if (RESOURCEDISPLAYTYPE_DOMAIN == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_WRKGRP_SUMMARYINFO);
                }
                else if (RESOURCEDISPLAYTYPE_SERVER == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_SERVER_SUMMARYINFO);
                }
                else if (RESOURCEDISPLAYTYPE_SHARE == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_SHARE_SUMMARYINFO);
                }
                else
                {
                    appDebugOut((DEB_TRACE, "CNetObj::AddPages. Unknown net resource type!\n"));
                }

                //
                //  Create a property sheet page object from a dialog box.
                //

                if (NULL != pszTemplate)
                {
                    FillAndAddPage(
                            lpfnAddPage,
                            lParam,
                            CPage::DlgProcPage,
                            pszTemplate);
                }
            }
        }
        else
        {
            appDebugOut((DEB_TRACE, "CNetObj::AddPages. NO net resources!\n"));
            // NOTE: this is really error
        }
    }
    else
    {
        appDebugOut((DEB_TRACE, "CNetObj::AddPages. No SHGetNetResource function!\n"));
        // NOTE: this is really error
    }

    ReleaseStgMedium(&medium);
    return hr;
}

BOOL
CNetObj::FillAndAddPage(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    DLGPROC pfnDlg,
    LPTSTR pszTemplate
    )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);  // no extra data.
    psp.dwFlags     = PSP_USEREFPARENT;
    psp.hInstance   = g_hInstance;
    psp.pszTemplate = pszTemplate;
    psp.hIcon       = NULL;
    psp.pszTitle    = NULL;
    psp.pfnDlgProc  = pfnDlg;
    psp.pfnCallback = NULL;
    psp.pcRefParent = &g_NonOLEDLLRefs;

    //
    // We need to backlink ourselves because we are using member variable
    // of this class.
    //
    psp.lParam      = (LPARAM)this;
    this->AddRef();

    hpage = CreatePropertySheetPage(&psp);
    if (NULL != hpage)
    {
        if (!lpfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
        }
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::ReplacePages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (From shlobj.h)
//              "The explorer never calls this member of property sheet
//              extensions. The explorer calls this member of control panel
//              extensions, so that they can replace some of default control
//              panel pages (such as a page of mouse control panel)."
//
//  Arguments:  uPageID -- Specifies the page to be replaced.
//              lpfnReplace -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CNetObj::ReplacePage(
    UINT                 uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM               lParam
    )
{
    CHECK_SIG(CNetObj);

    appAssert(!"CNetObj::ReplacePage called, not implemented");
    return E_NOTIMPL;
}


// dummy function to export to get linking to work
HRESULT PropDummyFunction()
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\ole.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       ole.cxx
//
//  Contents:   Class factory, etc, for all OLE objects
//
//  History:    25-Sep-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <initguid.h>
#include "guids.h"

#include "ole.hxx"
#include "ext.hxx"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

ULONG g_ulcInstancesNetObj = 0;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CNetObj::QueryInterface(
    IN REFIID riid,
    OUT LPVOID* ppvObj
    )
{
    appDebugOut((DEB_ITRACE, "CNetObj::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*)(IShellExtInit*) this;    // doesn't matter which
    }
    else
    if (IsEqualIID(IID_IShellExtInit, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IShellExtInit\n"));
        pUnkTemp = (IShellExtInit*) this;
    }
    else
    if (IsEqualIID(IID_IShellPropSheetExt, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IShellPropSheetExt\n"));
        pUnkTemp = (IShellPropSheetExt*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}

STDMETHODIMP_(ULONG)
CNetObj::AddRef(
    VOID
    )
{
    InterlockedIncrement((LONG*)&g_ulcInstancesNetObj);
    InterlockedIncrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE,
        "CNetObj::AddRef, local: %d, DLL: %d\n",
        _uRefs,
        g_ulcInstancesNetObj));

    return _uRefs;
}

STDMETHODIMP_(ULONG)
CNetObj::Release(
    VOID
    )
{
    InterlockedDecrement((LONG*)&g_ulcInstancesNetObj);
    ULONG cRef = InterlockedDecrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE,
        "CNetObj::Release, local: %d, DLL: %d\n",
        _uRefs,
        g_ulcInstancesNetObj));

    if (0 == cRef)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CNetObjCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CNetObjCF::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*) this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IClassFactory\n"));
        pUnkTemp = (IClassFactory*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}


STDMETHODIMP_(ULONG)
CNetObjCF::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstancesNetObj);

    appDebugOut((DEB_ITRACE,
        "CNetObjCF::AddRef, DLL: %d\n",
        g_ulcInstancesNetObj));

    return g_ulcInstancesNetObj;
}

STDMETHODIMP_(ULONG)
CNetObjCF::Release()
{
    InterlockedDecrement((LONG*)&g_ulcInstancesNetObj);

    appDebugOut((DEB_ITRACE,
        "CNetObjCF::Release, DLL: %d\n",
        g_ulcInstancesNetObj));

    return g_ulcInstancesNetObj;
}

STDMETHODIMP
CNetObjCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CNetObjCF::CreateInstance\n"));

    if (pUnkOuter != NULL)
    {
        // don't support aggregation
        return E_NOTIMPL;
    }

    CNetObj* pNetObj = new CNetObj();
    if (NULL == pNetObj)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pNetObj->QueryInterface(riid, ppvObj);
    pNetObj->Release();

    if (FAILED(hr))
    {
        hr = E_NOINTERFACE; // FEATURE: Whats the error code?
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP
CNetObjCF::LockServer(BOOL fLock)
{
    //
    // FEATURE: Whats supposed to happen here?
    //
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDAPI
DllCanUnloadNow(
    VOID
    )
{
    if (0 == g_ulcInstancesNetObj
        && 0 == g_NonOLEDLLRefs
        )
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

CNetObjCF cfNetObj;

STDAPI
DllGetClassObject(
    REFCLSID cid,
    REFIID iid,
    LPVOID* ppvObj
    )
{
    appDebugOut((DEB_TRACE, "DllGetClassObject\n"));

    HRESULT hr = E_NOINTERFACE;

    if (IsEqualCLSID(cid, CLSID_CNetObj))
    {
        hr = cfNetObj.QueryInterface(iid, ppvObj);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       util.cxx
//
//  Contents:   Misc helper functions
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "util.hxx"

//////////////////////////////////////////////////////////////////////////////

#define NETMSG_DLL TEXT("netmsg.dll")

//////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             g_hInstance,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        WCHAR szText[200];
        LoadString(g_hInstance, IDS_APP_MSG_NOT_FOUND, szText, ARRAYLEN(szText));
        wsprintf(pszBuffer,szText,dwMsgId);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyCommonDialog
//
//  Synopsis:   Common popup dialog routine - stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyCommonDialog(
    IN HWND    hwnd,
    IN HRESULT dwMsgCode,
    IN PWSTR   pszCaption,
    IN DWORD   dwFlags,
    IN va_list arglist
    )
{
    WCHAR szMsgBuf[500];

    MyFormatMessageText(dwMsgCode, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    return MessageBox(hwnd, szMsgBuf, pszCaption, dwFlags);
}



//+-------------------------------------------------------------------------
//
//  Function:   MyErrorDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
VOID
MyErrorDialog(
    IN HWND hwnd,
    IN HRESULT dwErrorCode,
    ...
    )
{
    WCHAR szCaption[100];
    va_list arglist;

    va_start(arglist, dwErrorCode);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    MyCommonDialog(hwnd, dwErrorCode, szCaption, MB_ICONSTOP | MB_OK, arglist);

    va_end(arglist);
}



//+-------------------------------------------------------------------------
//
//  Function:   MessageFromError
//
//  Synopsis:   MessageFromError returns a message ID which is more or
//              less appropriate to a return code from a remoted
//              NetServerGetInfo.
//
//  History:    26-Sep-95   BruceFo     Stolen from Win95
//
//--------------------------------------------------------------------------

HRESULT
MessageFromError(
    NET_API_STATUS err
    )
{
    switch (err)
    {
        case ERROR_ACCESS_DENIED:
        case ERROR_NETWORK_ACCESS_DENIED:
            return MSG_ACCESSDENIED;
        case ERROR_BAD_NETPATH:
            return MSG_SERVERNOTFOUND;
        default:
            return MSG_CANTREMOTE;
    }

    return 0;
}


//----------------------------------------------------------------------------

CWaitCursor::CWaitCursor(UINT idResCursor)
{
    _hcurWait = _hcurOld = NULL;

    if (0 != idResCursor)
    {
        _hcurWait = LoadCursor(g_hInstance, MAKEINTRESOURCE(idResCursor));
        _hcurOld = SetCursor(_hcurWait);
    }
    else
    {
        _hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    }
}

CWaitCursor::~CWaitCursor()
{
    ::SetCursor( _hcurOld );
    if (_hcurWait)
    {
        ::DestroyCursor( _hcurWait );
    }
}

//----------------------------------------------------------------------------

NET_API_STATUS
MyNetpGetDomainNameEx (
    IN  LPWSTR MachineName,
    OUT LPWSTR* DomainNamePtr, // alloc and set ptr (free with NetApiBufferFree)
    OUT PBOOL IsWorkgroupName
    )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.
    Stolen from netlib and hacked to remote it.

Arguments:

    MachineName - The machine in question

    DomainNamePtr - The name of the domain or workgroup

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO PrimaryDomainInfo;
    OBJECT_ATTRIBUTES ObjAttributes;
    UNICODE_STRING unicodeMachineName;

    //
    // Check for caller's errors.
    //
    if (DomainNamePtr == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open a handle to the machine's security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    RtlInitUnicodeString(&unicodeMachineName, MachineName);

    ntstatus = LsaOpenPolicy(
                   &unicodeMachineName,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION,
                   &PolicyHandle
                   );

    if (! NT_SUCCESS(ntstatus))
    {
        appDebugOut((DEB_ERROR,
            "NetpGetDomainName: LsaOpenPolicy returned 0x%08lx\n",
            ntstatus));
        return NERR_CfgCompNotFound;
    }

    //
    // Get the name of the primary domain from LSA
    //
    ntstatus = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyPrimaryDomainInformation,
                   (PVOID *) &PrimaryDomainInfo
                   );

    if (! NT_SUCCESS(ntstatus))
    {
        appDebugOut((DEB_ERROR,
            "NetpGetDomainName: LsaQueryInformationPolicy failed 0x%08lx\n",
            ntstatus));
        (void) LsaClose(PolicyHandle);
        return NERR_CfgCompNotFound;
    }

    (void) LsaClose(PolicyHandle);

    status = NetApiBufferAllocate(
                      PrimaryDomainInfo->DomainName.Length + sizeof(WCHAR),
                      (LPVOID*)DomainNamePtr);
    if (status != NERR_Success)
    {
        (void) LsaFreeMemory((PVOID) PrimaryDomainInfo);
        return status;
    }

    ZeroMemory(
        *DomainNamePtr,
        PrimaryDomainInfo->DomainName.Length + sizeof(WCHAR)
        );

    CopyMemory(
        *DomainNamePtr,
        PrimaryDomainInfo->DomainName.Buffer,
        PrimaryDomainInfo->DomainName.Length
        );

    *IsWorkgroupName = (PrimaryDomainInfo->DomainSid == NULL);

    (void) LsaFreeMemory((PVOID) PrimaryDomainInfo);

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\fixes\pages.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       pages.cxx
//
//  Contents:   property pages for provider, domain/workgroup, server, share
//
//  History:    26-Sep-95        BruceFo     Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "ext.hxx"
#include "pages.hxx"
#include "util.hxx"

////////////////////////////////////////////////////////////////////////////

//
//  This is the minimum version number necessary to
//  actually display a version number.  If we get a
//  machine with a major version number less that this
//  value, we don't display the version number.
//

#define MIN_DISPLAY_VER  2

////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CPage::PageCallback, static public
//
//  Synopsis:
//
//--------------------------------------------------------------------------

UINT CALLBACK
CPage::PageCallback(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE ppsp
    )
{
    switch (uMsg)
    {
    case PSPCB_CREATE:
        return 1;       // allow creation

    case PSPCB_RELEASE:
    {
        CPage* pThis = (CPage*)ppsp->lParam;
        delete pThis;   // do this LAST!
        return 0;       // ignored
    }

    default:
        appDebugOut((DEB_ERROR, "CPage::PageCallback, unknown page callback message %d\n", uMsg));
        return 0;

    } // end switch
}

//+-------------------------------------------------------------------------
//
//  Method:     CPage::DlgProcPage, static public
//
//  Synopsis:   Dialog Procedure for all CPage
//
//--------------------------------------------------------------------------

BOOL CALLBACK
CPage::DlgProcPage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CPage* pThis = NULL;

    if (msg==WM_INITDIALOG)
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
        pThis = (CPage*)psp->lParam;
        SetWindowLong(hwnd,GWL_USERDATA,(LPARAM)pThis);
    }
    else
    {
        pThis = (CPage*) GetWindowLong(hwnd,GWL_USERDATA);
    }

    if (pThis != NULL)
    {
        return pThis->_PageProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}


//+--------------------------------------------------------------------------
//
//  Method:     CPage::CPage, public
//
//  Synopsis:   Constructor
//
//---------------------------------------------------------------------------

CPage::CPage(
    IN CNetObj* pNetObj
    )
    :
    _pNetObj(pNetObj)
{
    INIT_SIG(CPage);

    if (NULL != _pNetObj)
    {
        //
        // We need to addref this because we are using member variable
        // of this class.
        //
        _pNetObj->AddRef();
    }
}


//+--------------------------------------------------------------------------
//
//  Method:     CPage::~CPage, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------------------

CPage::~CPage()
{
    CHECK_SIG(CPage);

    if (NULL != _pNetObj)
    {
        _pNetObj->Release();
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::InitInstance, public
//
//  Synopsis:   Part II of the constuctor process
//
//  Notes:      We don't want to handle any errors in constuctor, so this
//              method is necessary for the second phase error detection.
//
//--------------------------------------------------------------------------

HRESULT
CPage::InitInstance(
    VOID
    )
{
    CHECK_SIG(CPage);
    appDebugOut((DEB_ITRACE, "CPage::InitInstance\n"));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

BOOL
CPage::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CPage);

    static DWORD aHelpIds[] =
    {
        IDC_NETWORK,        IDH_NET_NETWORK,
        IDC_NETWORK_ICON,   IDH_NET_NETWORK,
        IDC_SERVER,         IDH_NET_SERVER,
        IDC_SERVER_ICON,    IDH_NET_SERVER,
        IDC_SERVER_TEXT,    IDH_NET_SERVER,
        IDC_COMMENT,        IDH_NET_COMMENT,
        IDC_COMMENT_TEXT,   IDH_NET_COMMENT,
        IDC_WORKGROUP_OR_DOMAIN,   IDH_NET_WORKGROUP_OR_DOMAIN_NAME,
        IDC_WORKGROUP_OR_DOMAIN_NAME,   IDH_NET_WORKGROUP_OR_DOMAIN_NAME,
        IDC_WORKGROUP_OR_DOMAIN_NAME_2_ICON, IDH_NET_WORKGROUP_OR_DOMAIN_NAME_2,
        IDC_WORKGROUP_OR_DOMAIN_NAME_2, IDH_NET_WORKGROUP_OR_DOMAIN_NAME_2,
        IDC_TYPE,           IDH_NET_TYPE,
        IDC_TYPE_TEXT,      IDH_NET_TYPE,
        IDC_SHARE,          IDH_NET_SHARE,
        IDC_SHARE_ICON,     IDH_NET_SHARE,
        IDC_WRKGRP_TYPE,    IDH_NET_WRKGRP_TYPE,
        IDC_WRKGRP_TYPE_TEXT,   IDH_NET_WRKGRP_TYPE,
        0,0
    };

    switch (msg)
    {
    case WM_INITDIALOG:
        _hwndPage = hwnd;
        return _OnInitDialog(hwnd, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return _OnNotify(hwnd, (int)wParam, (LPNMHDR)lParam);

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if (lphi->iContextType == HELPINFO_WINDOW)  // a control
        {
            WCHAR szHelp[50];
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                (HWND)lphi->hItemHandle,
                szHelp,
                HELP_WM_HELP,
                (DWORD)(LPVOID)aHelpIds);
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)wParam,
            szHelp,
            HELP_CONTEXTMENU,
            (DWORD)(LPVOID)aHelpIds);
        break;
    }

    } // end switch (msg)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitDialog(
    IN HWND hwnd,
    IN HWND hwndFocus,
    IN LPARAM lInitParam
    )
{
    CHECK_SIG(CPage);
    appDebugOut((DEB_ITRACE, "_OnInitDialog\n"));

    appAssert(NULL != _pNetObj);
    LPNETRESOURCE pnr = (LPNETRESOURCE)_pNetObj->_bufNetResource;
    appAssert(NULL != pnr);

    if (RESOURCEDISPLAYTYPE_NETWORK == pnr->dwDisplayType)
    {
        return _OnInitNetwork(hwnd, pnr);
    }
    else if (RESOURCEDISPLAYTYPE_DOMAIN == pnr->dwDisplayType)
    {
        return _OnInitDomain(hwnd, pnr);
    }
    else if (RESOURCEDISPLAYTYPE_SERVER == pnr->dwDisplayType)
    {
        return _OnInitServerOrShare(hwnd, pnr, TRUE);
    }
    else if (RESOURCEDISPLAYTYPE_SHARE == pnr->dwDisplayType)
    {
        return _OnInitServerOrShare(hwnd, pnr, FALSE);
    }
    else
    {
        appAssert(!"CNetObj::AddPages. Unknown net resource type!\n");
        return TRUE;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitNetwork, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitNetwork(
    IN HWND hwnd,
    IN LPNETRESOURCE pnr
    )
{
    CHECK_SIG(CPage);
    appAssert(NULL != pnr);

    SetDlgItemText(hwnd, IDC_NETWORK, pnr->lpProvider);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitDomain, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitDomain(
    IN HWND hwnd,
    LPNETRESOURCE pnr
    )
{
    CHECK_SIG(CPage);
    appAssert(NULL != pnr);

    SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN_NAME_2, pnr->lpRemoteName);
    SetDlgItemText(hwnd, IDC_WRKGRP_TYPE,              pnr->lpProvider);
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitServerOrShare, private
//
//  Synopsis:   WM_INITDIALOG handler for Server and Share objects
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitServerOrShare(
    IN HWND hwnd,
    IN LPNETRESOURCE pnr,
    IN BOOL fServer         // TRUE == server, FALSE == share
    )
{
    CHECK_SIG(CPage);
    appAssert(NULL != pnr);

    CWaitCursor wait;

    NET_API_STATUS err;
    LPTSTR pszRealServerName = pnr->lpRemoteName;
    appAssert(NULL != pszRealServerName);

    // Figure out server name without UNC prefix
    if (pszRealServerName[0] == TEXT('\\') && pszRealServerName[1] == TEXT('\\'))
    {
        pszRealServerName += 2;
    }

    if (!fServer)
    {
        // Get share name
        LPTSTR pszShareName = wcschr(pszRealServerName, TEXT('\\'));
        appAssert(NULL != pszShareName);
        *pszShareName++ = TEXT('\0');    // NOTE: NULL-terminating server name
        SetDlgItemText(hwnd, IDC_SHARE, pszShareName);
    }

    SetDlgItemText(hwnd, IDC_SERVER, pszRealServerName);

    // Get server information
    PSERVER_INFO_101 pServerInfo = NULL;
    err = NetServerGetInfo(pnr->lpRemoteName, 101, (LPBYTE*)&pServerInfo);
    if (NERR_Success != err)
    {
        MyErrorDialog(hwnd, MessageFromError(err), pszRealServerName);
        return TRUE;
    }

    // NOTE: I now have a pServerInfo to delete

    appAssert(NULL != pServerInfo);

    if (fServer)
    {
        if (NULL != pServerInfo->sv101_comment)
        {
            SetDlgItemText(hwnd, IDC_COMMENT, pServerInfo->sv101_comment);
        }
    }

    _SetServerType(hwnd, IDC_TYPE, pServerInfo);

    DWORD svtype = pServerInfo->sv101_type; // save type for later use
    NetApiBufferFree(pServerInfo);          // get rid of it so we don't have to worry about it

    UINT idLogonType = IDS_LOGON_WORKGROUP;
    if (svtype & SV_TYPE_NT)
    {
        // It's an NT server. See if it is in a workgroup or a domain.
        LPWSTR pszDomainName;
        BOOL bIsWorkgroupName;
        err = MyNetpGetDomainNameEx(pnr->lpRemoteName, &pszDomainName, &bIsWorkgroupName);
        if (err != NERR_Success)
        {
            MyErrorDialog(hwnd, MessageFromError(err), pszRealServerName);
            return TRUE;
        }
        SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN_NAME, pszDomainName);
        NetApiBufferFree(pszDomainName);

        if (!bIsWorkgroupName)
        {
            idLogonType = IDS_LOGON_DOMAIN;
        }
    }
    else
    {
        // It's not an NT server, so assume it's a workgroup.
        PWKSTA_INFO_100 pWorkstationInfo = NULL;
        err = NetWkstaGetInfo(pnr->lpRemoteName, 100, (LPBYTE*)&pWorkstationInfo);
        if (NERR_Success != err)
        {
            MyErrorDialog(hwnd, MessageFromError(err), pszRealServerName);
            return TRUE;
        }

        appAssert(NULL != pWorkstationInfo);

        if (NULL != pWorkstationInfo->wki100_langroup)
        {
            SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN_NAME, pWorkstationInfo->wki100_langroup);
        }
        NetApiBufferFree(pWorkstationInfo);
    }

    WCHAR szLogonType[80];
    LoadString(g_hInstance, idLogonType, szLogonType, ARRAYLEN(szLogonType));
    SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN, szLogonType);

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnNotify, private
//
//  Synopsis:   WM_NOTIFY handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnNotify(
    IN HWND hwnd,
    IN int idCtrl,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CPage);

    switch (phdr->code)
    {
    case PSN_APPLY:
    case PSN_RESET:         // cancel
        SetWindowLong(hwnd, DWL_MSGRESULT, FALSE); // go away
        return TRUE;

    case PSN_KILLACTIVE:    // change to another page
        SetWindowLong(hwnd, DWL_MSGRESULT, PSNRET_NOERROR);
        return FALSE;

    case PSN_SETACTIVE:
    case PSN_QUERYCANCEL:
        return FALSE;

    } // end switch (phdr->code)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_SetServerType, private
//
//  Synopsis:   Sets a server type control
//
//--------------------------------------------------------------------------

VOID
CPage::_SetServerType(
    HWND hwnd,
    int idControl,
    PSERVER_INFO_101 pinfo
    )
{
    UINT idType, idRole;
    HRESULT msgFormat;

    //
    //  Determine the server's type (NT, LM, etc) and role.
    //

    DWORD type = pinfo->sv101_type;

    if (type & SV_TYPE_NT)
    {
        idType = IDS_SERVER_TYPE_WINNT;
    }
    else
    if (type & SV_TYPE_WINDOWS)
    {
        idType = IDS_SERVER_TYPE_WINDOWS95;
    }
    else
    if (type & SV_TYPE_WFW)
    {
        idType = IDS_SERVER_TYPE_WFW;
    }
    else
    {
        idType = IDS_SERVER_TYPE_LANMAN;
    }

    if (type & SV_TYPE_DOMAIN_CTRL)
    {
        idRole = IDS_ROLE_PRIMARY;
    }
    else
    if (type & SV_TYPE_DOMAIN_BAKCTRL)
    {
        idRole = IDS_ROLE_BACKUP;
    }
    else
    if (type & SV_TYPE_SERVER_NT)
    {
        idRole = IDS_ROLE_SERVER;
    }
    else
    {
        idRole = IDS_ROLE_WKSTA;
    }

    UINT verMajor = pinfo->sv101_version_major & MAJOR_VERSION_MASK;
    UINT verMinor = pinfo->sv101_version_minor;

    msgFormat = (verMajor < MIN_DISPLAY_VER || (type & SV_TYPE_WINDOWS))
                    ? MSG_TYPE_FORMAT_UNKNOWN
                    : MSG_TYPE_FORMAT
                    ;

    WCHAR szType[80];
    LoadString(g_hInstance, idType, szType, ARRAYLEN(szType));

    WCHAR szRole[80];
    LoadString(g_hInstance, idRole, szRole, ARRAYLEN(szRole));

    DWORD aInserts[4];
    aInserts[0] = (DWORD)szType;
    aInserts[1] = verMajor;
    aInserts[2] = verMinor;
    aInserts[3] = (DWORD)szRole;

    WCHAR szBuffer[256];
    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE
                                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                             g_hInstance,
                             msgFormat,
                             LANG_SYSTEM_DEFAULT,
                             szBuffer,
                             ARRAYLEN(szBuffer),
                             (va_list*)aInserts);
    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        szBuffer[0] = TEXT('\0');
    }

    SetDlgItemText(hwnd, idControl, szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\pages.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       pages.cxx
//
//  Contents:   property pages for provider, domain/workgroup, server, share
//
//  History:    26-Sep-95        BruceFo     Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "ext.hxx"
#include "pages.hxx"
#include "util.hxx"

////////////////////////////////////////////////////////////////////////////

//
//  This is the minimum version number necessary to
//  actually display a version number.  If we get a
//  machine with a major version number less that this
//  value, we don't display the version number.
//

#define MIN_DISPLAY_VER  2

////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CPage::DlgProcPage, static public
//
//  Synopsis:   Dialog Procedure for all CPage
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CPage::DlgProcPage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CPage* pThis = NULL;

    if (msg==WM_INITDIALOG)
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
        pThis = new CPage(hwnd, psp->lParam);
        if (NULL != pThis)
        {
            if (FAILED(pThis->InitInstance()))
            {
                delete pThis;
                pThis = NULL;
            }
        }

        SetWindowLongPtr(hwnd,GWLP_USERDATA,(LPARAM)pThis);
    }
    else
    {
        pThis = (CPage*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
    }

    if (pThis != NULL)
    {
        return pThis->_PageProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}


//+--------------------------------------------------------------------------
//
//  Method:     CPage::CPage, public
//
//  Synopsis:   Constructor
//
//---------------------------------------------------------------------------

CPage::CPage(
    IN HWND hwndPage,
    IN LPARAM lParam
    )
    :
    _hwndPage(hwndPage),
    _pNetObj( (CNetObj*)lParam )
{
    INIT_SIG(CPage);
}


//+--------------------------------------------------------------------------
//
//  Method:     CPage::~CPage, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------------------

CPage::~CPage()
{
    CHECK_SIG(CPage);
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::InitInstance, public
//
//  Synopsis:   Part II of the constuctor process
//
//  Notes:      We don't want to handle any errors in constuctor, so this
//              method is necessary for the second phase error detection.
//
//--------------------------------------------------------------------------

HRESULT
CPage::InitInstance(
    VOID
    )
{
    CHECK_SIG(CPage);
    appDebugOut((DEB_ITRACE, "CPage::InitInstance\n"));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

INT_PTR
CPage::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CPage);

    static DWORD aHelpIds[] =
    {
        IDC_NETWORK,        IDH_NET_NETWORK,
        IDC_NETWORK_ICON,   IDH_NET_NETWORK,
        IDC_SERVER,         IDH_NET_SERVER,
        IDC_SERVER_ICON,    IDH_NET_SERVER,
        IDC_SERVER_TEXT,    IDH_NET_SERVER,
        IDC_COMMENT,        IDH_NET_COMMENT,
        IDC_COMMENT_TEXT,   IDH_NET_COMMENT,
        IDC_WORKGROUP_OR_DOMAIN,   IDH_NET_WORKGROUP_OR_DOMAIN_NAME,
        IDC_WORKGROUP_OR_DOMAIN_NAME,   IDH_NET_WORKGROUP_OR_DOMAIN_NAME,
        IDC_WORKGROUP_OR_DOMAIN_NAME_2_ICON, IDH_NET_WORKGROUP_OR_DOMAIN_NAME_2,
        IDC_WORKGROUP_OR_DOMAIN_NAME_2, IDH_NET_WORKGROUP_OR_DOMAIN_NAME_2,
        IDC_TYPE,           IDH_NET_TYPE,
        IDC_TYPE_TEXT,      IDH_NET_TYPE,
        IDC_SHARE,          IDH_NET_SHARE,
        IDC_SHARE_ICON,     IDH_NET_SHARE,
        IDC_WRKGRP_TYPE,    IDH_NET_WRKGRP_TYPE,
        IDC_WRKGRP_TYPE_TEXT,   IDH_NET_WRKGRP_TYPE,
        0,0
    };

    switch (msg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(hwnd, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return _OnNotify(hwnd, (int)wParam, (LPNMHDR)lParam);

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if (lphi->iContextType == HELPINFO_WINDOW)  // a control
        {
            WCHAR szHelp[50];
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                (HWND)lphi->hItemHandle,
                szHelp,
                HELP_WM_HELP,
                (DWORD_PTR)aHelpIds);
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)wParam,
            szHelp,
            HELP_CONTEXTMENU,
            (DWORD_PTR)aHelpIds);
        break;
    }

    case WM_DESTROY:
        if (NULL != _pNetObj)
        {
            _pNetObj->Release();
        }
        return TRUE;

    case WM_NCDESTROY:
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)NULL);
        delete this;    // do this LAST!
        return TRUE;

    } // end switch (msg)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitDialog(
    IN HWND hwnd,
    IN HWND hwndFocus,
    IN LPARAM lInitParam
    )
{
    CHECK_SIG(CPage);
    appDebugOut((DEB_ITRACE, "_OnInitDialog\n"));

    appAssert(NULL != _pNetObj);
    LPNETRESOURCE pnr = (LPNETRESOURCE)_pNetObj->_bufNetResource;
    appAssert(NULL != pnr);

    if (RESOURCEDISPLAYTYPE_NETWORK == pnr->dwDisplayType)
    {
        return _OnInitNetwork(hwnd, pnr);
    }
    else if (RESOURCEDISPLAYTYPE_DOMAIN == pnr->dwDisplayType)
    {
        return _OnInitDomain(hwnd, pnr);
    }
    else if (RESOURCEDISPLAYTYPE_SERVER == pnr->dwDisplayType)
    {
        return _OnInitServerOrShare(hwnd, pnr, TRUE);
    }
    else if (RESOURCEDISPLAYTYPE_SHARE == pnr->dwDisplayType)
    {
        return _OnInitServerOrShare(hwnd, pnr, FALSE);
    }
    else
    {
        appAssert(!"CNetObj::AddPages. Unknown net resource type!\n");
        return TRUE;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitNetwork, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitNetwork(
    IN HWND hwnd,
    IN LPNETRESOURCE pnr
    )
{
    CHECK_SIG(CPage);
    appAssert(NULL != pnr);

    SetDlgItemText(hwnd, IDC_NETWORK, pnr->lpProvider);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitDomain, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitDomain(
    IN HWND hwnd,
    LPNETRESOURCE pnr
    )
{
    CHECK_SIG(CPage);
    appAssert(NULL != pnr);

    SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN_NAME_2, pnr->lpRemoteName);
    SetDlgItemText(hwnd, IDC_WRKGRP_TYPE,              pnr->lpProvider);
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitServerOrShare, private
//
//  Synopsis:   WM_INITDIALOG handler for Server and Share objects
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitServerOrShare(
    IN HWND hwnd,
    IN LPNETRESOURCE pnr,
    IN BOOL fServer         // TRUE == server, FALSE == share
    )
{
    CHECK_SIG(CPage);
    appAssert(NULL != pnr);

    CWaitCursor wait;

    NET_API_STATUS err;
    LPTSTR pszRealServerName = pnr->lpRemoteName;
    appAssert(NULL != pszRealServerName);

    // Figure out server name without UNC prefix
    if (pszRealServerName[0] == TEXT('\\') && pszRealServerName[1] == TEXT('\\'))
    {
        pszRealServerName += 2;
    }

    if (!fServer)
    {
        // Get share name
        LPTSTR pszShareName = wcschr(pszRealServerName, TEXT('\\'));
        appAssert(NULL != pszShareName);
        *pszShareName++ = TEXT('\0');    // NOTE: NULL-terminating server name
        SetDlgItemText(hwnd, IDC_SHARE, pszShareName);
    }

    SetDlgItemText(hwnd, IDC_SERVER, pszRealServerName);

    // Get server information
    PSERVER_INFO_101 pServerInfo = NULL;
    err = NetServerGetInfo(pnr->lpRemoteName, 101, (LPBYTE*)&pServerInfo);
    if (NERR_Success != err)
    {
        MyErrorDialog(hwnd, MessageFromError(err), pszRealServerName);
        return TRUE;
    }

    // NOTE: I now have a pServerInfo to delete

    appAssert(NULL != pServerInfo);

    if (fServer)
    {
        if (NULL != pServerInfo->sv101_comment)
        {
            SetDlgItemText(hwnd, IDC_COMMENT, pServerInfo->sv101_comment);
        }
    }

    _SetServerType(hwnd, IDC_TYPE, pServerInfo);

    DWORD svtype = pServerInfo->sv101_type; // save type for later use
    NetApiBufferFree(pServerInfo);          // get rid of it so we don't have to worry about it

    UINT idLogonType = IDS_LOGON_WORKGROUP;
    if (svtype & SV_TYPE_NT)
    {
        // It's an NT server. See if it is in a workgroup or a domain.
        LPWSTR pszDomainName;
        BOOL bIsWorkgroupName;
        err = MyNetpGetDomainNameEx(pnr->lpRemoteName, &pszDomainName, &bIsWorkgroupName);
        if (err != NERR_Success)
        {
            MyErrorDialog(hwnd, MessageFromError(err), pszRealServerName);
            return TRUE;
        }
        SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN_NAME, pszDomainName);
        NetApiBufferFree(pszDomainName);

        if (!bIsWorkgroupName)
        {
            idLogonType = IDS_LOGON_DOMAIN;
        }
    }
    else
    {
        // It's not an NT server, so assume it's a workgroup.
        PWKSTA_INFO_100 pWorkstationInfo = NULL;
        err = NetWkstaGetInfo(pnr->lpRemoteName, 100, (LPBYTE*)&pWorkstationInfo);
        if (NERR_Success != err)
        {
            MyErrorDialog(hwnd, MessageFromError(err), pszRealServerName);
            return TRUE;
        }

        appAssert(NULL != pWorkstationInfo);

        if (NULL != pWorkstationInfo->wki100_langroup)
        {
            SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN_NAME, pWorkstationInfo->wki100_langroup);
        }
        NetApiBufferFree(pWorkstationInfo);
    }

    WCHAR szLogonType[80];
    LoadString(g_hInstance, idLogonType, szLogonType, ARRAYLEN(szLogonType));
    SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN, szLogonType);

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnNotify, private
//
//  Synopsis:   WM_NOTIFY handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnNotify(
    IN HWND hwnd,
    IN int idCtrl,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CPage);

    switch (phdr->code)
    {
    case PSN_APPLY:
    case PSN_RESET:         // cancel
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE); // go away
        return TRUE;

    case PSN_KILLACTIVE:    // change to another page
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        return FALSE;

    case PSN_SETACTIVE:
    case PSN_QUERYCANCEL:
        return FALSE;

    } // end switch (phdr->code)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_SetServerType, private
//
//  Synopsis:   Sets a server type control
//
//--------------------------------------------------------------------------

VOID
CPage::_SetServerType(
    HWND hwnd,
    int idControl,
    PSERVER_INFO_101 pinfo
    )
{
    //
    //  Determine the server's type (NT, LM, etc) and role.
    //

    DWORD type = pinfo->sv101_type;

    UINT verMajor = pinfo->sv101_version_major & MAJOR_VERSION_MASK;
    UINT verMinor = pinfo->sv101_version_minor;

    UINT idType = IDS_SERVER_TYPE_LANMAN;
    if (type & SV_TYPE_NT)
    {
        if (verMajor <= 4)
            idType = IDS_SERVER_TYPE_WINNT;
        else if (verMajor == 5 && verMinor == 0)
            idType = IDS_SERVER_TYPE_WIN2K;
        else
            idType = IDS_SERVER_TYPE_POSTWIN2K;
    }
    else
    if (type & SV_TYPE_WINDOWS)
    {
        idType = IDS_SERVER_TYPE_WINDOWS95;
    }
    else
    if (type & SV_TYPE_WFW)
    {
        idType = IDS_SERVER_TYPE_WFW;
    }

    UINT idRole = IDS_ROLE_PROFESSIONAL;
    if (type & SV_TYPE_DOMAIN_CTRL)
    {
        idRole = IDS_ROLE_PRIMARY;
    }
    else
    if (type & SV_TYPE_DOMAIN_BAKCTRL)
    {
        idRole = IDS_ROLE_BACKUP;
    }
    else
    if (type & SV_TYPE_SERVER_NT)
    {
        idRole = IDS_ROLE_SERVER;
    }
    else
    if (verMajor <= 4)
    {
        idRole = IDS_ROLE_WKSTA;
    }

    HRESULT msgFormat = MSG_TYPE_FORMAT;
    if (   verMajor < MIN_DISPLAY_VER
        || (type & SV_TYPE_WINDOWS)
        || (verMajor >= 5)
       )
    {
         msgFormat = MSG_TYPE_FORMAT_UNKNOWN;
    }

    WCHAR szType[80];
    LoadString(g_hInstance, idType, szType, ARRAYLEN(szType));

    WCHAR szRole[80];
    LoadString(g_hInstance, idRole, szRole, ARRAYLEN(szRole));

    DWORD_PTR aInserts[4];
    aInserts[0] = (DWORD_PTR)szType;
    aInserts[1] = verMajor;
    aInserts[2] = verMinor;
    aInserts[3] = (DWORD_PTR)szRole;

    WCHAR szBuffer[256];
    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE
                                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                             g_hInstance,
                             msgFormat,
                             LANG_USER_DEFAULT,
                             szBuffer,
                             ARRAYLEN(szBuffer),
                             (va_list*)aInserts);
    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        szBuffer[0] = TEXT('\0');
    }

    SetDlgItemText(hwnd, idControl, szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           101
#define IDS_NET_MSG_NOT_FOUND           102
#define IDS_NO_NET_MSG                  103
#define IDS_MSGTITLE                    104
#define IDS_HELPFILENAME                112
#define IDI_SERVER                      113
#define IDI_WORKGROUP                   114
#define IDI_SHARE                       115
#define IDD_NETWORK_SUMMARYINFO         116
#define IDI_NETWORK                     117
#define IDS_ROLE_PRIMARY                118
#define IDS_ROLE_BACKUP                 119
#define IDS_ROLE_WKSTA                  120
#define IDS_ROLE_SERVER                 122
#define IDC_WORKGROUP_OR_DOMAIN         123
#define IDC_WORKGROUP_OR_DOMAIN_NAME    124
#define IDS_SERVER_TYPE_WINNT           125
#define IDS_SERVER_TYPE_LANMAN          126
#define IDS_SERVER_TYPE_WFW             127
#define IDS_SERVER_TYPE_WINDOWS95       128
#define IDS_LOGON_DOMAIN                129
#define IDS_LOGON_WORKGROUP             130
#define IDC_WORKGROUP_OR_DOMAIN_NAME_2  131
#define IDS_ROLE_PROFESSIONAL           132
#define IDS_SERVER_TYPE_WIN2K           133
#define IDS_SERVER_TYPE_POSTWIN2K       134
#define IDD_SERVER_SUMMARYINFO          1017
#define IDC_COMMENT                     1019
#define IDD_SHARE_SUMMARYINFO           1026
#define IDC_SHARE                       1027
#define IDC_SERVER                      1028
#define IDC_TYPE                        1029
#define IDC_WRKGRP_TYPE                 1030
#define IDD_WRKGRP_SUMMARYINFO          1031
#define IDC_NETWORK                     1034
#define IDC_NETWORK_ICON                1035
#define IDC_SERVER_ICON                 1036
#define IDC_COMMENT_TEXT                1037
#define IDC_TYPE_TEXT                   1038
#define IDC_SHARE_ICON                  1039
#define IDC_SERVER_TEXT                 1040
#define IDC_WORKGROUP_OR_DOMAIN_NAME_2_ICON 1041
#define IDC_WRKGRP_TYPE_TEXT            1042

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1043
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\netobjs\fixes\ext.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ext.cxx
//
//  Contents:   Shell extension handler for network objects
//
//  Classes:    CNetObj
//
//  History:    26-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <pages.hxx>

#define DONT_WANT_SHELLDEBUG
#include <shsemip.h>

#include "resource.h"
#include "ext.hxx"
#include "util.hxx"

//--------------------------------------------------------------------------
//
// Shell DLL communication
//

typedef
UINT
(WINAPI *SHELLGETNETRESOURCE)(
    HNRES hnres,
    UINT iItem,
    LPNETRESOURCE pnresOut,
    UINT cbMax
    );

HINSTANCE g_hShellLibrary = NULL;
SHELLGETNETRESOURCE g_pFuncGNR = NULL;
UINT g_cfNetResource = 0;

BOOL LoadShellDllEntries(VOID);

//--------------------------------------------------------------------------


/*
 * Helper functions used to communicate with shell32.dll
 */

BOOL LoadShellDllEntries(VOID)
{
    if (g_hShellLibrary)
    {
        return TRUE;
    }

    g_hShellLibrary = LoadLibrary(TEXT("shell32.dll"));
    if (NULL == g_hShellLibrary)
    {
        return FALSE;
    }

    g_pFuncGNR = (SHELLGETNETRESOURCE)GetProcAddress(g_hShellLibrary, (LPSTR)(MAKELONG(SHGetNetResourceORD, 0)));
    if (NULL == g_pFuncGNR)
    {
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::CNetObj
//
//  Synopsis:   Constructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CNetObj::CNetObj(
    VOID
    )
    :
    _uRefs(0),
    _pDataObject(NULL),
    _hkeyProgID(NULL)
{
    INIT_SIG(CNetObj);

    AddRef(); // give it the correct initial reference count. add to the DLL reference count
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::~CNetObj
//
//  Synopsis:   Destructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CNetObj::~CNetObj()
{
    CHECK_SIG(CNetObj);

    if (_pDataObject)
    {
        _pDataObject->Release();
        _pDataObject = NULL;
    }

    if (_hkeyProgID)
    {
        LONG l = RegCloseKey(_hkeyProgID);
        if (l != ERROR_SUCCESS)
        {
            appDebugOut((DEB_ERROR, "CNetObj::destructor. Error closing registry key, 0x%08lx\n", l));
        }
        _hkeyProgID = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::Initialize
//
//  Derivation: IShellExtInit
//
//  Synopsis:   Initialize the shell extension. Stashes away the argument data.
//
//  History:    4-Apr-95    BruceFo  Created
//
//  Notes:      This method can be called more than once.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CNetObj::Initialize(
    LPCITEMIDLIST   pidlFolder,
    LPDATAOBJECT    pDataObject,
    HKEY            hkeyProgID
    )
{
    CHECK_SIG(CNetObj);

    CNetObj::~CNetObj();

    if (!LoadShellDllEntries())
    {
        return E_FAIL;
    }

    // Duplicate the pDataObject pointer
    _pDataObject = pDataObject;
    if (pDataObject)
    {
        pDataObject->AddRef();
    }

    // Duplicate the handle
    if (hkeyProgID)
    {
        LONG l = RegOpenKeyEx(hkeyProgID, NULL, 0L, MAXIMUM_ALLOWED, &_hkeyProgID);
        if (l != ERROR_SUCCESS)
        {
            appDebugOut((DEB_ERROR, "CNetObj::Initialize. Error duplicating registry key, 0x%08lx\n", l));
        }
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::AddPages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (from shlobj.h)
//              "The explorer calls this member function when it finds a
//              registered property sheet extension for a particular type
//              of object. For each additional page, the extension creates
//              a page object by calling CreatePropertySheetPage API and
//              calls lpfnAddPage.
//
//  Arguments:  lpfnAddPage -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CNetObj::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam
    )
{
    CHECK_SIG(CNetObj);

    //
    // Call IDataObject::GetData asking for a g_cfNetResource (i.e., HNRES).
    //
    STGMEDIUM medium;
    FORMATETC fmte =
    {
        g_cfNetResource
            ? g_cfNetResource
            : (g_cfNetResource = RegisterClipboardFormat(CFSTR_NETRESOURCES)),
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };
    appAssert(NULL != _pDataObject);
    HRESULT hr = _pDataObject->GetData(&fmte, &medium);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        return hr;
    }

    ///////////////// Now I have a 'medium' to release

    hr = S_OK;

    HNRES hnres = medium.hGlobal;

    // Get number of selected items
    if (NULL != g_pFuncGNR)
    {
        UINT cItems = (*g_pFuncGNR)(hnres, (UINT)-1, NULL, 0);
        if (cItems > 0)
        {
            // Retrieve NETRESOURCE object from clipboard
            LPNETRESOURCE pNetRes = (LPNETRESOURCE)_bufNetResource;
            UINT ret = (*g_pFuncGNR)(hnres, 0, pNetRes, MAX_ONE_RESOURCE); // Get first item
            if (ret == 0)
            {
                // bad hnres?
                appDebugOut((DEB_TRACE, "CNetObj::AddPages. SHGetNetResource returned 0\n"));
                // NOTE: this is really error
            }
            else if (ret > MAX_ONE_RESOURCE)
            {
                // FEATURE: Resize the buf and try again
                appDebugOut((DEB_TRACE, "CNetObj::AddPages. buffer too small, needs to be %d\n", ret));
            }
            else
            {
                LPTSTR pszTemplate = NULL;

                if (RESOURCEDISPLAYTYPE_NETWORK == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_NETWORK_SUMMARYINFO);
                }
                else if (RESOURCEDISPLAYTYPE_DOMAIN == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_WRKGRP_SUMMARYINFO);
                }
                else if (RESOURCEDISPLAYTYPE_SERVER == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_SERVER_SUMMARYINFO);
                }
                else if (RESOURCEDISPLAYTYPE_SHARE == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_SHARE_SUMMARYINFO);
                }
                else
                {
                    appDebugOut((DEB_TRACE, "CNetObj::AddPages. Unknown net resource type!\n"));
                }

                //
                //  Create a property sheet page object from a dialog box.
                //

                if (NULL != pszTemplate)
                {
                    hr = FillAndAddPage(
                            lpfnAddPage,
                            lParam,
                            pszTemplate);
                }
            }
        }
        else
        {
            appDebugOut((DEB_TRACE, "CNetObj::AddPages. NO net resources!\n"));
            // NOTE: this is really error
        }
    }
    else
    {
        appDebugOut((DEB_TRACE, "CNetObj::AddPages. No SHGetNetResource function!\n"));
        // NOTE: this is really error
    }

    ReleaseStgMedium(&medium);
    return hr;
}

HRESULT
CNetObj::FillAndAddPage(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPTSTR pszTemplate
    )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    CPage* pPage = new CPage(this);
    if (NULL == pPage)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPage->InitInstance();
    if (FAILED(hr))
    {
        delete pPage;
        return E_OUTOFMEMORY;
    }

    psp.dwSize      = sizeof(psp);  // no extra data.
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = g_hInstance;
    psp.pszTemplate = pszTemplate;
    psp.hIcon       = NULL;
    psp.pszTitle    = NULL;
    psp.pfnDlgProc  = CPage::DlgProcPage;
    psp.pfnCallback = CPage::PageCallback;
    psp.pcRefParent = &g_NonOLEDLLRefs;
    psp.lParam      = (LPARAM)pPage;

    hpage = CreatePropertySheetPage(&psp);
    if (NULL == hpage)
    {
        delete pPage;
        return E_OUTOFMEMORY;
    }

    BOOL fAdded = (*lpfnAddPage)(hpage, lParam);
    if (!fAdded)
    {
        DestroyPropertySheetPage(hpage);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::ReplacePages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (From shlobj.h)
//              "The explorer never calls this member of property sheet
//              extensions. The explorer calls this member of control panel
//              extensions, so that they can replace some of default control
//              panel pages (such as a page of mouse control panel)."
//
//  Arguments:  uPageID -- Specifies the page to be replaced.
//              lpfnReplace -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CNetObj::ReplacePage(
    UINT                 uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM               lParam
    )
{
    CHECK_SIG(CNetObj);

    appAssert(!"CNetObj::ReplacePage called, not implemented");
    return E_NOTIMPL;
}


// dummy function to export to get linking to work
HRESULT PropDummyFunction()
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\copyhook.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       copyhook.cxx
//
//  Contents:   CShareCopyHook implementation
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "copyhook.hxx"
#include "cache.hxx"
#include "shrinfo.hxx"
#include "util.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CShareCopyHook::CShareCopyHook
//
//  Synopsis:   Constructor
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

CShareCopyHook::CShareCopyHook(
    VOID
    )
    :
    _uRefs(0)
{
    INIT_SIG(CShareCopyHook);

    AddRef(); // give it the correct initial reference count. add to the DLL reference count
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCopyHook::~CShareCopyHook
//
//  Synopsis:   Destructor
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

CShareCopyHook::~CShareCopyHook()
{
    CHECK_SIG(CShareCopyHook);
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCopyHook::CopyCallback
//
//  Derivation: ICopyHook
//
//  Synopsis:   Called when the shell is copying an object
//
//  History:    21-Apr-95 BruceFo  Created
//
// FEATURE: instead of deleting a share on a directory move, how about
// moving the share?
//
//--------------------------------------------------------------------------

STDMETHODIMP_(UINT)
CShareCopyHook::CopyCallback(
    HWND hwnd,
    UINT wFunc,
    UINT fFlags,
    LPCWSTR pszSrcFile,
    DWORD dwSrcAttribs,
    LPCWSTR pszDestFile,
    DWORD dwDestAttribs
    )
{
    appDebugOut((DEB_TRACE,
        "CShareCopyHook::CopyCallback. %ws -> %ws\n",
        pszSrcFile, pszDestFile));

    UINT idMsg;

    if (!(dwSrcAttribs & FILE_ATTRIBUTE_DIRECTORY))
    {
       return IDYES;  //We're only worried about directories
    }

    if (!g_fSharingEnabled)
    {
        return IDYES;
    }

    switch (wFunc)
    {
        case FO_DELETE:
            idMsg = MSG_RMDIRCONFIRM;
            break;

        case FO_RENAME:
        case FO_MOVE:
            idMsg = MSG_MVDIRCONFIRM;
            break;

        default:
            return IDYES;
    }

    BOOL fChange = FALSE;
    UINT wnErr = IDYES;    /* by default, shell should go ahead and do it */
    CShareInfo* pWarnList = NULL;
    HRESULT hr = g_ShareCache.ConstructParentWarnList(pszSrcFile, &pWarnList);
    if (SUCCEEDED(hr))
    {
        if (NULL != pWarnList)
        {
            for (CShareInfo* p = (CShareInfo*) pWarnList->Next();
                 p != pWarnList;
                 p = (CShareInfo*) p->Next())
            {
                wnErr = WarnDelShare(hwnd, idMsg, p->GetNetname(), p->GetPath());
                if (wnErr != IDYES)
                {
                    // IDYES: obviously, continue
                    break;
                }

                fChange = TRUE;
            }

            // get rid of the temporary list
            DeleteShareInfoList(pWarnList, TRUE);

            if (fChange)
            {
                g_ShareCache.Refresh();
            }
        }
    }
    return wnErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\api.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       api.cxx
//
//  Contents:   Exported APIs from this DLL
//
//  History:    5-Oct-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "dllmain.hxx"
#include "shrpage.hxx"
#include "shrinfo.hxx"
#include "cache.hxx"
#include "util.hxx"

//--------------------------------------------------------------------------

static BOOL WINAPI
SharingDialogHelp(
    HWND   hwndParent,
    LPWSTR pszPath          // this is 'new' memory that I take ownership of
    );

//--------------------------------------------------------------------------
// A couple macros to use a stack buffer if smaller than a default size,
// else use a heap buffer.

// Example:
//      LPWSTR pBuffer;
//      DWORD dwBufLen;
//      GET_BUFFER(pBuffer, dwBufLen, WCHAR, wcslen(pszString) + 1, MAX_PATH);
//      if (NULL == pBuffer) { return NULL; } // couldn't get the buffer
//      ... play with pBuffer
//      FREE_BUFFER(pBuffer);

#define GET_BUFFER(pBuffer, dwBufLen, type, desiredLen, defaultLen) \
    DWORD __desiredLen ## pBuffer = desiredLen;                     \
    type __szTmpBuffer ## pBuffer[defaultLen];                      \
    if (__desiredLen ## pBuffer <= defaultLen)                      \
    {                                                               \
        pBuffer = __szTmpBuffer ## pBuffer;                         \
        dwBufLen = defaultLen;                                      \
    }                                                               \
    else                                                            \
    {                                                               \
        pBuffer = new type[__desiredLen ## pBuffer];                \
        if (NULL != pBuffer)                                        \
        {                                                           \
            dwBufLen = __desiredLen ## pBuffer;                     \
        }                                                           \
    }

#define FREE_BUFFER(pBuffer) \
    if (__szTmpBuffer ## pBuffer != pBuffer) { delete[] pBuffer; }

//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   IsPathSharedW
//
//  Synopsis:   IsPathShared is used by the shell to determine whether to
//              put a "shared folder / hand" icon next to a directory.
//              Different from Windows 95, we don't allow sharing remote
//              directories (e.g., \\brucefo4\c$\foo\bar style paths).
//
//  Arguments:  [lpcszPath] - path to look for
//              [bRefresh]  - TRUE if cache should be refreshed
//
//  Returns:    TRUE if the path is shared, FALSE otherwise
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL WINAPI
IsPathSharedW(
    LPCWSTR lpcszPath,
    BOOL bRefresh
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);

    appDebugOut((DEB_TRACE,"IsPathSharedW(%ws, %d)\n", lpcszPath, bRefresh));

    OneTimeInit();
    BOOL bSuccess = g_ShareCache.IsPathShared(lpcszPath, bRefresh);

    appDebugOut((DEB_TRACE,
        "IsPathShared(%ws, %ws) = %ws\n",
        lpcszPath,
        bRefresh ? L"refresh" : L"no refresh",
        bSuccess ? L"yes" : L"no"));

    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bSuccess;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsPathSharedA
//
//  Synopsis:   See IsPathSharedW
//
//  Arguments:  See IsPathSharedW
//
//  Returns:    See IsPathSharedW
//
//  History:    1-Mar-96    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL WINAPI
IsPathSharedA(
    LPCSTR lpcszPath,
    BOOL bRefresh
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"IsPathSharedA(%s, %d)\n", lpcszPath, bRefresh));

    if (NULL == lpcszPath)
    {
        return FALSE;   // invalid input!
    }

    LPWSTR pszTmp;
    DWORD dwBufLen;
    GET_BUFFER(pszTmp, dwBufLen, WCHAR, lstrlenA(lpcszPath) + 1, MAX_PATH);
    if (NULL == pszTmp)
    {
        return FALSE;   // didn't get the buffer
    }
    MultiByteToWideChar(CP_ACP, 0, lpcszPath, -1, pszTmp, dwBufLen);
    BOOL bReturn = IsPathSharedW(pszTmp, bRefresh);
    FREE_BUFFER(pszTmp);

    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}

//+-------------------------------------------------------------------------
//
//  Function:   SharingDialog
//
//  Synopsis:   This API brings up the "Sharing" dialog. This entrypoint is
//              only used by the FAX team, as far as I know. Note that the
//              paths passed in are ANSI---that's because that's what they
//              were in Win95 when the API was defined.
//
//              This API, on NT, only works locally. It does not do remote
//              sharing, as Win95 does. Thus, the pszComputerName parameter
//              is ignored.
//
//  Arguments:  hwndParent      -- parent window
//              pszComputerName -- a computer name. This is ignored!
//              pszPath         -- the path to share.
//
//  Returns:    TRUE if everything went OK, FALSE otherwise
//
//  History:    5-Oct-95    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL WINAPI
SharingDialogW(
    HWND   hwndParent,
    LPWSTR pszComputerName,
    LPWSTR pszPath
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"SharingDialogW(%ws)\n", pszPath));

    // Parameter validation
    if (NULL == pszPath)
    {
        return FALSE;
    }

    if (NULL != pszComputerName)
    {
        appDebugOut((DEB_TRACE,
            "SharingDialog() API called with a computer name which will be ignored\n"));
    }

    // Make sure the DLL is initialized. Note that this loads up the share
    // cache in this address space. Also, the first thing the dialog does
    // is refresh the cache, so we just wasted the work done to create the
    // cache in the init. Oh well...
    OneTimeInit(TRUE);

    PWSTR pszCopy = NewDup(pszPath);
    if (NULL == pszCopy)
    {
        return FALSE;
    }

    BOOL bReturn = SharingDialogHelp(hwndParent, pszCopy);
    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}

//+-------------------------------------------------------------------------
//
//  Function:   SharingDialogA
//
//  Synopsis:   see SharingDialogW
//
//  Arguments:  see SharingDialogW
//
//  Returns:    see SharingDialogW
//
//  History:    1-Mar-96    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL WINAPI
SharingDialogA(
    HWND  hwndParent,
    LPSTR pszComputerName,
    LPSTR pszPath
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"SharingDialogA(%s)\n", pszPath));

    // Parameter validation
    if (NULL == pszPath)
    {
        return FALSE;
    }

    if (NULL != pszComputerName)
    {
        appDebugOut((DEB_TRACE,
            "SharingDialog() API called with a computer name which will be ignored\n"));
    }

    // Make sure the DLL is initialized. Note that this loads up the share
    // cache in this address space. Also, the first thing the dialog does
    // is refresh the cache, so we just wasted the work done to create the
    // cache in the init. Oh well...
    OneTimeInit(TRUE);

    DWORD dwLen = lstrlenA(pszPath) + 1;
    PWSTR pszUnicodePath = new WCHAR[dwLen];
    if (NULL == pszUnicodePath)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return FALSE;
    }

    MultiByteToWideChar(CP_ACP, 0, pszPath, -1, pszUnicodePath, dwLen);
    BOOL bReturn = SharingDialogHelp(hwndParent, pszUnicodePath);
    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}


static BOOL WINAPI
SharingDialogHelp(
    HWND   hwndParent,
    LPWSTR pszPath          // this is 'new' memory that I take ownership of
    )
{
    CSharingPropertyPage* pPage = new CSharingPropertyPage(pszPath, TRUE);
    if (NULL == pPage)
    {
        delete[] pszPath;
        return FALSE;
    }

    HRESULT hr = pPage->InitInstance();
    if (FAILED(hr))
    {
        delete pPage;
        return FALSE;
    }

    PROPSHEETPAGE psp;

    psp.dwSize      = sizeof(psp);    // no extra data.
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_SHARE_PROPERTIES);
    psp.hIcon       = NULL;
    psp.pszTitle    = NULL;
    psp.pfnDlgProc  = CSharingPropertyPage::DlgProcPage;
    psp.lParam      = (LPARAM)pPage;  // transfer ownership
    psp.pfnCallback = CSharingPropertyPage::PageCallback;
    psp.pcRefParent = &g_NonOLEDLLRefs;

    INT_PTR ret = DialogBoxParam(
                    g_hInstance,
                    MAKEINTRESOURCE(IDD_SHARE_PROPERTIES),
                    hwndParent,
                    CSharingPropertyPage::DlgProcPage,
                    (LPARAM)&psp);
    if (-1 == ret)
    {
        appDebugOut((DEB_ERROR,"DialogBoxParam() error, 0x%08lx\n",GetLastError()));
        delete pPage;
        return FALSE;
    }

    // Now we must simulate a property sheet destroy.

    CSharingPropertyPage::PageCallback(NULL, PSPCB_RELEASE, &psp);

    return TRUE;
}


// APPCOMPAT: there appears to be a bug in the Win95 code where they think
// they're storing and using "\\machine\share", but it appears they are
// actually storing and using "machine\share".

DWORD
CopyShareNameToBuffer(
    IN     CShareInfo* p,
    IN OUT LPWSTR lpszNameBuf,
    IN     DWORD cchNameBufLen
    )
{
    appAssert(NULL != lpszNameBuf);
    appAssert(0 != cchNameBufLen);

    WCHAR szLocalComputer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD nSize = ARRAYLEN(szLocalComputer);
    if (!GetComputerName(szLocalComputer, &nSize))
    {
        return GetLastError();
    }

    /* Two slashes + server name + slash + share name + null terminator. */

    DWORD computerLen = wcslen(szLocalComputer);
    DWORD shareLen    = wcslen(p->GetNetname());
    if (2 + computerLen + 1 + shareLen + 1 <= cchNameBufLen)
    {
        /* Return network resource name as UNC path. */

        lpszNameBuf[0] = L'\\';
        lpszNameBuf[1] = L'\\';
        wcscpy(lpszNameBuf + 2, szLocalComputer);
        *(lpszNameBuf + 2 + computerLen) = L'\\';
        wcscpy(lpszNameBuf + 2 + computerLen + 1, p->GetNetname());
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_MORE_DATA;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   GetNetResourceFromLocalPathW
//
//  Synopsis:   Used by shell link tracking code.
//
//  Arguments:  [lpcszPath]      Path we're concerned about.
//              [lpszNameBuf]    If path is shared, UNC path to share goes here.
//              [cchNameBufLen] length of lpszNameBuf buffer in characters
//              [pdwNetType]     net type of local server, e.g., WNNC_NET_LANMAN
//
//  Returns:    TRUE if path is shared and net resource information
//              returned, else FALSE.
//
//  Notes:      *lpszNameBuf and *pwNetType are only valid if TRUE is returned.
//
//  Example:    If c:\documents is shared as MyDocs on machine Scratch, then
//              calling GetNetResourceFromLocalPath(c:\documents, ...) will
//              set lpszNameBuf to \\Scratch\MyDocs.
//
//  History:    3-Mar-96    BruceFo  Created from Win95 sources
//
//--------------------------------------------------------------------------

BOOL WINAPI
GetNetResourceFromLocalPathW(
    IN     LPCWSTR lpcszPath,
    IN OUT LPWSTR lpszNameBuf,
    IN     DWORD cchNameBufLen,
    OUT    PDWORD pdwNetType
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"GetNetResourceFromLocalPathW(%ws)\n", lpcszPath));

    // do some parameter validation
    if (NULL == lpcszPath || NULL == lpszNameBuf || NULL == pdwNetType || 0 == cchNameBufLen)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        InterlockedDecrement((long*)&g_NonOLEDLLRefs);
        return FALSE;
    }

    OneTimeInit();

    // Parameters seem OK (pointers might still point to bad memory);
    // do the work.

    CShareInfo* pShareList = new CShareInfo();  // dummy head node
    if (NULL == pShareList)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        InterlockedDecrement((long*)&g_NonOLEDLLRefs);
        return FALSE;   // out of memory
    }

    BOOL bReturn = FALSE;
    DWORD dwLastError;
    DWORD cShares;
    HRESULT hr = g_ShareCache.ConstructList(lpcszPath, pShareList, &cShares);
    if (SUCCEEDED(hr))
    {
        // Now, we have a list of (possibly zero) shares. The user is asking for
        // one of them. Give them the first normal, non-special share. If there
        // doesn't exist a non-special share, then give them a special share.

        if (cShares > 0)
        {
            BOOL bFoundOne = FALSE;
            CShareInfo* p;

            for (p = (CShareInfo*) pShareList->Next();
                 p != pShareList;
                 p = (CShareInfo*) p->Next())
            {
                if (p->GetType() == STYPE_DISKTREE)
                {
                    // found a share for this one.
                    bFoundOne = TRUE;
                    break;
                }
            }

            if (!bFoundOne)
            {
                for (p = (CShareInfo*) pShareList->Next();
                     p != pShareList;
                     p = (CShareInfo*) p->Next())
                {
                    if (p->GetType() == (STYPE_SPECIAL | STYPE_DISKTREE))
                    {
                        bFoundOne = TRUE;
                        break;
                    }
                }
            }

            if (bFoundOne)
            {
                dwLastError = CopyShareNameToBuffer(p, lpszNameBuf, cchNameBufLen);
                if (ERROR_SUCCESS == dwLastError)
                {
                    bReturn = TRUE;
                    *pdwNetType = WNNC_NET_LANMAN; // we only support LanMan
                }
            }
            else
            {
                // nothing found!
                dwLastError = ERROR_BAD_NET_NAME;
            }
        }
        else
        {
            dwLastError = ERROR_BAD_NET_NAME;
        }
    }
    else
    {
        dwLastError = ERROR_OUTOFMEMORY;
    }

    DeleteShareInfoList(pShareList, TRUE);

    if (!bReturn)
    {
        SetLastError(dwLastError);
    }

    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}


BOOL WINAPI
GetNetResourceFromLocalPathA(
    IN     LPCSTR lpcszPath,
    IN OUT LPSTR lpszNameBuf,
    IN     DWORD cchNameBufLen,
    OUT    PDWORD pdwNetType
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"GetNetResourceFromLocalPathA(%s)\n", lpcszPath));
    BOOL bReturn = FALSE;
    LPWSTR pszPathTmp, pszNameTmp;
    DWORD dwPathBufLen, dwNameBufLen;
    GET_BUFFER(pszPathTmp, dwPathBufLen, WCHAR, lstrlenA(lpcszPath) + 1, MAX_PATH);
    if (NULL != pszPathTmp)
    {
        MultiByteToWideChar(CP_ACP, 0, lpcszPath, -1, pszPathTmp, dwPathBufLen);

        GET_BUFFER(pszNameTmp, dwNameBufLen, WCHAR, cchNameBufLen, MAX_PATH);
        if (NULL != pszNameTmp)
        {
            // got the buffers, now party...
            bReturn = GetNetResourceFromLocalPathW(pszPathTmp, pszNameTmp, cchNameBufLen, pdwNetType);
            if (bReturn)
            {
                // now convert the return string back
                WideCharToMultiByte(CP_ACP, 0,
                        pszNameTmp, -1,
                        lpszNameBuf, cchNameBufLen,
                        NULL, NULL);
            }

            FREE_BUFFER(pszNameTmp);
        }
        else
        {
            // didn't get the buffer
            SetLastError(ERROR_OUTOFMEMORY);
        }

        FREE_BUFFER(pszPathTmp);
    }
    else
    {
        // didn't get the buffer
        SetLastError(ERROR_OUTOFMEMORY);
    }

    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetLocalPathFromNetResourceW
//
//  Synopsis:   Used by shell link tracking code.
//
//  Arguments:  [lpcszName]     A UNC path we're concerned about.
//              [dwNetType]     net type of local server, e.g., WNNC_NET_LANMAN
//              [lpszLocalPathBuf]   Buffer to place local path of UNC path
//              [cchLocalPathBufLen] length of lpszLocalPathBuf buffer in
//                                   characters
//              [pbIsLocal]     Set to TRUE if lpcszName points to a local
//                              resource.
//
//  Returns:
//
//  Notes:      *lpszLocalPathBuf and *pbIsLocal are only valid if
//              TRUE is returned.
//
//  Example:    If c:\documents is shared as MyDocs on machine Scratch, then
//              calling GetLocalPathFromNetResource(\\Scratch\MyDocs, ...) will
//              set lpszLocalPathBuf to c:\documents.
//
//  History:    3-Mar-96    BruceFo  Created from Win95 sources
//
//--------------------------------------------------------------------------

BOOL WINAPI
GetLocalPathFromNetResourceW(
    IN     LPCWSTR lpcszName,
    IN     DWORD dwNetType,
    IN OUT LPWSTR lpszLocalPathBuf,
    IN     DWORD cchLocalPathBufLen,
    OUT    PBOOL pbIsLocal
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"GetLocalPathFromNetResourceW(%ws)\n", lpcszName));
    OneTimeInit();

    BOOL bReturn = FALSE;
    DWORD dwLastError;

    *pbIsLocal = FALSE;

    if (g_fSharingEnabled)
    {
        if (0 != dwNetType && HIWORD(dwNetType) == HIWORD(WNNC_NET_LANMAN))
        {
            /* Is the network resource name a UNC path on this machine? */

            WCHAR szLocalComputer[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD nSize = ARRAYLEN(szLocalComputer);
            if (!GetComputerName(szLocalComputer, &nSize))
            {
                dwLastError = GetLastError();
            }
            else
            {
                dwLastError = ERROR_BAD_NET_NAME;

                DWORD dwLocalComputerLen = wcslen(szLocalComputer);
                if (   lpcszName[0] == L'\\'
                    && lpcszName[1] == L'\\'
                    && (0 == _wcsnicmp(lpcszName + 2, szLocalComputer, dwLocalComputerLen))
                    )
                {
                    LPCWSTR lpcszSep = &(lpcszName[2 + dwLocalComputerLen]);
                    if (*lpcszSep == L'\\')
                    {
                        *pbIsLocal = TRUE;

                        WCHAR szLocalPath[MAX_PATH];
                        if (g_ShareCache.IsExistingShare(lpcszSep + 1, NULL, szLocalPath))
                        {
                            if (wcslen(szLocalPath) < cchLocalPathBufLen)
                            {
                                wcscpy(lpszLocalPathBuf, szLocalPath);
                                dwLastError = ERROR_SUCCESS;
                                bReturn = TRUE;
                            }
                            else
                            {
                                dwLastError = ERROR_MORE_DATA;
                            }
                        }
                    }
                }
            }
        }
        else
        {
            dwLastError = ERROR_BAD_PROVIDER;
        }
    }
    else
    {
        appDebugOut((DEB_TRACE,"GetLocalPathFromNetResourceW: sharing not enabled\n"));
        dwLastError = ERROR_BAD_NET_NAME;
    }

    if (!bReturn)
    {
        SetLastError(dwLastError);
    }

    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}


BOOL WINAPI
GetLocalPathFromNetResourceA(
    IN     LPCSTR lpcszName,
    IN     DWORD dwNetType,
    IN OUT LPSTR lpszLocalPathBuf,
    IN     DWORD cchLocalPathBufLen,
    OUT    PBOOL pbIsLocal
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"GetLocalPathFromNetResourceA(%s)\n", lpcszName));

    BOOL bReturn = FALSE;
    LPWSTR pszLocalPathTmp, pszNameTmp;
    DWORD dwPathBufLen, dwNameBufLen;
    GET_BUFFER(pszLocalPathTmp, dwPathBufLen, WCHAR, cchLocalPathBufLen, MAX_PATH);
    if (NULL != pszLocalPathTmp)
    {
        GET_BUFFER(pszNameTmp, dwNameBufLen, WCHAR, lstrlenA(lpszLocalPathBuf) + 1, MAX_PATH);
        if (NULL != pszNameTmp)
        {
            MultiByteToWideChar(CP_ACP, 0, lpcszName, -1, pszNameTmp, dwNameBufLen);

            // got the buffers, now party...
            bReturn = GetLocalPathFromNetResourceW(pszNameTmp, dwNetType, pszLocalPathTmp, cchLocalPathBufLen, pbIsLocal);
            if (bReturn)
            {
                // now convert the return string back
                WideCharToMultiByte(CP_ACP, 0,
                        pszLocalPathTmp, -1,
                        lpszLocalPathBuf, cchLocalPathBufLen,
                        NULL, NULL);
            }

            FREE_BUFFER(pszNameTmp);
        }
        else
        {
            // didn't get the buffer
            SetLastError(ERROR_OUTOFMEMORY);
        }

        FREE_BUFFER(pszLocalPathTmp);
    }
    else
    {
        // didn't get the buffer
        SetLastError(ERROR_OUTOFMEMORY);
    }

    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}

STDAPI CanShareFolderW(LPCWSTR pszPath)
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"CanShareFolderW(%s)\n", pszPath));
    OneTimeInit();

    HRESULT hr = S_FALSE;

    if (g_fSharingEnabled || IsSimpleUI())
    {
        if ( (pszPath[0] >= L'A' && pszPath[0] <= L'Z') && pszPath[1] == L':')
        {
            WCHAR szRoot[4];

            szRoot[0] = pszPath[0];
            szRoot[1] = TEXT(':');
            szRoot[2] = TEXT('\\');
            szRoot[3] = 0;

            UINT uType = GetDriveType(szRoot);

            switch (uType)
            {
                case DRIVE_UNKNOWN:
                case DRIVE_NO_ROOT_DIR:
                case DRIVE_REMOTE:
                    hr = S_FALSE;
                    break;
        
                case DRIVE_FIXED:
                case DRIVE_REMOVABLE:
                    {
                        WCHAR szDesktopIni[MAX_PATH];
                        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));
                        hr = GetPrivateProfileInt(TEXT(".ShellClassInfo"), TEXT("Sharing"), TRUE, szDesktopIni) ? S_OK : S_FALSE;
                    }
                    break;

                default:
                   hr = S_OK;
                   break;
            }

            //
            // NTRAID#NTBUG9-353119-2001/04/10-jeffreys
            //
            // We need to call PathIsDirectory to prevent the "Share this
            // folder" task from appearing in the webview pane of CAB and
            // ZIP folders. (NTBUG9 #319149 and 319153)
            //
            // However, PathIsDirectory fails with ERROR_NOT_READY on an
            // empty CD or removable drive, which is a case we want to allow
            // or the Sharing page will not show. (NTBUG9 #353119)
            //
            if (S_OK == hr && !PathIsDirectory(pszPath))
            {
                hr = S_FALSE;

                if (GetLastError() == ERROR_NOT_READY &&
                    (DRIVE_CDROM == uType || DRIVE_REMOVABLE == uType) &&
                    PathIsRootW(pszPath))
                {
                    // Ok to share an empty CD or removable drive
                    hr = S_OK;
                }
            }
        }
    }

    InterlockedDecrement((long*)&g_NonOLEDLLRefs);

    return hr;
}

STDAPI ShowShareFolderUIW(HWND hwndParent, LPCWSTR pszPath)
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"ShowShareFolderUIW(%s)\n", pszPath));

    TCHAR szShare[50];
    LoadString(g_hInstance, IDS_MSGTITLE, szShare, ARRAYLEN(szShare));
    SHObjectProperties(hwndParent, SHOP_FILEPATH, pszPath, szShare);

    InterlockedDecrement((long*)&g_NonOLEDLLRefs);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\cache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       cache.cxx
//
//  Contents:   Functions to manage a cache of shares
//
//  History:    11-Apr-95    BruceFo  Created
//              21-Aug-95    BruceFo  Created CShareCache class to clean up
//                                      resource usage of resources protected
//                                      by critical section.
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "critsec.hxx"
#include "cache.hxx"
#include "dllmain.hxx"
#include "shrinfo.hxx"
#include "strhash.hxx"
#include "util.hxx"

//////////////////////////////////////////////////////////////////////////////

#if DBG == 1
VOID
DumpNetEnum(
    IN LPVOID pBufShares,
    IN ULONG entriesRead
    );
#endif // DBG == 1

//////////////////////////////////////////////////////////////////////////////

CShareCache g_ShareCache;   // the main share cache

//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::CShareCache
//
//  Synopsis:   Constructor.
//
//  History:    21-Aug-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CShareCache::CShareCache(
    VOID
    )
    :
    m_cShares(0),
    m_pBufShares(NULL),
    m_pHash(NULL)
{
    InitializeCriticalSection(&m_csBuf);
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::~CShareCache
//
//  Synopsis:   Destructor
//
//  History:    21-Aug-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CShareCache::~CShareCache()
{
    Delete();
    DeleteCriticalSection(&m_csBuf);
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::Delete
//
//  Synopsis:   Gets rid of cached memory.
//
//  History:    21-Aug-95    BruceFo  Created
//
//--------------------------------------------------------------------------

VOID
CShareCache::Delete(
    VOID
    )
{
    CTakeCriticalSection t(&m_csBuf);
    if (NULL != m_pBufShares)
    {
        NetApiBufferFree(m_pBufShares);
    }
    m_pBufShares = NULL;
    delete m_pHash;
    m_pHash = NULL;
    m_cShares = 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::IsPathShared
//
//  Synopsis:   See ::IsPathShared.
//
//  History:    21-Aug-95    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CShareCache::IsPathShared(
    LPCTSTR lpPath,
    BOOL fRefresh
    )
{
    BOOL bOldSharingEnabled = g_fSharingEnabled;
    BOOL bRet = FALSE;

    {
        // scope the critical section taking

        CTakeCriticalSection t(&m_csBuf);

        // For plug and play: if the server service starts
        // or stops, we get a refresh call.  If sharing is not currently
        // enabled but a refresh is request, see if sharing has just become
        // available.

        if (fRefresh)
        {
            appDebugOut((DEB_TRACE, "Forced cache refresh!\n"));

            RefreshNoCritSec();
        }

        if (CacheOK())
        {
            appAssert(NULL != m_pHash);
            bRet = m_pHash->IsMember(lpPath);
        }
        else
        {
            // the server doesn't seem to be running...
            bRet = FALSE;
        }
    }

    if (bOldSharingEnabled != g_fSharingEnabled)
    {
        // The server either came up or went down, and we refreshed based on
        // that fact. Force the shell/explorer to redraw *all* views.

        appDebugOut((DEB_TRACE, "Forcing the shell to redraw *all* views!\n"));

        SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
    }

    return bRet;
}



//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::Refresh
//
//  Synopsis:   Refreshes the cache of shares
//
//  History:    21-Aug-95    BruceFo  Created
//
//  Note:       Sets g_fSharingEnabled
//
//--------------------------------------------------------------------------

VOID
CShareCache::Refresh(
    VOID
    )
{
    CTakeCriticalSection t(&m_csBuf);
    RefreshNoCritSec();
}

// in:
//      pShare		  share to inspect
//      bIncludeHidden -> admin shares (X$, ADMIN$) will not be skipped
//                        otherwise they are included

BOOL ShouldSkipShare(SHARE_INFO_502* pShare, BOOL bIncludeHidden)
{
    // needs to have an associated path
    // needs to be STYPE_DISK (to skip IPC$)
    // STYPE_SPECIAL indicates hidden admin share 
    
    return (pShare->shi502_path == NULL) ||
           (pShare->shi502_path[0] == 0) ||
           ((pShare->shi502_type & ~STYPE_SPECIAL) != STYPE_DISKTREE) ||
           (bIncludeHidden ? FALSE : (pShare->shi502_type & STYPE_SPECIAL));
}



//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::RefreshNoCritSec
//
//  Synopsis:   Refreshes the cache of shares: the critical section must
//              already taken!
//
//  History:    18-Aug-95    BruceFo  Created
//
//  Note:       Sets g_fSharingEnabled
//
//--------------------------------------------------------------------------

VOID
CShareCache::RefreshNoCritSec(
    VOID
    )
{
    Delete();

    DWORD entriesRead, totalEntries;
    DWORD err = ::NetShareEnum(
                        NULL,   // local computer
                        502,
                        &m_pBufShares,
                        0xffffffff,     // no buffer limit; get them all!
                        &entriesRead,
                        &totalEntries,
                        NULL);  // no resume handle 'cause we're getting all
    if (err != NERR_Success)
    {
        appDebugOut((DEB_ERROR,
            "Error enumerating shares: 0x%08lx\n",
            err));

        m_pBufShares = NULL;    // just in case NetShareEnum munged it
        Delete();
    }
    else
    {
        appAssert(entriesRead == totalEntries);
        m_cShares = entriesRead;
    }

    if (m_cShares > 0)
    {
        //
        // Now, create a hash table and put all the shares into it (strings are
        // cached; don't copy any data)
        //

        m_pHash = new CStrHashTable(m_cShares * 2 - 1);
        if ((NULL == m_pHash) || FAILED(m_pHash->QueryError()))
        {
            // out of memory; delete everything
            Delete();
        }
        else
        {
            SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;

            for (UINT iShare = 0; iShare < m_cShares; iShare++)
            {
                SHARE_INFO_502* pShare = &pShareBase[iShare];

                if (ShouldSkipShare(pShare, FALSE)) // don't include hidden
                    continue;

                HRESULT hr = m_pHash->Insert(pShare->shi502_path);
                if (FAILED(hr))
                {
                    // out of memory; delete everything
                    Delete();
                    break;
                }
            }
        }

#if DBG == 1
        if (NULL != m_pHash)
        {
            // if everything hasn't been deleted because of a memory problem...
            m_pHash->Print();
        }
#endif // DBG == 1

    }

    g_fSharingEnabled = CacheOK();
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::IsShareNameUsed
//
//  Synopsis:   Returns TRUE if the share name in question is already used
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CShareCache::IsShareNameUsed(
    IN PWSTR pszShareName
    )
{
    CTakeCriticalSection t(&m_csBuf);

    if (!CacheOK())
    {
        return FALSE;
    }

    SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;

    for (UINT iShare = 0; iShare < m_cShares; iShare++)
    {
        SHARE_INFO_502* pShare = &pShareBase[iShare];
        if (0 == _wcsicmp(pszShareName, pShare->shi502_netname))
        {
            return TRUE;
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::IsExistingShare
//
//  Synopsis:   Finds out if a share name is already in use with a different
//              path.
//
//  Arguments:  [pszShareName] - name of share being replaced
//              [pszPath] - path to compare against
//              [pszOldPath] - If not null, filled with path of the share,
//                             if found
//
//  Returns:    Returns TRUE if found and the paths are different,
//              FALSE otherwise
//
//  History:    4-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

BOOL
CShareCache::IsExistingShare(
    IN PCWSTR pszShareName,
    IN PCWSTR pszPath,
    OUT PWSTR pszOldPath
    )
{
    appAssert(NULL != pszShareName);

    CTakeCriticalSection t(&m_csBuf);

    if (!CacheOK())
    {
        return FALSE;
    }

    SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;

    for (UINT iShare = 0; iShare < m_cShares; iShare++)
    {
        SHARE_INFO_502* pShare = &pShareBase[iShare];
        if (0 == _wcsicmp(pszShareName, pShare->shi502_netname))
        {
            if (pszOldPath != NULL)
            {
                wcscpy(pszOldPath, pShare->shi502_path);
            }

            return TRUE;
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::ConstructList
//
//  Synopsis:   Construct a list of shares for a particular path
//
//  Arguments:
//
//  Returns:    hresult
//
//  History:    21-Aug-95   BruceFo     Created
//
//--------------------------------------------------------------------------

HRESULT
CShareCache::ConstructList(
    IN PCWSTR          pszPath,
    IN OUT CShareInfo* pShareList,
    OUT ULONG*         pcShares
    )
{
    CTakeCriticalSection t(&m_csBuf);

    SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;

    HRESULT hr;
    ULONG cShares = 0;

    for (UINT iShare = 0; iShare < m_cShares; iShare++)
    {
        SHARE_INFO_502* pShare = &pShareBase[iShare];

        if (0 == _wcsicmp(pszPath, pShare->shi502_path))
        {
            if (ShouldSkipShare(pShare, TRUE))  // include hidden
                continue;
            //
            // We found one!
            //

            appDebugOut((DEB_ITRACE,
                "ConstructList: adding %ws\n",
                pShare->shi502_netname));

            CShareInfo* pNewInfo = new CShareInfo();
            if (NULL == pNewInfo)
            {
                return E_OUTOFMEMORY;
            }

            hr = pNewInfo->InitInstance();
            if (FAILED(hr))
            {
                delete pNewInfo;
                return hr;
            }

            // We can't point into the data protected by a critical section,
            // so we must copy it.
            hr = pNewInfo->Copy(pShare);
            if (FAILED(hr))
            {
                delete pNewInfo;
                return hr;
            }

            NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
            if ( NERR_Success != ret )
            {
                delete pNewInfo;
                return HRESULT_FROM_WIN32 (ret);
            }

            pNewInfo->InsertBefore(pShareList); // add to end of list

            ++cShares;
        }
    }

    *pcShares = cShares;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::ConstructParentWarnList
//
//  Synopsis:   Construct a new list of shares that are children or descendants
//              of the path passed in.
//
//  Arguments:  [pszPath] - the prefix path to check for
//              [ppShareList] - new share list, if success. Caller must delete
//                  it using 'delete' on each element. This list is
//                  doubly-linked with a dummy head node. NOTE: As an
//                  optimization, this is set to NULL if there is no share.
//                  This avoids allocating and deleting memory unless there
//                  is something to warn the user about.
//
//  Returns:    hresult
//
//  History:    21-Aug-95   BruceFo     Created
//
//--------------------------------------------------------------------------

HRESULT
CShareCache::ConstructParentWarnList(
    IN PCWSTR        pszPath,
    OUT CShareInfo** ppShareList
    )
{
    CTakeCriticalSection t(&m_csBuf);

    HRESULT hr;
    CShareInfo* pShareList = NULL;
    SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;
    INT cchPath = wcslen(pszPath);

    for (UINT iShare = 0; iShare < m_cShares; iShare++)
    {
        SHARE_INFO_502* pShare = &pShareBase[iShare];

        PWSTR pszSharePath = pShare->shi502_path;
        INT cchSharePath = wcslen(pszSharePath);

        if (cchSharePath >= cchPath)
        {
            // WARNING - the following won't work with LFN/shortname differences

            // PERF: we're doing a prefix match of the current directory
            // name on the set of share names. This could be expensive with
            // a linear search!

            if (0 == _wcsnicmp(pszSharePath, pszPath, cchPath)
                && (    *(pszSharePath + cchPath) == TEXT('\\')
                     || *(pszSharePath + cchPath) == TEXT('\0')
                   )
               )
            {
                appDebugOut((DEB_TRACE,
                    "ConstructParentWarnList, share %ws, file %ws. Found a prefix!\n",
                    pszSharePath, pszPath));

                if (NULL == pShareList)
                {
                    // do the lazy dummy head node creation if this is the
                    // first prefix match

                    pShareList = new CShareInfo();  // dummy head node
                    if (NULL == pShareList)
                    {
                        return E_OUTOFMEMORY;
                    }
                }

                CShareInfo* pNewInfo = new CShareInfo();
                if (NULL == pNewInfo)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = pNewInfo->InitInstance();
                    if (SUCCEEDED(hr))
                    {
                        // We can't point into the data protected by a
                        // critical section, so we must copy it.
                        hr = pNewInfo->Copy(pShare);
                        if ( SUCCEEDED (hr) )
                        {
                            NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
                            if ( NERR_Success != ret )
                            {
                                delete pNewInfo;
                                return HRESULT_FROM_WIN32 (ret);
                            }
                        }
                    }
                }

                if (FAILED(hr))
                {
                    delete pNewInfo;
                    DeleteShareInfoList(pShareList, TRUE);

                    return hr;
                }

                pNewInfo->InsertBefore(pShareList); // add to end of list
            }
        }
    }

    *ppShareList = pShareList;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::CacheOK
//
//  Synopsis:   Returns TRUE if the cache contains valid data.
//
//  History:    24-Sep-95    BruceFo  Created
//
//  Note:       The critical section must be held when calling this function
//
//--------------------------------------------------------------------------

BOOL
CShareCache::CacheOK(
    VOID
    )
{
    // either both are valid or both are invalid
    appAssert(
        ((NULL != m_pHash) && (NULL != m_pBufShares)) ||
        ((NULL == m_pHash) && (NULL == m_pBufShares))
        );

    return (NULL != m_pHash);
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Function:   DumpNetEnum
//
//  Synopsis:   Dumps an array of SHARE_INFO_502 structures.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

VOID
DumpNetEnum(
    IN LPVOID pBufShares,
    IN ULONG entriesRead
    )
{
    SHARE_INFO_502* pBase = (SHARE_INFO_502*) pBufShares;

    appDebugOut((DEB_TRACE,
        "DumpNetEnum: %d entries\n",
        entriesRead));

    for (ULONG i = 0; i < entriesRead; i++)
    {
        SHARE_INFO_502* p = &(pBase[i]);

        appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t Share name: %ws\n"
"\t       Type: %d (0x%08lx)\n"
"\t    Comment: %ws\n"
"\tPermissions: %d (0x%08lx)\n"
"\t   Max uses: %d\n"
"\t       Path: %ws\n"
"\t   Password: %ws\n"
"\t   Reserved: %d\n"
"\t   Security? %ws\n"
"\n"
,
p->shi502_netname,
p->shi502_type, p->shi502_type,
p->shi502_remark,
p->shi502_permissions, p->shi502_permissions,
p->shi502_max_uses,
p->shi502_path,
(NULL == p->shi502_passwd) ? L"none" : p->shi502_passwd,
p->shi502_reserved,
(NULL == p->shi502_security_descriptor) ? L"No" : L"Yes"
));

    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\dlgbase.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dlgbase.cxx
//
//  Contents:   CDialog base class
//
//  History:    19-Oct-94 BruceFo Created.
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dlgbase.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CDialog::_WinDlgProc, static private
//
//  Synopsis:   Windows Dialog Procedure
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CDialog::_WinDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CDialog *pPropPage = NULL;

    if (msg==WM_INITDIALOG)
    {
       SetWindowLongPtr(hwnd,GWLP_USERDATA,lParam);
    }

    pPropPage = (CDialog*) GetWindowLongPtr(hwnd,GWLP_USERDATA);

    if (pPropPage != NULL)
    {
        return pPropPage->DlgProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\makefile.inc ===
app.rc: $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        shell_ntshrui.manifest \
        resource.h \
        $(O)\messages.h \
        $(O)\messages.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\helpids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define HC_OK                       1
#define HC_CANCEL                   2
#define HC_SHARE_SHARENAME          3
#define HC_SHARE_COMMENT            4
#define HC_SHARE_MAXIMUM            5
#define HC_SHARE_ALLOW              6
#define HC_SHARE_ALLOW_VALUE        7
#define HC_SHARE_PERMISSIONS        8
#define HC_SHARE_NOTSHARED          9
#define HC_SHARE_SHAREDAS           10
#define HC_SHARE_SHARENAME_COMBO    11
#define HC_SHARE_REMOVE             12
#define HC_SHARE_NEWSHARE           13
#define HC_SHARE_LIMIT              14
#define IDH_SHARE_CACHING_BTN       1019
#define IDH_SHARE2_ShareOnNet       10001
#define IDH_SHARE2_ReadOnly         10002
#define IDH_SHARE2_ShareName        10003
#define IDH_SHARE2_MakePrivate      10004

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// The following are help ids for the ACL editor

// stolen from \nt\private\net\ui\common\h\uihelp.h
#define HC_UI_BASE              7000
#define HC_UI_SHELL_BASE        (HC_UI_BASE+10000)

// stolen from \nt\private\net\ui\shellui\h\helpnums.h
#define HC_NTSHAREPERMS              11 // Main share perm dialog
// The following four have to be consecutive
#define HC_SHAREADDUSER              12 // Share perm add dlg
#define HC_SHAREADDUSER_LOCALGROUP   13 // Share perm add->Members
#define HC_SHAREADDUSER_GLOBALGROUP  14 // Share perm add->Members
#define HC_SHAREADDUSER_FINDUSER     15 // Share perm add->FindUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\dlgnew.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dlgnew.cxx
//
//  Contents:   "New Share" dialog
//
//  History:    21-Feb-95 BruceFo Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "cache.hxx"
#include "dlgnew.hxx"
#include "acl.hxx"
#include "util.hxx"
#include "shrinfo.hxx"

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CDlgNewShare::SizeWndProc, public
//
//  Synopsis:   "allow" edit window subclass proc to disallow non-numeric
//              characters.
//
//  History:    5-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
CDlgNewShare::SizeWndProc(
    IN HWND hwnd,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (wMsg)
    {
    case WM_CHAR:
    {
        WCHAR chCharCode = (WCHAR)wParam;
        if (   (chCharCode == TEXT('\t'))
            || (chCharCode == TEXT('\b'))
            || (chCharCode == TEXT('\n'))
            )
        {
            break;
        }

        if (chCharCode < TEXT('0') || chCharCode > TEXT('9'))
        {
            // bad key: ignore it
            MessageBeep(0xffffffff);    // let user know it's an illegal char
            return FALSE;
        }

        break;
    }
    } // end of switch

    CDlgNewShare* pThis = (CDlgNewShare*)GetWindowLongPtr(GetParent(hwnd),GWLP_USERDATA);
    appAssert(NULL != pThis);
    return CallWindowProc(pThis->_pfnAllowProc, hwnd, wMsg, wParam, lParam);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::CDlgNewShare, private
//
//  Synopsis:   constructor
//
//--------------------------------------------------------------------------
CDlgNewShare::CDlgNewShare(
    IN HWND hwndParent
    )
    :
    CDialog(hwndParent, MAKEINTRESOURCE(IDD_NEW_SHARE)),
    _bShareNameChanged(FALSE),
    _bCommentChanged(FALSE),
    _wMaxUsers(DEFAULT_MAX_USERS),
    _fSecDescModified(FALSE),
    _pStoredSecDesc(NULL),
    _pfnAllowProc(NULL)
{
    INIT_SIG(CDlgNewShare);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::~CDlgNewShare, private
//
//  Synopsis:   destructor
//
//--------------------------------------------------------------------------
CDlgNewShare::~CDlgNewShare()
{
    CHECK_SIG(CDlgNewShare);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::DlgProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------
INT_PTR
CDlgNewShare::DlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CDlgNewShare);

    static DWORD aHelpIds[] =
    {
        IDOK,                       HC_OK,
        IDCANCEL,                   HC_CANCEL,
        IDC_SHARE_SHARENAME,        HC_SHARE_SHARENAME,
        IDC_SHARE_SHARENAME_TEXT,   HC_SHARE_SHARENAME,
        IDC_SHARE_COMMENT,          HC_SHARE_COMMENT,
        IDC_SHARE_COMMENT_TEXT,     HC_SHARE_COMMENT,
        IDC_SHARE_MAXIMUM,          HC_SHARE_MAXIMUM,
        IDC_SHARE_ALLOW,            HC_SHARE_ALLOW,
        IDC_SHARE_ALLOW_VALUE,      HC_SHARE_ALLOW_VALUE,
        IDC_SHARE_ALLOW_SPIN,       -1L, // 257807 by request of JillZ
        IDC_SHARE_PERMISSIONS,      HC_SHARE_PERMISSIONS,
        IDC_SHARE_LIMIT,            HC_SHARE_LIMIT,
        0,0
    };

    switch (msg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(hwnd);

    case WM_COMMAND:
        return _OnCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_VSCROLL:
        // The up/down control changed the edit control: select it again
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        return TRUE;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if (lphi->iContextType == HELPINFO_WINDOW)  // a control
        {
            WCHAR szHelp[50];
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                (HWND)lphi->hItemHandle,
                szHelp,
                HELP_WM_HELP,
                (DWORD_PTR)aHelpIds);
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)wParam,
            szHelp,
            HELP_CONTEXTMENU,
            (DWORD_PTR)aHelpIds);
        break;
    }

    case WM_DESTROY:
    {
        // restore original subclass to window.
        appAssert(NULL != GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE));
        SetWindowLongPtr(GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE), GWLP_WNDPROC, (LONG_PTR)_pfnAllowProc);
        return FALSE;
    }

    } // end of switch

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnInitDialog(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    // Subclass allow edit control to disallow non-positive numbers
    _pfnAllowProc = (WNDPROC)SetWindowLongPtr(
                                    GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE),
                                    GWLP_WNDPROC,
                                    (LONG_PTR)&SizeWndProc);

    // use LanMan API constants to set maximum share name & comment lengths
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_COMMENT,   EM_LIMITTEXT, MAXCOMMENTSZ, 0L);

    CheckRadioButton(
            hwnd,
            IDC_SHARE_MAXIMUM,
            IDC_SHARE_ALLOW,
            IDC_SHARE_MAXIMUM);

    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    // set the spin control range: 1 <--> large number
    SendDlgItemMessage(
            hwnd,
            IDC_SHARE_ALLOW_SPIN,
            UDM_SETRANGE,
            0,
            MAKELONG(g_uiMaxUsers, 1));

    SetFocus(GetDlgItem(hwnd, IDC_SHARE_SHARENAME));

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDlgNewShare::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CDlgNewShare);

    switch (wID)
    {

//
// Notifications
//

    case IDC_SHARE_MAXIMUM:
        if (BN_CLICKED == wNotifyCode)
        {
            // Take away WS_TABSTOP from the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) & ~WS_TABSTOP);

            _CacheMaxUses(hwnd);
            SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");
        }
        return TRUE;

    case IDC_SHARE_ALLOW:
        if (BN_CLICKED == wNotifyCode)
        {
            // Give WS_TABSTOP to the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) | WS_TABSTOP);

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        }
        return TRUE;

    case IDC_SHARE_ALLOW_VALUE:
    {
        if (EN_SETFOCUS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        }
        if (EN_KILLFOCUS == wNotifyCode)
        {
            _CacheMaxUses(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_ALLOW_SPIN:
        if (UDN_DELTAPOS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }
        }
        return TRUE;

    case IDC_SHARE_SHARENAME:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bShareNameChanged = TRUE;
        }
        return TRUE;
    }

    case IDC_SHARE_COMMENT:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bCommentChanged = TRUE;
        }
        return TRUE;
    }


//
// Commands
//

    case IDOK:
        return _OnOK(hwnd);

    case IDCANCEL:
        EndDialog(hwnd, FALSE);
        return TRUE;

    case IDC_SHARE_PERMISSIONS:
        return _OnPermissions(hwnd);

    } // end of switch (wID)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnOK, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnOK(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    HRESULT hr;

    // Validate the share

    WCHAR szShareName[NNLEN + 1];

    if (0 == GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName)))
    {
        MyErrorDialog(hwnd, IERR_BlankShareName);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }

	TrimLeadingAndTrailingSpaces(szShareName);

    HRESULT uTemp;
    if (!IsValidShareName(szShareName, &uTemp))
    {
        MyErrorDialog(hwnd, uTemp);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }

    // Trying to create a reserved share?
    if (0 == _wcsicmp(g_szIpcShare, szShareName))
    {
        MyErrorDialog(hwnd, IERR_SpecialShare);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }

    if (0 == _wcsicmp(g_szAdminShare, szShareName))
    {
        // We will let the admin create the admin$ share if they create
        // it in the directory specified by GetWindowsDirectory().
        WCHAR szWindowsDir[MAX_PATH];
        UINT err = GetWindowsDirectory(szWindowsDir, ARRAYLEN(szWindowsDir));
        if (err == 0)
        {
            // oh well, give them this error
            MyErrorDialog(hwnd, IERR_SpecialShare);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }

        if (0 != _wcsicmp(m_pShareInfo->GetPath(), szWindowsDir))
        {
            MyErrorDialog(hwnd, IERR_SpecialShare);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }

        // otherwise, it is the right directory. Let them create it.
    }

    // Check to see that the same share doesn't already exist. We don't allow
    // the user to create a share with the same name as a marked-for-delete
    // share, because it's easier!
    for (CShareInfo* p = (CShareInfo*) m_pInfoList->Next();
         p != m_pInfoList;
         p = (CShareInfo*) p->Next())
    {
        if (0 == _wcsicmp(p->GetNetname(), szShareName))
        {
            MyErrorDialog(hwnd, IERR_AlreadyExists, szShareName);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return TRUE;
        }
    }

    /* removed JonN 10/5/98
    // Check for downlevel accessibility
    // we should really get rid of this at some point -- JonN 7/18/97
    ULONG nType;
    if (NERR_Success != NetpPathType(NULL, szShareName, &nType, INPT_FLAGS_OLDPATHS))
    {
        DWORD id = MyConfirmationDialog(
                        hwnd,
                        IERR_InaccessibleByDos,
                        MB_YESNO | MB_ICONEXCLAMATION,
                        szShareName);
        if (id == IDNO)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return TRUE;
        }
    }
    */

    WCHAR szOldPath[PATHLEN + 1];

    if (g_ShareCache.IsExistingShare(szShareName, m_pShareInfo->GetPath(), szOldPath))
    {
        DWORD id = ConfirmReplaceShare(hwnd, szShareName, szOldPath, m_pShareInfo->GetPath());
        if (id != IDYES)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return TRUE;
        }

        // User said to replace the old share. We need to add
        // a "delete" record for the old share.

        CShareInfo* pNewInfo = new CShareInfo();
        if (NULL == pNewInfo)
        {
            return FALSE;
        }

        hr = pNewInfo->InitInstance();
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pNewInfo;
            return FALSE;
        }

        hr = pNewInfo->SetNetname(szShareName);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pNewInfo;
            return FALSE;
        }

        hr = pNewInfo->SetPath(szOldPath);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pNewInfo;
            return FALSE;
        }

        NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
        if ( NERR_Success != ret )
        {
            delete pNewInfo;
            return HRESULT_FROM_WIN32 (ret);
        }

        pNewInfo->SetDirtyFlag(SHARE_FLAG_REMOVE);
        pNewInfo->InsertBefore(m_pReplaceList); // add to end of replace list
    }

    // Everything OK, save away the data

    if (_bShareNameChanged)
    {
        hr = m_pShareInfo->SetNetname(szShareName);
        CHECK_HRESULT(hr);
    }

    if (_bCommentChanged)
    {
        WCHAR szComment[MAXCOMMENTSZ + 1];
        GetDlgItemText(hwnd, IDC_SHARE_COMMENT, szComment, ARRAYLEN(szComment));
        hr = m_pShareInfo->SetRemark(szComment);
        CHECK_HRESULT(hr);
    }

    if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_MAXIMUM))
    {
        hr = m_pShareInfo->SetMaxUses(SHI_USES_UNLIMITED);
        CHECK_HRESULT(hr);
    }
    else if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
    {
        _CacheMaxUses(hwnd);
        hr = m_pShareInfo->SetMaxUses(_wMaxUsers);
        CHECK_HRESULT(hr);
    }

    EndDialog(hwnd, TRUE);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnPermissions, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
BOOL
CDlgNewShare::_OnPermissions(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    WCHAR szShareName[NNLEN + 1];
    GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
    // don't trim spaces, this might be an existing share with spaces in its name

    PSECURITY_DESCRIPTOR pNewSecDesc = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = m_pShareInfo->GetSecurityDescriptor();
    appAssert(NULL == pSecDesc || IsValidSecurityDescriptor(pSecDesc));

    BOOL bSecDescChanged;
    LONG err = EditShareAcl(
                        hwnd,
                        NULL,
                        szShareName,
                        pSecDesc,
                        &bSecDescChanged,
                        &pNewSecDesc);

    if (bSecDescChanged)
    {
        _fSecDescModified = TRUE;

        appAssert(IsValidSecurityDescriptor(pNewSecDesc));
        m_pShareInfo->TransferSecurityDescriptor(pNewSecDesc);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_CacheMaxUses, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CDlgNewShare::_CacheMaxUses(
    IN HWND hwnd
    )
{
    DWORD dwRet = (DWORD)SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_GETPOS, 0, 0);
    if (HIWORD(dwRet) != 0)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        // Reset the edit control to the new value
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }
    else
    {
        _wMaxUsers = LOWORD(dwRet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\dllmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       dllmain.hxx
//
//  Contents:   DLL initialization entrypoint and global variables
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <locale.h>

#include "resource.h"
#include "critsec.hxx"
#include "cache.hxx"
#include "strhash.hxx"
#include "dllmain.hxx"
#include "util.hxx"

//--------------------------------------------------------------------------
// Globals used elsewhere

UINT        g_NonOLEDLLRefs = 0;
HINSTANCE   g_hInstance = NULL;
BOOL        g_fSharingEnabled = FALSE;   // until proven otherwise
UINT        g_uiMaxUsers = 0;   // max number of users based on product type

WCHAR       g_szAdminShare[] = L"ADMIN$";
WCHAR       g_szIpcShare[]   = L"IPC$";

//--------------------------------------------------------------------------
// Globals used only in this file

CRITICAL_SECTION    g_csOneTimeInit;
BOOL                g_fOneTimeInitDone = FALSE;

// Note: the total wait time is:
//    min( (the wait hint / WAIT_FRACTION), MAX_WAIT_PERIOD ) * MAX_WAIT_COUNT
// In the case of the server, with a 30 second hint, about 2 minutes, 30 sec.

#define WAIT_FRACTION   4       // the fraction of the hint to wait
#define MAX_WAIT_COUNT  20      // the maximum number of wait failures to tolerate before quiting
#define MAX_WAIT_PERIOD 15000L  // 15 seconds

#define WAIT_TO_BEGIN_GRANULARITY   4000    // 4 seconds
#define MAX_WAIT_TO_BEGIN           90000L  // 90 seconds: time to wait before giving up that it will ever start

//--------------------------------------------------------------------------
// Debugging

DECLARE_INFOLEVEL(Sharing)

//--------------------------------------------------------------------------

VOID
InitializeShareCache(
    VOID
    );

DWORD WINAPI
WaitForServerThread(
    IN LPVOID ThreadParameter
    );

BOOL
CheckServiceController(
    VOID
    );

BOOL
ServerConfiguredToStart(
    SC_HANDLE hScManager
    );

BOOL
WaitForServerToBeginStarting(
    SC_HANDLE hService,
    LPSERVICE_STATUS pServiceStatus // so we don't need to re-query on successful return
    );

//--------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Win32 DLL initialization function
//
//  Arguments:  [hInstance] - Handle to this dll
//              [dwReason]  - Reason this function was called.  Can be
//                            Process/Thread Attach/Detach.
//
//  Returns:    BOOL    - TRUE if no error.  FALSE otherwise
//
//  History:    4-Apr-95 BruceFo  Created
//
//---------------------------------------------------------------------------

extern "C"
BOOL
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
#if DBG == 1
        InitializeDebugging();
//         SharingInfoLevel = DEB_ERROR | DEB_TRACE;
        SharingInfoLevel = DEB_ERROR;
        SetWin4AssertLevel(ASSRT_BREAK | ASSRT_MESSAGE);
#endif // DBG == 1

        appDebugOut((DEB_TRACE, "ntshrui.dll: DllMain enter\n"));

        // Disable thread notification from OS
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance;
        // Be specific about where to get your manifest from - it's in the dll, at the
        // default resource ID for the shell, which is 123.
        SHFusionInitializeFromModuleID(hInstance, SHFUSION_DEFAULT_RESOURCE_ID);
        InitCommonControls();   // get up/down control
// eting removal of MSVCRT        setlocale(LC_CTYPE, ""); // set the C runtime library locale, for string operations
        InitializeCriticalSection(&g_csOneTimeInit);
        break;
    }

    case DLL_PROCESS_DETACH:
        appDebugOut((DEB_TRACE, "ntshrui.dll: DllMain leave\n"));
        SHFusionUninitialize();
        DeleteCriticalSection(&g_csOneTimeInit);
        break;
    }

    return TRUE;
}

extern HRESULT SharePropDummyFunction();
HRESULT Linkage()
{
    return SharePropDummyFunction();
}

//+-------------------------------------------------------------------------
//
//  Function:   OneTimeInit
//
//  Synopsis:   Initialization code: check if SMB server is running
//
//  History:    21-Apr-95 BruceFo  Created
//
//  Returns:
//  Note:       We don't want to do this in the DLL initialization code, so
//              we call it for every entrypoint, namely DllGetClassObject,
//              DllCanUnloadNow, and IsPathShared.
//
//--------------------------------------------------------------------------

VOID
OneTimeInit(
    IN BOOL bDialog // TRUE if for dialog API
    )
{
    // quick check; no critical section
    if (g_fOneTimeInitDone)
    {
        return;
    }

    {
        CTakeCriticalSection t(&g_csOneTimeInit);   // scope it

        // Since there wasn't a critical section on the above check, multiple
        // threads might have fallen through to the critical section taking,
        // and wait. After the one-time initialization is complete, the
        // first thread sets g_fOneTimeInitDone to TRUE and leaves the
        // critical section. At this point, the other threads will wake up
        // here. Do the check again, and return if another thread did the
        // initialization.

        if (g_fOneTimeInitDone)
        {
            return;
        }

        // Now, do the actual initialization

        if (!bDialog)
        {
            // First, determine if the server is running. If not, see if
            // we should wait for it. If we wait and it still isn't
            // started, then give up.

            InitializeShareCache();
        }
        // if it is a dialog call, then we don't load up the cache because
        // that's the first thing the dialog code does.

        // Determine the maximum number of users
        g_uiMaxUsers = IsWorkstationProduct()
                            ? MAX_USERS_ON_WORKSTATION
                            : MAX_USERS_ON_SERVER
                            ;

        g_fOneTimeInitDone = TRUE;  // set this *last*
    }
}


VOID
InitializeShareCache(
    VOID
    )

/*++

Routine Description:

    This routine initializes the share cache. It determines if the LanMan
    server is running. If it is, great.
    If it isn't, determine if it is starting. If so, wait for a while. After
    a while, if it still hasn't started, then give up and assume it's hung.
    If the server isn't starting, then determine if the configuration says it
    is going to start (set to autostart). If so, wait to see if it ever goes
    into the "start pending" state. Give up after a reasonable period. If it
    does go into this state, then wait for it to finish starting, as described
    before.

    Both LanMan and Service Controller APIs are used in this endeavor.

Arguments:

    None

Return Value:

    Returns TRUE if the server service has been started; otherwise
    returns FALSE.  Any API errors return FALSE, and hence assume
    the server isn't started or won't start.

--*/

{
    appDebugOut((DEB_TRACE, "InitializeShareCache: enter\n"));

    g_ShareCache.Refresh(); // sets g_fSharingEnabled
    if (g_fSharingEnabled)
    {
        // well, we've got a cache so no need to start up a thread and wait
        // for the server to start
        return;
    }

    // The server isn't currently started. Create a thread that waits for it
    // to start, and if it does, refreshes the shell.

    DWORD threadId;
    HANDLE hThread = CreateThread(
                            NULL,
                            0,
                            WaitForServerThread,
                            NULL,
                            0,
                            &threadId);
    if (NULL == hThread)
    {
        appDebugOut((DEB_ERROR, "Error creating thread\n"));
    }
    else
    {
        CloseHandle(hThread); // No reason to keep handle around
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   WaitForServerThread
//
//  Synopsis:   Thread procedure for the thread that waits for the server
//              to start.
//
//  History:    25-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

DWORD WINAPI
WaitForServerThread(
    IN LPVOID ThreadParameter
    )
{
    appDebugOut((DEB_TRACE, "Created thread to wait for server to start\n"));

    if (CheckServiceController())
    {
        // the server has started

        appDebugOut((DEB_TRACE, "The server finally started, after waiting in a thread. Refresh all!\n"));

        g_ShareCache.Refresh(); // sets g_fSharingEnabled

    }

    return 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   CheckServiceController
//
//  Synopsis:   Returns TRUE if the server starts, based on consulting the
//              service controller and waiting for the server to start.
//
//  History:    25-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CheckServiceController(
    VOID
    )
{
    // See if it is currently starting.

    SC_HANDLE hScManager;
    SC_HANDLE hService;
    SERVICE_STATUS serviceStatus;

    hScManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hScManager == NULL)
    {
        appDebugOut((DEB_ERROR,
                "CheckServiceController: OpenSCManager failed: 0x%08lx\n",
                GetLastError()));

        return FALSE;
    }

    appDebugOut((DEB_TRACE, "CheckServiceController: opening server service\n"));

    hService = OpenService(hScManager, SERVICE_SERVER, SERVICE_QUERY_STATUS);
    if (hService == NULL)
    {
        appDebugOut((DEB_ERROR,
                "CheckServiceController: OpenService failed: 0x%08lx\n",
                GetLastError()));

        CloseServiceHandle(hScManager);
        return FALSE;
    }

    // Now we've got a handle to the server service. See if it's started.

    appDebugOut((DEB_TRACE, "CheckServiceController: querying server service\n"));

    if (!QueryServiceStatus(hService, &serviceStatus))
    {
        appDebugOut((DEB_ERROR,
                "CheckServiceController: QueryServiceStatus failed: 0x%08lx\n",
                GetLastError()));

        CloseServiceHandle(hScManager);
        CloseServiceHandle(hService);
        return FALSE;
    }

    if (serviceStatus.dwCurrentState == SERVICE_RUNNING)
    {
        appDebugOut((DEB_TRACE, "CheckServiceController: Server is running!\n"));

        // we've off to the races!

        CloseServiceHandle(hScManager);
        CloseServiceHandle(hService);
        return TRUE;
    }

    if (serviceStatus.dwCurrentState != SERVICE_START_PENDING)
    {
        appDebugOut((DEB_TRACE, "CheckServiceController: Server is not running nor is it starting! State = %d\n", serviceStatus.dwCurrentState));

        // The server is not in the process of starting. Go check its
        // configuration and see if it is even configured to start.

        if (!ServerConfiguredToStart(hScManager))
        {
            // the service is not in the process of starting, nor is it
            // configured to start, so we give up.

            CloseServiceHandle(hScManager);
            CloseServiceHandle(hService);
            return FALSE;
        }

        if (!WaitForServerToBeginStarting(hService, &serviceStatus))
        {
            // The server is configured to start, but we already waited for
            // it to commence starting, and it never did. So give up on
            // it.

            CloseServiceHandle(hScManager);
            CloseServiceHandle(hService);
            return FALSE;
        }

        // the server is configured to start, we waited for it to commence
        // its startup sequence, and it actually did commence starting!
    }

    // In this case, the service is trying to start. Wait until it either
    // starts or we think it's hung.

    appDebugOut((DEB_TRACE, "CheckServiceController: Server is starting\n"));

    //
    // record the current check point. The service should "periodically
    // increment" this if it is making progress.
    //

    DWORD lastCheckPoint = serviceStatus.dwCheckPoint;
    DWORD waitCount = 0;

    while (serviceStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        if (lastCheckPoint == serviceStatus.dwCheckPoint)
        {
            ++waitCount;
            if (waitCount > MAX_WAIT_COUNT)
            {
                appDebugOut((DEB_TRACE,
                    "CheckServiceController: Server service is HUNG\n"));

                CloseServiceHandle(hScManager);
                CloseServiceHandle(hService);
                return FALSE;
            }
        }
        else
        {
            waitCount = 0;
            lastCheckPoint = serviceStatus.dwCheckPoint;
        }

        // Ideally, we would wait the wait hint and be done with it. However,
        // We don't want to be waiting if the service gives us an overly
        // generous wait hint and finishes while we're still waiting. So,
        // wait a fraction of the wait hint. The exact fraction is
        // 1/WAIT_FRACTION. The effect is that we wait no more than
        // MAX_WAIT_COUNT / WAIT_FRACTION times the wait hint before
        // giving up. We make sure we wait at least 1 second between checks.
        // Finally, cap the wait hint in case it is far to large, possibly
        // in error.

        DWORD dwWait = serviceStatus.dwWaitHint / WAIT_FRACTION;
        dwWait = (dwWait > MAX_WAIT_PERIOD) ? MAX_WAIT_PERIOD : dwWait;
        dwWait = (dwWait < 1000) ? 1000 : dwWait; // at least 1 second

        appDebugOut((DEB_TRACE,
            "CheckServiceController: sleeping. hint = %d, actually waiting %d\n",
            serviceStatus.dwWaitHint, dwWait));

        Sleep(dwWait);

        if (!QueryServiceStatus(hService, &serviceStatus))
        {
            appDebugOut((DEB_ERROR,
                    "CheckServiceController: QueryServiceStatus failed: 0x%08lx\n",
                    GetLastError()));

            CloseServiceHandle(hScManager);
            CloseServiceHandle(hService);
            return FALSE;
        }
    }

    CloseServiceHandle(hScManager);
    CloseServiceHandle(hService);

    if (serviceStatus.dwCurrentState == SERVICE_RUNNING)
    {
        appDebugOut((DEB_TRACE, "CheckServiceController: service finally started\n"));

        // This magic line refreshes *all* the explorer windows. Unfortunately,
        // it causes a share cache refresh for each one as well...
        SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

        return TRUE;    // Finally! It's running!
    }
    else
    {
        appDebugOut((DEB_TRACE, "CheckServiceController: service never started\n"));
        return FALSE;
    }
}


BOOL
ServerConfiguredToStart(
    SC_HANDLE hScManager
    )
{
    // We re-open the service because we want a different type of permission

    SC_HANDLE hService = OpenService(hScManager, SERVICE_SERVER, SERVICE_QUERY_CONFIG);
    if (hService == NULL)
    {
        appDebugOut((DEB_ERROR,
                "ServerConfiguredToStart: OpenService failed: 0x%08lx\n",
                GetLastError()));

        return FALSE;
    }

    BOOL b;
    DWORD cbBytesNeeded;
    BYTE buffer[1024];  // a large buffer...
    LPQUERY_SERVICE_CONFIG lpqscServConfig = (LPQUERY_SERVICE_CONFIG)buffer;
    b = QueryServiceConfig(
                    hService,
                    lpqscServConfig,
                    sizeof(buffer),
                    &cbBytesNeeded);
    if (!b)
    {
        appDebugOut((DEB_ERROR,
                "ServerConfiguredToStart: QueryServiceConfig failed: 0x%08lx\n",
                GetLastError()));

        return FALSE;
    }

    b = (lpqscServConfig->dwStartType == SERVICE_AUTO_START);
    CloseServiceHandle(hService);

    appDebugOut((DEB_TRACE,
        "ServerConfiguredToStart: configured to start? %s\n",
        b ? "yes" : "no"));

    return b;
}


BOOL
WaitForServerToBeginStarting(
    SC_HANDLE hService,
    LPSERVICE_STATUS pServiceStatus // so we don't need to re-query on successful return
    )
{
    // Here's the algorithm:
    //      wait WAIT_TO_BEGIN_GRANULARITY milliseconds
    //      query status
    //      if the service is running then return TRUE
    //      if we've waited MAX_WAIT_TO_BEGIN ms, return FALSE
    //      go back and wait again...

    DWORD dwWaitedMilliseconds;

    for (dwWaitedMilliseconds = 0;
         dwWaitedMilliseconds < MAX_WAIT_TO_BEGIN;
         dwWaitedMilliseconds += WAIT_TO_BEGIN_GRANULARITY)
    {
        appDebugOut((DEB_TRACE,
            "WaitForServerToBeginStarting: sleeping\n"));

        Sleep(WAIT_TO_BEGIN_GRANULARITY);

        if (!QueryServiceStatus(hService, pServiceStatus))
        {
            appDebugOut((DEB_ERROR,
                    "WaitForServerToBeginStarting: QueryServiceStatus failed: 0x%08lx\n",
                    GetLastError()));

            return FALSE;
        }

        if (   pServiceStatus->dwCurrentState == SERVICE_RUNNING
            || pServiceStatus->dwCurrentState == SERVICE_START_PENDING
            )
        {
            appDebugOut((DEB_TRACE,
                "WaitForServerToBeginStarting: server commenced startup\n"));

            return TRUE;
        }
    }

    appDebugOut((DEB_TRACE,
        "WaitForServerToBeginStarting: waited %d milliseconds for server to commence startup, then gave up\n",
         MAX_WAIT_TO_BEGIN));

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\permpage.h ===
// PermPage.h : Declaration of the standard permissions page class

#ifndef __PERMPAGE_H_INCLUDED__
#define __PERMPAGE_H_INCLUDED__

#include "aclui.h"

class CSecurityInformation : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo ) = 0;
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) = 0;
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) = 0;
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags,
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess );
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask);
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes );
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

protected:
	HRESULT NewDefaultDescriptor(
		PSECURITY_DESCRIPTOR* ppsd,
		SECURITY_INFORMATION RequestedInformation
		);

	// this will throw a memory exception where appropriate
	HRESULT MakeSelfRelativeCopy(
		PSECURITY_DESCRIPTOR  psdOriginal,
		PSECURITY_DESCRIPTOR* ppsdNew );
};

class CShareSecurityInformation : public CSecurityInformation
{
private:
	LPWSTR m_strMachineName;
	LPWSTR m_strShareName;
public:
	void SetMachineName( LPWSTR pszMachineName )
	{
		m_strMachineName = pszMachineName;
	}
	void SetShareName( LPWSTR pszShareName )
	{
		m_strShareName = pszShareName;
	}
	// note: these should be LPCTSTR but are left this way for convenience
	LPWSTR QueryMachineName()
	{
		return m_strMachineName;
	}
	LPWSTR QueryShareName()
	{
		return m_strShareName;
	}

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
};

class CSMBSecurityInformation : public CShareSecurityInformation
{
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );
public:
	// SHARE_INFO_502* m_pvolumeinfo;
	PSECURITY_DESCRIPTOR m_pInitialDescriptor;
	PSECURITY_DESCRIPTOR* m_ppCurrentDescriptor;
	CSMBSecurityInformation();
	~CSMBSecurityInformation();
};


#endif // ~__PERMPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\permpage.cxx ===
// PermPage.cxx : Implementation ACL Editor classes
// jonn 7/10/97 copied from \nt\private\admin\snapin\filemgmt\permpage.cpp

#include "headers.hxx"
#pragma hdrstop

#include "acl.hxx"
#include "resource.h" // IDS_SHAREPERM_*

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

#include <sddl.h>   // ConvertStringSecurityDescriptorToSecurityDescriptor

// need IID_ISecurityInformation
#define INITGUID
#include <initguid.h>
#include <aclui.h>

//
// I define my own implementation of ISecurityInformation
//

class CSecurityInformation : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo ) = 0;
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) = 0;
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) = 0;
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags,
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess );
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask);
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes );
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

protected:
    HRESULT NewDefaultDescriptor(
        PSECURITY_DESCRIPTOR* ppsd,
        SECURITY_INFORMATION RequestedInformation
        );

    HRESULT MakeSelfRelativeCopy(
        PSECURITY_DESCRIPTOR  psdOriginal,
        PSECURITY_DESCRIPTOR* ppsdNew );
};

class CShareSecurityInformation : public CSecurityInformation
{
private:
    LPWSTR m_strMachineName;
    LPWSTR m_strShareName;
    WCHAR  m_szTitle[200];
public:
    CShareSecurityInformation()
    {
        LoadString( g_hInstance, IDS_PERMPAGE_TITLE, m_szTitle, ARRAYLEN(m_szTitle) );
    }
    void SetMachineName( LPWSTR pszMachineName )
    {
        m_strMachineName = pszMachineName;
    }
    void SetShareName( LPWSTR pszShareName )
    {
        m_strShareName = pszShareName;
    }
    // note: these should be LPCTSTR but are left this way for convenience
    LPWSTR QueryMachineName()
    {
        return m_strMachineName;
    }
    LPWSTR QueryShareName()
    {
        return m_strShareName;
    }

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
};

class CSMBSecurityInformation : public CShareSecurityInformation
{
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );
public:
	PSECURITY_DESCRIPTOR m_pInitialDescriptor;
	PSECURITY_DESCRIPTOR* m_ppCurrentDescriptor;
	CSMBSecurityInformation();
	~CSMBSecurityInformation();
};



// ISecurityInformation interface implementation

SI_ACCESS siShareAccesses[] =
{
  { &GUID_NULL, 
    FILE_ALL_ACCESS, 
    MAKEINTRESOURCE(IDS_SHAREPERM_ALL), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE | FILE_GENERIC_WRITE | DELETE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_MODIFY), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_READ), 
    SI_ACCESS_GENERAL }
};
#define iShareDefAccess      2   // FILE_GEN_READ
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

STDMETHODIMP CSecurityInformation::GetAccessRights (
                            const GUID* pguidObjectType,
                            DWORD dwFlags,
                            PSI_ACCESS *ppAccess,
                            ULONG *pcAccesses,
                            ULONG *piDefaultAccess )
{
    appAssert(ppAccess != NULL);
    appAssert(pcAccesses != NULL);
    appAssert(piDefaultAccess != NULL);

    *ppAccess = siShareAccesses;
    *pcAccesses = ARRAYSIZE(siShareAccesses);
    *piDefaultAccess = iShareDefAccess;

    return S_OK;
}

// This is consistent with the NETUI code
GENERIC_MAPPING ShareMap =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

STDMETHODIMP CSecurityInformation::MapGeneric (
                       const GUID *pguidObjectType,
                       UCHAR *pAceFlags,
                       ACCESS_MASK *pMask)
{
    appAssert(pMask != NULL);

    MapGenericMask(pMask, &ShareMap);

    return S_OK;
}

STDMETHODIMP CSecurityInformation::GetInheritTypes (
                            PSI_INHERIT_TYPE *ppInheritTypes,
                            ULONG *pcInheritTypes )
{
    appAssert(FALSE);
    return E_NOTIMPL;
}
STDMETHODIMP CSecurityInformation::PropertySheetPageCallback(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage )
{
    return S_OK;
}

/*
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.  This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
*/
STDMETHODIMP CShareSecurityInformation::GetObjectInformation (
    PSI_OBJECT_INFO pObjectInfo )
{
    appAssert(pObjectInfo != NULL &&
           !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

    pObjectInfo->dwFlags = SI_EDIT_ALL | SI_NO_ACL_PROTECT | SI_PAGE_TITLE;
    pObjectInfo->hInstance = g_hInstance;
    pObjectInfo->pszServerName = QueryMachineName();
    pObjectInfo->pszObjectName = QueryShareName();

    // page title added JonN 3/8/99 per 115196
    pObjectInfo->pszPageTitle = m_szTitle;

    return S_OK;
}

//
// caller must free using LocalFree()
//
// jeffreys 10/11/2000: Replaced all of the old ACL goop with a
// call to ConvertStringSecurityDescriptorToSecurityDescriptor.
//

const WCHAR c_szDefaultShareSD[] = L"O:BAG:BAD:(A;;GA;;;WD)";

HRESULT CSecurityInformation::NewDefaultDescriptor(
    PSECURITY_DESCRIPTOR* ppsd,
    SECURITY_INFORMATION RequestedInformation
    )
{
    HRESULT hr = S_OK;

    *ppsd = NULL;

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            c_szDefaultShareSD,
            SDDL_REVISION_1,
            ppsd,
            NULL))
    {
        DWORD err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
    }

    return hr;
}

HRESULT CSecurityInformation::MakeSelfRelativeCopy(
	PSECURITY_DESCRIPTOR  psdOriginal,
	PSECURITY_DESCRIPTOR* ppsdNew )
{
	appAssert( NULL != psdOriginal );

	// we have to find out whether the original is already self-relative
	SECURITY_DESCRIPTOR_CONTROL sdc = 0;
	DWORD dwRevision = 0;
	if ( !::GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) )
	{
		appAssert( FALSE );
		DWORD err = ::GetLastError();
		return HRESULT_FROM_WIN32( err );
	}

	DWORD cb = ::GetSecurityDescriptorLength( psdOriginal ) + 20;
	PSECURITY_DESCRIPTOR psdSelfRelativeCopy = reinterpret_cast<PSECURITY_DESCRIPTOR>(
		::LocalAlloc(LMEM_ZEROINIT, cb) );
	if (NULL == psdSelfRelativeCopy)
	{
		return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}

	if ( sdc & SE_SELF_RELATIVE )
	// the original is in self-relative format, just byte-copy it
	{
		::memcpy( psdSelfRelativeCopy, psdOriginal, cb - 20 );
	}
	else if ( !::MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) )
	// the original is in absolute format, convert-copy it
	{
		appAssert( FALSE );
		if( NULL != ::LocalFree( psdSelfRelativeCopy ) )
		{
			appAssert(FALSE);
		}
		DWORD err = ::GetLastError();
		return HRESULT_FROM_WIN32( err );
	}
	*ppsdNew = psdSelfRelativeCopy;
	return S_OK;
}

CSMBSecurityInformation::CSMBSecurityInformation()
: CShareSecurityInformation()
, m_pInitialDescriptor( NULL )
, m_ppCurrentDescriptor( NULL )
{
}

CSMBSecurityInformation::~CSMBSecurityInformation()
{
}

STDMETHODIMP CSMBSecurityInformation::GetSecurity (
                        SECURITY_INFORMATION RequestedInformation,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                        BOOL fDefault )
{
	appAssert( NULL != m_ppCurrentDescriptor );

	// NOTE: we allow NULL == ppSecurityDescriptor, see SetSecurity
    if (0 == RequestedInformation )
    {
        appAssert(FALSE);
        return E_INVALIDARG;
    }

    if (fDefault)
        return E_NOTIMPL;

	if ( NULL == ppSecurityDescriptor )
		return S_OK;

	*ppSecurityDescriptor = NULL;

	HRESULT hr = S_OK;
	if (NULL != *m_ppCurrentDescriptor)
	{
		hr = MakeSelfRelativeCopy(
			*m_ppCurrentDescriptor,
			ppSecurityDescriptor );
		appAssert( SUCCEEDED(hr) && NULL != *ppSecurityDescriptor );
	}
	else if (NULL != m_pInitialDescriptor)
	{
		hr = MakeSelfRelativeCopy(
			m_pInitialDescriptor,
			ppSecurityDescriptor );
		appAssert( SUCCEEDED(hr) && NULL != *ppSecurityDescriptor );
	}
	else
	{
		hr = NewDefaultDescriptor(
			ppSecurityDescriptor,
			RequestedInformation );
		appAssert( SUCCEEDED(hr) && NULL != *ppSecurityDescriptor );
	}
	return hr;
}

STDMETHODIMP CSMBSecurityInformation::SetSecurity (
                        SECURITY_INFORMATION SecurityInformation,
                        PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
	appAssert( NULL != m_ppCurrentDescriptor );

	if (NULL != *m_ppCurrentDescriptor)
	{
		::LocalFree(*m_ppCurrentDescriptor);
		*m_ppCurrentDescriptor = NULL;
	}
	HRESULT hr = MakeSelfRelativeCopy(
		pSecurityDescriptor,
		m_ppCurrentDescriptor );
	appAssert( SUCCEEDED(hr) && NULL != *m_ppCurrentDescriptor );
	return hr;
}

HMODULE g_hlibACLUI = NULL;
typedef BOOL (*EDIT_SECURITY_PROC) ( HWND, LPSECURITYINFO );
EDIT_SECURITY_PROC g_pfnEditSecurityProc;

LONG
EditShareAcl(
    IN HWND                      hwndParent,
    IN LPWSTR                    pszServerName,
    IN TCHAR *                   pszShareName,
    IN PSECURITY_DESCRIPTOR      pSecDesc,
    OUT BOOL*                    pfSecDescModified,
    OUT PSECURITY_DESCRIPTOR*    ppSecDesc
	)
{
	appAssert( ppSecDesc != NULL );
	*ppSecDesc = NULL;

	if (NULL == g_hlibACLUI)
	{
		g_hlibACLUI = ::LoadLibrary(L"ACLUI.DLL");
		if (NULL == g_hlibACLUI)
		{
			appAssert(FALSE); // ACLUI.DLL isn't installed?
			return 0;
		}
	}

	if (NULL == g_pfnEditSecurityProc)
	{
		g_pfnEditSecurityProc = reinterpret_cast<EDIT_SECURITY_PROC>(
			::GetProcAddress(g_hlibACLUI,"EditSecurity") );
		if (NULL == g_pfnEditSecurityProc)
		{
			appAssert(FALSE); // ACLUI.DLL is invalid?
			return 0;
		}
	}

	CComObject<CSMBSecurityInformation>* psecinfo = NULL;
	HRESULT hRes = CComObject<CSMBSecurityInformation>::CreateInstance(&psecinfo);
	if ( FAILED(hRes) )
		return 0;

	psecinfo->AddRef();
	psecinfo->SetMachineName( pszServerName );
	psecinfo->SetShareName( pszShareName );
	psecinfo->m_pInitialDescriptor = pSecDesc;
	psecinfo->m_ppCurrentDescriptor = ppSecDesc;
	(g_pfnEditSecurityProc)(hwndParent,psecinfo);

	if (NULL != pfSecDescModified)
		*pfSecDescModified = (NULL != *ppSecDesc);

	psecinfo->Release();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\ole.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       ole.cxx
//
//  Contents:   Class factory, etc, for all OLE objects:
//              CShare and CShareCopyHook
//
//  History:    6-Apr-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "ole.hxx"
#include "copyhook.hxx"
#include "share.hxx"
#include "dllmain.hxx"

// {f81e9010-6ea4-11ce-a7ff-00aa003ca9f6}
const CLSID CLSID_CShare = {0xf81e9010, 0x6ea4, 0x11ce, 0xa7, 0xff, 0x00, 0xaa, 0x00, 0x3c, 0xa9, 0xf6 };
// {40dd6e20-7c17-11ce-a804-00aa003ca9f6}
const CLSID CLSID_CShareCopyHook = {0x40dd6e20, 0x7c17, 0x11ce, 0xa8, 0x04, 0x00, 0xaa, 0x00, 0x3c, 0xa9, 0xf6};


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

ULONG g_ulcInstancesShare = 0;
ULONG g_ulcInstancesShareCopyHook = 0;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShare::QueryInterface(
    IN REFIID riid,
    OUT LPVOID* ppvObj
    )
{
    appDebugOut((DEB_ITRACE, "CShare::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*)(IShellExtInit*) this;    // doesn't matter which
    }
    else
    if (IsEqualIID(IID_IShellExtInit, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IShellExtInit\n"));
        pUnkTemp = (IShellExtInit*) this;
    }
    else
    if (IsEqualIID(IID_IShellPropSheetExt, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IShellPropSheetExt\n"));
        pUnkTemp = (IShellPropSheetExt*) this;
    }
    else
    if (IsEqualIID(IID_IContextMenu, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IContextMenu\n"));
        pUnkTemp = (IContextMenu*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}

STDMETHODIMP_(ULONG)
CShare::AddRef(
    VOID
    )
{
    InterlockedIncrement((LONG*)&g_ulcInstancesShare);
    InterlockedIncrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE,
        "CShare::AddRef, local: %d, DLL: %d\n",
        _uRefs,
        g_ulcInstancesShare));

    return _uRefs;
}

STDMETHODIMP_(ULONG)
CShare::Release(
    VOID
    )
{
    InterlockedDecrement((LONG*)&g_ulcInstancesShare);
    ULONG cRef = InterlockedDecrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE,
        "CShare::Release, local: %d, DLL: %d\n",
        _uRefs,
        g_ulcInstancesShare));

    if (0 == cRef)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShareCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CShareCF::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*) this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IClassFactory\n"));
        pUnkTemp = (IClassFactory*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}


STDMETHODIMP_(ULONG)
CShareCF::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstancesShare);

    appDebugOut((DEB_ITRACE,
        "CShareCF::AddRef, DLL: %d\n",
        g_ulcInstancesShare));

    return g_ulcInstancesShare;
}

STDMETHODIMP_(ULONG)
CShareCF::Release()
{
    InterlockedDecrement((LONG*)&g_ulcInstancesShare);

    appDebugOut((DEB_ITRACE,
        "CShareCF::Release, DLL: %d\n",
        g_ulcInstancesShare));

    return g_ulcInstancesShare;
}

STDMETHODIMP
CShareCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CShareCF::CreateInstance\n"));

    if (pUnkOuter != NULL)
    {
        // don't support aggregation
        return E_NOTIMPL;
    }

    CShare* pShare = new CShare();
    if (NULL == pShare)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pShare->QueryInterface(riid, ppvObj);
    pShare->Release();

    return hr;
}

STDMETHODIMP
CShareCF::LockServer(BOOL fLock)
{
    //
    // FEATURE: Whats supposed to happen here?
    //
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShareCopyHook::QueryInterface(
    IN REFIID riid,
    OUT LPVOID* ppvObj
    )
{
    appDebugOut((DEB_ITRACE, "CShareCopyHook::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*) this;
    }
    else
    if (IsEqualIID(IID_IShellCopyHook, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "ICopyHook\n"));
        pUnkTemp = (ICopyHook*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}

STDMETHODIMP_(ULONG)
CShareCopyHook::AddRef(
    VOID
    )
{
    InterlockedIncrement((LONG*)&g_ulcInstancesShare);
    InterlockedIncrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE,
        "CShareCopyHook::AddRef, local: %d, DLL: %d\n",
        _uRefs,
        g_ulcInstancesShare));

    return _uRefs;
}

STDMETHODIMP_(ULONG)
CShareCopyHook::Release(
    VOID
    )
{
    InterlockedDecrement((LONG*)&g_ulcInstancesShare);
    ULONG cRef = InterlockedDecrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE,
        "CShareCopyHook::Release, local: %d, DLL: %d\n",
        _uRefs,
        g_ulcInstancesShare));

    if (0 == cRef)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShareCopyHookCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CShareCopyHookCF::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*) this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IClassFactory\n"));
        pUnkTemp = (IClassFactory*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}


STDMETHODIMP_(ULONG)
CShareCopyHookCF::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstancesShareCopyHook);
    return g_ulcInstancesShareCopyHook;
}

STDMETHODIMP_(ULONG)
CShareCopyHookCF::Release()
{
    InterlockedDecrement((LONG*)&g_ulcInstancesShareCopyHook);
    return g_ulcInstancesShareCopyHook;
}

STDMETHODIMP
CShareCopyHookCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CShareCopyHookCF::CreateInstance\n"));

    if (pUnkOuter != NULL)
    {
        // don't support aggregation
        return E_NOTIMPL;
    }

    CShareCopyHook* pShareCopyHook = new CShareCopyHook();
    if (NULL == pShareCopyHook)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pShareCopyHook->QueryInterface(riid, ppvObj);
    pShareCopyHook->Release();

    if (FAILED(hr))
    {
        hr = E_NOINTERFACE; // FEATURE: Whats the error code?
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP
CShareCopyHookCF::LockServer(BOOL fLock)
{
    //
    // FEATURE: Whats supposed to happen here?
    //
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDAPI
DllCanUnloadNow(
    VOID
    )
{
    OneTimeInit();

    if (0 == g_ulcInstancesShare
        && 0 == g_ulcInstancesShareCopyHook
        && 0 == g_NonOLEDLLRefs)
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

CShareCF cfShare;
CShareCopyHookCF cfShareCopyHook;

STDAPI
DllGetClassObject(
    REFCLSID cid,
    REFIID iid,
    LPVOID* ppvObj
    )
{
    OneTimeInit();

    appDebugOut((DEB_TRACE, "DllGetClassObject\n"));

    HRESULT hr = E_NOINTERFACE;

    if (IsEqualCLSID(cid, CLSID_CShare))
    {
        hr = cfShare.QueryInterface(iid, ppvObj);
    }
    else if (IsEqualCLSID(cid, CLSID_CShareCopyHook))
    {
        hr = cfShareCopyHook.QueryInterface(iid, ppvObj);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\shrpage.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       shrpage.cxx
//
//  Contents:   "Sharing" shell property page extension
//
//  History:    6-Apr-95        BruceFo     Created
//              12-Jul-00       JonN        fixed 140878, MSG_MULTIDEL debounce
//              06-Oct-00       jeffreys    Split CShareBase out of CSharingPropertyPage
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "dlgnew.hxx"
#include "cache.hxx"
#include "share.hxx"
#include "acl.hxx"
#include "shrinfo.hxx"
#include "shrpage.hxx"
#include "util.hxx"



void _MyShow( HWND hwndParent, INT idControl, BOOL fShow )
{
    HWND hwndChild = GetDlgItem( hwndParent, idControl );
    appAssert( NULL != hwndChild );
    ShowWindow( hwndChild, (fShow) ? SW_SHOW : SW_HIDE );
    EnableWindow( hwndChild, fShow );
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CShareBase::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShareBase, IOleWindow),                   // IID_IOleWindow
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CShareBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShareBase::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CShareBase::GetWindow(HWND *phwnd)
{
    *phwnd = _GetFrameWindow();
    return S_OK;
}

STDMETHODIMP CShareBase::ContextSensitiveHelp(BOOL /*fEnterMode*/)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::PageCallback, static public
//
//  Synopsis:
//
//--------------------------------------------------------------------------

UINT CALLBACK
CShareBase::PageCallback(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE ppsp
    )
{
    switch (uMsg)
    {
    case PSPCB_CREATE:
        return 1;       // allow creation

    case PSPCB_RELEASE:
    {
        CShareBase* pThis = (CShareBase*)ppsp->lParam;
        pThis->Release(); // do this LAST!
        return 0;       // ignored
    }

    case PSPCB_ADDREF:
        // Should probably implement some refcounting, but we only get
        // addref'd once and released once.
        return 0;

    default:
        appDebugOut((DEB_ERROR, "CShareBase::PageCallback, unknown page callback message %d\n", uMsg));
        return 0;

    } // end switch
}

//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::DlgProcPage, static public
//
//  Synopsis:   Dialog Procedure for all sharing dialogs/pages
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CShareBase::DlgProcPage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CShareBase* pThis = NULL;

    if (msg==WM_INITDIALOG)
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
        pThis = (CShareBase*)psp->lParam;
        SetWindowLongPtr(hwnd,GWLP_USERDATA,(LPARAM)pThis);
    }
    else
    {
        pThis = (CShareBase*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
    }

    if (pThis != NULL)
    {
        return pThis->_PageProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}


//+--------------------------------------------------------------------------
//
//  Method:     CShareBase::CShareBase, public
//
//  Synopsis:   Constructor
//
//---------------------------------------------------------------------------

CShareBase::CShareBase(
    IN PWSTR pszPath,
    IN BOOL bDialog     // called as a dialog, not a property page?
    )
    :
    _cRef(1),
    _pszPath(pszPath),      // take ownership!
    _hwndPage(NULL),
    _fInitializingPage(0),  // JonN 7/11/00 140878
    _bDirty(FALSE),
    _pInfoList(NULL),
    _pReplaceList(NULL),
    _pCurInfo(NULL),
    _cShares(0),
    _bNewShare(TRUE),
    _bDialog(bDialog)
{
    INIT_SIG(CShareBase);
    appAssert(NULL != _pszPath);
}


//+--------------------------------------------------------------------------
//
//  Method:     CShareBase::~CShareBase, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------------------

CShareBase::~CShareBase()
{
    CHECK_SIG(CShareBase);

    // delete the the list of shares
    appAssert(NULL != _pInfoList);
    DeleteShareInfoList(_pInfoList, TRUE);
    _pInfoList = NULL;
    _pCurInfo = NULL;

    // delete the "replacement" list
    appAssert(NULL != _pReplaceList);
    DeleteShareInfoList(_pReplaceList, TRUE);
    _pReplaceList = NULL;

    delete[] _pszPath;
    _pszPath = NULL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::InitInstance, public
//
//  Synopsis:   Part II of the constuctor process
//
//  Notes:      We don't want to handle any errors in constuctor, so this
//              method is necessary for the second phase error detection.
//
//--------------------------------------------------------------------------

HRESULT
CShareBase::InitInstance(
    VOID
    )
{
    CHECK_SIG(CShareBase);
    appDebugOut((DEB_ITRACE, "CShareBase::InitInstance\n"));

    _pInfoList = new CShareInfo();  // dummy head node
    if (NULL == _pInfoList)
    {
        return E_OUTOFMEMORY;
    }

    _pReplaceList = new CShareInfo();  // dummy head node
    if (NULL == _pReplaceList)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CShareBase);

    switch (msg)
    {
    case WM_INITDIALOG:
        _hwndPage = hwnd;
        //
        // We know this drive is allowed to be shared. However, someone may
        // have changed the number or characteristics of the share using the
        // command line or winfile or server manager or the new file server
        // tool, and the cache may not have been refreshed. Force a refresh
        // now, to pick up any new shares for this path.
        //
        // Note that for the SharingDialog() API, this is the first time the
        // cache gets loaded. If the server is not running, we nuke the dialog
        // and return an error code.
        //
        g_ShareCache.Refresh();
        if (_bDialog && !g_fSharingEnabled)
        {
            EndDialog(hwnd, -1);
        }
        _ConstructShareList();
        return _OnInitDialog(hwnd, (HWND)wParam, lParam);

    case WM_COMMAND:
        return _OnCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_NOTIFY:
        return _OnNotify(hwnd, (int)wParam, (LPNMHDR)lParam);

    case WM_HELP:
        return _OnHelp(hwnd, (LPHELPINFO)lParam);

    case WM_CONTEXTMENU:
        return _OnContextMenu(hwnd, (HWND)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    } // end switch (msg)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CShareBase);

//
// Commands only used when this page is invoked as a dialog box, via the
// SharingDialog() API:
//
    if (_bDialog)
    {
        switch (wID)
        {
        case IDCANCEL:
            if (!_DoCancel(hwnd))
            {
                // We might consider not going away. But instead, go away anyway.
            }
            EndDialog(hwnd, FALSE);
            return TRUE;

        case IDOK:
            if (!_ValidatePage(hwnd))
            {
                // don't go away
                return TRUE;
            }
            if (!_DoApply(hwnd, TRUE))
            {
                // don't go away
                return TRUE;
            }
            EndDialog(hwnd, TRUE);
            return TRUE;

        default:
            break;
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_OnNotify, private
//
//  Synopsis:   WM_NOTIFY handler
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_OnNotify(
    IN HWND hwnd,
    IN int idCtrl,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CShareBase);

    // assume a property sheet notification
    return _OnPropertySheetNotify(hwnd, phdr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_OnPropertySheetNotify, private
//
//  Synopsis:   WM_NOTIFY handler for the property sheet notification
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_OnPropertySheetNotify(
    IN HWND hwnd,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CShareBase);

    switch (phdr->code)
    {
    case PSN_RESET:         // cancel
        if (_DoCancel(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR); // go away
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
        }
        return TRUE;

    case PSN_KILLACTIVE:    // change to another page
        if (_ValidatePage(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            return FALSE;
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }

    case PSN_APPLY:
        if (_DoApply(hwnd, !!(((LPPSHNOTIFY)phdr)->lParam)))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR); // go away
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
        }
        return TRUE;

    } // end switch (phdr->code)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_DoApply, public
//
//  Synopsis:   If anything has changed, apply the data
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_DoApply(
    IN HWND hwnd,
    IN BOOL /*bClose*/
    )
{
    CHECK_SIG(CShareBase);

    if (_bDirty)
    {
        _bDirty = FALSE;
        PropSheet_UnChanged(_GetFrameWindow(),_hwndPage);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_DoCancel, public
//
//  Synopsis:   Do whatever is necessary to cancel the changes
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_DoCancel(
    IN HWND hwnd
    )
{
    CHECK_SIG(CShareBase);

    if (_bDirty)
    {
        _bDirty = FALSE;
        PropSheet_UnChanged(_GetFrameWindow(),_hwndPage);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_MarkPageDirty, private
//
//  Synopsis:   A change has made such that the page is now dirty
//
//--------------------------------------------------------------------------

VOID
CShareBase::_MarkPageDirty(
    VOID
    )
{
    CHECK_SIG(CShareBase);

    if (!_fInitializingPage)
    {
        if (!_bDirty)
        {
            appDebugOut((DEB_ITRACE, "Marking Sharing page dirty\n"));
            _bDirty = TRUE;
            PropSheet_Changed(_GetFrameWindow(),_hwndPage);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_ConnstructShareList, private
//
//  Synopsis:   Construct the list of shares for the current path by
//              iterating through the entire cache of shares and adding an
//              element for every path that matches.
//
//--------------------------------------------------------------------------

HRESULT
CShareBase::_ConstructShareList(
    VOID
    )
{
    CHECK_SIG(CShareBase);
    appDebugOut((DEB_ITRACE, "_ConstructShareList\n"));

    // This routine sets _cShares, and _bNewShare, and adds to
    // the _pInfoList list

    HRESULT hr;

    DeleteShareInfoList(_pInfoList);
    _pCurInfo = NULL;
    _bNewShare = FALSE;

    appAssert(_pInfoList->IsSingle());
    appAssert(_pCurInfo == NULL);
    appAssert(_pszPath != NULL);

    hr = g_ShareCache.ConstructList(_pszPath, _pInfoList, &_cShares);

    if (SUCCEEDED(hr) && _cShares == 0)
    {
        // There are no existing shares. Construct an element to be used
        // by the UI to stash the new share's data

        hr = _ConstructNewShareInfo();
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_ConstructNewShareInfo, private
//
//  Synopsis:   Construct an element to be used by the UI to stash the new
//              share's data
//
//--------------------------------------------------------------------------

HRESULT
CShareBase::_ConstructNewShareInfo(
    VOID
    )
{
    CHECK_SIG(CShareBase);
    HRESULT hr;

    CShareInfo* pNewInfo = new CShareInfo();
    if (NULL == pNewInfo)
    {
        return E_OUTOFMEMORY;
    }

    hr = pNewInfo->InitInstance();
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete pNewInfo;
        return hr;
    }

    hr = pNewInfo->SetPath(_pszPath);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete pNewInfo;
        return hr;
    }

    NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
    if ( NERR_Success != ret )
    {
        delete pNewInfo;
        return HRESULT_FROM_WIN32 (ret);
    }

    _bNewShare = TRUE;

    pNewInfo->SetDirtyFlag(SHARE_FLAG_ADDED);
    pNewInfo->InsertBefore(_pInfoList);

    //NOTE: leave the count of shares to be zero. The count of shares only
    // reflects the number of committed shares (?)

    // Get the shell's name for the folder to use as the share name. This
    // gives us localized names for things like "Shared Documents".
    //
    // Sometimes the shell's name contains invalid characters, such
    // as when we're looking at the root of the drive. In that case
    // SHGetFileInfo returns "label (X:)" and IsValidShareName fails
    // on the colon. For those, try calling shell32's PathCleanupSpec
    // to make the name valid.
    //
    // If SHGetFileInfo and PathCleanupSpec fail to give us a good name,
    // fall back on the old method, which is...
    //
    // Give the share a default name. For paths like "X:\", use the default
    // "X", for paths like "X:\foo\bar\baz", use the default "baz".
    // For everything else, juse leave it blank. Also, check that the
    // computed default is not already a share name. If it is, leave it
    // blank.

    appAssert(NULL != _pszPath);

    WCHAR szDefault[2] = L"";
    PWSTR pszDefault = NULL;
    SHFILEINFOW sfi = {0};

    if (SHGetFileInfoW(_pszPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
    {
        if (IsValidShareName(sfi.szDisplayName, &hr))
        {
            pszDefault = sfi.szDisplayName;
        }
        else
        {
            int iResult = PathCleanupSpec(NULL, sfi.szDisplayName);
            if (0 == (iResult & (PCS_TRUNCATED|PCS_PATHTOOLONG|PCS_FATAL))
                && IsValidShareName(sfi.szDisplayName, &hr))
            {
                pszDefault = sfi.szDisplayName;
            }
        }
        //
        // NTRAID#NTBUG9-225755-2000/12/19-jeffreys
        //
        // Win9x boxes can't see the share if the name is long
        //
        if (NULL != pszDefault && wcslen(pszDefault) > LM20_NNLEN)
        {
            // Go back to the old way below
            pszDefault = NULL;
        }
    }
    if (NULL == pszDefault)
    {
        pszDefault = szDefault;
        int len = wcslen(_pszPath);
        if (len == 3 && _pszPath[1] == L':' && _pszPath[2] == L'\\')
        {
            szDefault[0] = _pszPath[0];
        }
        else
        {
            PWSTR pszTmp = wcsrchr(_pszPath, L'\\');
            if (pszTmp != NULL)
            {
                pszDefault = pszTmp + 1;
            }
        }
    }

    if (g_ShareCache.IsShareNameUsed(pszDefault))
    {
        pszDefault = szDefault;
        szDefault[0] = L'\0';
    }

    hr = pNewInfo->SetNetname(pszDefault);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        // FEATURE: error handling?
        _bNewShare = FALSE;
        pNewInfo->Unlink();
        delete pNewInfo;
        return hr;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_ValidateNewShareName, protected
//
//  Synopsis:   Return TRUE if the sharename is valid, performing
//              confirmations if necessary
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_ValidateNewShareName(
    VOID
    )
{
    CHECK_SIG(CShareBase);

    if (!_bNewShare)
    {
        // nothing to do
        return TRUE;
    }

    appAssert(NULL != _pCurInfo);
    if (NULL == _pCurInfo) // JonN 5/2/01 384155
        return FALSE;

    PWSTR pszShareName = _pCurInfo->GetNetname();
    appAssert(NULL != pszShareName);

    if ((NULL == pszShareName) || (0 == wcslen(pszShareName))) // PREFIX 240253
    {
        MyErrorDialog(_hwndPage, IERR_BlankShareName);
        return FALSE;
    }

    HRESULT uTemp;
    if (!IsValidShareName(pszShareName, &uTemp))
    {
        MyErrorDialog(_hwndPage, uTemp);
        return FALSE;
    }

    // Trying to create a reserved share?
    if (0 == _wcsicmp(g_szIpcShare,   pszShareName))
    {
        MyErrorDialog(_hwndPage, IERR_SpecialShare);
        return FALSE;
    }

    if (0 == _wcsicmp(g_szAdminShare, pszShareName))
    {
        // We will let the admin create the admin$ share if they create
        // it in the directory specified by GetWindowsDirectory().
        WCHAR szWindowsDir[MAX_PATH];
        UINT err = GetWindowsDirectory(szWindowsDir, ARRAYLEN(szWindowsDir));
        if (err == 0)
        {
            // oh well, give them this error
            MyErrorDialog(_hwndPage, IERR_SpecialShare);
            return FALSE;
        }

        if (0 != _wcsicmp(_pCurInfo->GetPath(), szWindowsDir))
        {
            MyErrorDialog(_hwndPage, IERR_SpecialShare);
            return FALSE;
        }

        // otherwise, it is the right directory. Let them create it.
    }

    /* removed JonN 10/5/98
    // Check for downlevel accessibility
    // we should really get rid of this at some point -- JonN 7/18/97
    ULONG nType;
    if (NERR_Success != NetpPathType(NULL, pszShareName, &nType, INPT_FLAGS_OLDPATHS))
    {
        DWORD id = MyConfirmationDialog(
                        _hwndPage,
                        IERR_InaccessibleByDos,
                        MB_YESNO | MB_ICONEXCLAMATION,
                        pszShareName);
        if (id == IDNO)
        {
            return FALSE;
        }
    }
    */

    WCHAR szOldPath[PATHLEN+1];

    if (g_ShareCache.IsExistingShare(pszShareName, _pCurInfo->GetPath(), szOldPath))
    {
        DWORD id = ConfirmReplaceShare(_hwndPage, pszShareName, szOldPath, _pCurInfo->GetPath());
        if (id != IDYES)
        {
            return FALSE;
        }

        // User said to replace the old share. We need to add
        // a "delete" record for the old share.

        HRESULT hr;

        CShareInfo* pNewInfo = new CShareInfo();
        if (NULL == pNewInfo)
        {
            return FALSE;
        }

        hr = pNewInfo->InitInstance();
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pNewInfo;
            return FALSE;
        }

        // only need net name for delete; ignore other fields
        hr = pNewInfo->SetNetname(pszShareName);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pNewInfo;
            return FALSE;
        }

        hr = pNewInfo->SetPath(szOldPath);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pNewInfo;
            return FALSE;
        }

        NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
        if ( NERR_Success != ret )
        {
            delete pNewInfo;
            return HRESULT_FROM_WIN32 (ret);
        }

        pNewInfo->SetDirtyFlag(SHARE_FLAG_REMOVE);
        pNewInfo->InsertBefore(_pReplaceList); // add to end of replace list
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_CommitShares, protected
//
//  Synopsis:   Commit outstanding share edits.  Note that this method does
//              not reset _bDirty.
//
//--------------------------------------------------------------------------

VOID
CShareBase::_CommitShares(
    IN BOOL bNotShared
    )
{
    CHECK_SIG(CShareBase);

    if (!_bDirty)
    {
        // nothing to do
        return;
    }

    if (bNotShared)
    {
        // When the user hits "Not Shared" after having had "Shared As"
        // selected, we don't actually delete anything (or even mark it
        // for deletion). This is so the user can hit "Shared As" again
        // and they haven't lost anything. However, if they subsequently
        // apply changes, we must go through and actually delete anything
        // that they wanted to delete. So, fix up our list to do this.
        // Delete SHARE_FLAG_ADDED nodes, and mark all others as
        // SHARE_FLAG_REMOVE.

        for (CShareInfo* p = (CShareInfo*) _pInfoList->Next();
             p != _pInfoList;
             )
        {
            CShareInfo* pNext = (CShareInfo*)p->Next();

            if (p->GetFlag() == SHARE_FLAG_ADDED)
            {
                // get rid of p
                p->Unlink();
                delete p;
            }
            else
            {
                p->SetDirtyFlag(SHARE_FLAG_REMOVE);
            }

            p = pNext;
        }
    }

    //
    // Commit the changes!
    //

    HRESULT hr;
    CShareInfo* p;

    // Delete all "replace" shares first. These are all the shares whos
    // names are being reused to share a different directory.
    // These replace deletes have already been confirmed.

    for (p = (CShareInfo*) _pReplaceList->Next();
         p != _pReplaceList;
         p = (CShareInfo*) p->Next())
    {
        appAssert(p->GetFlag() == SHARE_FLAG_REMOVE);
        NET_API_STATUS ret = p->Commit(NULL);
        if (ret != NERR_Success)
        {
            DisplayError(_hwndPage, IERR_CANT_DEL_SHARE, ret, p->GetNetname());
            // We've got a problem here because we couldn't delete a
            // share that will be added subsequently. Oh well...
        }

        // Note that we don't delete this list because we need to notify
        // the shell (*after* all changes) that all these guys have
        // changed (and get rid of those little hands)...
    }

    // Now, do all add/delete/modify of the current

    for (p = (CShareInfo*) _pInfoList->Next();
         p != _pInfoList;
         )
    {
        CShareInfo* pNext = (CShareInfo*)p->Next();

        if (0 != p->GetFlag())
        {
            if (SHARE_FLAG_REMOVE == p->GetFlag())
            {
                // confirm the delete, if there are connections
                DWORD id = ConfirmStopShare(_hwndPage, MB_YESNO, p->GetNetname());
                if (id != IDYES)
                {
                    p->SetDirtyFlag(0);  // don't do anything to it
                }
            }

            NET_API_STATUS ret = p->Commit(NULL);
            if (ret != NERR_Success)
            {
                HRESULT hrMsg = 0;
                switch (p->GetFlag())
                {
                case SHARE_FLAG_ADDED:  hrMsg = IERR_CANT_ADD_SHARE;    break;
                case SHARE_FLAG_MODIFY: hrMsg = IERR_CANT_MODIFY_SHARE; break;
                case SHARE_FLAG_REMOVE: hrMsg = IERR_CANT_DEL_SHARE;    break;
                default:
                    appAssert(!"Illegal flag for a failed commit!");
                }
                DisplayError(_hwndPage, hrMsg, ret, p->GetNetname());
            }
            else
            {
                if (p->GetFlag() == SHARE_FLAG_REMOVE)
                {
                    // nuke it!
                    p->Unlink();
                    delete p;
                }
                else
                {
                    p->SetDirtyFlag(0);  // clear flag on success
                }
            }
        }

        p = pNext;
    }

    if (_bNewShare)
    {
        _bNewShare = FALSE;
        _cShares = 1;
    }

    // I refresh the cache, even though the shell comes back and asks
    // for a refresh after every SHChangeNotify. However, SHChangeNotify
    // is asynchronous, and I need the cache refreshed immediately so I
    // can display the new share information, if the "apply" button was
    // hit and the page didn't go away.

    g_ShareCache.Refresh();

    appDebugOut((DEB_TRACE,
        "Changed share for path %ws, notifying shell\n",
        _pszPath));

    SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, _pszPath, NULL);
    // FEATURE: might want to use SHCNE_NETUNSHARE, but the shell doesn't
    // distinguish them

    // Now, notify the shell about all the paths we got rid of to be able
    // to use their share names ...
    for (p = (CShareInfo*) _pReplaceList->Next();
         p != _pReplaceList;
         )
    {
        appAssert(p->GetFlag() == SHARE_FLAG_REMOVE);

        appDebugOut((DEB_TRACE,
            "Got rid of share on path %ws, notifying shell\n",
            p->GetPath()));

        // We're going to be asked by the shell to refresh the cache once
        // for every notify. But, seeing as how the average case is zero
        // of these notifies, don't worry about it.
        SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, p->GetPath(), NULL);

        CShareInfo* pNext = (CShareInfo*) p->Next();
        p->Unlink();
        delete p;
        p = pNext;
    }

    _ConstructShareList();
}


//+-------------------------------------------------------------------------
//
//  Member:     CSharingPropertyPage::SizeWndProc, public
//
//  Synopsis:   "allow" edit window subclass proc to disallow non-numeric
//              characters.
//
//  History:    5-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
CSharingPropertyPage::SizeWndProc(
    IN HWND hwnd,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (wMsg)
    {
    case WM_CHAR:
    {
        WCHAR chCharCode = (WCHAR)wParam;
        if (   (chCharCode == TEXT('\t'))
            || (chCharCode == TEXT('\b'))
            || (chCharCode == TEXT('\n'))
//          || (chCharCode == TEXT('\x1b')) // ESCAPE key
            )
        {
            break;
        }

        if (chCharCode < TEXT('0') || chCharCode > TEXT('9'))
        {
            // bad key: ignore it
            MessageBeep(0xffffffff);    // let user know it's an illegal char
            return FALSE;
        }

        break;
    }
    } // end of switch

    CSharingPropertyPage* pThis = (CSharingPropertyPage*)GetWindowLongPtr(GetParent(hwnd),GWLP_USERDATA);
    appAssert(NULL != pThis);
    appAssert(NULL != pThis->_pfnAllowProc);
    return CallWindowProc(pThis->_pfnAllowProc, hwnd, wMsg, wParam, lParam);
}


//+--------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::CSharingPropertyPage, public
//
//  Synopsis:   Constructor
//
//---------------------------------------------------------------------------

CSharingPropertyPage::CSharingPropertyPage(
    IN PWSTR pszPath,
    IN BOOL bDialog     // called as a dialog, not a property page?
    )
    :
    CShareBase(pszPath, bDialog),
    _wIDSelected(0),        // JonN 7/12/00 140878
    _bItemDirty(FALSE),
    _bShareNameChanged(FALSE),
    _bCommentChanged(FALSE),
    _bUserLimitChanged(FALSE),
    _wMaxUsers(DEFAULT_MAX_USERS),
    _pfnAllowProc(NULL),
    _bIsCachingSupported (false)
{
    INIT_SIG(CSharingPropertyPage);
}


//+--------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::~CSharingPropertyPage, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------------------

CSharingPropertyPage::~CSharingPropertyPage()
{
    CHECK_SIG(CSharingPropertyPage);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CSharingPropertyPage);

    switch (msg)
    {
    case WM_VSCROLL:
        // The up/down control changed the edit control: select it again
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        return TRUE;

    case WM_CLOSE:
        // NOTE: There is a bug where hitting "ESCAPE" with the focus on the
        // MLE for the "allow" text doesn't kill the property sheet unless we
        // forward the WM_CLOSE message on to the property sheet root dialog.
        return (BOOL)SendMessage(_GetFrameWindow(), msg, wParam, lParam);

    case WM_DESTROY:
        // restore original subclass to window.
        appAssert(NULL != GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE));
        SetWindowLongPtr(GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE), GWLP_WNDPROC, (LONG_PTR)_pfnAllowProc);
        break;

    } // end switch (msg)

    return CShareBase::_PageProc(hwnd, msg, wParam, lParam);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnInitDialog(
    IN HWND hwnd,
    IN HWND hwndFocus,
    IN LPARAM lInitParam
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appDebugOut((DEB_ITRACE, "_OnInitDialog\n"));

    // Subclass allow edit control to disallow non-positive numbers
    _pfnAllowProc = (WNDPROC)SetWindowLongPtr(
                                    GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE),
                                    GWLP_WNDPROC,
                                    (LONG_PTR)&SizeWndProc);

    // use LanMan API constants to set maximum share name & comment lengths
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_COMMENT,   EM_LIMITTEXT, MAXCOMMENTSZ, 0L);

    if (_bDialog)
    {
        SetWindowText(hwnd, _pszPath);
    }
    else
    {
        _MyShow( hwnd, IDOK, FALSE );
        _MyShow( hwnd, IDCANCEL, FALSE );
    }

    _InitializeControls(hwnd);

// #if DBG == 1
//  Dump(L"_OnInitDialog finished");
// #endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CSharingPropertyPage);

    switch (wID)
    {

//
// Notifications
//

    case IDC_SHARE_NOTSHARED:
    {
        if (BN_CLICKED == wNotifyCode)
        {
            if (   (!_fInitializingPage)
                && (IDC_SHARE_NOTSHARED != _wIDSelected) // JonN 7/11/00 140878
                // JonN 7/11/00 140878
                // sometimes you get BN_CLICKED even before the
                // button is selected according to IsDlgButtonChecked
                && (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_NOTSHARED))
               )
            {
                _wIDSelected = IDC_SHARE_NOTSHARED;

                _ReadControls(hwnd);

                // Delete all shares from the combo box; convert the combo box
                // to the edit control (default state), and then disable
                // all the controls.  Cache whatever shares we had, so if
                // the user hits "Shared As", we can put them back.

                if (_cShares > 1)
                {
                    // JonN 7/11/00 140878
                    // Additional BN_CLICKED notifications are coming in while
                    // the MSG_MULTIDEL dialog is still onscreen, resulting
                    // in multiple copies of the dialog.
                    _fInitializingPage++; // JonN 7/11/00 140878

                    DWORD id = MyConfirmationDialog(
                                    hwnd,
                                    MSG_MULTIDEL,
                                    MB_YESNO | MB_ICONQUESTION);
                    if (IDNO == id)
                    {
                        CheckRadioButton(
                                hwnd,
                                IDC_SHARE_NOTSHARED,
                                IDC_SHARE_SHAREDAS,
                                IDC_SHARE_SHAREDAS);

						//
						// JonN 3/8/01 140878 part 2 (unit-test 3/9/01)
						// At this point, IDC_SHARE_SHAREDAS is selected,
						// but focus is still on IDC_SHARE_NOTSHARED and
						// _wIDSelected == IDC_SHARE_NOTSHARED.
						// Correct this, but stay in the _fInitializingPage
						// block so that the page will not be marked dirty.
						//
				        SendMessage(hwnd, WM_NEXTDLGCTL,
							(WPARAM)GetDlgItem(hwnd,IDC_SHARE_SHAREDAS),
							(LPARAM)TRUE);
		                _wIDSelected = IDC_SHARE_SHAREDAS;

                        _fInitializingPage--; // JonN 7/11/00 140878
                        return TRUE;
                    }
                    _fInitializingPage--; // JonN 7/11/00 140878
                }

                //
                // Next, regenerate the UI
                //

                _SetControlsFromData(hwnd, NULL);

                _MarkPageDirty();
            }
        }

        return TRUE;
    }

    case IDC_SHARE_SHAREDAS:
    {
        if (BN_CLICKED == wNotifyCode)
        {

            if (   (!_fInitializingPage)
                && (IDC_SHARE_SHAREDAS != _wIDSelected) // JonN 7/11/00 140878
                // JonN 7/11/00 140878
                // Sometimes you get BN_CLICKED even before the
                // button is selected according to IsDlgButtonChecked
                && (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS))
               )
            {
                _wIDSelected = IDC_SHARE_SHAREDAS;

                // if there were shares there that we just hid when the user
                // pressed "Not Shared", then put them back.

                //
                // Regenerate the UI
                //

                _SetControlsFromData(hwnd, NULL);

                _MarkPageDirty();
            }
        }

        return TRUE;
    }

    case IDC_SHARE_SHARENAME:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bShareNameChanged = TRUE;
                _MarkItemDirty();
            }
            EnableWindow (GetDlgItem(hwnd, IDC_SHARE_CACHING),
                    IsCachingSupported ());
        }
        return TRUE;
    }

    case IDC_SHARE_COMMENT:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bCommentChanged = TRUE;
                _MarkItemDirty();
            }
        }
        return TRUE;
    }

    case IDC_SHARE_SHARENAME_COMBO:
    {
        if (CBN_SELCHANGE == wNotifyCode)
        {
            _ReadControls(hwnd);

            HWND hwndCombo = GetDlgItem(hwnd, IDC_SHARE_SHARENAME_COMBO);
            int item = ComboBox_GetCurSel(hwndCombo);
            LRESULT itemData = ComboBox_GetItemData(hwndCombo, item);
            _pCurInfo = (CB_ERR == itemData) ? NULL : (CShareInfo *)itemData;
            appAssert(NULL != _pCurInfo);

            _SetFieldsFromCurrent(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_MAXIMUM:
        if (BN_CLICKED == wNotifyCode)
        {
            // Take away WS_TABSTOP from the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) & ~WS_TABSTOP);

            _CacheMaxUses(hwnd);
            SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

    case IDC_SHARE_ALLOW:
        if (BN_CLICKED == wNotifyCode)
        {
            // Give WS_TABSTOP to the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) | WS_TABSTOP);

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

    case IDC_SHARE_ALLOW_VALUE:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }

        if (EN_SETFOCUS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }

        if (EN_KILLFOCUS == wNotifyCode)
        {
            _CacheMaxUses(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_ALLOW_SPIN:
        if (UDN_DELTAPOS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

//
// Commands
//

    case IDC_SHARE_PERMISSIONS:
        return _OnPermissions(hwnd);

    case IDC_SHARE_REMOVE:
        return _OnRemove(hwnd);

    case IDC_SHARE_NEWSHARE:
        return _OnNewShare(hwnd);

    case IDC_SHARE_CACHING:
        return _OnCaching(hwnd);

    default:
        break;
    }

    return CShareBase::_OnCommand(hwnd, wNotifyCode, wID, hwndCtl);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnHelp, private
//
//  Synopsis:   WM_HELP handler
//
//--------------------------------------------------------------------------

static const DWORD aHelpIds[] =
{
    IDOK,                       HC_OK,
    IDCANCEL,                   HC_CANCEL,
    IDC_SHARE_SHARENAME,        HC_SHARE_SHARENAME,
    IDC_SHARE_SHARENAME_TEXT,   HC_SHARE_SHARENAME,
    IDC_SHARE_COMMENT,          HC_SHARE_COMMENT,
    IDC_SHARE_COMMENT_TEXT,     HC_SHARE_COMMENT,
    IDC_SHARE_MAXIMUM,          HC_SHARE_MAXIMUM,
    IDC_SHARE_ALLOW,            HC_SHARE_ALLOW,
    IDC_SHARE_ALLOW_VALUE,      HC_SHARE_ALLOW_VALUE,
    IDC_SHARE_ALLOW_SPIN,       -1L, // 257807 by request of JillZ
    IDC_SHARE_PERMISSIONS,      HC_SHARE_PERMISSIONS,
    IDC_SHARE_LIMIT,            HC_SHARE_LIMIT,

    IDC_SHARE_NOTSHARED,        HC_SHARE_NOTSHARED,
    IDC_SHARE_SHAREDAS,         HC_SHARE_SHAREDAS,
    IDC_SHARE_SHARENAME_COMBO,  HC_SHARE_SHARENAME_COMBO,
    IDC_SHARE_REMOVE,           HC_SHARE_REMOVE,
    IDC_SHARE_NEWSHARE,         HC_SHARE_NEWSHARE,
    IDC_SHARE_ICON,             -1L, // 311328 JillZ
    IDC_SHARE_TOPTEXT,          -1L, // 311328 JillZ
    0,0
};
static const DWORD aCSCUIHelpIds[] =
{
    IDC_SHARE_CACHING,          IDH_SHARE_CACHING_BTN,
    IDC_SHARE_CACHING_TEXT,     IDH_SHARE_CACHING_BTN,
    0,0
};

BOOL
CSharingPropertyPage::_OnHelp(
    IN HWND hwnd,
    IN LPHELPINFO lphi
    )
{
    if (lphi->iContextType == HELPINFO_WINDOW)  // a control
    {
        WCHAR szHelp[50];
        if ( IDC_SHARE_CACHING == lphi->iCtrlId || IDC_SHARE_CACHING_TEXT == lphi->iCtrlId )
        {
            LoadString(g_hInstance, IDS_CSCUI_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                    (HWND)lphi->hItemHandle,
                    szHelp,
                    HELP_WM_HELP,
                    (DWORD_PTR)aCSCUIHelpIds);
        }
        else
        {
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                    (HWND)lphi->hItemHandle,
                    szHelp,
                    HELP_WM_HELP,
                    (DWORD_PTR)aHelpIds);
        }
    }

    return TRUE;
}


#define _AfxGetDlgCtrlID(hWnd)          ((UINT)(WORD)::GetDlgCtrlID(hWnd))
HWND MyChildWindowFromPoint(HWND hWnd, POINT pt)
{
    appAssert(hWnd != NULL);

    // check child windows
    ::ClientToScreen(hWnd, &pt);
    HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
    for (; hWndChild != NULL; hWndChild = ::GetWindow(hWndChild, GW_HWNDNEXT))
    {
        if (_AfxGetDlgCtrlID(hWndChild) != (WORD)-1 &&
	        (::GetWindowLong(hWndChild, GWL_STYLE) & WS_VISIBLE))
        {
            // see if point hits the child window
            RECT rect;
            ::GetWindowRect(hWndChild, &rect);
            if (PtInRect(&rect, pt))
                return hWndChild;
        }
    }

    return NULL;    // not found
}

//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnContextMenu, private
//
//  Synopsis:   WM_CONTEXTMENU handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnContextMenu(
    IN HWND hwnd,
    IN HWND hCtrlWnd,
    IN int xPos,
    IN int yPos
    )
{
    WCHAR   szHelp[50];
    int     ctrlID = 0;

    if ( hwnd == hCtrlWnd )
    {
        POINT	point;

        point.x = xPos;
        point.y = yPos;
        if ( ScreenToClient (hwnd, &point) )
        {
            hCtrlWnd = MyChildWindowFromPoint (hwnd, point); // takes client coords
            if ( !hCtrlWnd )
                hCtrlWnd = hwnd;
        }
    }

    ctrlID = GetDlgCtrlID (hCtrlWnd);
    if ( IDC_SHARE_CACHING == ctrlID || IDC_SHARE_CACHING_TEXT == ctrlID )
    {
        LoadString(g_hInstance, IDS_CSCUI_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
                hCtrlWnd,
                szHelp,
                HELP_CONTEXTMENU,
                (DWORD_PTR)aCSCUIHelpIds);
    }
    else
    {
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
                hCtrlWnd,
                szHelp,
                HELP_CONTEXTMENU,
                (DWORD_PTR)aHelpIds);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnPermissions, private
//
//  Synopsis:   WM_COMMAND handler: the permissions button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnPermissions(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(NULL != _pCurInfo);
    if (NULL == _pCurInfo) // JonN 5/2/01 384155
        return TRUE;

    if (STYPE_SPECIAL & _pCurInfo->GetType())
    {
        MyErrorDialog(hwnd, IERR_AdminShare);
        return TRUE;
    }

    WCHAR szShareName[NNLEN + 1];
    if (_cShares > 0)
    {
        wcscpy(szShareName, _pCurInfo->GetNetname());
    }
    else
    {
        GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
        // don't trim spaces, this might be an existing share with spaces in its name
    }

    PSECURITY_DESCRIPTOR pNewSecDesc = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = _pCurInfo->GetSecurityDescriptor();
    appAssert(NULL == pSecDesc || IsValidSecurityDescriptor(pSecDesc));

    BOOL bSecDescChanged;
    LONG err = EditShareAcl(
                        hwnd,
                        NULL,
                        szShareName,
                        pSecDesc,
                        &bSecDescChanged,
                        &pNewSecDesc);

    if (bSecDescChanged)
    {
        appAssert(IsValidSecurityDescriptor(pNewSecDesc));
        _pCurInfo->TransferSecurityDescriptor(pNewSecDesc);
        _MarkPageDirty();
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnRemove, private
//
//  Synopsis:   WM_COMMAND handler: the Remove button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnRemove(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(_cShares > 1);
    appAssert(_pCurInfo != NULL);
    if (NULL == _pCurInfo) // JonN 5/2/01 384155
        return TRUE;

    //
    // Alter the data structures
    //

    if (_pCurInfo->GetFlag() == SHARE_FLAG_ADDED)
    {
        // Something that was added this session is being removed: get rid of
        // it from our list.

        _pCurInfo->Unlink();
        delete _pCurInfo;
        _pCurInfo = NULL;
        // the _SetControlsFromData call resets the _pCurInfo pointer
    }
    else
    {
        // if the state was MODIFY or no state, then set it to REMOVE
        _pCurInfo->SetDirtyFlag(SHARE_FLAG_REMOVE);
    }

    --_cShares;

    //
    // Next, regenerate the UI
    //

    _SetControlsFromData(hwnd, NULL);

    _MarkPageDirty();

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnNewShare, private
//
//  Synopsis:   WM_COMMAND handler: the New Share button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnNewShare(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    //
    // First, create an object to put the new share into.
    // FEATURE: for out of memory errors, should we pop up an error box?
    //

    HRESULT hr;

    CShareInfo* pNewInfo = new CShareInfo();
    if (NULL == pNewInfo)
    {
        return FALSE;
    }

    hr = pNewInfo->InitInstance();
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete pNewInfo;
        return FALSE;
    }

    hr = pNewInfo->SetPath(_pszPath);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete pNewInfo;
        return FALSE;
    }

    NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
    if ( NERR_Success != ret )
    {
        delete pNewInfo;
        return HRESULT_FROM_WIN32 (ret);
    }

    pNewInfo->SetDirtyFlag(SHARE_FLAG_ADDED);

    CDlgNewShare dlg(hwnd);
    dlg.m_pInfoList = _pInfoList;
    dlg.m_pReplaceList = _pReplaceList;
    dlg.m_pShareInfo = pNewInfo;
    if (dlg.DoModal())
    {
        _ReadControls(hwnd);    // read current stuff

        //
        // Add the new one to the list
        //

        pNewInfo->InsertBefore(_pInfoList); // add to end of list

        ++_cShares; // one more share in the list...

        //
        // Next, regenerate the UI
        //

        _SetControlsFromData(hwnd, pNewInfo->GetNetname());

        _MarkPageDirty();
    }
    else
    {
        // user hit "cancel"
        delete pNewInfo;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnCaching, private
//
//  Synopsis:   WM_COMMAND handler: the Caching button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnCaching(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    // show wait cursor ??
    HINSTANCE    hInstance = ::LoadLibrary (L"FileMgmt.dll");
    if ( hInstance )
    {
        typedef HRESULT (*PfnCacheSettingsDlg)(HWND hwndParent, DWORD & dwFlags);
        PfnCacheSettingsDlg pfn = (PfnCacheSettingsDlg) ::GetProcAddress (
                hInstance, "CacheSettingsDlg");
        appAssert( NULL != _pCurInfo );
        if ( pfn && NULL != _pCurInfo) // JonN 5/2/01 384155
        {
            DWORD    dwFlags = _pCurInfo->GetCacheFlags ();

            HRESULT    hResult = pfn (hwnd, dwFlags);
            if ( S_OK == hResult )
            {
                _pCurInfo->SetCacheFlags (dwFlags);
                _MarkPageDirty();
            }
        }
        ::FreeLibrary (hInstance);
        return FALSE;
    }
    else
        return FALSE;

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_InitializeControls, private
//
//  Synopsis:   Initialize the controls from scratch
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_InitializeControls(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    //
    // Set defaults first
    //

    _SetControlsToDefaults(hwnd);

    _fInitializingPage++; // JonN 7/11/00 140878
    CheckRadioButton(
            hwnd,
            IDC_SHARE_NOTSHARED,
            IDC_SHARE_SHAREDAS,
            (_cShares > 0) ? IDC_SHARE_SHAREDAS : IDC_SHARE_NOTSHARED);
    _fInitializingPage--; // JonN 7/11/00 140878

    _SetControlsFromData(hwnd, NULL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_SetControlsToDefaults, private
//
//  Synopsis:   Set all the controls on the page to their default values
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetControlsToDefaults(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    _fInitializingPage++; // JonN 7/11/00 140878

    // Make "Maximum" the default number of users, and clear the value field
    // (which the spin button set on creation?).

    CheckRadioButton(
            hwnd,
            IDC_SHARE_MAXIMUM,
            IDC_SHARE_ALLOW,
            IDC_SHARE_MAXIMUM);

    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    // set the spin control range: 1 <--> large number
    SendDlgItemMessage(
            hwnd,
            IDC_SHARE_ALLOW_SPIN,
            UDM_SETRANGE,
            0,
            MAKELONG(g_uiMaxUsers, 1));

    _HideControls(hwnd, 0);

    HWND hwndCombo = GetDlgItem(hwnd, IDC_SHARE_SHARENAME_COMBO);
    ComboBox_ResetContent(hwndCombo);

    SetDlgItemText(hwnd, IDC_SHARE_SHARENAME,   L"");
    SetDlgItemText(hwnd, IDC_SHARE_COMMENT,     L"");
    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");


    _fInitializingPage--; // JonN 7/11/00 140878
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::SetControlsFromData, private
//
//  Synopsis:   From the class variables and current state of the radio
//              buttons, set the enabled/disabled state of the buttons, as
//              well as filling the controls with the appropriate values.
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetControlsFromData(
    IN HWND hwnd,
    IN PWSTR pszPreferredSelection
    )
{
    CHECK_SIG(CSharingPropertyPage);

    BOOL bIsShared = (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS));

    _EnableControls(hwnd, bIsShared);

    if (bIsShared)
    {
        appDebugOut((DEB_ITRACE, "_SetControlsFromData: path is shared\n"));

        _HideControls(hwnd, _cShares);

        //
        // Now, set controls based on actual data
        //

        _fInitializingPage++; // JonN 7/11/00 140878

        // if there is a new share, we only show the edit control for the
        // share name, not the combo box.

        if (_cShares == 0)
        {
            _pCurInfo = (CShareInfo*)_pInfoList->Next();
            appAssert(NULL != _pCurInfo);

            if (NULL != _pCurInfo) // JonN 5/2/01 384155
                SetDlgItemText(hwnd, IDC_SHARE_SHARENAME, _pCurInfo->GetNetname());
        }
        else // (_cShares > 0)
        {
            // in the combo box, the "item data" is the CShareInfo pointer of
            // the item.

            // fill the combo.

            HWND hwndCombo = GetDlgItem(hwnd, IDC_SHARE_SHARENAME_COMBO);
            ComboBox_ResetContent(hwndCombo);

            for (CShareInfo* p = (CShareInfo*) _pInfoList->Next();
                 p != _pInfoList;
                 p = (CShareInfo*) p->Next())
            {
                if (p->GetFlag() != SHARE_FLAG_REMOVE)
                {
                    int item = ComboBox_AddString(hwndCombo, p->GetNetname());
                    if (CB_ERR == item || CB_ERRSPACE == item)
                    {
                        // FEATURE: how to recover here?
                        break;
                    }

                    if (CB_ERR == ComboBox_SetItemData(hwndCombo, item, p))
                    {
                        // FEATURE: how to recover here?
                    }
                }
            }

            int sel = 0;
            if (NULL != pszPreferredSelection)
            {
                sel = ComboBox_FindStringExact(hwndCombo, -1, pszPreferredSelection);
                if (CB_ERR == sel)
                {
                    sel = 0;
                }
            }
            ComboBox_SetCurSel(hwndCombo, sel);

            _pCurInfo = (CShareInfo*)ComboBox_GetItemData(hwndCombo, sel);
            appAssert(NULL != _pCurInfo);
        }

        _fInitializingPage--; // JonN 7/11/00 140878

        // From the current item, set the rest of the fields

        _SetFieldsFromCurrent(hwnd);

        // This must be called after the share name field is initialized.
        EnableWindow(GetDlgItem(hwnd, IDC_SHARE_CACHING), IsCachingSupported ());
    }
    else
    {
        appDebugOut((DEB_ITRACE, "_SetControlsFromData: path is not shared\n"));
        _pCurInfo = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_EnableControls, private
//
//  Synopsis:   Enable/disable controls
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_EnableControls(
    IN HWND hwnd,
    IN BOOL bEnable
    )
{
    CHECK_SIG(CSharingPropertyPage);

    int idControls[] =
    {
        IDC_SHARE_SHARENAME_TEXT,
        IDC_SHARE_SHARENAME,
        IDC_SHARE_SHARENAME_COMBO,
        IDC_SHARE_COMMENT_TEXT,
        IDC_SHARE_COMMENT,
        IDC_SHARE_LIMIT,
        IDC_SHARE_MAXIMUM,
        IDC_SHARE_ALLOW,
        IDC_SHARE_ALLOW_SPIN,
        IDC_SHARE_ALLOW_VALUE,
        IDC_SHARE_REMOVE,
        IDC_SHARE_NEWSHARE,
        IDC_SHARE_PERMISSIONS
    };

    for (int i = 0; i < ARRAYLEN(idControls); i++)
    {
        EnableWindow(GetDlgItem(hwnd, idControls[i]), bEnable);
    }

    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_CACHING),
            bEnable && IsCachingSupported ());
}



//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_HideControls, private
//
//  Synopsis:   Hide or show the controls based on the current number
//              of shares.
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_HideControls(
    IN HWND hwnd,
    IN int cShares
    )
{
    CHECK_SIG(CSharingPropertyPage);

    _MyShow( hwnd, IDC_SHARE_REMOVE,          !!(cShares > 1) );
    _MyShow( hwnd, IDC_SHARE_NEWSHARE,        !!(cShares >= 1) );
    _MyShow( hwnd, IDC_SHARE_SHARENAME,       !!(cShares < 1) );
    _MyShow( hwnd, IDC_SHARE_SHARENAME_COMBO, !!(cShares >= 1) );
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_SetFieldsFromCurrent, private
//
//  Synopsis:   From the currently selected share, set the property page
//              controls.
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetFieldsFromCurrent(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(NULL != _pCurInfo);

    _fInitializingPage++; // JonN 7/11/00 140878

    SetDlgItemText(hwnd, IDC_SHARE_COMMENT,
        (NULL == _pCurInfo) ? L'\0' : _pCurInfo->GetRemark());

    DWORD dwLimit = (NULL == _pCurInfo) // JonN 5/2/01 384155
                        ? SHI_USES_UNLIMITED : _pCurInfo->GetMaxUses(); 
    if (dwLimit == SHI_USES_UNLIMITED)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        appDebugOut((DEB_ITRACE, "_SetFieldsFromCurrent: unlimited users\n"));

        CheckRadioButton(
                hwnd,
                IDC_SHARE_MAXIMUM,
                IDC_SHARE_ALLOW,
                IDC_SHARE_MAXIMUM);

        SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");
    }
    else
    {
        _wMaxUsers = (WORD)dwLimit;

        appDebugOut((DEB_ITRACE,
            "_SetFieldsFromCurrent: max users = %d\n",
            _wMaxUsers));

        CheckRadioButton(
                hwnd,
                IDC_SHARE_MAXIMUM,
                IDC_SHARE_ALLOW,
                IDC_SHARE_ALLOW);

        // let the spin control set the edit control
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));

        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }

    _fInitializingPage--; // JonN 7/11/00 140878
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_ReadControls, private
//
//  Synopsis:   Load the data in the controls into internal data structures.
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_ReadControls(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (!_bItemDirty)
    {
        // nothing to read
        appDebugOut((DEB_ITRACE, "_ReadControls: item not dirty\n"));
        return TRUE;
    }

    appDebugOut((DEB_ITRACE, "_ReadControls: item dirty\n"));
    appAssert(NULL != _pCurInfo);
    if (NULL == _pCurInfo) // JonN 5/2/01 384155
        return TRUE;

    if (_bShareNameChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: share name changed\n"));

        WCHAR szShareName[NNLEN + 1];
        GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
        TrimLeadingAndTrailingSpaces(szShareName);
        _pCurInfo->SetNetname(szShareName);
        _bShareNameChanged = FALSE;
    }

    if (_bCommentChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: comment changed\n"));

        WCHAR szComment[MAXCOMMENTSZ + 1];
        GetDlgItemText(hwnd, IDC_SHARE_COMMENT, szComment, ARRAYLEN(szComment));
        _pCurInfo->SetRemark(szComment);
        _bCommentChanged = FALSE;
    }

    if (_bUserLimitChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: user limit changed\n"));

        if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_MAXIMUM))
        {
            _pCurInfo->SetMaxUses(SHI_USES_UNLIMITED);
        }
        else if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
        {
            _CacheMaxUses(hwnd);
            _pCurInfo->SetMaxUses(_wMaxUsers);
        }
        _bUserLimitChanged = FALSE;
    }

    _bItemDirty = FALSE;

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_MarkItemDirty, private
//
//  Synopsis:   A change has made such that the current item (and page)
//              is now dirty
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_MarkItemDirty(
    VOID
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (!_fInitializingPage)
    {
        if (!_bItemDirty)
        {
            appDebugOut((DEB_ITRACE, "Marking Sharing page---current item---dirty\n"));
            _bItemDirty = TRUE;
        }

        _MarkPageDirty();
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_ValidatePage, private
//
//  Synopsis:   Return TRUE if the current page is valid
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_ValidatePage(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    _ReadControls(hwnd);    // read current stuff

    if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS))
    {
        // If the user is creating a share on the property sheet (as
        // opposed to using the "new share" dialog), we must validate the
        // share.... Note that _bNewShare is still TRUE if the the user has
        // clicked on "Not Shared", so we must check that too.

        // Validate the share

        if (!_ValidateNewShareName())
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }
    }

#if DBG == 1
    Dump(L"_ValidatePage finished");
#endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_DoApply, public
//
//  Synopsis:   If anything has changed, apply the data
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_DoApply(
    IN HWND hwnd,
    IN BOOL bClose
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (_bDirty)
    {
        BOOL bNotShared = (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_NOTSHARED));

        if (!bNotShared)
        {
            _ReadControls(hwnd);
        }

        _CommitShares(bNotShared);

        CShareBase::_DoApply(hwnd, bClose);

        if (!bClose)
        {
            _InitializeControls(hwnd);
        }
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_DoCancel, public
//
//  Synopsis:   Do whatever is necessary to cancel the changes
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_DoCancel(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (_bDirty)
    {
        _bItemDirty = FALSE;
        _bShareNameChanged = FALSE;
        _bCommentChanged = FALSE;
        _bUserLimitChanged = FALSE;
    }

    return CShareBase::_DoCancel(hwnd);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_CacheMaxUses, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_CacheMaxUses(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    DWORD dwRet = (DWORD)SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_GETPOS, 0, 0);
    if (HIWORD(dwRet) != 0)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        // Reset the edit control to the new value
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }
    else
    {
        _wMaxUsers = LOWORD(dwRet);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::IsCachingSupported
//
//  Synopsis:   Does the operating system support caching on this share?
//				This method initializes _bIsCachingSupported, if it is not already true
//
//--------------------------------------------------------------------------
bool CSharingPropertyPage::IsCachingSupported()
{
    if (!_bIsCachingSupported)
    {
        LPWSTR	pszShareName = 0;
        WCHAR	szShareName[NNLEN + 1];
        UINT	nRet =  GetDlgItemText (_hwndPage, IDC_SHARE_SHARENAME, szShareName,
                ARRAYLEN(szShareName));
        if ( nRet > 0 )
            pszShareName = szShareName;
        else if ( _pCurInfo )
            pszShareName = _pCurInfo->GetNetname ();

        if ( pszShareName )
        {
            SHARE_INFO_501* pshi501 = NULL;
            //
            // On pre-NT5 systems (per IsaacHe), NetShareGetInfo will return
            // ERROR_INVALID_LEVEL for info level 501 regardless of the share
            // name provided.  This is because the net code validates the
            // requested level *before* validating the share name.
            // Therefore, passing a blank share name works for our purposes
            // here.  If NetShareGetInfo returns ERROR_INVALID_LEVEL, this
            // means level 501 is not supported which means the system
            // isn't NT5 which means caching is not supported.  No need to
            // query the contents of *pshi501 because we're not interested in
            // the level of caching at this point. [brianau - 8/11/98]
            //
            NET_API_STATUS retval = ::NetShareGetInfo(
                    L"",            // machine name
                    L"",            // share name
                    501,
                    (LPBYTE*)&pshi501);

            if (ERROR_INVALID_LEVEL != retval)
            {
                _bIsCachingSupported = true;
            }
            if ( pshi501 )
            {
                ::NetApiBufferFree (pshi501);
            }
        }
    }

    return _bIsCachingSupported;
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::Dump, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CSharingPropertyPage::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CSharingPropertyPage);

    appDebugOut((DEB_TRACE,
        "CSharingPropertyPage::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t            This: 0x%08lx\n"
"\t            Path: %ws\n"
"\t            Page: 0x%08lx\n"
"\t   Initializing?: %ws\n"
"\t          Dirty?: %ws\n"
"\t     Item dirty?: %ws\n"
"\t  Share changed?: %ws\n"
"\tComment changed?: %ws\n"
"\tUsr Lim changed?: %ws\n"
"\t        Max uses: %d\n"
"\t      _pInfoList: 0x%08lx\n"
"\t       _pCurInfo: 0x%08lx\n"
"\t          Shares: %d\n"
,
this,
_pszPath,
_hwndPage,
_fInitializingPage ? L"yes" : L"no",
_bDirty ? L"yes" : L"no",
_bItemDirty ? L"yes" : L"no",
_bShareNameChanged ? L"yes" : L"no",
_bCommentChanged ? L"yes" : L"no",
_bUserLimitChanged ? L"yes" : L"no",
_wMaxUsers,
_pInfoList,
_pCurInfo,
_cShares
));

    CShareInfo* p;

    for (p = (CShareInfo*) _pInfoList->Next();
         p != _pInfoList;
         p = (CShareInfo*) p->Next())
    {
        p->Dump(L"Prop page list");
    }

    for (p = (CShareInfo*) _pReplaceList->Next();
         p != _pReplaceList;
         p = (CShareInfo*) p->Next())
    {
        p->Dump(L"Replace list");
    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\dlgbase.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dlgbase.cxx
//
//  Contents:   CDialog base class
//
//  History:    19-Oct-94 BruceFo Created.
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dlgbase.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CDialog::_WinDlgProc, static private
//
//  Synopsis:   Windows Dialog Procedure
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CDialog::_WinDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CDialog *pPropPage = NULL;

    if (msg==WM_INITDIALOG)
    {
       SetWindowLongPtr(hwnd,GWLP_USERDATA,lParam);
    }

    pPropPage = (CDialog*) GetWindowLongPtr(hwnd,GWLP_USERDATA);

    if (pPropPage != NULL)
    {
        return pPropPage->DlgProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\share.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       share.cxx
//
//  Contents:   Shell extension handler for sharing
//
//  Classes:    CShare
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "shrpage.hxx"
#include "shrpage2.hxx"

#include "share.hxx"
#include "acl.hxx"
#include "util.hxx"
#include "resource.h"

//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//
//  Member:     CShare::CShare
//
//  Synopsis:   Constructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CShare::CShare(VOID) :
    _uRefs(1),
    _fPathChecked(FALSE),
	_fMultipleSharesSelected (FALSE)
{
    INIT_SIG(CShare);
    _szPath[0] = 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShare::~CShare
//
//  Synopsis:   Destructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CShare::~CShare()
{
    CHECK_SIG(CShare);
}

#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])

LPCITEMIDLIST IDA_GetIDListPtr(LPIDA pida, UINT i)
{
    if (i == (UINT)-1 || i < pida->cidl)
    {
        return HIDA_GetPIDLItem(pida, i);
    }

    return NULL;
}

//
//  Retrieve a PIDL from the HIDA.
//
STDAPI_(LPITEMIDLIST) 
IDA_FullIDList(
      CIDA * pidaIn
    , UINT idxIn
    )
{
    LPITEMIDLIST pidl = NULL;
    LPCITEMIDLIST pidlParent = IDA_GetIDListPtr( pidaIn, (UINT) -1 );
    if ( NULL != pidlParent )
    {
        LPCITEMIDLIST pidlRel = IDA_GetIDListPtr( pidaIn, idxIn );
        if ( NULL != pidlRel )
        {
            pidl = ILCombine( pidlParent, pidlRel );
        }
    }

    return pidl;
}



//
//  Use LocalFree( ) to free the ppidaOut returned here
//
//  Return Values:
//      S_OK
//          Successfully extracted and copied the HIDA.
//
//      E_OUTOFMEMORY
//          Failed to copy the HIDA.
//
//      other HRESULTs
//
HRESULT
DataObj_CopyHIDA( 
      IDataObject * pdtobjIn
    , CIDA **       ppidaOut
    )
{
    HRESULT     hr;
    STGMEDIUM   medium;

    static CLIPFORMAT g_cfHIDA = 0;

    FORMATETC   fmte = { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    //  Check parameters
    appAssert( NULL != pdtobjIn );
    appAssert( NULL != ppidaOut );

    //  Clear out parameter
    *ppidaOut = NULL;

    //
    //  Register clip format if not already done.
    //

    if ( 0 == g_cfHIDA )
    {
        g_cfHIDA = (CLIPFORMAT) RegisterClipboardFormat( CFSTR_SHELLIDLIST );
    }

    fmte.cfFormat = g_cfHIDA;

    //
    //  Retrieve HIDA
    //

    hr = pdtobjIn->GetData( &fmte, &medium );
    if ( SUCCEEDED( hr ) )
    {
        SIZE_T sizet = GlobalSize( medium.hGlobal );
        if ( (~((DWORD) 0)) > sizet )
        {
            DWORD cb = (DWORD) sizet;
            CIDA * pida = (CIDA *) LocalAlloc( 0, cb );
            if ( NULL != pida )
            {
                void * pv = GlobalLock( medium.hGlobal );
                CopyMemory( pida, pv, cb );
                GlobalUnlock( medium.hGlobal );

                *ppidaOut = pida;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        ReleaseStgMedium( &medium );
    }

    return hr;
}


//
// Helpers to banish STRRET's into the realm of darkness
//
STDAPI DisplayNameOf(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch)
{
    *psz = 0;
    STRRET sr;
    HRESULT hr = psf->GetDisplayNameOf(pidl, flags, &sr);
    if (SUCCEEDED(hr))
        hr = StrRetToBuf(&sr, pidl, psz, cch);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CShare::Initialize
//
//  Derivation: IShellExtInit
//
//  Synopsis:   Initialize the shell extension. Stashes away the argument data.
//
//  History:    4-Apr-95    BruceFo  Created
//
//  Notes:      This method can be called more than once.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::Initialize(
    LPCITEMIDLIST   pidlFolder,
    LPDATAOBJECT    pDataObject,
    HKEY            hkeyProgID
    )
{
    CHECK_SIG(CShare);

    HRESULT hr = E_FAIL;

    if (pDataObject && _szPath[0] == 0)
    {
        STGMEDIUM medium;
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        hr = pDataObject->GetData(&fmte, &medium);
        if (SUCCEEDED(hr))
        {
            // Get the count of shares that have been selected.  Display the page only
            // if 1 share is selected but not for multiple shares.
            UINT nCntFiles = ::DragQueryFile ((HDROP) medium.hGlobal, -1, _szPath, ARRAYLEN (_szPath));
            if ( nCntFiles > 1 )
            {
                _fMultipleSharesSelected = TRUE;
            }

            DragQueryFile((HDROP)medium.hGlobal, 0, _szPath, ARRAYLEN(_szPath));
            ReleaseStgMedium(&medium);

            hr = S_OK;
        }
    }

    if (FAILED(hr) && _szPath[0] == 0 )
    {
        LPIDA pida;

        hr = DataObj_CopyHIDA(pDataObject, &pida);
        if (SUCCEEDED(hr))
        {
            if (pida->cidl > 1)
            {
                _fMultipleSharesSelected = TRUE;
            }

            //  Only grab the first guy.
            LPITEMIDLIST pidl = IDA_FullIDList( pida, 0 );
            if ( NULL != pidl )
            {
                LPCITEMIDLIST pidlParent = IDA_GetIDListPtr( pida, (UINT) -1 );
                if (NULL != pidlParent)
                {
                    IShellFolder * psf;
                    LPCITEMIDLIST pidlLast;

                    hr = SHBindToParent(pidl, IID_IShellFolder, (void**)&psf, &pidlLast);
                    if (SUCCEEDED(hr))
                    {
                        hr = DisplayNameOf(psf, pidlLast, SHGDN_NORMAL | SHGDN_FORPARSING, _szPath, ARRAYLEN(_szPath));

                        psf->Release();
                    }
                }
            }

            LocalFree(pida);
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShare::AddPages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (from shlobj.h)
//              "The explorer calls this member function when it finds a
//              registered property sheet extension for a particular type
//              of object. For each additional page, the extension creates
//              a page object by calling CreatePropertySheetPage API and
//              calls lpfnAddPage.
//
//  Arguments:  lpfnAddPage -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam
    )
{
    CHECK_SIG(CShare);

    if (!_fMultipleSharesSelected && _OKToShare())
    {
        appAssert(_szPath[0]);

        //
        //  Create a property sheet page object from a dialog box.
        //

        PWSTR pszPath = NewDup(_szPath);
        if (NULL == pszPath)
        {
            return E_OUTOFMEMORY;
        }

        // Now we have pszPath memory to delete

        BOOL bSimpleUI = IsSimpleUI();

        CShareBase* pPage = NULL;
        if (bSimpleUI)
        {
            pPage = new CSimpleSharingPage(pszPath);
        }
        else
        {
            pPage = new CSharingPropertyPage(pszPath, FALSE);
        }

        if (NULL == pPage)
        {
            delete[] pszPath;
            return E_OUTOFMEMORY;
        }

        // Now the pPage object owns pszPath memory. However, we have
        // pPage memory to delete.

        HRESULT hr = pPage->InitInstance();
        if (FAILED(hr))
        {
            pPage->Release();
            return E_OUTOFMEMORY;
        }

        PROPSHEETPAGE psp;

        psp.dwSize      = sizeof(psp);    // no extra data.
        psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
        psp.hInstance   = g_hInstance;
        psp.pszTemplate = bSimpleUI ? MAKEINTRESOURCE(IDD_SIMPLE_SHARE_PROPERTIES) : MAKEINTRESOURCE(IDD_SHARE_PROPERTIES);
        psp.hIcon       = NULL;
        psp.pszTitle    = NULL;
        psp.pfnDlgProc  = CShareBase::DlgProcPage;
        psp.lParam      = (LPARAM)pPage;  // transfer ownership
        psp.pfnCallback = CShareBase::PageCallback;
        psp.pcRefParent = &g_NonOLEDLLRefs;

        HPROPSHEETPAGE hpage = CreatePropertySheetPage(&psp);
        if (NULL == hpage)
        {
            // If CreatePropertySheetPage fails, we still have pPage memory
            // to delete.
            pPage->Release();
            return E_OUTOFMEMORY;
        }

        BOOL fAdded = (*lpfnAddPage)(hpage, lParam);
        if (!fAdded)
        {
            // At this point, pPage memory, as the lParam of a PROPSHEETPAGE
            // that has been converted into an HPROPSHEETPAGE, is owned by the
            // hpage. Calling DestroyPropertySheetPage will invoke the
            // PageCallback function, subsequently destroying the pPage object,
            // and hence the pszPath object within it. Whew!

            DestroyPropertySheetPage(hpage);
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShare::ReplacePages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (From shlobj.h)
//              "The explorer never calls this member of property sheet
//              extensions. The explorer calls this member of control panel
//              extensions, so that they can replace some of default control
//              panel pages (such as a page of mouse control panel)."
//
//  Arguments:  uPageID -- Specifies the page to be replaced.
//              lpfnReplace -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::ReplacePage(
    UINT                 uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM               lParam
    )
{
    CHECK_SIG(CShare);

    appAssert(!"CShare::ReplacePage called, not implemented");
    return E_NOTIMPL;
}



//+-------------------------------------------------------------------------
//
//  Member:     CShare::QueryContextMenu
//
//  Derivation: IContextMenu
//
//  Synopsis:   Called when shell wants to add context menu items.
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
    )
{
    CHECK_SIG(CShare);

    if ((hmenu == NULL) || (uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY)))
    {
        return S_OK;
    }

    int  cNumberAdded = 0;
    UINT idCmd        = idCmdFirst;

    // 159891 remove context menu if multiple shares selected
    if (!_fMultipleSharesSelected && _OKToShare())
    {
        appAssert(_szPath[0]);

        WCHAR szShareMenuItem[50];
        LoadString(g_hInstance, IDS_SHARING, szShareMenuItem, ARRAYLEN(szShareMenuItem));

        if (InsertMenu(hmenu, indexMenu, MF_STRING | MF_BYPOSITION, idCmd++, szShareMenuItem))
        {
            cNumberAdded++;
            InsertMenu(hmenu, indexMenu, MF_SEPARATOR | MF_BYPOSITION, 0, NULL);
        }
    }
    return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, (USHORT)cNumberAdded));
}



//+-------------------------------------------------------------------------
//
//  Member:     CShare::InvokeCommand
//
//  Derivation: IContextMenu
//
//  Synopsis:   Called when the shell wants to invoke a context menu item.
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::InvokeCommand(
    LPCMINVOKECOMMANDINFO pici
    )
{
    CHECK_SIG(CShare);

    HRESULT hr = E_INVALIDARG;  // assume error.

    if (0 == HIWORD(pici->lpVerb))
    {
        appAssert(_szPath[0]);
        hr = ShowShareFolderUIW(pici->hwnd, _szPath);
    }
    else
    {
        // FEATURE: compare the strings if not a MAKEINTRESOURCE?
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShare::GetCommandString
//
//  Derivation: IContextMenu
//
//  Synopsis:   Called when the shell wants to get a help string or the
//              menu string.
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT*       pwReserved,
    LPSTR       pszName,
    UINT        cchMax
    )
{
    CHECK_SIG(CShare);

    if (uType == GCS_HELPTEXT)
    {
        LoadStringW(g_hInstance, IDS_MENUHELP, (LPWSTR)pszName, cchMax);
        return NOERROR;
    }
    else
    {
        LoadStringW(g_hInstance, IDS_SHARING, (LPWSTR)pszName, cchMax);
        return NOERROR;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CShare::_OKToShare
//
//  Synopsis:   Determine if it is ok to share the current object. It stashes
//              away the current path by querying the cached IDataObject.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CShare::_OKToShare(VOID)
{
    CHECK_SIG(CShare);

    if (!_fPathChecked)
    {
        _fPathChecked = TRUE;
        _fOkToSharePath = (S_OK == CanShareFolderW(_szPath));
    }

    return _fOkToSharePath;
}


// dummy function to export to get linking to work

HRESULT SharePropDummyFunction()
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           100
#define IDS_NET_MSG_NOT_FOUND           101
#define IDS_NO_NET_MSG                  102
#define IDS_MSGTITLE                    103
#define IDS_SHARING                     104
#define IDS_MENUHELP                    105
#define IDS_ACLEDIT_PERM_GEN_NO_ACCESS  106
#define IDS_ACLEDIT_PERM_GEN_READ       107
#define IDS_ACLEDIT_PERM_GEN_MODIFY     108
#define IDS_ACLEDIT_PERM_GEN_ALL        109
#define IDS_ACLEDIT_TITLE               110
#define IDS_HELPFILENAME                111
#define IDS_SHAREPERM_READ              112
#define IDS_SHAREPERM_MODIFY            113
#define IDS_SHAREPERM_ALL               114
#define IDS_CSCUI_HELPFILENAME          115
#define IDI_ICON_SHARE                  116
#define IDS_PERMPAGE_TITLE              117
#define IDS_PRIVATE_CONFIRM_DELSHARE    118
#define IDS_PRIVATE_CREATE_PASSWORD     119
#define IDS_SIMPLE_SHARE_HELPFILE       120
#define IDS_SHARE_HELP_SHARING_AND_SECURITY_PER 121
#define IDI_SECURITY                    122
#define IDI_NETWORK                     123
#define IDI_SMALL_EXCL                  124
#define IDS_SHARE_HELP_SHARING_AND_SECURITY_WKS 125
#define IDS_PERM_PROGRESS_TITLE         126
#define IDI_INFO                        127
#define IDD_SHARE_PROPERTIES            1000
#define IDC_SHARE_SHARENAME             1001
#define IDC_SHARE_COMMENT               1002
#define IDC_SHARE_SHARENAME_TEXT        1003
#define IDC_SHARE_COMMENT_TEXT          1004
#define IDC_SHARE_LIMIT                 1005
#define IDC_SHARE_MAXIMUM               1006
#define IDC_SHARE_ALLOW                 1007
#define IDC_SHARE_PERMISSIONS           1008
#define IDC_SHARE_ALLOW_SPIN            1010
#define IDC_SHARE_ALLOW_VALUE           1011
#define IDC_SHARE_REMOVE                1012
#define IDC_SHARE_NOTSHARED             1013
#define IDC_SHARE_SHAREDAS              1014
#define IDC_SHARE_SHARENAME_COMBO       1015
#define IDC_SHARE_NEWSHARE              1017
#define IDD_NEW_SHARE                   1018
#define IDC_SHARE_CACHING               1019
#define IDC_SHARE_CACHING_TEXT          1020
#define IDC_SHARE_ICON                  1021
#define IDC_SHARE_TOPTEXT               1022
#define IDD_SIMPLE_SHARE_PROPERTIES     1025
#define IDC_SIMPLE_SHARE_SECURITY_STATIC 1036
#define IDC_SIMPLE_SHARE_NETWORKING_STATIC 1037
#define IDC_LNK_SHARE_PARENT_PROTECTED  1038
#define IDC_LNK_SHARE_NETWORK_WIZARD    1039
#define IDC_LNK_SHARE_HELP_ON_SECURITY  1040
#define IDC_LNK_SHARE_HELP_SHARING_AND_SECURITY 1041
#define IDC_I_SHARE_INFORMATION         1043
#define IDC_LNK_SHARE_OPEN_SHARED_DOCS  1044
#define IDC_LNK_SHARE_DRIVE_BLOCADE     1045
#define IDC_GB_SECURITY                 1046
#define IDC_GB_NETWORK_SHARING          1047
#define IDC_S_SHARE_SYSTEM_FOLDER       1049
#define IDC_LNK_SHARE_SECURITY_OVERRIDE 1050
#define IDD_SIMPLE_SHARE_ENABLE_WARNING 1051
#define IDC_RB_ENABLE_FILE_SHARING      1052
#define IDC_RB_RUN_THE_WIZARD           1053
#define IDC_ICON_INFO                   1054

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1055
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\shrinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       shrinfo.cxx
//
//  Contents:   Lanman SHARE_INFO_502 encapsulation
//
//  History:    21-Feb-95   BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "shrinfo.hxx"
#include "util.hxx"
#include <sddl.h>       // ConvertStringSecurityDescriptorToSecurityDescriptor


CShareInfo::CShareInfo(
    VOID
    )
    :
    m_bOwn(TRUE),
    m_flags(0),
    m_pInfo(NULL),
    m_dwCacheFlags (0),
    m_bCachingSupported (true)
{
    INIT_SIG(CShareInfo);
    Close();    // doubly-linked list
}

CShareInfo::CShareInfo(
    IN SHARE_INFO_502* pInfo
    )
    :
    m_bOwn(FALSE),
    m_flags(0),
    m_pInfo(pInfo),
    m_dwCacheFlags (0),
    m_bCachingSupported (true)
{
    INIT_SIG(CShareInfo);
    Close();    // doubly-linked list
}

HRESULT
CShareInfo::InitInstance(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        appAssert(m_pInfo == NULL);

        m_pInfo = new SHARE_INFO_502;
        if (NULL == m_pInfo)
        {
            return E_OUTOFMEMORY;
        }

        m_pInfo->shi502_netname       = NULL;
        m_pInfo->shi502_type          = STYPE_DISKTREE;
        m_pInfo->shi502_remark        = NULL;
        m_pInfo->shi502_permissions   = ACCESS_ALL;
        m_pInfo->shi502_max_uses      = SHI_USES_UNLIMITED;
        m_pInfo->shi502_path          = NULL;
        m_pInfo->shi502_passwd        = NULL;
        m_pInfo->shi502_reserved      = 0;

        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                c_szReadonlyShareSD,
                SDDL_REVISION_1,
                &m_pInfo->shi502_security_descriptor,
                NULL))
        {
            // If we continued here and the user clicked Apply, the share
            // would be wide open (no security).
            return E_ACCESSDENIED;
        }
    }

    return S_OK;
}

CShareInfo::~CShareInfo()
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        if (NULL != m_pInfo)    // must check; InitInstance might have failed
        {
            delete[] m_pInfo->shi502_netname;
            delete[] m_pInfo->shi502_remark;
            delete[] m_pInfo->shi502_path;
            delete[] m_pInfo->shi502_passwd;
            if (NULL != m_pInfo->shi502_security_descriptor)
            {
                ::LocalFree(m_pInfo->shi502_security_descriptor);
                m_pInfo->shi502_security_descriptor = NULL;
            }
            delete m_pInfo;
        }
    }
}

NET_API_STATUS
CShareInfo::Commit(
    IN PWSTR pszMachine
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if (m_flags == 0)
    {
        // nothing changed
        appDebugOut((DEB_ITRACE, "CShareInfo::Commit: nothing (%ws)\n", m_pInfo->shi502_netname));
        return NERR_Success;
    }

// #if DBG == 1
//     Dump(L"Commit");
// #endif // DBG == 1

    NET_API_STATUS ret = NERR_Success; // JonN 05/30/00 PREFIX 114205

    // Note: we store a path, even for admin$. However, the NetShare* APIs
    // don't like seeing a path for admin$, so we temporarily strip it here
    // if necessary, before calling any APIs.

    LPWSTR pszPathTmp = m_pInfo->shi502_path;
    if (0 == _wcsicmp(g_szAdminShare, m_pInfo->shi502_netname))
    {
        m_pInfo->shi502_path = NULL;
    }

    if (SHARE_FLAG_ADDED == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: add (%ws)\n", m_pInfo->shi502_netname));
        ret = NetShareAdd(pszMachine, 502, (LPBYTE)m_pInfo, NULL);
        if ( NERR_Success == ret )
            ret = WriteCacheFlags ();
    }
    else if (SHARE_FLAG_REMOVE == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: remove (%ws)\n", m_pInfo->shi502_netname));
        ret = NetShareDel(pszMachine, m_pInfo->shi502_netname, 0);
    }
    else if (SHARE_FLAG_MODIFY == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: modify (%ws)\n", m_pInfo->shi502_netname));
        DWORD parm_err;
        ret = NetShareSetInfo(pszMachine, m_pInfo->shi502_netname, 502, (LPBYTE)m_pInfo, &parm_err);
        if ( NERR_Success == ret )
            ret = WriteCacheFlags ();
    }


    // Restore the original, in case of admin$
    m_pInfo->shi502_path = pszPathTmp;

    // Must refresh the cache of shares after all commits
    if (ret != NERR_Success)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: err = %d\n", ret));
    }

    return ret;
}

SHARE_INFO_502*
CShareInfo::GetShareInfo(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo;
}

PWSTR
CShareInfo::GetNetname(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);
    
    if ( m_pInfo )
        return m_pInfo->shi502_netname;
    else
        return 0;
}

DWORD
CShareInfo::GetType(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_type;
    else
        return 0;
}

PWSTR
CShareInfo::GetRemark(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_remark;
    else
        return 0;
}

DWORD
CShareInfo::GetMaxUses(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_max_uses;
    else
        return 0;
}

PWSTR
CShareInfo::GetPassword(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_passwd;
    else
        return 0;
}

PWSTR
CShareInfo::GetPath(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_path;
    else
        return 0;
}

PSECURITY_DESCRIPTOR
CShareInfo::GetSecurityDescriptor(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_security_descriptor;
    else
        return 0;
}

HRESULT
CShareInfo::SetNetname(
    IN PWSTR pszNetname
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetNetname() = '%ws'\n",
        pszNetname));

    delete[] m_pInfo->shi502_netname;
    m_pInfo->shi502_netname = NewDup(pszNetname);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetType(
    IN DWORD dwType
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (dwType != m_pInfo->shi502_type)
    {
        // only take ownership and set the data if it's changed!

        if (!TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        appDebugOut((DEB_ITRACE,
            "CShareInfo::SetType(%ws) = %d\n",
            m_pInfo->shi502_netname,
            dwType));

        m_pInfo->shi502_type = dwType;

        if (m_flags != SHARE_FLAG_ADDED)
        {
            m_flags = SHARE_FLAG_MODIFY;
        }
    }

    return S_OK;
}

HRESULT
CShareInfo::SetRemark(
    IN PWSTR pszRemark
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetRemark(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszRemark));

    delete[] m_pInfo->shi502_remark;
    m_pInfo->shi502_remark = NewDup(pszRemark);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetMaxUses(
    IN DWORD dwMaxUses
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (dwMaxUses != m_pInfo->shi502_max_uses)
    {
        // only take ownership and set the data if it's changed!

        if (!TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        appDebugOut((DEB_ITRACE,
            "CShareInfo::SetMaxUses(%ws) = %d\n",
            m_pInfo->shi502_netname,
            dwMaxUses));

        m_pInfo->shi502_max_uses = dwMaxUses;

        if (m_flags != SHARE_FLAG_ADDED)
        {
            m_flags = SHARE_FLAG_MODIFY;
        }
    }

    return S_OK;
}

HRESULT
CShareInfo::SetPassword(
    IN PWSTR pszPassword
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetPassword(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszPassword));

    delete[] m_pInfo->shi502_passwd;
    m_pInfo->shi502_passwd = NewDup(pszPassword);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetPath(
    IN PWSTR pszPath
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetPath(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszPath));

    delete[] m_pInfo->shi502_path;
    if (pszPath[0] == TEXT('\0'))
    {
        m_pInfo->shi502_path = NULL;    // so IPC$ and ADMIN$ work
    }
    else
    {
        m_pInfo->shi502_path = NewDup(pszPath);
    }

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetSecurityDescriptor(%ws) = ...\n",
        m_pInfo->shi502_netname));

    if (NULL != m_pInfo->shi502_security_descriptor)
        ::LocalFree(m_pInfo->shi502_security_descriptor);
    m_pInfo->shi502_security_descriptor = CopySecurityDescriptor(pSecDesc);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}


// security descriptors alloced via ::LocalAlloc
HRESULT
CShareInfo::TransferSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::TransferSecurityDescriptor(%ws) = ...\n",
        m_pInfo->shi502_netname));

    if (NULL != m_pInfo->shi502_security_descriptor)
        ::LocalFree(m_pInfo->shi502_security_descriptor);
    m_pInfo->shi502_security_descriptor = pSecDesc;

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

ULONG
CShareInfo::GetFlag(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    return m_flags;
}

VOID
CShareInfo::SetDirtyFlag(
    ULONG flag
    )
{
    CHECK_SIG(CShareInfo);

    m_flags = flag;
}

HRESULT
CShareInfo::Copy(
    IN SHARE_INFO_502* pInfo
    )
{
    CHECK_SIG(CShareInfo);

    // get a valid SHARE_INFO_502 structure...

    if (m_bOwn)
    {
        // delete what's already there

        appAssert(NULL != m_pInfo);

        delete[] m_pInfo->shi502_netname;
        delete[] m_pInfo->shi502_remark;
        delete[] m_pInfo->shi502_path;
        delete[] m_pInfo->shi502_passwd;
        if (NULL != m_pInfo->shi502_security_descriptor)
        {
            ::LocalFree(m_pInfo->shi502_security_descriptor);
            m_pInfo->shi502_security_descriptor = NULL;
        }
    }
    else
    {
        m_pInfo = new SHARE_INFO_502;
        if (NULL == m_pInfo)
        {
            return E_OUTOFMEMORY;
        }
    }

    appAssert(NULL != m_pInfo);

    m_bOwn = TRUE;

    m_pInfo->shi502_netname       = NULL;
    m_pInfo->shi502_type          = pInfo->shi502_type;
    m_pInfo->shi502_remark        = NULL;
    m_pInfo->shi502_permissions   = pInfo->shi502_permissions;
    m_pInfo->shi502_max_uses      = pInfo->shi502_max_uses;
    m_pInfo->shi502_path          = NULL;
    m_pInfo->shi502_passwd        = NULL;
    m_pInfo->shi502_reserved      = pInfo->shi502_reserved;
    m_pInfo->shi502_security_descriptor = NULL;

    if (NULL != pInfo->shi502_netname)
    {
        m_pInfo->shi502_netname = NewDup(pInfo->shi502_netname);
    }
    if (NULL != pInfo->shi502_remark)
    {
        m_pInfo->shi502_remark = NewDup(pInfo->shi502_remark);
    }
    if (NULL != pInfo->shi502_path)
    {
        m_pInfo->shi502_path = NewDup(pInfo->shi502_path);
    }
    if (NULL != pInfo->shi502_passwd)
    {
        m_pInfo->shi502_passwd = NewDup(pInfo->shi502_passwd);
    }

    if (NULL != pInfo->shi502_security_descriptor)
    {
        m_pInfo->shi502_security_descriptor = CopySecurityDescriptor(pInfo->shi502_security_descriptor);
    }

    return S_OK;
}

BOOL
CShareInfo::TakeOwn(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    if (m_pInfo == NULL)
        return FALSE;

    if (m_bOwn)
    {
        return TRUE;    // already own the memory
    }

    SHARE_INFO_502* pInfo = new SHARE_INFO_502;
    if (NULL == pInfo)
    {
        return FALSE;
    }

    pInfo->shi502_type          = m_pInfo->shi502_type;
    pInfo->shi502_permissions   = m_pInfo->shi502_permissions;
    pInfo->shi502_max_uses      = m_pInfo->shi502_max_uses;
    pInfo->shi502_reserved      = 0;

    pInfo->shi502_netname = NULL;
    if (NULL != m_pInfo->shi502_netname)
    {
        pInfo->shi502_netname = NewDup(m_pInfo->shi502_netname);
    }

    pInfo->shi502_remark  = NULL;
    if (NULL != m_pInfo->shi502_remark)
    {
        pInfo->shi502_remark = NewDup(m_pInfo->shi502_remark);
    }

    pInfo->shi502_path    = NULL;
    if (NULL != m_pInfo->shi502_path)
    {
        pInfo->shi502_path = NewDup(m_pInfo->shi502_path);
    }

    pInfo->shi502_passwd  = NULL;
    if (NULL != m_pInfo->shi502_passwd)
    {
        pInfo->shi502_passwd = NewDup(m_pInfo->shi502_passwd);
    }

    pInfo->shi502_security_descriptor = NULL;
    if (NULL != m_pInfo->shi502_security_descriptor)
    {
        pInfo->shi502_security_descriptor = CopySecurityDescriptor(m_pInfo->shi502_security_descriptor);
    }

    m_pInfo = pInfo;
    m_bOwn = TRUE;

#if DBG == 1
    Dump(L"After TakeOwn");
#endif // DBG == 1

    return TRUE;
}


VOID
DeleteShareInfoList(
    IN CShareInfo* pShareInfoList,
    IN BOOL fDeleteDummyHeadNode
    )
{
    if (NULL == pShareInfoList)
    {
        // allow "deletion" of NULL list
        return;
    }

    for (CShareInfo* p = (CShareInfo*) pShareInfoList->Next();
         p != pShareInfoList;
         )
    {
        CShareInfo* pNext = (CShareInfo*)p->Next();
        delete p;
        p = pNext;
    }

    if (fDeleteDummyHeadNode)
    {
        delete pShareInfoList;
    }
    else
    {
        pShareInfoList->Close();    // reset pointers
    }
}


#if DBG == 1

VOID
CShareInfo::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CShareInfo);

    appDebugOut((DEB_TRACE,
        "CShareInfo::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t       This: 0x%08lx\n"
"\t       Info: 0x%08lx\n"
"\tOwn memory?: %ws\n"
"\t      Flags: %ws\n"
"\t Share name: %ws\n"
"\t       Type: %d\n"
"\t    Comment: %ws\n"
"\tPermissions: %d\n"
"\t   Max uses: %d\n"
"\t       Path: %ws\n"
"\t   Password: %ws\n"
"\t   Reserved: %d\n"
"\t   Security? %ws\n"
,
this,
m_pInfo,
m_bOwn ? L"yes" : L"no",
(m_flags == 0)
    ? L"none"
    : (m_flags == SHARE_FLAG_ADDED)
        ? L"added"
        : (m_flags == SHARE_FLAG_REMOVE)
            ? L"remove"
            : (m_flags == SHARE_FLAG_MODIFY)
                ? L"modify"
                : L"UNKNOWN!",
(NULL == m_pInfo->shi502_netname) ? L"none" : m_pInfo->shi502_netname,
m_pInfo->shi502_type,
(NULL == m_pInfo->shi502_remark) ? L"none" : m_pInfo->shi502_remark,
m_pInfo->shi502_permissions,
m_pInfo->shi502_max_uses,
(NULL == m_pInfo->shi502_path) ? L"none" : m_pInfo->shi502_path,
(NULL == m_pInfo->shi502_passwd) ? L"none" : m_pInfo->shi502_passwd,
m_pInfo->shi502_reserved,
(NULL == m_pInfo->shi502_security_descriptor) ? L"No" : L"Yes"
));

}

#endif // DBG == 1

DWORD 
CShareInfo::GetCacheFlags(
    VOID
    ) const
{
    CHECK_SIG(CShareInfo);

    return m_dwCacheFlags;
}

void 
CShareInfo::SetCacheFlags(
    DWORD dwFlags
    )
{
    CHECK_SIG(CShareInfo);

    m_dwCacheFlags = dwFlags;
    if ( SHARE_FLAG_ADDED != m_flags )
        m_flags = SHARE_FLAG_MODIFY;
}

//
// These methods cover the seperate API to determine whether IntelliMirror
// caching is enabled.  By default (FPNW and SFM) they are disabled.
//
// We read this data at level 501 in order to determine whether the target
// server is NT4.  NetShareGetInfo[1005] actually succeeds on an NT4 server,
// whereas NetShareGetInfo[501] fails with ERROR_INVALID_LEVEL.  We want this
// to fail so that we can disable the checkbox where the underlying
// functionality is not supported.
//
// CODEWORK: If this becomes remotable, we'll need to do a better job of 
//            handling the error case when this method fails.
//
NET_API_STATUS 
CShareInfo::ReadCacheFlags(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    NET_API_STATUS retval = NERR_Success;

    m_dwCacheFlags = 0;
		
    if ( m_bCachingSupported ) // If we've already determined that caching is 
           // not supported, don't call this again
    {
        SHARE_INFO_501* pshi501 = NULL;
        PWSTR           pwszNetName = GetNetname ();

        if ( pwszNetName && *pwszNetName )
        {
            retval = ::NetShareGetInfo(
                    L"",            // machine name
                    pwszNetName,    // share name
                    501,
                    (LPBYTE*)&pshi501);
            if (NERR_Success == retval)
            {
                if ( pshi501 )
                {
                    m_dwCacheFlags = pshi501->shi501_flags;
                    ::NetApiBufferFree (pshi501);
                }
            }
            else if ( ERROR_INVALID_LEVEL == retval )
            {
                // This share is probably on an NT 4.0 machine and does not 
                // support caching
                m_bCachingSupported = false;
                retval = NERR_Success;
            }
            else if ( NERR_Success != retval )
                m_bCachingSupported = false;
        }
    }
    return retval;
}

NET_API_STATUS 
CShareInfo::WriteCacheFlags(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    NET_API_STATUS retval = NERR_Success;

    if ( m_bCachingSupported ) // If we've already determined that caching is 
						       // not supported, don't call this again
    {
        SHARE_INFO_1005 shi1005;
        ZeroMemory( &shi1005, sizeof(shi1005) );
        shi1005.shi1005_flags = m_dwCacheFlags;
        DWORD dwDummy = 0;
        retval = ::NetShareSetInfo(
                L"",            // machine name
                GetNetname (),    // share name
                1005,
                (LPBYTE)&shi1005,
                &dwDummy);
        if ( ERROR_INVALID_LEVEL == retval )
        {
            // This share is probably on an NT 4.0 machine and does not support 
            // caching
            m_bCachingSupported = false;
            retval = NERR_Success;
        }
        else if ( NERR_Success != retval )
            m_bCachingSupported = false;
    }

	return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\shrpage2.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       shrpage2.cxx
//
//  Contents:   "Simple Sharing" shell property page extension
//
//  History:    06-Oct-00       jeffreys    Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "dlgnew.hxx"
#include "cache.hxx"
#include "share.hxx"
#include "acl.hxx"
#include "shrinfo.hxx"
#include "shrpage2.hxx"
#include "util.hxx"
#include <userenv.h>    // GetProfilesDirectory
#include <sddl.h>       // ConvertSidToStringSid, ConvertStringSecurityDescriptorToSecurityDescriptor
#include <seopaque.h>   // FirstAce, etc.
#include <shgina.h>     // ILocalMachine, ILogonUser
#include <shpriv.h>     // IHomeNetworkWizard

extern GENERIC_MAPPING ShareMap;    // permpage.cpp

//
//  Forward Decl.
//

INT_PTR
WarningDlgProc(
    IN HWND hWnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

// Security descriptor stuff used on this page
//
// (A;OICI;GA;;;SY) == Allow GENERIC_ALL to SYSTEM
// (A;OICI;GA;;;%s) == Allow GENERIC_ALL to <current user>
// (A;OICI;GA;;;BA) == Allow GENERIC_ALL to Builtin (local) Administrators
// (A;OICI;GRGWGXSD;;;WD) == Allow Modify access to Everyone (Read, Write, eXecute, Delete)
//
// "OI" == Object Inherit (inherit onto files)
// "CI" == Container Inherit (inherit onto subfolders)
//
// See sddl.h for more info.

// Share permissions
const WCHAR c_szFullShareSD[]     = L"D:(A;;GRGWGXSD;;;WD)";
const WCHAR c_szReadonlyShareSD[] = L"D:(A;;GRGX;;;WD)";

// Folder permissions (used only on profile folders)
const WCHAR c_szPrivateFolderSD[] = L"D:P(A;OICI;GA;;;SY)(A;OICI;GA;;;%s)";
const WCHAR c_szDefaultProfileSD[]= L"D:P(A;OICI;GA;;;SY)(A;OICI;GA;;;%s)(A;OICI;GA;;;BA)";

// Root folder permissions (see SDDLRoot in ds\security\services\scerpc\headers.h)
const WCHAR c_szRootSDSecure[] = L"D:(A;OICI;GA;;;BA)(A;OICI;GA;;;SY)(A;OICIIO;GA;;;CO)(A;CIOI;GRGX;;;BU)(A;CI;4;;;BU)(A;CIIO;2;;;BU)(A;;GRGX;;;WD)";
const WCHAR c_szRootSDUnsecure[]= L"D:P(A;OICI;GA;;;WD)";

typedef struct
{
    SID sid;            // contains 1 subauthority
    DWORD dwSubAuth[1]; // we currently need at most 2 subauthorities
} _SID2;

const  SID  g_WorldSid  =  {SID_REVISION,1,SECURITY_WORLD_SID_AUTHORITY,  {SECURITY_WORLD_RID}         };
const _SID2 g_AdminsSid = {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}}, {DOMAIN_ALIAS_RID_ADMINS}};
const _SID2 g_PowerUSid = {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}}, {DOMAIN_ALIAS_RID_POWER_USERS}};
const _SID2 g_UsersSid  = {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}}, {DOMAIN_ALIAS_RID_USERS}};
const _SID2 g_GuestsSid = {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}}, {DOMAIN_ALIAS_RID_GUESTS}};

static const UINT g_rgHideTheseControlsOnDriveBlockade[] = {
      IDC_GB_SECURITY
    , IDC_GB_NETWORK_SHARING
    , IDC_SIMPLE_SHARE_SECURITY_STATIC
    , IDC_SHARE_NOTSHARED
    , IDC_LNK_SHARE_PARENT_PROTECTED
    , IDC_SHARE_ICON
    , IDC_SIMPLE_SHARE_NETWORKING_STATIC
    , IDC_SHARE_SHAREDAS
    , IDC_SHARE_SHARENAME_TEXT
    , IDC_SHARE_SHARENAME
    , IDC_SHARE_PERMISSIONS
    , IDC_I_SHARE_INFORMATION
    , IDC_LNK_SHARE_NETWORK_WIZARD
    , IDC_LNK_SHARE_OPEN_SHARED_DOCS
    , IDC_LNK_SHARE_HELP_SHARING_AND_SECURITY
    , IDC_LNK_SHARE_HELP_ON_SECURITY
    , IDC_S_SHARE_SYSTEM_FOLDER
    , IDC_LNK_SHARE_SECURITY_OVERRIDE
    };




//+-------------------------------------------------------------------------
//
//  Method:     _GetUserSid
//
//  Synopsis:   Get the current user's SID from the thread or process token.
//
//--------------------------------------------------------------------------

BOOL
_GetUserSid(
    OUT PWSTR *ppszSID
    )
{
    BOOL bResult = FALSE;
    HANDLE hToken;

    *ppszSID = NULL;

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)
        || OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        BYTE buffer[sizeof(TOKEN_USER) + sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD)];
        ULONG cbBuffer = sizeof(buffer);

        if (GetTokenInformation(hToken,
                                TokenUser,
                                buffer,
                                cbBuffer,
                                &cbBuffer))
        {
            PTOKEN_USER ptu = (PTOKEN_USER)buffer;
            bResult = ConvertSidToStringSidW(ptu->User.Sid, ppszSID);
        }

        CloseHandle(hToken);
    }

    return bResult;
}


//+-------------------------------------------------------------------------
//
//  Method:     _GetUserProfilePath
//
//  Synopsis:   Retrieve the profile path for a particular user.
//
//--------------------------------------------------------------------------

HRESULT _GetUserProfilePath(PCWSTR pszUserSID, PWSTR szPath, DWORD cchPath)
{
    WCHAR szKey[MAX_PATH];
    DWORD cbSize;
    DWORD dwErr;

    PathCombineW(szKey, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList", pszUserSID);

    cbSize = cchPath * sizeof(WCHAR);
    dwErr = SHGetValue(HKEY_LOCAL_MACHINE, szKey, L"ProfileImagePath", NULL, szPath, &cbSize);

    return HRESULT_FROM_WIN32(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Method:     _CheckFolderType
//
//  Synopsis:   Check whether the target folder is contained in a
//              special folder, such as the user's profile.
//
//--------------------------------------------------------------------------

static const struct
{
    int csidl;
    BOOL bTestSubfolder;
    BOOL bUserSpecific;
    DWORD dwFlags;
    PCWSTR pszDefaultSD;    // needed if CFT_FLAG_CAN_MAKE_PRIVATE is on
} c_rgFolderInfo[] =
{
    // NOTE: Order is important here!
    {CSIDL_SYSTEM,                  TRUE,   FALSE,  CFT_FLAG_ALWAYS_SHARED | CFT_FLAG_SYSTEM_FOLDER,  NULL},
    {CSIDL_PROGRAM_FILES,           FALSE,  FALSE,  CFT_FLAG_ALWAYS_SHARED | CFT_FLAG_SYSTEM_FOLDER,  NULL},
    {CSIDL_COMMON_DOCUMENTS,        TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_COMMON_DESKTOPDIRECTORY, TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_COMMON_PICTURES,         TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_COMMON_MUSIC,            TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_COMMON_VIDEO,            TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_PROFILE,                 TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_DESKTOPDIRECTORY,        TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_PERSONAL,                TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_MYPICTURES,              TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_MYMUSIC,                 TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_MYVIDEO,                 TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_WINDOWS,                 TRUE,   FALSE,  CFT_FLAG_ALWAYS_SHARED | CFT_FLAG_SYSTEM_FOLDER,  NULL},
};
// Some of the folders above are normally contained within another, e.g. MyDocs
// inside Profile, but may be redirected elsewhere. In such cases, the child
// folder should be listed *after* the parent folder. This is important for
// correctly finding the point at which the protected ACL is set.
//
// Also, upgrades from previous OS's can leave profiles under CSIDL_WINDOWS.
// We don't allow sharing under CSIDL_WINDOWS, except we want to allow the user
// to share folders in their profile.  So leave CSIDL_WINDOWS last.


BOOL
_PathIsEqualOrSubFolder(
    PWSTR pszParent,
    PCWSTR pszSubFolder
    )
{
    WCHAR szCommon[MAX_PATH];

    //  PathCommonPrefix() always removes the slash on common
    return (pszParent[0] && PathRemoveBackslashW(pszParent)
            && PathCommonPrefixW(pszParent, pszSubFolder, szCommon)
            && lstrcmpiW(pszParent, szCommon) == 0);
}

DWORD
_CheckFolderType(
    PCWSTR pszFolder,
    PCWSTR pszUserSID,
    BOOL *pbFolderRoot,
    PCWSTR *ppszDefaultAcl
    )
{
    // Default is to allow sharing, unless there is a reason not to
    DWORD dwSharingFlags = CFT_FLAG_SHARING_ALLOWED;

    if (pbFolderRoot)
    {
        *pbFolderRoot = FALSE;
    }

    if (ppszDefaultAcl)
    {
        *ppszDefaultAcl = NULL;
    }

    // Note that we don't mess with UNC paths

    if (NULL == pszFolder       ||
        L'\0' == *pszFolder     ||
        PathIsUNC(pszFolder))
    {
        return CFT_FLAG_NO_SHARING;
    }

    //  We warn about sharing out the root folder of drives.
    if (PathIsRoot(pszFolder))
    {
        return CFT_FLAG_ROOT_FOLDER;
    }

    WCHAR szPath[MAX_PATH];
    BOOL bFolderRoot = FALSE;
    int i;
    HRESULT hr;

    if (NULL != pszUserSID)
    {
        LPWSTR pszCurrentSID = NULL;
        if (_GetUserSid(&pszCurrentSID))
        {
            appAssert(NULL != pszCurrentSID);
            if (0 == lstrcmpiW(pszUserSID, pszCurrentSID))
            {
                // Use NULL for current user to avoid E_NOTIMPL cases below
                pszUserSID = NULL;
            }
            LocalFree(pszCurrentSID);
        }
    }

    for (i = 0; i < ARRAYLEN(c_rgFolderInfo); i++)
    {
        // If the user is specified, need to check the correct profile
        if (c_rgFolderInfo[i].bUserSpecific && NULL != pszUserSID)
        {
            switch (c_rgFolderInfo[i].csidl)
            {
            case CSIDL_PROFILE:
                hr = _GetUserProfilePath(pszUserSID, szPath, ARRAYLEN(szPath));
                break;

            case CSIDL_DESKTOPDIRECTORY:
            case CSIDL_PERSONAL:
            case CSIDL_MYPICTURES:
            case CSIDL_MYMUSIC:
            case CSIDL_MYVIDEO:
            default:
                // Need to load the user's hive and read the shell folder
                // path from there.
                //
                // For now, we don't really need these, so just skip them.
                appAssert(FALSE);
                hr = E_NOTIMPL;
                break;
            }
        }
        else
        {
            hr = SHGetFolderPathW(NULL, c_rgFolderInfo[i].csidl | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath);
        }
        if (S_OK == hr)
        {
            bFolderRoot = (lstrcmpiW(szPath, pszFolder) == 0);
            if (bFolderRoot ||
                (c_rgFolderInfo[i].bTestSubfolder && _PathIsEqualOrSubFolder(szPath, pszFolder)))
            {
                if (bFolderRoot && ppszDefaultAcl)
                {
                    *ppszDefaultAcl = c_rgFolderInfo[i].pszDefaultSD;
                }
                dwSharingFlags = c_rgFolderInfo[i].dwFlags;
                break;
            }
        }
    }

    if (ARRAYLEN(c_rgFolderInfo) == i)
    {
        // Check for other profile dirs. If there were a CSIDL for this we
        // could just add it to the list above.
        DWORD cchPath = ARRAYLEN(szPath);
        if (GetProfilesDirectoryW(szPath, &cchPath))
        {
            bFolderRoot = (lstrcmpiW(szPath, pszFolder) == 0);
            if (bFolderRoot || _PathIsEqualOrSubFolder(szPath, pszFolder))
            {
                // No sharing
                dwSharingFlags = CFT_FLAG_NO_SHARING;
            }
        }
    }

    if (pbFolderRoot)
    {
        *pbFolderRoot = bFolderRoot;
    }

    return dwSharingFlags;
}


//+-------------------------------------------------------------------------
//
//  Method:     IsGuestEnabledForNetworkAccess
//
//  Synopsis:   Test whether the Guest account can be used for incoming
//              network connections.
//
//--------------------------------------------------------------------------

BOOL IsGuestEnabledForNetworkAccess()
{
    BOOL bResult = FALSE;
    ILocalMachine *pLM;

    if (SUCCEEDED(CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_ILocalMachine, (void**)&pLM)))
    {
        VARIANT_BOOL vbEnabled = VARIANT_FALSE;
        bResult = (SUCCEEDED(pLM->get_isGuestEnabled(ILM_GUEST_NETWORK_LOGON, &vbEnabled)) && VARIANT_TRUE == vbEnabled);
        pLM->Release();
    }

    return bResult;
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSimpleSharingPage::CSimpleSharingPage(
    IN PWSTR pszPath
    )
    :
    CShareBase(pszPath, FALSE),
    _bSharingEnabled(TRUE),
    _bShareNameChanged(FALSE),
    _bSecDescChanged(FALSE),
    _bIsPrivateVisible(FALSE),
    _bDriveRootBlockade(TRUE),
    _dwPermType(0),
    _pszInheritanceSource(NULL)
{
    INIT_SIG(CSimpleSharingPage);
}

CSimpleSharingPage::~CSimpleSharingPage()
{
    CHECK_SIG(CSimpleSharingPage);

    if (NULL != _pszInheritanceSource)
    {
        LocalFree(_pszInheritanceSource);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CSimpleSharingPage);

    switch (msg)
    {
    case WM_SETTINGCHANGE:
        // Reinitialize the dialog
        _InitializeControls(hwnd);
        break;
    }

    return CShareBase::_PageProc(hwnd, msg, wParam, lParam);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_OnInitDialog(
    IN HWND hwnd,
    IN HWND hwndFocus,
    IN LPARAM lInitParam
    )
{
    CHECK_SIG(CSimpleSharingPage);
    appDebugOut((DEB_ITRACE, "_OnInitDialog\n"));

    // use LanMan API constant to set maximum share name length
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);

    _InitializeControls(hwnd);

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CSimpleSharingPage);

    switch (wID)
    {
    case IDC_SHARE_SHAREDAS:
        if (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS))
        {
            _ReadControls(hwnd);
        }
        // Fall through...
    case IDC_SHARE_NOTSHARED:
        if (BN_CLICKED == wNotifyCode)
        {
            _SetControlsFromData(hwnd);
            _MarkPageDirty();
        }
        return TRUE;

    case IDC_SHARE_SHARENAME:
        if (EN_CHANGE == wNotifyCode && !_fInitializingPage)
        {
            _bShareNameChanged = TRUE;
            _MarkPageDirty();
        }
        return TRUE;

    case IDC_SHARE_PERMISSIONS:
        if (BN_CLICKED == wNotifyCode)
        {
            _bSecDescChanged = TRUE;
            _MarkPageDirty();
        }
        return TRUE;
    }

    return CShareBase::_OnCommand(hwnd, wNotifyCode, wID, hwndCtl);
}

BOOL
RunTheNetworkSharingWizard(
    HWND hwnd
    )
{
    HRESULT hr;
    IHomeNetworkWizard *pHNW;

    hr = CoCreateInstance( CLSID_HomeNetworkWizard, NULL, CLSCTX_INPROC_SERVER, IID_IHomeNetworkWizard, (void**)&pHNW );
    if (SUCCEEDED(hr))
    {
        BOOL bRebootRequired = FALSE;

        hr = pHNW->ShowWizard(hwnd, &bRebootRequired);
        if ( SUCCEEDED(hr) && bRebootRequired )
        {
            RestartDialogEx(hwnd, NULL, EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG);
        }

        pHNW->Release();
    }

    return (SUCCEEDED(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnPropertySheetNotify, private
//
//  Synopsis:   WM_NOTIFY handler
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_OnPropertySheetNotify(
    IN HWND hwnd,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CSimpleSharingPage);

    switch (phdr->code)
    {
    case NM_RETURN:
    case NM_CLICK:
        switch (phdr->idFrom)
        {
        case IDC_LNK_SHARE_PARENT_PROTECTED:
            {
                HWND hwndFrame = _GetFrameWindow();

                // Close the current propsheet
                PropSheet_PressButton(hwndFrame, PSBTN_CANCEL);

                appAssert(NULL != _pszInheritanceSource);

                // Show the sharing page for the ancestor folder
                WCHAR szCaption[50];
                LoadStringW(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
                SHObjectProperties(GetParent(hwndFrame), SHOP_FILEPATH, _pszInheritanceSource, szCaption);

            }
            return TRUE;

        case IDC_LNK_SHARE_NETWORK_WIZARD:
            appAssert(!_bSharingEnabled);
            if ( RunTheNetworkSharingWizard( hwnd ) )
            {
                // Reinitialize the dialog
                _InitializeControls(hwnd);
            }
            break;

        case IDC_LNK_SHARE_SECURITY_OVERRIDE:
            {
                UINT iRet = (UINT) DialogBox( g_hInstance, MAKEINTRESOURCE(IDD_SIMPLE_SHARE_ENABLE_WARNING), hwnd, WarningDlgProc );
                if ( IDC_RB_RUN_THE_WIZARD == iRet )
                {
                    appAssert(!_bSharingEnabled);
                    if ( RunTheNetworkSharingWizard( hwnd ) )
                    {
                        //
                        //  Now that we changed the "networking state," re-initialize the dialog
                        //  and update the control to the new state.
                        //

                        _InitializeControls(hwnd);
                    }
                }
                else if ( IDC_RB_ENABLE_FILE_SHARING == iRet )
                {
                    ILocalMachine *pLM;
                    HRESULT hr = CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_ILocalMachine, (void**)&pLM);
                    if (SUCCEEDED(hr))
                    {
                        hr = pLM->EnableGuest(ILM_GUEST_NETWORK_LOGON);
                        pLM->Release();

                        SendNotifyMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);
                    }

                    //
                    //  Now that we changed the "networking state," re-initialize the dialog
                    //  and update the control to the new state.
                    //

                    _InitializeControls(hwnd);
                }
            }
            break;

        case IDC_LNK_SHARE_DRIVE_BLOCADE:
            if (_bDriveRootBlockade)
            {
                //  Unhide the other controls
                for (ULONG idx = 0; idx < ARRAYLEN(g_rgHideTheseControlsOnDriveBlockade); idx ++ )
                {
                    ShowWindow(GetDlgItem(hwnd, g_rgHideTheseControlsOnDriveBlockade[idx]), SW_SHOW);
                }
                _bDriveRootBlockade = FALSE;
                _InitializeControls( hwnd );
            }
            return TRUE;

        case IDC_LNK_SHARE_OPEN_SHARED_DOCS:
            {
                WCHAR szPath[MAX_PATH];

                BOOL b = SHGetSpecialFolderPath(NULL, szPath, CSIDL_COMMON_DOCUMENTS, TRUE);
                if (b)
                {
                    DWORD_PTR dwRet = (DWORD_PTR) ShellExecute(hwnd, L"Open", szPath, NULL, NULL, SW_SHOW);
                    if ( 32 < dwRet )
                    {
                        HWND hwndFrame = _GetFrameWindow();

                        // Close the current propsheet
                        PropSheet_PressButton(hwndFrame, PSBTN_CANCEL);
                    }
                }
            }
            return TRUE;

        case IDC_LNK_SHARE_HELP_SHARING_AND_SECURITY:
            {
                WCHAR szPath[MAX_PATH];
                HWND hwndFrame = _GetFrameWindow();

                if (IsOS(OS_PERSONAL))
                {
                    LoadString(g_hInstance, IDS_SHARE_HELP_SHARING_AND_SECURITY_PER, szPath, ARRAYLEN(szPath));
                }
                else
                {
                    LoadString(g_hInstance, IDS_SHARE_HELP_SHARING_AND_SECURITY_WKS, szPath, ARRAYLEN(szPath));
                }
                ShellExecute(hwndFrame, NULL, szPath, NULL, NULL, SW_NORMAL);
            }
            break;

        }
        break;

    default:
        break;
    }

    return CShareBase::_OnPropertySheetNotify(hwnd, phdr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnHelp, private
//
//  Synopsis:   WM_HELP handler
//
//--------------------------------------------------------------------------

static const DWORD aHelpIds[] =
{
    IDC_SHARE_SHARENAME,        IDH_SHARE2_ShareName,
    IDC_SHARE_SHARENAME_TEXT,   IDH_SHARE2_ShareName,
    IDC_SHARE_NOTSHARED,        IDH_SHARE2_MakePrivate,
    IDC_SHARE_SHAREDAS,         IDH_SHARE2_ShareOnNet,
    IDC_SHARE_PERMISSIONS,      IDH_SHARE2_ReadOnly,
    IDC_LNK_SHARE_DRIVE_BLOCADE,    -1,  // no help
    0,0
};

BOOL
CSimpleSharingPage::_OnHelp(
    IN HWND hwnd,
    IN LPHELPINFO lphi
    )
{
    CHECK_SIG(CSimpleSharingPage);

    if (lphi->iContextType == HELPINFO_WINDOW)  // a control
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_SIMPLE_SHARE_HELPFILE, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)lphi->hItemHandle,
            szHelp,
            HELP_WM_HELP,
            (DWORD_PTR)aHelpIds);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnContextMenu, private
//
//  Synopsis:   WM_CONTEXTMENU handler
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_OnContextMenu(
    IN HWND hwnd,
    IN HWND hwndCtl,
    IN int xPos,
    IN int yPos
    )
{
    CHECK_SIG(CSimpleSharingPage);

    WCHAR szHelp[50];
    LoadString(g_hInstance, IDS_SIMPLE_SHARE_HELPFILE, szHelp, ARRAYLEN(szHelp));
    WinHelp(
        hwndCtl,
        szHelp,
        HELP_CONTEXTMENU,
        (DWORD_PTR)aHelpIds);

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_InitializeControls, private
//
//  Synopsis:   Initialize the controls from scratch
//
//--------------------------------------------------------------------------

VOID
CSimpleSharingPage::_InitializeControls(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    _fInitializingPage++;

    _dwPermType = IFPFU_NOT_NTFS;
    _bIsPrivateVisible = FALSE;
    if (NULL != _pszInheritanceSource)
    {
        LocalFree(_pszInheritanceSource);
        _pszInheritanceSource = NULL;
    }

    // Check whether to show the "Make Private" stuff
    DWORD dwFolderFlags = _CheckFolderType(_pszPath, NULL, NULL, NULL);
    if (dwFolderFlags & CFT_FLAG_CAN_MAKE_PRIVATE)
    {
        _dwPermType = IFPFU_NOT_PRIVATE;

        LPWSTR pszSID = NULL;
        if (_GetUserSid(&pszSID))
        {
            appAssert(NULL != pszSID);
            IsFolderPrivateForUser(_pszPath, pszSID, &_dwPermType, &_pszInheritanceSource);
            LocalFree(pszSID);
        }

        if ((_dwPermType & IFPFU_NOT_NTFS) == 0)
        {
            _bIsPrivateVisible = TRUE;
        }
    }
    CheckDlgButton(hwnd, IDC_SHARE_NOTSHARED, (_bIsPrivateVisible && (_dwPermType & IFPFU_PRIVATE) != 0) ? BST_CHECKED : BST_UNCHECKED);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_NOTSHARED), _bIsPrivateVisible);

    BOOL bIsFolderNetworkShared = FALSE;

    if ( g_fSharingEnabled )
    {
        // Is there a net share?
        if (_cShares > 0)
        {
            // It's shared, but check for hidden (admin$) shares and
            // ignore them by removing them from the list.

            appAssert(_bNewShare == FALSE);

            for (CShareInfo* p = (CShareInfo*)_pInfoList->Next();
                 p != _pInfoList && _cShares > 0;
                 )
            {
                CShareInfo* pNext = (CShareInfo*)p->Next();

                if (STYPE_SPECIAL & p->GetType())
                {
                    // remove p from the list
                    p->Unlink();
                    delete p;
                    _cShares--;
                }

                p = pNext;
            }
            if (_cShares == 0)
            {
                // No shares left, so construct an element to be used
                // by the UI to stash the new share's data.
                _ConstructNewShareInfo();
            }
        }

        // Now is it shared?
        if (_cShares > 0)
        {
            CheckDlgButton(hwnd, IDC_SHARE_SHAREDAS, BST_CHECKED);
            bIsFolderNetworkShared = TRUE;
        }
        else
        {
            SetDlgItemText(hwnd, IDC_SHARE_SHARENAME,   L"");
            CheckDlgButton(hwnd, IDC_SHARE_SHAREDAS, BST_UNCHECKED);
        }
    }

    //
    // The Simple Sharing page (shrpage2.cxx) assumes ForceGuest
    // mode is in effect for incoming network access. This mode uses
    // the Guest account for all network connections.
    //
    // Out of the box, the Guest account is disabled, effectively
    // disabling network sharing.  The Home Networking Wizard is
    // used to enable network sharing (and the Guest account).
    //
    // So we test whether the Guest account is enabled for network
    // logon to determine whether to enable the sharing UI. If
    // network sharing is disabled, we disable the UI and offer
    // to launch the Home Networking Wizard.
    //
    // Note that it is possible for a net share to exist even though
    // the Guest account is disabled.
    //
    _bSharingEnabled = IsGuestEnabledForNetworkAccess();

    BOOL bShowPrivateWarning = (_bIsPrivateVisible && (_dwPermType & IFPFU_PRIVATE_INHERITED));
    BOOL bInheritanceSource  = (NULL == _pszInheritanceSource);
    BOOL bIsRootFolder       = (dwFolderFlags & CFT_FLAG_ROOT_FOLDER);
    BOOL bIsSystemFolder     = (dwFolderFlags & CFT_FLAG_SYSTEM_FOLDER);
    BOOL bIsInSharedFolder   = (dwFolderFlags & CFT_FLAG_ALWAYS_SHARED);

    // see if the path is the root of a drive. if so, put up the blockade.
    if (_bDriveRootBlockade && bIsRootFolder && !bIsFolderNetworkShared)
    {
        _MyShow(hwnd, IDC_LNK_SHARE_DRIVE_BLOCADE, TRUE);

        //  Hide all the other controls when the blockade is up.
        for (ULONG idx = 0; idx < ARRAYLEN(g_rgHideTheseControlsOnDriveBlockade); idx ++ )
        {
            ShowWindow(GetDlgItem(hwnd, g_rgHideTheseControlsOnDriveBlockade[idx]), SW_HIDE);
        }
    }
    else
    {
        BOOL bShowInfoIcon          = FALSE;
        BOOL bShowNetworkWizard     = FALSE;
        BOOL bShowParentProteced    = FALSE;
        BOOL bShowSystemFolder      = FALSE;

        //  Hide the blockade
        _MyShow(hwnd, IDC_LNK_SHARE_DRIVE_BLOCADE, FALSE );

        //  Turn on the "special info" as nessecary.
        if (bIsSystemFolder)
        {
            _bSharingEnabled = FALSE;
            bShowSystemFolder = TRUE;
            bShowInfoIcon = TRUE;
        }
        else if (bShowPrivateWarning && !bInheritanceSource)
        {
            bShowParentProteced = TRUE;
            bShowInfoIcon = TRUE;
        }
        else if (!bShowPrivateWarning && !_bSharingEnabled && g_fSharingEnabled)
        {
            bShowNetworkWizard = TRUE;
        }

        _MyShow(hwnd, IDC_LNK_SHARE_PARENT_PROTECTED    , bShowParentProteced);
        _MyShow(hwnd, IDC_LNK_SHARE_NETWORK_WIZARD      , bShowNetworkWizard);
        _MyShow(hwnd, IDC_LNK_SHARE_SECURITY_OVERRIDE   , bShowNetworkWizard);
        _MyShow(hwnd, IDC_SIMPLE_SHARE_NETWORKING_STATIC, !bShowNetworkWizard);
        _MyShow(hwnd, IDC_SHARE_SHAREDAS                , !bShowNetworkWizard);
        _MyShow(hwnd, IDC_SHARE_SHARENAME_TEXT          , !bShowNetworkWizard);
        _MyShow(hwnd, IDC_SHARE_PERMISSIONS             , !bShowNetworkWizard);
        _MyShow(hwnd, IDC_S_SHARE_SYSTEM_FOLDER         , bShowSystemFolder);
        _MyShow(hwnd, IDC_I_SHARE_INFORMATION           , bShowInfoIcon);
    }

    _SetControlsFromData(hwnd);

    _fInitializingPage--;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::SetControlsFromData, private
//
//  Synopsis:   From the class variables and current state of the radio
//              buttons, set the enabled/disabled state of the buttons, as
//              well as filling the controls with the appropriate values.
//
//--------------------------------------------------------------------------

VOID
CSimpleSharingPage::_SetControlsFromData(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    _fInitializingPage++;

    BOOL bIsPrivate = (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_NOTSHARED));
    BOOL bIsShared = (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS));

    // We don't allow both to be checked at the same time
    appAssert(!(bIsPrivate && bIsShared));

    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_NOTSHARED), !bIsShared && _bIsPrivateVisible && !(_dwPermType & IFPFU_PRIVATE_INHERITED));
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_SHAREDAS),       _bSharingEnabled && !bIsPrivate);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_SHARENAME_TEXT), _bSharingEnabled && bIsShared);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_SHARENAME),      _bSharingEnabled && bIsShared);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_PERMISSIONS),    _bSharingEnabled && bIsShared);

    if (bIsShared)
    {
        appDebugOut((DEB_ITRACE, "_SetControlsFromData: path is shared\n"));

        _pCurInfo = (CShareInfo*)_pInfoList->Next();
        if (NULL != _pCurInfo)
        {
            SetDlgItemText(hwnd, IDC_SHARE_SHARENAME, _pCurInfo->GetNetname());

            // If the share really exists, then make the name read-only.
            // This corresponds to the non-editable combo-box on the full
            // sharing page.
            SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_SETREADONLY, (_cShares > 0), 0);

            CheckDlgButton(hwnd, IDC_SHARE_PERMISSIONS, _IsReadonlyShare(_pCurInfo) ? BST_UNCHECKED : BST_CHECKED);
        }
        else
        {
            CheckDlgButton(hwnd, IDC_SHARE_SHAREDAS, BST_UNCHECKED );
        }
    }
    else
    {
        appDebugOut((DEB_ITRACE, "_SetControlsFromData: path is not shared\n"));
        _pCurInfo = NULL;
    }

    _fInitializingPage--;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_ReadControls, private
//
//  Synopsis:   Load the data in the controls into internal data structures.
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_ReadControls(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    if (_bShareNameChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: share name changed\n"));
        if (NULL != _pCurInfo)
        {
            WCHAR szShareName[NNLEN + 1];
            GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
            TrimLeadingAndTrailingSpaces(szShareName);
            _pCurInfo->SetNetname(szShareName);
            _bShareNameChanged = FALSE;
        }
        else
        {
            appDebugOut((DEB_ITRACE, "_ReadControls: _pCurInfo is NULL\n"));
        }
    }

    if (_bSecDescChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: permissions changed\n"));
        if(NULL != _pCurInfo)
        {
            PSECURITY_DESCRIPTOR pSD;
            BOOL bIsReadonly = (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_PERMISSIONS));

            if (ConvertStringSecurityDescriptorToSecurityDescriptorW(
                    bIsReadonly ? c_szReadonlyShareSD : c_szFullShareSD,
                    SDDL_REVISION_1,
                    &pSD,
                    NULL))
            {
                appAssert(IsValidSecurityDescriptor(pSD));

                // _pCurInfo takes ownership of pSD; no need to free on success
                if (FAILED(_pCurInfo->TransferSecurityDescriptor(pSD)))
                {
                    LocalFree(pSD);
                }
            }

            _bSecDescChanged = FALSE;
        }
        else
        {
            appDebugOut((DEB_ITRACE, "_ReadControls: _pCurInfo is NULL\n"));
        }
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_ValidatePage, private
//
//  Synopsis:   Return TRUE if the current page is valid
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_ValidatePage(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    _ReadControls(hwnd);    // read current stuff

    if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS))
    {
        // If the user is creating a share on the property sheet (as
        // opposed to using the "new share" dialog), we must validate the
        // share.... Note that _bNewShare is still TRUE if the the user has
        // clicked on "Not Shared", so we must check that too.

        // Validate the share

        if (!_ValidateNewShareName())
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }
    }

#if DBG == 1
    Dump(L"_ValidatePage finished");
#endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_DoApply, private
//
//  Synopsis:   If anything has changed, apply the data
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_DoApply(
    IN HWND hwnd,
    IN BOOL bClose
    )
{
    CHECK_SIG(CSimpleSharingPage);

    if (_bDirty)
    {
        HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

        BOOL bIsShared = (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS));

        if (bIsShared)
        {
            _ReadControls(hwnd);

            //
            // NTRAID#NTBUG9-382492-2001/05/05-jeffreys
            //
            // Win9x boxes can't see the share if the name is longer than LM20_NNLEN
            //
            if (NULL != _pCurInfo)
            {
                if (_pCurInfo->GetFlag() == SHARE_FLAG_ADDED)
                {
                    PCWSTR pszName = _pCurInfo->GetNetname();
                    if (NULL != pszName &&
                        wcslen(pszName) > LM20_NNLEN &&
                        IDNO == MyConfirmationDialog(hwnd, MSG_LONGNAMECONFIRM, MB_YESNO | MB_ICONWARNING, pszName))
                    {
                        return FALSE;
                    }
                }
            }
        }

        _CommitShares(!bIsShared);

        if (_bDirty)
        {
            DWORD dwLevel;
            BOOL bIsPrivate = (_bIsPrivateVisible && BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_NOTSHARED));

            appAssert(!(bIsShared && bIsPrivate));

            if (bIsPrivate)
            {
                // Private to the current user
                dwLevel = 0;
            }
            else if (!bIsShared)
            {
                // Default ACL (neither private nor shared)
                dwLevel = 1;
            }
            else if (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_PERMISSIONS))
            {
                // Read-only share
                dwLevel = 2;
            }
            else
            {
                // Read-write share
                dwLevel = 3;
            }

            _SetFolderPermissions(dwLevel);
        }

        CShareBase::_DoApply(hwnd, bClose);

        if (!bClose)
        {
            _InitializeControls(hwnd);
        }

        SetCursor(hcur);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_DoCancel, private
//
//  Synopsis:   Do whatever is necessary to cancel the changes
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_DoCancel(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    if (_bDirty)
    {
        _bShareNameChanged = FALSE;
    }

    return CShareBase::_DoCancel(hwnd);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_SetFolderPermissions, private
//
//  Synopsis:   Set new permissions on the subtree, either restricting
//              access to the current user or making the folder accessible
//              to everyone.
//
//--------------------------------------------------------------------------

typedef struct _SET_PERM_THREAD_DATA
{
    DWORD dwLevel;
    HWND hwndOwner;
    WCHAR szPath[1];
} SET_PERM_THREAD_DATA;

DWORD WINAPI _SetFolderPermissionsThread(LPVOID pv)
{
    DWORD dwError = ERROR_INVALID_DATA;
    SET_PERM_THREAD_DATA *ptd = (SET_PERM_THREAD_DATA*)pv;
    if (ptd)
    {
        dwError = ERROR_SUCCESS;
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
        if (!SetFolderPermissionsForSharing(ptd->szPath, NULL, ptd->dwLevel, ptd->hwndOwner))
        {
            dwError = GetLastError();
        }
        LocalFree(ptd);
    }
    FreeLibraryAndExitThread(g_hInstance, dwError);
    return 0;
}

BOOL
CSimpleSharingPage::_SetFolderPermissions(
    IN DWORD dwLevel
    )
{
    CHECK_SIG(CSimpleSharingPage);

    BOOL bResult = FALSE;

    IActionProgressDialog *papd = NULL;
    IActionProgress *pap = NULL;

    // Show progress UI so the user understands that we're doing a lengthy
    // operation, even though there's no way to cancel SetNamedSecurityInfo
    // or get progress from it.  This requires us to call SetNamedSecurityInfo
    // on a different thread.
    //
    // Also, if the user cancels the progress dialog, we'll release the UI
    // thread even though we can't stop the SetNamedSecurityInfo call.  Just
    // abandon the thread and let it run.
    //
    // This can lead to weird results when toggling the "Make private" checkbox
    // on a large subtree:
    // 1. toggle "Make private" and click Apply
    // 2. cancel the progress UI
    // 3. the "Make private" checkbox reverts to the previous state
    // 4. Cancel the property sheet and reopen after the disk stops grinding
    // 5. the "Make private" checkbox shows the new state
    // Apparently, SetNamedSecurityInfo sets folder security in post-order, so
    // the top folder doesn't get the new permissions until then end.
    //
    // Hopefully, this is rare enough that we don't need to do anything about it.

    HRESULT hr = CoCreateInstance(CLSID_ProgressDialog,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IActionProgressDialog,
                                  (void**)&papd);
    if (SUCCEEDED(hr))
    {
        WCHAR szTitle[64];

        IUnknown_SetSite(papd, this); // needed for modality

        LoadStringW(g_hInstance, IDS_PERM_PROGRESS_TITLE, szTitle, ARRAYLEN(szTitle));

        hr = papd->Initialize(SPINITF_MODAL | SPINITF_NOMINIMIZE, szTitle, NULL);
        if (SUCCEEDED(hr))
        {
            hr = papd->QueryInterface(IID_IActionProgress, (void**)&pap);
            if (SUCCEEDED(hr))
            {
                hr = pap->Begin(SPACTION_APPLYINGATTRIBS, SPBEGINF_MARQUEEPROGRESS);
            }
        }
    }

    // Kick off a thread to do the grunge work

    SET_PERM_THREAD_DATA *ptd = (SET_PERM_THREAD_DATA*)LocalAlloc(LPTR, sizeof(SET_PERM_THREAD_DATA) + wcslen(_pszPath)*sizeof(WCHAR));
    if (NULL != ptd)
    {
        DWORD dwT;

        // It is possible to make a folder private with net sharing disabled.
        // It is also possible that net sharing was previously enabled and net
        // shares may still exist. Let's not confuse the user with a warning
        // about deleting net shares on child folders if we happen to have this
        // rare combination.  That is, pass NULL for the HWND when sharing is
        // disabled.

        ptd->dwLevel = dwLevel;
        ptd->hwndOwner = _bSharingEnabled ? _hwndPage : NULL;
        wcscpy(ptd->szPath, _pszPath);

        LoadLibraryW(L"ntshrui.dll");

        HANDLE hThread = CreateThread(NULL, 0, _SetFolderPermissionsThread, ptd, 0, &dwT);
        if (NULL == hThread)
        {
            // CreateThread failed? Do it synchronously
            bResult = SetFolderPermissionsForSharing(ptd->szPath, NULL, ptd->dwLevel, ptd->hwndOwner);
            LocalFree(ptd);
            FreeLibrary(g_hInstance);
        }
        else
        {
            // Poll for cancel every 1/2 second
            dwT = pap ? 500 : INFINITE;
            while (WAIT_TIMEOUT == WaitForSingleObject(hThread, dwT))
            {
                BOOL bCancelled;
                hr = pap->QueryCancel(&bCancelled);

                // QueryCancel pumps messages, which somehow resets
                // the cursor to normal. (_DoApply sets the hourglass)
                SetCursor(LoadCursor(NULL, IDC_WAIT));

                if (SUCCEEDED(hr) && bCancelled)
                {
                    // Abandon the worker thread
                    break;
                }
            }

            // Check the result

            bResult = TRUE;
            dwT = ERROR_SUCCESS;
            GetExitCodeThread(hThread, &dwT);

            // If the exit code is STILL_ACTIVE, assume success.
            // (failure tends to happen quickly -- access denied, etc.)
            if (STILL_ACTIVE == dwT)
            {
                dwT = ERROR_SUCCESS;
            }

            if (ERROR_SUCCESS != dwT)
            {
                SetLastError(dwT);
                bResult = FALSE;
            }

            CloseHandle(hThread);
        }
    }

    if (pap)
    {
        pap->End();
        pap->Release();
    }

    if (papd)
    {
        papd->Stop();
        papd->Release();
    }

    // If we just made the folder private, check whether the user has
    // a password. If not, offer to launch the User Accounts CPL.

    if (bResult && 0 == dwLevel && !_UserHasPassword())
    {
        WCHAR szMsg[MAX_PATH];
        WCHAR szCaption[50];
        LoadStringW(g_hInstance, IDS_PRIVATE_CREATE_PASSWORD, szMsg, ARRAYLEN(szMsg));
        LoadStringW(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));

        if (IDYES == MessageBoxW(_hwndPage, szMsg, szCaption, MB_YESNO | MB_ICONWARNING))
        {
            // Launch the User Accounts CPL to the password page
            SHELLEXECUTEINFO sei = {0};
            sei.cbSize = sizeof(SHELLEXECUTEINFO);
            sei.fMask = SEE_MASK_DOENVSUBST;
            sei.hwnd = _hwndPage;
            sei.nShow = SW_SHOWNORMAL;
            sei.lpFile = TEXT("%SystemRoot%\\system32\\rundll32.exe");
            sei.lpParameters = TEXT("shell32,Control_RunDLL nusrmgr.cpl ,initialTask=ChangePassword");
            sei.lpDirectory = TEXT("%SystemRoot%\\system32");
            ShellExecuteEx(&sei);
        }
    }

    return bResult;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_IsReadonlyShare, private
//
//  Synopsis:   Test whether the share ACL grants more than read access to
//              Everyone or Guest.
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_IsReadonlyShare(
    IN CShareInfo *pShareInfo
    )
{
    CHECK_SIG(CSimpleSharingPage);

    BOOL bReadonly = TRUE;

    // Get the current share ACL and check for read-only
    PSECURITY_DESCRIPTOR pSD = pShareInfo->GetSecurityDescriptor();
    if (NULL == pSD)
    {
        // Default security allows anyone to connect with Full Control
        bReadonly = FALSE;
    }
    else
    {
        PACL pDacl;
        BOOL bPresent;
        BOOL bDefault;

        if (GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefault) && NULL != pDacl)
        {
            TRUSTEE tEveryone;
            TRUSTEE tGuests;
            ACCESS_MASK dwAllMask = 0;
            ACCESS_MASK dwGuestMask = 0;

            // The masks are all initialized to zero. If one or more of the
            // calls to GetEffectiveRightsFromAcl fails, then it will look like
            // that trustee has no rights and the UI will adjust accordingly.
            // There is nothing we could do better by trapping errors from
            // GetEffectiveRightsFromAcl, so don't bother.

            BuildTrusteeWithSid(&tEveryone, (PSID)&g_WorldSid);
            tEveryone.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            GetEffectiveRightsFromAcl(pDacl, &tEveryone, &dwAllMask);

            BuildTrusteeWithSid(&tGuests, (PSID)&g_GuestsSid);
            tGuests.TrusteeType = TRUSTEE_IS_ALIAS;
            GetEffectiveRightsFromAcl(pDacl, &tGuests, &dwGuestMask);

            if ((dwAllMask & ~(FILE_GENERIC_READ | FILE_GENERIC_EXECUTE)) != 0
                || (dwGuestMask & ~(FILE_GENERIC_READ | FILE_GENERIC_EXECUTE)) != 0)
            {
                bReadonly = FALSE;
            }
        }
        else
        {
            // NULL DACL means no security
            bReadonly = FALSE;
        }
    }

    return bReadonly;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_UserHasPassword, private
//
//  Synopsis:   Test whether the current user has a non-blank password.
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_UserHasPassword(
    VOID
    )
{
    CHECK_SIG(CSimpleSharingPage);

    // If anything fails, we assume the user has a password
    BOOL bHasPassword = TRUE;
    ILogonEnumUsers *pEnumUsers;

    HRESULT hr = CoCreateInstance(
        CLSID_ShellLogonEnumUsers,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ILogonEnumUsers,
        (void**)&pEnumUsers);

    if (SUCCEEDED(hr))
    {
        ILogonUser *pUser;

        // Currently, this function always returns S_OK, so need to check NULL
        hr = pEnumUsers->get_currentUser(&pUser);
        if (SUCCEEDED(hr) && NULL != pUser)
        {
            VARIANT_BOOL vb = VARIANT_TRUE;

            hr = pUser->get_passwordRequired(&vb);
            if (SUCCEEDED(hr))
            {
                if (VARIANT_FALSE == vb)
                {
                    bHasPassword = FALSE;
                }
            }

            pUser->Release();
        }
        pEnumUsers->Release();
    }

    return bHasPassword;
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::Dump, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CSimpleSharingPage::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CSimpleSharingPage);

    appDebugOut((DEB_TRACE,
        "CSimpleSharingPage::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t            This: 0x%08lx\n"
"\t            Path: %ws\n"
"\t            Page: 0x%08lx\n"
"\t   Initializing?: %ws\n"
"\t          Dirty?: %ws\n"
"\t  Share changed?: %ws\n"
"\tPrivate visible?: %ws\n"
"\t     _dwPermType: 0x%08lx\n"
"\t      _pInfoList: 0x%08lx\n"
"\t       _pCurInfo: 0x%08lx\n"
"\t          Shares: %d\n"
,
this,
_pszPath,
_hwndPage,
_fInitializingPage ? L"yes" : L"no",
_bDirty ? L"yes" : L"no",
_bShareNameChanged ? L"yes" : L"no",
_bIsPrivateVisible ? L"yes" : L"no",
_dwPermType,
_pInfoList,
_pCurInfo,
_cShares
));

    CShareInfo* p;

    for (p = (CShareInfo*) _pInfoList->Next();
         p != _pInfoList;
         p = (CShareInfo*) p->Next())
    {
        p->Dump(L"Prop page list");
    }

    for (p = (CShareInfo*) _pReplaceList->Next();
         p != _pReplaceList;
         p = (CShareInfo*) p->Next())
    {
        p->Dump(L"Replace list");
    }
}

#endif // DBG == 1


//+-------------------------------------------------------------------------
//
//  Method:     _IsDaclPrivateForUser
//
//  Synopsis:   See whether the DACL grants Full Control to the user
//              and locks everyone else out
//
//--------------------------------------------------------------------------

BOOL WINAPI
_IsDaclPrivateForUser(
    IN     PACL   pDacl,
    IN     PCWSTR pszUserSID
    )
{
    BOOL bResult = FALSE;

    static const struct
    {
        PSID psid;
        TRUSTEE_TYPE type;
    } rgTrustees[] =
    {
        {(PSID)&g_WorldSid,     TRUSTEE_IS_WELL_KNOWN_GROUP},
        {(PSID)&g_AdminsSid,    TRUSTEE_IS_ALIAS},
        {(PSID)&g_PowerUSid,    TRUSTEE_IS_ALIAS},
        {(PSID)&g_UsersSid,     TRUSTEE_IS_ALIAS},
    };

    if (pDacl)
    {
        PSID psidUser = NULL;
        TRUSTEE tTemp;
        ACCESS_MASK dwUserMask = 0;

        // The masks are all initialized to zero. If one or more of the
        // calls to GetEffectiveRightsFromAcl fails, then it will look like
        // that trustee has no rights and the UI will adjust accordingly.
        // There is nothing we could do better by trapping errors from
        // GetEffectiveRightsFromAcl, so don't bother.

        if (ConvertStringSidToSid(pszUserSID, &psidUser))
        {
            BuildTrusteeWithSid(&tTemp, psidUser);
            tTemp.TrusteeType = TRUSTEE_IS_USER;
            GetEffectiveRightsFromAcl(pDacl, &tTemp, &dwUserMask);
            LocalFree(psidUser);
        }

        //
        // These tests may need some fine tuning
        //
        if ((dwUserMask & FILE_ALL_ACCESS) == FILE_ALL_ACCESS)
        {
            ACCESS_MASK dwOtherMask = 0;
            UINT i;

            for (i = 0; i < ARRAYLEN(rgTrustees); i++)
            {
                ACCESS_MASK dwTempMask = 0;
                BuildTrusteeWithSid(&tTemp, rgTrustees[i].psid);
                tTemp.TrusteeType = rgTrustees[i].type;
                GetEffectiveRightsFromAcl(pDacl, &tTemp, &dwTempMask);
                dwOtherMask |= dwTempMask;
            }

            if ((dwOtherMask & ~(READ_CONTROL | SYNCHRONIZE)) == 0)
            {
                // Looks like the folder is private for this user
                bResult = TRUE;
            }
        }
    }

    return bResult;
}


BOOL _IsVolumeNTFS(PCWSTR pszFolder)
{
    WCHAR szVolume[MAX_PATH];
    DWORD dwFSFlags = 0;

    return (GetVolumePathNameW(pszFolder, szVolume, ARRAYLEN(szVolume)) &&
            GetVolumeInformationW(szVolume, NULL, 0, NULL, NULL, &dwFSFlags, NULL, 0) &&
            0 != (FS_PERSISTENT_ACLS & dwFSFlags));
}

//+-------------------------------------------------------------------------
//
//  Method:     IsFolderPrivateForUser, exported
//
//  Synopsis:   Check the DACL on a folder
//
//--------------------------------------------------------------------------

BOOL WINAPI
IsFolderPrivateForUser(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    OUT    PDWORD pdwPrivateType,
    OUT    PWSTR* ppszInheritanceSource
    )
{
    if (NULL != ppszInheritanceSource)
    {
        *ppszInheritanceSource = NULL;
    }

    if (NULL == pdwPrivateType)
    {
        return FALSE;
    }

    *pdwPrivateType = IFPFU_NOT_PRIVATE;

    if (NULL == pszFolderPath || NULL == pszUserSID)
    {
        return FALSE;
    }

    // One would think that we could call GetNamedSecurityInfo without first
    // checking for NTFS, and just let it fail on FAT volumes. However,
    // GetNamedSecurityInfo succeeds on FAT and returns a valid security
    // descriptor with a NULL DACL.  This is actually correct in that
    // a NULL DACL means no security, which is true on FAT.
    //
    // We then have the problem of trying to differentiate between a NULL
    // DACL on an NTFS volume (it can happen), and a NULL DACL from a FAT
    // volume.  Let's just check for NTFS first.

    if (!_IsVolumeNTFS(pszFolderPath))
    {
        // No ACLs, so we're done
        *pdwPrivateType = IFPFU_NOT_NTFS;
        return TRUE;
    }

    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pDacl = NULL;
    DWORD dwErr = GetNamedSecurityInfoW(
        (PWSTR)pszFolderPath,
        SE_FILE_OBJECT,
        DACL_SECURITY_INFORMATION,
        NULL,
        NULL,
        &pDacl,
        NULL,
        &pSD);

    if (ERROR_SUCCESS == dwErr)
    {
        appAssert(NULL != pSD);

        if (_IsDaclPrivateForUser(pDacl, pszUserSID))
        {
            SECURITY_DESCRIPTOR_CONTROL wControl = 0;
            DWORD dwRevision;

            *pdwPrivateType = IFPFU_PRIVATE;

            // Check the control bits to see if we are inheriting
            GetSecurityDescriptorControl(pSD, &wControl, &dwRevision);

            if ((wControl & SE_DACL_PROTECTED) == 0)
            {
                // The DACL is not protected; assume the rights are inherited.
                //
                // When making a folder private, we always protect the DACL
                // on the folder and reset child ACLs, so the assumption
                // about inheriting is correct when using the simple UI.
                //
                // If someone uses the old Security page or cacls.exe to
                // modify ACLs, then the safest thing is to disable the
                // page and only let them reset everything from higher up.
                // Well, it turns out that that's exactly what happens when
                // we set IFPFU_PRIVATE_INHERITED.

                *pdwPrivateType |= IFPFU_PRIVATE_INHERITED;

                // Does the caller want the ancestor that made this
                // subtree private?
                if (NULL != ppszInheritanceSource)
                {
                    PINHERITED_FROMW pInheritedFrom = (PINHERITED_FROMW)LocalAlloc(LPTR, sizeof(INHERITED_FROMW)*pDacl->AceCount);

                    if (pInheritedFrom != NULL)
                    {
                        dwErr = GetInheritanceSourceW(
                            (PWSTR)pszFolderPath,
                            SE_FILE_OBJECT,
                            DACL_SECURITY_INFORMATION,
                            TRUE,
                            NULL,
                            0,
                            pDacl,
                            NULL,
                            &ShareMap,
                            pInheritedFrom);

                        if (ERROR_SUCCESS == dwErr)
                        {
                            PACE_HEADER pAceHeader;
                            UINT i;

                            PSID psidUser = NULL;
                            if (ConvertStringSidToSid(pszUserSID, &psidUser))
                            {
                                // Enumerate the ACEs looking for the ACE that grants
                                // Full Control to the current user

                                for (i = 0, pAceHeader = (PACE_HEADER)FirstAce(pDacl);
                                     i < pDacl->AceCount;
                                     i++,   pAceHeader = (PACE_HEADER)NextAce(pAceHeader))
                                {
                                    PKNOWN_ACE pAce = (PKNOWN_ACE)pAceHeader;
                                    if (IsKnownAceType(pAceHeader) &&
                                        EqualSid(psidUser, &pAce->SidStart) &&
                                        (pAce->Mask & FILE_ALL_ACCESS) == FILE_ALL_ACCESS)
                                    {
                                        // Found it. But we only want the inheritance
                                        // source if it's not explicit.
                                        if (pInheritedFrom[i].GenerationGap > 0)
                                        {
                                            *ppszInheritanceSource = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*wcslen(pInheritedFrom[i].AncestorName) + sizeof(L'\0'));
                                            if (NULL != *ppszInheritanceSource)
                                            {
                                                wcscpy(*ppszInheritanceSource, pInheritedFrom[i].AncestorName);
                                            }
                                        }

                                        // Stop looking
                                        break;
                                    }
                                }
                                LocalFree(psidUser);
                            }
                        }

                        LocalFree(pInheritedFrom);
                    }
                }
            }
        }

        LocalFree(pSD);
    }
    else
    {
        // GetNamedSecurityInfo failed.  The path may not exist, or it may
        // be FAT. In any case, assume permissions are not available.
        *pdwPrivateType = IFPFU_NOT_NTFS;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     _MakeSecurityDescriptorForUser
//
//  Synopsis:   Insert a SID string into a string SD and convert it
//              to a binary SD.
//
//--------------------------------------------------------------------------

BOOL
_MakeSecurityDescriptorForUser(PCWSTR pszSD, PCWSTR pszUserSID, PSECURITY_DESCRIPTOR *ppSD, PACL *ppDacl)
{
    BOOL bResult;
    WCHAR szSD[MAX_PATH];
    PSECURITY_DESCRIPTOR pSD;

    szSD[0] = L'\0';
    wnsprintfW(szSD, ARRAYLEN(szSD), pszSD, pszUserSID);

    bResult = ConvertStringSecurityDescriptorToSecurityDescriptorW(szSD, SDDL_REVISION_1, &pSD, NULL);

    if (bResult)
    {
        *ppSD = pSD;

        if (ppDacl)
        {
            BOOL bPresent;
            BOOL bDefault;

            GetSecurityDescriptorDacl(pSD, &bPresent, ppDacl, &bDefault);
        }
    }

    return bResult;
}


int _ShowDeleteShareWarning(HWND hwndParent)
{
    WCHAR szMsg[MAX_PATH];
    WCHAR szCaption[50];
    LoadStringW(g_hInstance, IDS_PRIVATE_CONFIRM_DELSHARE, szMsg, ARRAYLEN(szMsg));
    LoadStringW(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));

    return MessageBoxW(hwndParent, szMsg, szCaption, MB_YESNO | MB_ICONWARNING);
}


BOOL _IsRootACLSecure(PACL pDacl)
{
    TRUSTEE tTemp;
    ACCESS_MASK dwMask = 0;
    BuildTrusteeWithSid(&tTemp, (PSID)&g_WorldSid);
    tTemp.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    GetEffectiveRightsFromAcl(pDacl, &tTemp, &dwMask);
    return !(dwMask & (WRITE_DAC | WRITE_OWNER));
}


//+-------------------------------------------------------------------------
//
//  Method:     SetFolderPermissionsForSharing, exported
//
//  Parameters:
//  pszFolderPath   - Folder to adjust permissions on
//  pszUserSID      - User SID (NULL for current user)
//  dwLevel         - 0 = "private". Only the user and local system get access.
//                    1 = "not shared". Remove explicit Everyone ACE.
//                    2 = "shared read-only". Grant explicit RX to Everyone.
//                    3 = "shared read/write". Grant explicit RWXD to Everyone.
//  hwndParent      - MessageBox parent. Set to NULL to prevent warnings.
//
//  Synopsis:   Set the DACL on a folder according to the sharing level
//
//--------------------------------------------------------------------------

#define SIZEOF_EVERYONE_ACE     (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) + sizeof(g_WorldSid))

static const struct
{
    DWORD AceFlags;
    DWORD AccessMask;
} c_rgEveryoneAces[] =
{
    {0,                                          0},
    {CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, FILE_GENERIC_READ | FILE_GENERIC_EXECUTE},
    {CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE | DELETE},
};

//
// Hash algorithm borrowed from shell32\hash.c
//
ULONG _HashString(PCWSTR psz)
{
    UINT hash  = 314159269;
    for(; *psz; psz++)
    {
        hash ^= (hash<<11) + (hash<<5) + (hash>>2) + (UINT)*psz;
    }
    return (hash & 0x7FFFFFFF);
}

BOOL WINAPI
SetFolderPermissionsForSharing(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    IN     DWORD  dwLevel,
    IN     HWND   hwndParent
    )
{
    BOOL bResult = FALSE;
    DWORD dwFolderFlags;
    BOOL bSpecialFolderRoot = FALSE;
    PCWSTR pszDefaultSD = NULL;
    LPWSTR pszUserSIDToFree = NULL;

    appDebugOut((DEB_ITRACE, "SetFolderPermissionsForSharing\n"));

    if (dwLevel > 3)
    {
        appDebugOut((DEB_ITRACE, "Invalid sharing level\n"));
        return FALSE;
    }

    dwFolderFlags = _CheckFolderType(pszFolderPath, pszUserSID, &bSpecialFolderRoot, &pszDefaultSD);

    if (0 == (dwFolderFlags & (CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ROOT_FOLDER)))
    {
        appDebugOut((DEB_ITRACE, "Sharing not allowed on this folder\n"));
        return FALSE;
    }

    if (0 == (dwFolderFlags & CFT_FLAG_CAN_MAKE_PRIVATE) && 0 == dwLevel)
    {
        appDebugOut((DEB_ITRACE, "Can't make this folder private\n"));
        return FALSE;
    }

    // One would think that we could call GetNamedSecurityInfo without first
    // checking for NTFS, and just let it fail on FAT volumes. However,
    // GetNamedSecurityInfo succeeds on FAT and returns a valid security
    // descriptor with a NULL DACL.  This is actually correct in that
    // a NULL DACL means no security, which is true on FAT.
    //
    // We then have the problem of trying to differentiate between a NULL
    // DACL on an NTFS volume (it can happen), and a NULL DACL from a FAT
    // volume.  Let's just check for NTFS first.

    if (!_IsVolumeNTFS(pszFolderPath))
    {
        // No ACLs, so we're done
        return (0 != dwLevel);
    }

    // If we are making the folder private, first check whether any child
    // folders are shared on the net. If so, warn that we are going to nuke them.

    CShareInfo* pWarnList = NULL;
    if (0 == dwLevel &&
        SUCCEEDED(g_ShareCache.ConstructParentWarnList(pszFolderPath, &pWarnList)) &&
        NULL != pWarnList &&
        NULL != hwndParent)
    {
        if (IDNO == _ShowDeleteShareWarning(hwndParent))
        {
            DeleteShareInfoList(pWarnList, TRUE);
            return FALSE;
        }

        // JonN 4/04/01 328512
        // Explorer Sharing Tab (NTSHRUI) should popup warning on deleting
        // SYSVOL,NETLOGON and C$, D$... shares
        for (CShareInfo* p = (CShareInfo*)pWarnList->Next();
                         p != pWarnList;
            )
        {
            CShareInfo* pNext = (CShareInfo*)p->Next();

            DWORD id = ConfirmStopShare( hwndParent, MB_YESNO, p->GetNetname() );
            if ( IDYES != id )
            {
                DeleteShareInfoList(pWarnList, TRUE);
                return FALSE;
            }

            p = pNext;
        }

    }
    // No more early returns after this point (have to free pWarnList)

    if (NULL == pszUserSID || L'\0' == pszUserSID[0])
    {
        _GetUserSid(&pszUserSIDToFree);
        pszUserSID = pszUserSIDToFree;
    }

    // Use a mutex to prevent multiple threads from setting permissions on the
    // same folder at the same time. The mutex name cannot contain '\' so hash
    // the path to obtain a name unique to this folder.

    WCHAR szMutex[30];
    wsprintfW(szMutex, L"share perms %x", _HashString(pszFolderPath));

    HANDLE hMutex = CreateMutex(NULL, FALSE, szMutex);
    if (NULL != hMutex)
    {
        WaitForSingleObject(hMutex, INFINITE);

        if (pszUserSID)
        {
            PSECURITY_DESCRIPTOR pSD = NULL;
            PACL pDacl = NULL;
            DWORD dwErr = GetNamedSecurityInfoW(
                (PWSTR)pszFolderPath,
                SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                &pDacl,
                NULL,
                &pSD);

            if (ERROR_SUCCESS == dwErr)
            {
                PACL pDaclToFree = NULL;

                appAssert(NULL != pSD);

                if (dwFolderFlags & CFT_FLAG_CAN_MAKE_PRIVATE)
                {
                    if (_IsDaclPrivateForUser(pDacl, pszUserSID))
                    {
                        // _IsDaclPrivateForUser returns FALSE if pDacl is NULL
                        appAssert(NULL != pDacl);

                        if (0 == dwLevel)
                        {
                            // Already private, nothing to do
                            bResult = TRUE;
                            pDacl = NULL;
                        }
                        else // making public
                        {
                            if (bSpecialFolderRoot)
                            {
                                // Taking a special folder that was private, and making
                                // it public. First need to reset the DACL to default.
                                // (Special folders often have protected DACLs.)
                                if (pszDefaultSD)
                                {
                                    LocalFree(pSD);
                                    pSD = NULL;
                                    pDacl = NULL;

                                    // If this fails, pDacl will be NULL and we will fail below
                                    _MakeSecurityDescriptorForUser(pszDefaultSD, pszUserSID, &pSD, &pDacl);

                                    appDebugOut((DEB_ITRACE, "Using default security descriptor\n"));
                                }
                            }
                            else // not root of special folder
                            {
                                SECURITY_DESCRIPTOR_CONTROL wControl = 0;
                                DWORD dwRevision;

                                // Check the control bits to see if we are inheriting
                                GetSecurityDescriptorControl(pSD, &wControl, &dwRevision);

                                if ((wControl & SE_DACL_PROTECTED) == 0)
                                {
                                    // Inheriting from parent, assume the parent folder
                                    // is private. Can't make a subfolder public.
                                    pDacl = NULL;

                                    appDebugOut((DEB_ITRACE, "Can't make private subfolder public\n"));
                                }
                                else
                                {
                                    // This folder is private and we're making it public.
                                    // Eliminate all explicit ACEs and reset the protected
                                    // bit so it inherits normal permissions from its parent.

                                    pDacl->AceCount = 0;
                                    SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED, 0);
                                }
                            }
                        }
                    }
                    else // Not currently private
                    {
                        if (0 == dwLevel)
                        {
                            // Reset the DACL to private before continuing below
                            LocalFree(pSD);
                            pSD = NULL;
                            pDacl = NULL;

                            // If this fails, pDacl will be NULL and we will fail below
                            _MakeSecurityDescriptorForUser(c_szPrivateFolderSD, pszUserSID, &pSD, &pDacl);
                        }
                    }
                }
                else // can't make private
                {
                    // We check for this above
                    appAssert(0 != dwLevel);
                }

                if ((dwFolderFlags & CFT_FLAG_ROOT_FOLDER) && NULL != pDacl)
                {
                    // Currently can't make root folders private
                    appAssert(0 != dwLevel);

                    //
                    // NTRAID#NTBUG9-378617-2001/05/04-jeffreys
                    //
                    // Root ACLs tend to have an explicit Everyone ACE, which
                    // screws us up in some cases.  Easiest thing is to start
                    // with a new ACL and don't touch the Everyone entry below.
                    //

                    BOOL bRootIsSecure = _IsRootACLSecure(pDacl);

                    LocalFree(pSD);
                    pSD = NULL;
                    pDacl = NULL;

                    // If this fails, pDacl will be NULL and we will fail below
                    _MakeSecurityDescriptorForUser(bRootIsSecure ? c_szRootSDSecure : c_szRootSDUnsecure, pszUserSID, &pSD, &pDacl);

                    appDebugOut((DEB_ITRACE, "Using default security descriptor\n"));
                }

                //
                // If we're making the folder public, adjust the existing ACL
                //
                if (NULL != pDacl && 0 != dwLevel)
                {
                    PKNOWN_ACE pAce;
                    int iEntry;
                    USHORT cAces = 0;
                    ULONG cbExplicitAces = 0;

                    // Adjust the level to use as an index into c_rgEveryoneAces
                    DWORD dwPublicLevel = dwLevel - 1;
                    appAssert(dwPublicLevel < ARRAYLEN(c_rgEveryoneAces));

                    for (iEntry = 0, pAce = (PKNOWN_ACE)FirstAce(pDacl);
                         iEntry < pDacl->AceCount;
                         iEntry++, pAce = (PKNOWN_ACE)NextAce(pAce))
                    {
                        // Assuming the ACL is canonical, we can stop as soon as we find
                        // an inherited ACE, since the rest will all be inherited and we
                        // can't modify those.
                        if (AceInherited(&pAce->Header))
                            break;

                        cAces++;
                        cbExplicitAces += pAce->Header.AceSize;

                        if (!(dwFolderFlags & CFT_FLAG_ROOT_FOLDER) &&
                            IsKnownAceType(pAce) &&
                            EqualSid((PSID)&pAce->SidStart, (PSID)&g_WorldSid))
                        {
                            pAce->Header.AceFlags = (UCHAR)c_rgEveryoneAces[dwPublicLevel].AceFlags;
                            pAce->Mask = c_rgEveryoneAces[dwPublicLevel].AccessMask;

                            // We don't need to add another Everyone ACE below
                            dwPublicLevel = 0;
                        }
                    }

                    // Trim off inherited ACEs. We don't need to include them when
                    // saving the new ACL, and this generally leaves enough space
                    // in the ACL to add an Everyone ACE if we need to.
                    pDacl->AceCount = cAces;

                    if (0 != dwPublicLevel)
                    {
                        // Need to add an explicit entry for Everyone.

                        ULONG cbAclSize = sizeof(ACL) + SIZEOF_EVERYONE_ACE + cbExplicitAces;

                        if (cbAclSize > (ULONG)pDacl->AclSize)
                        {
                            // No room in the existing ACL.  Allocate a new
                            // ACL and copy existing entries (if any)
                            pDaclToFree = (PACL)LocalAlloc(LPTR, cbAclSize);
                            if (NULL != pDaclToFree)
                            {
                                CopyMemory(pDaclToFree, pDacl, pDacl->AclSize);
                                pDaclToFree->AclSize = (USHORT)cbAclSize;
                                pDacl = pDaclToFree;
                            }
                            else
                            {
                                // Fail
                                pDacl = NULL;
                                appDebugOut((DEB_ITRACE, "Unable to alloc buffer for new ACL\n"));
                            }
                        }

                        if (NULL != pDacl)
                        {
                            appAssert(cbAclSize <= (ULONG)pDacl->AclSize);

                            if (!AddAccessAllowedAceEx(pDacl,
                                                       ACL_REVISION2,
                                                       c_rgEveryoneAces[dwPublicLevel].AceFlags,
                                                       c_rgEveryoneAces[dwPublicLevel].AccessMask,
                                                       (PSID)&g_WorldSid))
                            {
                                // Fail
                                pDacl = NULL;
                                appDebugOut((DEB_ITRACE, "Unable to add Everyone ACE\n"));
                            }
                        }
                    }
                }

                //
                // Set the new DACL on the folder
                //
                if (NULL != pDacl)
                {
                    SECURITY_INFORMATION si;
                    SECURITY_DESCRIPTOR_CONTROL wControl = 0;
                    DWORD dwRevision;

                    GetSecurityDescriptorControl(pSD, &wControl, &dwRevision);

                    if (SE_DACL_PROTECTED & wControl)
                    {
                        // The security descriptor specifies SE_DACL_PROTECTED
                        si = DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION;
                    }
                    else
                    {
                        // Prevent the system from automagically protecting the DACL
                        si = DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION;
                    }

                    if (0 == dwLevel)
                    {
                        // To make the folder private, we have to make sure we blow
                        // away any explicit permissions on children, so use
                        // TreeResetNamedSecurityInfo with KeepExplicit = FALSE.

                        // TreeResetNamedSecurityInfo has a callback mechanism, but
                        // we currently don't use it. Note that the paths passed to
                        // the callback look like
                        //     "\Device\HarddiskVolume1\dir\name"

                        appDebugOut((DEB_ITRACE, "Making folder private; resetting child ACLs\n"));
                        appAssert(si == (DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION));

                        dwErr = TreeResetNamedSecurityInfoW(
                            (PWSTR)pszFolderPath,
                            SE_FILE_OBJECT,
                            si,
                            NULL,
                            NULL,
                            pDacl,
                            NULL,
                            FALSE,  // KeepExplicit (perms on children)
                            NULL,
                            ProgressInvokeNever,
                            NULL
                            );

                        if (ERROR_SUCCESS == dwErr && NULL != pWarnList)
                        {
                            // Nuke child shares
                            for (CShareInfo* p = (CShareInfo*)pWarnList->Next();
                                 p != pWarnList;
                                 )
                            {
                                CShareInfo* pNext = (CShareInfo*)p->Next();

                                if (p->GetFlag() != SHARE_FLAG_ADDED)
                                {
                                    p->SetDirtyFlag(SHARE_FLAG_REMOVE);
                                    p->Commit(NULL);
                                    SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, p->GetPath(), NULL);
                                }

                                // get rid of p
                                p->Unlink();
                                delete p;

                                p = pNext;
                            }
                        }
                    }
                    else
                    {
                        // To make the folder public, we grant access at this level
                        // without blowing away child permissions, including DACL
                        // protection. This means that a private subfolder will still
                        // be private. Use SetNamedSecurityInfo for these, since
                        // TreeResetNamedSecurityInfo always removes SE_DACL_PROTECTED
                        // from children.

                        dwErr = SetNamedSecurityInfoW(
                            (PWSTR)pszFolderPath,
                            SE_FILE_OBJECT,
                            si,
                            NULL,
                            NULL,
                            pDacl,
                            NULL);
                    }

                    if (ERROR_SUCCESS == dwErr)
                    {
                        bResult = TRUE;
                    }
                }

                LocalFree(pDaclToFree);
                LocalFree(pSD);
            }
        }

        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    LocalFree(pszUserSIDToFree);

    if (NULL != pWarnList)
    {
        DeleteShareInfoList(pWarnList, TRUE);
    }

    return bResult;
}


//
//  Description:
//      Dialog proc for the enabling sharing warning dialog.
//  
INT_PTR
WarningDlgProc(
    IN HWND hWnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:
        {
            //
            //  Load warning icon from USER32.
            //

            HICON hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_WARNING));
            if (hIcon)
            {
                SendDlgItemMessage(hWnd, IDC_ICON_INFO, STM_SETICON, (WPARAM )hIcon, 0L);
            }

            //
            //  Set default radio item.
            //

            SendDlgItemMessage(hWnd, IDC_RB_RUN_THE_WIZARD, BM_SETCHECK, BST_CHECKED, 0);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            if ( BN_CLICKED == HIWORD(wParam) )
            {
                UINT iRet = (UINT) SendDlgItemMessage(hWnd, IDC_RB_RUN_THE_WIZARD, BM_GETCHECK, 0, 0 );
                if ( BST_CHECKED == iRet )
                {
                    EndDialog(hWnd, IDC_RB_RUN_THE_WIZARD );
                }
                else
                {
                    EndDialog(hWnd, IDC_RB_ENABLE_FILE_SHARING );
                }
            }
            break;

        case IDCANCEL:
            if ( BN_CLICKED == HIWORD(wParam) )
            {
                EndDialog(hWnd, IDCANCEL);
                return TRUE;
            }
            break;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\strhash.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       strhash.cxx
//
//  Contents:   A hash table for strings
//
//  History:    7-Nov-94    BruceFo Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "strhash.hxx"

const DWORD g_cMinElemsRehash = 3;
const DWORD g_cMinBuckets     = 13;

//////////////////////////////////////////////////////////////////////////////
// Methods for the CStrHashBucketElem class
//////////////////////////////////////////////////////////////////////////////

CStrHashBucketElem::CStrHashBucketElem(
    IN const WCHAR* pszKey
    )
    :
    m_pszKey(pszKey),
    m_next(NULL)
{
    INIT_SIG(CStrHashBucketElem);
}

CStrHashBucketElem::~CStrHashBucketElem()
{
    CHECK_SIG(CStrHashBucketElem);
}

BOOL
CStrHashBucketElem::IsEqual(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashBucketElem);
    appAssert(NULL != pszKey);
    appAssert(NULL != m_pszKey);

    // NOTE: case-insensitive compare. This affects the hash function!
    return (0 == _wcsicmp(pszKey, m_pszKey));
}

//////////////////////////////////////////////////////////////////////////////
// Methods for the CStrHashBucket class
//////////////////////////////////////////////////////////////////////////////

CStrHashBucket::CStrHashBucket(
    VOID
    )
    :
    m_head(NULL)
{
    INIT_SIG(CStrHashBucket);
}

CStrHashBucket::~CStrHashBucket(
    VOID
    )
{
    CHECK_SIG(CStrHashBucket);

    for (CStrHashBucketElem* x = m_head; NULL != x; )
    {
        CStrHashBucketElem* tmp = x->m_next;
        delete x;
        x = tmp;
    }
}

HRESULT
CStrHashBucket::Insert(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashBucket);
    appAssert(NULL != pszKey);

    CStrHashBucketElem* x = new CStrHashBucketElem(pszKey);
    if (NULL == x)
    {
        return E_OUTOFMEMORY;
    }

    x->m_next = m_head;
    m_head = x;
    return S_OK;
}

// return TRUE if it was found and removed, FALSE if it wasn't even found
BOOL
CStrHashBucket::Remove(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashBucket);
    appAssert(NULL != pszKey);

    CStrHashBucketElem** pPrev = &m_head;

    for (CStrHashBucketElem* x = m_head; NULL != x; x = x->m_next)
    {
        if (x->IsEqual(pszKey)) // found it
        {
            *pPrev = x->m_next;
            delete x;
            return TRUE;
        }

        pPrev = &x->m_next;
    }

    return FALSE; // didn't find it
}

BOOL
CStrHashBucket::IsMember(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashBucket);
    appAssert(NULL != pszKey);

    for (CStrHashBucketElem* x = m_head; NULL != x; x = x->m_next)
    {
        if (x->IsEqual(pszKey))
        {
            return TRUE; // found it
        }
    }
    return FALSE; // didn't find it
}

//////////////////////////////////////////////////////////////////////////////
// Methods for the CStrHashTable class
//////////////////////////////////////////////////////////////////////////////

CStrHashTable::CStrHashTable(
    IN DWORD cNumBuckets
    )
    :
    m_cElems(0),
    m_cMinNumBuckets(cNumBuckets)
{
    INIT_SIG(CStrHashTable);

    m_cNumBuckets = max(cNumBuckets, g_cMinBuckets);
    m_ht = new CStrHashBucket[m_cNumBuckets];
    if (NULL == m_ht)
    {
        appDebugOut((DEB_ERROR,
            "Failed to allocate hash table with %d buckets\n",
            m_cNumBuckets));

        m_cMinNumBuckets = 0;
        m_cNumBuckets = 0;
    }
}

HRESULT
CStrHashTable::QueryError(
    VOID
    )
{
    if (NULL == m_ht)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

CStrHashTable::~CStrHashTable(
    VOID
    )
{
    CHECK_SIG(CStrHashTable);

    delete[] m_ht;
}

HRESULT
CStrHashTable::Insert(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashTable);

    if (NULL == pszKey)
    {
        return E_INVALIDARG;
    }

    appAssert(NULL != m_ht);

    DWORD key = HashFunction(pszKey);
    if (!(m_ht[key].IsMember(pszKey)))
    {
        // only insert if the key isn't already in the table.
        HRESULT hr = m_ht[key].Insert(pszKey);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            return hr;
        }
        ++m_cElems;
        return CheckRehash();
    }

    return S_OK;
}

HRESULT
CStrHashTable::Remove(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashTable);

    if (NULL == pszKey)
    {
        return E_INVALIDARG;
    }

    appAssert(NULL != m_ht);

    if (m_ht[HashFunction(pszKey)].Remove(pszKey))
    {
        --m_cElems;
        return CheckRehash();
    }

    return S_OK;    // key was not found and hence not deleted
}

BOOL
CStrHashTable::IsMember(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashTable);

    if (NULL == pszKey)
    {
        return FALSE;   // invalid argument, really
    }

    appAssert(NULL != m_ht);

    return m_ht[HashFunction(pszKey)].IsMember(pszKey);
}

DWORD
CStrHashTable::Count(
    VOID
    )
{
    CHECK_SIG(CStrHashTable);

    return m_cElems;
}

// This returns the iteration data, or NULL on failure
CIterateData*
CStrHashTable::IterateStart(
    VOID
    )
{
    CHECK_SIG(CStrHashTable);

    CIterateData* pData = new CIterateData;
    if (NULL != pData)
    {
        IterateGetNext(pData);
    }
    return pData;
}

const WCHAR*
CStrHashTable::IterateGetData(
    IN OUT CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);
    appAssert(NULL != pCurrent);
    appAssert(ITERATE_END != pCurrent->m_CurrentBucket);

    return pCurrent->m_pCurrentElem->m_pszKey;
}

BOOL
CStrHashTable::IterateDone(
    IN CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);
    appAssert(NULL != pCurrent);

    return (ITERATE_END == pCurrent->m_CurrentBucket);
}

VOID
CStrHashTable::IterateEnd(
    IN CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);

    delete pCurrent;
}

VOID
CStrHashTable::IterateGetNext(
    IN OUT CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);
    appAssert(NULL != pCurrent);
    appAssert(ITERATE_END != pCurrent->m_CurrentBucket);

    if (NULL != pCurrent->m_pCurrentElem)
    {
        if (NULL != pCurrent->m_pCurrentElem->m_next)
        {
            // just get next element in bucket
            pCurrent->m_pCurrentElem = pCurrent->m_pCurrentElem->m_next;
        }
        else
        {
            // need to search to new bucket
            ++pCurrent->m_CurrentBucket;
            IterateGetBucket(pCurrent);
        }
    }
    else
    {
        IterateGetBucket(pCurrent);
    }
}

VOID
CStrHashTable::IterateGetBucket(
    IN OUT CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);
    appAssert(NULL != m_ht);

    for (DWORD i = pCurrent->m_CurrentBucket; i < m_cNumBuckets; i++)
    {
        if (NULL != m_ht[i].m_head)
        {
            pCurrent->m_pCurrentElem  = m_ht[i].m_head;
            pCurrent->m_CurrentBucket = i;
            return;
        }
    }
    pCurrent->m_CurrentBucket = ITERATE_END; // we've iterated through all!
}

DWORD
CStrHashTable::HashFunction(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashTable);

    appAssert(NULL != pszKey);
    appAssert(m_cNumBuckets > 0);

    DWORD total = 0;
    for (const WCHAR* p = pszKey; L'\0' != *p; p++)
    {
        // lower case it, so case-insensitive IsEqual works
        total += towlower(*p);
    }
    return total % m_cNumBuckets;
}

HRESULT
CStrHashTable::CheckRehash(
    VOID
    )
{
    CHECK_SIG(CStrHashTable);

    if (m_cElems > g_cMinElemsRehash && m_cElems > m_cMinNumBuckets)
    {
        if (   (m_cElems > m_cNumBuckets)
            || (m_cElems < m_cNumBuckets / 4) )
        {
            // add one to at least make it odd (for better hashing behavior)
            return Rehash(m_cElems * 2 + 1);
        }
    }
    return S_OK;
}

HRESULT
CStrHashTable::Rehash(
    IN DWORD cNumBuckets
    )
{
    CHECK_SIG(CStrHashTable);

    cNumBuckets = max(cNumBuckets, g_cMinBuckets);
    CStrHashBucket* ht = new CStrHashBucket[cNumBuckets];
    if (NULL == ht)
    {
        // return error, but don't delete the existing table
        return E_OUTOFMEMORY;
    }

    appAssert(NULL != m_ht);

    // now transfer all data from old to new

    ULONG cOldNumBuckets = m_cNumBuckets;
    m_cNumBuckets = cNumBuckets;    // set this so HashFunction() uses it

    for (ULONG i=0; i < cOldNumBuckets; i++)
    {
        for (CStrHashBucketElem* x = m_ht[i].m_head; NULL != x; )
        {
            CStrHashBucketElem* tmp = x->m_next;

            // now, just put this bucket in the right place in the new
            // hash table. Avoid performing new's and copying the keys.

            DWORD bucket = HashFunction(x->m_pszKey);
            x->m_next = ht[bucket].m_head;
            ht[bucket].m_head = x;

            x = tmp;
        }

        m_ht[i].m_head = NULL; // there isn't anything left in the list!
    }

    // the data is transfered; complete the switchover

    delete[] m_ht;
    m_ht = ht;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\ntshrui\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       util.cxx
//
//  Contents:   Misc helper functions
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "util.hxx"
#include <safeboot.h>   // SAFEBOOT_* flags

//////////////////////////////////////////////////////////////////////////////

#define NETMSG_DLL TEXT("netmsg.dll")

//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             g_hInstance,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        WCHAR szText[200];
        LoadString(g_hInstance, IDS_APP_MSG_NOT_FOUND, szText, ARRAYLEN(szText));
        wsprintf(pszBuffer,szText,dwMsgId);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyCommonDialog
//
//  Synopsis:   Common popup dialog routine - stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyCommonDialog(
    IN HWND    hwnd,
    IN HRESULT dwMsgCode,
    IN PWSTR   pszCaption,
    IN DWORD   dwFlags,
    IN va_list arglist
    )
{
    WCHAR szMsgBuf[500];

    MyFormatMessageText(dwMsgCode, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    return MessageBox(hwnd, szMsgBuf, pszCaption, dwFlags);
}


//+-------------------------------------------------------------------------
//
//  Function:   MyConfirmationDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyConfirmationDialog(
    IN HWND hwnd,
    IN HRESULT dwMsgCode,
    IN DWORD dwFlags,
    ...
    )
{
    WCHAR szCaption[100];
    DWORD dwReturn;
    va_list arglist;

    va_start(arglist, dwFlags);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    dwReturn = MyCommonDialog(hwnd, dwMsgCode, szCaption, dwFlags, arglist);
    va_end(arglist);

    return dwReturn;
}


//+-------------------------------------------------------------------------
//
//  Function:   MyErrorDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
VOID
MyErrorDialog(
    IN HWND hwnd,
    IN HRESULT dwErrorCode,
    ...
    )
{
    WCHAR szCaption[100];
    va_list arglist;

    va_start(arglist, dwErrorCode);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    MyCommonDialog(hwnd, dwErrorCode, szCaption, MB_ICONSTOP | MB_OK, arglist);

    va_end(arglist);
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  History:    28-Dec-94   BruceFo   Created
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    if (NULL == psz)
    {
        appDebugOut((DEB_IERROR,"Illegal string to duplicate: NULL\n"));
        return NULL;
    }

    PWSTR pszRet = new WCHAR[wcslen(psz) + 1];
    if (NULL == pszRet)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return NULL;
    }

    wcscpy(pszRet, psz);
    return pszRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetResourceString
//
//  Synopsis:   Load a resource string, are return a "new"ed copy
//
//  Arguments:  [dwId] -- a resource string ID
//
//  Returns:    new memory copy of a string
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

PWSTR
GetResourceString(
    IN DWORD dwId
    )
{
    WCHAR sz[50];
    if (0 == LoadString(g_hInstance, dwId, sz, ARRAYLEN(sz)))
    {
        return NULL;
    }
    else
    {
        return NewDup(sz);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     FindLastComponent, public
//
//  Synopsis:   Parse a string to find the last component.
//
//  History:    21-Nov-94   BruceFo
//
//--------------------------------------------------------------------------

PWSTR
FindLastComponent(
    IN WCHAR* pszStr
    )
{
    PWSTR pszTmp = wcsrchr(pszStr, L'\\');
    if (pszTmp != NULL)
    {
        return pszTmp + 1;
    }
    else
    {
        return pszStr;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CopySecurityDescriptor, public
//
//  Synopsis:   Copy an NT security descriptor. The security descriptor must
//              be in self-relative (not absolute) form. Delete the result
//              using LocalFree().
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

PSECURITY_DESCRIPTOR
CopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    appDebugOut((DEB_ITRACE, "CopySecurityDescriptor, pSecDesc = 0x%08lx\n", pSecDesc));

    if (NULL == pSecDesc)
    {
        return NULL;
    }

    appAssert(IsValidSecurityDescriptor(pSecDesc));

    LONG err;

    DWORD dwLen = GetSecurityDescriptorLength(pSecDesc);
    PSECURITY_DESCRIPTOR pSelfSecDesc = reinterpret_cast<PSECURITY_DESCRIPTOR>(
		::LocalAlloc( LMEM_ZEROINIT,dwLen ) );
    if (NULL == pSelfSecDesc)
    {
        appDebugOut((DEB_ERROR, "new SECURITY_DESCRIPTOR (2) failed\n"));
        return NULL;    // actually, should probably return an error
    }

    DWORD cbSelfSecDesc = dwLen;
    if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &cbSelfSecDesc))
    {
        appDebugOut((DEB_TRACE, "MakeSelfRelativeSD failed, 0x%08lx\n", GetLastError()));

        // assume it failed because it was already self-relative
        CopyMemory(pSelfSecDesc, pSecDesc, dwLen);
    }

    appAssert(IsValidSecurityDescriptor(pSelfSecDesc));

    return pSelfSecDesc;
}


//+-------------------------------------------------------------------------
//
//  Member:     WarnDelShare, public
//
//  Synopsis:   Function to warn a user that a share will be deleted, and give
//              the user a chance to cancel.
//
//  Arguments:  [hwnd] - parent window handle for messages
//              [idMsg] - message ID to display (rmdir vs. move)
//              [pszShare] - share name
//              [pszPath] - path that share affects
//
//  Returns:    IDYES if share was deleted, IDNO if we don't want to delete,
//              but keep going, IDCANCEL to stop going.
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

UINT
WarnDelShare(
    IN HWND hwnd,
    IN UINT idMsg,
    IN PWSTR pszShare,
    IN PWSTR pszPath
    )
{
    DWORD id = MyConfirmationDialog(
                    hwnd,
                    idMsg,
                    MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                    pszPath,
                    pszShare);
    if (id != IDYES)
    {
        return id;
    }

    id = ConfirmStopShare(hwnd, MB_YESNOCANCEL, pszShare);
    if (id != IDYES)
    {
        return id;
    }

    UINT ret = NetShareDel(NULL, pszShare, 0);
    if (ret != NERR_Success)
    {
        DisplayError(hwnd, IERR_CANT_DEL_SHARE, ret, pszShare);
        return IDYES;   // allow the stop anyway
    }

    return IDYES;
}


//+-------------------------------------------------------------------------
//
//  Member:     ConfirmStopShare, public
//
//  Synopsis:   Display the appropriate confirmations when stopping a share.
//
//  Arguments:  [hwnd] - parent window handle for messages
//              [uType] - either MB_YESNO or MB_YESNOCANCEL
//              [pszShare] - ptr to affected share name
//
//  Returns:    IDYES if share should be deleted, IDNO if we don't want to
//              delete, but keep going, IDCANCEL to stop going.
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

DWORD
ConfirmStopShare(
    IN HWND hwnd,
    IN UINT uType,
    IN LPWSTR pszShare
    )
{
    DWORD id = IDYES;
    DWORD cConns = 0;
    DWORD cOpens = 0;
    NET_API_STATUS err = ShareConnectionInfo(pszShare, &cConns, &cOpens);
    if (err != NERR_Success)
    {
        DisplayError(hwnd, IERR_CANT_DEL_SHARE, err, pszShare);
        // allow the stop anyway
    }
    else if (cConns != 0)
    {
        // If there are any open files, just give the more detailed
        // message about there being open files. Otherwise, just say how
        // many connections there are.

        if (cOpens != 0)
        {
            id = MyConfirmationDialog(
                        hwnd,
                        MSG_STOPSHAREOPENS,
                        uType | MB_ICONEXCLAMATION,
                        cOpens,
                        cConns,
                        pszShare);
        }
        else
        {
            id = MyConfirmationDialog(
                        hwnd,
                        MSG_STOPSHARECONNS,
                        uType | MB_ICONEXCLAMATION,
                        cConns,
                        pszShare);
        }
    }

    // JonN 4/4/01 328512
    // Explorer Sharing Tab (NTSHRUI) should popup warning on deleting
    // SYSVOL,NETLOGON and C$, D$... shares
    //
    // No need to worry about IPC$, that won't turn up in NTSHRUI

    if (IDYES == id)
    {
        bool fSpecialShare = !lstrcmpi(pszShare,L"NETLOGON")
                          || !lstrcmpi(pszShare,L"SYSVOL");
        if (   fSpecialShare
            || (lstrlen(pszShare) == 2 && L'$'== pszShare[1])
           )
        {
            id = MyConfirmationDialog(
                        hwnd,
                        (fSpecialShare) ? MSG_DELSPECIALSHARE
                                        : MSG_DELADMINSHARE,
                        uType | MB_ICONEXCLAMATION,
                        pszShare);
        }
    }

    return id;
}



//+-------------------------------------------------------------------------
//
//  Member:     ShareConnectionInfo, public
//
//  Synopsis:   Determine how many connections and file opens exist for a
//              share, for use by confirmation dialogs.
//
//  Arguments:  [pszShare] - ptr to affected share name
//              [pcConns]  - *pcConns get the number of connections
//              [pcOpens]  - *pcOpens get the number of file opens
//
//  Returns:    standard net api code, NERR_Success if everything ok.
//
//  History:    19-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

NET_API_STATUS
ShareConnectionInfo(
    IN LPWSTR pszShare,
    OUT LPDWORD pcConns,
    OUT LPDWORD pcOpens
    )
{
    CONNECTION_INFO_1* pBuf;

    DWORD iEntry, iTotal;
    NET_API_STATUS err = NetConnectionEnum(
                            NULL,
                            pszShare,
                            1,
                            (LPBYTE*)&pBuf,
                            0xffffffff,     // no buffer limit; get them all!
                            &iEntry,
                            &iTotal,
                            NULL);

   if ((err == NERR_Success) || (err == ERROR_MORE_DATA))
   {
      int iConnections = 0;
      for (DWORD i = 0; i < iEntry; i++)
      {
          iConnections += pBuf[i].coni1_num_opens;
      }

      *pcConns = iTotal;
      *pcOpens = iConnections;
      err = NERR_Success;
   }
   else
   {
      *pcConns = 0;
      *pcOpens = 0;
   }
   NetApiBufferFree(pBuf);

   appDebugOut((DEB_ITRACE,"Share '%ws' has %d connections and %d opens\n", pszShare, *pcConns, *pcOpens));

   return err;
}


//+-------------------------------------------------------------------------
//
//  Function:   DisplayError
//
//  Synopsis:   Display an error message
//
//  History:    24-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
DisplayError(
    IN HWND           hwnd,
    IN HRESULT        dwErrorCode, // message file number. not really an HRESULT
    IN NET_API_STATUS err,
    IN PWSTR          pszShare
    )
{
    if (   err < MIN_LANMAN_MESSAGE_ID
        || err > MAX_LANMAN_MESSAGE_ID
        )
    {
        // a Win32 error?

        WCHAR szMsg[500];
        DWORD dwReturn = FormatMessage(
                                 FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 err,
                                 LANG_USER_DEFAULT,
                                 szMsg,
                                 ARRAYLEN(szMsg),
                                 NULL);
        if (0 == dwReturn)   // couldn't find message
        {
            appDebugOut((DEB_IERROR,
                "FormatMessage (from system) failed, 0x%08lx\n",
                GetLastError()));

            MyErrorDialog(hwnd, IERR_UNKNOWN, err);
        }
        else
        {
            MyErrorDialog(hwnd, dwErrorCode, pszShare, szMsg);
        }
    }
    else
    {
        DisplayLanmanError(hwnd, dwErrorCode, err, pszShare);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   DisplayLanmanError
//
//  Synopsis:   Display an error message from a LanMan error.
//
//  History:    24-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
DisplayLanmanError(
    IN HWND           hwnd,
    IN HRESULT        dwErrorCode, // message file number. not really an HRESULT
    IN NET_API_STATUS err,
    IN PWSTR          pszShare
    )
{
    if (   err < MIN_LANMAN_MESSAGE_ID
        || err > MAX_LANMAN_MESSAGE_ID
        )
    {
        MyErrorDialog(hwnd, IERR_UNKNOWN, err);
        return;
    }

    WCHAR szCaption[100];
    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));

    //
    // get LanMan message from system message file.
    //

    WCHAR szNetMsg[500];
    WCHAR szBuf[500];

    HINSTANCE hInstanceNetMsg = LoadLibrary(NETMSG_DLL);
    if (NULL == hInstanceNetMsg)
    {
        appDebugOut((DEB_IERROR,
            "LoadLibrary(netmsg.dll) failed, 0x%08lx\n",
            GetLastError()));

        LoadString(g_hInstance, IDS_NO_NET_MSG, szBuf, ARRAYLEN(szBuf));
        MessageBox(hwnd, szBuf, szCaption, MB_ICONSTOP | MB_OK);
        return;
    }

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             hInstanceNetMsg,
                             err,
                             LANG_USER_DEFAULT,
                             szNetMsg,
                             ARRAYLEN(szNetMsg),
                             NULL);
    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        LoadString(g_hInstance, IDS_NET_MSG_NOT_FOUND, szBuf, ARRAYLEN(szBuf));
        wsprintf(szNetMsg, szBuf, GetLastError());
        MessageBox(hwnd, szNetMsg, szCaption, MB_ICONSTOP | MB_OK);
    }
    else
    {
        MyErrorDialog(hwnd, dwErrorCode, pszShare, szNetMsg);
    }

    FreeLibrary(hInstanceNetMsg);
}


//+-------------------------------------------------------------------------
//
//  Function:   IsValidShareName
//
//  Synopsis:   Checks if the proposed share name is valid or not. If not,
//              it will return a message id for the reason why.
//
//  Arguments:  [pszShareName] - Proposed share name
//              [puId] - If name is invalid, this will contain the reason why.
//
//  Returns:    TRUE if name is valid, else FALSE.
//
//  History:    3-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

BOOL
IsValidShareName(
    IN  PCWSTR pszShareName,
    OUT HRESULT* uId
    )
{
    if (NetpNameValidate(NULL, (PWSTR)pszShareName, NAMETYPE_SHARE, 0L) != NERR_Success)
    {
        *uId = IERR_InvalidShareName;
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetErrorFocus
//
//  Synopsis:   Set focus to an edit control and select its text.
//
//  Arguments:  [hwnd] - dialog window
//              [idCtrl] - edit control to set focus to (and select)
//
//  Returns:    nothing
//
//  History:    3-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
SetErrorFocus(
    IN HWND hwnd,
    IN UINT idCtrl
    )
{
    HWND hCtrl = ::GetDlgItem(hwnd, idCtrl);
    ::SetFocus(hCtrl);
    ::SendMessage(hCtrl, EM_SETSEL, 0, -1);
}


//+-------------------------------------------------------------------------
//
//  Function:   ConfirmReplaceShare
//
//  Synopsis:   Display confirmations for replacing an existing share
//
//  Arguments:  [hwnd] - dialog window
//              [pszShareName] - name of share being replaced
//              [pszOldPath] - current path for the share
//              [pszNewPath] - directory the user's trying to share
//
//  Returns:    Returns IDYES or IDNO
//
//  History:    4-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

DWORD
ConfirmReplaceShare(
    IN HWND hwnd,
    IN PCWSTR pszShareName,
    IN PCWSTR pszOldPath,
    IN PCWSTR pszNewPath
    )
{
    DWORD id = MyConfirmationDialog(
                    hwnd,
                    MSG_RESHARENAMECONFIRM,
                    MB_YESNO | MB_ICONEXCLAMATION,
                    pszOldPath,
                    pszShareName,
                    pszNewPath);
    if (id != IDYES)
    {
        return id;
    }

    return ConfirmStopShare(hwnd, MB_YESNO, (PWSTR)pszShareName);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsWorkstationProduct
//
//  Synopsis:   Determines the NT product type (server or workstation),
//              and returns TRUE if it is workstation.
//
//  Arguments:  (none)
//
//  Returns:    TRUE if running on workstation products
//
//  History:    11-Sep-95 BruceFo   Created
//
//----------------------------------------------------------------------------

BOOL
IsWorkstationProduct(
    VOID
    )
{
    //
    // Determine whether this is the workstation or server product by looking
    // at HKEY_LOCAL_MACHINE, System\CurrentControlSet\Control\ProductOptions.
    // The ProductType value therein is interpreted as follows:
    //
    // LanmanNt -- server product, running as domain controller
    // ServerNt -- server product, not a domain controller
    // WinNT    -- workstation product
    //

    LONG    ec;
    HKEY    hkey;
    DWORD   type;
    DWORD   size;
    UCHAR   buf[100];
    BOOL    fIsWorkstation = TRUE;

    ec = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                0,
                KEY_QUERY_VALUE,
                &hkey
                );

    if (ec == NO_ERROR)
    {
        size = sizeof(buf);
        ec = RegQueryValueEx(hkey,
                             TEXT("ProductType"),
                             NULL,
                             &type,
                             buf,
                             &size);

        if ((ec == NO_ERROR) && (type == REG_SZ))
        {
            if (0 == lstrcmpi((LPTSTR)buf, TEXT("lanmannt")))
            {
                fIsWorkstation = FALSE;
            }

            if (0 == lstrcmpi((LPTSTR)buf, TEXT("servernt")))
            {
                fIsWorkstation = FALSE;
            }
        }

        RegCloseKey(hkey);
    }

    return fIsWorkstation;
}


//+---------------------------------------------------------------------------
//
//  Function:   TrimLeadingAndTrailingSpaces
//
//  Synopsis:   Trims the leading and trailing spaces from a null-terminated string.
//              Used primarily for share names.
//
//  History:    18-Jul-97 JonN      Created
//
//----------------------------------------------------------------------------

VOID
TrimLeadingAndTrailingSpaces(
    IN OUT PWSTR psz
	)
{
	int cchStrlen = ::wcslen(psz);
	int cchLeadingSpaces = 0;
	int cchTrailingSpaces = 0;
	while (L' ' == psz[cchLeadingSpaces])
		cchLeadingSpaces++;
	if (cchLeadingSpaces < cchStrlen)
	{
		while (L' ' == psz[cchStrlen-(cchTrailingSpaces+1)])
			cchTrailingSpaces++;
	}
	if ((cchLeadingSpaces+cchTrailingSpaces) > 0)
	{
		cchStrlen -= (cchLeadingSpaces+cchTrailingSpaces);
		(void)memmove( psz,
		               psz+cchLeadingSpaces,
					   cchStrlen*sizeof(WCHAR) );
		psz[cchStrlen] = L'\0';
	}
}

//+---------------------------------------------------------------------------
//
//  Function:   IsSafeMode
//
//  Synopsis:   Checks the registry to see if the system is in safe mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//
//----------------------------------------------------------------------------

BOOL
IsSafeMode(
    VOID
    )
{
    BOOL    fIsSafeMode = FALSE;
    LONG    ec;
    HKEY    hkey;

    ec = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option"),
                0,
                KEY_QUERY_VALUE,
                &hkey
                );

    if (ec == NO_ERROR)
    {
        DWORD dwValue;
        DWORD dwValueSize = sizeof(dwValue);

        ec = RegQueryValueEx(hkey,
                             TEXT("OptionValue"),
                             NULL,
                             NULL,
                             (LPBYTE)&dwValue,
                             &dwValueSize);

        if (ec == NO_ERROR)
        {
            fIsSafeMode = (dwValue == SAFEBOOT_MINIMAL || dwValue == SAFEBOOT_NETWORK);
        }

        RegCloseKey(hkey);
    }

    return fIsSafeMode;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsForcedGuestModeOn
//
//  Synopsis:   Checks the registry to see if the system is using the
//              Guest-only network access mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Modified and changed name
//
//----------------------------------------------------------------------------

BOOL
IsForcedGuestModeOn(
    VOID
    )
{
    BOOL fIsForcedGuestModeOn = FALSE;

    if (IsOS(OS_PERSONAL))
    {
        // Guest mode is always on for Personal
        fIsForcedGuestModeOn = TRUE;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        LONG    ec;
        HKEY    hkey;

        // Professional, not in a domain. Check the ForceGuest value.

        ec = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                    0,
                    KEY_QUERY_VALUE,
                    &hkey
                    );

        if (ec == NO_ERROR)
        {
            DWORD dwValue;
            DWORD dwValueSize = sizeof(dwValue);

            ec = RegQueryValueEx(hkey,
                                 TEXT("ForceGuest"),
                                 NULL,
                                 NULL,
                                 (LPBYTE)&dwValue,
                                 &dwValueSize);

            if (ec == NO_ERROR && 1 == dwValue)
            {
                fIsForcedGuestModeOn = TRUE;
            }

            RegCloseKey(hkey);
        }
    }

    return fIsForcedGuestModeOn;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsSimpleUI
//
//  Synopsis:   Checks whether to show the simple version of the UI.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Removed CTRL key check
//
//----------------------------------------------------------------------------

BOOL
IsSimpleUI(
    VOID
    )
{
    // Show old UI in safe mode and anytime network access involves
    // true user identity (server, pro with GuestMode off).
    
    // Show simple UI anytime network access is done using the Guest
    // account (personal, pro with GuestMode on) except in safe mode.

    return (!IsSafeMode() && IsForcedGuestModeOn());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\dlgnew.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dlgnew.cxx
//
//  Contents:   "New Share" dialog
//
//  History:    21-Feb-95 BruceFo Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "dlgnew.hxx"
#include "acl.hxx"
#include "util.hxx"
#include "shrinfo.hxx"

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CDlgNewShare::SizeWndProc, public
//
//  Synopsis:   "allow" edit window subclass proc to disallow non-numeric
//              characters.
//
//  History:    5-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
CDlgNewShare::SizeWndProc(
    IN HWND hwnd,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (wMsg)
    {
    case WM_CHAR:
    {
        WCHAR chCharCode = (WCHAR)wParam;
        if (   (chCharCode == TEXT('\t'))
            || (chCharCode == TEXT('\b'))
            || (chCharCode == TEXT('\n'))
            )
        {
            break;
        }

        if (chCharCode < TEXT('0') || chCharCode > TEXT('9'))
        {
            // bad key: ignore it
            MessageBeep(0xffffffff);    // let user know it's an illegal char
            return FALSE;
        }

        break;
    }
    } // end of switch

    CDlgNewShare* pThis = (CDlgNewShare*)GetWindowLongPtr(GetParent(hwnd),GWLP_USERDATA);
    appAssert(NULL != pThis);
    return CallWindowProc(pThis->_pfnAllowProc, hwnd, wMsg, wParam, lParam);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::CDlgNewShare, private
//
//  Synopsis:   constructor
//
//--------------------------------------------------------------------------
CDlgNewShare::CDlgNewShare(
    IN HWND hwndParent,
    IN PWSTR pszMachine
    )
    :
    CDialog(hwndParent, MAKEINTRESOURCE(IDD_NEW_SHARE)),
    _pszMachine(pszMachine),
    _bShareNameChanged(FALSE),
    _bPathChanged(FALSE),
    _bCommentChanged(FALSE),
    _wMaxUsers(DEFAULT_MAX_USERS),
    _fSecDescModified(FALSE),
    _pfnAllowProc(NULL),
    _pShareInfo(NULL)
{
    INIT_SIG(CDlgNewShare);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::~CDlgNewShare, private
//
//  Synopsis:   destructor
//
//--------------------------------------------------------------------------
CDlgNewShare::~CDlgNewShare()
{
    CHECK_SIG(CDlgNewShare);

    delete _pShareInfo;
    _pShareInfo = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::DlgProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------
INT_PTR
CDlgNewShare::DlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CDlgNewShare);

    static DWORD aHelpIds[] =
    {
        IDOK,                   HC_OK,
        IDCANCEL,               HC_CANCEL,
        IDC_SHARE_SHARENAME,    HC_SHARE_SHARENAME,
        IDC_SHARE_PATH,         HC_SHARE_PATH,
        IDC_SHARE_COMMENT,      HC_SHARE_COMMENT,
        IDC_SHARE_MAXIMUM,      HC_SHARE_MAXIMUM,
        IDC_SHARE_ALLOW,        HC_SHARE_ALLOW,
        IDC_SHARE_ALLOW_VALUE,  HC_SHARE_ALLOW_VALUE,
        IDC_SHARE_PERMISSIONS,  HC_SHARE_PERMISSIONS,
        0,0
    };

    switch (msg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(hwnd);

    case WM_COMMAND:
        return _OnCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_VSCROLL:
        // The up/down control changed the edit control: select it again
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        return TRUE;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if (lphi->iContextType == HELPINFO_WINDOW)  // a control
        {
            WCHAR szHelp[50];
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                (HWND)lphi->hItemHandle,
                szHelp,
                HELP_WM_HELP,
                (DWORD_PTR)aHelpIds);
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)wParam,
            szHelp,
            HELP_CONTEXTMENU,
            (DWORD_PTR)aHelpIds);
        break;
    }

    case WM_DESTROY:
    {
        // restore original subclass to window.
        appAssert(NULL != GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE));
        SetWindowLongPtr(GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE), GWLP_WNDPROC, (LONG_PTR)_pfnAllowProc);
        return FALSE;
    }

    } // end of switch

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnInitDialog(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    HRESULT hr;

    // for some reason, this dialog comes up on the bottom!
//  SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
//  SetActiveWindow(hwnd);
    SetForegroundWindow(hwnd);

    // Use a trick from the property sheet code to properly place the dialog.
    // Basically, we want it to go wherever a new window would have gone, not
    // always in the upper-left corner of the screen. This avoids the problem
    // of multiple dialogs showing up in the same place on the screen,
    // overlapping each other.

    const TCHAR c_szStatic[] = TEXT("Static");

    HWND hwndT = CreateWindowEx(0, c_szStatic, NULL,
                    WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT,
                    0, 0, NULL, NULL, g_hInstance, NULL);
    if (hwndT)
    {
        RECT rc;
        GetWindowRect(hwndT, &rc);
        DestroyWindow(hwndT);
        SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    SetDialogIconBig(hwnd, IDI_SHARESFLD);
    SetDialogIconSmall(hwnd, IDI_SHARESFLD);

    // storage for security descriptor

    _pShareInfo = new CShareInfo();
    if (NULL == _pShareInfo)
    {
        return FALSE;
    }

    hr = _pShareInfo->InitInstance();
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete _pShareInfo;
        return FALSE;
    }

    // Subclass allow edit control to disallow non-positive numbers
    _pfnAllowProc = (WNDPROC)SetWindowLongPtr(
                                    GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE),
                                    GWLP_WNDPROC,
                                    (LONG_PTR)&SizeWndProc);

    // use LanMan API constants to set maximum share name & comment lengths
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_PATH,      EM_LIMITTEXT, MAX_PATH-1, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_COMMENT,   EM_LIMITTEXT, MAXCOMMENTSZ, 0L);

    CheckRadioButton(
            hwnd,
            IDC_SHARE_MAXIMUM,
            IDC_SHARE_ALLOW,
            IDC_SHARE_MAXIMUM);

    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    // set the spin control range: 1 <--> large number
    SendDlgItemMessage(
            hwnd,
            IDC_SHARE_ALLOW_SPIN,
            UDM_SETRANGE,
            0,
            MAKELONG(g_uiMaxUsers, 1));

    SetFocus(GetDlgItem(hwnd, IDC_SHARE_SHARENAME));

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDlgNewShare::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CDlgNewShare);

    switch (wID)
    {

//
// Notifications
//

    case IDC_SHARE_MAXIMUM:
        if (BN_CLICKED == wNotifyCode)
        {
            // Take away WS_TABSTOP from the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) & ~WS_TABSTOP);

            _CacheMaxUses(hwnd);
            SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");
        }
        return TRUE;

    case IDC_SHARE_ALLOW:
        if (BN_CLICKED == wNotifyCode)
        {
            // Give WS_TABSTOP to the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) | WS_TABSTOP);

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        }
        return TRUE;

    case IDC_SHARE_ALLOW_VALUE:
    {
        if (EN_SETFOCUS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        }
        if (EN_KILLFOCUS == wNotifyCode)
        {
            _CacheMaxUses(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_ALLOW_SPIN:
        if (UDN_DELTAPOS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }
        }
        return TRUE;

    case IDC_SHARE_SHARENAME:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bShareNameChanged = TRUE;
        }
        return TRUE;
    }

    case IDC_SHARE_PATH:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bPathChanged = TRUE;
        }
        return TRUE;
    }

    case IDC_SHARE_COMMENT:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bCommentChanged = TRUE;
        }
        return TRUE;
    }


//
// Commands
//

    case IDOK:
        return _OnOK(hwnd);

    case IDCANCEL:
        EndDialog(hwnd, FALSE);
        return TRUE;

    case IDC_SHARE_PERMISSIONS:
        return _OnPermissions(hwnd);

    } // end of switch (wID)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnOK, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnOK(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    HRESULT hr;
    HRESULT uTemp;
    BOOL    fSpecial = FALSE;   // IPC$ or ADMIN$

    // Validate the share

    WCHAR szShareName[NNLEN + 1];

    if (0 == GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName)))
    {
        MyErrorDialog(hwnd, IERR_BlankShareName);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }
    TrimLeadingAndTrailingSpaces(szShareName);

    WCHAR szPath[MAX_PATH];
    GetDlgItemText(hwnd, IDC_SHARE_PATH, szPath, ARRAYLEN(szPath));

    // Trying to create a reserved share?
    if (   (0 == _wcsicmp(g_szIpcShare,   szShareName))
        || (0 == _wcsicmp(g_szAdminShare, szShareName)))
    {
        // We will let you add IPC$ and ADMIN$ as long as there is no
        // path specified.
        if (szPath[0] != TEXT('\0'))
        {
            MyErrorDialog(hwnd, MSG_ADDSPECIAL);
            SetErrorFocus(hwnd, IDC_SHARE_PATH);
            return TRUE;
        }

        fSpecial = TRUE;
    }
    else if (!IsValidShareName(szShareName, &uTemp))
    {
        MyErrorDialog(hwnd, uTemp);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }

    // If the user entered some ACL, warn them that we're going to nuke
    // it and let the system use its default (since special shares can't
    // have their security set).
    if (fSpecial || DriveLetterShare(szShareName))
    {
        if (_fSecDescModified)
        {
            DWORD id = MyConfirmationDialog(
                            hwnd,
                            MSG_NOSECURITYONSPECIAL,
                            MB_YESNO | MB_ICONEXCLAMATION);
            if (id == IDNO)
            {
                SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
                return TRUE;
            }
            _pShareInfo->TransferSecurityDescriptor(NULL);
        }
    }

    // Check to see that the same share isn't already used, for either the
    // same path or for another path.

    SHARE_INFO_2* info2;
    NET_API_STATUS ret = NetShareGetInfo(_pszMachine, szShareName, 2, (LPBYTE*)&info2);
    if (ret == NERR_Success)
    {
        // It is already shared. Trying to re-share IPC$ or ADMIN$?

        if (fSpecial)
        {
            MyErrorDialog(hwnd, IERR_AlreadyExistsSpecial, szShareName);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info2);
            return TRUE;
        }

        // Is it already shared for the same path?
        if (0 == _wcsicmp(info2->shi2_path, szPath))
        {
            MyErrorDialog(hwnd, IERR_AlreadyExists, szShareName);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info2);
            return TRUE;
        }

        // Shared for a different path. Ask the user if they wish to delete
        // the old share and create the new one using the name.

        DWORD id = ConfirmReplaceShare(hwnd, szShareName, info2->shi2_path, szPath);
        if (id == IDNO)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info2);
            return TRUE;
        }
        else if (id == IDCANCEL)
        {
            EndDialog(hwnd, FALSE);
            NetApiBufferFree(info2);
            return TRUE;
        }

        // User said to replace the old share. Do it.
        ret = NetShareDel(_pszMachine, szShareName, 0);
        if (ret != NERR_Success)
        {
            DisplayError(hwnd, IERR_CANT_DEL_SHARE, ret, szShareName);
            NetApiBufferFree(info2);
            return FALSE;
        }
        else
        {
            SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, info2->shi2_path, NULL);
        }

        NetApiBufferFree(info2);
    }

    if (!fSpecial)
    {
        // Check for downlevel accessibility
        // CODEWORK we should really get rid of this at some point -- JonN 7/18/97
        ULONG nType;
        if (NERR_Success != NetpPathType(NULL, szShareName, &nType, INPT_FLAGS_OLDPATHS))
        {
            DWORD id = MyConfirmationDialog(
                            hwnd,
                            IERR_InaccessibleByDos,
                            MB_YESNO | MB_ICONEXCLAMATION,
                            szShareName);
            if (id == IDNO)
            {
                SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
                return TRUE;
            }
        }
    }

    // Everything OK, save away the data

    if (_bShareNameChanged)
    {
        hr = _pShareInfo->SetNetname(szShareName);
        CHECK_HRESULT(hr);
    }

    if (_bPathChanged)
    {
        hr = _pShareInfo->SetPath(szPath);
        CHECK_HRESULT(hr);
    }

    if (_bCommentChanged)
    {
    	WCHAR szComment[MAXCOMMENTSZ + 1];
        GetDlgItemText(hwnd, IDC_SHARE_COMMENT, szComment, ARRAYLEN(szComment));
        hr = _pShareInfo->SetRemark(szComment);
        CHECK_HRESULT(hr);
    }

    if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_MAXIMUM))
    {
        hr = _pShareInfo->SetMaxUses(SHI_USES_UNLIMITED);
        CHECK_HRESULT(hr);
    }
    else if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
    {
        _CacheMaxUses(hwnd);
        hr = _pShareInfo->SetMaxUses(_wMaxUsers);
        CHECK_HRESULT(hr);
    }

    _pShareInfo->SetDirtyFlag(SHARE_FLAG_ADDED);
    ret = _pShareInfo->Commit(_pszMachine);
    if (ret != NERR_Success)
    {
        DisplayError(hwnd, IERR_CANT_ADD_SHARE, ret, _pShareInfo->GetNetname());
    }

    if (fSpecial)
    {
        // IPC$ doesn't have a path. ADMIN$ does, but we need to get it: we
        // create the share passing in no path, as required by the API, but
        // then we ask the server what it decided to share it as.

        if (0 == _wcsicmp(g_szAdminShare, szShareName))
        {
            SHARE_INFO_2* info2;
            NET_API_STATUS ret = NetShareGetInfo(_pszMachine, szShareName, 2, (LPBYTE*)&info2);
            if (ret == NERR_Success)
            {
                SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, info2->shi2_path, NULL);
                NetApiBufferFree(info2);
            }
            // else... oh well. No notification to the shell.
        }
    }
    else
    {
        SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, _pShareInfo->GetPath(), NULL);
    }

    EndDialog(hwnd, TRUE);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnPermissions, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
BOOL
CDlgNewShare::_OnPermissions(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    WCHAR szShareName[NNLEN + 1];
    GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
    // don't trim spaces, this might be an existing share with spaces in its name

    PSECURITY_DESCRIPTOR pNewSecDesc = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = _pShareInfo->GetSecurityDescriptor();
    appAssert(NULL == pSecDesc || IsValidSecurityDescriptor(pSecDesc));

    BOOL bSecDescChanged;
    LONG err = EditShareAcl(
                        hwnd,
                        _pszMachine,
                        szShareName,
                        pSecDesc,
                        &bSecDescChanged,
                        &pNewSecDesc);

    if (bSecDescChanged)
    {
        _fSecDescModified = TRUE;

        appAssert(IsValidSecurityDescriptor(pNewSecDesc));
        _pShareInfo->TransferSecurityDescriptor(pNewSecDesc);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_CacheMaxUses, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CDlgNewShare::_CacheMaxUses(
    IN HWND hwnd
    )
{
    DWORD dwRet = (DWORD)SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_GETPOS, 0, 0);
    if (HIWORD(dwRet) != 0)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        // Reset the edit control to the new value
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }
    else
    {
        _wMaxUsers = LOWORD(dwRet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\dutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       dutil.cxx
//
//  Contents:   Utility functions and macros for data objects
//
//  History:    14-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dutil.hxx"

LPIDA
DataObj_GetHIDA(
    LPDATAOBJECT pdtobj,
    STGMEDIUM* pmedium
    )
{
    FORMATETC fmte = {(CLIPFORMAT)g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (NULL != pmedium)
    {
        pmedium->pUnkForRelease = NULL;
        pmedium->hGlobal = NULL;
    }

    if (NULL == pmedium)
    {
        if (SUCCEEDED(pdtobj->QueryGetData(&fmte)))
        {
            return (LPIDA)TRUE;
        }
        else
        {
            return (LPIDA)FALSE;
        }
    }
    else if (SUCCEEDED(pdtobj->GetData(&fmte, pmedium)))
    {
        return (LPIDA)GlobalLock(pmedium->hGlobal);
    }
    return NULL;
}


VOID
HIDA_ReleaseStgMedium(
    LPIDA pida,
    STGMEDIUM* pmedium
    )
{
    if ((NULL != pmedium->hGlobal) && (pmedium->tymed==TYMED_HGLOBAL))
    {
#if DBG == 1
        if (NULL != pida)
        {
            LPIDA pidaT = (LPIDA)GlobalLock(pmedium->hGlobal);
            appAssert(pidaT == pida);
            GlobalUnlock(pmedium->hGlobal);
        }
#endif
        GlobalUnlock(pmedium->hGlobal);
    }
    else
    {
        appAssert(FALSE);
    }

    ReleaseStgMedium(pmedium);
}

LPITEMIDLIST*
ILA_Clone(
    UINT cidl,
    LPCITEMIDLIST* apidl
    )
{
    LPITEMIDLIST* aNewPidl = new LPITEMIDLIST[cidl];
    if (NULL == aNewPidl)
    {
        return NULL;
    }

    for (UINT i = 0; i < cidl; i++)
    {
        aNewPidl[i] = ILClone(apidl[i]);
        if (NULL == aNewPidl[i])
        {
            // delete what we've allocated so far
            for (UINT j = 0; j < i; j++)
            {
                ILFree(aNewPidl[i]);
            }
            delete[] aNewPidl;
            return NULL;
        }
    }

    return aNewPidl;
}

VOID
ILA_Free(
    UINT cidl,
    LPITEMIDLIST* apidl
    )
{
    for (UINT i = 0; i < cidl; i++)
    {
        ILFree(apidl[i]);
    }
    delete[] apidl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\enum.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       enum.cxx
//
//  Contents:   Implementation of IEnumIDList
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "enum.hxx"
#include "util.hxx"


CSharesEnum::CSharesEnum(
    IN PWSTR pszMachine,
    IN DWORD level
    )
    :
    m_pszMachine(pszMachine),
    m_level(level),
    m_uFlags(0),
    m_pShares(NULL),
    m_cShares(0),
    m_dwEnumFlags(0),
    m_iCurrent(0),
    m_ulRefs(0)
{
    AddRef();
}


HRESULT
CSharesEnum::Init(
    ULONG uFlags
    )
{
    HRESULT hr = S_OK;
    LPBYTE pBuf = NULL;
    DWORD entriesread, totalentries;
    NET_API_STATUS ret = NERR_Success;

    m_uFlags = uFlags;

    //
    // Enumerate shares.
    //

    appAssert(m_level == 1 || m_level == 2);

    ret = NetShareEnum(
                m_pszMachine,
                m_level,
                &pBuf,
                0xffffffff,     // get them all!
                &entriesread,
                &totalentries,
                NULL);
    if (NERR_Success != ret)
    {
        hr = HRESULT_FROM_WIN32(ret);
    }
    else
    {
        appAssert(entriesread == totalentries);

        m_pShares = (SHARE_INFO_2*)pBuf;    // possibly level one info
        m_cShares = entriesread;

#ifdef WIZARDS
        m_dwEnumFlags = EF_SHOW_NEW_WIZARD;

        // Now, see if the machine is running the NetWare or Mac server.

        PSERVER_INFO_101 pServerInfo;
        NET_API_STATUS ret = NetServerGetInfo(m_pszMachine, 101, (LPBYTE*)&pServerInfo);
        if (NERR_Success != ret)
        {
            hr = HRESULT_FROM_WIN32(ret);
        }
        else
        {
            if (pServerInfo->sv101_type & SV_TYPE_AFP)
            {
                m_dwEnumFlags |= EF_SHOW_MAC_WIZARD;
            }
            if (pServerInfo->sv101_type & SV_TYPE_NOVELL)
            {
                m_dwEnumFlags |= EF_SHOW_NW_WIZARD;
            }

            // If *either* of the non-SMB servers are running, then all the
            // special "all" wizard object.

            if (m_dwEnumFlags & (EF_SHOW_MAC_WIZARD | EF_SHOW_NW_WIZARD))
            {
                m_dwEnumFlags |= EF_SHOW_ALL_WIZARD;
            }
        }
        NetApiBufferFree(pServerInfo);
#endif // WIZARDS
    }

    return hr;
}


CSharesEnum::~CSharesEnum()
{
    if (NULL != m_pShares)
    {
        NetApiBufferFree(m_pShares);
    }
}


STDMETHODIMP
CSharesEnum::Next(
    ULONG celt,
    LPITEMIDLIST* ppidlOut,
    ULONG* pceltFetched
    )
{
    HRESULT hr = S_OK;
    IDSHARE ids;
    ULONG celtFetched = 0;

    if (NULL == pceltFetched)
    {
        if (celt != 1)
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        *pceltFetched = 0;
    }

    if (celt == 0)
    {
        return S_OK;
    }

    if (!(m_uFlags & SHCONTF_NONFOLDERS))
    {
        return S_FALSE;
    }

CopyAnother:

    if (celtFetched == celt)
    {
        if (NULL != pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        return S_OK;    // got celt elements
    }

#ifdef WIZARDS
    if (0 != m_dwEnumFlags)
    {
        // We still have some special stuff to enumerate

        if (m_dwEnumFlags & EF_SHOW_NEW_WIZARD)
        {
            FillSpecialID(&ids, SHID_SHARE_NEW, IDS_SHARE_NEW);
            m_dwEnumFlags &= ~EF_SHOW_NEW_WIZARD;
            goto CopyOne;
        }

        if (m_dwEnumFlags & EF_SHOW_NW_WIZARD)
        {
            FillSpecialID(&ids, SHID_SHARE_NW, IDS_SHARE_NW);
            m_dwEnumFlags &= ~EF_SHOW_NW_WIZARD;
            goto CopyOne;
        }

        if (m_dwEnumFlags & EF_SHOW_MAC_WIZARD)
        {
            FillSpecialID(&ids, SHID_SHARE_MAC, IDS_SHARE_MAC);
            m_dwEnumFlags &= ~EF_SHOW_MAC_WIZARD;
            goto CopyOne;
        }

        if (m_dwEnumFlags & EF_SHOW_ALL_WIZARD)
        {
            FillSpecialID(&ids, SHID_SHARE_ALL, IDS_SHARE_ALL);
            m_dwEnumFlags &= ~EF_SHOW_ALL_WIZARD;
            goto CopyOne;
        }
    }
#endif // WIZARDS

    if (m_iCurrent >= m_cShares)
    {
        // already enumerated all of them
        if (NULL != pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        return S_FALSE; // didn't copy celt
    }

    switch (m_level)
    {
    case 1: FillID1(&ids, &(((LPSHARE_INFO_1)m_pShares)[m_iCurrent])); break;
    case 2: FillID2(&ids, &(((LPSHARE_INFO_2)m_pShares)[m_iCurrent])); break;
    default: appAssert(FALSE);
    }

    ++m_iCurrent;

#ifdef WIZARDS
CopyOne:
#endif // WIZARDS

    ppidlOut[celtFetched] = ILClone((LPCITEMIDLIST)(&ids));
    if (NULL == ppidlOut[celtFetched])
    {
        // free up everything so far
        for (ULONG i = 0; i < celtFetched; i++)
        {
            ILFree(ppidlOut[i]);
        }
        return E_OUTOFMEMORY;
    }

    ++celtFetched;
    goto CopyAnother;
}


STDMETHODIMP
CSharesEnum::Skip(
    ULONG celt
    )
{
    if (m_iCurrent >= m_cShares)
    {
        return S_FALSE;
    }

    m_iCurrent += celt;
    return NOERROR;
}


STDMETHODIMP
CSharesEnum::Reset(
    VOID
    )
{
    m_iCurrent = 0;
    return NOERROR;
}


STDMETHODIMP
CSharesEnum::Clone(
    IEnumIDList** ppenum
    )
{
    return E_FAIL;  // not supported
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\guids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       guids.h
//
//  Contents:   All GUIDs
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

DEFINE_GUID(CLSID_CShares, 0x02a36f10, 0x2f6f, 0x11cf, 0x8c, 0xe4, 0x00,0xaa,0x00,0x3c,0xa9,0xf6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\dllmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       dllmain.hxx
//
//  Contents:   DLL initialization entrypoint and global variables
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <locale.h>
#include <setupapi.h>
#include "resource.h"
#include "util.hxx"

const TCHAR c_szShellIDList[] = CFSTR_SHELLIDLIST;

//+--------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Win32 DLL initialization function
//
//  Arguments:  [hInstance] - Handle to this dll
//              [dwReason]  - Reason this function was called.  Can be
//                            Process/Thread Attach/Detach.
//
//  Returns:    BOOL    - TRUE if no error.  FALSE otherwise
//
//  History:    4-Apr-95 BruceFo  Created
//
//---------------------------------------------------------------------------

extern "C"
BOOL
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
#if DBG == 1
        InitializeDebugging();
//         SharingInfoLevel = DEB_ERROR | DEB_TRACE;
        SharingInfoLevel = DEB_ERROR;
        SetWin4AssertLevel(ASSRT_BREAK | ASSRT_MESSAGE);
#endif // DBG == 1

        appDebugOut((DEB_TRACE, "shareui.dll: DllMain enter\n"));

        // Disable thread notification from OS
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance;
        InitCommonControls();   // get up/down control
        setlocale(LC_CTYPE, ""); // set the C runtime library locale, for string operations
        g_cfHIDA = RegisterClipboardFormat(c_szShellIDList);

        // Determine the maximum number of users
        g_uiMaxUsers = IsWorkstationProduct()
                            ? MAX_USERS_ON_WORKSTATION
                            : MAX_USERS_ON_SERVER
                            ;

        break;
    }

    case DLL_PROCESS_DETACH:
        appDebugOut((DEB_TRACE, "shareui.dll: DllMain leave\n"));
        break;
    }

    return TRUE;
}


//
// Procedure for uninstalling this DLL (given an INF file). Note: this DLL
// really should dynamically load setupapi.dll, to avoid its overhead all the
// time.
//
void WINAPI
UninstallW(
  HWND hwndStub,
  HINSTANCE hInstance,
  LPTSTR lpszCmdLine,
  int nCmdShow
  )
{
    RUNDLLPROC pfnCheckAPI = UninstallW;  // let compiler check the prototype

    if (!lpszCmdLine || lstrlen(lpszCmdLine) >= MAX_PATH)
    {
        return;
    }

    TCHAR szSure[200];
    LoadString(g_hInstance, IDS_SUREUNINST, szSure, ARRAYLEN(szSure));
    TCHAR szTitle[200];
    LoadString(g_hInstance, IDS_MSGTITLE, szTitle, ARRAYLEN(szTitle));

    if (MessageBox(hwndStub, szSure, szTitle, MB_YESNO | MB_ICONSTOP) != IDYES)
    {
        return;
    }

    HINF hinf = SetupOpenInfFile(
                  lpszCmdLine,  // should be the name of the inf
                  NULL,         // optional Version section CLASS info
                  INF_STYLE_WIN4,
                  NULL);        // optional error line info
    if (INVALID_HANDLE_VALUE == hinf)
    {
        appDebugOut((DEB_ERROR,
            "SetupOpenInfFile failed, 0x%x\n",
            GetLastError()));
        return;
    }

    PVOID pContext = SetupInitDefaultQueueCallback(hwndStub);

    BOOL ret = SetupInstallFromInfSection(
                  hwndStub,     // optional, handle of a parent window
                  hinf,         // handle to the INF file
                  TEXT("DefaultUninstall"), // section of the INF file to install
                  SPINST_REGISTRY | SPINST_FILES,   // which lines to install from section
                  HKEY_CURRENT_USER,    // optional, key for registry installs
                  NULL,                 // optional, path for source files
                  SP_COPY_FORCE_NEWER,  // optional, specifies copy behavior
                  SetupDefaultQueueCallback, // optional, specifies callback routine
                  pContext,             // optional, callback routine context
                  NULL,                 // optional, device information set
                  NULL);                // optional, device info structure
    if (!ret)
    {
      appDebugOut((DEB_ERROR,
          "SetupInstallFromInfSection failed, 0x%x\n",
          GetLastError()));
    }

    SetupCloseInfFile(hinf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\makefile.inc ===
app.rc: $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        app.rc2 \
        share.ico \
        shrfld.ico \
        ipc.ico \
        resource.h \
        $(O)\messages.h \
        $(O)\messages.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\helpids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define HC_OK                       1
#define HC_CANCEL                   2
#define HC_SHARE_SHARENAME          3
#define HC_SHARE_COMMENT            4
#define HC_SHARE_MAXIMUM            5
#define HC_SHARE_ALLOW              6
#define HC_SHARE_ALLOW_VALUE        7
#define HC_SHARE_PERMISSIONS        8
#define HC_SHARE_PATH               9

// The following are help ids for the ACL editor

#define ACL_HC_MAIN_DLG                 20
#define ACL_HC_ADD_USER_DLG             21
#define ACL_HC_ADD_USER_MEMBERS_LG_DLG  22
#define ACL_HC_ADD_USER_MEMBERS_GG_DLG  23
#define ACL_HC_ADD_USER_SEARCH_DLG      24
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\menuutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       menuutil.cxx
//
//  Contents:   Context menu utilities, stolen from the shell. This is
//              basically CDefFolderMenu_MergeMenu and its support.
//
//  History:    20-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "menuutil.hxx"

// Cannonical command names stolen from the shell
TCHAR const c_szDelete[]     = TEXT("delete");
TCHAR const c_szCut[]        = TEXT("cut");
TCHAR const c_szCopy[]       = TEXT("copy");
TCHAR const c_szLink[]       = TEXT("link");
TCHAR const c_szProperties[] = TEXT("properties");
TCHAR const c_szPaste[]      = TEXT("paste");
TCHAR const c_szPasteLink[]  = TEXT("pastelink");
TCHAR const c_szRename[]     = TEXT("rename");

HMENU
LoadPopupMenu(
    HINSTANCE hinst,
    UINT id
    )
{
    HMENU hmParent = LoadMenu(hinst, MAKEINTRESOURCE(id));
    if (NULL == hmParent)
    {
        return NULL;
    }

    HMENU hmPopup = GetSubMenu(hmParent, 0);
    RemoveMenu(hmParent, 0, MF_BYPOSITION);
    DestroyMenu(hmParent);

    return hmPopup;
}

HMENU
MyGetMenuFromID(
    HMENU hmMain,
    UINT uID
    )
{
    MENUITEMINFO mii;

    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_SUBMENU;
    mii.cch    = 0;     // just in case

    if (!GetMenuItemInfo(hmMain, uID, FALSE, &mii))
    {
        return NULL;
    }

    return mii.hSubMenu;
}

int
MyMergePopupMenus(
    HMENU hmMain,
    HMENU hmMerge,
    int idCmdFirst,
    int idCmdLast)
{
    int i;
    int idTemp;
    int idMax = idCmdFirst;

    for (i = GetMenuItemCount(hmMerge) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask  = MIIM_ID | MIIM_SUBMENU;
        mii.cch    = 0;     // just in case

        if (!GetMenuItemInfo(hmMerge, i, TRUE, &mii))
        {
            continue;
        }

        idTemp = Shell_MergeMenus(
                    MyGetMenuFromID(hmMain, mii.wID),
                    mii.hSubMenu,
                    0,
                    idCmdFirst,
                    idCmdLast,
                    MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
        if (idMax < idTemp)
        {
            idMax = idTemp;
        }
    }

    return idMax;
}


VOID
MyMergeMenu(
    HINSTANCE hinst,
    UINT idMainMerge,
    UINT idPopupMerge,
    LPQCMINFO pqcm)
{
    HMENU hmMerge;
    UINT idMax = pqcm->idCmdFirst;
    UINT idTemp;

    if (idMainMerge
        && (hmMerge = LoadPopupMenu(hinst, idMainMerge)) != NULL)
    {
        idMax = Shell_MergeMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->indexMenu,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast,
                        MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
        DestroyMenu(hmMerge);
    }

    if (idPopupMerge
        && (hmMerge = LoadMenu(hinst, MAKEINTRESOURCE(idPopupMerge))) != NULL)
    {
        idTemp = MyMergePopupMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast);
        if (idMax < idTemp)
        {
            idMax = idTemp;
        }
        DestroyMenu(hmMerge);
    }

    pqcm->idCmdFirst = idMax;
}


VOID
MyInsertMenu(
    HINSTANCE hinst,
    UINT idInsert,
    LPQCMINFO pqcm)
{
    HMENU hmInsert;
    UINT idMax = pqcm->idCmdFirst;

    if (idInsert
        && (hmInsert = LoadPopupMenu(hinst, idInsert)) != NULL)
    {
        for (int i = GetMenuItemCount(hmInsert) - 1; i >= 0; --i)
        {
            MENUITEMINFO mii;

            mii.cbSize = sizeof(mii);
            mii.fMask  = MIIM_ID | MIIM_SUBMENU;
            mii.cch    = 0;     // just in case

            if (!GetMenuItemInfo(hmInsert, i, TRUE, &mii))
            {
                continue;
            }

            if (!InsertMenuItem(pqcm->hmenu, idMax, TRUE, &mii))
            {
                ++idMax;
            }
        }
        DestroyMenu(hmInsert);
    }

    pqcm->idCmdFirst = idMax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\menu.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       menu.cxx
//
//  Contents:   Implementation of IContextMenu
//
//  History:    20-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "util.hxx"
#include "dutil.hxx"
#include "menu.hxx"
#include "menuutil.hxx"
#include "shares.h"
#include "resource.h"


CSharesCM::CSharesCM(
    IN HWND hwnd
    )
    :
    m_ulRefs(0),
    m_hwnd(hwnd),
    m_cidl(0),
    m_apidl(NULL),
    m_psf(NULL)
{
    AddRef();
}


HRESULT
CSharesCM::InitInstance(
    IN PWSTR pszMachine,
    IN UINT cidl,
    IN LPCITEMIDLIST* apidl,
    IN IShellFolder* psf
    )
{
    m_pszMachine = pszMachine;

    m_cidl = cidl;
    m_apidl = ILA_Clone(cidl, apidl);
    if (NULL == m_apidl)
    {
        return E_OUTOFMEMORY;
    }

    appAssert(NULL != psf);
    m_psf = psf;
    m_psf->AddRef();

    return S_OK;
}


CSharesCM::~CSharesCM()
{
    ILA_Free(m_cidl, m_apidl);
    m_cidl = 0;
    m_apidl = NULL;

    appAssert(NULL != m_psf);
    m_psf->Release();
    m_psf = NULL;
}


STDMETHODIMP
CSharesCM::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
    )
{
    if (uFlags & CMF_DVFILE)
    {
        // This IContextMenu was created to add items to the DefView "File"
        // menu. This menu already has 4 standard items: Create Shortcut,
        // Delete, Rename, and Properties. Since we only want Delete and
        // Properties, and don't need to add anything, we simply do nothing
        // and let DefView do the work.
        return ResultFromShort(0);
    }
    else
    {
        // Got an IContextMenu because of a double-click on the item (to get
        // the default item) or a right-click on the item (to display the
        // entire context menu). So, put it up.

        QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };
        MyMergeMenu(g_hInstance, POPUP_SHARE, 0, &qcm);

        ULONG dwInOut = SFGAO_CANDELETE | SFGAO_HASPROPSHEET | SFGAO_CANRENAME;
        HRESULT hr = m_psf->GetAttributesOf(m_cidl, (LPCITEMIDLIST*)m_apidl, &dwInOut);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            return hr;
        }

        if (!(dwInOut & SFGAO_CANDELETE))
        {
            EnableMenuItem(hmenu, idCmdFirst + SHARED_FILE_DELETE, MF_GRAYED | MF_BYCOMMAND);
        }
        if (!(dwInOut & SFGAO_CANRENAME))
        {
            EnableMenuItem(hmenu, idCmdFirst + SHARED_FILE_RENAME, MF_GRAYED | MF_BYCOMMAND);
        }
        if (!(dwInOut & SFGAO_HASPROPSHEET))
        {
            EnableMenuItem(hmenu, idCmdFirst + SHARED_FILE_PROPERTIES, MF_GRAYED | MF_BYCOMMAND);
        }

        SetMenuDefaultItem(hmenu, idCmdFirst + SHARED_FILE_PROPERTIES, FALSE);
        return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
    }
}

STDMETHODIMP
CSharesCM::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    HRESULT hr = S_OK;
    LPIDSHARE pids;
    UINT i;
    UINT idCmd = (UINT)LOWORD(lpici->lpVerb);

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        // Check for "delete" and "properties" that come from the toolbar or
        // the shell view.
        if (0 == lstrcmpA(pszCmd, "delete"))
        {
            idCmd = SHARED_FILE_DELETE;
        }
        else if (0 == lstrcmpA(pszCmd, "rename"))
        {
            idCmd = SHARED_FILE_RENAME;
        }
        else if (0 == lstrcmpA(pszCmd, "properties"))
        {
            idCmd = SHARED_FILE_PROPERTIES;
        }
        else
        {
            return E_INVALIDARG;
        }
    }

    switch(idCmd)
    {
    case SHARED_FILE_DELETE:
    {
        for (UINT i = 0; i < m_cidl; i++)
        {
            pids = (LPIDSHARE)m_apidl[i];
            hr = ShareDoDelete(m_hwnd, m_pszMachine, Share_GetName(pids));
            CHECK_HRESULT(hr);
            // even if failure, keep going
        }
        break;
    }

    case SHARED_FILE_RENAME:
    {
        appAssert(!"Shouldn't get rename command here!");
        hr = E_FAIL;
        break;
    }

    case SHARED_FILE_PROPERTIES:
    {
        // should we do multiple-select properties?
        appAssert(m_cidl == 1);
        pids = (LPIDSHARE)m_apidl[0];

        // pass in a pointer to our own IUnknown
        IUnknown* punk;
        hr = QueryInterface(IID_IUnknown, (LPVOID*)&punk);
        if (SUCCEEDED(hr))
        {
            hr = ShareDoProperties(punk, m_pszMachine, Share_GetName(pids));
            punk->Release();
        }
        break;
    }

    } // switch(wParam)

    return hr;
}

STDMETHODIMP
CSharesCM::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax
    )
{
    HRESULT hr = E_FAIL;

    *((LPWSTR)pszName) = TEXT('\0');
    if (uType == GCS_HELPTEXT)
    {
        LoadStringW(g_hInstance, (UINT)(idCmd + IDS_MH_FSIDM_FIRST), (LPWSTR)pszName, cchMax);
        hr = S_OK;
    }
    else if (uType == GCS_VERB)
    {
        switch(idCmd)
        {
        case SHARED_FILE_DELETE:
        case SHARED_FILE_PROPERTIES:
            break;

        case SHARED_FILE_RENAME:
            StrNCopy((LPWSTR)pszName, c_szRename, cchMax);
            hr = S_OK;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\menubg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       menubg.cxx
//
//  Contents:   Implementation of IContextMenu
//
//  History:    20-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "util.hxx"
#include "menubg.hxx"
#include "menuutil.hxx"
#include "resource.h"


STDMETHODIMP
CSharesCMBG::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
    )
{
    UINT idMainMerge;
    if (uFlags & CMF_DVFILE)
    {
        // This IContextMenu was created to add items to the DefView menu.
        // We only want to add a "new" item to the "File" menu, so set don't
        // do any "main" merge.
        idMainMerge = 0;
    }
    else
    {
        // In this case, it's actually a background right-click context menu,
        // so merge in the "New" menu.
        idMainMerge = POPUP_SHARESBG_POPUPMERGE2;
    }

    QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };

    switch (m_level)
    {
    case 1:
        MyMergeMenu(
                g_hInstance,
                0,
                POPUP_SHARESBG_POPUPMERGE1,
                &qcm);
        break;

    case 2:
        MyMergeMenu(
                g_hInstance,
                idMainMerge,
                POPUP_SHARESBG_POPUPMERGE2,
                &qcm);
        break;

    default: appAssert(FALSE);
    }

    return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
}

STDMETHODIMP
CSharesCMBG::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        return E_INVALIDARG;
    }

    appAssert(ICOL1_NAME    == ICOL2_NAME);
    appAssert(ICOL1_COMMENT == ICOL2_COMMENT);

    UINT idCmd = (UINT)LOWORD(lpici->lpVerb);
    switch (idCmd)
    {
    case FSIDM_SORTBYNAME:
        ShellFolderView_ReArrange(m_hwnd, ICOL2_NAME);
        return NOERROR;

    case FSIDM_SORTBYCOMMENT:
        ShellFolderView_ReArrange(m_hwnd, ICOL2_COMMENT);
        return NOERROR;

    case FSIDM_SORTBYPATH:
        appAssert(m_level >= 2);
        ShellFolderView_ReArrange(m_hwnd, ICOL2_PATH);
        return NOERROR;

    case FSIDM_SORTBYMAXUSES:
        appAssert(m_level >= 2);
        ShellFolderView_ReArrange(m_hwnd, ICOL2_MAXUSES);
        return NOERROR;

    case FSIDM_NEWSHARE:
    {
        appAssert(m_level >= 2);
        // pass in a pointer to our own IUnknown
        IUnknown* punk;
        HRESULT hr = QueryInterface(IID_IUnknown, (LPVOID*)&punk);
        if (SUCCEEDED(hr))
        {
            hr = ShareDoNew(punk, m_pszMachine);
            punk->Release();
        }
        return hr;
    }

    default:
        return E_INVALIDARG;
    }
}

STDMETHODIMP
CSharesCMBG::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax
    )
{
    *((LPWSTR)pszName) = TEXT('\0');
    if (uType == GCS_HELPTEXT)
    {
        LoadStringW(g_hInstance, (UINT)(idCmd + IDS_MH_FSIDM_FIRST), (LPWSTR)pszName, cchMax);
        return NOERROR;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\menusp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       menusp.cxx
//
//  Contents:   Implementation of IContextMenu
//
//  History:    20-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "util.hxx"
#include "dutil.hxx"
#include "menusp.hxx"
#include "menuutil.hxx"
#include "shares.h"
#include "resource.h"


#ifdef WIZARDS

CSharesCMSpecial::CSharesCMSpecial(
    IN HWND hwnd
    )
    :
    m_ulRefs(0),
    m_hwnd(hwnd),
    m_pidl(NULL),
    m_psf(NULL)
{
    AddRef();
}


HRESULT
CSharesCMSpecial::InitInstance(
    IN PWSTR pszMachine,
    IN LPCITEMIDLIST pidl,
    IN IShellFolder* psf
    )
{
    m_pszMachine = pszMachine;

    m_pidl = ILClone(pidl);
    if (NULL == m_pidl)
    {
        return E_OUTOFMEMORY;
    }

    m_psf = psf;
    m_psf->AddRef();

    return S_OK;
}


CSharesCMSpecial::~CSharesCMSpecial()
{
    ILFree(m_pidl);
    m_pidl = NULL;
    m_psf->Release();
    m_psf = NULL;
}


STDMETHODIMP
CSharesCMSpecial::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
    )
{
    UINT idMerge;
    if (uFlags & CMF_DVFILE)
    {
        idMerge = POPUP_SPECIAL_FILE;
    }
    else
    {
        idMerge = POPUP_SPECIAL;
    }

    QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };
    MyMergeMenu(g_hInstance, idMerge, 0, &qcm);
    SetMenuDefaultItem(hmenu, idCmdFirst + FSIDM_OPENSPECIAL, FALSE);
    return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
}

STDMETHODIMP
CSharesCMSpecial::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    HRESULT hr = S_OK;
    LPIDSHARE pids;
    UINT i;
    UINT idCmd = (UINT)LOWORD((DWORD)lpici->lpVerb);

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        // Check for "link" that comes from the toolbar or the shell view.
        if (0 == lstrcmpA(pszCmd, "link"))
        {
            idCmd = SHARED_FILE_LINK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }

    switch(idCmd)
    {
    case FSIDM_OPENSPECIAL:
    {
        pids = (LPIDSHARE)m_pidl;
        hr = ShareDoSpecial(m_hwnd, m_pszMachine, Share_GetFlags(pids));
        CHECK_HRESULT(hr);
        break;
    }

    case SHARED_FILE_LINK:
    {
        UINT dwfInOut = 0;
        IDataObject* pDataObject;
        hr = m_psf->GetUIObjectOf(
                        lpici->hwnd,
                        1,
                        (LPCITEMIDLIST*)&m_pidl,
                        IID_IDataObject,
                        &dwfInOut,
                        (LPVOID*)&pDataObject);
        if (SUCCEEDED(hr))
        {
            SHCreateLinks(
                lpici->hwnd,
                NULL,
                pDataObject,
                SHCL_USETEMPLATE,
                NULL);
            pDataObject->Release();
        }
        break;
    }

    } // switch(wParam)

    return hr;
}

STDMETHODIMP
CSharesCMSpecial::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax
    )
{
    *((LPWSTR)pszName) = TEXT('\0');
    if (uType == GCS_HELPTEXT)
    {
        LoadStringW(g_hInstance, idCmd + IDS_MH_FSIDM_FIRST, (LPWSTR)pszName, cchMax);
        return NOERROR;
    }

    return E_FAIL;
}

#endif // WIZARDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\pfolder.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       pfolder.cxx
//
//  Contents:   Implementation of IPersistFolder
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "guids.h"
#include "pfolder.hxx"
#include "shares.hxx"
#include "util.hxx"

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesPF::GetClassID(
    LPCLSID lpClassID
    )
{
    CShares* This = IMPL(CShares,m_PersistFolder,this);
    *lpClassID = CLSID_CShares;
    return S_OK;
}


STDMETHODIMP
CSharesPF::Initialize(
    LPCITEMIDLIST pidl
    )
{
    CShares* This = IMPL(CShares,m_PersistFolder,this);
    This->m_pidl = ILClone(pidl);
    if (NULL == This->m_pidl)
    {
        return E_OUTOFMEMORY;
    }

    // Determine what share info level to use, based on which level succeeds.
    // NOTE: if this is being invoked remotely, we assume that IRemoteComputer
    // is invoked *before* IPersistFolder.

    // Try 2, then 1.
    if (IsLevelOk(This->m_pszMachine, 2))
    {
        This->m_level = 2;
    }
    else if (IsLevelOk(This->m_pszMachine, 1))
    {
        This->m_level = 1;
    }
    else
    {
        // error: can't enumerate
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\ole.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       ole.cxx
//
//  Contents:   IUnknown & IClassFactory for all OLE objects
//
//  History:    13-Dec-95    BruceFo     Created
//
//  Note:  There are three types of IUnknown implementations here. The first
//  is for the "Shared Folders" COM objects. Each of these interfaces can be
//  QueryInterface'd from the others, and all return the same IUnknown. There
//  is a single shared object reference count (not interface reference count).
//  These interfaces include: IShellFolder, IPersistFolder, IRemoteComputer.
//
//  The second type is standard, separate interfaces that get interface-specific
//  reference counts. This includes: IShellDetails, IEnumIDList,
//  IExtractIcon, IExtractIconA.
//
//  The third type is the IUnknown implementation for the "Shared Folders"
//  COM object class factory. This object is a global static object, so it
//  never gets destructed.
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <initguid.h>
#include "guids.h"

#include "ole.hxx"
#include "shares.h"
#include "shares.hxx"
#include "sdetails.hxx"
#include "sfolder.hxx"
#include "pfolder.hxx"
#include "rcomp.hxx"
#include "menu.hxx"
#include "menusp.hxx"
#include "menubg.hxx"
#include "enum.hxx"
#include "xicon.hxx"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

ULONG g_ulcInstances = 0;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShares::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        AddRef();
        *ppvObj = (IUnknown*) this;
        hr = S_OK;
    }
    else if (IsEqualIID(IID_IShellFolder, riid))
    {
        hr = m_ShellFolder.QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(IID_IPersistFolder, riid))
    {
        hr = m_PersistFolder.QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(IID_IRemoteComputer, riid))
    {
        hr = m_RemoteComputer.QueryInterface(riid, ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(ULONG)
CShares::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    InterlockedIncrement((LONG*)&m_ulRefs);
    return m_ulRefs;
}

STDMETHODIMP_(ULONG)
CShares::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesSF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    if (IsEqualIID(IID_IShellFolder, riid))
    {
        AddRef();
        *ppvObj = (IShellFolder*) this;
        hr = S_OK;
    }
    else
    {
        CShares* This = IMPL(CShares,m_ShellFolder,this);
        hr = This->QueryInterface(riid, ppvObj);
    }

    return hr;
}

STDMETHODIMP_(ULONG)
CSharesSF::AddRef()
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    return This->AddRef();
}

STDMETHODIMP_(ULONG)
CSharesSF::Release()
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    return This->Release();
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesPF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    if (IsEqualIID(IID_IPersistFolder, riid))
    {
        AddRef();
        *ppvObj = (IPersistFolder*) this;
        hr = S_OK;
    }
    else
    {
        CShares* This = IMPL(CShares,m_PersistFolder,this);
        hr = This->QueryInterface(riid, ppvObj);
    }

    return hr;
}

STDMETHODIMP_(ULONG)
CSharesPF::AddRef()
{
    CShares* This = IMPL(CShares,m_PersistFolder,this);
    return This->AddRef();
}

STDMETHODIMP_(ULONG)
CSharesPF::Release()
{
    CShares* This = IMPL(CShares,m_PersistFolder,this);
    return This->Release();
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesRC::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    if (IsEqualIID(IID_IRemoteComputer, riid))
    {
        AddRef();
        *ppvObj = (IRemoteComputer*) this;
        hr = S_OK;
    }
    else
    {
        CShares* This = IMPL(CShares,m_RemoteComputer,this);
        hr = This->QueryInterface(riid, ppvObj);
    }

    return hr;
}

STDMETHODIMP_(ULONG)
CSharesRC::AddRef()
{
    CShares* This = IMPL(CShares,m_RemoteComputer,this);
    return This->AddRef();
}

STDMETHODIMP_(ULONG)
CSharesRC::Release()
{
    CShares* This = IMPL(CShares,m_RemoteComputer,this);
    return This->Release();
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesSD::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IShellDetails*) this;
    }
    else if (IsEqualIID(IID_IShellDetails, riid))
    {
        pUnkTemp = (IUnknown*)(IShellDetails*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesSD::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    InterlockedIncrement((LONG*)&m_ulRefs);
    return m_ulRefs;
}

STDMETHODIMP_(ULONG)
CSharesSD::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesCM::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else if (IsEqualIID(IID_IContextMenu, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesCM::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    InterlockedIncrement((LONG*)&m_ulRefs);
    return m_ulRefs;
}

STDMETHODIMP_(ULONG)
CSharesCM::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

#ifdef WIZARDS

STDMETHODIMP
CSharesCMSpecial::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else if (IsEqualIID(IID_IContextMenu, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesCMSpecial::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    InterlockedIncrement((LONG*)&m_ulRefs);
    return m_ulRefs;
}

STDMETHODIMP_(ULONG)
CSharesCMSpecial::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

#endif // WIZARDS

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesCMBG::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else if (IsEqualIID(IID_IContextMenu, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesCMBG::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    InterlockedIncrement((LONG*)&m_ulRefs);
    return m_ulRefs;
}

STDMETHODIMP_(ULONG)
CSharesCMBG::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesEnum::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IEnumIDList*) this;
    }
    else if (IsEqualIID(IID_IEnumIDList, riid))
    {
        pUnkTemp = (IUnknown*)(IEnumIDList*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesEnum::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    InterlockedIncrement((LONG*)&m_ulRefs);
    return m_ulRefs;
}

STDMETHODIMP_(ULONG)
CSharesEnum::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesEI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IExtractIcon*) this;
    }
    else if (IsEqualIID(IID_IExtractIcon, riid))
    {
        pUnkTemp = (IUnknown*)(IExtractIcon*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesEI::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    InterlockedIncrement((LONG*)&m_ulRefs);
    return m_ulRefs;
}

STDMETHODIMP_(ULONG)
CSharesEI::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE

STDMETHODIMP
CSharesEIA::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IExtractIconA*) this;
    }
    else if (IsEqualIID(IID_IExtractIcon, riid))
    {
        pUnkTemp = (IUnknown*)(IExtractIconA*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesEIA::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    InterlockedIncrement((LONG*)&m_ulRefs);
    return m_ulRefs;
}

STDMETHODIMP_(ULONG)
CSharesEIA::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

#endif // UNICODE

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IClassFactory*) this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        pUnkTemp = (IUnknown*)(IClassFactory*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesCF::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    return g_ulcInstances;
}

STDMETHODIMP_(ULONG)
CSharesCF::Release()
{
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return g_ulcInstances;
}

STDMETHODIMP
CSharesCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    if (pUnkOuter != NULL)
    {
        // don't support aggregation
        return E_NOTIMPL;
    }

    CShares* pShare = new CShares();
    if (NULL == pShare)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pShare->QueryInterface(riid, ppvObj);
    pShare->Release();
    return hr;
}

STDMETHODIMP
CSharesCF::LockServer(BOOL fLock)
{
    return S_OK; // FEATURE: Whats supposed to happen here?
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDAPI
DllCanUnloadNow(
    VOID
    )
{
    if (0 == g_ulcInstances
        && 0 == g_NonOLEDLLRefs)
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

CSharesCF cfCShares;

STDAPI
DllGetClassObject(
    REFCLSID cid,
    REFIID iid,
    LPVOID* ppvObj
    )
{
    InterlockedIncrement((LONG*)&g_ulcInstances); // don't nuke me now!

    HRESULT hr = E_NOINTERFACE;

    if (IsEqualCLSID(cid, CLSID_CShares))
    {
        hr = cfCShares.QueryInterface(iid, ppvObj);
    }

    InterlockedDecrement((LONG*)&g_ulcInstances);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\permpage.cxx ===
// PermPage.cxx : Implementation ACL Editor classes
// jonn 7/14/97 copied from \nt\private\windows\shell\lmui\ntshrui\permpage.cpp

#include "headers.hxx"
#pragma hdrstop

#include "acl.hxx"
#include "resource.h" // IDS_SHAREPERM_*

// definition in headers.hxx conflicts with stddef.h (atlbase.h)
#undef offsetof

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

// need IID_ISecurityInformation
#define INITGUID
#include <initguid.h>
#include <aclui.h>

//
// I define my own implementation of ISecurityInformation
//

class CSecurityInformation : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo ) = 0;
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) = 0;
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) = 0;
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags,
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess );
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask);
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes );
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

protected:
	HRESULT NewDefaultDescriptor(
		PSECURITY_DESCRIPTOR* ppsd,
		SECURITY_INFORMATION RequestedInformation
		);

	HRESULT MakeSelfRelativeCopy(
		PSECURITY_DESCRIPTOR  psdOriginal,
		PSECURITY_DESCRIPTOR* ppsdNew );
};

class CShareSecurityInformation : public CSecurityInformation
{
private:
	LPWSTR m_strMachineName;
	LPWSTR m_strShareName;
public:
	void SetMachineName( LPWSTR pszMachineName )
	{
		m_strMachineName = pszMachineName;
	}
	void SetShareName( LPWSTR pszShareName )
	{
		m_strShareName = pszShareName;
	}
	// note: these should be LPCTSTR but are left this way for convenience
	LPWSTR QueryMachineName()
	{
		return m_strMachineName;
	}
	LPWSTR QueryShareName()
	{
		return m_strShareName;
	}

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
};

class CSMBSecurityInformation : public CShareSecurityInformation
{
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );
public:
	PSECURITY_DESCRIPTOR m_pInitialDescriptor;
	PSECURITY_DESCRIPTOR* m_ppCurrentDescriptor;
	CSMBSecurityInformation();
	~CSMBSecurityInformation();
};



// ISecurityInformation interface implementation

SI_ACCESS siShareAccesses[] =
{
    { &GUID_NULL, FILE_ALL_ACCESS,             MAKEINTRESOURCE(IDS_SHAREPERM_ALL),    SI_ACCESS_GENERAL },
    { &GUID_NULL, FILE_GENERIC_WRITE | DELETE, MAKEINTRESOURCE(IDS_SHAREPERM_MODIFY), SI_ACCESS_GENERAL },
    { &GUID_NULL, FILE_GENERIC_READ,           MAKEINTRESOURCE(IDS_SHAREPERM_READ),   SI_ACCESS_GENERAL }
};
#define iShareDefAccess      2   // FILE_GEN_READ
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

STDMETHODIMP CSecurityInformation::GetAccessRights (
                            const GUID* pguidObjectType,
                            DWORD dwFlags,
                            PSI_ACCESS *ppAccess,
                            ULONG *pcAccesses,
                            ULONG *piDefaultAccess )
{
    appAssert(ppAccess != NULL);
    appAssert(pcAccesses != NULL);
    appAssert(piDefaultAccess != NULL);

    *ppAccess = siShareAccesses;
    *pcAccesses = ARRAYSIZE(siShareAccesses);
    *piDefaultAccess = iShareDefAccess;

    return S_OK;
}

// This is consistent with the NETUI code
GENERIC_MAPPING ShareMap =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

STDMETHODIMP CSecurityInformation::MapGeneric (
                       const GUID *pguidObjectType,
                       UCHAR *pAceFlags,
                       ACCESS_MASK *pMask)
{
    appAssert(pMask != NULL);

    MapGenericMask(pMask, &ShareMap);

    return S_OK;
}

STDMETHODIMP CSecurityInformation::GetInheritTypes (
                            PSI_INHERIT_TYPE *ppInheritTypes,
                            ULONG *pcInheritTypes )
{
    appAssert(FALSE);
    return E_NOTIMPL;
}
STDMETHODIMP CSecurityInformation::PropertySheetPageCallback(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage )
{
    return S_OK;
}

/*
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.  This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
*/
STDMETHODIMP CShareSecurityInformation::GetObjectInformation (
    PSI_OBJECT_INFO pObjectInfo )
{
    appAssert(pObjectInfo != NULL &&
           !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

    pObjectInfo->dwFlags = SI_EDIT_ALL | SI_NO_ACL_PROTECT;
    pObjectInfo->hInstance = g_hInstance;
    pObjectInfo->pszServerName = QueryMachineName();
    pObjectInfo->pszObjectName = QueryShareName();

    return S_OK;
}

//
// original code from \\marsslm\backup\src\ncpmgr\ncpmgr\shareacl.cxx
// ACL-wrangling templated from \net\ui\common\src\lmobj\lmobj\security.cxx
//
// caller must free using LocalFree()
//
HRESULT CSecurityInformation::NewDefaultDescriptor(
	PSECURITY_DESCRIPTOR* ppsd,
	SECURITY_INFORMATION RequestedInformation
	)
{
	*ppsd = NULL;
	PSID psidWorld = NULL;
	PSID psidAdmins = NULL;
	ACCESS_ALLOWED_ACE* pace = NULL;
	ACL* pacl = NULL;
	SECURITY_DESCRIPTOR sd;
	HRESULT hr = S_OK;
	do { // false loop
		// build World SID
		SID_IDENTIFIER_AUTHORITY IDAuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;
		if ( !::AllocateAndInitializeSid(
			&IDAuthorityWorld,
			1,
			SECURITY_WORLD_RID,
			0,0,0,0,0,0,0,
			&psidWorld ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

		// build Admins SID
		SID_IDENTIFIER_AUTHORITY IDAuthorityNT = SECURITY_NT_AUTHORITY;
		if ( !::AllocateAndInitializeSid(
			&IDAuthorityNT,
			2,
			SECURITY_BUILTIN_DOMAIN_RID,
			DOMAIN_ALIAS_RID_ADMINS,
			0,0,0,0,0,0,
			&psidAdmins ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

		// build ACE
		DWORD cbSid = ::GetLengthSid(psidWorld);
		if ( 0 == cbSid )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}
		INT cbAce = sizeof(ACCESS_ALLOWED_ACE) + cbSid;
		pace = reinterpret_cast<ACCESS_ALLOWED_ACE*>(new BYTE[ cbAce+10 ]);
		if ( NULL == pace )
		{
			appAssert( FALSE );
			hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			break;
		}
		::memset((BYTE*)pace,0,cbAce+10);
		pace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;   // SetType()
		pace->Header.AceFlags = 0;                        // SetInheritFlags()
		pace->Header.AceSize = (WORD)cbAce;               // SetSize() (in SetSID())
		pace->Mask = GENERIC_ALL;                         // SetAccessMask()
		::memcpy( &(pace->SidStart), psidWorld, cbSid );  // SetSID()

		// build ACL
		DWORD cbAcl = sizeof(ACL) + cbAce + 10;
		pacl = reinterpret_cast<ACL*>(new BYTE[ cbAcl ]);
		if ( NULL == pacl )
		{
			appAssert( FALSE );
			hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			break;
		}
		::memset((BYTE*)pacl,0,cbAcl);
		if ( !::InitializeAcl( pacl, cbAcl, ACL_REVISION2 ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}
		if ( !::AddAce( pacl, ACL_REVISION2, 0, pace, cbAce ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

		// build security descriptor in absolute format
		if ( !::InitializeSecurityDescriptor(
			&sd,
			SECURITY_DESCRIPTOR_REVISION ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}
		if (   !::SetSecurityDescriptorOwner( &sd, psidAdmins, FALSE )
			|| !::SetSecurityDescriptorGroup( &sd, psidAdmins, FALSE )
			|| !::SetSecurityDescriptorDacl(  &sd, TRUE, pacl, FALSE )
		   )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

		// convert security descriptor to self-relative format
		DWORD cbSD = 0;
		// this call should fail and set cbSD to the correct size
		if ( ::MakeSelfRelativeSD( &sd, NULL, &cbSD ) || 0 == cbSD )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}
		*ppsd = reinterpret_cast<PSECURITY_DESCRIPTOR>(
			::LocalAlloc( LMEM_ZEROINIT, cbSD + 20 ) );

        if (!*ppsd)
        {
			hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			break;
		}
        ::memset( (BYTE*)*ppsd, 0, cbSD + 20 );
		if ( !::MakeSelfRelativeSD( &sd, *ppsd, &cbSD ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

	} while (FALSE); // false loop

	// clean up
	if ( NULL != psidWorld ) {
		(void)::FreeSid( psidWorld );
	}
	if ( NULL != psidAdmins ) {
		(void)::FreeSid( psidAdmins );
	}
	delete pace;
	delete pacl;

	return hr;
}

HRESULT CSecurityInformation::MakeSelfRelativeCopy(
	PSECURITY_DESCRIPTOR  psdOriginal,
	PSECURITY_DESCRIPTOR* ppsdNew )
{
	appAssert( NULL != psdOriginal );

	// we have to find out whether the original is already self-relative
	SECURITY_DESCRIPTOR_CONTROL sdc = 0;
	DWORD dwRevision = 0;
	if ( !::GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) )
	{
		appAssert( FALSE );
		DWORD err = ::GetLastError();
		return HRESULT_FROM_WIN32( err );
	}

	DWORD cb = ::GetSecurityDescriptorLength( psdOriginal ) + 20;
	PSECURITY_DESCRIPTOR psdSelfRelativeCopy = reinterpret_cast<PSECURITY_DESCRIPTOR>(
		::LocalAlloc(LMEM_ZEROINIT, cb) );
	if (NULL == psdSelfRelativeCopy)
	{
		return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}

	if ( sdc & SE_SELF_RELATIVE )
	// the original is in self-relative format, just byte-copy it
	{
		::memcpy( psdSelfRelativeCopy, psdOriginal, cb - 20 );
	}
	else if ( !::MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) )
	// the original is in absolute format, convert-copy it
	{
		appAssert( FALSE );
		if( NULL != ::LocalFree( psdSelfRelativeCopy ) )
		{
			appAssert(FALSE);
		}
		DWORD err = ::GetLastError();
		return HRESULT_FROM_WIN32( err );
	}
	*ppsdNew = psdSelfRelativeCopy;
	return S_OK;
}

CSMBSecurityInformation::CSMBSecurityInformation()
: CShareSecurityInformation()
, m_pInitialDescriptor( NULL )
, m_ppCurrentDescriptor( NULL )
{
}

CSMBSecurityInformation::~CSMBSecurityInformation()
{
}

STDMETHODIMP CSMBSecurityInformation::GetSecurity (
                        SECURITY_INFORMATION RequestedInformation,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                        BOOL fDefault )
{
	appAssert( NULL != m_ppCurrentDescriptor );

	// NOTE: we allow NULL == ppSecurityDescriptor, see SetSecurity
    if (0 == RequestedInformation )
    {
        appAssert(FALSE);
        return E_INVALIDARG;
    }

    if (fDefault)
        return E_NOTIMPL;

	if ( NULL == ppSecurityDescriptor )
		return S_OK;

	*ppSecurityDescriptor = NULL;

	HRESULT hr = S_OK;
	if (NULL != *m_ppCurrentDescriptor)
	{
		hr = MakeSelfRelativeCopy(
			*m_ppCurrentDescriptor,
			ppSecurityDescriptor );
		appAssert( SUCCEEDED(hr) && NULL != *ppSecurityDescriptor );
	}
	else if (NULL != m_pInitialDescriptor)
	{
		hr = MakeSelfRelativeCopy(
			m_pInitialDescriptor,
			ppSecurityDescriptor );
		appAssert( SUCCEEDED(hr) && NULL != *ppSecurityDescriptor );
	}
	else
	{
		hr = NewDefaultDescriptor(
			ppSecurityDescriptor,
			RequestedInformation );
		appAssert( SUCCEEDED(hr) && NULL != *ppSecurityDescriptor );
	}
	return hr;
}

STDMETHODIMP CSMBSecurityInformation::SetSecurity (
                        SECURITY_INFORMATION SecurityInformation,
                        PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
	appAssert( NULL != m_ppCurrentDescriptor );

	if (NULL != *m_ppCurrentDescriptor)
	{
		::LocalFree(*m_ppCurrentDescriptor);
		*m_ppCurrentDescriptor = NULL;
	}
	HRESULT hr = MakeSelfRelativeCopy(
		pSecurityDescriptor,
		m_ppCurrentDescriptor );
	appAssert( SUCCEEDED(hr) && NULL != *m_ppCurrentDescriptor );
	return hr;
}

HMODULE g_hlibACLUI = NULL;
typedef BOOL (*EDIT_SECURITY_PROC) ( HWND, LPSECURITYINFO );
EDIT_SECURITY_PROC g_pfnEditSecurityProc;

LONG
EditShareAcl(
    IN HWND                      hwndParent,
    IN LPWSTR                    pszServerName,
    IN TCHAR *                   pszShareName,
    IN PSECURITY_DESCRIPTOR      pSecDesc,
    OUT BOOL*                    pfSecDescModified,
    OUT PSECURITY_DESCRIPTOR*    ppSecDesc
	)
{
	appAssert( ppSecDesc != NULL );
	*ppSecDesc = NULL;

	if (NULL == g_hlibACLUI)
	{
		g_hlibACLUI = ::LoadLibrary(L"ACLUI.DLL");
		if (NULL == g_hlibACLUI)
		{
			appAssert(FALSE); // ACLUI.DLL isn't installed?
			return 0;
		}
	}

	if (NULL == g_pfnEditSecurityProc)
	{
		g_pfnEditSecurityProc = reinterpret_cast<EDIT_SECURITY_PROC>(
			::GetProcAddress(g_hlibACLUI,"EditSecurity") );
		if (NULL == g_pfnEditSecurityProc)
		{
			appAssert(FALSE); // ACLUI.DLL is invalid?
			return 0;
		}
	}

	CComObject<CSMBSecurityInformation>* psecinfo = NULL;
	HRESULT hRes = CComObject<CSMBSecurityInformation>::CreateInstance(&psecinfo);
	if ( FAILED(hRes) )
		return 0;

	psecinfo->AddRef();
	psecinfo->SetMachineName( pszServerName );
	psecinfo->SetShareName( pszShareName );
	psecinfo->m_pInitialDescriptor = pSecDesc;
	psecinfo->m_ppCurrentDescriptor = ppSecDesc;
	(g_pfnEditSecurityProc)(hwndParent,psecinfo);

	if (NULL != pfSecDescModified)
		*pfSecDescModified = (NULL != *ppSecDesc);

	psecinfo->Release();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//

#include <shlobj.h>
#include <shlobjp.h>

#define IDS_APP_MSG_NOT_FOUND           100
#define IDS_NET_MSG_NOT_FOUND           101
#define IDS_NO_NET_MSG                  102
#define IDS_MSGTITLE                    103
#define IDS_SHARE_MENUHELP              105
#define IDS_ACLEDIT_PERM_GEN_NO_ACCESS  106
#define IDS_ACLEDIT_PERM_GEN_READ       107
#define IDS_ACLEDIT_PERM_GEN_MODIFY     108
#define IDS_ACLEDIT_PERM_GEN_ALL        109
#define IDS_ACLEDIT_TITLE               110
#define IDS_HELPFILENAME                111
#define IDS_NAME                        112
#define IDS_COMMENT                     113
#define IDS_PATH                        114
#define IDS_MAXUSES                     115
#define IDS_UNLIMITED                   116
#define IDS_SHARE_PROPTITLE             117
#ifdef WIZARDS
#define IDS_SHARE_NEW                   118
#define IDS_SHARE_NW                    119
#define IDS_SHARE_MAC                   120
#define IDS_SHARE_ALL                   121
#endif // WIZARDS
#define IDS_SUREUNINST                  122
#define IDS_SHAREPERM_READ              123
#define IDS_SHAREPERM_MODIFY            124
#define IDS_SHAREPERM_ALL               125
#define IDI_SHARESFLD                   200
#define IDI_SHARE                       201
#ifdef WIZARDS
#define IDI_NEWSHARE                    202
#define IDI_NWSHARE                     203
#define IDI_MACSHARE                    204
#define IDI_ALLSHARE                    205
#endif // WIZARDS
#define IDI_IPC                         206
#define POPUP_SHARESBG_MERGE            300
#define POPUP_SHARESBG_POPUPMERGE1      301
#define POPUP_SHARESBG_POPUPMERGE2      302
#define POPUP_SHARE                     303
#ifdef WIZARDS
#define POPUP_SPECIAL                   304
#define POPUP_SPECIAL_FILE              305
#endif // WIZARDS
#define IDD_SHARE_PROPERTIES            1000
#define IDC_SHARE_SHARENAME             1001
#define IDC_SHARE_COMMENT               1002
#define IDC_SHARE_SHARENAME_TEXT        1003
#define IDC_SHARE_COMMENT_TEXT          1004
#define IDC_SHARE_LIMIT                 1005
#define IDC_SHARE_MAXIMUM               1006
#define IDC_SHARE_ALLOW                 1007
#define IDC_SHARE_PERMISSIONS           1008
#define IDC_SHARE_USERS_TEXT            1009
#define IDC_SHARE_ALLOW_SPIN            1010
#define IDC_SHARE_ALLOW_VALUE           1011
#define IDC_SHARE_PATH_TEXT             1012
#define IDC_SHARE_PATH                  1013
#define IDD_NEW_SHARE                   1018

#define FSIDM_SORT_FIRST                0x0030
#define FSIDM_SORTBYNAME                (FSIDM_SORT_FIRST + 0x0009)
#define FSIDM_SORTBYCOMMENT             (FSIDM_SORT_FIRST + 0x000a)
#define FSIDM_SORTBYPATH                (FSIDM_SORT_FIRST + 0x000b)
#define FSIDM_SORTBYMAXUSES             (FSIDM_SORT_FIRST + 0x000c)

#define FSIDM_MENU_NEW                  0x0060
#define FSIDM_NEWSHARE                  (FSIDM_MENU_NEW + 0x0003)

#define FSIDM_MENU_OPEN                 0x0070
#ifdef WIZARDS
#define FSIDM_OPENSPECIAL               (FSIDM_MENU_OPEN + 0x0001)
#endif // WIZARDS

#define IDS_MH_FSIDM_FIRST              2000
#define IDS_MH_FSIDM_LAST               2999

#define IDS_MH_SORTBYNAME               (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYNAME)
#define IDS_MH_SORTBYCOMMENT            (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYCOMMENT)
#define IDS_MH_SORTBYPATH               (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYPATH)
#define IDS_MH_SORTBYMAXUSES            (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYMAXUSES)
#define IDS_MH_MENU_NEW                 (IDS_MH_FSIDM_FIRST + FSIDM_MENU_NEW)
#define IDS_MH_NEWSHARE                 (IDS_MH_FSIDM_FIRST + FSIDM_NEWSHARE)

#define IDS_MH_DELETE                   (IDS_MH_FSIDM_FIRST + SHARED_FILE_DELETE)
#define IDS_MH_PROPERTIES               (IDS_MH_FSIDM_FIRST + SHARED_FILE_PROPERTIES)

#ifdef WIZARDS
#define IDS_MH_OPENSPECIAL              (IDS_MH_FSIDM_FIRST + FSIDM_OPENSPECIAL)
#endif // WIZARDS
#define IDS_MH_FILE_LINK                (IDS_MH_FSIDM_FIRST + SHARED_FILE_LINK)
#define IDS_MH_FILE_RENAME              (IDS_MH_FSIDM_FIRST + SHARED_FILE_RENAME)

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        126
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\sdetails.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       sdetails.cxx
//
//  Contents:   Implementation of IShellDetails
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "sdetails.hxx"
#include "shares.h"
#include "shares.hxx"
#include "resource.h"
#include "util.hxx"

//////////////////////////////////////////////////////////////////////////////

//
// Define the columns that we know about...
//

struct COL_INFO
{
    UINT idString;
    int  fmt;
    UINT cxChar;
};

const COL_INFO c_ColumnHeaders1[] =
{
    {IDS_NAME,    LVCFMT_LEFT, 25},
    {IDS_COMMENT, LVCFMT_LEFT, 30},
};

const COL_INFO c_ColumnHeaders2[] =
{
    {IDS_NAME,    LVCFMT_LEFT, 25},
    {IDS_COMMENT, LVCFMT_LEFT, 30},
    {IDS_PATH,    LVCFMT_LEFT, 30},
    {IDS_MAXUSES, LVCFMT_LEFT, 15},
};

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesSD::GetDetailsOf(
    LPCITEMIDLIST pidl,
    UINT iColumn,
    LPSHELLDETAILS lpDetails
    )
{
    switch (m_level)
    {
    case 1: return GetDetailsOf1(pidl, iColumn, lpDetails);
    case 2: return GetDetailsOf2(pidl, iColumn, lpDetails);
    default: appAssert(FALSE); return E_FAIL;
    }
}

STDMETHODIMP
CSharesSD::GetDetailsOf1(
    LPCITEMIDLIST pidl,
    UINT iColumn,
    LPSHELLDETAILS lpDetails
    )
{
    if (iColumn >= ICOL1_MAX)
    {
        return E_NOTIMPL;
    }

    HRESULT hr;
    LPIDSHARE pids = (LPIDSHARE)pidl;
    if (NULL == pids)
    {
        hr = STRRETLoadString(c_ColumnHeaders1[iColumn].idString, &lpDetails->str);
        if (FAILED(hr))
        {
            return hr;
        }

        lpDetails->fmt    = c_ColumnHeaders1[iColumn].fmt;
        lpDetails->cxChar = c_ColumnHeaders1[iColumn].cxChar;
        return NOERROR;
    }

#ifdef WIZARDS

    if (   Share_IsNewShareWizard(pids)
        || Share_IsNetWareWizard(pids)
        || Share_IsMacWizard(pids)
        )
    {
        switch (iColumn)
        {
        case ICOL1_NAME:
            hr = STRRETCopy(Share_GetName(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL1_COMMENT:
            lpDetails->str.uType = STRRET_CSTR;
            lpDetails->str.cStr[0] = '\0';
            break;
        }
    }
    else
#endif // WIZARDS
    {
        appAssert(Share_GetLevel(pids) == 1);

        switch (iColumn)
        {
        case ICOL1_NAME:
            hr = STRRETCopy(Share_GetName(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL1_COMMENT:
            hr = STRRETCopy(Share_GetComment(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;
        }
    }

    return NOERROR;
}

STDMETHODIMP
CSharesSD::GetDetailsOf2(
    LPCITEMIDLIST pidl,
    UINT iColumn,
    LPSHELLDETAILS lpDetails
    )
{
    if (iColumn >= ICOL2_MAX)
    {
        return E_NOTIMPL;
    }

    HRESULT hr;
    LPIDSHARE pids = (LPIDSHARE)pidl;
    if (NULL == pids)
    {
        hr = STRRETLoadString(c_ColumnHeaders2[iColumn].idString, &lpDetails->str);
        if (FAILED(hr))
        {
            return hr;
        }

        lpDetails->fmt    = c_ColumnHeaders2[iColumn].fmt;
        lpDetails->cxChar = c_ColumnHeaders2[iColumn].cxChar;
        return NOERROR;
    }

#ifdef WIZARDS
    if (   Share_IsNewShareWizard(pids)
        || Share_IsNetWareWizard(pids)
        || Share_IsMacWizard(pids)
        )
    {
        switch (iColumn)
        {
        case ICOL2_NAME:
            hr = STRRETCopy(Share_GetName(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL2_COMMENT:
            lpDetails->str.uType = STRRET_CSTR;
            lpDetails->str.cStr[0] = '\0';
            break;
        }
    }
    else
#endif // WIZARDS
    {
        appAssert(Share_GetLevel(pids) == 2);

        switch (iColumn)
        {
        case ICOL2_NAME:
            hr = STRRETCopy(Share_GetName(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL2_COMMENT:
            hr = STRRETCopy(Share_GetComment(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL2_PATH:
            hr = STRRETCopy(Share_GetPath(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL2_MAXUSES:
        {
            DWORD maxuses = Share_GetMaxUses(pids);
            if (maxuses == SHI_USES_UNLIMITED)
            {
                hr = STRRETLoadString(IDS_UNLIMITED, &lpDetails->str);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            else
            {
                TCHAR szTemp[MAX_PATH];
                wsprintf(szTemp, TEXT("%d"), maxuses);
                hr = STRRETCopy(szTemp, &lpDetails->str);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            break;
        }

        }
    }

    return NOERROR;
}

STDMETHODIMP
CSharesSD::ColumnClick(
    UINT iColumn
    )
{
    ShellFolderView_ReArrange(m_hwnd, iColumn);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\rcomp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       rcomp.cxx
//
//  Contents:   Implementation of IRemoteComputer
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "guids.h"
#include "rcomp.hxx"
#include "shares.hxx"
#include "util.hxx"

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesRC::Initialize(
    LPCWSTR pszMachine,
    BOOL bEnumerating
    )
{
    CShares* This = IMPL(CShares,m_RemoteComputer,this);

    if (NULL == pszMachine)
    {
        return E_INVALIDARG;
    }

    //
    // We only want to show the remote shares folder if it is an NT
    // server and the user has administrative access. That means that
    // NetShareEnum must pass at least level 2.
    //

    if (bEnumerating)
    {
        if (!IsLevelOk(const_cast<LPWSTR>(pszMachine), 2))
        {
            return E_FAIL;
        }
    }

    This->m_pszMachine = NewDup(pszMachine);
    if (NULL == This->m_pszMachine)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\shitemid.h ===
#ifndef _WINNETWK_
#include <winnetwk.h>
#endif // _WINNETWK_

#define SHID_JUNCTION           0x80

#define SHID_GROUPMASK          0x70
#define SHID_TYPEMASK           0x7f
#define SHID_INGROUPMASK        0x0f

#define SHID_ROOT               0x10
#define SHID_ROOT_REGITEM       0x1f    // Mail

#if ((DRIVE_REMOVABLE|DRIVE_FIXED|DRIVE_REMOTE|DRIVE_CDROM|DRIVE_RAMDISK) != 0x07)
#error Definitions of DRIVE_* are changed!
#endif

#define SHID_COMPUTER           0x20
#define SHID_COMPUTER_1         0x21    // free
#define SHID_COMPUTER_REMOVABLE (0x20 | DRIVE_REMOVABLE)  // 2
#define SHID_COMPUTER_FIXED     (0x20 | DRIVE_FIXED)      // 3
#define SHID_COMPUTER_REMOTE    (0x20 | DRIVE_REMOTE)     // 4
#define SHID_COMPUTER_CDROM     (0x20 | DRIVE_CDROM)      // 5
#define SHID_COMPUTER_RAMDISK   (0x20 | DRIVE_RAMDISK)    // 6
#define SHID_COMPUTER_7         0x27    // free
#define SHID_COMPUTER_DRIVE525  0x28    // 5.25 inch floppy disk drive
#define SHID_COMPUTER_DRIVE35   0x29    // 3.5 inch floppy disk drive
#define SHID_COMPUTER_NETDRIVE  0x2a    // Network drive
#define SHID_COMPUTER_NETUNAVAIL 0x2b   // Network drive that is not restored.
#define SHID_COMPUTER_C         0x2c    // free
#define SHID_COMPUTER_D         0x2d    // free
#define SHID_COMPUTER_REGITEM   0x2e    // Controls, Printers, ...
#define SHID_COMPUTER_MISC      0x2f    // Unknown drive type

#define SHID_FS                 0x30
#define SHID_FS_TYPEMASK        0x3F
#define SHID_FS_DIRECTORY       0x31    // CHICAGO
#define SHID_FS_FILE            0x32    // FOO.TXT
#define SHID_FS_UNICODE         0x34    // Is it unicode? (this is a bitmask)
#define SHID_FS_DIRUNICODE      0x35    // Folder with a unicode name
#define SHID_FS_FILEUNICODE     0x36    // File with a unicode name

#define SHID_NET                0x40    
#define SHID_NET_DOMAIN         (SHID_NET | RESOURCEDISPLAYTYPE_DOMAIN)
#define SHID_NET_SERVER         (SHID_NET | RESOURCEDISPLAYTYPE_SERVER)
#define SHID_NET_SHARE          (SHID_NET | RESOURCEDISPLAYTYPE_SHARE)
#define SHID_NET_FILE           (SHID_NET | RESOURCEDISPLAYTYPE_FILE)
#define SHID_NET_GROUP          (SHID_NET | RESOURCEDISPLAYTYPE_GROUP)
#define SHID_NET_NETWORK        (SHID_NET | RESOURCEDISPLAYTYPE_NETWORK)
#define SHID_NET_RESTOFNET      (SHID_NET | RESOURCEDISPLAYTYPE_ROOT)
#define SHID_NET_SHAREADMIN     (SHID_NET | RESOURCEDISPLAYTYPE_SHAREADMIN)
#define SHID_NET_DIRECTORY      (SHID_NET | RESOURCEDISPLAYTYPE_DIRECTORY)
#define SHID_NET_TREE           (SHID_NET | RESOURCEDISPLAYTYPE_TREE)
#define SHID_NET_REGITEM        0x4e    // Remote Computer items
#define SHID_NET_PRINTER        0x4f    // \\PYREX\LASER1

#define SIL_GetType(pidl)       (ILIsEmpty(pidl) ? 0 : (pidl)->mkid.abID[0])
#define FS_IsValidID(pidl)      ((SIL_GetType(pidl) & SHID_GROUPMASK) == SHID_FS)
#define NET_IsValidID(pidl)     ((SIL_GetType(pidl) & SHID_GROUPMASK) == SHID_NET)

typedef struct _ICONMAP // icmp
{
    UINT        uType;                  // SHID_ type
    UINT        indexResource;          // Resource index (of SHELL232.DLL)
} ICONMAP, FAR* LPICONMAP;

UINT SILGetIconIndex(LPCITEMIDLIST pidl, const ICONMAP aicmp[], UINT cmax);

#pragma pack(1)
typedef struct _IDNETRESOURCE   // idn
{
        WORD    cb;
        BYTE    bFlags;         // Display type in low nibble
        BYTE    uType;
        BYTE    uUsage;         // Usage in low nibble, More Flags in high nibble
        CHAR    szNetResName[1];
        // char szProvider[*] - If NET_HASPROVIDER bit is set
        // char szComment[*]  - If NET_HASCOMMENT bit is set.
        // WCHAR szNetResNameWide[*] - If NET_UNICODE bit it set.
        // WCHAR szProviderWide[*]   - If NET_UNICODE and NET_HASPROVIDER
        // WCHAR szCommentWide[*]    - If NET_UNICODE and NET_HASCOMMENT
} IDNETRESOURCE, *LPIDNETRESOURCE;
typedef const IDNETRESOURCE *LPCIDNETRESOURCE;
#pragma pack()

//===========================================================================
// CNetwork: Some private macro
//===========================================================================

#define NET_DISPLAYNAMEOFFSET           ((UINT)((LPIDNETRESOURCE)0)->szNetResName)
#define NET_GetFlags(pidnRel)           ((pidnRel)->bFlags)
#define NET_GetDisplayType(pidnRel)     ((pidnRel)->bFlags & 0x0f)
#define NET_GetType(pidnRel)            ((pidnRel)->uType)
#define NET_GetUsage(pidnRel)           ((pidnRel)->uUsage & 0x0f)

// Define some Flags that are on high nibble of uUsage byte
#define NET_HASPROVIDER                 0x80    // Has own copy of provider
#define NET_HASCOMMENT                  0x40    // Has comment field in pidl
#define NET_REMOTEFLD                   0x20    // Is remote folder
#define NET_UNICODE                     0x10    // Has unicode names
#define NET_FHasComment(pidnRel)        ((pidnRel)->uUsage & NET_HASCOMMENT)
#define NET_FHasProvider(pidnRel)        ((pidnRel)->uUsage & NET_HASPROVIDER)
#define NET_IsRemoteFld(pidnRel)        ((pidnRel)->uUsage & NET_REMOTEFLD)
#define NET_IsUnicode(pidnRel)          ((pidnRel)->uUsage & NET_UNICODE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\shrinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       shrinfo.cxx
//
//  Contents:   Lanman SHARE_INFO_502 encapsulation
//
//  History:    21-Feb-95   BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "shrinfo.hxx"
#include "util.hxx"

CShareInfo::CShareInfo(
    VOID
    )
    :
    m_bOwn(TRUE),
    m_flags(0),
    m_pInfo(NULL)
{
    INIT_SIG(CShareInfo);
}

CShareInfo::CShareInfo(
    IN SHARE_INFO_502* pInfo
    )
    :
    m_bOwn(FALSE),
    m_flags(0),
    m_pInfo(pInfo)
{
    INIT_SIG(CShareInfo);
}

HRESULT
CShareInfo::InitInstance(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        appAssert(m_pInfo == NULL);

        m_pInfo = new SHARE_INFO_502;
        if (NULL == m_pInfo)
        {
            return E_OUTOFMEMORY;
        }

        m_pInfo->shi502_netname       = NULL;
        m_pInfo->shi502_type          = STYPE_DISKTREE;
        m_pInfo->shi502_remark        = NULL;
        m_pInfo->shi502_permissions   = ACCESS_ALL;
        m_pInfo->shi502_max_uses      = SHI_USES_UNLIMITED;
        m_pInfo->shi502_path          = NULL;
        m_pInfo->shi502_passwd        = NULL;
        m_pInfo->shi502_reserved      = 0;
        m_pInfo->shi502_security_descriptor = NULL;
    }

    return S_OK;
}

CShareInfo::~CShareInfo()
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        if (NULL != m_pInfo)    // must check; InitInstance might have failed
        {
			if ( m_pInfo->shi502_netname )
				delete[] m_pInfo->shi502_netname;
			if ( m_pInfo->shi502_remark )
				delete[] m_pInfo->shi502_remark;
			if ( m_pInfo->shi502_path )
				delete[] m_pInfo->shi502_path;
			if ( m_pInfo->shi502_passwd )
				delete[] m_pInfo->shi502_passwd;
			if ( m_pInfo->shi502_security_descriptor )
				::LocalFree( (BYTE*)m_pInfo->shi502_security_descriptor );
            delete m_pInfo;
        }
    }
}

NET_API_STATUS
CShareInfo::Commit(
    IN PWSTR pszMachine
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if (m_flags == 0)
    {
        // nothing changed
        appDebugOut((DEB_ITRACE, "CShareInfo::Commit: nothing (%ws)\n", m_pInfo->shi502_netname));
        return NERR_Success;
    }

// #if DBG == 1
//     Dump(L"Commit");
// #endif // DBG == 1

    NET_API_STATUS ret;

    // Note: we store a path, even for admin$. However, the NetShare* APIs
    // don't like seeing a path for admin$, so we temporarily strip it here
    // if necessary, before calling any APIs.

    LPWSTR pszPathTmp = m_pInfo->shi502_path;
    if (0 == _wcsicmp(g_szAdminShare, m_pInfo->shi502_netname))
    {
        m_pInfo->shi502_path = NULL;
    }

    if (SHARE_FLAG_ADDED == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: add (%ws)\n", m_pInfo->shi502_netname));
        ret = NetShareAdd(pszMachine, 502, (LPBYTE)m_pInfo, NULL);
    }
    else if (SHARE_FLAG_REMOVE == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: remove (%ws)\n", m_pInfo->shi502_netname));
        ret = NetShareDel(pszMachine, m_pInfo->shi502_netname, 0);
    }
    else if (SHARE_FLAG_MODIFY == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: modify (%ws)\n", m_pInfo->shi502_netname));
        DWORD parm_err;
        ret = NetShareSetInfo(pszMachine, m_pInfo->shi502_netname, 502, (LPBYTE)m_pInfo, &parm_err);
    }

    // Restore the original, in case of admin$
    m_pInfo->shi502_path = pszPathTmp;

    // Must refresh the cache of shares after all commits
    if (ret != NERR_Success)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: err = %d\n", ret));
    }

    return ret;
}

SHARE_INFO_502*
CShareInfo::GetShareInfo(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo;
}

PWSTR
CShareInfo::GetNetname(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_netname;
}

DWORD
CShareInfo::GetType(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_type;
}

PWSTR
CShareInfo::GetRemark(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_remark;
}

DWORD
CShareInfo::GetMaxUses(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_max_uses;
}

PWSTR
CShareInfo::GetPassword(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_passwd;
}

PWSTR
CShareInfo::GetPath(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_path;
}

PSECURITY_DESCRIPTOR
CShareInfo::GetSecurityDescriptor(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_security_descriptor;
}

HRESULT
CShareInfo::SetNetname(
    IN PWSTR pszNetname
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetNetname() = '%ws'\n",
        pszNetname));

	if ( m_pInfo->shi502_netname )
		delete[] m_pInfo->shi502_netname;
    m_pInfo->shi502_netname = NewDup(pszNetname);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetType(
    IN DWORD dwType
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (dwType != m_pInfo->shi502_type)
    {
        // only take ownership and set the data if it's changed!

        if (!TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        appDebugOut((DEB_ITRACE,
            "CShareInfo::SetType(%ws) = %d\n",
            m_pInfo->shi502_netname,
            dwType));

        m_pInfo->shi502_type = dwType;

        if (m_flags != SHARE_FLAG_ADDED)
        {
            m_flags = SHARE_FLAG_MODIFY;
        }
    }

    return S_OK;
}

HRESULT
CShareInfo::SetRemark(
    IN PWSTR pszRemark
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetRemark(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszRemark));

	if ( m_pInfo->shi502_remark )
		delete[] m_pInfo->shi502_remark;
    m_pInfo->shi502_remark = NewDup(pszRemark);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetMaxUses(
    IN DWORD dwMaxUses
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (dwMaxUses != m_pInfo->shi502_max_uses)
    {
        // only take ownership and set the data if it's changed!

        if (!TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        appDebugOut((DEB_ITRACE,
            "CShareInfo::SetMaxUses(%ws) = %d\n",
            m_pInfo->shi502_netname,
            dwMaxUses));

        m_pInfo->shi502_max_uses = dwMaxUses;

        if (m_flags != SHARE_FLAG_ADDED)
        {
            m_flags = SHARE_FLAG_MODIFY;
        }
    }

    return S_OK;
}

HRESULT
CShareInfo::SetPassword(
    IN PWSTR pszPassword
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetPassword(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszPassword));

	if ( m_pInfo->shi502_passwd )
		delete[] m_pInfo->shi502_passwd;
    m_pInfo->shi502_passwd = NewDup(pszPassword);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetPath(
    IN PWSTR pszPath
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetPath(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszPath));

	if ( m_pInfo->shi502_path )
		delete[] m_pInfo->shi502_path;
    if (pszPath[0] == TEXT('\0'))
    {
        m_pInfo->shi502_path = NULL;    // so IPC$ and ADMIN$ work
    }
    else
    {
        m_pInfo->shi502_path = NewDup(pszPath);
    }

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetSecurityDescriptor(%ws) = ...\n",
        m_pInfo->shi502_netname));

	if ( m_pInfo->shi502_security_descriptor )
		::LocalFree( (BYTE*)m_pInfo->shi502_security_descriptor );
    m_pInfo->shi502_security_descriptor = CopySecurityDescriptor(pSecDesc);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}


HRESULT
CShareInfo::TransferSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::TransferSecurityDescriptor(%ws) = ...\n",
        m_pInfo->shi502_netname));

	if ( m_pInfo->shi502_security_descriptor )
		::LocalFree( (BYTE*)m_pInfo->shi502_security_descriptor );
    m_pInfo->shi502_security_descriptor = pSecDesc;

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

ULONG
CShareInfo::GetFlag(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    return m_flags;
}

VOID
CShareInfo::SetDirtyFlag(
    ULONG flag
    )
{
    CHECK_SIG(CShareInfo);

    m_flags = flag;
}

HRESULT
CShareInfo::Copy(
    IN SHARE_INFO_502* pInfo
    )
{
    CHECK_SIG(CShareInfo);

    // get a valid SHARE_INFO_502 structure...

    if (m_bOwn)
    {
        // delete what's already there

        appAssert(NULL != m_pInfo);

		if ( m_pInfo->shi502_netname )
			delete[] m_pInfo->shi502_netname;
		if ( m_pInfo->shi502_remark )
			delete[] m_pInfo->shi502_remark;
		if ( m_pInfo->shi502_path )
			delete[] m_pInfo->shi502_path;
		if ( m_pInfo->shi502_passwd )
	        delete[] m_pInfo->shi502_passwd;
		if ( m_pInfo->shi502_security_descriptor )
			::LocalFree( (BYTE*)m_pInfo->shi502_security_descriptor );
    }
    else
    {
        m_pInfo = new SHARE_INFO_502;
        if (NULL == m_pInfo)
        {
            return E_OUTOFMEMORY;
        }
    }

    appAssert(NULL != m_pInfo);

    m_bOwn = TRUE;

    m_pInfo->shi502_netname       = NULL;
    m_pInfo->shi502_type          = pInfo->shi502_type;
    m_pInfo->shi502_remark        = NULL;
    m_pInfo->shi502_permissions   = pInfo->shi502_permissions;
    m_pInfo->shi502_max_uses      = pInfo->shi502_max_uses;
    m_pInfo->shi502_path          = NULL;
    m_pInfo->shi502_passwd        = NULL;
    m_pInfo->shi502_reserved      = pInfo->shi502_reserved;
    m_pInfo->shi502_security_descriptor = NULL;

    if (NULL != pInfo->shi502_netname)
    {
        m_pInfo->shi502_netname = NewDup(pInfo->shi502_netname);
    }
    if (NULL != pInfo->shi502_remark)
    {
        m_pInfo->shi502_remark = NewDup(pInfo->shi502_remark);
    }
    if (NULL != pInfo->shi502_path)
    {
        m_pInfo->shi502_path = NewDup(pInfo->shi502_path);
    }
    if (NULL != pInfo->shi502_passwd)
    {
        m_pInfo->shi502_passwd = NewDup(pInfo->shi502_passwd);
    }

    if (NULL != pInfo->shi502_security_descriptor)
    {
        m_pInfo->shi502_security_descriptor = CopySecurityDescriptor(pInfo->shi502_security_descriptor);
    }

    return S_OK;
}

BOOL
CShareInfo::TakeOwn(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        return TRUE;    // already own the memory
    }

    SHARE_INFO_502* pInfo = new SHARE_INFO_502;
    if (NULL == pInfo)
    {
        return FALSE;
    }

    pInfo->shi502_type          = m_pInfo->shi502_type;
    pInfo->shi502_permissions   = m_pInfo->shi502_permissions;
    pInfo->shi502_max_uses      = m_pInfo->shi502_max_uses;
    pInfo->shi502_reserved      = 0;

    pInfo->shi502_netname = NULL;
    if (NULL != m_pInfo->shi502_netname)
    {
        pInfo->shi502_netname = NewDup(m_pInfo->shi502_netname);
    }

    pInfo->shi502_remark  = NULL;
    if (NULL != m_pInfo->shi502_remark)
    {
        pInfo->shi502_remark = NewDup(m_pInfo->shi502_remark);
    }

    pInfo->shi502_path    = NULL;
    if (NULL != m_pInfo->shi502_path)
    {
        pInfo->shi502_path = NewDup(m_pInfo->shi502_path);
    }

    pInfo->shi502_passwd  = NULL;
    if (NULL != m_pInfo->shi502_passwd)
    {
        pInfo->shi502_passwd = NewDup(m_pInfo->shi502_passwd);
    }

    pInfo->shi502_security_descriptor = NULL;
    if (NULL != m_pInfo->shi502_security_descriptor)
    {
        pInfo->shi502_security_descriptor = CopySecurityDescriptor(m_pInfo->shi502_security_descriptor);
    }

    m_pInfo = pInfo;
    m_bOwn = TRUE;

#if DBG == 1
    Dump(L"After TakeOwn");
#endif // DBG == 1

    return TRUE;
}


#if DBG == 1

VOID
CShareInfo::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CShareInfo);

    appDebugOut((DEB_TRACE,
        "CShareInfo::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t       This: 0x%08lx\n"
"\t       Info: 0x%08lx\n"
"\tOwn memory?: %ws\n"
"\t      Flags: %ws\n"
"\t Share name: %ws\n"
"\t       Type: %d\n"
"\t    Comment: %ws\n"
"\tPermissions: %d\n"
"\t   Max uses: %d\n"
"\t       Path: %ws\n"
"\t   Password: %ws\n"
"\t   Reserved: %d\n"
"\t   Security? %ws\n"
,
this,
m_pInfo,
m_bOwn ? L"yes" : L"no",
(m_flags == 0)
    ? L"none"
    : (m_flags == SHARE_FLAG_ADDED)
        ? L"added"
        : (m_flags == SHARE_FLAG_REMOVE)
            ? L"remove"
            : (m_flags == SHARE_FLAG_MODIFY)
                ? L"modify"
                : L"UNKNOWN!",
(NULL == m_pInfo->shi502_netname) ? L"none" : m_pInfo->shi502_netname,
m_pInfo->shi502_type,
(NULL == m_pInfo->shi502_remark) ? L"none" : m_pInfo->shi502_remark,
m_pInfo->shi502_permissions,
m_pInfo->shi502_max_uses,
(NULL == m_pInfo->shi502_path) ? L"none" : m_pInfo->shi502_path,
(NULL == m_pInfo->shi502_passwd) ? L"none" : m_pInfo->shi502_passwd,
m_pInfo->shi502_reserved,
(NULL == m_pInfo->shi502_security_descriptor) ? L"No" : L"Yes"
));

}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\shares.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       shares.h
//
//  Contents:   Definition of the shell IDLIST type for Shares
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#ifndef __SHARES_H__
#define __SHARES_H__

struct IDSHARE
{
    USHORT  cb;
    BYTE    bFlags;
    BYTE    bReserved;          // for alignment
    DWORD   type;               // shiX_type field
    DWORD   maxUses;            // only valid for SHID_SHARE_2
    USHORT  oPath;              // only valid for SHID_SHARE_2: cBuf[oPath] is start of path
    USHORT  oComment;           // cBuf[oComment] is start of comment
    TCHAR   cBuf[MAX_PATH*3];   // cBuf[0] is the start of name
};
typedef IDSHARE* LPIDSHARE;

#define SHID_SHARE_1    0x50    // Net share info level 1
#define SHID_SHARE_2    0x51    // Net share info level 2
#ifdef WIZARDS
#define SHID_SHARE_ALL  0x5c    // "all" shares wizard
#define SHID_SHARE_NW   0x5d    // NetWare shares wizard
#define SHID_SHARE_MAC  0x5e    // Mac shares wizard
#define SHID_SHARE_NEW  0x5f    // New Share wizard
#endif // WIZARDS

#define Share_GetFlags(pidl)        (pidl->bFlags)
#define Share_GetName(pidl)         (pidl->cBuf)
#define Share_GetComment(pidl)      (&(pidl->cBuf[pidl->oComment]))
#define Share_GetPath(pidl)         (&(pidl->cBuf[pidl->oPath]))
#define Share_GetType(pidl)         (pidl->type)
#define Share_GetMaxUses(pidl)      (pidl->maxUses)

#ifdef WIZARDS
#define Share_IsAllWizard(pidl)         (pidl->bFlags == SHID_SHARE_ALL)
#define Share_IsNetWareWizard(pidl)     (pidl->bFlags == SHID_SHARE_NW)
#define Share_IsMacWizard(pidl)         (pidl->bFlags == SHID_SHARE_MAC)
#define Share_IsNewShareWizard(pidl)    (pidl->bFlags == SHID_SHARE_NEW)
#define Share_IsSpecial(pidl)           (Share_IsNetWareWizard(pidl) || Share_IsMacWizard(pidl) || Share_IsNewShareWizard(pidl))
#endif // WIZARDS

#define Share_IsShare(pidl)         (pidl->bFlags == SHID_SHARE_1 || pidl->bFlags == SHID_SHARE_2)
#define Share_GetLevel(pidl)        (appAssert(Share_IsShare(pidl)), pidl->bFlags - SHID_SHARE_1 + 1)

#define Share_GetNameOffset(pidl)    offsetof(IDSHARE, cBuf)
#define Share_GetCommentOffset(pidl) (offsetof(IDSHARE, cBuf) + pidl->oComment * sizeof(TCHAR))
#define Share_GetPathOffset(pidl)    (offsetof(IDSHARE, cBuf) + pidl->oPath * sizeof(TCHAR))

#endif // __SHARES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\sfolder.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       sfolder.cxx
//
//  Contents:   Implementation of IShellFolder
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dutil.hxx"
#include "enum.hxx"
#include "menuutil.hxx"
#include "menu.hxx"
#include "menusp.hxx"
#include "menubg.hxx"
#include "sdetails.hxx"
#include "sfolder.hxx"
#include "shares.h"
#include "shares.hxx"
#include "util.hxx"
#include "xicon.hxx"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////

void
FSSetStatusText(
    HWND hwndOwner,
    LPTSTR* ppszText,
    int iStart,
    int iEnd);

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesSF::ParseDisplayName(
    HWND hwndOwner,
    LPBC pbc,
    LPOLESTR lpszDisplayName,
    ULONG* pchEaten,
    LPITEMIDLIST* ppidlOutm,
    ULONG* pdwAttributes
    )
{
    return E_NOTIMPL;
}


STDMETHODIMP
CSharesSF::GetAttributesOf(
    UINT cidl,
    LPCITEMIDLIST* apidl,
    ULONG* pdwInOut
    )
{
    // There are four types of object: New object, View NetWare, View Mac,
    // and regular share. If there is a single selection, then the operations
    // possible are:
    //      New share:      open, create shortcut
    //      View NetWare:   open, create shortcut
    //      View Mac:       open, create shortcut
    //      a share:        delete, properties
    // If there are different types of objects multiply selected, then
    // the items must all be shares, or there are no allowed operations.
    // For shares, the only multiple-select operation allowed is delete.

    ULONG fMask = 0;

    if (cidl == 0)
    {
        // What things in general can be done in the folder? Return a
        // mask of everything possible.
        fMask = SFGAO_CANDELETE | SFGAO_HASPROPSHEET | SFGAO_CANRENAME | SFGAO_LINK;
    }
    else if (cidl == 1)
    {
        LPIDSHARE pids = (LPIDSHARE)apidl[0];
        if (Share_IsShare(pids))
        {
            fMask = SFGAO_CANDELETE | SFGAO_HASPROPSHEET;
            if (!(Share_GetType(pids) & STYPE_SPECIAL))
            {
                fMask |= SFGAO_CANRENAME;
            }
        }
        else
        {
            fMask = SFGAO_CANLINK;
        }
    }
    else if (cidl > 1)
    {
        UINT i;
        for (i = 0; i < cidl; i++)
        {
            LPIDSHARE pids = (LPIDSHARE)apidl[i];
            if (!Share_IsShare(pids))
            {
                break;
            }
        }

        if (i == cidl)
        {
            fMask |= SFGAO_CANDELETE;
        }
    }

    *pdwInOut &= fMask;
    return S_OK;
}


STDMETHODIMP
CSharesSF::GetUIObjectOf(
    HWND hwndOwner,
    UINT cidl,
    LPCITEMIDLIST* apidl,
    REFIID riid,
    UINT* prgfInOut,
    LPVOID* ppvOut
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    HRESULT hr = E_NOINTERFACE;

    *ppvOut = NULL;

    if (cidl == 1 && IsEqualIID(riid, IID_IExtractIcon))
    {
        LPIDSHARE pids = (LPIDSHARE)apidl[0];

        CSharesEI* pObj = new CSharesEI(Share_GetFlags(pids), Share_GetType(pids));
        if (NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }

        hr = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }
#ifdef UNICODE
    else if (cidl == 1 && IsEqualIID(riid, IID_IExtractIconA))
    {
        LPIDSHARE pids = (LPIDSHARE)apidl[0];

        CSharesEIA* pObj = new CSharesEIA(Share_GetFlags(pids), Share_GetType(pids));
        if (NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }

        hr = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }
#endif // UNICODE
    else if (cidl > 0 && IsEqualIID(riid, IID_IContextMenu))
    {
        // Create a context menu for selected items. If there is only one
        // item, then the context menu is based on that object and is
        // CSharesCM for shares and CSharesCMSpecial for special objects.
        // If there is a multiple selection, then the selection must all be
        // shares, in which case the context-menu is CSharesCM, else there
        // is no context menu!

        if (This->m_level < 2)
        {
            // user has insufficient privilege to perform any operations.
            return E_NOINTERFACE;
        }

        IUnknown* punk = NULL;
        if (cidl == 1)
        {
            LPIDSHARE pids = (LPIDSHARE)apidl[0];
            if (Share_IsShare(pids))
            {
                CSharesCM* pObj = new CSharesCM(hwndOwner);
                if (NULL == pObj)
                {
                    return E_OUTOFMEMORY;
                }

                hr = pObj->InitInstance(This->m_pszMachine, cidl, apidl, this);
                if (FAILED(hr))
                {
                    return hr;
                }

                punk = (IUnknown*)pObj;
            }
#ifdef WIZARDS
            else
            {
                CSharesCMSpecial* pObj = new CSharesCMSpecial(hwndOwner);
                if (NULL == pObj)
                {
                    return E_OUTOFMEMORY;
                }

                hr = pObj->InitInstance(This->m_pszMachine, apidl[0], this);
                if (FAILED(hr))
                {
                    return hr;
                }

                punk = (IUnknown*)pObj;
            }
#endif // WIZARDS
        }
        else if (cidl > 1)
        {
            UINT i;
            for (i = 0; i < cidl; i++)
            {
                LPIDSHARE pids = (LPIDSHARE)apidl[i];
                if (!Share_IsShare(pids))
                {
                    break;
                }
            }

            if (i == cidl)
            {
                CSharesCM* pObj = new CSharesCM(hwndOwner);
                if (NULL == pObj)
                {
                    return E_OUTOFMEMORY;
                }

                hr = pObj->InitInstance(This->m_pszMachine, cidl, apidl, this);
                if (FAILED(hr))
                {
                    return hr;
                }

                punk = (IUnknown*)pObj;
            }
            else
            {
                return E_FAIL;
            }
        }

        appAssert(NULL != punk);
        hr = punk->QueryInterface(riid, ppvOut);
        punk->Release();
    }
    else if (cidl > 0 && IsEqualIID(riid, IID_IDataObject))
    {
        hr = CIDLData_CreateFromIDArray(
                        This->m_pidl,
                        cidl,
                        apidl,
                        (LPDATAOBJECT *)ppvOut);
    }

    return hr;
}


STDMETHODIMP
CSharesSF::EnumObjects(
    HWND hwndOwner,
    DWORD grfFlags,
    LPENUMIDLIST* ppenumUnknown
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    HRESULT hr = E_FAIL;

    *ppenumUnknown = NULL;

    if (!(grfFlags & SHCONTF_NONFOLDERS))
    {
        return hr;
    }

    appAssert(0 != This->m_level);
    CSharesEnum* pEnum = new CSharesEnum(This->m_pszMachine, This->m_level);
    if (NULL == pEnum)
    {
        return E_OUTOFMEMORY;
    }

    hr = pEnum->Init(grfFlags);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pEnum->QueryInterface(IID_IEnumIDList, (LPVOID*)ppenumUnknown);
    pEnum->Release();
    return hr;
}


STDMETHODIMP
CSharesSF::BindToObject(
    LPCITEMIDLIST pidl,
    LPBC pbc,
    REFIID riid,
    LPVOID* ppvOut
    )
{
    //
    // Shares folder doesn't contain sub-folders
    //

    *ppvOut = NULL;
    return E_FAIL;
}


// not used in Win95
STDMETHODIMP
CSharesSF::BindToStorage(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID* ppvOut
    )
{
    *ppvOut = NULL;
    return E_NOTIMPL;
}

#define PlusMinus(x) (((x) < 0) ? -1 : ( ((x) > 0) ? 1 : 0 ))

int
CSharesSF::_CompareOne(
    DWORD iCol,
    LPIDSHARE pids1,
    LPIDSHARE pids2
    )
{
    switch (iCol)
    {
    case ICOL2_NAME:
        return lstrcmpi(Share_GetName(pids1), Share_GetName(pids2));

    case ICOL2_COMMENT:
        return lstrcmpi(Share_GetComment(pids1), Share_GetComment(pids2));

    case ICOL2_PATH:
        return lstrcmpi(Share_GetPath(pids1), Share_GetPath(pids2));

    case ICOL2_MAXUSES:
    {
        DWORD max1 = Share_GetMaxUses(pids1);
        DWORD max2 = Share_GetMaxUses(pids2);
        if (max1 == SHI_USES_UNLIMITED && max2 == SHI_USES_UNLIMITED)
        {
            return 0;
        }
        else if (max1 == SHI_USES_UNLIMITED)
        {
            return 1;
        }
        else if (max2 == SHI_USES_UNLIMITED)
        {
            return -1;
        }
        else
        {
            return max1 - max2;
        }
    }

    default: appAssert(!"Illegal column"); return 0;
    }
}

STDMETHODIMP
CSharesSF::CompareIDs(
    LPARAM iCol,
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);

    // If one item is a special item, then put it ahead of the other one.
    // If they are both special items, sort on name.

    LPIDSHARE pids1 = (LPIDSHARE)pidl1;
    LPIDSHARE pids2 = (LPIDSHARE)pidl2;
    int iCmp;

#ifdef WIZARDS
    if (Share_IsSpecial(pids1))
    {
        if (Share_IsSpecial(pids2))
        {
            // both special; sort on name
            return ResultFromShort(lstrcmpi(Share_GetName(pids1),
                                            Share_GetName(pids2)));
        }
        else
        {
            return ResultFromShort(-1);
        }
    }
    else if (Share_IsSpecial(pids2))
    {
        return ResultFromShort(1);
    }
#endif // WIZARDS

    // Documentation says iCol is always zero, but that is wrong! It will
    // be non-zero in case the user has clicked on a column heading to sort
    // the column. In general, we want the entire item to be equal before we
    // return 0 for equality. To do this, we first check the chosen element.
    // If it is not equal, return the value. Otherwise, check all elements in
    // this standard order:
    //      name
    //      comment
    //      path
    //      max uses
    //      current uses
    // Only after all these checks return 0 (equality) do we return 0 (equality)

    iCmp = _CompareOne((ULONG)iCol, pids1, pids2);
    if (iCmp != 0)
    {
        return ResultFromShort(PlusMinus(iCmp));
    }

    // now, check each in turn

    iCmp = _CompareOne(ICOL2_NAME, pids1, pids2);
    if (iCmp != 0)
    {
        return ResultFromShort(PlusMinus(iCmp));
    }

    iCmp = _CompareOne(ICOL2_COMMENT, pids1, pids2);
    if (iCmp != 0)
    {
        return ResultFromShort(PlusMinus(iCmp));
    }

    if (This->m_level == 2)
    {
        iCmp = _CompareOne(ICOL2_PATH, pids1, pids2);
        if (iCmp != 0)
        {
            return ResultFromShort(PlusMinus(iCmp));
        }

        iCmp = _CompareOne(ICOL2_MAXUSES, pids1, pids2);
        if (iCmp != 0)
        {
            return ResultFromShort(PlusMinus(iCmp));
        }
    }

    return 0;   // the same!
}


STDMETHODIMP
CSharesSF::CreateViewObject(
    HWND hwnd,
    REFIID riid,
    LPVOID* ppvOut
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    HRESULT hr = E_NOINTERFACE;

    *ppvOut = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        CSFV csfv =
        {
            sizeof(CSFV),         // cbSize
            (IShellFolder*)this,  // pshf
            NULL,                 // psvOuter
            NULL,                 // pidl to monitor (NULL == all)
            SHCNE_NETSHARE | SHCNE_NETUNSHARE | SHCNE_UPDATEITEM, // events
            _SFVCallBack,         // pfnCallback
            FVM_DETAILS
        };

        hr = SHCreateShellFolderViewEx(&csfv, (LPSHELLVIEW *)ppvOut);
    }
    else if (IsEqualIID(riid, IID_IShellDetails))
    {
        appAssert(This->m_level != 0);
        CSharesSD* pObj = new CSharesSD(hwnd, This->m_level);
        if (NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }

        hr = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        // Create a context menu for the background
        CSharesCMBG* pObj = new CSharesCMBG(hwnd, This->m_pszMachine, This->m_level);
        if (NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }

        hr = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }

    return hr;
}


STDMETHODIMP
CSharesSF::GetDisplayNameOf(
    LPCITEMIDLIST pidl,
    DWORD uFlags,
    LPSTRRET lpName
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);

    LPIDSHARE pids = (LPIDSHARE)pidl;
    if (uFlags == SHGDN_FORPARSING)
    {
        return E_NOTIMPL;   // don't support parsing.
    }
    else if (uFlags == SHGDN_INFOLDER)
    {
        return STRRETCopy(Share_GetName(pids), lpName);
    }
    else if (uFlags == SHGDN_NORMAL)
    {
        if (NULL == This->m_pszMachine)
        {
            return STRRETCopy(Share_GetName(pids), lpName);
        }
        else
        {
            LPWSTR pszMachine = This->m_pszMachine;
            if (pszMachine[0] == TEXT('\\') && pszMachine[1] == TEXT('\\'))
            {
                pszMachine += 2;
            }

            WCHAR szBuf[MAX_PATH];
            szBuf[0] = L'\0';
            MyFormatMessage(
                    MSG_TEMPLATE_WITH_ON,
                    szBuf,
                    ARRAYLEN(szBuf),
                    pszMachine,
                    Share_GetName(pids));
#ifdef UNICODE
            LPTSTR pszCopy = (LPTSTR)SHAlloc((lstrlen(szBuf)+1) * sizeof(TCHAR));
            if (pszCopy)
            {
                wcscpy(pszCopy, szBuf);
                lpName->uType = STRRET_OLESTR;
                lpName->pOleStr = pszCopy;
            }
            else
            {
                lpName->uType = STRRET_CSTR;
                lpName->cStr[0] = '\0';
            }
#else
            lpName->uType = STRRET_CSTR;
            lstrcpyn(lpName->cStr, szBuf, ARRAYSIZE(lpName->cStr));
            SHFree(pszRet);
#endif

            return S_OK;
        }
    }
    else
    {
        return E_INVALIDARG;
    }
}


STDMETHODIMP
CSharesSF::SetNameOf(
    HWND hwndOwner,
    LPCITEMIDLIST pidl,
    LPCOLESTR lpszName,
    DWORD uFlags,
    LPITEMIDLIST* ppidlOut
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);

    if (uFlags != SHGDN_INFOLDER)
    {
        return E_NOTIMPL;
    }

    if (NULL == lpszName || L'\0' == *lpszName)
    {
        // can't change name to nothing
        MessageBeep(0);
        return E_FAIL;
    }

    NET_API_STATUS ret;
    WCHAR szBuf[MAX_PATH];
    LPSHARE_INFO_502 pInfo;
    LPIDSHARE pids = (LPIDSHARE)pidl;

    // Get information about the existing share before deleting it.
    ret = NetShareGetInfo(This->m_pszMachine, Share_GetName(pids), 502, (LPBYTE*)&pInfo);
    if (ret != NERR_Success)
    {
        DisplayError(hwndOwner, IERR_CANT_DEL_SHARE, ret, Share_GetName(pids));
        return HRESULT_FROM_WIN32(ret);
    }

    // Validate the new share name

    // Trying to create a reserved share?
    if (   (0 == _wcsicmp(g_szIpcShare,   lpszName))
        || (0 == _wcsicmp(g_szAdminShare, lpszName)))
    {
        MyErrorDialog(hwndOwner, MSG_ADDSPECIAL2);
        NetApiBufferFree(pInfo);
        return E_FAIL;
    }

    HRESULT hrTemp;
    if (!IsValidShareName(lpszName, &hrTemp))
    {
        MyErrorDialog(hwndOwner, hrTemp);
        NetApiBufferFree(pInfo);
        return E_FAIL;
    }

    // Check to see that the same share isn't already used, for either the
    // same path or for another path.

    SHARE_INFO_2* pInfo2;
    ret = NetShareGetInfo(This->m_pszMachine, (LPWSTR)lpszName, 2, (LPBYTE*)&pInfo2);
    if (ret == NERR_Success)
    {
        // Is it already shared for the same path?
        if (0 == _wcsicmp(pInfo2->shi2_path, pInfo->shi502_path))
        {
            MyErrorDialog(hwndOwner, IERR_AlreadyExists, lpszName);
            NetApiBufferFree(pInfo);
            NetApiBufferFree(pInfo2);
            return TRUE;
        }

        // Shared for a different path. Ask the user if they wish to delete
        // the old share and create the new one using the name.

        DWORD id = ConfirmReplaceShare(hwndOwner, lpszName, pInfo2->shi2_path, pInfo->shi502_path);
        if (id == IDNO || id == IDCANCEL)   // FEATURE: should be only yes/no
        {
            NetApiBufferFree(pInfo);
            NetApiBufferFree(pInfo2);
            return E_FAIL;
        }

        // User said to replace the old share. Do it.
        ret = NetShareDel(This->m_pszMachine, (LPWSTR)lpszName, 0);
        if (ret != NERR_Success)
        {
            DisplayError(hwndOwner, IERR_CANT_DEL_SHARE, ret, (LPWSTR)lpszName);
            NetApiBufferFree(pInfo);
            NetApiBufferFree(pInfo2);
            return FALSE;
        }
        else
        {
            SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, pInfo2->shi2_path, NULL);
        }

        NetApiBufferFree(pInfo2);
    }

    // Check for downlevel accessibility
    ULONG nType;
    if (NERR_Success != NetpPathType(NULL, (LPWSTR)lpszName, &nType, INPT_FLAGS_OLDPATHS))
    {
        DWORD id = MyConfirmationDialog(
                        hwndOwner,
                        IERR_InaccessibleByDos,
                        MB_YESNO | MB_ICONEXCLAMATION,
                        lpszName);
        if (id == IDNO)
        {
            return TRUE;
        }
    }

    // delete the existing share
    ret = NetShareDel(This->m_pszMachine, Share_GetName(pids), 0);
    if (ret != NERR_Success)
    {
        NetApiBufferFree(pInfo);
        DisplayError(hwndOwner, IERR_CANT_DEL_SHARE, ret, Share_GetName(pids));
        return HRESULT_FROM_WIN32(ret);
    }

    // Create a new share with the new name.
    LPWSTR ptmp = pInfo->shi502_netname;
    pInfo->shi502_netname = (LPWSTR)lpszName;   // cast away const
    ret = NetShareAdd(This->m_pszMachine, 502, (LPBYTE)pInfo, NULL);
    if (ret != NERR_Success)
    {
        pInfo->shi502_netname = ptmp;
        NetApiBufferFree(pInfo);
        DisplayError(hwndOwner, IERR_CANT_ADD_SHARE, ret, (LPWSTR)lpszName); // cast away const
        return HRESULT_FROM_WIN32(ret);
    }

    // Ok, now I've renamed it. So, fill an ID list with the new guy, and
    // return it in *ppidlOut.

    HRESULT hr = S_OK;
    if (NULL != ppidlOut)
    {
        IDSHARE ids;
        FillID2(&ids, (LPSHARE_INFO_2)pInfo); // ignore security at end of level 502

        *ppidlOut = ILClone((LPCITEMIDLIST)(&ids));
        if (NULL == *ppidlOut)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // force a view refresh
    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, NULL, 0);

    pInfo->shi502_netname = ptmp;
    NetApiBufferFree(pInfo);
    return hr;
}


//
// Callback from SHCreateShellFolderViewEx
//

HRESULT CALLBACK
CSharesSF::_SFVCallBack(
    LPSHELLVIEW psvOuter,
    LPSHELLFOLDER psf,
    HWND hwndOwner,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,psf);
    HRESULT hr = S_OK;     // assume no error

    switch (uMsg)
    {
    case DVM_UPDATESTATUSBAR:
    {
        IShellBrowser* psb = FileCabinet_GetIShellBrowser(hwndOwner);
        UINT cidl = ShellFolderView_GetSelectedCount(hwndOwner);
        if (cidl == 1)
        {
            LPITEMIDLIST *apidl;
            LPIDSHARE pids;
            LPTSTR lpsz = TEXT("");

            ShellFolderView_GetSelectedObjects(hwndOwner, &apidl);
            if (apidl)
            {
                pids = (LPIDSHARE)apidl[0];
                if (Share_IsShare(pids))
                {
                    lpsz = Share_GetComment(pids);
                }
                FSSetStatusText(hwndOwner, &lpsz, 0, 0);
                LocalFree(apidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }
        break;
    }

    case DVM_MERGEMENU:
    {
        appDebugOut((DEB_TRACE, "DVM_MERGEMENU\n"));
        appAssert(This->m_pMenuBg == NULL);
        hr = psf->CreateViewObject(hwndOwner, IID_IContextMenu, (LPVOID*)&This->m_pMenuBg);
        if (SUCCEEDED(hr))
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;
            hr = This->m_pMenuBg->QueryContextMenu(
                                    pqcm->hmenu,
                                    pqcm->indexMenu,
                                    pqcm->idCmdFirst,
                                    pqcm->idCmdLast,
                                    CMF_DVFILE);
        }
        break;
    }

    case DVM_UNMERGEMENU:
    {
        appDebugOut((DEB_TRACE, "DVM_UNMERGEMENU\n"));
        if (NULL != This->m_pMenuBg)
        {
            This->m_pMenuBg->Release();
            This->m_pMenuBg = NULL;
        }
        break;
    }

    case DVM_INVOKECOMMAND:
    {
        appDebugOut((DEB_TRACE, "DVM_INVOKECOMMAND\n"));
        appAssert(This->m_pMenuBg != NULL);
        CMINVOKECOMMANDINFO ici =
        {
            sizeof(ici),
            0,  // mask
            hwndOwner,
            (LPCSTR)wParam,
            NULL,
            NULL,
            0,
            0,
            NULL
        };
        hr = This->m_pMenuBg->InvokeCommand(&ici);
        break;
    }

    case DVM_GETHELPTEXT:
    {
        appDebugOut((DEB_TRACE, "DVM_GETHELPTEXT\n"));
        hr = This->m_pMenuBg->GetCommandString(LOWORD(wParam), GCS_HELPTEXT, NULL, (LPSTR)lParam, HIWORD(wParam));
        break;
    }

    case DVM_DEFITEMCOUNT:
        //
        // If DefView times out enumerating items, let it know we probably only
        // have about 20 items
        //

        *(int *)lParam = 20;
        break;

    case DVM_FSNOTIFY:
    {
        LPCITEMIDLIST* ppidl = (LPCITEMIDLIST*)wParam;

        switch (lParam)
        {
        case SHCNE_NETSHARE:
        case SHCNE_NETUNSHARE:
            // a share was added, removed, or changed. Force a view refresh.
//            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, NULL, 0);
            return S_OK;
        }
        break;
    }

    default:
        hr = E_FAIL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\shrpage.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       shrpage.cxx
//
//  Contents:   "Sharing" shell property page extension
//
//  History:    6-Apr-95        BruceFo     Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "dlgnew.hxx"
#include "acl.hxx"
#include "shrinfo.hxx"
#include "shrpage.hxx"
#include "util.hxx"

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::DlgProcPage, static public
//
//  Synopsis:   Dialog Procedure for all CSharingPropertyPage
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CSharingPropertyPage::DlgProcPage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CSharingPropertyPage* pThis = NULL;

    if (msg==WM_INITDIALOG)
    {
        SHARE_PROPSHEETPAGE* sprop = (SHARE_PROPSHEETPAGE*)lParam;
        pThis = new CSharingPropertyPage(hwnd, sprop->pszMachine, sprop->pszShareName);
        if (NULL != pThis)
        {
            if (FAILED(pThis->InitInstance()))
            {
                delete pThis;
                pThis = NULL;
            }
        }

        SetWindowLongPtr(hwnd,GWLP_USERDATA,(LPARAM)pThis);
    }
    else
    {
        pThis = (CSharingPropertyPage*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
    }

    if (pThis != NULL)
    {
        return pThis->_PageProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CSharingPropertyPage::SizeWndProc, public
//
//  Synopsis:   "allow" edit window subclass proc to disallow non-numeric
//              characters.
//
//  History:    5-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
CSharingPropertyPage::SizeWndProc(
    IN HWND hwnd,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (wMsg)
    {
    case WM_CHAR:
    {
        WCHAR chCharCode = (WCHAR)wParam;
        if (   (chCharCode == TEXT('\t'))
            || (chCharCode == TEXT('\b'))
            || (chCharCode == TEXT('\n'))
//          || (chCharCode == TEXT('\x1b')) // ESCAPE key
            )
        {
            break;
        }

        if (chCharCode < TEXT('0') || chCharCode > TEXT('9'))
        {
            // bad key: ignore it
            MessageBeep(0xffffffff);    // let user know it's an illegal char
            return FALSE;
        }

        break;
    }
    } // end of switch

    CSharingPropertyPage* pThis = (CSharingPropertyPage*)GetWindowLongPtr(GetParent(hwnd),GWLP_USERDATA);
    appAssert(NULL != pThis);
    appAssert(NULL != pThis->_pfnAllowProc);
    return CallWindowProc(pThis->_pfnAllowProc, hwnd, wMsg, wParam, lParam);
}


//+--------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::CSharingPropertyPage, public
//
//  Synopsis:   Constructor
//
//---------------------------------------------------------------------------

CSharingPropertyPage::CSharingPropertyPage(
    IN HWND hwndPage,
    IN PWSTR pszMachine,
    IN PWSTR pszShare
    )
    :
    _hwndPage(hwndPage),
    _pszMachine(pszMachine),
    _pszShare(pszShare),
    _bDirty(FALSE),
    _bShareNameChanged(FALSE),
    _bPathChanged(FALSE),
    _bCommentChanged(FALSE),
    _bUserLimitChanged(FALSE),
    _bSecDescChanged(FALSE),
    _wMaxUsers(DEFAULT_MAX_USERS),
    _pCurInfo(NULL),
    _pszReplacePath(NULL),
    _pfnAllowProc(NULL)
{
    INIT_SIG(CSharingPropertyPage);
    appAssert(NULL != _pszShare);
}


//+--------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::~CSharingPropertyPage, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------------------

CSharingPropertyPage::~CSharingPropertyPage()
{
    CHECK_SIG(CSharingPropertyPage);

    delete _pCurInfo;
    _pCurInfo = NULL;

    delete[] _pszReplacePath;
    _pszReplacePath = NULL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::InitInstance, public
//
//  Synopsis:   Part II of the constuctor process
//
//  Notes:      We don't want to handle any errors in constuctor, so this
//              method is necessary for the second phase error detection.
//
//--------------------------------------------------------------------------

HRESULT
CSharingPropertyPage::InitInstance(
    VOID
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appDebugOut((DEB_ITRACE, "CSharingPropertyPage::InitInstance\n"));

    SHARE_INFO_502* info502;
    NET_API_STATUS ret = NetShareGetInfo(_pszMachine, _pszShare, 502, (LPBYTE*)&info502);
    if (ret == NERR_Success)
    {
        _pCurInfo = new CShareInfo(info502);
        if (NULL == _pCurInfo)
        {
            return E_OUTOFMEMORY;
        }

        if (!_pCurInfo->TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        NetApiBufferFree(info502);
    }
    else
    {
        appDebugOut((DEB_ERROR, "Couldn't get info\n"));
        return HRESULT_FROM_WIN32(ret);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

INT_PTR
CSharingPropertyPage::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CSharingPropertyPage);

    static DWORD aHelpIds[] =
    {
        IDC_SHARE_SHARENAME,        HC_SHARE_SHARENAME,
        IDC_SHARE_PATH,             HC_SHARE_PATH,
        IDC_SHARE_COMMENT,          HC_SHARE_COMMENT,
        IDC_SHARE_MAXIMUM,          HC_SHARE_MAXIMUM,
        IDC_SHARE_ALLOW,            HC_SHARE_ALLOW,
        IDC_SHARE_ALLOW_VALUE,      HC_SHARE_ALLOW_VALUE,
        IDC_SHARE_PERMISSIONS,      HC_SHARE_PERMISSIONS,

        0,0
    };

    switch (msg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(hwnd, (HWND)wParam, lParam);

    case WM_COMMAND:
        return _OnCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_NOTIFY:
        return _OnNotify(hwnd, (int)wParam, (LPNMHDR)lParam);

    case WM_VSCROLL:
        // The up/down control changed the edit control: select it again
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        return TRUE;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if (lphi->iContextType == HELPINFO_WINDOW)  // a control
        {
            WCHAR szHelp[50];
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                (HWND)lphi->hItemHandle,
                szHelp,
                HELP_WM_HELP,
                (DWORD_PTR)aHelpIds);
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)wParam,
            szHelp,
            HELP_CONTEXTMENU,
            (DWORD_PTR)aHelpIds);
        break;
    }

    case WM_CLOSE:
        // BUGBUG: There is a bug where hitting "ESCAPE" with the focus on the
        // MLE for the "allow" text doesn't kill the property sheet unless we
        // forward the WM_CLOSE message on to the property sheet root dialog.
        return SendMessage(GetParent(hwnd), msg, wParam, lParam);

    case WM_DESTROY:
        // restore original subclass to window.
        appAssert(NULL != GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE));
        SetWindowLongPtr(GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE), GWLP_WNDPROC, (LONG_PTR)_pfnAllowProc);
        break;

    case WM_NCDESTROY:
        return _OnNcDestroy(hwnd);

    } // end switch (msg)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnInitDialog(
    IN HWND hwnd,
    IN HWND hwndFocus,
    IN LPARAM lInitParam
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appDebugOut((DEB_ITRACE, "_OnInitDialog\n"));

    SetDialogIconBig(_GetFrameWindow(), IDI_SHARESFLD);

    // Subclass allow edit control to disallow non-positive numbers
    _pfnAllowProc = (WNDPROC)SetWindowLongPtr(
                                    GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE),
                                    GWLP_WNDPROC,
                                    (LONG_PTR)&SizeWndProc);

    // use LanMan API constants to set maximum share name & comment lengths
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_PATH,      EM_LIMITTEXT, MAX_PATH-1, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_COMMENT,   EM_LIMITTEXT, MAXCOMMENTSZ, 0L);

    _InitializeControls(hwnd);

// #if DBG == 1
//  Dump(L"_OnInitDialog finished");
// #endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CSharingPropertyPage);

    switch (wID)
    {

//
// Notifications
//

    case IDC_SHARE_SHARENAME:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bShareNameChanged = TRUE;
                _MarkItemDirty();
            }
        }
        return TRUE;
    }

    case IDC_SHARE_PATH:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bPathChanged = TRUE;
                _MarkItemDirty();
            }
        }
        return TRUE;
    }

    case IDC_SHARE_COMMENT:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bCommentChanged = TRUE;
                _MarkItemDirty();
            }
        }
        return TRUE;
    }

    case IDC_SHARE_MAXIMUM:
        if (BN_CLICKED == wNotifyCode)
        {
            // Take away WS_TABSTOP from the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) & ~WS_TABSTOP);

            _CacheMaxUses(hwnd);
            SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

    case IDC_SHARE_ALLOW:
        if (BN_CLICKED == wNotifyCode)
        {
            // Give WS_TABSTOP to the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) | WS_TABSTOP);

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

    case IDC_SHARE_ALLOW_VALUE:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }

        if (EN_SETFOCUS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }

        if (EN_KILLFOCUS == wNotifyCode)
        {
            _CacheMaxUses(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_ALLOW_SPIN:
        if (UDN_DELTAPOS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

//
// Commands
//

    case IDC_SHARE_PERMISSIONS:
        return _OnPermissions(hwnd);

    default:
        break;
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnNotify, private
//
//  Synopsis:   WM_NOTIFY handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnNotify(
    IN HWND hwnd,
    IN int idCtrl,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CSharingPropertyPage);

    // assume a property sheet notification
    return _OnPropertySheetNotify(hwnd, phdr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnPropertySheetNotify, private
//
//  Synopsis:   WM_NOTIFY handler for the property sheet notification
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnPropertySheetNotify(
    IN HWND hwnd,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CSharingPropertyPage);

    switch (phdr->code)
    {
    case PSN_RESET:         // cancel
        if (_DoCancel(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE); // go away
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
        }
        return TRUE;

    case PSN_KILLACTIVE:    // change to another page
        if (_ValidatePage(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            return FALSE;
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }

    case PSN_APPLY:
        if (_DoApply(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE); // go away
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
        }
        return TRUE;

    } // end switch (phdr->code)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnNcDestroy, private
//
//  Synopsis:   WM_NCDESTROY handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnNcDestroy(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    delete this;    // do this LAST!
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnPermissions, private
//
//  Synopsis:   WM_COMMAND handler: the permissions button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnPermissions(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(NULL != _pCurInfo);

    if (STYPE_SPECIAL & _pCurInfo->GetType())
    {
        MyErrorDialog(hwnd, IERR_AdminShare);
        return TRUE;
    }

    WCHAR szShareName[NNLEN + 1];
    GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
    // don't trim spaces, this might be an existing share with spaces in its name

    PSECURITY_DESCRIPTOR pNewSecDesc = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = _pCurInfo->GetSecurityDescriptor();
    appAssert(NULL == pSecDesc || IsValidSecurityDescriptor(pSecDesc));

    BOOL bSecDescChanged;
    LONG err = EditShareAcl(
                        hwnd,
                        _pszMachine,
                        szShareName,
                        pSecDesc,
                        &bSecDescChanged,
                        &pNewSecDesc);

    if (bSecDescChanged)
    {
        _bSecDescChanged = TRUE;

        appAssert(IsValidSecurityDescriptor(pNewSecDesc));
        _pCurInfo->TransferSecurityDescriptor(pNewSecDesc);
        _MarkItemDirty();
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_InitializeControls, private
//
//  Synopsis:   Initialize the controls from scratch
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_InitializeControls(
    IN HWND hwnd
    )
{
    _SetControlsToDefaults(hwnd);
    _SetControlsFromData(hwnd);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_SetControlsToDefaults, private
//
//  Synopsis:   Set all the controls on the page to their default values
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetControlsToDefaults(
    IN HWND hwnd
    )
{
    _fInitializingPage = TRUE;

    // Make "Maximum" the default number of users, and clear the value field
    // (which the spin button set on creation?).

    CheckRadioButton(
            hwnd,
            IDC_SHARE_MAXIMUM,
            IDC_SHARE_ALLOW,
            IDC_SHARE_MAXIMUM);

    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    // set the spin control range: 1 <--> large number
    SendDlgItemMessage(
            hwnd,
            IDC_SHARE_ALLOW_SPIN,
            UDM_SETRANGE,
            0,
            MAKELONG(g_uiMaxUsers, 1));

    SetDlgItemText(hwnd, IDC_SHARE_SHARENAME,   L"");
    SetDlgItemText(hwnd, IDC_SHARE_PATH,        L"");
    SetDlgItemText(hwnd, IDC_SHARE_COMMENT,     L"");
    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    _fInitializingPage = FALSE;
}



//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::SetControlsFromData, private
//
//  Synopsis:   From the class variables and current state of the radio
//              buttons, set the enabled/disabled state of the buttons, as
//              well as filling the controls with the appropriate values.
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetControlsFromData(
    IN HWND hwnd
    )
{
    appAssert(NULL != _pCurInfo);

    _fInitializingPage = TRUE;

    SetDlgItemText(hwnd, IDC_SHARE_SHARENAME, _pCurInfo->GetNetname());
    SetDlgItemText(hwnd, IDC_SHARE_PATH,      _pCurInfo->GetPath());
    SetDlgItemText(hwnd, IDC_SHARE_COMMENT,   _pCurInfo->GetRemark());

    DWORD dwLimit = _pCurInfo->GetMaxUses();
    if (dwLimit == SHI_USES_UNLIMITED)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        appDebugOut((DEB_ITRACE, "_SetControlsFromData: unlimited users\n"));

        CheckRadioButton(
                hwnd,
                IDC_SHARE_MAXIMUM,
                IDC_SHARE_ALLOW,
                IDC_SHARE_MAXIMUM);

        SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");
    }
    else
    {
        _wMaxUsers = (WORD)dwLimit;

        appDebugOut((DEB_ITRACE,
            "_SetControlsFromData: max users = %d\n",
            _wMaxUsers));

        CheckRadioButton(
                hwnd,
                IDC_SHARE_MAXIMUM,
                IDC_SHARE_ALLOW,
                IDC_SHARE_ALLOW);

        // let the spin control set the edit control
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));

        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }

    // Managine a special share?
    if (_pCurInfo->GetType() & STYPE_SPECIAL)
    {
        // Can't change the path or the name
        // Making it read-only makes it easier to read than if it were disabled
        SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_SETREADONLY, (WPARAM)(BOOL)TRUE, 0);
        SendDlgItemMessage(hwnd, IDC_SHARE_PATH,      EM_SETREADONLY, (WPARAM)(BOOL)TRUE, 0);
    }

    _fInitializingPage = FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_MarkItemDirty, private
//
//  Synopsis:   A change has made such that the current item (and page)
//              is now dirty
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_MarkItemDirty(
    VOID
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (!_fInitializingPage)
    {
        if (!_bDirty)
        {
            appDebugOut((DEB_ITRACE, "Marking Sharing page dirty\n"));
            _bDirty = TRUE;
            PropSheet_Changed(_GetFrameWindow(),_hwndPage);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_ValidatePage, private
//
//  Synopsis:   Return TRUE if the current page is valid
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_ValidatePage(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(NULL != _pCurInfo);

    if (!_bDirty)
    {
        // nothing to validate
        return TRUE;
    }

    if (!_bShareNameChanged)
    {
        appDebugOut((DEB_ITRACE, "_ValidatePage: share name not changed!\n"));

        return TRUE;
    }

    delete[] _pszReplacePath;
    _pszReplacePath = NULL;

    WCHAR szShareName[MAX_PATH];
    GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
    TrimLeadingAndTrailingSpaces(szShareName);

    WCHAR szPath[MAX_PATH];
    GetDlgItemText(hwnd, IDC_SHARE_PATH, szPath, ARRAYLEN(szPath));

    // Validate the share

    if (0 == wcslen(szShareName))
    {
        MyErrorDialog(hwnd, IERR_BlankShareName);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return FALSE;
    }

    HRESULT uTemp;
    if (!IsValidShareName(szShareName, &uTemp))
    {
        MyErrorDialog(hwnd, uTemp);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return FALSE;
    }

    // Trying to create a reserved share?
    if (   (0 == _wcsicmp(g_szIpcShare,   szShareName))
        || (0 == _wcsicmp(g_szAdminShare, szShareName)))
    {
        MyErrorDialog(hwnd, IERR_SpecialShare);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return FALSE;
    }

    // If the user entered some ACL, warn them that we're going to nuke
    // it and let the system use its default (since special shares can't
    // have their security set).
    if (DriveLetterShare(szShareName))
    {
        if (_bSecDescChanged)
        {
            DWORD id = MyConfirmationDialog(
                            hwnd,
                            MSG_NOSECURITYONSPECIAL,
                            MB_YESNO | MB_ICONEXCLAMATION);
            if (id == IDNO)
            {
                SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
                return FALSE;
            }
            _pCurInfo->TransferSecurityDescriptor(NULL);
        }
    }

    // Check for downlevel accessibility
    // CODEWORK we should really get rid of this at some point -- JonN 7/18/97
    ULONG nType;
    if (NERR_Success != NetpPathType(NULL, szShareName, &nType, INPT_FLAGS_OLDPATHS))
    {
        DWORD id = MyConfirmationDialog(
                        hwnd,
                        IERR_InaccessibleByDos,
                        MB_YESNO | MB_ICONEXCLAMATION,
                        szShareName);
        if (id == IDNO)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }
    }

    // Check to see that the same share isn't already used, for either the
    // same path or for another path.

    SHARE_INFO_502* info502;
    NET_API_STATUS ret = NetShareGetInfo(_pszMachine, szShareName, 502, (LPBYTE*)&info502);
    if (ret == NERR_Success)
    {
        // It is already shared. Same path?

        if (0 == _wcsicmp(info502->shi502_path, szPath))
        {
            MyErrorDialog(hwnd, IERR_AlreadyExists, szShareName);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info502);
            return FALSE;
        }

        // Shared for a different path. Ask the user if they wish to delete
        // the old share and create the new one using the name.

        DWORD id = ConfirmReplaceShare(hwnd, szShareName, info502->shi502_path, szPath);
        if (id == IDNO)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info502);
            return FALSE;
        }
        else if (id == IDCANCEL)
        {
            // EndDialog(hwnd, FALSE);  // BUGBUG: nuke page
            NetApiBufferFree(info502);
            return TRUE;
        }
        else
        {
            _pszReplacePath = NewDup(info502->shi502_path);
            if (NULL == _pszReplacePath)
            {
                NetApiBufferFree(info502);
                MyErrorDialog(hwnd, E_OUTOFMEMORY);
                return FALSE;
            }
        }

        NetApiBufferFree(info502);
    }
    else
    {
        // NetShareGetInfo failed. This is probably because there
        // is no share by this name, in which case it is a pure rename.

        appDebugOut((DEB_TRACE,
            "NetShareGetInfo failed, 0x%08lx\n",
            ret));
    }

#if DBG == 1
    Dump(L"_ValidatePage finished");
#endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_DoApply, public
//
//  Synopsis:   If anything has changed, apply the data
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_DoApply(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (_bDirty)
    {
        appAssert(NULL != _pCurInfo);

        NET_API_STATUS ret;
        HRESULT hr;

        // If either the share name changed or the path changed, we need
        // to delete the old share. If the share name changed, it is
        // because the user is renaming the share. If the path changed,
        // it is because the LanMan APIs don't allow a NetShareSetInfo
        // to change the shared path.

        if (_bShareNameChanged)
        {
            // The share name was changed. This is either a pure rename, in
            // which case the old share should be deleted and a share with
            // the new name created, or the user changed the share name to
            // the name of an already existing share, in which case both the
            // current share name as well as the share to be replaced must be
            // deleted.

            if (NULL != _pszReplacePath)
            {
                // user said to replace an existing share
        		WCHAR szShareName[NNLEN + 1];
                GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
                TrimLeadingAndTrailingSpaces(szShareName);

                ret = NetShareDel(_pszMachine, szShareName, 0);
                if (ret != NERR_Success)
                {
                    DisplayError(hwnd, IERR_CANT_DEL_SHARE, ret, szShareName);
                    delete[] _pszReplacePath;
                    _pszReplacePath = NULL;
                    return FALSE;
                }
                else
                {
                    SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, _pszReplacePath, NULL);
                }

                delete[] _pszReplacePath;
                _pszReplacePath = NULL;
            }
        }

        if (_bShareNameChanged || _bPathChanged)
        {
            // delete the existing share
            ret = NetShareDel(_pszMachine, _pCurInfo->GetNetname(), 0);
            if (ret != NERR_Success)
            {
                DisplayError(hwnd, IERR_CANT_DEL_SHARE, ret, _pCurInfo->GetNetname());
                return FALSE;
            }
            else
            {
                // Only if the path changed in the rename should the shell
                // be notified
                if (_bPathChanged)
                {
                    SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, _pCurInfo->GetPath(), NULL);
                }
            }
        }

        if (_bShareNameChanged)
        {
            // User wants to rename the share.
        	WCHAR szShareName[NNLEN + 1];
            _pCurInfo->SetDirtyFlag(SHARE_FLAG_ADDED);   // special case
            GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
            TrimLeadingAndTrailingSpaces(szShareName);
            _pCurInfo->SetNetname(szShareName);
        }

        if (_bPathChanged)
        {
			WCHAR szPath[MAX_PATH];
            _pCurInfo->SetDirtyFlag(SHARE_FLAG_ADDED);   // special case
            GetDlgItemText(hwnd, IDC_SHARE_PATH, szPath, ARRAYLEN(szPath));
            _pCurInfo->SetPath(szPath);
        }

        if (_bCommentChanged)
        {
        	WCHAR szComment[MAXCOMMENTSZ + 1];
            GetDlgItemText(hwnd, IDC_SHARE_COMMENT, szComment, ARRAYLEN(szComment));
            _pCurInfo->SetRemark(szComment);
        }

        if (_bUserLimitChanged)
        {
            if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_MAXIMUM))
            {
                _pCurInfo->SetMaxUses(SHI_USES_UNLIMITED);
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                _CacheMaxUses(hwnd);
                _pCurInfo->SetMaxUses(_wMaxUsers);
            }
        }

        //
        // Commit the changes!
        //

        ret = _pCurInfo->Commit(_pszMachine);
        if (ret != NERR_Success)
        {
            HRESULT hrMsg = 0;
            switch (_pCurInfo->GetFlag())
            {
            case SHARE_FLAG_ADDED:  hrMsg = IERR_CANT_ADD_SHARE;    break;
            case SHARE_FLAG_MODIFY: hrMsg = IERR_CANT_MODIFY_SHARE; break;
            default:
                appAssert(!"Illegal flag for a failed commit!");
            }
            DisplayError(hwnd, hrMsg, ret, _pCurInfo->GetNetname());
        }
        else
        {
            _pCurInfo->SetDirtyFlag(0);  // clear flag on success
        }

        _bDirty = FALSE;
        _bShareNameChanged = FALSE;
        _bPathChanged = FALSE;
        _bCommentChanged = FALSE;
        _bUserLimitChanged = FALSE;
        _bSecDescChanged = FALSE;
        PropSheet_UnChanged(_GetFrameWindow(),_hwndPage);

        SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, _pCurInfo->GetPath(), NULL);

        _InitializeControls(hwnd);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_DoCancel, public
//
//  Synopsis:   Do whatever is necessary to cancel the changes
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_DoCancel(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (_bDirty)
    {
        _bDirty = FALSE;
        _bShareNameChanged = FALSE;
        _bPathChanged = FALSE;
        _bCommentChanged = FALSE;
        _bUserLimitChanged = FALSE;
        _bSecDescChanged = FALSE;
        PropSheet_UnChanged(_GetFrameWindow(),_hwndPage);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_CacheMaxUses, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_CacheMaxUses(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    DWORD dwRet = (DWORD)SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_GETPOS, 0, 0);
    if (HIWORD(dwRet) != 0)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        // Reset the edit control to the new value
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }
    else
    {
        _wMaxUsers = LOWORD(dwRet);
    }
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::Dump, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CSharingPropertyPage::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CSharingPropertyPage);

    appDebugOut((DEB_TRACE,
        "CSharingPropertyPage::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t            This: 0x%08lx\n"
"\t            Page: 0x%08lx\n"
"\t   Initializing?: %ws\n"
"\t          Dirty?: %ws\n"
"\t  Share changed?: %ws\n"
"\t   Path changed?: %ws\n"
"\tComment changed?: %ws\n"
"\tUsr Lim changed?: %ws\n"
"\t        Max uses: %d\n"
"\t       _pCurInfo: 0x%08lx\n"
,
this,
_hwndPage,
_fInitializingPage ? L"yes" : L"no",
_bDirty            ? L"yes" : L"no",
_bShareNameChanged ? L"yes" : L"no",
_bPathChanged      ? L"yes" : L"no",
_bCommentChanged   ? L"yes" : L"no",
_bUserLimitChanged ? L"yes" : L"no",
_wMaxUsers,
_pCurInfo
));

    _pCurInfo->Dump(L"Current");
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\xicon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       xicon.cxx
//
//  Contents:   Implementation of CSharesEI & CSharesEIA, implementations
//              of IExtractIcon
//
//  History:    14-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "xicon.hxx"
#include "resource.h"
#include "shares.h"

STDMETHODIMP
CSharesEI::GetIconLocation(
    UINT uFlags,
    LPTSTR szIconFile,
    UINT cchMax,
    int* piIndex,
    UINT* pwFlags)
{
    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    lstrcpy(szIconFile, TEXT("shareui.dll"));

    WORD wIcon = 0;
    switch (m_bFlags)
    {
    case SHID_SHARE_1:
    case SHID_SHARE_2:
		if ((m_dwType & ~STYPE_SPECIAL) == STYPE_IPC)
		{
        	wIcon = IDI_IPC;
		}
		else
		{
        	wIcon = IDI_SHARE;
		}
        break;

#ifdef WIZARDS
    case SHID_SHARE_NW:
        wIcon = IDI_NWSHARE;
        break;

    case SHID_SHARE_MAC:
        wIcon = IDI_MACSHARE;
        break;

    case SHID_SHARE_ALL:
        wIcon = IDI_ALLSHARE;
        break;

    case SHID_SHARE_NEW:
        wIcon = IDI_NEWSHARE;
        break;
#endif // WIZARDS

    default: appAssert(!"Unknown share type");
    }

    *piIndex = -(int)wIcon;
    *pwFlags = GIL_PERINSTANCE;

    return S_OK;
}

STDMETHODIMP
CSharesEI::Extract(
    LPCTSTR pszFile,
    UINT   nIconIndex,
    HICON* phiconLarge,
    HICON* phiconSmall,
    UINT   nIconSize
    )
{
    return S_FALSE;
}


#ifdef UNICODE

STDMETHODIMP
CSharesEIA::GetIconLocation(
    UINT uFlags,
    LPSTR szIconFile,
    UINT cchMax,
    int* piIndex,
    UINT* pwFlags
    )
{
    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    lstrcpyA(szIconFile, "shareui.dll");

    WORD wIcon = 0;
    switch (m_bFlags)
    {
    case SHID_SHARE_1:
    case SHID_SHARE_2:
		if ((m_dwType & ~STYPE_SPECIAL) == STYPE_IPC)
		{
        	wIcon = IDI_IPC;
		}
		else
		{
        	wIcon = IDI_SHARE;
		}
        break;

#ifdef WIZARDS
    case SHID_SHARE_NW:
        wIcon = IDI_NWSHARE;
        break;

    case SHID_SHARE_MAC:
        wIcon = IDI_MACSHARE;
        break;

    case SHID_SHARE_ALL:
        wIcon = IDI_ALLSHARE;
        break;

    case SHID_SHARE_NEW:
        wIcon = IDI_NEWSHARE;
        break;
#endif // WIZARDS

    default: appAssert(!"Unknown share type");
    }

    *piIndex = -(int)wIcon;
    *pwFlags = GIL_PERINSTANCE;

    return S_OK;
}


STDMETHODIMP
CSharesEIA::Extract(
    LPCSTR pszFile,
    UINT   nIconIndex,
    HICON* phiconLarge,
    HICON* phiconSmall,
    UINT   nIconSize)
{
    return S_FALSE;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\lmui\shareui\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       util.cxx
//
//  Contents:   Misc helper functions
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "shares.h"
#include "util.hxx"
#include "shrpage.hxx"
#include "dlgnew.hxx"

//////////////////////////////////////////////////////////////////////////////

DECLARE_INFOLEVEL(Sharing)

#define NETMSG_DLL TEXT("netmsg.dll")

#ifdef WIZARDS
TCHAR g_szShareWizardCmd[] = TEXT("ShrPubW.exe"); // The Share Publishing Wizard
TCHAR g_szShareWizardArg[] = TEXT("/folder "); // The Share Publishing Wizard
TCHAR g_szSfm[]  = TEXT("/sfm ");   // Services For Macintosh
TCHAR g_szFpnw[] = TEXT("/fpnw ");  // File and Print Services for NetWare
TCHAR g_szAll[]  = TEXT("/all ");   // all services
#endif // WIZARDS

//--------------------------------------------------------------------------
// Globals used elsewhere

UINT        g_NonOLEDLLRefs = 0;
HINSTANCE   g_hInstance = NULL;
UINT        g_uiMaxUsers = 0;   // max number of users based on product type
WCHAR       g_szAdminShare[] = L"ADMIN$";
WCHAR       g_szIpcShare[]   = L"IPC$";
UINT        g_cfHIDA = 0;

//////////////////////////////////////////////////////////////////////////////

DWORD
ConfirmStopShare(
    IN HWND hwnd,
    IN LPWSTR pszShare
    );

NET_API_STATUS
ShareConnectionInfo(
    IN LPWSTR pszShare,
    OUT LPDWORD pcConns,
    OUT LPDWORD pcOpens
    );

//////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             g_hInstance,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        WCHAR szText[200];
        LoadString(g_hInstance, IDS_APP_MSG_NOT_FOUND, szText, ARRAYLEN(szText));
        wsprintf(pszBuffer,szText,dwMsgId);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessage
//
//  Synopsis:
//
//  Note:
//
//--------------------------------------------------------------------------
VOID
MyFormatMessage(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    ...
    )
{
    va_list arglist;
    va_start(arglist, dwBufferSize);
    MyFormatMessageText(dwMsgId, pszBuffer, dwBufferSize, &arglist);
    va_end(arglist);
}


//+-------------------------------------------------------------------------
//
//  Function:   MyCommonDialog
//
//  Synopsis:   Common popup dialog routine - stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyCommonDialog(
    IN HWND    hwnd,
    IN HRESULT dwMsgCode,
    IN PWSTR   pszCaption,
    IN DWORD   dwFlags,
    IN va_list arglist
    )
{
    WCHAR szMsgBuf[500];

    MyFormatMessageText(dwMsgCode, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    return MessageBox(hwnd, szMsgBuf, pszCaption, dwFlags);
}


//+-------------------------------------------------------------------------
//
//  Function:   MyConfirmationDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyConfirmationDialog(
    IN HWND hwnd,
    IN HRESULT dwMsgCode,
    IN DWORD dwFlags,
    ...
    )
{
    WCHAR szCaption[100];
    DWORD dwReturn;
    va_list arglist;

    va_start(arglist, dwFlags);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    dwReturn = MyCommonDialog(hwnd, dwMsgCode, szCaption, dwFlags, arglist);
    va_end(arglist);

    return dwReturn;
}


//+-------------------------------------------------------------------------
//
//  Function:   MyErrorDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
VOID
MyErrorDialog(
    IN HWND hwnd,
    IN HRESULT dwErrorCode,
    ...
    )
{
    WCHAR szCaption[100];
    va_list arglist;

    va_start(arglist, dwErrorCode);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    MyCommonDialog(hwnd, dwErrorCode, szCaption, MB_ICONSTOP | MB_OK, arglist);

    va_end(arglist);
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  History:    28-Dec-94   BruceFo   Created
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    if (NULL == psz)
    {
        appDebugOut((DEB_IERROR,"Illegal string to duplicate: NULL\n"));
        return NULL;
    }

    PWSTR pszRet = new WCHAR[wcslen(psz) + 1];
    if (NULL == pszRet)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return NULL;
    }

    wcscpy(pszRet, psz);
    return pszRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetResourceString
//
//  Synopsis:   Load a resource string, are return a "new"ed copy
//
//  Arguments:  [dwId] -- a resource string ID
//
//  Returns:    new memory copy of a string
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

PWSTR
GetResourceString(
    IN DWORD dwId
    )
{
    WCHAR sz[50];
    if (0 == LoadString(g_hInstance, dwId, sz, ARRAYLEN(sz)))
    {
        return NULL;
    }
    else
    {
        return NewDup(sz);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CopySecurityDescriptor, public
//
//  Synopsis:   Copy an NT security descriptor. The security descriptor must
//              be in self-relative (not absolute) form. Delete the result
//              using LocalFree().
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

PSECURITY_DESCRIPTOR
CopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    appDebugOut((DEB_ITRACE, "CopySecurityDescriptor, pSecDesc = 0x%08lx\n", pSecDesc));

    if (NULL == pSecDesc)
    {
        return NULL;
    }

    appAssert(IsValidSecurityDescriptor(pSecDesc));

    LONG err;

    DWORD dwLen = GetSecurityDescriptorLength(pSecDesc);
    PSECURITY_DESCRIPTOR pSelfSecDesc = reinterpret_cast<PSECURITY_DESCRIPTOR>(
		::LocalAlloc(LMEM_ZEROINIT, dwLen) );
    if (NULL == pSelfSecDesc)
    {
        appDebugOut((DEB_ERROR, "new SECURITY_DESCRIPTOR (2) failed\n"));
        return NULL;    // actually, should probably return an error
    }

    DWORD cbSelfSecDesc = dwLen;
    if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &cbSelfSecDesc))
    {
        appDebugOut((DEB_TRACE, "MakeSelfRelativeSD failed, 0x%08lx\n", GetLastError()));

        // assume it failed because it was already self-relative
        CopyMemory(pSelfSecDesc, pSecDesc, dwLen);
    }

    appAssert(IsValidSecurityDescriptor(pSelfSecDesc));

    return pSelfSecDesc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DisplayError
//
//  Synopsis:   Display an error message
//
//  History:    24-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
DisplayError(
    IN HWND           hwnd,
    IN HRESULT        dwErrorCode, // message file number. not really an HRESULT
    IN NET_API_STATUS err,
    IN PWSTR          pszShare
    )
{
    if (   err < MIN_LANMAN_MESSAGE_ID
        || err > MAX_LANMAN_MESSAGE_ID
        )
    {
        // a Win32 error?

        WCHAR szMsg[500];
        DWORD dwReturn = FormatMessage(
                                 FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 err,
                                 LANG_USER_DEFAULT,
                                 szMsg,
                                 ARRAYLEN(szMsg),
                                 NULL);
        if (0 == dwReturn)   // couldn't find message
        {
            appDebugOut((DEB_IERROR,
                "FormatMessage (from system) failed, 0x%08lx\n",
                GetLastError()));

            MyErrorDialog(hwnd, IERR_UNKNOWN, err);
        }
        else
        {
            MyErrorDialog(hwnd, dwErrorCode, pszShare, szMsg);
        }
    }
    else
    {
        DisplayLanmanError(hwnd, dwErrorCode, err, pszShare);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   DisplayLanmanError
//
//  Synopsis:   Display an error message from a LanMan error.
//
//  History:    24-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
DisplayLanmanError(
    IN HWND           hwnd,
    IN HRESULT        dwErrorCode, // message file number. not really an HRESULT
    IN NET_API_STATUS err,
    IN PWSTR          pszShare
    )
{
    if (   err < MIN_LANMAN_MESSAGE_ID
        || err > MAX_LANMAN_MESSAGE_ID
        )
    {
        MyErrorDialog(hwnd, IERR_UNKNOWN, err);
        return;
    }

    WCHAR szCaption[100];
    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));

    //
    // get LanMan message from system message file.
    //

    WCHAR szNetMsg[500];
    WCHAR szBuf[500];

    HINSTANCE hInstanceNetMsg = LoadLibrary(NETMSG_DLL);
    if (NULL == hInstanceNetMsg)
    {
        appDebugOut((DEB_IERROR,
            "LoadLibrary(netmsg.dll) failed, 0x%08lx\n",
            GetLastError()));

        LoadString(g_hInstance, IDS_NO_NET_MSG, szBuf, ARRAYLEN(szBuf));
        MessageBox(hwnd, szBuf, szCaption, MB_ICONSTOP | MB_OK);
        return;
    }

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             hInstanceNetMsg,
                             err,
                             LANG_USER_DEFAULT,
                             szNetMsg,
                             ARRAYLEN(szNetMsg),
                             NULL);
    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        LoadString(g_hInstance, IDS_NET_MSG_NOT_FOUND, szBuf, ARRAYLEN(szBuf));
        wsprintf(szNetMsg, szBuf, GetLastError());
        MessageBox(hwnd, szNetMsg, szCaption, MB_ICONSTOP | MB_OK);
    }
    else
    {
        MyErrorDialog(hwnd, dwErrorCode, pszShare, szNetMsg);
    }

    FreeLibrary(hInstanceNetMsg);
}


//+-------------------------------------------------------------------------
//
//  Function:   IsValidShareName
//
//  Synopsis:   Checks if the proposed share name is valid or not. If not,
//              it will return a message id for the reason why.
//
//  Arguments:  [pszShareName] - Proposed share name
//              [puId] - If name is invalid, this will contain the reason why.
//
//  Returns:    TRUE if name is valid, else FALSE.
//
//  History:    3-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

BOOL
IsValidShareName(
    IN  PCWSTR pszShareName,
    OUT HRESULT* uId
    )
{
    if (NetpNameValidate(NULL, (PWSTR)pszShareName, NAMETYPE_SHARE, 0L) != NERR_Success)
    {
        *uId = IERR_InvalidShareName;
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetErrorFocus
//
//  Synopsis:   Set focus to an edit control and select its text.
//
//  Arguments:  [hwnd] - dialog window
//              [idCtrl] - edit control to set focus to (and select)
//
//  Returns:    nothing
//
//  History:    3-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
SetErrorFocus(
    IN HWND hwnd,
    IN UINT idCtrl
    )
{
    HWND hCtrl = ::GetDlgItem(hwnd, idCtrl);
    ::SetFocus(hCtrl);
    ::SendMessage(hCtrl, EM_SETSEL, 0, -1);
}


//+-------------------------------------------------------------------------
//
//  Function:   ConfirmReplaceShare
//
//  Synopsis:   Display confirmations for replacing an existing share
//
//  Arguments:  [hwnd] - dialog window
//              [pszShareName] - name of share being replaced
//              [pszOldPath] - current path for the share
//              [pszNewPath] - directory the user's trying to share
//
//  Returns:    Returns IDYES, IDNO, or IDCANCEL
//
//  History:    4-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

DWORD
ConfirmReplaceShare(
    IN HWND hwnd,
    IN PCWSTR pszShareName,
    IN PCWSTR pszOldPath,
    IN PCWSTR pszNewPath
    )
{
    DWORD id = MyConfirmationDialog(
                    hwnd,
                    MSG_RESHARENAMECONFIRM,
                    MB_YESNO | MB_ICONEXCLAMATION,
                    pszOldPath,
                    pszShareName,
                    pszNewPath);
    if (id != IDYES)
    {
        return id;
    }

    return ConfirmStopShare(hwnd, (PWSTR)pszShareName);
}

//+-------------------------------------------------------------------------
//
//  Member:     ConfirmStopShare, public
//
//  Synopsis:   Display the appropriate confirmations when stopping a share.
//
//  Arguments:  [hwnd] - parent window handle for messages
//              [pszShare] - ptr to affected share name
//
//  Returns:    IDYES if share should be deleted, IDNO if we don't want to
//              delete, but keep going, IDCANCEL to stop going.
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

DWORD
ConfirmStopShare(
    IN HWND hwnd,
    IN LPWSTR pszShare
    )
{
    DWORD cConns, cOpens;
    NET_API_STATUS err = ShareConnectionInfo(pszShare, &cConns, &cOpens);
    if (err != NERR_Success)
    {
        DisplayError(hwnd, IERR_CANT_DEL_SHARE, err, pszShare);
        return IDYES;   // allow the stop anyway
    }

    if (cConns != 0)
    {
        // If there are any open files, just give the more detailed
        // message about there being open files. Otherwise, just say how
        // many connections there are.

        if (cOpens != 0)
        {
            return MyConfirmationDialog(
                        hwnd,
                        MSG_STOPSHAREOPENS,
                        MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                        cOpens,
                        cConns,
                        pszShare);
        }
        else
        {
            return MyConfirmationDialog(
                        hwnd,
                        MSG_STOPSHARECONNS,
                        MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                        cConns,
                        pszShare);
        }
    }

    return IDYES;           /* OK to delete */
}



//+-------------------------------------------------------------------------
//
//  Member:     ShareConnectionInfo, public
//
//  Synopsis:   Determine how many connections and file opens exist for a
//              share, for use by confirmation dialogs.
//
//  Arguments:  [pszShare] - ptr to affected share name
//              [pcConns]  - *pcConns get the number of connections
//              [pcOpens]  - *pcOpens get the number of file opens
//
//  Returns:    standard net api code, NERR_Success if everything ok.
//
//  History:    19-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

NET_API_STATUS
ShareConnectionInfo(
    IN LPWSTR pszShare,
    OUT LPDWORD pcConns,
    OUT LPDWORD pcOpens
    )
{
    CONNECTION_INFO_1* pBuf;

    DWORD iEntry, iTotal;
    NET_API_STATUS err = NetConnectionEnum(
                            NULL,
                            pszShare,
                            1,
                            (LPBYTE*)&pBuf,
                            0xffffffff,     // no buffer limit; get them all!
                            &iEntry,
                            &iTotal,
                            NULL);

   if ((err == NERR_Success) || (err == ERROR_MORE_DATA))
   {
      int iConnections = 0;
      for (DWORD i = 0; i < iEntry; i++)
      {
          iConnections += pBuf[i].coni1_num_opens;
      }

      *pcConns = iTotal;
      *pcOpens = iConnections;
      err = NERR_Success;
   }
   else
   {
      *pcConns = 0;
      *pcOpens = 0;
   }
   NetApiBufferFree(pBuf);

   appDebugOut((DEB_ITRACE,"Share '%ws' has %d connections and %d opens\n", pszShare, *pcConns, *pcOpens));

   return err;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsWorkstationProduct
//
//  Synopsis:   Determines the NT product type (server or workstation),
//              and returns TRUE if it is workstation.
//
//  Arguments:  (none)
//
//  Returns:    TRUE if running on workstation products
//
//  History:    11-Sep-95 BruceFo   Created
//
//----------------------------------------------------------------------------

BOOL
IsWorkstationProduct(
    VOID
    )
{
    //
    // Determine whether this is the workstation or server product by looking
    // at HKEY_LOCAL_MACHINE, System\CurrentControlSet\Control\ProductOptions.
    // The ProductType value therein is interpreted as follows:
    //
    // LanmanNt -- server product, running as domain controller
    // ServerNt -- server product, not a domain controller
    // WinNT    -- workstation product
    //

    LONG    ec;
    HKEY    hkey;
    DWORD   type;
    DWORD   size;
    UCHAR   buf[100];
    BOOL    fIsWorkstation = TRUE;

    ec = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                0,
                KEY_QUERY_VALUE,
                &hkey
                );

    if (ec == NO_ERROR)
    {
        size = sizeof(buf);
        ec = RegQueryValueEx(hkey,
                             TEXT("ProductType"),
                             NULL,
                             &type,
                             buf,
                             &size);

        if ((ec == NO_ERROR) && (type == REG_SZ))
        {
            if (0 == lstrcmpi((LPTSTR)buf, TEXT("lanmannt")))
            {
                fIsWorkstation = FALSE;
            }

            if (0 == lstrcmpi((LPTSTR)buf, TEXT("servernt")))
            {
                fIsWorkstation = FALSE;
            }
        }

        RegCloseKey(hkey);
    }

    return fIsWorkstation;
}

BOOL
DriveLetterShare(
    PWSTR pszShareName
    )
{
    if (NULL == pszShareName || lstrlen(pszShareName) != 2)
    {
        return FALSE;
    }

    // BUGBUG: what about non-English char sets?
    return (   ((pszShareName[0] >= TEXT('a')) && pszShareName[0] <= TEXT('z'))
            || ((pszShareName[0] >= TEXT('A')) && pszShareName[0] <= TEXT('Z'))
            )
           && (pszShareName[1] == TEXT('$'))
           ;
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Function:   DumpNetEnum
//
//  Synopsis:   Dumps an array of SHARE_INFO_1 structures.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

VOID
DumpNetEnum(
    IN LPVOID pBufShares,
    IN ULONG entriesRead
    )
{
    SHARE_INFO_1* pBase = (SHARE_INFO_1*) pBufShares;

    appDebugOut((DEB_TRACE,
        "DumpNetEnum: %d entries\n",
        entriesRead));

    for (ULONG i = 0; i < entriesRead; i++)
    {
        SHARE_INFO_1* p = &(pBase[i]);

        appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t Share name: %ws\n"
"\t       Type: %d (0x%08lx)\n"
"\t    Comment: %ws\n"
"\n"
,
p->shi1_netname,
p->shi1_type, p->shi1_type,
p->shi1_remark
));

    }
}

#endif // DBG == 1

struct SHARE_PROPERTIES_DATA
{
    IUnknown* punk;
    LPTSTR    pszMachine;
    LPTSTR    pszShareName;
};

DWORD CALLBACK
SharePropertiesThreadProc(
    LPVOID lpThreadParameter
    )
{
    SHARE_PROPERTIES_DATA* pData = (SHARE_PROPERTIES_DATA*)lpThreadParameter;
    if (NULL == pData)
    {
        appAssert(!"Unexpected properties thread data");
        return 0;
    }

    WCHAR szCaption[MAX_PATH];
    LoadString(g_hInstance, IDS_SHARE_PROPTITLE, szCaption, ARRAYLEN(szCaption));

    SHARE_PROPSHEETPAGE sprop;

    sprop.psp.dwSize      = sizeof(sprop);    // no extra data.
    sprop.psp.dwFlags     = PSP_USEREFPARENT;
    sprop.psp.hInstance   = g_hInstance;
    sprop.psp.pszTemplate = MAKEINTRESOURCE(IDD_SHARE_PROPERTIES);
    sprop.psp.hIcon       = NULL;
    sprop.psp.pszTitle    = NULL;
    sprop.psp.pfnDlgProc  = CSharingPropertyPage::DlgProcPage;
    sprop.psp.lParam      = 0;
    sprop.psp.pfnCallback = NULL;
    sprop.psp.pcRefParent = &g_NonOLEDLLRefs;
    sprop.pszMachine      = pData->pszMachine;
    sprop.pszShareName    = pData->pszShareName;

    PROPSHEETHEADER psh;

    psh.dwSize     = sizeof(PROPSHEETHEADER);
    psh.dwFlags    = PSH_PROPSHEETPAGE | PSH_USEICONID;
    psh.hwndParent = NULL;
    psh.hInstance  = g_hInstance;
    psh.pszIcon    = MAKEINTRESOURCE(IDI_SHARESFLD);
    psh.pszCaption = szCaption;
    psh.nPages     = 1;
    psh.nStartPage = 0;
    psh.ppsp       = (LPCPROPSHEETPAGE)&sprop;
    psh.pfnCallback= NULL;

    PropertySheet(&psh);

    pData->punk->Release();
    LocalFree(pData);       // The strings are packed in the same allocation!
    return 0;
}

HRESULT
ShareDoProperties(
    IN IUnknown* punk,
    IN LPTSTR    pszMachine,
    IN LPTSTR    pszShareName
    )
{
    if (NULL == pszShareName)
    {
        return E_INVALIDARG;
    }

    DWORD cbMachine = 0;
    DWORD cbStrings = 0;
    if (NULL != pszMachine)
    {
        cbMachine = (lstrlen(pszMachine) + 1) * sizeof(TCHAR);
        cbStrings += cbMachine;
    }
    cbStrings += (lstrlen(pszShareName) + 1) * sizeof(TCHAR);

    HRESULT hr = S_OK;
    HANDLE hThread;
    DWORD idThread;
    SHARE_PROPERTIES_DATA* pData = (SHARE_PROPERTIES_DATA*)LocalAlloc(LPTR, sizeof(SHARE_PROPERTIES_DATA) + cbStrings);
    if (pData)
    {
        if (NULL != pszMachine)
        {
            pData->pszMachine = (LPWSTR)(((LPBYTE)pData) + sizeof(SHARE_PROPERTIES_DATA));
            lstrcpy(pData->pszMachine, pszMachine);
        }
        else
        {
            pData->pszMachine   = NULL;
        }
        pData->pszShareName = (LPWSTR)(((LPBYTE)pData) + sizeof(SHARE_PROPERTIES_DATA) + cbMachine);
        lstrcpy(pData->pszShareName, pszShareName);

        pData->punk = punk;
        pData->punk->AddRef();

        hThread = CreateThread(NULL, 0, SharePropertiesThreadProc, pData, 0, &idThread);

        if (hThread)
        {
            CloseHandle(hThread);
            return S_OK;
        }
        else
        {
            pData->punk->Release();
            LocalFree(pData);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT
ShareDoDelete(
    IN HWND hwndOwner,
    IN PWSTR pszMachine,
    IN PWSTR pszShareName
    )
{
    // Remove the share. We need to know the path that was
    // shared to be able to update the explorer. So, get
    // that.
    SHARE_INFO_1* pInfo1 = NULL;
    SHARE_INFO_2* pInfo2 = NULL;
    DWORD ret;
    HRESULT hr = S_OK;

    ret = NetShareGetInfo(pszMachine, pszShareName, 2, (LPBYTE*)&pInfo2);
    if (NERR_Success != ret)
    {
        // make sure it's null
        pInfo2 = NULL;
    }

    // Warn and confirm if it's a special share, either ADMIN$, IPC$,
    // or <drive>$
    if (NULL == pInfo2)
    {
        // Permissions problem? Try getting SHARE_INFO_1.

        ret = NetShareGetInfo(pszMachine, pszShareName, 1, (LPBYTE*)&pInfo1);
        if (NERR_Success != ret)
        {
            // make sure it's null
            pInfo1 = NULL;
        }
    }
    else
    {
        pInfo1 = (SHARE_INFO_1*)pInfo2; // I just need the type
    }

    if (NULL != pInfo1)
    {
        DWORD id = IDYES;
        if (pInfo1->shi1_type & STYPE_SPECIAL)
        {
            id = MyConfirmationDialog(
                            hwndOwner,
                            MSG_DELETESPECIAL,
                            MB_YESNO | MB_ICONEXCLAMATION,
                            pszShareName);
        }

        if (pInfo1 != (SHARE_INFO_1*)pInfo2)
        {
            NetApiBufferFree(pInfo1);
        }

        if (id != IDYES)
        {
            hr = S_OK;
            goto nodelete;
        }
    }

    // Actually delete the share
    ret = NetShareDel(pszMachine, pszShareName, 0);
    if (NERR_Success == ret)
    {
        if (NULL != pInfo2)
        {
            SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, pInfo2->shi2_path, 0);
        }
    }
    else
    {
        // BUGBUG: error message to user

        hr = HRESULT_FROM_WIN32(GetLastError());
    }

nodelete:
    if (NULL != pInfo2)
    {
        NetApiBufferFree(pInfo2);
    }

    return hr;
}

struct SHARE_NEW_DATA
{
    IUnknown* punk;
    LPTSTR    pszMachine;
};

DWORD CALLBACK
ShareNewThreadProc(
    LPVOID lpThreadParameter
    )
{
    SHARE_NEW_DATA* pData = (SHARE_NEW_DATA*)lpThreadParameter;
    if (NULL == pData)
    {
        appAssert(!"Unexpected properties thread data");
        return 0;
    }

    CDlgNewShare dlg(NULL, pData->pszMachine);
    if (dlg.DoModal())
    {
    }

    pData->punk->Release();
    LocalFree(pData);       // The strings are packed in the same allocation!
    return 0;
}


HRESULT
ShareDoNew(
    IN IUnknown* punk,
    IN PWSTR pszMachine
    )
{
    DWORD cbStrings = 0;
    if (NULL != pszMachine)
    {
        cbStrings += (lstrlen(pszMachine) + 1) * sizeof(TCHAR);
    }

    HRESULT hr = S_OK;
    HANDLE hThread;
    DWORD idThread;
    SHARE_NEW_DATA* pData = (SHARE_NEW_DATA*)LocalAlloc(LPTR, sizeof(SHARE_NEW_DATA) + cbStrings);
    if (pData)
    {
        if (NULL != pszMachine)
        {
            pData->pszMachine = (LPWSTR)(((LPBYTE)pData) + sizeof(SHARE_NEW_DATA));
            lstrcpy(pData->pszMachine, pszMachine);
        }
        else
        {
            pData->pszMachine   = NULL;
        }

        pData->punk = punk;
        pData->punk->AddRef();

        hThread = CreateThread(NULL, 0, ShareNewThreadProc, pData, 0, &idThread);

        if (hThread)
        {
            CloseHandle(hThread);
            return S_OK;
        }
        else
        {
            pData->punk->Release();
            LocalFree(pData);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


#ifdef WIZARDS
HRESULT
ShareDoSpecial(
    IN HWND hwndOwner,
    IN PWSTR pszMachine,
    IN BYTE bType
    )
{
    // Construct the command line to pass to the Share Wizard

    TCHAR szCommandLine[MAX_PATH];
    lstrcpy(szCommandLine, g_szShareWizardArg);

    switch (bType)
    {
    case SHID_SHARE_NW:
        wcscat(szCommandLine, g_szFpnw);
        break;

    case SHID_SHARE_MAC:
        wcscat(szCommandLine, g_szSfm);
        break;

    case SHID_SHARE_ALL:
        wcscat(szCommandLine, g_szAll);
        break;

    case SHID_SHARE_NEW:
        // nothing special
        break;

    default: appAssert(!"Unknown object type");
    }

    if (NULL != pszMachine)
    {
        wcscat(szCommandLine, pszMachine);
    }

    appDebugOut((DEB_TRACE, "Invoking wizard with this command line: %ws\n", szCommandLine));

    // Looks like CreateProcess writes to this buffer!
    STARTUPINFO si = { 0 };
    si.cb = sizeof(si);
    PROCESS_INFORMATION pi = { 0 };
    BOOL b = CreateProcess(
                    g_szShareWizardCmd,
                    szCommandLine,
                    NULL,   // pointer to process security attributes
                    NULL,   // pointer to thread security attributes
                    FALSE,  // handle inheritance flag
                    0,      // creation flags
                    NULL,   // pointer to new environment block
                    NULL,   // pointer to current directory name
                    &si,    // pointer to STARTUPINFO
                    &pi);   // pointer to PROCESS_INFORMATION
    if (b)
    {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    else
    {
        appDebugOut((DEB_ERROR,
            "CreateProcess failed, 0x%08lx\n",
            GetLastError()));

        MyErrorDialog(hwndOwner, MSG_NOWIZARD);
    }

    return S_OK;
}
#endif // WIZARDS


VOID FSSetStatusText(HWND hwndOwner, LPTSTR* ppszText, int iStart, int iEnd)
{
    HWND hwndStatus = NULL;
    IShellBrowser* psb = FileCabinet_GetIShellBrowser(hwndOwner);

    if (psb)
    {
        psb->GetControlWindow(FCW_STATUS, &hwndStatus);
        if (hwndStatus)
        {
            for (; iStart <= iEnd; iStart++)
            {
                LPTSTR lpsz;

                if (ppszText)
                {
                    lpsz = *ppszText;
                    ppszText++;
                }
                else
                {
                    lpsz = (LPTSTR)TEXT("");
                }
#ifdef WINDOWS_ME
                SendMessage(hwndStatus, SB_SETTEXT, SB_RTLREADING | (WPARAM)iStart, (LPARAM)lpsz);
#else
                SendMessage(hwndStatus, SB_SETTEXT, (WPARAM)iStart, (LPARAM)lpsz);
#endif
            }
        }
    }
}


BOOL
IsLevelOk(
    IN PWSTR pszMachine,
    IN DWORD level
    )
{
    LPBYTE pBuf = NULL;
    DWORD entriesread, totalentries;
    NET_API_STATUS ret;

    // we want to get the minimum amount of data, because all we care about
    // is whether it succeeds the access check
    DWORD prefmaxlen = 300;
    for (;; prefmaxlen *= 2)
    {
        ret = NetShareEnum(
                        pszMachine,
                        level,
                        &pBuf,
                        prefmaxlen,
                        &entriesread,
                        &totalentries,
                        NULL);
        if (NERR_BufTooSmall != ret)
        {
            NetApiBufferFree(pBuf);
            break;
        }
    }

    if (ERROR_ACCESS_DENIED == ret)
    {
        return FALSE;
    }
    else if (NERR_Success == ret || ERROR_MORE_DATA == ret)
    {
        return TRUE;
    }
    else
    {
        // some other error
        return FALSE;
    }
}


VOID
SetDialogIconBig(
    IN HWND hwnd,
    WORD idIcon
    )
{
    HICON hiconLarge = (HICON)LoadImage(
                            g_hInstance,
                            MAKEINTRESOURCE(idIcon),
                            IMAGE_ICON,
                            GetSystemMetrics(SM_CXICON),
                            GetSystemMetrics(SM_CYICON),
                            LR_DEFAULTCOLOR);
    if (NULL == hiconLarge)
    {
        appDebugOut((DEB_ERROR,
            "LoadImage for large image failed, 0x%08lx\n",
            GetLastError()));
    }
    else
    {
        SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hiconLarge);
    }
}


VOID
SetDialogIconSmall(
    IN HWND hwnd,
    WORD idIcon
    )
{
    HICON hiconSmall = (HICON)LoadImage(
                            g_hInstance,
                            MAKEINTRESOURCE(idIcon),
                            IMAGE_ICON,
                            GetSystemMetrics(SM_CXSMICON),
                            GetSystemMetrics(SM_CYSMICON),
                            LR_DEFAULTCOLOR);
    if (NULL == hiconSmall)
    {
        appDebugOut((DEB_ERROR,
            "LoadImage for small image failed, 0x%08lx\n",
            GetLastError()));
    }
    else
    {
        SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hiconSmall);
    }
}

//////////////////////////////////////////////////////////////////////////////

HRESULT
STRRETLoadString(
    UINT ids,
    STRRET* pstr
    )
{
#ifdef UNICODE
    TCHAR szTemp[MAX_PATH];
    szTemp[0] = TEXT('\0');

    LoadString(g_hInstance, ids, szTemp, ARRAYLEN(szTemp));
    pstr->pOleStr = (LPOLESTR)SHAlloc((lstrlen(szTemp)+1) * sizeof(TCHAR));
    if (NULL != pstr->pOleStr)
    {
        pstr->uType = STRRET_OLESTR;
        lstrcpy(pstr->pOleStr, szTemp);
    }
    else
    {
        pstr->uType = STRRET_CSTR;
        pstr->cStr[0] = '\0';
        return E_OUTOFMEMORY;
    }
#else
    pstr->uType = STRRET_CSTR;
    LoadString(g_hInstance, ids, pstr->cStr, ARRAYLEN(pstr->cStr));
#endif

    return S_OK;
}

HRESULT
STRRETCopy(
    LPTSTR pszString,
    STRRET* pstr
    )
{
#ifdef UNICODE
    pstr->pOleStr = (LPOLESTR)SHAlloc((lstrlen(pszString)+1) * sizeof(TCHAR));
    if (NULL != pstr->pOleStr)
    {
        pstr->uType = STRRET_OLESTR;
        lstrcpy(pstr->pOleStr, pszString);
    }
    else
    {
        pstr->uType = STRRET_CSTR;
        pstr->cStr[0] = '\0';
        return E_OUTOFMEMORY;
    }
#else
    pstr->uType = STRRET_CSTR;
    int cch = lstrlen(pszString);
    cch = min(cch, ARRAYLEN(pstr->cStr) - 1);
    strncpy(pstr->cStr, pszString, cch);
    pszString[cch] = '\0';
#endif

    return S_OK;
}


VOID
FillSpecialID(
    LPIDSHARE pids,
    BYTE bFlags,        // SHID_SHARE_*
    UINT idsName
    )
{
    WCHAR szBuf[MAX_PATH];
    szBuf[0] = L'\0';
    LoadString(g_hInstance, idsName, szBuf, ARRAYLEN(szBuf));
    LPWSTR pszName    = szBuf;
    USHORT nameLength = (USHORT)lstrlen(pszName);
    USHORT nameOffset = 0;

    pids->bFlags      = bFlags;
    pids->bReserved   = 0;
    pids->maxUses     = 0xffffffff;     // bogus

    // we don't store nameOffset
    pids->oComment = 0xffff;            // bogus
    pids->oPath    = 0xffff;            // bogus

    lstrcpy(&pids->cBuf[nameOffset],    pszName);

    pids->cb = offsetof(IDSHARE, cBuf)
               + (nameLength + 1) * sizeof(WCHAR);

    //
    // null terminate pidl
    //

    *(USHORT *)((LPBYTE)pids + pids->cb) = 0;
}

VOID
FillID1(
    LPIDSHARE pids,
    LPSHARE_INFO_1 pInfo
    )
{
    LPWSTR pszName    = pInfo->shi1_netname;
    LPWSTR pszComment = pInfo->shi1_remark;

    USHORT  nameLength, commentLength;
    USHORT  nameOffset, commentOffset;

    nameLength    = (USHORT)lstrlen(pszName);
    commentLength = (USHORT)lstrlen(pszComment);

    nameOffset    = 0;
    commentOffset = nameOffset + nameLength + 1;

    pids->bFlags      = SHID_SHARE_1;
    pids->bReserved   = 0;
    pids->type        = pInfo->shi1_type;
    pids->maxUses     = 0xffffffff;     // bogus

    // we don't store nameOffset
    pids->oComment = commentOffset;
    pids->oPath    = 0xffff;            // bogus

    lstrcpy(&pids->cBuf[nameOffset],    pszName);
    lstrcpy(&pids->cBuf[commentOffset], pszComment);

    pids->cb = offsetof(IDSHARE, cBuf)
               + (nameLength + 1 + commentLength + 1) * sizeof(WCHAR);

    //
    // null terminate pidl
    //

    *(USHORT *)((LPBYTE)pids + pids->cb) = 0;
}


VOID
FillID2(
    LPIDSHARE pids,
    LPSHARE_INFO_2 pInfo
    )
{
    LPWSTR pszName    = pInfo->shi2_netname;
    LPWSTR pszComment = pInfo->shi2_remark;
    LPWSTR pszPath    = pInfo->shi2_path;

    USHORT  nameLength, commentLength, pathLength;
    USHORT  nameOffset, commentOffset, pathOffset;

    nameLength    = (USHORT)lstrlen(pszName);
    commentLength = (USHORT)lstrlen(pszComment);
    pathLength    = (USHORT)lstrlen(pszPath);

    nameOffset    = 0;
    commentOffset = nameOffset + nameLength + 1;
    pathOffset    = commentOffset + commentLength + 1;

    pids->bFlags      = SHID_SHARE_2;
    pids->bReserved   = 0;
    pids->type        = pInfo->shi2_type;
    pids->maxUses     = pInfo->shi2_max_uses;

    // we don't store nameOffset
    pids->oComment = commentOffset;
    pids->oPath    = pathOffset;

    lstrcpy(&pids->cBuf[nameOffset],    pszName);
    lstrcpy(&pids->cBuf[commentOffset], pszComment);
    lstrcpy(&pids->cBuf[pathOffset],    pszPath);

    pids->cb = offsetof(IDSHARE, cBuf)
               + (nameLength + 1 + commentLength + 1 + pathLength + 1) * sizeof(WCHAR);

    //
    // null terminate pidl
    //

    *(USHORT *)((LPBYTE)pids + pids->cb) = 0;
}


VOID
StrNCopy(
    OUT LPWSTR pszTarget,
    IN LPCWSTR pszSource,
    IN DWORD cchTarget
    )
{
    DWORD cch = lstrlen(pszSource) + 1;
    cch = min(cch, cchTarget);
    wcsncpy(pszTarget, pszSource, cch - 1);
    pszTarget[cch - 1] = TEXT('\0');
}



//+---------------------------------------------------------------------------
//
//  Function:   TrimLeadingAndTrailingSpaces
//
//  Synopsis:   Trims the leading and trailing spaces from a null-terminated string.
//              Used primarily for share names.
//
//  History:    18-Jul-97 JonN      Created
//
//----------------------------------------------------------------------------

VOID
TrimLeadingAndTrailingSpaces(
    IN OUT PWSTR psz
	)
{
	int cchStrlen = ::wcslen(psz);
	int cchLeadingSpaces = 0;
	int cchTrailingSpaces = 0;
	while (L' ' == psz[cchLeadingSpaces])
		cchLeadingSpaces++;
	if (cchLeadingSpaces < cchStrlen)
	{
		while (L' ' == psz[cchStrlen-(cchTrailingSpaces+1)])
			cchTrailingSpaces++;
	}
	if ((cchLeadingSpaces+cchTrailingSpaces) > 0)
	{
		cchStrlen -= (cchLeadingSpaces+cchTrailingSpaces);
		(void)memmove( psz,
		               psz+cchLeadingSpaces,
					   cchStrlen*sizeof(WCHAR) );
		psz[cchStrlen] = L'\0';
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\migrate\shell.cpp ===
/*****************************************************************************\
    FILE: shell.cpp

    DESCRIPTION:
        Upgrade shell settings

    BryanSt 10/14/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


#include <windows.h>
#include <tchar.h>
#include <shlwapi.h>                // PathAppend
#include <wininet.h>                // IActiveDesktop
#include <shlobj.h>                 // IActiveDesktop
#include <shlobjp.h>                // IActiveDesktop
#include <shlguid.h>                // IActiveDesktop
#include <shlguidp.h>               // IActiveDesktop

#include "shmgdefs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\migrate\gradient.c ===
#include <windows.h>
#include <stdio.h>
#include "shmgdefs.h"

#undef COLOR_MAX

#define COLOR_MAX (COLOR_GRADIENTINACTIVECAPTION + 1)
#define COLOR_MAX_NT4 (COLOR_INFOBK + 1)
#define SCHEME_MAX 27

CONST TCHAR* rgpszSchemes[SCHEME_MAX] = {
    TEXT("High Contrast Black (EL)"),       // 0
    TEXT("High Contrast White (EL)"),       // 1
    TEXT("Brick"),                          // 2
    TEXT("Desert"),                         // 3
    TEXT("Eggplant"),                       // 4
    TEXT("High Contrast Black"),            // 5
    TEXT("High Contrast White"),            // 6
    TEXT("Lilac"),                          // 7
    TEXT("Marine (HC)"),                    // 8
    TEXT("Plum (HC)"),                      // 9
    TEXT("Pumpkin (L)"),                    // 10
    TEXT("Rainy Day"),                      // 11
    TEXT("Red, White, and Blue (VGA)"),     // 12
    TEXT("Rose"),                           // 13
    TEXT("Slate"),                          // 14
    TEXT("Spruce"),                         // 15
    TEXT("Storm (VGA)"),                    // 16
    TEXT("Teal (VGA)"),                     // 17
    TEXT("Windows Standard"),               // 18
    TEXT("Rose (large)"),                   // 19
    TEXT("High Contrast Black (L)"),        // 20
    TEXT("High Contrast White (L)"),        // 21
    TEXT("Lilac (large)"),                  // 22
    TEXT("Windows Standard (EL)"),          // 23
    TEXT("Windows Standard (L)"),           // 24
    TEXT("Maple"),                          // 25
    TEXT("Wheat)")                          // 26
};

CONST TCHAR* rgpsz[COLOR_MAX] = {
    TEXT("Scrollbar"),
    TEXT("Background"),
    TEXT("ActiveTitle"),
    TEXT("InactiveTitle"),
    TEXT("Menu"),
    TEXT("Window"),
    TEXT("WindowFrame"),
    TEXT("MenuText"),
    TEXT("WindowText"),
    TEXT("TitleText"),
    TEXT("ActiveBorder"),
    TEXT("InactiveBorder"),
    TEXT("AppWorkspace"),
    TEXT("Hilight"),
    TEXT("HilightText"),
    TEXT("ButtonFace"),
    TEXT("ButtonShadow"),
    TEXT("GrayText"),
    TEXT("ButtonText"),
    TEXT("InactiveTitleText"),
    TEXT("ButtonHilight"),
    TEXT("ButtonDkShadow"),
    TEXT("ButtonLight"),
    TEXT("InfoText"),
    TEXT("InfoWindow"),
    TEXT("ButtonAlternateFace"),
    TEXT("HotTracking"),
    TEXT("GradientActiveTitle"),
    TEXT("GradientInactiveTitle")
};

COLORREF rgcr[SCHEME_MAX][COLOR_MAX] = {
{0x02000000,0x02000000,0x02800080,0x02008000,0x02000000,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x0200FFFF,0x02008000,0x02000000,0x02800080,0x02FFFFFF,0x02000000,0x02808080,0x0200FF00,0x02FFFFFF,0x02FFFFFF,0x02C0C0C0,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x02800080,0x02800080,0x02800080,0x02008000},
{0x02FFFFFF,0x02FFFFFF,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02808080,0x02C0C0C0,0x02808080,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02808080,0x0200FF00,0x02000000,0x02000000,0x02C0C0C0,0x02000000,0x02C0C0C0,0x02000000,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF},
{0x02D2E0E1,0x00000042,0x02000080,0x0261898D,0x02A5BFC2,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02D2E0E1,0x02A5BFC2,0x02A5BFC2,0x02D2E0E1,0x0261898D,0x02FFFFFF,0x02A5BFC2,0x0261898D,0x0261898D,0x02000000,0x02D2E0E1,0x02D2E0E1,0x02000000,0x02A5BFC2,0x02000080,0x02D2E0E1,0x00C0C0C0,0x02000080,0x004074B0,0x0270B8C8},
{0x02DDE6EA,0x02688DA2,0x02808000,0x02688DA2,0x02BBCCD5,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02BBCCD5,0x02BBCCD5,0x02688DA2,0x02808000,0x02FFFFFF,0x02BBCCD5,0x02688DA2,0x02688DA2,0x02000000,0x02FFFFFF,0x02DDE6EA,0x02000000,0x02BBCCD5,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02808000,0x00AABD84,0x0280D0E8},
{0x02A8B090,0x00400040,0x02788058,0x02A8B090,0x02A8B090,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02A8B090,0x02A8B090,0x02808080,0x02788058,0x02FFFFFF,0x02A8B090,0x02788058,0x02788058,0x02000000,0x02788058,0x02D8D8C8,0x02000000,0x02A8B090,0x02800080,0x02FFFFFF,0x00C0C0C0,0x02788058,0x00834B83,0x00D2BDCB},
{0x02000000,0x02000000,0x02800080,0x02008000,0x02000000,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x0200FFFF,0x02008000,0x02000000,0x02800080,0x02FFFFFF,0x02000000,0x02808080,0x0200FF00,0x02FFFFFF,0x02FFFFFF,0x02C0C0C0,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x00C0C0C0,0x02800080,0x02D88CC8,0x0012B42B},
{0x02FFFFFF,0x02FFFFFF,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02808080,0x02C0C0C0,0x02808080,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02808080,0x0200FF00,0x02000000,0x02000000,0x02C0C0C0,0x02000000,0x02C0C0C0,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02000000,0x02A09CA0,0x02D8D4D8},
{0x02D9A8AE,0x02000000,0x02B14E5A,0x02808080,0x02D9A8AE,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02D9A8AE,0x02D9A8AE,0x02B14E5A,0x02B14E5A,0x02FFFFFF,0x02D9A8AE,0x02B14E5A,0x02B14E5A,0x02000000,0x02FFFFFF,0x02ECD5D8,0x02000000,0x02D9A8AE,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02B14E5A,0x02CB8FB6,0x02D0B4B8},
{0x02D8E0C8,0x00474E2C,0x02800000,0x02889048,0x02B8C088,0x02D8E0C8,0x02000000,0x02000000,0x02000000,0x02C0C0C0,0x02B8C088,0x02B8C088,0x00848D4B,0x02800000,0x02FFFFFF,0x02B8C088,0x02889048,0x02889048,0x02000000,0x02C0C0C0,0x02D8E0C8,0x02000000,0x02B8C088,0x02000000,0x02D8E0C8,0x00C0C0C0,0x02800000,0x02C0B418,0x02D8CC78},
{0x00C8D0D8,0x00402840,0x00604048,0x00586078,0x009098A8,0x00C8D0D8,0x00000000,0x00000000,0x00000000,0x00C8D0D8,0x009098A8,0x009098A8,0x005A6374,0x00484828,0x00C8D0D8,0x009098A8,0x00586078,0x00586078,0x00000000,0x009098A8,0x00C8D0D8,0x00000000,0x009098A8,0x00580030,0x00C8CCD5,0x00C0C0C0,0x00604048,0x00B884A0,0x007898A8},
{0x02CFEAF5,0x00420042,0x022FA5D7,0x02A4A0A0,0x029DD5EC,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x029DD5EC,0x029DD5EC,0x02CFEAF5,0x02800080,0x02FFFFFF,0x029DD5EC,0x022FA5D7,0x022FA5D7,0x02000000,0x02CFEAF5,0x02CFEAF5,0x02000000,0x029DD5EC,0x02800080,0x02FFFFFF,0x00C0C0C0,0x022FA5D7,0x0288CCE0,0x0290CCD0},
{0x02D9CCC1,0x02000000,0x027D654F,0x02808080,0x02B19983,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02B19983,0x02B19983,0x02808080,0x027D654F,0x02FFFFFF,0x02B19983,0x027D654F,0x027D654F,0x02000000,0x02D9CCC1,0x02D9CCC1,0x02000000,0x02B19983,0x02000000,0x02FFFFFF,0x00C0C0C0,0x027D654F,0x02D0B480,0x02D0BCB0},
{0x02C0C0C0,0x00420000,0x02000080,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02FFFFFF,0x02000080,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02C0C0C0,0x02800000,0x02FFFFFF,0x00C0C0C0,0x02000080,0x02A81000,0x00C9BEBA},
{0x02B7AFCF,0x02808080,0x0270609F,0x02A4A0A0,0x02B7AFCF,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02B7AFCF,0x02B7AFCF,0x0270609F,0x0270609F,0x02FFFFFF,0x02B7AFCF,0x0270609F,0x0270609F,0x02000000,0x02000000,0x02DCD8E7,0x02000000,0x02B7AFCF,0x02000000,0x02FFFFFF,0x00C0C0C0,0x0270609F,0x02D0CCD8,0x02D0D4D0},
{0x02E3DCCE,0x00414141,0x02978055,0x02808080,0x02C8B99D,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C8B99D,0x02C8B99D,0x00424242,0x02978055,0x02FFFFFF,0x02C8B99D,0x02978055,0x02978055,0x02000000,0x02C0C0C0,0x02E3DCCE,0x02000000,0x02C8B99D,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02978055,0x02D8B888,0x02C8BCA0},
{0x02D3E3D0,0x00213F21,0x02649759,0x02808080,0x02A9C8A2,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02A9C8A2,0x02A9C8A2,0x02D3E3D0,0x02649759,0x02FFFFFF,0x02A9C8A2,0x02649759,0x02649759,0x02000000,0x02D3E3D0,0x02D3E3D0,0x02000000,0x02A9C8A2,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02649759,0x02E8C898,0x02B0CCA8},
{0x02C0C0C0,0x02000000,0x02800080,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02808080,0x02800080,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02000000,0x02FFFFFF,0x02000000,0x02C0C0C0,0x02800080,0x02FFFFFF,0x00C0C0C0,0x02800080,0x02B08C38,0x02A8ACA8},
{0x02C0C0C0,0x00404000,0x02808000,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02808080,0x02808000,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02F0FBFF,0x02FFFFFF,0x02000000,0x02C0C0C0,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02808000,0x00D8CC00,0x02B8C898},
{0x00C0C0C0,0x00808000,0x00800000,0x00808080,0x00C0C0C0,0x00FFFFFF,0x00000000,0x00000000,0x00000000,0x00FFFFFF,0x00C0C0C0,0x00C0C0C0,0x00808080,0x00800000,0x00FFFFFF,0x00C0C0C0,0x00808080,0x00808080,0x00000000,0x00C0C0C0,0x00FFFFFF,0x00000000,0x00C0C0C0,0x00000000,0x00E1FFFF,0x00C0C0C0,0x00800000,0x00D08410,0x00B5B5B5},
{0x02C0C0C0,0x02808080,0x027060A0,0x02A4A0A0,0x02B8B0D0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02B8B0D0,0x02B8B0D0,0x02E0D8E8,0x027060A0,0x02FFFFFF,0x02B8B0D0,0x027060A0,0x027060A0,0x02000000,0x027D7D7D,0x02E0D8E8,0x02000000,0x02B8B0D0,0x02000000,0x02FFFFFF,0x00C0C0C0,0x027060A0,0x02D0CCD8,0x02D0D4D0},
{0x02000000,0x02000000,0x02800080,0x02008000,0x02000000,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x0200FFFF,0x02008000,0x02000000,0x02800080,0x02FFFFFF,0x02000000,0x02808080,0x0200FF00,0x02FFFFFF,0x02FFFFFF,0x02C0C0C0,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x00C0C0C0,0x02800080,0x00800080,0x00008000},
{0x02FFFFFF,0x02FFFFFF,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02808080,0x02C0C0C0,0x02808080,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02808080,0x0200FF00,0x02000000,0x02000000,0x02C0C0C0,0x02000000,0x02C0C0C0,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02000000,0x00000000,0x00FFFFFF},
{0x02D9A8AE,0x02000000,0x02B14E5A,0x02808080,0x02D9A8AE,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02D9A8AE,0x02D9A8AE,0x02B14E5A,0x02B14E5A,0x02FFFFFF,0x02D9A8AE,0x02B14E5A,0x02B14E5A,0x02000000,0x02FFFFFF,0x02ECD5D8,0x02000000,0x02D9A8AE,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02B14E5A,0x02CB8FB6,0x02D0B4B8},
{0x02C0C0C0,0x02808000,0x02800000,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02808080,0x02800000,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02DFDFDF,0x02000000,0x00E1FFFF,0x00C0C0C0,0x02800000,0x02D08410,0x02B5B5B5},
{0x02C0C0C0,0x02808000,0x02800000,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02808080,0x02800000,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02DFDFDF,0x02000000,0x02E1FFFF,0x00C0C0C0,0x02800000,0x02D08410,0x02B5B5B5},
{0x02D7ECF2,0x02000000,0x0246A6C6,0x02A4A0A0,0x02AED8E6,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02AED8E6,0x02AED8E6,0x02D7ECF2,0x0246A6C6,0x02000000,0x02AED8E6,0x0246A6C6,0x0246A6C6,0x02000000,0x02D7ECF2,0x02D7ECF2,0x02000000,0x02AED8E6,0x02000000,0x02FFFFFF,0x02C0C0C0,0x0246A6C6,0x02389CC0,0x0288C8E0},
{0x02D0EEEE,0x021D4000,0x02008080,0x0241BCBC,0x02A0DEDE,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02A0DEDE,0x02A0DEDE,0x02D0EEEE,0x02008080,0x02FFFFFF,0x02A0DEDE,0x0241BCBC,0x0241BCBC,0x02000000,0x02FFFFFF,0x02D0EEEE,0x02000000,0x02A0DEDE,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02008080,0x0248B0C8,0x0280B8B8},
};

void SetColor(HKEY hkey, int iColor, COLORREF cr)
{
    TCHAR sz[16];
    wsprintf(sz, TEXT("%d %d %d"), GetRValue(cr), GetGValue(cr), GetBValue(cr));
    RegSetValueEx(hkey, rgpsz[iColor], 0, REG_SZ, (LPBYTE)sz, (wcslen(sz) + 1) * sizeof(TCHAR));
}

void SetGradient(HKEY hkey, int iScheme)
{
    SetColor(hkey, COLOR_GRADIENTACTIVECAPTION, rgcr[iScheme][COLOR_GRADIENTACTIVECAPTION]);
    SetColor(hkey, COLOR_GRADIENTINACTIVECAPTION, rgcr[iScheme][COLOR_GRADIENTINACTIVECAPTION]);
}

void SetDesktop(HKEY hkey)
{
    SetColor(hkey, COLOR_DESKTOP, 0x00A56E3A);
}

#if DBG
#define DebugOut fwprintf
#else
#define DebugOut
#endif

void FixGradientColors(void)
{
    COLORREF cr, rgcrCurrent[COLOR_MAX] = {0x00C0C0C0,0x00808000,0x00800000,0x00808080,0x00C0C0C0,0x00FFFFFF,0x00000000,0x00000000,0x00000000,0x00FFFFFF,0x00C0C0C0,0x00C0C0C0,0x00808080,0x00800000,0x00FFFFFF,0x00C0C0C0,0x00808080,0x00808080,0x00000000,0x00C0C0C0,0x00FFFFFF,0x00000000,0x00C0C0C0,0x00000000,0x00E1FFFF,0x00C0C0C0,0x00800000,0x00800000,0x00808080};
    HKEY hkey;
    DWORD dwSize;
    int i, j;
    TCHAR szColor[16];
    DWORD dwR, dwG, dwB;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0,
            KEY_READ | KEY_SET_VALUE | KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS) {
        RegDeleteValue(hkey, TEXT("UserPreferencesMask"));
        RegCloseKey(hkey);
    }

    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Colors"), 0, KEY_READ | KEY_SET_VALUE | KEY_QUERY_VALUE, &hkey) != ERROR_SUCCESS)
        return;

    for (i = 0; i < sizeof(rgpsz) / sizeof(rgpsz[0]); i++) {

        dwSize = sizeof(szColor) * sizeof(TCHAR);

        if (RegQueryValueEx(hkey, rgpsz[i], NULL, NULL, (LPBYTE)szColor, &dwSize) == ERROR_SUCCESS) {
            swscanf(szColor, TEXT("%d %d %d"), &dwR, &dwG, &dwB);
            rgcrCurrent[i] = RGB(dwR, dwG, dwB);
        }
    }

    for (i = 0; i < SCHEME_MAX; i++) {

        for (j = 0; j < COLOR_MAX_NT4; j++) {
            cr = (rgcr[i][j] & 0x00FFFFFF);
            if (rgcrCurrent[j] != cr) {
                break;
            }
        }

        if (j == COLOR_MAX_NT4) {
            break;
        }
    }

    if (j == COLOR_MAX_NT4) {
        DebugOut(stderr, TEXT("Upgrading NT4 color scheme %s\n"), rgpszSchemes[i]);
        SetGradient(hkey, i);

        /*
         * For Windows Standard, WS EL, WS L, update the desktop color.
         */
        if (i == 18 || i == 23 || i == 24) {
            DebugOut(stderr, TEXT("Updating %s desktop color\n"), rgpszSchemes[i]);
            SetDesktop(hkey);
        }

    } else {
        DebugOut(stderr, TEXT("No matching NT4 scheme found\n"));
    }

    RegCloseKey(hkey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\migrate\shmcvt1.c ===
#include <windows.h>
#include <winuserp.h>
#include <tchar.H>
#include <stdio.h>
#include "shmgdefs.h"
#include <regstr.h>

// structure used to store a scheme in the registry
#define SCHEME_VERSION_16 1
#define LF_FACESIZE16    32

#pragma pack(1)
typedef struct {
    SHORT   lfHeight;
    SHORT   lfWidth;
    SHORT   lfEscapement;
    SHORT   lfOrientation;
    SHORT   lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE16];
} LOGFONT16;

typedef LOGFONT16 *LPLOGFONT16;

typedef struct {
    SHORT version;
    NONCLIENTMETRICSA ncm;
    LOGFONT16 lfIconTitle;
    COLORREF rgb[COLOR_MAX];
} SCHEMEDATA16;

typedef SCHEMEDATA16 *PSCHEMEDATA16;
#pragma pack()

// structure used to store a scheme in the registry
#define SCHEME_VERSION_NT 2

typedef struct {
    SHORT version;
    WORD  wDummy;           // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX];
} SCHEMEDATAW;

typedef SCHEMEDATAW *PSCHEMEDATAW;

typedef TCHAR FILEPATH[MAX_PATH];

typedef struct tagSZNODE {
    TCHAR *psz;
    struct tagSZNODE *next;
} SZNODE;

TCHAR szApprSchemes[] = TEXT("Control Panel\\Appearance\\Schemes");
TCHAR szNTCsrSchemes[] = TEXT("Control Panel\\Cursor Schemes");
TCHAR szWinCsrSchemes[] = TEXT("Control Panel\\Cursors\\Schemes");
TCHAR szSystemRoot[] = TEXT("%SystemRoot%\\System32\\");

const TCHAR szWinCursors[] = TEXT("Control Panel\\Cursors");
const TCHAR szSchemes[] = TEXT("Schemes");
const TCHAR szDaytonaSchemes[] = REGSTR_PATH_SETUP TEXT("\\Control Panel\\Cursors\\Schemes");

#define ID_NONE_SCHEME  0       //
#define ID_USER_SCHEME  1       // These are the possible values of "Scheme Source" as define for the
#define ID_OS_SCHEME    2       //  mouse pointer applet

/***********************************************************************\
*
* CONVERSION ROUTINES
*
* NOTE: Although ConvertLF16to32 appears to be identical to ConvertLFAtoW
*       they are actually different once compiled:  the size of the individual
*       fields for a LOGFONT16 and a LOGFONTA are different.
*
\***********************************************************************/

void ConvertLF16to32( LPLOGFONTW plfwDst, UNALIGNED LOGFONT16 *plfaSrc ) {
    plfwDst->lfHeight           = plfaSrc->lfHeight;
    plfwDst->lfWidth            = plfaSrc->lfWidth;
    plfwDst->lfEscapement       = plfaSrc->lfEscapement;
    plfwDst->lfOrientation      = plfaSrc->lfOrientation;
    plfwDst->lfWeight           = plfaSrc->lfWeight;
    plfwDst->lfItalic           = plfaSrc->lfItalic;
    plfwDst->lfUnderline        = plfaSrc->lfUnderline;
    plfwDst->lfStrikeOut        = plfaSrc->lfStrikeOut;
    plfwDst->lfCharSet          = plfaSrc->lfCharSet;
    plfwDst->lfOutPrecision     = plfaSrc->lfOutPrecision;
    plfwDst->lfClipPrecision    = plfaSrc->lfClipPrecision;
    plfwDst->lfQuality          = plfaSrc->lfQuality;
    plfwDst->lfPitchAndFamily   = plfaSrc->lfPitchAndFamily;

    MultiByteToWideChar(CP_ACP, 0, plfaSrc->lfFaceName, -1, plfwDst->lfFaceName, ARRAYSIZE(plfwDst->lfFaceName));
}

void ConvertLFAtoW( LPLOGFONTW plfwDst, UNALIGNED LOGFONTA *plfaSrc ) {
    plfwDst->lfHeight           = plfaSrc->lfHeight;
    plfwDst->lfWidth            = plfaSrc->lfWidth;
    plfwDst->lfEscapement       = plfaSrc->lfEscapement;
    plfwDst->lfOrientation      = plfaSrc->lfOrientation;
    plfwDst->lfWeight           = plfaSrc->lfWeight;
    plfwDst->lfItalic           = plfaSrc->lfItalic;
    plfwDst->lfUnderline        = plfaSrc->lfUnderline;
    plfwDst->lfStrikeOut        = plfaSrc->lfStrikeOut;
    plfwDst->lfCharSet          = plfaSrc->lfCharSet;
    plfwDst->lfOutPrecision     = plfaSrc->lfOutPrecision;
    plfwDst->lfClipPrecision    = plfaSrc->lfClipPrecision;
    plfwDst->lfQuality          = plfaSrc->lfQuality;
    plfwDst->lfPitchAndFamily   = plfaSrc->lfPitchAndFamily;

    MultiByteToWideChar(CP_ACP, 0, plfaSrc->lfFaceName, -1, plfwDst->lfFaceName, ARRAYSIZE(plfwDst->lfFaceName));
}



void ConvertNCMAtoW( LPNONCLIENTMETRICSW pncmwDst, UNALIGNED NONCLIENTMETRICSA *pncmaSrc ) {
    pncmwDst->cbSize = sizeof(*pncmwDst);
    pncmwDst->iBorderWidth      = pncmaSrc->iBorderWidth;
    pncmwDst->iScrollWidth      = pncmaSrc->iScrollWidth;
    pncmwDst->iScrollHeight     = pncmaSrc->iScrollHeight;
    pncmwDst->iCaptionWidth     = pncmaSrc->iCaptionWidth;
    pncmwDst->iCaptionHeight    = pncmaSrc->iCaptionHeight;
    pncmwDst->iSmCaptionWidth   = pncmaSrc->iSmCaptionWidth;
    pncmwDst->iSmCaptionHeight  = pncmaSrc->iSmCaptionHeight;
    pncmwDst->iMenuWidth        = pncmaSrc->iMenuWidth;
    pncmwDst->iMenuHeight       = pncmaSrc->iMenuHeight;


    ConvertLFAtoW( &(pncmwDst->lfCaptionFont),   &(pncmaSrc->lfCaptionFont) );
    ConvertLFAtoW( &(pncmwDst->lfSmCaptionFont), &(pncmaSrc->lfSmCaptionFont) );
    ConvertLFAtoW( &(pncmwDst->lfMenuFont),      &(pncmaSrc->lfMenuFont) );
    ConvertLFAtoW( &(pncmwDst->lfStatusFont),    &(pncmaSrc->lfStatusFont) );
    ConvertLFAtoW( &(pncmwDst->lfMessageFont),   &(pncmaSrc->lfMessageFont) );
}

void CvtDeskCPL_Win95ToSUR( void ) {
    HKEY hk = NULL;
    DWORD cchClass, cb, cch, cSubk, cchMaxSubk, cchMaxCls, iVal, cchMaxVName;
    DWORD cbMaxVData, cbSecDes, dwType;
    FILETIME pfLstWr;
    TCHAR szClass[4];
    LONG lRet;
    PVOID pvVData = NULL;
    LPTSTR pszVName = NULL;
    LONG erc;
    FILETIME ftLstWr;

    // Open the key (Appearence\Schemes)
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szApprSchemes, 0, KEY_READ | KEY_WRITE, &hk) != ERROR_SUCCESS)
        goto ErrorExit;


    cchClass = ARRAYSIZE(szClass);
    erc = RegQueryInfoKey(hk, szClass, &cchClass, NULL, &cSubk, &cchMaxSubk,
            &cchMaxCls, &iVal, &cchMaxVName, &cbMaxVData, &cbSecDes, &ftLstWr);

    if( erc != ERROR_SUCCESS && erc != ERROR_MORE_DATA)
        goto ErrorExit;

    cchMaxVName += 1;

    pszVName = LocalAlloc(LMEM_FIXED, cchMaxVName * SIZEOF(TCHAR));
    pvVData  = LocalAlloc(LMEM_FIXED, cbMaxVData);

    if (pvVData == NULL || pszVName == NULL)
        goto ErrorExit;

    // for each value in the key
    iVal = 0;

    for(;;) {
        PSCHEMEDATA16 psda;
        SCHEMEDATAW  sdw;

        cch = cchMaxVName;
        cb  = cbMaxVData;
        if( RegEnumValue(hk, iVal++, pszVName, &cch, NULL, &dwType, pvVData, &cb  ) != ERROR_SUCCESS )
            break;

        // check if it has been converted yet
        psda = pvVData;
        if (psda->version != SCHEME_VERSION_16)
            continue;

        // if not, convert ANSI font names to UNICODE and tag the structure
        // as converted
        sdw.version = SCHEME_VERSION_NT;
        sdw.wDummy = 0;
        CopyMemory(sdw.rgb, psda->rgb, SIZEOF(sdw.rgb));
        ConvertNCMAtoW( &(sdw.ncm), &(psda->ncm) );
        ConvertLF16to32( &(sdw.lfIconTitle), &(psda->lfIconTitle) );

        // write the new data back out
        RegSetValueEx(hk, pszVName, 0L, dwType, (LPBYTE)&sdw, SIZEOF(sdw));
    }

ErrorExit:
    // close the key
    if (hk)
        RegCloseKey(hk);

    if (pvVData)
        LocalFree(pvVData);

    if (pszVName)
        LocalFree(pszVName);

}

#ifdef LATER
void CvtDeskCPL_DaytonaToSur( void ) {
}
#endif

//
// NOTE!  These enums MUST be in the same order that the names will appear in the registry string
enum { arrow,help,appstart,wait,cross,ibeam,pen,no,sizens,sizewe,sizenwse,sizenesw,move,altsel, C_CURSORS } ID_CURSORS;

FILEPATH aszCurs[C_CURSORS];
TCHAR    szOut[(C_CURSORS * (MAX_PATH+1)) + 1];

void CvtCursorsCPL_DaytonaToSUR( void ) {
    HKEY hkIn = NULL, hkOut = NULL;
    DWORD dwTmp;
    DWORD cchClass;
    LONG erc;
    DWORD dwType;
    DWORD cSubk;
    DWORD cchMaxSubk;
    DWORD cchMaxCls;
    DWORD iVal;
    DWORD cchMaxVName;
    DWORD cbMaxVData;
    DWORD cbSecDes;
    FILETIME ftLstWr;
    DWORD cch;
    DWORD cb;
    TCHAR szClass[4];
    PVOID pvVData = NULL;
    LPTSTR pszVName = NULL;

    // Open the source registry key (Cursor Schemes)
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szNTCsrSchemes, 0, KEY_READ, &hkIn) != ERROR_SUCCESS)
        goto ErrorExit;

    // Open/create the dest registry key (Cursors\Schemes)
    if (RegCreateKeyEx(HKEY_CURRENT_USER, szWinCsrSchemes, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                KEY_READ | KEY_WRITE, NULL, &hkOut, &dwTmp) != ERROR_SUCCESS) {
        goto ErrorExit;
    }

    // for each value in the source key
    cchClass = ARRAYSIZE(szClass);
    erc = RegQueryInfoKey(hkIn, szClass, &cchClass, NULL, &cSubk, &cchMaxSubk,
            &cchMaxCls, &iVal, &cchMaxVName, &cbMaxVData, &cbSecDes, &ftLstWr);

    if( erc != ERROR_SUCCESS && erc != ERROR_MORE_DATA)
        goto ErrorExit;

    cchMaxVName += 1;

    pszVName = LocalAlloc(LMEM_FIXED, cchMaxVName * SIZEOF(TCHAR));
    pvVData  = LocalAlloc(LMEM_FIXED, cbMaxVData + sizeof(TCHAR));

    if (pvVData == NULL || pszVName == NULL)
        goto ErrorExit;

    iVal = 0;

    for(;;) {
        DWORD cbData;
        LPTSTR pszOut;
        int   i;

        cch = cchMaxVName;
        cb  = cbMaxVData;

        if( RegEnumValue(hkIn, iVal++, pszVName, &cch, NULL, &dwType, pvVData, &cb  ) != ERROR_SUCCESS )
            break;

        // if the name already exists in the new key then skip this one
        if (RegQueryValueEx(hkOut, pszVName, NULL, NULL, NULL, &cbData ) == ERROR_SUCCESS && cbData != 0)
            continue;

        if (dwType != REG_EXPAND_SZ && dwType != REG_SZ)
            continue;

        *(TCHAR *)((LPBYTE)pvVData+cb) = TEXT('\0');  // Make sure nul terminated

        // convert the data to SUR format
        for( i = 0; i < C_CURSORS; i++ ) {
            *aszCurs[i] = TEXT('\0');
        }

        //arrow,wait,appstart,no,ibeam,cross,ns,ew,nwse,nesw,move

        _stscanf(pvVData, TEXT("%[^,], %[^,], %[^,], %[^,], %[^,], %[^,], %[^,], %[^,], %[^,], %[^,]"),
                aszCurs[arrow],aszCurs[wait],aszCurs[appstart],aszCurs[no],
                aszCurs[ibeam],aszCurs[cross],aszCurs[sizens],aszCurs[sizewe],
                aszCurs[sizenwse],aszCurs[sizenesw],aszCurs[move]);

        szOut[0] = TEXT('\0');
        pszOut = szOut;

        for( i = 0; i < C_CURSORS; i++ ) {
            if (!HasPath(aszCurs[i]))
                pszOut += mystrcpy( pszOut, szSystemRoot, TEXT('\0') );

            pszOut += mystrcpy( pszOut, aszCurs[i], TEXT('\0') );

            *pszOut++ = TEXT(',');
        }

        *(pszOut-1) = TEXT('\0');

        // write the new data back out
        RegSetValueEx(hkOut, pszVName, 0L, REG_EXPAND_SZ, (LPBYTE)szOut, (DWORD)(sizeof(TCHAR)*(pszOut - szOut)));
    }

ErrorExit:
    // close the registry keys
    if (hkIn)
        RegCloseKey(hkIn);

    if (hkOut)
        RegCloseKey(hkOut);

    if (pvVData)
        LocalFree(pvVData);

    if (pszVName)
        LocalFree(pszVName);
}

void FixupCursorSchemePaths( void ) {
    HKEY hk = NULL;
    DWORD cchClass, cb, cch, cSubk, cchMaxSubk, cchMaxCls, iVal, cchMaxVName;
    DWORD cbMaxVData, cbSecDes, dwType;
    FILETIME pfLstWr;
    TCHAR szClass[4];
    LONG lRet;
    PVOID pvVData = NULL;
    LPTSTR pszVName = NULL;
    LONG erc;
    FILETIME ftLstWr;

    // Open the key (Appearence\Schemes)
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szWinCsrSchemes, 0, KEY_READ | KEY_WRITE, &hk) != ERROR_SUCCESS)
        goto ErrorExit;


    cchClass = ARRAYSIZE(szClass);
    erc = RegQueryInfoKey(hk, szClass, &cchClass, NULL, &cSubk, &cchMaxSubk,
            &cchMaxCls, &iVal, &cchMaxVName, &cbMaxVData, &cbSecDes, &ftLstWr);

    if( erc != ERROR_SUCCESS && erc != ERROR_MORE_DATA)
        goto ErrorExit;

    cchMaxVName += 1;

    DPRINT(( TEXT("cchName:%d cbData:%d\n"), cchMaxVName, cbMaxVData ));
    pszVName = LocalAlloc(LMEM_FIXED, cchMaxVName * SIZEOF(TCHAR));
    pvVData  = LocalAlloc(LMEM_FIXED, cbMaxVData + sizeof(TCHAR));

    if (pvVData == NULL || pszVName == NULL)
        goto ErrorExit;

    // for each value in the key
    iVal = 0;

    for(;;) {
        LPTSTR pszIn, pszOut;
        BOOL fFixed;
        TCHAR szTmp[MAX_PATH];

        cch = cchMaxVName;
        cb  = cbMaxVData;
        DPRINT(( TEXT("\n\n>>>>>>>>>>>>>>>>>>>Getting scheme %d "), iVal ));
        if( RegEnumValue(hk, iVal++, pszVName, &cch, NULL, &dwType, pvVData, &cb  ) != ERROR_SUCCESS )
            break;

        if (dwType != REG_EXPAND_SZ && dwType != REG_SZ)
            continue;

        *(TCHAR *)((LPBYTE)pvVData+cb) = TEXT('\0');  // Make sure nul terminated

        // check if it has been converted yet
        DPRINT(( TEXT("Scheme : %s = [%s]"), pszVName, pvVData ));

        fFixed = FALSE;
        pszOut = szOut;

        pszIn = pvVData;
        pszIn--;    // prime pszIn for first comma skip

        do {
            pszIn++;    // skip over comma separator
            pszIn += mystrcpy( szTmp, pszIn, TEXT(',') );   // bump ptr by length of token

            DPRINT((TEXT("\n\t%s"), szTmp));

            if (!HasPath(szTmp)) {
                fFixed = TRUE;
                DPRINT((TEXT(" <fixed...")));
                pszOut += mystrcpy( pszOut, szSystemRoot, TEXT('\0') );
                DPRINT((TEXT(">")));
            }

            pszOut += mystrcpy( pszOut, szTmp, TEXT('\0') );

            *pszOut++ = TEXT(',');

#ifdef SHMG_DBG
            *pszOut = TEXT('\0');
            DPRINT((TEXT("\nszOut so far: '%s'"), szOut ));
#endif
        } while ( *pszIn );

        *(pszOut-1) = TEXT('\0');

        DPRINT((TEXT("\n\n******** Findal szOut: [%s]"), szOut ));

        // write the new data back out
        if (fFixed) {
            DPRINT((TEXT("  (Saving back to reg)")));
            RegSetValueEx(hk, pszVName, 0L, REG_EXPAND_SZ, (LPBYTE)szOut, (DWORD)(sizeof(TCHAR)*(pszOut - szOut)));
        }

    }

ErrorExit:

    DPRINT(( TEXT("\n\n **EXITING FN()**\n" )));

    // close the key
    if (hk)
        RegCloseKey(hk);

    if (pvVData)
        LocalFree(pvVData);

    if (pszVName)
        LocalFree(pszVName);


}

// this function will remove entries from HKCU\Control Panel\Cursors\Schemes which are identical to
// schemes found in HKLM\%Current Version%\Control Panel\Cursors\Schemes
//
//  HKCU\Control Panel\Cursors
//      This key contains the users currently selected cursor scheme
//  HKCU\Control Panel\Cursors "Scheme Source"
//      This is a new key which will be added if not present.  The key indicates if the currently
//      select user scheme is user defined or system defined.
//  HKCU\Control Panel\Cursors\Schemes <Scheme name> <file list>
//      This is the location for user defined schemes.  If any of these schemes have both the same
//      scheme name and the same file list as a system defined scheme then that key will be
//      removed from the user list.  If the currently selected cursor scheme is removed then
//      "Scheme Source" will be updated to reflect the new location.
//  HKLM\%Current Version%\Control Panel\Cursors\Schemes <Scheme name>
//      Under the new optional component model, optional components are installed on a per-machine
//      basis into this location instead of the old per-user basis.  This allows floating profiles
//      to use system pointer schemes on multiple machines and simplifies component installation.
void CvtCursorSchemesToMultiuser( void )
{
    HKEY hkOldCursors, hkOldSchemes;
    HKEY hkNewSchemes;
    DWORD iSchemeLocation;
    DWORD iType;
    TCHAR szDefaultScheme[MAX_PATH+1];
    const TCHAR szSchemeSource[] = TEXT("Scheme Source");
    SZNODE *pnHead = NULL;
    SZNODE *pnTail = NULL;

    // open a key to the original cursors location
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szWinCursors, 0, KEY_ALL_ACCESS, &hkOldCursors) == ERROR_SUCCESS)
    {
        long len = sizeof( szDefaultScheme );
        if (RegQueryValue( hkOldCursors, NULL, szDefaultScheme, &len ) != ERROR_SUCCESS)
        {
            szDefaultScheme[0] = TEXT('\0');    // if the default key isn't set, the user has the default cursors
        }

        // try to read the value of "Scheme Source"
        len = sizeof( iSchemeLocation );
        if ( RegQueryValueEx( hkOldCursors, szSchemeSource, 0, &iType, (BYTE *)&iSchemeLocation, &len )
                != ERROR_SUCCESS )
        {
            iSchemeLocation = ID_USER_SCHEME;  // if the value isn't there then it's a user scheme
            RegSetValueEx( hkOldCursors, szSchemeSource, 0, REG_DWORD, (BYTE *)&iSchemeLocation,
                           sizeof( iSchemeLocation ) );
        }

        // now open the schemes subkey, this is what we're interested in
        if (RegOpenKeyEx( hkOldCursors, szSchemes, 0, KEY_ALL_ACCESS, &hkOldSchemes ) == ERROR_SUCCESS )
        {
            TCHAR szOldKeyName[MAX_PATH+1];
            TCHAR szOldKeyValue[C_CURSORS*(MAX_PATH+1)+1];
            TCHAR szNewKeyValue[C_CURSORS*(MAX_PATH+1)+1];
            long iLenName;       // the length of the name of the old key
            long iLenValue;      // the length of the value of the old key
            long iLenNewKey;     // the length of the new key's value
            int iIndex;

            // now we are ready to enum the user defined schemes, but first lets make sure we can
            // open the new location, if we can't open it then we bail out.
            if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, szDaytonaSchemes, 0, KEY_READ, &hkNewSchemes ) != ERROR_SUCCESS )
                goto bailOut;
            DPRINT(( TEXT("Opened key %s"), szDaytonaSchemes ));

            // now we start reading the new schemes
            for (iIndex = 0;;)
            {
                // read next scheme
                iLenName = ARRAYSIZE(szOldKeyName);      // these must be reset each time around
                iLenValue = sizeof( szOldKeyValue );
                if (RegEnumValue( hkOldSchemes, iIndex++, szOldKeyName, &iLenName, NULL, NULL,
                                  (BYTE *)szOldKeyValue, &iLenValue ) != ERROR_SUCCESS )
                {
                    // we fail if we are out of data, which means we're done
                    break;
                }
                DPRINT(( TEXT("Opened key: %s\n"), szOldKeyName ));

                // now we try to find a key with the same name in the new location
                iLenNewKey = sizeof( szNewKeyValue );
                if (RegQueryValueEx( hkNewSchemes, szOldKeyName, 0, NULL, (BYTE *)szNewKeyValue, &iLenNewKey )
                        == ERROR_SUCCESS )
                {
                    // if the new key exists, compare the values
                    DPRINT(( TEXT("  Key exists in HKLM.\n") ));
                    DPRINT(( TEXT("    Old=%s\n    New=%s\n"), szOldKeyValue, szNewKeyValue ));

                    if ( lstrcmpi(szOldKeyValue, szNewKeyValue) == 0 )
                    {
                        // if the values are the same, see if this is the currently selected scheme
                        if ( lstrcmp(szOldKeyName, szDefaultScheme) == 0 )
                        {
                            // since we're going to delete the user defined scheme and the system scheme
                            // has the same name and value we simply change the value of "Scheme Source"
                            iSchemeLocation = ID_OS_SCHEME;
                            RegSetValueEx( hkOldCursors, szSchemeSource, 0, REG_DWORD, (unsigned char *)&iSchemeLocation,
                                           sizeof( iSchemeLocation ) );
                        }
                        // remove the user key
                        DPRINT(( TEXT("      Tagging user key for removal.\n") ));
                        if ( pnTail == NULL )
                        {
                            pnTail = (SZNODE *)LocalAlloc( LMEM_FIXED, sizeof( SZNODE ) );
                            pnHead = pnTail;
                            if (!pnTail)    // not enough memory
                                break;
                        }
                        else
                        {
                            pnTail->next = (SZNODE *)LocalAlloc( LMEM_FIXED, sizeof( SZNODE ) );
                            pnTail = pnTail->next;
                            if (!pnTail)    // not enough memory
                                break;
                        }
                        pnTail->next = NULL;
                        pnTail->psz = LocalAlloc( LMEM_FIXED, sizeof( szOldKeyName ) );
                        if (!pnTail->psz)   // not enough memory
                            break;
                        lstrcpy( pnTail->psz, szOldKeyName );
                    }
                }
            }

            // If we tagged any keys for deletion they will be stored in our list
            while (pnHead)
            {
                if (pnHead->psz)    // if we ran out of memory, this could be NULL
                {
                    DPRINT(( TEXT("Deleting key %s\n"), pnHead->psz ));
                    RegDeleteValue( hkOldSchemes, pnHead->psz );
                    LocalFree( pnHead->psz ); // Clean up the list as we go
                }
                pnTail = pnHead;
                pnHead = pnHead->next;
                LocalFree( pnTail );    // Clean up as we go
            }

            // now we are finished removing the duplicate keys, clean up and exit
            RegCloseKey( hkNewSchemes );
bailOut:
            RegCloseKey( hkOldSchemes );
        }
        // else: no schemes are defined for current user so there's nothing to do

        RegCloseKey( hkOldCursors );
    }
    // else: no cursor key exists for current user so there's nothing to do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\migrate\schemnt5.c ===
///////////////////////////////////////////////////////////////////////////////
// schemnt5.c
//
// This component of shmgrate.exe is designed to upgrade the user's schemes
// and colors to the new values required for Windows 2000.  This work is
// coordinated with changes to the scheme data provided by Win2000 setup
// in the files hivedef.inx and hiveusd.inx.
//
// brianau 6/11/98
// brianau 2/18/99  - Updated for "MS Sans Serif"->"Microsoft Sans Serif"
//                    conversion.
// brianau 6/24/99  - Set gradient colors same as non-gradient colors in
//                    NT4 custom schemes.
//
#include <windows.h>
#include <winuserp.h>
#include <tchar.h>
#include <stdio.h>
#include <shlwapi.h>

#include "shmgdefs.h"

#ifndef COLOR_3DALTFACE
//
// This is not defined in winuser.h (looks like it should be).
// The desktop applet places this color at ordinal 25 in the
// order of colors.  There's a "hole" in the ordinal numbers
// defined in winuser.h between numbers 24 and 26 so I'm 
// assuming it's supposed to be COLOR_3DALTFACE.  Regardless,
// the number is valid for the arrays in this module.
//
#   define COLOR_3DALTFACE 25
#endif

//
// This string defines the new font to be used for the 
// NC fonts.  If you want to change the face name, this 
// is the only place a change is required.
//
#define STR_NEWNCFONT  TEXT("Tahoma")

//
// Defining this macro prevents any registry changes from being
// made. Used for development only.
//
// Undefine before flight.
//
//#define NO_REG_CHANGES 1
//
//
// Redefine a private version of COLOR_MAX macro (winuser.h)
// This code needs to stay in sync with Windows Setup and 
// desk.cpl, not what is defined in winuser.h.  Someone added
// two new colors to winuser.h which increased COLOR_MAX by 2
// which increased the size of SCHEMEDATA by 8 bytes.  This 
// caused us to write out 8 extra bytes to the registry so that
// desk.cpl no longer recognizes these entries.  Setup, desk.cpl
// and shmgrate need to stay in sync with respect to the size of 
// SCHEMEDATA. [brianau - 4/3/00]
//
#define MAX_COLORS (COLOR_GRADIENTINACTIVECAPTION + 1)
//
// This structure was taken from shell\ext\cpls\desknt5\lookdlg.c
// It's the definition the desktop applet uses for reading/writing
// scheme data to/from the registry.
//
typedef struct {
    SHORT version;
    WORD  wDummy;           // For alignment.
    NONCLIENTMETRICS ncm;
    LOGFONT lfIconTitle;
    COLORREF rgb[MAX_COLORS];
} SCHEMEDATA;


const TCHAR g_szRegKeySchemes[]      = TEXT("Control Panel\\Appearance\\Schemes");
const TCHAR g_szRegKeyMetrics[]      = TEXT("Control Panel\\Desktop\\WindowMetrics");
const TCHAR g_szRegKeyColors[]       = TEXT("Control Panel\\Colors");
const TCHAR g_szRegValRGB[]          = TEXT("255 255 255");
const TCHAR g_szMsSansSerif[]        = TEXT("MS Sans Serif");
const TCHAR g_szMicrosoftSansSerif[] = TEXT("Microsoft Sans Serif");
const TCHAR g_szCaptionFont[]        = TEXT("CaptionFont");
const TCHAR g_szSmCaptionFont[]      = TEXT("SmCaptionFont");
const TCHAR g_szMenuFont[]           = TEXT("MenuFont");
const TCHAR g_szStatusFont[]         = TEXT("StatusFont");
const TCHAR g_szMessageFont[]        = TEXT("MessageFont");
const TCHAR g_szIconFont[]           = TEXT("IconFont");
const TCHAR g_szNewNcFont[]          = STR_NEWNCFONT;

//
// Font Metric Item index values.  This enumeration represents the
// order of items in any global arrays associated with the
// non-client metric font items.
// These must stay in sync with the entries in g_rgpszFontMetrics[] 
// and g_rglfDefaults[].
//
enum FontMetricIndex { FMI_CAPTIONFONT,
                       FMI_SMCAPTIONFONT,
                       FMI_MENUFONT,
                       FMI_STATUSFONT,
                       FMI_MESSAGEFONT,
                       FMI_ICONFONT };
//
// Font metric reg value name strings.
// The order of these must match the order of the FontMetricIndex
// enumeration.
//
const LPCTSTR g_rgpszFontMetrics[] = { g_szCaptionFont,
                                       g_szSmCaptionFont,
                                       g_szMenuFont,
                                       g_szStatusFont,
                                       g_szMessageFont,
                                       g_szIconFont
                                     };
//
// Total number of window font metrics being considered.
//
#define NUM_NC_FONTS ARRAYSIZE(g_rgpszFontMetrics)
//
// Default LOGFONT data for NC fonts.
// Used if there's no NC font data present (i.e. clean US install).
// This data corresponds to the "Windows Standard" scheme on a clean 
// NT 5.0 installation modified with our desired changes.  
// These entries must be maintained in the order of the FontMetricIndex 
// enumeration.
//
// For reference, The LOGFONT structure is:
//
// struct LOGFONT {
//    LONG      lfHeight;
//    LONG      lfWidth;
//    LONG      lfEscapement;
//    LONG      lfOrientation;
//    LONG      lfWeight;
//    BYTE      lfItalic;
//    BYTE      lfUnderline;
//    BYTE      lfStrikeOut;
//    BYTE      lfCharSet;
//    BYTE      lfOutPrecision;
//    BYTE      lfClipPrecision;
//    BYTE      lfQuality;
//    BYTE      lfPitchAndFamily;
//    TCHAR     lfFaceName[LF_FACESIZE]; // LF_FACESIZE == 32.
// };
//
const LOGFONT g_rglfDefaults[NUM_NC_FONTS] = {

    { -11, 0, 0, 0, 700, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // CAPTION
    { -11, 0, 0, 0, 700, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // SMCAPTION
    { -11, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // MENU
    { -11, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // STATUS
    { -11, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // MESSAGE
    { -11, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }  // ICON
    };

//
// These are the elements represented in the "Control Panel\Colors"
// reg key.  The rgbValue member is the new color value we want
// to assign.  See UpdateElementColor() for usage.
//
const struct NcmColors
{
    LPCTSTR  pszName;   // Value name in "Control Panel\Colors" reg key.
    COLORREF rgbValue;  // The new color.

} g_rgWinStdColors[] = { 

    { TEXT("Scrollbar"),             0x00C8D0D4 }, // COLOR_SCROLLBAR
    { TEXT("Background"),            0x00A56E3A }, // COLOR_BACKGROUND
    { TEXT("ActiveTitle"),           0x006A240A }, // COLOR_ACTIVECAPTION
    { TEXT("InactiveTitle"),         0x00808080 }, // COLOR_INACTIVECAPTION
    { TEXT("Menu"),                  0x00C8D0D4 }, // COLOR_MENU
    { TEXT("Window"),                0x00FFFFFF }, // COLOR_WINDOW
    { TEXT("WindowFrame"),           0x00000000 }, // COLOR_WINDOWFRAME
    { TEXT("MenuText"),              0x00000000 }, // COLOR_MENUTEXT
    { TEXT("WindowText"),            0x00000000 }, // COLOR_WINDOWTEXT
    { TEXT("TitleText"),             0x00FFFFFF }, // COLOR_CAPTIONTEXT
    { TEXT("ActiveBorder"),          0x00C8D0D4 }, // COLOR_ACTIVEBORDER
    { TEXT("InactiveBorder"),        0x00C8D0D4 }, // COLOR_INACTIVEBORDER
    { TEXT("AppWorkspace"),          0x00808080 }, // COLOR_APPWORKSPACE
    { TEXT("Hilight"),               0x006A240A }, // COLOR_HIGHLIGHT
    { TEXT("HilightText"),           0x00FFFFFF }, // COLOR_HIGHLIGHTTEXT
    { TEXT("ButtonFace"),            0x00C8D0D4 }, // COLOR_BTNFACE
    { TEXT("ButtonShadow"),          0x00808080 }, // COLOR_BTNSHADOW
    { TEXT("GrayText"),              0x00808080 }, // COLOR_GRAYTEXT
    { TEXT("ButtonText"),            0x00000000 }, // COLOR_BTNTEXT
    { TEXT("InactiveTitleText"),     0x00C8D0D4 }, // COLOR_INACTIVECAPTIONTEXT
    { TEXT("ButtonHilight"),         0x00FFFFFF }, // COLOR_BTNHIGHLIGHT
    { TEXT("ButtonDkShadow"),        0x00404040 }, // COLOR_3DDKSHADOW
    { TEXT("ButtonLight"),           0x00C8D0D4 }, // COLOR_3DLIGHT
    { TEXT("InfoText"),              0x00000000 }, // COLOR_INFOTEXT
    { TEXT("InfoWindow"),            0x00E1FFFF }, // COLOR_INFOBK
    { TEXT("ButtonAlternateFace"),   0x00B5B5B5 }, // COLOR_3DALTFACE
    { TEXT("HotTrackingColor"),      0x00800000 }, // COLOR_HOTLIGHT
    { TEXT("GradientActiveTitle"),   0x00F0CAA6 }, // COLOR_GRADIENTACTIVECAPTION
    { TEXT("GradientInactiveTitle"), 0x00C0C0C0 }  // COLOR_GRADIENTINACTIVECAPTION
};



#ifdef NO_REG_CHANGES
void DumpLogFont(
    const LOGFONT *plf
    )
{
    DPRINT((TEXT("Dumping LOGFONT ----------------------------------\n")));
    DPRINT((TEXT("\tplf->lfHeight.........: %d\n"), plf->lfHeight));
    DPRINT((TEXT("\tplf->lfWidth..........: %d\n"), plf->lfWidth));
    DPRINT((TEXT("\tplf->lfEscapement.....: %d\n"), plf->lfEscapement));
    DPRINT((TEXT("\tplf->lfOrientation....: %d\n"), plf->lfOrientation));
    DPRINT((TEXT("\tplf->lfWeight.........: %d\n"), plf->lfWeight));
    DPRINT((TEXT("\tplf->lfItalic.........: %d\n"), plf->lfItalic));
    DPRINT((TEXT("\tplf->lfUnderline......: %d\n"), plf->lfUnderline));
    DPRINT((TEXT("\tplf->lfStrikeOut......: %d\n"), plf->lfStrikeOut));
    DPRINT((TEXT("\tplf->lfCharSet........: %d\n"), plf->lfCharSet));
    DPRINT((TEXT("\tplf->lfOutPrecision...: %d\n"), plf->lfOutPrecision));
    DPRINT((TEXT("\tplf->lfClipPrecision..: %d\n"), plf->lfClipPrecision));
    DPRINT((TEXT("\tplf->lfQuality........: %d\n"), plf->lfQuality));
    DPRINT((TEXT("\tplf->lfPitchAndFamily.: %d\n"), plf->lfPitchAndFamily));
    DPRINT((TEXT("\tplf->lfFaceName.......: \"%s\"\n"), plf->lfFaceName));
}


void DumpSchemeStructure(
    const SCHEMEDATA *psd
    )
{
    int i;

    DPRINT((TEXT("version..............: %d\n"), psd->version));
    DPRINT((TEXT("ncm.cbSize...........: %d\n"), psd->ncm.cbSize));
    DPRINT((TEXT("ncm.iBorderWidth.....: %d\n"), psd->ncm.iBorderWidth));
    DPRINT((TEXT("ncm.iScrollWidth.....: %d\n"), psd->ncm.iScrollWidth));
    DPRINT((TEXT("ncm.iScrollHeight....: %d\n"), psd->ncm.iScrollHeight));
    DPRINT((TEXT("ncm.iCaptionWidth....: %d\n"), psd->ncm.iCaptionWidth));
    DPRINT((TEXT("ncm.iSmCaptionWidth..: %d\n"), psd->ncm.iSmCaptionWidth));
    DPRINT((TEXT("ncm.iSmCaptionHeight.: %d\n"), psd->ncm.iSmCaptionHeight));
    DPRINT((TEXT("ncm.iMenuWidth.......: %d\n"), psd->ncm.iMenuWidth));
    DPRINT((TEXT("ncm.iMenuHeight......: %d\n"), psd->ncm.iMenuHeight));
    DPRINT((TEXT("ncm.lfCaptionFont:\n")));
    DumpLogFont(&psd->ncm.lfCaptionFont);
    DPRINT((TEXT("ncm.lfSmCaptionFont:\n")));
    DumpLogFont(&psd->ncm.lfSmCaptionFont);
    DPRINT((TEXT("ncm.lfMenuFont:\n")));
    DumpLogFont(&psd->ncm.lfMenuFont);
    DPRINT((TEXT("ncm.lfStatusFont:\n")));
    DumpLogFont(&psd->ncm.lfStatusFont);
    DPRINT((TEXT("ncm.lfMessageFont:\n")));
    DumpLogFont(&psd->ncm.lfMessageFont);
    DPRINT((TEXT("lfIconTitle:\n")));
    DumpLogFont(&psd->lfIconTitle);
    for (i = 0; i < ARRAYSIZE(psd->rgb); i++)
    {
        DPRINT((TEXT("Color[%2d] (%3d,%3d,%3d)\n"),
               i,
               GetRValue(psd->rgb[i]),
               GetGValue(psd->rgb[i]),
               GetBValue(psd->rgb[i])));
    }
}
#endif



//
// Retrieve a named color value for a given user.
//
DWORD
GetColorForUser(
    HKEY hkeyColors,
    LPCTSTR pszName,
    COLORREF *prgb
    )
{
    DWORD dwType;
    TCHAR szValue[ARRAYSIZE(g_szRegValRGB)];
    DWORD cbData = sizeof(szValue);

    DWORD dwResult = RegQueryValueEx(hkeyColors, 
                                     pszName,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)szValue,
                                     &cbData);

    if (ERROR_SUCCESS == dwResult && REG_SZ == dwType)
    {
        //
        // Values in the registry are in REG_SZ formatted as
        // "RRR GGG BBB" where RRR, GGG and BBB are byte values
        // expressed as ASCII text.
        //
        BYTE rgbTemp[3] = {0,0,0};
        LPTSTR pszTemp  = szValue;
        LPTSTR pszColor = szValue;
        int i;
        for (i = 0; i < ARRAYSIZE(rgbTemp); i++)
        {
            //
            // Skip any leading spaces.
            //
            while(*pszTemp && TEXT(' ') == *pszTemp)
                pszTemp++;
            //
            // Remember the start of this color value.
            //
            pszColor = pszTemp;
            //
            // Find the end of the current color value.
            //
            while(*pszTemp && TEXT(' ') != *pszTemp)
                pszTemp++;

            if (2 != i && TEXT('\0') == *pszTemp)
            {
                //
                // Nul character encountered before 3rd member of color
                // triplet was read.  Assume it's bogus data.
                //
                dwResult = ERROR_INVALID_DATA;
                DPRINT((TEXT("Invalid color data in registry \"%s\"\n"), szValue));
                break;
            }
            //
            // Nul-terminate this color value string and conver it to a number.
            //
            *pszTemp++ = TEXT('\0');
            rgbTemp[i] = (BYTE)StrToInt(pszColor);
        }
        //
        // Return color info as an RGB triplet.
        //
        *prgb = RGB(rgbTemp[0], rgbTemp[1], rgbTemp[2]);
    }
    else
    {
        DPRINT((TEXT("Error %d querying reg color value \"%s\"\n"), dwResult, pszName));
        dwResult = ERROR_INVALID_HANDLE;
    }
    return dwResult;
}


//
// Update a named color value for a specified user.
//
DWORD
UpdateColorForUser(
    HKEY hkeyColors,
    LPCTSTR pszName,
    COLORREF rgb
    )
{
    DWORD dwResult;
    TCHAR szValue[ARRAYSIZE(g_szRegValRGB)];
    //
    // Convert RGB triplet to a text string for storage in the registry.
    //
    wsprintf(szValue, TEXT("%d %d %d"), GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));
    //
    // Save it to the registry.
    //
    dwResult = RegSetValueEx(hkeyColors,
                             pszName,
                             0,
                             REG_SZ,
                             (CONST BYTE *)szValue,
                             sizeof(szValue));

    if (ERROR_SUCCESS != dwResult)
    {
        DPRINT((TEXT("Error %d setting color value \"%s\" to \"%s\"\n"), dwResult, pszName, szValue));
    }
    return dwResult;
}


DWORD
UpdateElementColor(
    HKEY hkeyColors,
    const int *rgiElements,
    int cElements
    )
{
    int i;
    for (i = 0; i < cElements; i++)
    {
        int iElement = rgiElements[i];
        UpdateColorForUser(hkeyColors, 
                           g_rgWinStdColors[iElement].pszName,
                           g_rgWinStdColors[iElement].rgbValue);
    }
    return ERROR_SUCCESS;
}

    

//
// Perform all color updates for a user's NCM colors.
// These are the new "softer" grays and blues.
// ChristoB provided the color values.
//
DWORD
UpdateColorsForUser(
    HKEY hkeyUser
    )
{
    HKEY hkeyColors;
    DWORD dwResult = RegOpenKeyEx(hkeyUser,
                                  g_szRegKeyColors,
                                  0,
                                  KEY_QUERY_VALUE | KEY_SET_VALUE,
                                  &hkeyColors);

    if (ERROR_SUCCESS == dwResult)
    {
        //
        // Update these if the 3D button color is 192,192,192.
        //
        const int rgFaceChanges[] = { COLOR_BTNFACE,
                                      COLOR_SCROLLBAR,
                                      COLOR_MENU,
                                      COLOR_ACTIVEBORDER,
                                      COLOR_INACTIVEBORDER,
                                      COLOR_3DDKSHADOW,
                                      COLOR_3DLIGHT };
        //
        // Update these if the active caption color is 0,0,128
        //
        const int rgCaptionChanges[] = { COLOR_ACTIVECAPTION,
                                         COLOR_HIGHLIGHT,
                                         COLOR_GRADIENTACTIVECAPTION,
                                         COLOR_GRADIENTINACTIVECAPTION };
        //
        // Update these if the desktop is 128,128,0 (seafoam green)
        //
        const int rgDesktopChanges[] = { COLOR_BACKGROUND };

        struct
        {
            int        iTest;               // COLOR_XXXXX value.
            COLORREF   rgbTest;             // Color value that triggers upgrade.
            const int *prgChanges;          // Array of elements to upgrade.
            int        cChanges;            // Number of elements to upgrade.

        } rgci [] = {{ COLOR_3DFACE,        0x00C0C0C0, rgFaceChanges,    ARRAYSIZE(rgFaceChanges)    },
                     { COLOR_ACTIVECAPTION, 0x00800000, rgCaptionChanges, ARRAYSIZE(rgCaptionChanges) },
                     { COLOR_BACKGROUND,    0x00808000, rgDesktopChanges, ARRAYSIZE(rgDesktopChanges) }};

        int i;
        COLORREF rgb;
        for (i = 0; i < ARRAYSIZE(rgci); i++)
        {
            int iTest        = rgci[i].iTest;
            COLORREF rgbTest = rgci[i].rgbTest;

            if (ERROR_SUCCESS == GetColorForUser(hkeyColors, g_rgWinStdColors[iTest].pszName, &rgb) &&
                rgbTest == rgb)
            {
                UpdateElementColor(hkeyColors, rgci[i].prgChanges, rgci[i].cChanges);
            }
        }
        RegCloseKey(hkeyColors);
    }
    else
    {
        DPRINT((TEXT("Error %d opening reg key \"%s\" for user.\n"), dwResult, g_szRegKeyColors));
    }

    return dwResult;
}


//
// Convert a font metric name to a member of the FontMetricIndex
// enumeration.  Used to index into g_rgpszFontMetrics[] and 
// g_rglfDefaults[].
// 
// i.e. Returns FMI_CAPTIONFONT for "CaptionFont".
//
int
FontMetricNameToIndex(
    LPCTSTR pszName
    )
{
    int i;
    for (i = 0; i < ARRAYSIZE(g_rgpszFontMetrics); i++)
    {
        if (0 == lstrcmp(pszName, g_rgpszFontMetrics[i]))
            return i;
    }
    return -1;
}


//
// When updating a font from "MS Sans Serif" to a TrueType font
// we want to ensure the font point size is 8pt or greater.
// So, if the current font face is "MS Sans Serif" and
// (-11 < lfHeight < 0) is true, we force the lfHeight
// to -11 which corresponds to 8pt.  The standard windows
// schemes incorrectly have the height of the icon font
// specified as -8 (6pt) when it should be -11 (8pt).
// The problem is that the smallest pt size supported by 
// MS Sans Serif is 8pt so even if the requested size is 6pt,
// you see 8pt.  Once we switch to Tahoma (a TrueType font),
// it can produce the requested 6pt size so that's what you
// see.  6pt is way too small for desktop icons.
// The default icon font size used by user32.dll is 8pt.  
// See code in ntuser\kernel\inctlpan.c CreateFontFromWinIni().
// 
void
CorrectTooSmallFont(
    LOGFONT *plf
    )
{
    if ((0 > (int)plf->lfHeight) && (-11 < (int)plf->lfHeight))
    {
        //
        // NT uses font height values.
        //
        plf->lfHeight = -11;
    }
    else if ((0 < (int)plf->lfHeight) && (8 > (int)plf->lfHeight))
    {
        //
        // Win9x uses font point sizes.
        //
        plf->lfHeight = 8;
    }
}



//
// Replace any LOGFONT members in a LOGFONT structure and write the data
// to the registry for a given nc font metric.
//
// If plf is NULL, a new LOGFONT with default data is written to 
// the registry for the metric value.
// If plf is non-NULL and the LOGFONT's facename is in the list of 
// facenames to be updated, the required substitutions are made and
// the LOGFONT data is replaced in the registry.
//
DWORD
UpdateNcFont(
    HKEY hkeyMetrics, 
    LPCTSTR pszValueName,
    const LOGFONT *plf
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    int iMetrics   = FontMetricNameToIndex(pszValueName);
    LOGFONT lfCopy;
    if (NULL == plf)
    {
        //
        // Use all default values.
        //
        plf = &g_rglfDefaults[iMetrics];
    }
    else
    {
        //
        // First see if this face name should be updated.
        //
        if (0 == lstrcmpi(plf->lfFaceName, g_szMsSansSerif))
        {
            //
            // Yep.  Update the face name string in the logfont.  
            // Also make sure that the point size is 8 or greater
            //
            lfCopy = *plf;
            CorrectTooSmallFont(&lfCopy);
            lstrcpyn(lfCopy.lfFaceName, g_szNewNcFont, ARRAYSIZE(lfCopy.lfFaceName));
            plf = &lfCopy;
        }
        else
        {
            plf = NULL;  // Don't update the LOGFONT.
        }
    }

    if (NULL != plf)
    {
#ifdef NO_REG_CHANGES    
        DumpLogFont(plf);
#else
        dwResult = RegSetValueEx(hkeyMetrics,
                                 pszValueName,
                                 0,
                                 REG_BINARY,
                                 (const LPBYTE)plf,
                                 sizeof(*plf));

        if (ERROR_SUCCESS != dwResult)
        {
            DPRINT((TEXT("Error %d setting NC font data for \"%s\"\n"), 
                   dwResult, pszValueName));
        }
#endif
    }
    return dwResult;
}


//
// Update the nc font metrics for a particular user key under HKEY_USERS.
// If a particular font metric exists, the required replacements will be performed.
// If a particular font metric doesn't exist, it is added with default information.
// Note that not all keys under HKEY_USERS contain WindowMetric information.
//
DWORD
UpdateWindowMetricsForUser(
    HKEY hkeyUser
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    HKEY hkeyMetrics;

    dwResult = RegOpenKeyEx(hkeyUser,
                            g_szRegKeyMetrics,
                            0,
                            KEY_ALL_ACCESS,
                            &hkeyMetrics);

    if (ERROR_SUCCESS == dwResult)
    {
        DWORD cbValue;
        DWORD dwType;
        LOGFONT lf;
        int i;

        for (i = 0; i < ARRAYSIZE(g_rgpszFontMetrics); i++)
        {
            LPCTSTR pszValueName = g_rgpszFontMetrics[i];
            //
            // Start out with plf as NULL.  If a LOGFONT doesn't exist
            // for this NC font, leaving plf as NULL will cause 
            // UpdateNcFont to create a new default LOGFONT entry for this
            // NC font.
            //
            LOGFONT *plf = NULL;

            cbValue = sizeof(lf);
            dwResult = RegQueryValueEx(hkeyMetrics,
                                       pszValueName,
                                       NULL,
                                       &dwType,
                                       (LPBYTE)&lf,
                                       &cbValue);

            if (ERROR_SUCCESS == dwResult)
            {
                if (REG_BINARY == dwType)
                {
                    //
                    // A LOGFONT already exists for this NC font.
                    // Passing it's address to UpdateNcFont will
                    // update the LOGFONT.
                    //
                    plf = &lf;
                }
            }
            dwResult = UpdateNcFont(hkeyMetrics, pszValueName, plf);
        }
    }
    else if (ERROR_FILE_NOT_FOUND == dwResult)
    {
        //
        // Some keys under HKEY_USERS don't have WindowMetric information.
        // Such cases are not processed but are still considered successful.
        //
        dwResult = ERROR_SUCCESS;
    }
    else
    {
        DPRINT((TEXT("Error %d opening key \"%s\"\n"), dwResult, g_szRegKeyMetrics));
    }
    return dwResult;
}


//
// Load a scheme's SCHEMEDATA from the registry, perform any necessary
// updates and re-write the data back to the registry.
//
DWORD
UpdateScheme(
    HKEY hkeySchemes, 
    LPCTSTR pszScheme
    )
{
    SCHEMEDATA sd;
    DWORD dwResult;
    DWORD dwType;
    DWORD cbsd = sizeof(sd);

    dwResult = RegQueryValueEx(hkeySchemes,
                               pszScheme,
                               NULL,
                               &dwType,
                               (LPBYTE)&sd,
                               &cbsd);

    if (ERROR_SUCCESS == dwResult)
    {
        if (REG_BINARY == dwType)
        {
            int i;

            struct LogFontInfo
            {
                DWORD iMetrics;
                LOGFONT *plf;

            } rglfi[] = {
                  { FMI_CAPTIONFONT,   &sd.ncm.lfCaptionFont   },
                  { FMI_SMCAPTIONFONT, &sd.ncm.lfSmCaptionFont },
                  { FMI_MENUFONT,      &sd.ncm.lfMenuFont      },
                  { FMI_STATUSFONT,    &sd.ncm.lfStatusFont    },
                  { FMI_MESSAGEFONT,   &sd.ncm.lfMessageFont   },
                  { FMI_ICONFONT,      &sd.lfIconTitle         },
                  };

            for (i = 0; i < ARRAYSIZE(rglfi); i++)
            {
                if (0 == lstrcmpi(rglfi[i].plf->lfFaceName, g_szMsSansSerif))
                {
                    //
                    // Ensure it's no smaller than 8pt.  Anything less
                    // than 8 pt is not readable on current displays.
                    //
                    CorrectTooSmallFont(rglfi[i].plf);
                    //
                    // Update the logfont's facename from 
                    // "MS Sans Serif" to "Microsoft Sans Serif".
                    //
                    lstrcpyn(rglfi[i].plf->lfFaceName, 
                             g_szMicrosoftSansSerif, 
                             ARRAYSIZE(rglfi[i].plf->lfFaceName));
                }
            }

            if (cbsd < sizeof(sd))
            {
                //
                // This is an NT4 custom scheme.
                //
                //   NT4->W2K custom schemes are not upgraded so they're still
                //            in NT4 format.  cbsd < sizeof(sd).
                //
                //   W9x->W2K custom schemes are upgraded by the Win9x migration
                //            process so they're already in W2K format.
                //            cbsd == sizeof(sd)
                // 
                // The scheme has no gradient colors defined.  We set them here to 
                // the same color as the corresponding non-gradient colors.  This
                // will result in solid-color caption bars for custom schemes.
                // Also update the hotlight color.
                //
                sd.rgb[COLOR_GRADIENTACTIVECAPTION]   = sd.rgb[COLOR_ACTIVECAPTION];
                sd.rgb[COLOR_GRADIENTINACTIVECAPTION] = sd.rgb[COLOR_INACTIVECAPTION];
                sd.rgb[COLOR_HOTLIGHT]                = sd.rgb[COLOR_ACTIVECAPTION];
            }

            dwResult = RegSetValueEx(hkeySchemes,
                                     pszScheme,
                                     0,
                                     REG_BINARY,
                                     (const LPBYTE)&sd,
                                     sizeof(sd));

            if (ERROR_SUCCESS != dwResult)
            {
                DPRINT((TEXT("Error %d saving new scheme \"%s\"\n"), dwResult, pszScheme));
            }
        }
        else
        {
            DPRINT((TEXT("Invalid data type %d for scheme \"%s\". Expected REG_BINARY.\n"), 
                   dwType, pszScheme));
        }
    }
    else
    {
        DPRINT((TEXT("Error %d querying scheme \"%s\"\n"), dwResult, pszScheme));
    }
    return dwResult;
}

//
// Handles all of the "scheme" related adjustments.
// 1. Converts "MS Sans Serif" to "Microsoft Sans Serif" in 
//    all schemes.  Also ensures we don't have any 6pt
//    Microsoft Sans Serif fonts used.
//
DWORD
UpdateDesktopSchemesForUser(
    HKEY hkeyUser
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    HKEY hkeySchemes;
    
    dwResult = RegOpenKeyEx(hkeyUser,
                            g_szRegKeySchemes,
                            0,
                            KEY_ALL_ACCESS,
                            &hkeySchemes);

    if (ERROR_SUCCESS == dwResult)
    {
        DWORD dwIndex = 0;
        TCHAR szValueName[MAX_PATH];
        DWORD cchValueName;
        DWORD type;
        while(ERROR_SUCCESS == dwResult)
        {
            cchValueName = ARRAYSIZE(szValueName);
            dwResult = RegEnumValue(hkeySchemes,
                                    dwIndex++,
                                    szValueName,
                                    &cchValueName,
                                    NULL,
                                    &type,
                                    NULL,
                                    NULL);

            if (ERROR_SUCCESS == dwResult)
            {
                //
                // Convert "MS Sans Serif" to "Microsoft Sans Serif" in ALL schemes
                //
                UpdateScheme(hkeySchemes, szValueName);
            }
        }
        RegCloseKey(hkeySchemes);
    }
    if (ERROR_FILE_NOT_FOUND == dwResult)
    {
        //
        // Not all subkeys under HKEY_USER have the 
        // Control Panel\Appearance\Schemes subkey.
        //
        dwResult = ERROR_SUCCESS;
    }

    return dwResult;
}



//
// Function used to upgrade schemes and non-client metrics on upgrades
// from Win9x and NT to Win2000.
// 
void 
UpgradeSchemesAndNcMetricsToWin2000ForUser(
    HKEY hkeyUser
    )
{
    DWORD dwResult = ERROR_SUCCESS;

    DPRINT((TEXT("Updating schemes and non-client metrics.\n")));
    //
    // Update gradient colors BEFORE making any other changes.  
    // This code is in gradient.c
    //
    FixGradientColors();

    dwResult = UpdateWindowMetricsForUser(hkeyUser);
    if (ERROR_SUCCESS != dwResult)
    {
        DPRINT((TEXT("Error %d updating non-client metrics for user\n"), dwResult));
    }
    dwResult = UpdateDesktopSchemesForUser(hkeyUser);
    if (ERROR_SUCCESS != dwResult)
    {
        DPRINT((TEXT("Error %d updating schemes for user\n"), dwResult));
    }
    dwResult = UpdateColorsForUser(hkeyUser);
    if (ERROR_SUCCESS != dwResult)
    {
        DPRINT((TEXT("Error %d updating color information for user\n"), dwResult));
    }

    DPRINT((TEXT("Update of schemes and non-client metrics completed.\n")));
}

//
// This version is called on an upgrade from NT->Win2000.
//
void 
UpgradeSchemesAndNcMetricsToWin2000(
    void
    )
{
    UpgradeSchemesAndNcMetricsToWin2000ForUser(HKEY_CURRENT_USER);
}


//
// On upgrades from Win9x we are passed a string value representing the 
// key under which we'll find the user's Control Panel\Appearance subkey.
// The string is in the form "HKCU\$$$".  We first translate the root key
// descriptor into a true root key then pass that root and the "$$$" 
// part onto RegOpenKeyEx.  This function takes that string and opens
// the associated hive key.
//
DWORD
OpenUserKeyForWin9xUpgrade(
    char *pszUserKeyA,
    HKEY *phKey
    )
{
    DWORD dwResult = ERROR_INVALID_PARAMETER;

    if (NULL != pszUserKeyA && NULL != phKey)
    {
        typedef struct {
            char *pszRootA;
            HKEY hKeyRoot;

        } REGISTRY_ROOTS, *PREGISTRY_ROOTS;

        static REGISTRY_ROOTS rgRoots[] = {
            { "HKLM",                 HKEY_LOCAL_MACHINE   },
            { "HKEY_LOCAL_MACHINE",   HKEY_LOCAL_MACHINE   },
            { "HKCC",                 HKEY_CURRENT_CONFIG  },
            { "HKEY_CURRENT_CONFIG",  HKEY_CURRENT_CONFIG  },
            { "HKU",                  HKEY_USERS           },
            { "HKEY_USERS",           HKEY_USERS           },
            { "HKCU",                 HKEY_CURRENT_USER    },
            { "HKEY_CURRENT_USER",    HKEY_CURRENT_USER    },
            { "HKCR",                 HKEY_CLASSES_ROOT    },
            { "HKEY_CLASSES_ROOT",    HKEY_CLASSES_ROOT    }
          };

        char szUserKeyA[MAX_PATH];      // For a local copy.
        char *pszSubKeyA = szUserKeyA;

        //
        // Make a local copy that we can modify.
        //
        lstrcpynA(szUserKeyA, pszUserKeyA, ARRAYSIZE(szUserKeyA));

        *phKey = NULL;
        //
        // Find the backslash.
        //
        while(*pszSubKeyA && '\\' != *pszSubKeyA)
            pszSubKeyA++;

        if ('\\' == *pszSubKeyA)
        {
            HKEY hkeyRoot = NULL;
            int i;
            //
            // Replace backslash with nul to separate the root key and
            // sub key strings in our local copy of the original argument 
            // string.
            //
            *pszSubKeyA++ = '\0';
            //
            // Now find the true root key in rgRoots[].
            //
            for (i = 0; i < ARRAYSIZE(rgRoots); i++)
            {
                if (0 == lstrcmpiA(rgRoots[i].pszRootA, szUserKeyA))
                {
                    hkeyRoot = rgRoots[i].hKeyRoot;
                    break;
                }
            }
            if (NULL != hkeyRoot)
            {
                //
                // Open the key.
                //
                dwResult = RegOpenKeyExA(hkeyRoot,
                                         pszSubKeyA,
                                         0,
                                         KEY_ALL_ACCESS,
                                         phKey);
            }
        }
    }
    return dwResult;
}


//
// This version is called on an upgrade from Win9x to Win2000.
//
void 
UpgradeSchemesAndNcMetricsFromWin9xToWin2000(
    char *pszUserKey
    )
{
    HKEY hkeyUser;
    DWORD dwResult = OpenUserKeyForWin9xUpgrade(pszUserKey, &hkeyUser);
    if (ERROR_SUCCESS == dwResult)
    {
        UpgradeSchemesAndNcMetricsToWin2000ForUser(hkeyUser);
        RegCloseKey(hkeyUser);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\migrate\shmgdefs.h ===
#define ARRAYSIZE(s)    (sizeof(s) / (sizeof(s[0])))
#define SIZEOF(s)       sizeof(s)

#define IDS_HTML_HELP_DIR  101

/*
 * Common utility functions
 */
BOOL HasPath( LPTSTR pszFilename );
int mystrcpy( LPTSTR pszOut, LPTSTR pszIn, TCHAR chTerm );


/*
 * Conversion Routines
 */
void CvtDeskCPL_Win95ToSUR( void );
void CvtCursorsCPL_DaytonaToSUR( void );
void FixupCursorSchemePaths( void );
void FixWindowsProfileSecurity( void );
void FixUserProfileSecurity( void );
void FixPoliciesSecurity( void );
void CvtCursorSchemesToMultiuser( void );
void FixGradientColors( void );
void UpgradeSchemesAndNcMetricsToWin2000( void );
void UpgradeSchemesAndNcMetricsFromWin9xToWin2000(char *pszUserKey);
void SetSystemBitOnCAPIDir(void);
void FixHtmlHelp(void);
void SetScreensaverOnFriendlyUI();
void AddConfigurePrograms(void);

EXTERN_C void UserConfigIE();
EXTERN_C void UserConfigOE();
EXTERN_C void ShowHideIE(BOOL fShow, BOOL fForceAssociations, BOOL fNonUpdateInstall);
EXTERN_C void ShowHideOE(BOOL fShow, BOOL fForceAssociations, BOOL fNonUpdateInstall);
EXTERN_C void ReinstallVM();
EXTERN_C void FixupOptionalComponents();
EXTERN_C void OCInstallUpdate();
EXTERN_C void OCInstallCleanupInitiallyClear();
    
#ifdef SHMG_DBG
    void Dprintf( LPTSTR pszFmt, ... );
#   define DPRINT(p)   Dprintf p
#   define SHMG_DBG    1
void SHMGLogErrMsg(char *szErrMsg, DWORD dwError);

#else

#define DPRINT(p)
#define SHMGLogErrMsg(x, y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\migrate\shmgrate.c ===
#include <windows.h>
#include <userenv.h>
#include <userenvp.h>
#include <shlwapi.h>
#include "shmgdefs.h"

EXTERN_C void UpgradeDesktopWallpaper(void);

enum {
    CMD_W95_TO_SUR,
    CMD_DAYTONA_CURSORS,
    CMD_FIX_CURSOR_PATHS,
    CMD_FIX_SPECIAL_FOLDERS,
    CMD_FIX_WINDOWS_PROFILE_SECURITY,
    CMD_FIX_USER_PROFILE_SECURITY,
    CMD_FIX_POLICIES_SECURITY,
    CMD_CVT_SCHEMES_TO_MULTIUSER,
    CMD_UPGRADE_NT4_PROFILE_TO_NT5,
    CMD_UPGRADE_SCHEMES_AND_NCMETRICS_TO_WIN2000,
    CMD_UPGRADE_SCHEMES_AND_NCMETRICS_FROM_WIN9X_TO_WIN2000,
    CMD_FIX_CAPI_DIR_ATTRIBUTES,
    CMD_MERGE_DESKTOP_AND_NORMAL_STREAMS,
    CMD_MOVE_AND_ADJUST_ICON_METRICS,
    CMD_FIX_HTML_HELP,
    CMD_SET_SCREENSAVER_FRIENDLYUI,
    CMD_ADD_CONFIGURE_PROGRAMS,
    CMD_OCINSTALL_FIXUP,

    //  enums from here down will run within OleInitialize/OleUnitialize
    CMD_OLE_REQUIRED_START = 10000,
    CMD_OCINSTALL_SHOW_IE,
    CMD_OCINSTALL_REINSTALL_IE,
    CMD_OCINSTALL_HIDE_IE,
    CMD_OCINSTALL_USER_CONFIG_IE,
    CMD_OCINSTALL_SHOW_OE,
    CMD_OCINSTALL_REINSTALL_OE,
    CMD_OCINSTALL_HIDE_OE,
    CMD_OCINSTALL_USER_CONFIG_OE,
    CMD_OCINSTALL_SHOW_VM,
    CMD_OCINSTALL_REINSTALL_VM,
    CMD_OCINSTALL_HIDE_VM,
    CMD_OCINSTALL_UPDATE,
    CMD_OCINSTALL_CLEANUP_INITIALLY_CLEAR,
} CMD_VALS;

int mystrcpy( LPTSTR pszOut, LPTSTR pszIn, TCHAR chTerm ) {
    BOOL fInQuote = FALSE;
    LPTSTR pszStrt = pszOut;

    while( *pszIn && !fInQuote && *pszIn != chTerm ) {
        if (*pszIn == TEXT('"')) {
            fInQuote = !fInQuote;
        }
        *pszOut++ = *pszIn++;
    }

    *pszOut = TEXT('\0');
    return (int)(pszOut - pszStrt);
}

BOOL HasPath( LPTSTR pszFilename ) {
    //
    // Special case null string so it won't get changed
    //
    if (*pszFilename == TEXT('\0'))
        return TRUE;

    for(; *pszFilename; pszFilename++ ) {
        if (*pszFilename == TEXT(':') || *pszFilename == TEXT('\\') || *pszFilename == TEXT('/')) {
            return TRUE;
        }
    }

    return FALSE;
}

void HandOffToShell32 (LPCSTR pcszCommand, LPCSTR pcszOptionalArgument)

{
    TCHAR   szShell32Path[MAX_PATH];

    if (GetSystemDirectory(szShell32Path, ARRAYSIZE(szShell32Path)) != 0)
    {
        HINSTANCE   hInstShell32;

        PathAppend(szShell32Path, TEXT("shell32.dll"));
        hInstShell32 = LoadLibrary(szShell32Path);
        if (hInstShell32 != NULL)
        {
            typedef HRESULT (*PFNFirstUserLogon) (LPCSTR pcszCommand, LPCSTR pcszOptionalArgument);

            PFNFirstUserLogon   pfnFirstUserLogon;

            // Call shell32!FirstUserLogon which is Ordinal230 defined in shell32.src.

            pfnFirstUserLogon = (PFNFirstUserLogon)GetProcAddress(hInstShell32, (LPCSTR)MAKEINTRESOURCE(230));
            if (pfnFirstUserLogon != NULL)
                pfnFirstUserLogon(pcszCommand, pcszOptionalArgument);
            FreeLibrary(hInstShell32);
        }
    }
}

/*
 * Command Parser
 */
typedef struct {
    LPSTR  pszCmd;
    int    idCmd;
} CMD;

CMD aCmds[] = {
    { "W",                                   CMD_W95_TO_SUR       },
    { "Cvt-Curs",                            CMD_DAYTONA_CURSORS  },
    { "Fix-Curs",                            CMD_FIX_CURSOR_PATHS },
    { "Fix-Folders",                         CMD_FIX_SPECIAL_FOLDERS},
    { "Fix-Win-Security",                    CMD_FIX_WINDOWS_PROFILE_SECURITY},
    { "Fix-User-Security",                   CMD_FIX_USER_PROFILE_SECURITY},
    { "Fix-Policies-Security",               CMD_FIX_POLICIES_SECURITY},
    { "Cvt-Mouse-Schemes",                   CMD_CVT_SCHEMES_TO_MULTIUSER},
    { "UpgradeProfileNT4ToNT5",              CMD_UPGRADE_NT4_PROFILE_TO_NT5},
    { "UpgradeSchemesAndNcMetricsToWin2000", CMD_UPGRADE_SCHEMES_AND_NCMETRICS_TO_WIN2000},
    { "UpgradeSchemesAndNcMetricsFromWin9xToWin2000", CMD_UPGRADE_SCHEMES_AND_NCMETRICS_FROM_WIN9X_TO_WIN2000},
    { "FixCAPIDirAttrib",                    CMD_FIX_CAPI_DIR_ATTRIBUTES},
    { "MergeDesktopAndNormalStreams",        CMD_MERGE_DESKTOP_AND_NORMAL_STREAMS },
    { "MoveAndAdjustIconMetrics",            CMD_MOVE_AND_ADJUST_ICON_METRICS },
    { "Fix-HTML-Help",                       CMD_FIX_HTML_HELP },
    { "Set-Screensaver-On-FriendlyUI",       CMD_SET_SCREENSAVER_FRIENDLYUI },
    { "AddConfigurePrograms",                CMD_ADD_CONFIGURE_PROGRAMS },
    { "OCInstallShowIE",                     CMD_OCINSTALL_SHOW_IE },
    { "OCInstallReinstallIE",                CMD_OCINSTALL_REINSTALL_IE },
    { "OCInstallHideIE",                     CMD_OCINSTALL_HIDE_IE },
    { "OCInstallUserConfigIE",               CMD_OCINSTALL_USER_CONFIG_IE },
    { "OCInstallShowOE",                     CMD_OCINSTALL_SHOW_OE },
    { "OCInstallReinstallOE",                CMD_OCINSTALL_REINSTALL_OE },
    { "OCInstallHideOE",                     CMD_OCINSTALL_HIDE_OE },
    { "OCInstallUserConfigOE",               CMD_OCINSTALL_USER_CONFIG_OE },
//    { "OCInstallShowVM",                     CMD_OCINSTALL_SHOW_VM },
    { "OCInstallReinstallVM",                CMD_OCINSTALL_REINSTALL_VM },
//    { "OCInstallHideVM",                     CMD_OCINSTALL_HIDE_VM },
    { "OCInstallFixup",                      CMD_OCINSTALL_FIXUP },
    { "OCInstallUpdate",                     CMD_OCINSTALL_UPDATE },
    { "OCInstallCleanupInitiallyClear",      CMD_OCINSTALL_CLEANUP_INITIALLY_CLEAR },
};

#define C_CMDS  ARRAYSIZE(aCmds)

void __cdecl main( int cArgs, char **szArg) {
    int i;
    HRESULT hrOle = E_FAIL;

    SHMGLogErrMsg("main called with args", (DWORD)cArgs);

    if (cArgs < 2 || cArgs > 3)
        ExitProcess(1);

#ifdef SHMG_DBG
    for(i=1; i<cArgs; i++)
        SHMGLogErrMsg(szArg[i], (DWORD)i);
#endif        

    for( i = 0; i < C_CMDS && lstrcmpA( szArg[1], aCmds[i].pszCmd ) != 0; i++ );

    if (i >= C_CMDS)
        ExitProcess(1);
   
    if (aCmds[i].idCmd >= CMD_OLE_REQUIRED_START)
    {
        hrOle = OleInitialize(NULL);

        if (FAILED(hrOle))
        {
            ExitProcess(1);
        }
    }
    
    switch( aCmds[i].idCmd ) {

    case CMD_W95_TO_SUR:
        CvtDeskCPL_Win95ToSUR();
        break;

    case CMD_DAYTONA_CURSORS:
        CvtCursorsCPL_DaytonaToSUR();
        break;

    case CMD_FIX_CURSOR_PATHS:
        FixupCursorSchemePaths();
        break;

    case CMD_FIX_SPECIAL_FOLDERS:
        ResetUserSpecialFolderPaths();
        break;

    case CMD_FIX_WINDOWS_PROFILE_SECURITY:
        FixWindowsProfileSecurity();
        break;

    case CMD_FIX_USER_PROFILE_SECURITY:
        FixUserProfileSecurity();
        break;

    case CMD_FIX_POLICIES_SECURITY:
        FixPoliciesSecurity();
        break;

    case CMD_CVT_SCHEMES_TO_MULTIUSER:
        CvtCursorSchemesToMultiuser();
        break;

    case CMD_UPGRADE_NT4_PROFILE_TO_NT5:
        MigrateNT4ToNT5();
        break;

    case CMD_UPGRADE_SCHEMES_AND_NCMETRICS_TO_WIN2000:
        UpgradeSchemesAndNcMetricsToWin2000();
        break;

    case CMD_UPGRADE_SCHEMES_AND_NCMETRICS_FROM_WIN9X_TO_WIN2000:
        UpgradeSchemesAndNcMetricsFromWin9xToWin2000(cArgs > 2 ? szArg[2] : NULL);
        break;

    case CMD_FIX_CAPI_DIR_ATTRIBUTES:
        SetSystemBitOnCAPIDir();
        break;

    case CMD_MERGE_DESKTOP_AND_NORMAL_STREAMS:
    case CMD_MOVE_AND_ADJUST_ICON_METRICS:
        HandOffToShell32(szArg[1], cArgs > 2 ? szArg[2] : NULL);
        break;

    case CMD_FIX_HTML_HELP:
        FixHtmlHelp();
        break;

    case CMD_SET_SCREENSAVER_FRIENDLYUI:
        SetScreensaverOnFriendlyUI();
        break;

    case CMD_ADD_CONFIGURE_PROGRAMS:
        AddConfigurePrograms();
        break;

    case CMD_OCINSTALL_FIXUP:
        FixupOptionalComponents();
        break;

    case CMD_OCINSTALL_UPDATE:
        OCInstallUpdate();
        break;

    case CMD_OCINSTALL_CLEANUP_INITIALLY_CLEAR:
        OCInstallCleanupInitiallyClear();
        break;
        
    case CMD_OCINSTALL_SHOW_IE:
        ShowHideIE(TRUE, FALSE, TRUE);
        break;
        
    case CMD_OCINSTALL_REINSTALL_IE:
        ShowHideIE(TRUE, TRUE, TRUE);
        break;
        
    case CMD_OCINSTALL_HIDE_IE:
        ShowHideIE(FALSE, FALSE, TRUE);
        break;
        
    case CMD_OCINSTALL_USER_CONFIG_IE:
        UserConfigIE();
        break;
        
    case CMD_OCINSTALL_SHOW_OE:
        ShowHideOE(TRUE, FALSE, TRUE);
        break;
        
    case CMD_OCINSTALL_REINSTALL_OE:
        ShowHideOE(TRUE, TRUE, TRUE);
        break;
        
    case CMD_OCINSTALL_HIDE_OE:
        ShowHideOE(FALSE, FALSE, TRUE);
        break;
        
    case CMD_OCINSTALL_USER_CONFIG_OE:
        UserConfigOE();
        break;
        
    case CMD_OCINSTALL_SHOW_VM:
        //  Do nothing...
        break;
        
    case CMD_OCINSTALL_REINSTALL_VM:
        ReinstallVM();
        break;
        
    case CMD_OCINSTALL_HIDE_VM:
        //  Do nothing...
        break;

    default:
        ExitProcess(2);
    }

    if (SUCCEEDED(hrOle))
    {
        OleUninitialize();
    }


    ExitProcess(0);
}



#ifdef SHMG_DBG
/***************************************************************************\
*
*     FUNCTION: FmtSprintf( DWORD id, ... );
*
*     PURPOSE:  sprintf but it gets the pattern string from the message rc.
*
* History:
* 03-May-1993 JonPa         Created it.
\***************************************************************************/
TCHAR g_szDbgBuffer[16384];
char g_szDbgBufA[16384];
void Dprintf( LPTSTR pszFmt, ... ) {
    DWORD cb;
    LPVOID psz = g_szDbgBuffer;
    va_list marker;

    va_start( marker, pszFmt );

    wvsprintf( g_szDbgBuffer, pszFmt, marker );
    OutputDebugString(g_szDbgBuffer);


#ifdef UNICODE
    cb = WideCharToMultiByte(CP_ACP, 0, g_szDbgBuffer, -1, g_szDbgBufA, sizeof(g_szDbgBufA), NULL, NULL);
    psz = g_szDbgBufA;
#else
    cb = lstrlen(g_szDbgBuffer) * sizeof(TCHAR);
#endif

    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), psz, cb, &cb, NULL);

    va_end( marker );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\migrate\ocinst.cpp ===
#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <inetreg.h>
#include <advpub.h>
#include <debug.h>
#include <inetreg.h>
#include <shlobj.h>
#include <advpub.h>
#include <xpsp1res.h>
#include <regstr.h>
#include "shmgdefs.h"

HINSTANCE g_hInstResLib = NULL;

const WCHAR c_szIEApp[] = L"iexplore.exe";
const WCHAR c_szOEApp[] = L"msimn.exe";
const WCHAR c_szWMP[] = L"wmplayer.exe";
const WCHAR c_szMessenger[] = L"msmsgs.exe";
const WCHAR c_szIECanonicalName[] = L"IEXPLORE.EXE";
const WCHAR c_szOECanonicalName[] = L"Outlook Express";

#ifndef INTERNET_MAX_PATH_LENGTH
#define INTERNET_MAX_PATH_LENGTH    2048
#endif

#ifdef _TNOONAN_TEST_WIN64
#define _WIN64
#undef CSIDL_PROGRAM_FILESX86
#define CSIDL_PROGRAM_FILESX86  CSIDL_PROGRAM_FILES
#endif

//
//  We must create our shortcuts in the same language as the install
//  language.  If the install language is USEnglish, we cannot use
//  LoadString because MUI might redirect us to the localized string,
//  so we have a hard-coded list of USEnglish strings.  We need that
//  anyway in the Hide case, where we may need to delete old USEnglish
//  versions of the shortcut left over from previous versions of IE.
//
enum {  // Localized Shortcut Name
    LSN_SM_IE,
    LSN_QL_IE,
    LSN_SM_OE,
    LSN_QL_OE,
    LSN_NOSHOW_OE,
    LSN_NOSHOW_IE,
#ifdef _WIN64
    LSN_SM_IE32,
#endif

    // special sentinel value
    LSN_NONE = -1,
};

struct LOCALIZEDSHORTCUTINFO
{
    LPCWSTR pszExe;             // The application to run
    LPCWSTR pszUSEnglish;       // Use if native OS is USEnglish or MUI-localized
    UINT    idsLocalized;       // Use if native OS is fully-localized (relative to xpsp1res)
    UINT    idsDescription;     // Shortcut description (relative to xpsp1res)
    BOOL    fNeverShowShortcut; // Use if we should never show (only hide)
};

const LOCALIZEDSHORTCUTINFO c_rglsi[] = {
    {       // LSN_SM_IE
        c_szIEApp,
        L"Internet Explorer",
        IDS_OC_IESHORTCUTNAME_SM,
        IDS_OC_IEDESCRIPTION,
        FALSE,
    },

    {       // LSN_QL_IE
        c_szIEApp,
        L"Launch Internet Explorer Browser",
        IDS_OC_IESHORTCUTNAME_QL,
        IDS_OC_IEDESCRIPTION,
        FALSE,
    },

    {       // LSN_SM_OE
        c_szOEApp,
        L"Outlook Express",
        IDS_OC_OESHORTCUTNAME_SM,
        IDS_OC_OEDESCRIPTION,
        FALSE,
    },

    {       // LSN_QL_OE
        c_szOEApp,
        L"Launch Outlook Express",
        IDS_OC_OESHORTCUTNAME_QL,
        IDS_OC_OEDESCRIPTION,
        TRUE,
    },

    {   //  LSN_NOSHOW_OE
        c_szOEApp,
        L"Outlook Express",
        IDS_OC_OESHORTCUTNAME_SM,
        IDS_OC_OEDESCRIPTION,
        TRUE,
    },
 
    {   //  LSN_NOSHOW_IE
        c_szIEApp,
        L"Internet Explorer",
        IDS_OC_OESHORTCUTNAME_SM,
        IDS_OC_OEDESCRIPTION,
        TRUE,
    },

#ifdef _WIN64
    {   // LSN_SM_IE32
        NULL,       // Special-cased in CreateShortcut since it's not in App Paths
        L"Internet Explorer (32-bit)",
        IDS_OC_IESHORTCUTNAME_SM64,
        IDS_OC_IEDESCRIPTION,
        FALSE,
    },
#endif

};

#ifdef _WIN64
WCHAR g_szIE32Path[MAX_PATH];
#endif

const WCHAR c_szIMN[] = L"Internet Mail and News";
const WCHAR c_szNTOS[] = L"Microsoft(R) Windows NT(TM) Operating System";
const WCHAR c_szHotmail[] = L"Hotmail";

const WCHAR c_szUrlDll[] = L"url.dll";
const WCHAR c_szMailNewsDll[] = L"mailnews.dll";

const WCHAR c_szIEInstallInfoKey[] = L"Software\\Clients\\StartMenuInternet\\IEXPLORE.EXE\\InstallInfo";
const WCHAR c_szOEInstallInfoKey[] = L"Software\\Clients\\Mail\\Outlook Express\\InstallInfo";
const WCHAR c_szIconsVisible[] = L"IconsVisible";
const WCHAR c_szReinstallCommand[] = L"ReinstallCommand";
const WCHAR c_szHideIconsCommand[] = L"HideIconsCommand";
const WCHAR c_szShowIconsCommand[] = L"ShowIconsCommand";

const WCHAR c_szReinstallCommandOE[] = L"%SystemRoot%\\system32\\shmgrate.exe OCInstallReinstallOE";
const WCHAR c_szHideIconsCommandOE[] = L"%SystemRoot%\\system32\\shmgrate.exe OCInstallHideOE";
const WCHAR c_szShowIconsCommandOE[] = L"%SystemRoot%\\system32\\shmgrate.exe OCInstallShowOE";
    
const WCHAR c_szStartMenuInternetClientKey[] = L"Software\\Clients\\StartMenuInternet";
const WCHAR c_szMailClientKey[] = L"Software\\Clients\\Mail";

#ifdef _WIN64
const WCHAR c_szMailClientKeyWOW32[] = L"Software\\Wow6432Node\\Clients\\Mail";
#endif

const WCHAR c_szJavaVMKey[] = L"CLSID\\{08B0E5C0-4FCB-11CF-AAA5-00401C608501}";

const WCHAR c_szInitiallyClearKey[] = L"Software\\Microsoft\\Active Setup\\Installed Components\\InitiallyClear";
const WCHAR c_szIEAccessKey[] = L"Software\\Microsoft\\Active Setup\\Installed Components\\>{26923b43-4d38-484f-9b9e-de460746276c}";
const WCHAR c_szOEAccessKey[] = L"Software\\Microsoft\\Active Setup\\Installed Components\\>{881dd1c5-3dcf-431b-b061-f3f88e8be88a}";

const WCHAR c_szIsInstalled[] = L"IsInstalled";
const WCHAR c_szLocale[] = L"Locale";
const WCHAR c_szVersion[] = L"Version";

const WCHAR c_szOCManagerSubComponents[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents";
const WCHAR c_szIEAccess[] = L"IEAccess";
const WCHAR c_szOEAccess[] = L"OEAccess";

const WCHAR c_szKeyComponentFormat[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CLSID\\%s\\ShellFolder";
const WCHAR c_szIEDesktopCLSID[] = L"{871C5380-42A0-1069-A2EA-08002B30309D}";
const WCHAR c_szShellFolder[] = L"ShellFolder";
const WCHAR c_szAttribute[] = L"Attributes";

void ShellFree(LPITEMIDLIST pidl)
{
    if (pidl)
    {
        IMalloc *pMalloc;

        if (SUCCEEDED(SHGetMalloc(&pMalloc)))
        {
            pMalloc->Free(pidl);
            pMalloc->Release();
        }
    }
}

HINSTANCE GetResLibInstance()
{
    if (NULL == g_hInstResLib)
    {
        g_hInstResLib = LoadLibraryEx(L"xpsp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    }

    return g_hInstResLib;
}

BOOL IsServer()
{
    OSVERSIONINFOEX osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    return (GetVersionEx((OSVERSIONINFO *)&osvi) && 
            ((VER_NT_SERVER == osvi.wProductType) || (VER_NT_DOMAIN_CONTROLLER == osvi.wProductType)));
}

LONG GetStringValue(
    IN  HKEY    hkey,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue,          OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData)            OPTIONAL
{
    DWORD dwType;
    DWORD cbData = pcbData ? *pcbData : 0;

    LONG lResult = SHGetValueW(hkey, pwszSubKey, pwszValue, &dwType, pvData, pcbData);

    if ((ERROR_SUCCESS == lResult) && (REG_SZ == dwType))
    {
        //  NULL terminate this puppy...
        if (pvData && cbData)
        {
            WCHAR *psz = (WCHAR *)pvData;
            psz[(cbData / sizeof(WCHAR)) - 1] = 0;
        }
    }
    else
    {
        lResult = ERROR_BADKEY;
    }

    return lResult;
}

inline HRESULT FailedHresultFromWin32()
{
    DWORD dwGLE = GetLastError();

    return (dwGLE != NOERROR) ? HRESULT_FROM_WIN32(dwGLE) : E_UNEXPECTED;
}

void SendChangeNotification(int csidl)
{
    LPITEMIDLIST pidl;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl, &pidl)))
    {
        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidl, NULL);
        
        ShellFree(pidl);
    }
}

BOOL IsNtSetupRunning()
{
    BOOL fSetupRunning = FALSE;
    DWORD dwSetupRunning;
    DWORD cbValue = sizeof(dwSetupRunning);
    long lResult = SHGetValue(HKEY_LOCAL_MACHINE, L"system\\Setup", L"SystemSetupInProgress", NULL, &dwSetupRunning, &cbValue);

    if ((ERROR_SUCCESS == lResult) && (dwSetupRunning))
    {
        fSetupRunning = TRUE;
    }
    else
    {
        cbValue = sizeof(dwSetupRunning);
        lResult = SHGetValue(HKEY_LOCAL_MACHINE, L"system\\Setup", L"UpgradeInProgress", NULL, &dwSetupRunning, &cbValue);

        if ((ERROR_SUCCESS == lResult) && (dwSetupRunning))
        {
            fSetupRunning = TRUE;
        }
    }

    return fSetupRunning;
}

BOOL IsIgnorableClientProgram(LPCWSTR pszCurrentClient, LPCWSTR *ppszIgnoreList)
{
    BOOL fResult = (lstrlen(pszCurrentClient) == 0);

    if (!fResult && (NULL != ppszIgnoreList))
    {
        while (NULL != *ppszIgnoreList)
        {
            if (0 == StrCmpI(pszCurrentClient, *ppszIgnoreList))
            {
                fResult = TRUE;
                break;
            }
            ppszIgnoreList++;
        }
    }

    return fResult;
}

void SetDefaultClientProgram(HKEY hkeyRoot, LPCWSTR pszClientKey, LPCWSTR pszCanonicalName, LPCWSTR *ppszIgnoreList, BOOL fShow, BOOL fForce)
{
    HKEY hKey;
    LONG lResult = RegOpenKeyEx(hkeyRoot, pszClientKey, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        WCHAR szCurrentClient[MAX_PATH];
        DWORD cbCurrentClient = sizeof(szCurrentClient);
        
        lResult = GetStringValue(hKey, NULL, NULL, szCurrentClient, &cbCurrentClient);
        
        //  If we're meant to show ourselves then just show set the key
        if (fShow)
        {
            if (fForce || 
                ((ERROR_SUCCESS != lResult) || IsIgnorableClientProgram(szCurrentClient, ppszIgnoreList)))
            {
                RegSetValue(hKey, NULL, REG_SZ, pszCanonicalName, lstrlen(pszCanonicalName) * sizeof(WCHAR));
            }
        }
        else
        {
            //  If we're meant to disappear then clear the key only if we're the one that is currently set.
            if (fForce || ((ERROR_SUCCESS == lResult) && (0 == StrCmpI(pszCanonicalName, szCurrentClient))))
            {
                RegSetValue(hKey, NULL, REG_SZ, L"", 0);
            }
        }
                
        RegCloseKey(hKey);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error opening client key %s - 0x%08x", pszClientKey, lResult);
    }    
}


BOOL IsInstalled(LPCWSTR pszComponent)
{
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue = sizeof(dwValue);
    DWORD dwResult = SHGetValueW(HKEY_LOCAL_MACHINE, pszComponent, c_szIsInstalled, &dwType, &dwValue, &cbValue);

    BOOL fIsInstalled = ((ERROR_SUCCESS == dwResult) && (REG_DWORD == dwType) && (dwValue));

    return fIsInstalled;
}

void SetBool(LPCWSTR pszKey, LPCWSTR pszValue, BOOL fValue)
{
    HKEY hKey;
    DWORD dwDisposition;

    LONG lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_SET_VALUE, NULL, &hKey, &dwDisposition);

    if (ERROR_SUCCESS == lResult)
    {
        DWORD dwValue = fValue ? TRUE : FALSE;
        
        lResult = RegSetValueEx(hKey, pszValue, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));

        if (ERROR_SUCCESS != lResult)
        {
            TraceMsg(TF_ERROR, "Error setting value %s - 0x%08x", pszValue, lResult);
        }
        RegCloseKey(hKey);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error creating %s key - 0x%08x", pszKey, lResult);
    }
}

//Copy data from HKLM to HKCU
LONG CopyRegValue(LPCWSTR pszSubKey, LPCWSTR pszValue)
{
    HKEY hKeySrc;
    LONG lResult;
    
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszSubKey, 0, KEY_QUERY_VALUE, &hKeySrc);

    if (ERROR_SUCCESS == lResult)
    {
        BYTE buffer[128];
        DWORD dwSize = sizeof(buffer);
        
        lResult = RegQueryValueEx(hKeySrc, pszValue, NULL, NULL, (LPBYTE)buffer, &dwSize);

        RegCloseKey(hKeySrc);

        if (ERROR_SUCCESS == lResult)
        {
            HKEY hKeyDst;

            lResult = RegCreateKeyEx(HKEY_CURRENT_USER, pszSubKey, 0, NULL, 
                                     REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hKeyDst, NULL);

            if (ERROR_SUCCESS == lResult)
            {
                lResult = RegSetValueEx(hKeyDst, pszValue, NULL, REG_SZ, (CONST BYTE *)buffer, dwSize);
            }
            RegCloseKey(hKeyDst);
        }       
    }

    return lResult;
}

void UpdateActiveSetupValues(LPCWSTR pszKeyName, BOOL fInstall)
{
    if (fInstall)
    {
        CopyRegValue(pszKeyName, c_szLocale);
        CopyRegValue(pszKeyName, c_szVersion);
    }
    else
    {
        RegDeleteKey(HKEY_CURRENT_USER, pszKeyName);
    }
}

LONG GetExeAppPathWorker(LPCWSTR pszAppName, LPWSTR pszExePath, UINT cchExePath, LPCWSTR pszFmt)
{
    WCHAR szExeKey[MAX_PATH];
    HKEY hKey;           

    wnsprintf(szExeKey, ARRAYSIZE(szExeKey), pszFmt, pszAppName);
    
    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szExeKey, 0, KEY_QUERY_VALUE, &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        LONG cbExePath = cchExePath * sizeof(WCHAR);

        lResult = RegQueryValue(hKey, NULL, pszExePath, &cbExePath);
        if (ERROR_SUCCESS != lResult)
        {
            TraceMsg(TF_ERROR, "Error querying for app path value - 0x%08x", lResult);
        }

        RegCloseKey(hKey);
    }

    return lResult;
}

LONG GetExeAppPath(LPCWSTR pszAppName, LPWSTR pszExePath, UINT cchExePath)
{
    return GetExeAppPathWorker(pszAppName, pszExePath, cchExePath, L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\%s");
}

#ifdef _WIN64
LONG GetWow32ExeAppPath(LPCWSTR pszAppName, LPWSTR pszExePath, UINT cchExePath)
{
    return GetExeAppPathWorker(pszAppName, pszExePath, cchExePath, L"Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\App Paths\\%s");
}
#endif

void ShowHideFile(LPCWSTR pszFileName, BOOL fShow)
{
    DWORD dwAttrs = GetFileAttributes(pszFileName);
    
    if (fShow)
    {
        dwAttrs &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
    }
    else
    {
        dwAttrs |= FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;
    }
    
    SetFileAttributes(pszFileName, dwAttrs);
}

void ShowHideExe(LPCWSTR pszAppName, BOOL fShow)
{
    WCHAR szExePath[MAX_PATH];
    
    if (ERROR_SUCCESS == GetExeAppPath(pszAppName, szExePath, ARRAYSIZE(szExePath)))
    {
        ShowHideFile(szExePath, fShow);
    }    
}

#ifdef _WIN64
void ShowHideWow32Exe(LPCWSTR pszAppName, BOOL fShow)
{
    WCHAR szExePath[MAX_PATH];
    
    if (ERROR_SUCCESS == GetWow32ExeAppPath(pszAppName, szExePath, ARRAYSIZE(szExePath)))
    {
        ShowHideFile(szExePath, fShow);
    }    
}
#endif

void CreateShortcut(LPCWSTR pszExePath, LPWSTR pszLinkFullFilePath, int idName, int idDescription)
{
    IShellLink *pShellLink;

    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void **)&pShellLink);

    if (SUCCEEDED(hr))
    {
        if (idDescription)
        {
            WCHAR szDescription[MAX_PATH];

            wnsprintf(szDescription, ARRAYSIZE(szDescription), L"@xpsp1res.dll,-%d", idDescription);
            pShellLink->SetDescription(szDescription);
        }

        pShellLink->SetWorkingDirectory(L"%HOMEDRIVE%%HOMEPATH%");

        if (SUCCEEDED(pShellLink->SetPath(pszExePath)))
        {
            IPersistFile *pPersistFile;

            if (SUCCEEDED(pShellLink->QueryInterface(IID_IPersistFile, (void **)&pPersistFile)))
            {
                if (SUCCEEDED(pPersistFile->Save(pszLinkFullFilePath, TRUE)))
                {
                    SHSetLocalizedName(pszLinkFullFilePath, L"xpsp1res.dll", idName);
                }

                pPersistFile->Release();
            }
        }

        pShellLink->Release();
    }
    else
    {
        TraceMsg(TF_ERROR, "Couldn't create shell link object - hr = 0x%08x", hr);
    }
}

void FindAndNukeIcons(LPCWSTR pszLinkPath, LPCWSTR pszLongExePath)
{
    WCHAR szStartDir[MAX_PATH];

    WCHAR szShortExePath[MAX_PATH];
            
    DWORD cch = GetShortPathName(pszLongExePath, szShortExePath, ARRAYSIZE(szShortExePath));

    if (!cch || (cch >= ARRAYSIZE(szShortExePath)))
    {
        szShortExePath[0] = 0;
    }

    if (GetCurrentDirectory(ARRAYSIZE(szStartDir), szStartDir))
    {
        if (SetCurrentDirectory(pszLinkPath))
        {
            WIN32_FIND_DATA fd;
            
            HANDLE hFind = FindFirstFile(L"*.lnk", &fd);

            if (INVALID_HANDLE_VALUE != hFind)
            {
                IShellLink *pShellLink;
                HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void **)&pShellLink);

                if (SUCCEEDED(hr))
                {
                    IPersistFile *pPersistFile;

                    hr = pShellLink->QueryInterface(IID_IPersistFile, (void **)&pPersistFile);

                    if (SUCCEEDED(hr))
                    {
                        do
                        {
                            WCHAR szLinkPath[MAX_PATH];
                            WCHAR szArgs[INTERNET_MAX_PATH_LENGTH];
                                                            
                            if (SUCCEEDED(pPersistFile->Load(fd.cFileName, STGM_READ)) &&
                                SUCCEEDED(pShellLink->GetPath(szLinkPath, ARRAYSIZE(szLinkPath), NULL, 0)) &&
                                ((0 == StrCmpI(pszLongExePath, szLinkPath)) || (0 == StrCmpI(szShortExePath, szLinkPath))) &&
                                SUCCEEDED(pShellLink->GetArguments(szArgs, ARRAYSIZE(szArgs))))
                            {
                                PathRemoveBlanks(szArgs);

                                if (!szArgs[0])
                                {
                                    SetFileAttributes(fd.cFileName, FILE_ATTRIBUTE_NORMAL);
                                    DeleteFile(fd.cFileName);
                                }
                            }
                        }
                        while (FindNextFile(hFind, &fd));

                        pPersistFile->Release();
                    }

                    pShellLink->Release();
                }

                FindClose(hFind);
            }
        }

        SetCurrentDirectory(szStartDir);
    }
}

void ShowShortcut(LPCWSTR pszLinkPath, int lsn, BOOL fShow)
{
    WCHAR szLinkFullFilePath[MAX_PATH];
    WCHAR szLinkFileName[MAX_PATH];

    szLinkFileName[0] = 0;

    //  If we should use the localized name as the filename, then try to get it.
    //  We should use the localized name if the install language is not USEnglish.
    if (LANGIDFROMLCID(GetSystemDefaultUILanguage()) != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
    {
        LoadString(GetResLibInstance(), c_rglsi[lsn].idsLocalized,
                   szLinkFileName, ARRAYSIZE(szLinkFileName));
    }

    //  If we couldn't (or shouldn't) get the localized name, then
    //  use the USEnglish name instead.
    if (!szLinkFileName[0])
    {
        lstrcpyn(szLinkFileName, c_rglsi[lsn].pszUSEnglish, ARRAYSIZE(szLinkFileName));
    }
    PathAddExtension(szLinkFileName, L".lnk");
    PathCombine(szLinkFullFilePath, pszLinkPath, szLinkFileName);

    WCHAR szExePath[MAX_PATH];
    LONG lResult;

#ifdef _WIN64
    if (lsn == LSN_SM_IE32)
    {
        StrCpyN(szExePath, g_szIE32Path, ARRAYSIZE(szExePath));
        lResult = ERROR_SUCCESS;
    }
    else
#endif
    {
        lResult = GetExeAppPath(c_rglsi[lsn].pszExe, szExePath, ARRAYSIZE(szExePath));
    }

    if (ERROR_SUCCESS == lResult)
    {
        if (fShow)
        {
            if (!c_rglsi[lsn].fNeverShowShortcut)
            {
                CreateShortcut(szExePath, szLinkFullFilePath, c_rglsi[lsn].idsLocalized, c_rglsi[lsn].idsDescription);
            }
        }
        else
        {
            FindAndNukeIcons(pszLinkPath, szExePath);
        }
    }
}

LONG QueryExplorerCLSIDFlags(LPCWSTR pszCLSID, DWORD *pdwFlags)
{
    WCHAR szKeyComponent[MAX_PATH];

    wnsprintf(szKeyComponent, ARRAYSIZE(szKeyComponent), c_szKeyComponentFormat, pszCLSID);

    DWORD dwSize = sizeof(*pdwFlags);

    return SHGetValueW(HKEY_CURRENT_USER, szKeyComponent, c_szAttribute, NULL, pdwFlags, &dwSize);
}

void SetExplorerCLSIDFlags(LPCWSTR pszCLSID, DWORD dwAndFlags, DWORD dwOrFlags)
{
    DWORD dwFlags = 0;
    WCHAR szKeyComponent[MAX_PATH];

    wnsprintf(szKeyComponent, ARRAYSIZE(szKeyComponent), c_szKeyComponentFormat, pszCLSID);

    DWORD dwSize = sizeof(dwFlags);

    SHGetValueW(HKEY_CURRENT_USER, szKeyComponent, c_szAttribute, NULL, &dwFlags, &dwSize);

    dwFlags &= dwAndFlags;
    dwFlags |= dwOrFlags;

    SHSetValue(HKEY_CURRENT_USER, szKeyComponent, c_szAttribute, REG_DWORD, &dwFlags, sizeof(dwFlags));
}

void NukeFiles(LPCWSTR pszPath, LPCWSTR pszFileSpec)
{
    WCHAR szStartDir[MAX_PATH];
    
    if (GetCurrentDirectory(ARRAYSIZE(szStartDir), szStartDir))
    {
        if (SetCurrentDirectory(pszPath))
        {
            WIN32_FIND_DATA fd;
            
            HANDLE hFind = FindFirstFile(pszFileSpec, &fd);

            if (INVALID_HANDLE_VALUE != hFind)
            {
                do
                {
                    SetFileAttributes(fd.cFileName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(fd.cFileName);
                }
                while (FindNextFile(hFind, &fd));

                FindClose(hFind);
            }
        }

        SetCurrentDirectory(szStartDir);
    }
}

void NukeDesktopCleanupIcons()
{
    WCHAR szPath[MAX_PATH];
    HINSTANCE hInstCleaner = LoadLibraryEx(L"fldrclnr.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    WCHAR szUnusedShortcutFolder[MAX_PATH];

//  From nt\shell\applets\cleanup\fldrclnr\resource.h:
#define IDS_ARCHIVEFOLDER               8
#define IDS_ARCHIVEFOLDER_FIRSTBOOT     15

//  From nt\shell\applets\cleanup\fldrclnr\cleanupwiz.h:
#define REGSTR_OEM_PATH                   REGSTR_PATH_SETUP TEXT("\\OemStartMenuData")
#define REGSTR_OEM_TITLEVAL               TEXT("DesktopShortcutsFolderName")
    
    if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, FALSE))
    {
        NukeFiles(szPath, L"*.{871C5380-42A0-1069-A2EA-08002B30309D}");

        if (hInstCleaner && 
            LoadString(hInstCleaner, IDS_ARCHIVEFOLDER, szUnusedShortcutFolder, ARRAYSIZE(szUnusedShortcutFolder)))
        {
            PathAppend(szPath, szUnusedShortcutFolder);
            NukeFiles(szPath, L"*.{871C5380-42A0-1069-A2EA-08002B30309D}");
        }
    }

    DWORD cb = sizeof(szUnusedShortcutFolder);
    DWORD dwType;

    //  Get the folder name from either the registry or fldrclnr.dll and get the startmenu\programs folder
    if (
        (
         (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_OEM_PATH, REGSTR_OEM_TITLEVAL, &dwType, szUnusedShortcutFolder, &cb))
         ||
         (hInstCleaner && LoadString(hInstCleaner, IDS_ARCHIVEFOLDER_FIRSTBOOT, szUnusedShortcutFolder, ARRAYSIZE(szUnusedShortcutFolder)))
        )
        &&
        SHGetSpecialFolderPath(NULL, szPath, CSIDL_PROGRAMS, FALSE)
       )
    {
        PathAppend(szPath, szUnusedShortcutFolder);
        NukeFiles(szPath, L"*.{871C5380-42A0-1069-A2EA-08002B30309D}");
    }

    if (hInstCleaner)
    {
        FreeLibrary(hInstCleaner);
    }
}

void RemoveIcons(int lsn, int *pcsidlList, DWORD nEntries)
{
    for (DWORD i = 0; i < nEntries; i++)
    {
        WCHAR szPath[MAX_PATH];

        if (SHGetSpecialFolderPath(NULL, szPath, pcsidlList[i], FALSE))
        {
            ShowShortcut(szPath, lsn, FALSE);
        }
    }
}

void RemoveAnAnnoyingIESubFolderIcon(int csidl)
{
    WCHAR szPath[MAX_PATH];

    if (SHGetSpecialFolderPath(NULL, szPath, csidl, FALSE))
    {
        WCHAR szIEFolder[MAX_PATH];

        PathCombine(szIEFolder, szPath, L"Internet Explorer");
        ShowShortcut(szIEFolder, LSN_NOSHOW_IE, FALSE);

        WCHAR szLocalizedName[MAX_PATH];

        LoadString(GetResLibInstance(), IDS_OC_IESHORTCUTNAME_SM, szLocalizedName, ARRAYSIZE(szLocalizedName));
        PathRemoveExtension(szLocalizedName);
        PathCombine(szIEFolder, szPath, szLocalizedName);
        ShowShortcut(szIEFolder, LSN_NOSHOW_IE, FALSE);
        
        LoadString(GetResLibInstance(), IDS_OC_IESHORTCUTNAME_QL, szLocalizedName, ARRAYSIZE(szLocalizedName));
        PathRemoveExtension(szLocalizedName);
        PathCombine(szIEFolder, szPath, szLocalizedName);
        ShowShortcut(szIEFolder, LSN_NOSHOW_IE, FALSE);
    }
}

void RemoveAnnoyingIESubFolderIcons()
{
    RemoveAnAnnoyingIESubFolderIcon(CSIDL_PROGRAMS);
    RemoveAnAnnoyingIESubFolderIcon(CSIDL_COMMON_PROGRAMS);
}

void ShowIEDesktopIcon(BOOL fShow)
{
    if (fShow)
    {
        SetExplorerCLSIDFlags(c_szIEDesktopCLSID, ~SFGAO_NONENUMERATED, 0);
    }
    else
    {
        NukeDesktopCleanupIcons();
        SetExplorerCLSIDFlags(c_szIEDesktopCLSID, 0xffffffff, SFGAO_NONENUMERATED);
    }
    
    SendChangeNotification(CSIDL_DESKTOP);
    SendChangeNotification(CSIDL_DESKTOPDIRECTORY);
}

//  Ensure a handler is in place for all the important things
void FixupIEAssociations(BOOL fForceAssociations)
{
    // In order for shdocvw to do its magic, IEXPLORE.EXE must be properly
    // registered.  Setup runs OC Manager before it runs IE.INF, so don't
    // call shdocvw to try to do something he can't do.  (He'll assert if
    // you try.)
    HKEY hk;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"),
                     0, KEY_READ, &hk) != ERROR_SUCCESS)
    {
        // ie.inf hasn't run yet - shdocvw can't do its thing
        return;
    }
    RegCloseKey(hk);

    //  Shdocvw does a pretty good job of this, let's give him a crack at it
    HINSTANCE hinst = LoadLibrary(L"shdocvw.dll");

    if (NULL != hinst)
    {
        typedef HRESULT (WINAPI *DLLINSTALL)(BOOL bInstall, LPCWSTR pszCmdLine);

        DLLINSTALL pfnDllInstall = (DLLINSTALL)GetProcAddress(hinst, "DllInstall");

        if (pfnDllInstall)
        {
            pfnDllInstall(TRUE, (fForceAssociations ? L"ForceAssoc" : L""));
        }
        else
        {
            TraceMsg(TF_ERROR, "Error getting DllInstall entry point - GLE = 0x%08x", GetLastError());
        }

        FreeLibrary(hinst);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error loading shdocvw - GLE = 0x%08x", GetLastError());
    }
}
    
//  This will create or delete shortcuts in Start Menu\Programs and the Quick Launch bar
void ShowUserShortcuts(int lsnSM, int lsnQL, BOOL fShow)
{
    WCHAR szPath[MAX_PATH];
    
    if (lsnSM >= 0 && SHGetSpecialFolderPath(NULL, szPath, CSIDL_PROGRAMS, fShow))
    {
        ShowShortcut(szPath, lsnSM, fShow);
    }

    if (lsnQL >= 0 && SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, fShow))
    {
        WCHAR szQuickLaunchPath[MAX_PATH];

        LoadString(GetResLibInstance(), IDS_OC_QLAUNCHAPPDATAPATH, szQuickLaunchPath, ARRAYSIZE(szQuickLaunchPath));

        PathAppend(szPath, szQuickLaunchPath);

        //  In case we're the first ones through, create the Quick Launch dir
        CreateDirectory(szPath, NULL);
        
        ShowShortcut(szPath, lsnQL, fShow);
    }
}

//  Internet Explorer optional component goo
void UserConfigIE()
{
    BOOL fIsInstalled = IsInstalled(c_szIEAccessKey);

    ShowIEDesktopIcon(fIsInstalled);

    ShowUserShortcuts(LSN_SM_IE, LSN_QL_IE, fIsInstalled);

#ifdef _WIN64
    WCHAR szLinkDir[MAX_PATH];

    if (SHGetSpecialFolderPath(NULL, szLinkDir, CSIDL_PROGRAMS, fIsInstalled))
    {
        WCHAR szExePath[MAX_PATH];

        if (SHGetSpecialFolderPath(NULL, szExePath, CSIDL_PROGRAM_FILESX86, FALSE))
        {
            PathCombine(g_szIE32Path, szExePath, L"Internet Explorer\\iexplore.exe");
            ShowShortcut(szLinkDir, LSN_SM_IE32, fIsInstalled);
        }
    }
#endif

    if (!fIsInstalled)
    {
        int csidlList[] = { CSIDL_DESKTOPDIRECTORY, CSIDL_COMMON_DESKTOPDIRECTORY, CSIDL_COMMON_PROGRAMS };

        RemoveIcons(LSN_NOSHOW_IE, csidlList, ARRAYSIZE(csidlList));
        
        RemoveAnnoyingIESubFolderIcons();
    }

    SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)L"Software\\Clients\\StartMenuInternet");
}

void SetIEShowHideFlags(BOOL fShow)
{
    SetBool(c_szIEAccessKey, c_szIsInstalled, fShow);
    SetBool(c_szIEInstallInfoKey, c_szIconsVisible, fShow);
    SetBool(c_szOCManagerSubComponents, c_szIEAccess, fShow);
}

void ShowHideIE(BOOL fShow, BOOL fForceAssociations, BOOL fNonUpdateInstall)
{   
    SetIEShowHideFlags(fShow);

    if (fShow)
    {
        if (fNonUpdateInstall)
        {
            FixupIEAssociations(fForceAssociations);
        }

        SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szStartMenuInternetClientKey, c_szIECanonicalName, NULL, TRUE, fForceAssociations);
    }
    else
    {
        SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szStartMenuInternetClientKey, c_szIECanonicalName, NULL, FALSE, FALSE);

        int csidlList[] = { CSIDL_COMMON_DESKTOPDIRECTORY, CSIDL_COMMON_PROGRAMS };

        RemoveIcons(LSN_NOSHOW_IE, csidlList, ARRAYSIZE(csidlList));
        RemoveAnAnnoyingIESubFolderIcon(CSIDL_COMMON_PROGRAMS);
    }

    if (fNonUpdateInstall && !IsNtSetupRunning())
    {
        SetDefaultClientProgram(HKEY_CURRENT_USER, c_szStartMenuInternetClientKey, c_szIECanonicalName, NULL, FALSE, fShow);
        UserConfigIE();
        UpdateActiveSetupValues(c_szIEAccessKey, fShow);

        SendChangeNotification(CSIDL_DESKTOP);
    }
    else
    {
        SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)L"Software\\Clients\\StartMenuInternet");
    }

    ShowHideExe(c_szIEApp, fShow);
    
#ifdef _WIN64
    ShowHideWow32Exe(c_szIEApp, fShow);
#endif
}

//  Outlook Express optional component goo

void UserConfigOE()
{
    BOOL fIsInstalled = IsInstalled(c_szOEAccessKey);

    ShowUserShortcuts(LSN_SM_OE, LSN_QL_OE, fIsInstalled);

    SHSendMessageBroadcastW(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_MAILCLIENTS);

    if (!fIsInstalled)
    {
        //  ShowUserShortcuts(fInstalled=FALSE) already cleaned up any
        // old OE Quick Launch shortcuts, so all that's left to remove
        // is the desktop icon

        int csidlList[] = { CSIDL_DESKTOPDIRECTORY, CSIDL_COMMON_DESKTOPDIRECTORY, CSIDL_COMMON_PROGRAMS };

        RemoveIcons(LSN_NOSHOW_OE, csidlList, ARRAYSIZE(csidlList));
    }
}

void SetOEShowHideFlags(BOOL fShow)
{
    SetBool(c_szOEAccessKey, c_szIsInstalled, fShow);
    SetBool(c_szOEInstallInfoKey, c_szIconsVisible, fShow);
    SetBool(c_szOCManagerSubComponents, c_szOEAccess, fShow);
}

void FixupOEAssociations(BOOL fForceAssociations, LPCWSTR *ppszIgnoreList)
{
    if (!IsNtSetupRunning())
    {
        long lResult;
        
        if (!fForceAssociations)
        {
            WCHAR szValue[MAX_PATH];
            DWORD cbValue = sizeof(szValue);
            DWORD dwType;

            lResult = SHGetValueW(HKEY_CLASSES_ROOT, L"mailto\\shell\\open\\command", NULL, &dwType, szValue, &cbValue);

            if ((REG_SZ == dwType) &&
                ((ERROR_MORE_DATA == lResult) || ((ERROR_SUCCESS == lResult) && (cbValue >= (2 * sizeof(WCHAR))))))
            {
                //   Some sort of valid string data at least character in length -- see if it's one we should stomp,
                //   otherwise leave it alone

                if (NULL != ppszIgnoreList)
                {
                    while (NULL != *ppszIgnoreList)
                    {
                        if (NULL != StrStrIW(szValue, *ppszIgnoreList))
                        {
                            fForceAssociations = TRUE;
                            break;
                        }
                        ppszIgnoreList++;
                    }
                }
            }
            else
            {
                //  Either it's not a string or it's zero length
                fForceAssociations = TRUE;
            }
        }

        if (fForceAssociations)
        {
            HKEY hkey;
            DWORD dwDisposition;

            SHDeleteKey(HKEY_CLASSES_ROOT, L"mailto");
            
            lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT, L"mailto", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, 
                                          NULL, &hkey, &dwDisposition);

            if (ERROR_SUCCESS == lResult)
            {
                SHCopyKey(HKEY_LOCAL_MACHINE, L"Software\\Clients\\Mail\\Outlook Express\\Protocols\\mailto", hkey, 0);
                RegCloseKey(hkey);
            }
        }
    }
}

void ShowHideOE(BOOL fShow, BOOL fForceAssociations, BOOL fNonUpdateInstall)
{
    if (!IsServer())
    {
        static LPCWSTR ppszIgnoreClientsNormal[] = { c_szIMN, c_szNTOS, NULL };
        static LPCWSTR ppszIgnoreClientsSetup[] = { c_szIMN, c_szNTOS, c_szHotmail, NULL };
        LPCWSTR *ppszIgnoreClients = !IsNtSetupRunning() ? ppszIgnoreClientsNormal : ppszIgnoreClientsSetup;

        static LPCWSTR ppszIgnoreMailto[] = { c_szUrlDll, c_szMailNewsDll, NULL };
        
        SetOEShowHideFlags(fShow);

        if (fShow)
        {
            FixupOEAssociations(fForceAssociations, ppszIgnoreMailto);
            
            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szMailClientKey, c_szOECanonicalName, ppszIgnoreClients, TRUE, fForceAssociations);
#ifdef _WIN64
            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szMailClientKeyWOW32, c_szOECanonicalName, ppszIgnoreClients, TRUE, fForceAssociations);
#endif
        }
        else
        {
            FixupOEAssociations(FALSE, ppszIgnoreMailto);

            int csidlList[] = { CSIDL_COMMON_DESKTOPDIRECTORY, CSIDL_COMMON_PROGRAMS };

            RemoveIcons(LSN_NOSHOW_OE, csidlList, ARRAYSIZE(csidlList));
            
            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szMailClientKey, c_szOECanonicalName, ppszIgnoreClients, FALSE, FALSE);
#ifdef _WIN64
            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szMailClientKeyWOW32, c_szOECanonicalName, ppszIgnoreClients, FALSE, FALSE);
#endif
        }
        
        if (fNonUpdateInstall && !IsNtSetupRunning())
        {
            SetDefaultClientProgram(HKEY_CURRENT_USER, c_szMailClientKey, c_szOECanonicalName, ppszIgnoreClients, FALSE, fShow);
            UserConfigOE();
            UpdateActiveSetupValues(c_szOEAccessKey, fShow);

            SendChangeNotification(CSIDL_DESKTOP);
        }
        else
        {
            SHSendMessageBroadcastW(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_MAILCLIENTS);
        }
    }

    ShowHideExe(c_szOEApp, fShow);

#ifdef _WIN64
    ShowHideWow32Exe(c_szOEApp, fShow);
#endif
}

HRESULT CallRegisterServer(LPCWSTR pszModule, BOOL fRegister)
{
    HRESULT hr;
    
    HINSTANCE hinst = LoadLibrary(pszModule);

    if (NULL != hinst)
    {
        typedef HRESULT (WINAPI *DLLREGISTERSERVER)();
        LPCSTR pszRegFuncName = fRegister ? "DllRegisterServer" : "DllUnregisterServer";

        DLLREGISTERSERVER pfnDllRegisterServer = (DLLREGISTERSERVER)GetProcAddress(hinst, pszRegFuncName);

        if (pfnDllRegisterServer)
        {
            hr = pfnDllRegisterServer();
        }
        else
        {
            TraceMsg(TF_ERROR, "Error getting DllRegisterServer entry point - GLE = 0x%08x", GetLastError());
            hr = FailedHresultFromWin32();
        }

        FreeLibrary(hinst);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error loading %s - GLE = 0x%08x", pszModule, GetLastError());
        hr = FailedHresultFromWin32();
    }

    return hr;
}

void ReinstallVM()
{
#if 0
    SHDeleteKey(HKEY_CLASSES_ROOT, c_szJavaVMKey);

    CallRegisterServer(L"msjava.dll", TRUE);
#endif
}

void FixupMailClientKey()
{
    SHSetValueW(HKEY_LOCAL_MACHINE, c_szOEInstallInfoKey, c_szReinstallCommand, REG_EXPAND_SZ, c_szReinstallCommandOE, sizeof(c_szReinstallCommandOE));
    SHSetValueW(HKEY_LOCAL_MACHINE, c_szOEInstallInfoKey, c_szHideIconsCommand, REG_EXPAND_SZ, c_szHideIconsCommandOE, sizeof(c_szHideIconsCommandOE));
    SHSetValueW(HKEY_LOCAL_MACHINE, c_szOEInstallInfoKey, c_szShowIconsCommand, REG_EXPAND_SZ, c_szShowIconsCommandOE, sizeof(c_szShowIconsCommandOE));
    SetBool(c_szOEInstallInfoKey, c_szIconsVisible, IsInstalled(c_szOEAccessKey));
}

extern "C" void FixupOptionalComponents()
{
    //  Need to do this here since the app paths weren't set during setup.
    ShowHideExe(c_szIEApp, IsInstalled(c_szIEAccessKey));
    ShowHideExe(c_szOEApp, IsInstalled(c_szOEAccessKey));

#ifdef _WIN64
    ShowHideWow32Exe(c_szIEApp, IsInstalled(c_szIEAccessKey));
    ShowHideWow32Exe(c_szOEApp, IsInstalled(c_szOEAccessKey));
#endif

    //  OE likes to nuke the whole branch and start from scratch.
    FixupMailClientKey();
}

#define FC_QUICKLAUNCH          0x00000001
#define FC_ALLPROGRAMS          0x00000002
#define FC_DESKTOP              0x00000004
#define FC_EXPLORERCLSID        0x00000008
#define FC_MAX                  0x00000008

struct SHORTCUTFINDENTRY
{
    LPCTSTR     pszExe;
    LPCTSTR     pszExplorerCLSID;
    DWORD       dwFoldersToCheck;
    DWORD       dwFoldersToRecurseCheck;
};

SHORTCUTFINDENTRY scfEntries[] =
{
    { c_szIEApp, c_szIEDesktopCLSID, FC_QUICKLAUNCH | FC_ALLPROGRAMS | FC_EXPLORERCLSID, 0 },
    { c_szOEApp, NULL, FC_QUICKLAUNCH | FC_ALLPROGRAMS, 0 },
    { c_szWMP, NULL, FC_QUICKLAUNCH | FC_ALLPROGRAMS, FC_ALLPROGRAMS },
    { c_szMessenger, NULL, FC_QUICKLAUNCH | FC_ALLPROGRAMS, FC_ALLPROGRAMS },
};

HRESULT FindAnyIcons(LPCWSTR pszLinkPath, LPCWSTR pszLongExePath, BOOL fRecurse, BOOL *pfFound)
{
    //  Pretty straightforward here.  Loop through all the .lnk files in a directory and see if we
    //  find a shortcut pointing to the EXE in question.  This function will also recurse if asked.

    WCHAR szStartDir[MAX_PATH];
    HRESULT hr = E_FAIL;

    *pfFound = FALSE;

    WCHAR szShortExePath[MAX_PATH];
    
    DWORD cch = GetShortPathName(pszLongExePath, szShortExePath, ARRAYSIZE(szShortExePath));

    if (!cch || (cch >= ARRAYSIZE(szShortExePath)))
    {
        szShortExePath[0] = 0;
    }

    if (GetCurrentDirectory(ARRAYSIZE(szStartDir), szStartDir))
    {
        if (SetCurrentDirectory(pszLinkPath))
        {
            WIN32_FIND_DATA fd;
            
            HANDLE hFind = FindFirstFile(fRecurse ? L"*" : L"*.lnk", &fd);

            if (INVALID_HANDLE_VALUE != hFind)
            {
                IShellLink *pShellLink;
                hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void **)&pShellLink);

                if (SUCCEEDED(hr))
                {
                    IPersistFile *pPersistFile;

                    hr = pShellLink->QueryInterface(IID_IPersistFile, (void **)&pPersistFile);

                    if (SUCCEEDED(hr))
                    {
                        do
                        {
                            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                            {
                                if ((0 != StrCmpI(fd.cFileName, L".")) && (0 != StrCmpI(fd.cFileName, L"..")) && fRecurse)
                                {
                                    hr = FindAnyIcons(fd.cFileName, pszLongExePath, fRecurse, pfFound);
                                }
                            }
                            else if (0 == StrCmpIC(PathFindExtension(fd.cFileName), L".lnk"))
                            {
                                WCHAR szLinkPath[MAX_PATH];
                                                                
                                if (SUCCEEDED(pPersistFile->Load(fd.cFileName, STGM_READ)) &&
                                    SUCCEEDED(pShellLink->GetPath(szLinkPath, ARRAYSIZE(szLinkPath), NULL, 0)) &&
                                    ((0 == StrCmpI(pszLongExePath, szLinkPath)) || (0 == StrCmpI(szShortExePath, szLinkPath))))
                                {
                                    *pfFound = TRUE;
                                }
                            }
                        }
                        while (SUCCEEDED(hr) && (FALSE == *pfFound) && FindNextFile(hFind, &fd));

                        pPersistFile->Release();
                    }

                    pShellLink->Release();
                }

                FindClose(hFind);
            }
        }

        SetCurrentDirectory(szStartDir);
    }

    return hr;
}

void GetCurrentIconInvisibility()
{
    //  Loop through our list of "interesting" .EXEs.  For each one, look in "interesting" places to see if
    //  the shortcut is NOT present.  If the shortcut is missing, then presumably the user did this on purpose.
    //  The problem is that a bunch of per-user install stubs will get rerun after an SP and recreate the 
    //  shortcuts.  This is a no-no.
    for (int i = 0; i < ARRAYSIZE(scfEntries); i++)
    {
        WCHAR szExePath[MAX_PATH];
        
        if (ERROR_SUCCESS == GetExeAppPath(scfEntries[i].pszExe, szExePath, ARRAYSIZE(szExePath)))
        {
            DWORD dwInitiallyClear = 0;

            //  Loop through each of the bits, look to see if the icon is NOT there.  If it's not there, then
            //  we'll set that bit in dwInitiallyClear.
            //
            //  Note that we err on the side of leaving the bit unset so in failure cases we may allow an icon 
            //  to be recreated -- this is generally a better approach since most of the time the icons will
            //  not be deleted.
            
            for (DWORD dwFolderClass = FC_QUICKLAUNCH; dwFolderClass <= FC_MAX; dwFolderClass <<= 1)
            {
                if (dwFolderClass & scfEntries[i].dwFoldersToCheck)
                {
                    if (FC_EXPLORERCLSID != dwFolderClass)
                    {           
                        HRESULT hr = E_FAIL;
                        WCHAR szPath[MAX_PATH];
                        
                        switch (dwFolderClass)
                        {
                            case FC_QUICKLAUNCH:
                                if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, FALSE))
                                {
                                    WCHAR szQuickLaunchPath[MAX_PATH];

                                    LoadString(GetResLibInstance(), IDS_OC_QLAUNCHAPPDATAPATH, szQuickLaunchPath, ARRAYSIZE(szQuickLaunchPath));
                                    PathAppend(szPath, szQuickLaunchPath);
                                    hr = S_OK;
                                }
                                break;
                                
                            case FC_ALLPROGRAMS:
                                hr = SHGetSpecialFolderPath(NULL, szPath, CSIDL_PROGRAMS, FALSE) ? S_OK : E_FAIL;
                                break;
                                
                            case FC_DESKTOP:
                                hr = SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, FALSE) ? S_OK : E_FAIL;
                                break;

                            default:
                                hr = E_UNEXPECTED;
                                break;
                        }

                        if (SUCCEEDED(hr))
                        {
                            BOOL fFound;
                            hr = FindAnyIcons(szPath, szExePath, 
                                    dwFolderClass & scfEntries[i].dwFoldersToRecurseCheck, &fFound);

                            if (SUCCEEDED(hr) && !fFound)
                            {
                                dwInitiallyClear |= dwFolderClass;
                            }
                        }
                    }
                    else
                    {
                        //  This will only work for the currently logged in user...
                        DWORD dwFlags;

                        ASSERT(NULL != scfEntries[i].pszExplorerCLSID);

                        if (ERROR_SUCCESS == QueryExplorerCLSIDFlags(scfEntries[i].pszExplorerCLSID, &dwFlags))
                        {
                            if (dwFlags & SFGAO_NONENUMERATED)
                            {
                                dwInitiallyClear |= FC_EXPLORERCLSID;
                            }
                        }                        
                    }
                }
            }

            //  Only record a value for this app if there is a shortcut missing...
            if (dwInitiallyClear)
            {
                SHSetValue(HKEY_CURRENT_USER, c_szInitiallyClearKey, scfEntries[i].pszExe, REG_DWORD, &dwInitiallyClear, sizeof(dwInitiallyClear));
            }
        }
    }
}

extern "C" void OCInstallUpdate()
{
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue = sizeof(dwValue);
    DWORD dwResult = SHGetValueW(HKEY_LOCAL_MACHINE, c_szOCManagerSubComponents, c_szIEAccess, &dwType, &dwValue, &cbValue);

    BOOL fIEAccessIsOn = ((ERROR_SUCCESS == dwResult) && (REG_DWORD == dwType) && (dwValue));
   
    ShowHideIE(fIEAccessIsOn, FALSE, FALSE);

    //  If IE is on, then we go ahead and write the active setup values in case the IE version is not updated as well.
    //  This way we don't recreate icons for this user when there is no change to IE.
    if (fIEAccessIsOn)
    {
        UpdateActiveSetupValues(c_szIEAccessKey, TRUE);
    }

    cbValue = sizeof(dwValue);
    dwResult = SHGetValueW(HKEY_LOCAL_MACHINE, c_szOCManagerSubComponents, c_szOEAccess, &dwType, &dwValue, &cbValue);

    BOOL fOEAccessIsOn = TRUE;

    if ((ERROR_SUCCESS == dwResult) && (REG_DWORD == dwType) && !dwValue)
    {
        fOEAccessIsOn = FALSE;
    }
    ShowHideOE(fOEAccessIsOn, FALSE, FALSE);

    //  If OE is on, then we go ahead and write the active setup values in case the OE version is not updated as well.
    //  This way we don't recreate icons for this user when there is no change to OE.
    if (fOEAccessIsOn)
    {
        UpdateActiveSetupValues(c_szOEAccessKey, TRUE);
    }

    GetCurrentIconInvisibility();
}

extern "C" void OCInstallCleanupInitiallyClear()
{
    HKEY hKey;

    //  This code runs through and sees if we need to delete any shortcuts that were created by an SP update install
    //  that the user had previously deleted.  The idea is that we shouldn't be recreating them.   
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szInitiallyClearKey, 0, KEY_QUERY_VALUE, &hKey))
    {
        int nRegEnum = 0;
        
        while (1)
        {
            WCHAR szExe[MAX_PATH];
            DWORD cchExe = ARRAYSIZE(szExe);
            DWORD dwType;
            DWORD dwFlags;
            DWORD cbFlags = sizeof(dwFlags);

            LONG lResult = RegEnumValue(hKey, nRegEnum, szExe, &cchExe, NULL, &dwType, (LPBYTE)&dwFlags, &cbFlags);

            if (ERROR_NO_MORE_ITEMS == lResult)
            {
                break;
            }
            else if ((ERROR_SUCCESS == lResult) && (REG_DWORD == dwType))
            {
                WCHAR szExePath[MAX_PATH];
        
                if (ERROR_SUCCESS == GetExeAppPath(szExe, szExePath, ARRAYSIZE(szExePath)))
                {
                    //  Once we have the EXE, loop through each bit and see if it was initially clear (meaning
                    //  the shorcut was not present before update ran).
                    
                    for (DWORD dwFolderClass = FC_QUICKLAUNCH; dwFolderClass <= FC_MAX; dwFolderClass <<= 1)
                    {
                        if (dwFlags & dwFolderClass)
                        {
                            if (FC_EXPLORERCLSID != dwFolderClass)
                            {
                                HRESULT hr = E_FAIL;
                                WCHAR szPath[MAX_PATH];
                        
                                switch (dwFolderClass)
                                {
                                    case FC_QUICKLAUNCH:
                                        if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, FALSE))
                                        {
                                            WCHAR szQuickLaunchPath[MAX_PATH];

                                            LoadString(GetResLibInstance(), IDS_OC_QLAUNCHAPPDATAPATH, szQuickLaunchPath, ARRAYSIZE(szQuickLaunchPath));
                                            PathAppend(szPath, szQuickLaunchPath);
                                            hr = S_OK;
                                        }
                                        break;
                                        
                                    case FC_ALLPROGRAMS:
                                        hr = SHGetSpecialFolderPath(NULL, szPath, CSIDL_PROGRAMS, FALSE) ? S_OK : E_FAIL;
                                        break;
                                        
                                    case FC_DESKTOP:
                                        hr = SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, FALSE) ? S_OK : E_FAIL;
                                        break;

                                    default:
                                        hr = E_UNEXPECTED;
                                        break;
                                }

                                if (SUCCEEDED(hr))
                                {
                                    FindAndNukeIcons(szPath, szExePath);
                                }
                            }
                            else
                            {
                                //  need to grovel for the CLSID in this case.
                                for (int i = 0; i < ARRAYSIZE(scfEntries); i++)
                                {
                                    if (0 == StrCmpI(szExe, scfEntries[i].pszExe))
                                    {
                                        SetExplorerCLSIDFlags(scfEntries[i].pszExplorerCLSID, 0xffffffff, SFGAO_NONENUMERATED);
                                        break;
                                    }
                                }
                            }       
                        }
                    }
                }
            }
            
            nRegEnum++;
        }
                
        RegCloseKey(hKey);
    }

    //  This makes sure that we only get called once.
    SHDeleteKey(HKEY_CURRENT_USER, c_szInitiallyClearKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\migrate\profile.c ===
//*************************************************************
//  File name: profile.c
//
//  Description:   Fixes hard coded paths in the registry for
//                 special folder locations.  Also fixes security
//                 on a few registry keys.
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <xpsp1res.h>
#include <userenv.h>
#include <userenvp.h>
#include <tchar.h>
#include "shmgdefs.h"


//*************************************************************
//
//  ApplySecurityToRegistryTree()
//
//  Purpose:    Applies the passed security descriptor to the passed
//              key and all its descendants.  Only the parts of
//              the descriptor inddicated in the security
//              info value are actually applied to each registry key.
//
//  Parameters: RootKey   -     Registry key
//              pSD       -     Security Descriptor
//
//  Return:     ERROR_SUCCESS if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/19/95     ericflo    Created
//              6/16/96     bobday     Stolen directly from USERENV
//
//*************************************************************

DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD)

{
    DWORD Error;
    DWORD SubKeyIndex;
    LPTSTR SubKeyName;
    HKEY SubKey;
    DWORD cchSubKeySize = MAX_PATH + 1;



    //
    // First apply security
    //

    Error = RegSetKeySecurity(RootKey, DACL_SECURITY_INFORMATION, pSD);

    if (Error != ERROR_SUCCESS) {
        return Error;
    }


    //
    // Open each sub-key and apply security to its sub-tree
    //

    SubKeyIndex = 0;

    SubKeyName = GlobalAlloc (GPTR, cchSubKeySize * sizeof(TCHAR));

    if (!SubKeyName) {
        return GetLastError();
    }

    while (TRUE) {

        //
        // Get the next sub-key name
        //

        Error = RegEnumKey(RootKey, SubKeyIndex, SubKeyName, cchSubKeySize);


        if (Error != ERROR_SUCCESS) {

            if (Error == ERROR_NO_MORE_ITEMS) {

                //
                // Successful end of enumeration
                //

                Error = ERROR_SUCCESS;

            } else {

            }

            break;
        }


        //
        // Open the sub-key
        //

        Error = RegOpenKeyEx(RootKey,
                             SubKeyName,
                             0,
                             WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                             &SubKey);

        if (Error != ERROR_SUCCESS) {
            break;
        }

        //
        // Apply security to the sub-tree
        //

        Error = ApplySecurityToRegistryTree(SubKey, pSD);


        //
        // We're finished with the sub-key
        //

        RegCloseKey(SubKey);

        //
        // See if we set the security on the sub-tree successfully.
        //

        if (Error != ERROR_SUCCESS) {
            break;
        }

        //
        // Go enumerate the next sub-key
        //

        SubKeyIndex ++;
    }


    GlobalFree (SubKeyName);

    return Error;

}

//*************************************************************
//
//  MakeKeyOrTreeSecure()
//
//  Purpose:    Sets the attributes on the registry key and possibly sub-keys
//              such that Administrators and the OS can delete it and Everyone
//              else has read permission only (OR general read/write access)
//
//  Parameters: RootKey -   Key to set security on
//              fWrite  -   Allow write (or just read)
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/6/95     ericflo    Created
//              06/16/96    bobday     Ported from MakeFileSecure in USERENV
//
//*************************************************************

BOOL MakeKeyOrTreeSecure (HKEY RootKey, BOOL fWrite)
{
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWorld = SECURITY_WORLD_SID_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidEveryone = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    DWORD Error;
    DWORD dwAccess;



    if (fWrite) {
        dwAccess = KEY_ALL_ACCESS;
    } else {
        dwAccess = KEY_READ;
    }

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         goto Exit;
    }


    //
    // Get the World sid
    //

    if (!AllocateAndInitializeSid(&authWorld, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryone)) {

         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (3 * GetLengthSid (psidSystem)) +
            (3 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        goto Exit;
    }



    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, dwAccess, psidEveryone)) {
        goto Exit;
    }



    //
    // Now the inheritable ACEs
    //
    if (fWrite) {
        dwAccess = GENERIC_ALL;
    } else {
        dwAccess = GENERIC_READ;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, dwAccess, psidEveryone)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        goto Exit;
    }


    //
    // Set the security
    //
    Error = ApplySecurityToRegistryTree(RootKey, &sd);

    if (Error == ERROR_SUCCESS) {
        bRetVal = TRUE;
    }


Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }


    if (psidEveryone) {
        FreeSid(psidEveryone);
    }


    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}

void FixWindowsProfileSecurity( void )
{
    HKEY    hkeyWindows;
    HKEY    hkeyShellExt;
    DWORD   Error;

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows"),
                          0,
                          WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                          &hkeyWindows);

    if (Error == ERROR_SUCCESS)
    {
        MakeKeyOrTreeSecure(hkeyWindows, TRUE);
        RegCloseKey(hkeyWindows);
    }

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions"),
                          0,
                          WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                          &hkeyShellExt);
    if (Error == ERROR_SUCCESS)
    {
        MakeKeyOrTreeSecure(hkeyShellExt, FALSE);
        RegCloseKey(hkeyShellExt);
    }
}

void FixUserProfileSecurity( void )
{
    HKEY    hkeyPolicies;
    DWORD   Error;

    Error = RegOpenKeyEx( HKEY_CURRENT_USER,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"),
                          0,
                          WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                          &hkeyPolicies);

    if (Error == ERROR_SUCCESS)
    {
        MakeKeyOrTreeSecure(hkeyPolicies, FALSE);
        RegCloseKey(hkeyPolicies);
    }
}

void FixPoliciesSecurity( void )
{
    HKEY    hkeyPolicies;
    DWORD   Error, dwDisp;

    Error = RegCreateKeyEx( HKEY_CURRENT_USER,
                            TEXT("Software\\Policies"),
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                            NULL,
                            &hkeyPolicies,
                            &dwDisp);

    if (Error == ERROR_SUCCESS)
    {
        MakeKeyOrTreeSecure(hkeyPolicies, FALSE);
        RegCloseKey(hkeyPolicies);
    }
}

void SetSystemBitOnCAPIDir(void)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    TCHAR szAppData[MAX_PATH];
    DWORD FileAttributes;


    if (S_OK == SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT, szAppData)){

        //
        // It is better to use tcscpy and tcscat. This is just a temp fix and it is build with
        // Unicode anyway. Not worth to include extra header file.
        // We do not check error case here. This is just a best effort. If we got error, so what?
        // MAX_PATH should be enough for these DIRs. Not worth to take care of \\?\ format.
        //

        lstrcpyn(szPath, szAppData, ARRAYSIZE(szPath));
        StrCatBuff(szPath, TEXT("\\Microsoft\\Protect"), ARRAYSIZE(szPath));
        FileAttributes = GetFileAttributes(szPath);
        if ((FileAttributes != -1) && ((FileAttributes & FILE_ATTRIBUTE_SYSTEM) == 0)) {
            FileAttributes |= FILE_ATTRIBUTE_SYSTEM;
            SetFileAttributes(szPath, FileAttributes);
        }

        lstrcpyn(szPath, szAppData, ARRAYSIZE(szPath));
        StrCatBuff(szPath, TEXT("\\Microsoft\\Crypto"), ARRAYSIZE(szPath));
        FileAttributes = GetFileAttributes(szPath);
        if ((FileAttributes != -1) && ((FileAttributes & FILE_ATTRIBUTE_SYSTEM) == 0)) {
            FileAttributes |= FILE_ATTRIBUTE_SYSTEM;
            SetFileAttributes(szPath, FileAttributes);
        }
    }

}

void SetScreensaverOnFriendlyUI()
{
    if (IsOS(OS_FRIENDLYLOGONUI)       &&
        IsOS(OS_FASTUSERSWITCHING))
    {
        HKEY hkey;

        if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0, KEY_SET_VALUE, &hkey) == ERROR_SUCCESS)
        {
            TCHAR szTemp[MAX_PATH];

            RegSetValueEx(hkey, TEXT("ScreenSaveActive"), 0, REG_SZ, (BYTE*)TEXT("1"), sizeof(TEXT("1")));
    
            if (RegQueryValueEx(hkey, TEXT("SCRNSAVE.EXE"), NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            {
                // if the user dosen't already have a screensaver set, then choose one for them!
                if (ExpandEnvironmentStrings(TEXT("%SystemRoot%\\System32\\logon.scr"), szTemp, ARRAYSIZE(szTemp)))
                {
                    RegSetValueEx(hkey, TEXT("SCRNSAVE.EXE"), 0, REG_SZ, (BYTE*)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
                }
            }

            RegCloseKey(hkey);
        }
    }
}


#define OTHERSIDS_EVERYONE             1
#define OTHERSIDS_POWERUSERS           2

BOOL MakeFileSecure (LPTSTR lpFile, DWORD dwOtherSids)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidUsers = NULL, psidPowerUsers = NULL;
    PSID  psidEveryOne = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bAddPowerUsersAce=TRUE;
    BOOL bAddEveryOneAce=FALSE;
    DWORD dwAccMask;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         goto Exit;
    }


    //
    // Get the users sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0, 0, 0, 0, 0, 0, &psidUsers)) {

         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin))  +
            (2 * GetLengthSid (psidUsers))  +
            sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    //
    // Get the power users sid, if required.
    // Don't fail if you don't get because it might not be available on DCs??
    //

    bAddPowerUsersAce = TRUE;
    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_POWER_USERS, 0, 0, 0, 0, 0, 0, &psidPowerUsers)) {

        bAddPowerUsersAce = FALSE;
    }

    if (bAddPowerUsersAce)
        cbAcl += (2 * GetLengthSid (psidPowerUsers)) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    //
    // Get the EveryOne sid, if required.
    //

    if (dwOtherSids & OTHERSIDS_EVERYONE) {
        bAddEveryOneAce = TRUE;
        if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryOne)) {

            goto Exit;
        }
    }

    if (bAddEveryOneAce)
        cbAcl += (2 * GetLengthSid (psidEveryOne)) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        goto Exit;
    }


    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*GENERIC_READ | GENERIC_EXECUTE,*/ psidUsers)) {
        goto Exit;
    }


    if (bAddPowerUsersAce) {

        //
        // By default give read permissions, otherwise give modify permissions
        //

        dwAccMask = (dwOtherSids & OTHERSIDS_POWERUSERS) ? (FILE_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER)):
                                                           (GENERIC_READ | GENERIC_EXECUTE);

        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*dwAccMask,*/ psidPowerUsers)) {
            goto Exit;
        }
    }

    if (bAddEveryOneAce) {
        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*GENERIC_READ | GENERIC_EXECUTE,*/ psidEveryOne)) {
            goto Exit;
        }
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*GENERIC_READ | GENERIC_EXECUTE,*/ psidUsers)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    if (bAddPowerUsersAce) {
        aceIndex++;
        dwAccMask = (dwOtherSids & OTHERSIDS_POWERUSERS) ? (FILE_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER)):
                                                           (GENERIC_READ | GENERIC_EXECUTE);

        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*dwAccMask,*/ psidPowerUsers)) {
            goto Exit;
        }

        if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
            goto Exit;
        }

        lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    }

    if (bAddEveryOneAce) {
        aceIndex++;

        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*GENERIC_READ | GENERIC_EXECUTE,*/ psidEveryOne)) {
            goto Exit;
        }

        if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
            goto Exit;
        }

        lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        goto Exit;
    }


    //
    // Set the security
    //

    if (SetFileSecurity (lpFile, DACL_SECURITY_INFORMATION, &sd)) {
        bRetVal = TRUE;
    } else {
    }



Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }


    if (psidUsers) {
        FreeSid(psidUsers);
    }

    if ((bAddPowerUsersAce) && (psidPowerUsers)) {
        FreeSid(psidPowerUsers);
    }

    if ((bAddEveryOneAce) && (psidEveryOne)) {
        FreeSid(psidEveryOne);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}


#ifdef SHMG_DBG

void SHMGLogErrMsg(char *szErrMsg, DWORD dwError)
{
    DWORD   dwBytesWritten = 0;
    char    szMsg[256];
    static HANDLE  hLogFile = 0;

    if (!hLogFile) {
        hLogFile = CreateFile(_T("shmgrate.log"), GENERIC_WRITE,
                                FILE_SHARE_WRITE, 0,
                                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 );
    }                                
                                                                   
    sprintf(szMsg, "%s : (%X)\r\n", szErrMsg, dwError);
    WriteFile(hLogFile, szMsg, strlen(szMsg), &dwBytesWritten, 0);
}            

#endif

void
FixHtmlHelp(
    void
    )
{
    TCHAR AppDataPath[MAX_PATH*2];
    TCHAR HtmlHelpPath[MAX_PATH];

    SHMGLogErrMsg("FixHtmlHelp Called",0);
    
    if (SHGetFolderPath(NULL, CSIDL_COMMON_APPDATA, NULL, SHGFP_TYPE_CURRENT, AppDataPath) == S_OK &&
        LoadString( GetModuleHandle(NULL), IDS_HTML_HELP_DIR, HtmlHelpPath, sizeof(HtmlHelpPath)/sizeof(WCHAR) ) > 0)
    {
        _tcscat( AppDataPath, HtmlHelpPath );
                        
        if (CreateDirectory( AppDataPath, NULL )) {
            if (!MakeFileSecure(AppDataPath,OTHERSIDS_EVERYONE|OTHERSIDS_POWERUSERS)) 
                SHMGLogErrMsg("Could not apply security attributes", 0);
        }        
        else
            SHMGLogErrMsg("Could not create the directory", GetLastError());
    } 
    else
       SHMGLogErrMsg("Could not get APPDATA path", GetLastError());
}

// Add the SP1 "Configure Programs" shortcut to the common start menu
// On a clean install, this is handled by syssetup.inf, but on a
// RTM->SP1 upgrade, we need to do it by hand.
//

void AddConfigurePrograms()
{
    if (!IsOS(OS_ANYSERVER))
    {
        TCHAR szPath[MAX_PATH];

        if (GetSystemDirectory(szPath, ARRAYSIZE(szPath)) &&
            PathAppend(szPath, TEXT("XPSP1RES.DLL")))
        {
            HINSTANCE hinstSp1 = LoadLibraryEx(szPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
            if (hinstSp1)
            {
                TCHAR szTitle[MAX_PATH];
                LoadString(hinstSp1, IDS_APPWIZ_CONFIGUREPROGRAMS, szTitle, ARRAYSIZE(szTitle));
                CreateLinkFile(CSIDL_COMMON_STARTMENU, NULL, szTitle,
                               TEXT("control.exe appwiz.cpl,,3"),
                               TEXT("moricons.dll"), -114,
                               NULL, 0, SW_SHOWNORMAL, TEXT("@xpsp1res.dll,-10078"));
                if (S_OK == SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU, NULL, SHGFP_TYPE_CURRENT, szPath) &&
                    PathAppend(szPath, szTitle) &&
                    PathAddExtension(szPath, TEXT(".lnk")))
                {
                    SHSetLocalizedName(szPath, L"xpsp1res.dll", IDS_APPWIZ_CONFIGUREPROGRAMS);
                }
            }
            FreeLibrary(hinstSp1);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\convgrp.c ===
/****************************************************************************/
/*                                                                          */
/*  CONVGRP.C -                                                             */
/*                                                                          */
/*      Conversion from Windows NT 1.0 program group format with ANSI       */
/*      strings to Windows NT 1.0a group format with UNICODE strings.       */
/*                                                                          */
/*  Created: 09-10-93   Johanne Caron                                       */
/*                                                                          */
/****************************************************************************/
#include "progman.h"
#include "convgrp.h"

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateNewGroupFromAnsiGroup() -                                                      */
/*                                                                          */
/*  This function creates a new, empty group.                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HANDLE CreateNewGroupFromAnsiGroup(LPGROUPDEF_A lpGroupORI)
{
    HANDLE      hT = NULL;
    LPGROUPDEF  lpgd;
    int         i;
    int         cb;
    int         cItems;          // number of items in 16bit group
    LPSTR       pGroupName;      // 32bit group name
    LPTSTR      pGroupNameUNI = NULL;   // 32bit UNICODE group name
    INT         wGroupNameLen;   // length of pGroupName DWORD aligned.
    INT		cchWideChar = 0; //character count of resultant unicode string
    INT		cchMultiByte = 0;

    pGroupName = (LPSTR)PTR(lpGroupORI, lpGroupORI->pName);

    //
    // convert pGroupName to unicode here
    //
    cchMultiByte=MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pGroupName, -1, pGroupNameUNI, cchWideChar);

    pGroupNameUNI = LocalAlloc(LPTR,(++cchMultiByte)*sizeof(TCHAR));
    if (pGroupNameUNI)
    {
        MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED, pGroupName, -1, pGroupNameUNI, cchMultiByte);


        wGroupNameLen = MyDwordAlign(sizeof(TCHAR)*(lstrlen(pGroupNameUNI) + 1));
        cItems = lpGroupORI->cItems;
        cb = sizeof(GROUPDEF) + (cItems * sizeof(DWORD)) +  wGroupNameLen;

        //
        // In CreateNewGroup before GlobalAlloc.
        //
        hT = GlobalAlloc(GHND, (DWORD)cb);
        if (hT) 
        {
            lpgd = (LPGROUPDEF)GlobalLock(hT);

            //
            // use the NT 1.0 group settings for what we can.
            //
            lpgd->nCmdShow = lpGroupORI->nCmdShow;
            lpgd->wIconFormat = lpGroupORI->wIconFormat;
            lpgd->cxIcon = lpGroupORI->cxIcon;
            lpgd->cyIcon = lpGroupORI->cyIcon;
            lpgd->ptMin.x = (INT)lpGroupORI->ptMin.x;
            lpgd->ptMin.y = (INT)lpGroupORI->ptMin.y;
            CopyRect(&(lpgd->rcNormal),&(lpGroupORI->rcNormal));


            lpgd->dwMagic = GROUP_UNICODE;
            lpgd->cbGroup = (DWORD)cb;
            lpgd->pName = sizeof(GROUPDEF) + cItems * sizeof(DWORD);

            lpgd->Reserved1 = (WORD)-1;
            lpgd->Reserved2 = (DWORD)-1;

            lpgd->cItems = (WORD)cItems;

            for (i = 0; i < cItems; i++) 
            {
                lpgd->rgiItems[i] = 0;
            }

            lstrcpy((LPTSTR)((LPSTR)lpgd + sizeof(GROUPDEF) + cItems * sizeof(DWORD)),
                    pGroupNameUNI); // lhb tracks
            LocalFree(pGroupNameUNI);

            GlobalUnlock(hT);
        }
    }
    return hT;
}

DWORD AddThing_A(HANDLE hGroup, LPSTR lpStuff, WORD cbStuff)
{
    LPTSTR      lpStuffUNI = NULL;
    BOOL	bAlloc = FALSE;
    DWORD cb;

    if (cbStuff == 0xFFFF) {
        return 0xFFFF;
    }

    if (!cbStuff) {
	    INT cchMultiByte;
	    INT cchWideChar = 0;

    	bAlloc = TRUE;
        cchMultiByte=MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpStuff,
            -1,lpStuffUNI,cchWideChar) ;

        lpStuffUNI = LocalAlloc(LPTR,(++cchMultiByte)*sizeof(TCHAR)) ;

        MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpStuff,
            -1,lpStuffUNI,cchMultiByte) ;

        cbStuff = (WORD)sizeof(TCHAR)*(1 + lstrlen(lpStuffUNI)); // lhb tracks
    } else {
        lpStuffUNI = (LPTSTR)lpStuff;
    }

    cb = AddThing(hGroup, lpStuffUNI, cbStuff);

    if (bAlloc)
    	LocalFree(lpStuffUNI);

    return(cb);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ConvertToUnicodeGroup() -                                               */
/*                                                                          */
/*  returns the size of the new unicode group.                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int ConvertToUnicodeGroup(LPGROUPDEF_A lpGroupORI, LPHANDLE lphNewGroup)
{
    HANDLE hNewGroup;
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    LPBYTE lpid_A;
    LPPMTAG lptag_A;
    LPSTR lpTagValue;
    WORD wTagId;
    LPSTR lpT;	
    DWORD offset;
    int cb;
    int i;
    INT cchMultiByte;
    INT cchWideChar;
    LPTSTR lpTagValueUNI;
    BOOL bAlloc = FALSE;

    hNewGroup = CreateNewGroupFromAnsiGroup(lpGroupORI);
    if (!hNewGroup) {
        return(0);
    }

    //
    // Add all items to the new formatted group.
    //
    for (i = 0; (i < (int)lpGroupORI->cItems) && (i < CITEMSMAX); i++) {

      //
      // Get the pointer to the 16bit item
      //
      lpid_A = (LPBYTE)ITEM(lpGroupORI, i);
      if (lpGroupORI->rgiItems[i]) {

        //
        // Create the item.
        //
        offset = AddThing(hNewGroup, NULL, sizeof(ITEMDEF));
        if (!offset) {
            KdPrint(("ConvGrp: Addthing ITEMDEF failed for item %d \n", i));
            goto QuitThis;
        }

        lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);

        lpgd->rgiItems[i] = offset;
        lpid = ITEM(lpgd, i);

        //
        // Set the item's position.
        //
        lpid->pt.x = ((LPITEMDEF_A)lpid_A)->pt.x;
        lpid->pt.y = ((LPITEMDEF_A)lpid_A)->pt.y;

        //
        // Add the item's Name.
        //
        GlobalUnlock(hNewGroup);
        lpT = (LPSTR)PTR(lpGroupORI,((LPITEMDEF_A)lpid_A)->pName);

        offset = AddThing_A(hNewGroup, lpT, 0);
        if (!offset) {
            KdPrint(("ConvGrp: Addthing pName failed for item %d \n", i));
            goto PuntCreation;
        }
        lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pName = offset;

        //
        // Add the item's Command line.
        //
        GlobalUnlock(hNewGroup);
        lpT = (LPSTR)PTR(lpGroupORI, ((LPITEMDEF_A)lpid_A)->pCommand);
        offset = AddThing_A(hNewGroup, lpT, 0);
        if (!offset) {
            KdPrint(("ConvGrp: Addthing pCommand failed for item %d \n", i));
            goto PuntCreation;
        }
        lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pCommand = offset;

        //
        // Add the item's Icon path.
        //
        GlobalUnlock(hNewGroup);
        lpT = (LPSTR)PTR(lpGroupORI, ((LPITEMDEF_A)lpid_A)->pIconPath);
        offset = AddThing_A(hNewGroup, lpT, 0);
        if (!offset) {
            KdPrint(("ConvGrp: Addthing pIconPath failed for item %d \n", i));
            goto PuntCreation;
        }
        lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pIconPath = offset;

        //
        // Get the item's icon resource using the Icon path and the icon index.
        // And add the item's Icon resource.
        //
        lpid->iIcon    = ((LPITEMDEF_A)lpid_A)->idIcon;
	    lpid->cbIconRes = ((LPITEMDEF_A)lpid_A)->cbIconRes;
	    lpid->wIconVer  = ((LPITEMDEF_A)lpid_A)->wIconVer;
        GlobalUnlock(hNewGroup);

        lpT = (LPBYTE)PTR(lpGroupORI, ((LPITEMDEF_A)lpid_A)->pIconRes);
        offset = AddThing_A(hNewGroup, (LPSTR)lpT, lpid->cbIconRes);
        if (!offset) {
            KdPrint(("ConvGrp: AddThing pIconRes failed for item %d \n", i));
            goto PuntCreation;
        }
        lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pIconRes = offset;

        GlobalUnlock(hNewGroup);

      }
    }

    /*
     * Copy all the tags to the new group format.
     */
    lptag_A = (LPPMTAG)((LPSTR)lpGroupORI + lpGroupORI->cbGroup); // lhb tracks

    if (lptag_A->wID == ID_MAGIC &&
        lptag_A->wItem == (int)0xFFFF &&
        *(LONG FAR *)lptag_A->rgb == PMTAG_MAGIC) {

        //
        // This is the first tag id, goto start of item tags.
        //
        (LPBYTE)lptag_A += lptag_A->cb;

        while (lptag_A->wID != ID_LASTTAG) {

            wTagId = lptag_A->wID;
            cb = lptag_A->cb  - (3 * sizeof(DWORD)); // cb - sizeof tag

            if (wTagId == ID_MINIMIZE) {
                lpTagValueUNI = NULL;
            }
            else {
                lpTagValue = lptag_A->rgb ;
                if (wTagId != ID_HOTKEY) {

                    bAlloc = TRUE;
                    cchWideChar = 0;
                    cchMultiByte=MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,lpTagValue,
                                        -1,lpTagValueUNI,cchWideChar) ;

                    lpTagValueUNI = LocalAlloc(LPTR,(++cchMultiByte)*sizeof(TCHAR)) ;

                    MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpTagValue,
                                        -1,lpTagValueUNI,cchMultiByte) ;
                    cb = sizeof(TCHAR)*(lstrlen(lpTagValueUNI) + 1); // lhb tracks
                }
                else {
                    lpTagValueUNI = (LPTSTR)lpTagValue;
                }
            }

            if (! AddTag( hNewGroup,
                          lptag_A->wItem,   // wItem
                          wTagId,              // wID
                          lpTagValueUNI,          // rgb : tag value
                          cb
                        )) {

                KdPrint(("ConvGrp: AddTag wItem=%d, wID=%d failed \n",
                              lptag_A->wItem ,
                              lptag_A->wID));
            }

            if (bAlloc && lpTagValueUNI) {
                LocalFree(lpTagValueUNI);
                bAlloc = FALSE;
            }

            (LPBYTE)lptag_A += lptag_A->cb ;      //  go to next tag
        }
    }

    lpgd = GlobalLock(hNewGroup);
    cb = SizeofGroup(lpgd);
    GlobalUnlock(hNewGroup);
    *lphNewGroup = hNewGroup;
    return(cb);

PuntCreation:
QuitThis:
    if (hNewGroup) {
        GlobalFree(hNewGroup);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\convgrp.h ===
/****************************************************************************/
/*                                                                          */
/*  CONVGRP.H -                                                             */
/*                                                                          */
/*      Header file for the conversion from Windows NT 1.0 program group    */
/*      format with ANSI strings to Windows NT 1.0a group format            */
/*      with UNICODE strings.                                               */
/*                                                                          */
/*  Created: 09-10-93   Johanne Caron                                       */
/*                                                                          */
/****************************************************************************/

//  -- old 32 bit ansi group structures --
typedef struct tagGROUPDEF_A {
    DWORD   dwMagic;        /* magical bytes 'PMCC' */
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    cbGroup;        /* length of group segment */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    nCmdShow;       /* min, max, or normal state */
    WORD    pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */

    WORD    cItems;         /* number of items in group */
    WORD    rgiItems[1];    /* array of ITEMDEF offsets */
} GROUPDEF_A, *PGROUPDEF_A;
typedef GROUPDEF_A *LPGROUPDEF_A;

typedef struct tagITEMDEF_A {
    POINT   pt;             /* location of item icon in group */
    WORD    idIcon;         /* id of item icon */
    WORD    wIconVer;       /* icon version */
    WORD    cbIconRes;      /* size of icon resource */
    WORD    indexIcon;      /* index of item icon */
    WORD    dummy2;         /* - not used anymore */
    WORD    pIconRes;       /* offset of icon resource */
    WORD    dummy3;         /* - not used anymore */
    WORD    pName;          /* offset of name string */
    WORD    pCommand;       /* offset of command string */
    WORD    pIconPath;      /* offset of icon path */
} ITEMDEF_A, *PITEMDEF_A;
typedef ITEMDEF_A *LPITEMDEF_A;

//
// Defined in pmgseg.c
//

DWORD PASCAL AddThing(HANDLE hGroup, LPTSTR lpStuff, DWORD cbStuff);
WORD PASCAL AddUpGroupFile(LPGROUPDEF lpgd);
INT PASCAL AddTag(HANDLE h, int item, WORD id, LPTSTR lpbuf, int cb);
DWORD PASCAL SizeofGroup(LPGROUPDEF lpgd);
int ConvertToUnicodeGroup(LPGROUPDEF_A lpGroupORI, LPHANDLE lphNewGroup);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\notify.c ===
/****************************** Module Header ******************************\
* Module Name: notify.c
*
* Copyright (c) 1992, Microsoft Corporation
*
* Handles notification of key value changes in the registry that affect
* the Program Manager.
*
* History:
* 04-16-92 JohanneC       Created.
\***************************************************************************/
#include "progman.h"


BOOL InHandleProgramGroupsEvent = FALSE;
BOOL bHandleProgramGroupsEvent = TRUE;

//
// 2 watch events: common groups key & personal groups key
//
HANDLE gahEvents[2];
HANDLE hEventCommonGroups;
HANDLE hEventPersGroups;
HANDLE hEventGroupValueSet;

HANDLE hChangeNotifyThread;

/***************************************************************************\
*
*
*
* History:
* 04-16-91 Johannec       Created
\***************************************************************************/
BOOL APIENTRY InitializeGroupKeyNotification()
{

    hEventCommonGroups = CreateEvent(NULL, FALSE, FALSE, NULL);
    hEventPersGroups = CreateEvent(NULL, FALSE, FALSE, NULL);
    hEventGroupValueSet = CreateEvent(NULL, FALSE, FALSE,
                                      TEXT(" Progman.GroupValueSet"));

    gahEvents[0] = hEventPersGroups;
    gahEvents[1] = hEventCommonGroups;

    if (hEventPersGroups && hkeyProgramGroups) {
        RegNotifyChangeKeyValue(hkeyProgramGroups, TRUE, REG_NOTIFY_CHANGE_NAME,
                                 hEventPersGroups, TRUE);
    }
    if (hEventCommonGroups && hkeyCommonGroups) {
        RegNotifyChangeKeyValue(hkeyCommonGroups, TRUE, REG_NOTIFY_CHANGE_NAME,
                                 hEventCommonGroups, TRUE);
    }


    if (!hEventCommonGroups && !hEventPersGroups) {
        return(FALSE);
    }

    return(TRUE);
}


VOID APIENTRY ResetProgramGroupsEvent(BOOL bCommonGroup)
{
   if (bCommonGroup) {
       if (hEventCommonGroups && hkeyCommonGroups) {
           ResetEvent(hEventCommonGroups);
           RegNotifyChangeKeyValue(hkeyCommonGroups, TRUE, REG_NOTIFY_CHANGE_NAME,
               hEventCommonGroups, TRUE);
       }
   }
   else {
      if (hEventPersGroups && hkeyProgramGroups) {
          ResetEvent(hEventPersGroups);
          RegNotifyChangeKeyValue(hkeyProgramGroups, TRUE, REG_NOTIFY_CHANGE_NAME,
              hEventPersGroups, TRUE);
      }
   }
}

/***************************************************************************\
*
*
*
*
* History:
* 04-16-91 Johannec       Created
\***************************************************************************/
VOID HandleGroupKeyChange(BOOL bCommonGroup)
{
    int i = 0;
    DWORD cbGroupKey = MAXKEYLEN;
    TCHAR szGroupKey[MAXKEYLEN];
    FILETIME ft;
    HWND hwndT;
    PGROUP pGroup;
    PGROUP *ppGroup;
    PITEM pItem;
    HKEY hkeyGroups;
    HKEY hkey;
    TCHAR szT[10];

    if (InHandleProgramGroupsEvent || !bHandleProgramGroupsEvent) {
        goto RegNotify;
    }

    InHandleProgramGroupsEvent = TRUE;

    if (bCommonGroup) {
        hkeyGroups = hkeyCommonGroups;
    }
    else {
        hkeyGroups = hkeyProgramGroups;
    }

    while (!RegEnumKeyEx(hkeyGroups, i, szGroupKey, &cbGroupKey, 0, 0, 0, &ft)) {
        if (cbGroupKey) {
          /* Search for the group... if it already exists, activate it. */
          hwndT = GetWindow(hwndMDIClient, GW_CHILD);
          while (hwndT) {
              /* Skip icon titles. */
              if (!GetWindow(hwndT, GW_OWNER)) {
                  /* Compare the group title with the request. */
                  pGroup = (PGROUP)GetWindowLongPtr(hwndT,GWLP_PGROUP);
                  if (!lstrcmpi(szGroupKey, pGroup->lpKey)) {
                      if (pGroup->fCommon && bCommonGroup ||
                           !pGroup->fCommon && !bCommonGroup)
                          break;
                  }
              }
              hwndT = GetWindow(hwndT, GW_HWNDNEXT);
          }

          /* If we didn't find it, load it. */
          if (!hwndT) {
              //
              // Wait until the value is set before loading the group.
              //
              WaitForSingleObject(hEventGroupValueSet, 300);
              ResetEvent(hEventGroupValueSet);

              LoadGroupWindow(szGroupKey, 0, bCommonGroup);
          }
        }

        i++;
        cbGroupKey = MAXKEYLEN;
    }

    //
    // Test if any groups were deleted through regedt32.exe.
    //

    for (hwndT = GetWindow(hwndMDIClient, GW_CHILD);
                   hwndT;
                   hwndT = GetWindow(hwndT, GW_HWNDNEXT)) {

        /* Skip icon titles. */
        if (GetWindow(hwndT, GW_OWNER))
            continue;

        /* Compare the group title with the request. */
         pGroup = (PGROUP)GetWindowLongPtr(hwndT, GWLP_PGROUP);
         if ( (pGroup->fCommon && !bCommonGroup) ||
              (!pGroup->fCommon && bCommonGroup) ) {
             continue;
         }

         if (RegOpenKey(hkeyGroups, pGroup->lpKey, &hkey) == ERROR_SUCCESS) {
             RegCloseKey(hkey);
         }
         else {
             //
             // Couldn't find the group in the registry so delete it
             // in progman.
             //
             /* Destroy the window, the global memory block, and the file. */
             SendMessage(hwndMDIClient, WM_MDIDESTROY, (WPARAM)hwndT, 0L);
             NukeIconBitmap(pGroup);
             GlobalFree(pGroup->hGroup);

             if (!bCommonGroup) {

                 //
                 // Remove the program manager's settings for that personal group.
                 //
                 wsprintf(szT,TEXT("Group%d"),pGroup->wIndex);
                 RegDeleteValue(hkeyPMGroups, szT);
             }

             /* Unlink the group structure. */
             for (ppGroup=&pFirstGroup; *ppGroup && *ppGroup != pGroup; ppGroup = &(*ppGroup)->pNext)
                 ;

             if (*ppGroup)
                 *ppGroup = pGroup->pNext;

             if (pLastGroup == &pGroup->pNext)
                 pLastGroup = ppGroup;

             /* Destroying the window should activate another one, but if it is the
              * last one, nothing will get activated, so to make sure punt the
              * current group pointer...
              */
             if (pCurrentGroup == pGroup)
                 pCurrentGroup = NULL;

             /* Lastly, toss out the group and item structures. */
             while (pGroup->pItems) {
                 pItem = pGroup->pItems;
                 pGroup->pItems = pItem->pNext;
                 LocalFree((HANDLE)pItem);
             }
             LocalFree((HANDLE)pGroup->lpKey);
             LocalFree((HANDLE)pGroup);

             if (!bCommonGroup) {

                 //
                 // Change the program manager's settings for that personal group.
                 //
                 WriteGroupsSection();
             }
         }
    }

RegNotify:

    ResetProgramGroupsEvent(bCommonGroup);

    InHandleProgramGroupsEvent = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\hotkey.c ===
/*
 * hotkey.c
 *
 *  Copyright (c) 1991,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *        This file is for support of program manager under NT Windows.
 *        This file is/was ported from hotkey.c (program manager).
 *
 *  MODIFICATION HISTORY
 *      Initial Version: x/x/90    Author Unknown, since he didn't feel
 *                                like commenting the code...
 *
 *      NT 32b Version: 1/18/91    Jeff Pack
 *                                Intitial port to begin.
 *
 *
 */

#include "progman.h"

#define HK_SHIFT    0x0100
#define HK_CONTROL  0x0200
#define HK_ALT        0x0400
#define HK_EXT        0x0800

#define F_EXT        0x01000000L

TCHAR szHotKey[] = TEXT("pmhotkey");

typedef struct HOTKEYWINDOWBYTES {
    UINT    hotkey;
    int     cyFont;
    HFONT   hfont;
} HOTKEYWINDOWBYTES;

#define HWL_HOTKEY  FIELD_OFFSET(HOTKEYWINDOWBYTES, hotkey)
#define HWL_CYFONT  FIELD_OFFSET(HOTKEYWINDOWBYTES, cyFont)
#define HWLP_FONT   FIELD_OFFSET(HOTKEYWINDOWBYTES, hfont)

/*** SetHotKey --
 *
 *
 * void APIENTRY SetHotKey(HWND hwnd, WORD hk)
 *
 * ENTRY -     HWND    hWnd
 *            WORD    hk
 *
 * EXIT  -    void
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

void APIENTRY SetHotKey(HWND hwnd, WPARAM hk)
{

    /* don't invalidate if it's the same
     */
    if((LONG)hk == GetWindowLong(hwnd, HWL_HOTKEY)){
        return;
    }
    SetWindowLong(hwnd, HWL_HOTKEY, (LONG)hk);

    InvalidateRect(hwnd,NULL,TRUE);
}

/*** GetKeyName --
 *
 *
 * void APIENTRY GetKeyName(WORD vk, PSTR psz, BOOL fExt)
 *
 * ENTRY -     WORD    hk
 *            PSTR    psz
 *            BOOL    fExt
 *
 * EXIT  -    void
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

void APIENTRY GetKeyName(UINT vk, LPTSTR psz, BOOL fExt)
{
    LONG scan;
    scan = (LONG)MapVirtualKey(vk,0) << 16;
    if (fExt){
        scan |= F_EXT;
    }

    GetKeyNameText(scan,psz,50);
}

/*** PaintHotKey --
 *
 *
 * void APIENTRY PaintHotKey(register HWND hwnd)
 *
 * ENTRY -     HWND    hWnd
 *
 * EXIT  -    void
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

void APIENTRY PaintHotKey(register HWND hwnd)
{
    TCHAR sz[128];
    TCHAR szPlus[10];
    WORD cch;
    WORD hk;
    register HDC hdc;
#ifndef ORGCODE
    SIZE size;
#endif
    PAINTSTRUCT ps;
    int x, y;
    HANDLE hFont;
    DWORD dwColor;

    LoadString(hAppInstance, IDS_PLUS, szPlus, CharSizeOf(szPlus));

    if(hk = (WORD)GetWindowLong(hwnd, HWL_HOTKEY)){
        sz[0] = 0;
        cch = 0;
        if (hk & HK_CONTROL){
            GetKeyName(VK_CONTROL,sz,FALSE);
            lstrcat(sz,szPlus);
          }
        if (hk & HK_SHIFT){
            GetKeyName(VK_SHIFT, sz + lstrlen(sz), FALSE);
            lstrcat(sz,szPlus);
        }
        if (hk & HK_ALT){
            GetKeyName(VK_MENU, sz + lstrlen(sz), FALSE);
            lstrcat(sz,szPlus);
        }
        GetKeyName((UINT)LOBYTE(hk), sz + lstrlen(sz), hk & HK_EXT);
    }
    else{
        LoadString(hAppInstance,IDS_NONE,sz,100);
    }

    cch = (WORD)lstrlen(sz);
    HideCaret(hwnd);

    hdc = BeginPaint(hwnd,&ps);

    SetBkMode(hdc, TRANSPARENT);

    hFont = SelectObject(hdc,(HANDLE)GetWindowLongPtr(hwnd,HWLP_FONT));
    x = GetSystemMetrics(SM_CXBORDER);
    y = GetSystemMetrics(SM_CYBORDER);

    if (IsWindowEnabled(hwnd)){
	    dwColor = GetSysColor(COLOR_WINDOWTEXT);
    	dwColor = SetTextColor(hdc,dwColor);
        TextOut(hdc,x,y,sz,cch);
    }
    else if (dwColor = GetSysColor(COLOR_GRAYTEXT)){
        dwColor = SetTextColor(hdc,dwColor);
        TextOut(hdc,x,y,sz,cch);
        SetTextColor(hdc,dwColor);
    }
    else{
        GrayString(hdc,NULL,NULL,(LPARAM)(LPTSTR)sz,cch,x,y,0,0);
    }

#ifdef ORGCODE
    x = (WORD)GetTextExtentPoint(hdc,sz,cch);
#else
    /*Used to return x/y in DWORD, now returns cx,cy in size*/
    GetTextExtentPoint(hdc, sz, cch, &size);
    x = size.cx;
#endif
    if (GetFocus() == hwnd)
    SetCaretPos(x+GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CYBORDER));
    ShowCaret(hwnd);

    if (hFont){
        SelectObject(hdc,hFont);
    }

    SetBkMode(hdc, OPAQUE);

    EndPaint(hwnd,&ps);
}

/*** HotKeyWndProc --
 *
 *
 * LRESULT APIENTRY HotKeyWndProc(register HWND hwnd, UINT wMsg,
 *                                register WPARAM wParam, LPARAM lParam)
 *
 * ENTRY -     HWND    hWnd
 *            WORD    wMsg
 *            WPARAM    wParam
 *            LPARAM    lParam
 * EXIT  -    LRESULT xxx - returns info, or zero, for nothing to return
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

LRESULT APIENTRY HotKeyWndProc(register HWND hwnd, UINT wMsg,
                             register WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    WORD wT;
#ifndef ORGCODE
    SIZE size;
#endif
    switch (wMsg){
    case WM_CREATE:
        SetHotKey(hwnd,0);
        SendMessage(hwnd,WM_SETFONT,(WPARAM)GetStockObject(SYSTEM_FONT),0L);
        break;

    case WM_SETFOCUS:
        InvalidateRect(hwnd,NULL,TRUE);
        CreateCaret(hwnd,NULL,0,GetWindowLong(hwnd,HWL_CYFONT));
        ShowCaret(hwnd);
        break;

    case WM_KILLFOCUS:
        if (!LOBYTE(GetWindowLong(hwnd,HWL_HOTKEY))){
            SetHotKey(hwnd,0);
        }
        DestroyCaret();
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTCHARS | DLGC_WANTARROWS;

    case WM_SETTEXT:
        SetHotKey(hwnd,LOWORD(lParam));
        break;

    case WM_GETTEXT:
        *(LPINT)lParam = GetWindowLong(hwnd,HWL_HOTKEY);
        break;

    case WM_SETHOTKEY:
        SetHotKey(hwnd,(WPARAM) wParam);
        break;

    case WM_GETHOTKEY:
        return GetWindowLong(hwnd,HWL_HOTKEY);

    case WM_LBUTTONDOWN:
        SetFocus(hwnd);
        break;

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        switch (wParam) {
        case VK_RETURN:
        case VK_TAB:
        case VK_SPACE:
        case VK_DELETE:
        case VK_ESCAPE:
        case VK_BACK:
            SetHotKey(hwnd,0);
            return DefWindowProc(hwnd,wMsg,wParam,lParam);
        case VK_MENU:
        case VK_SHIFT:
        case VK_CONTROL:
            wParam = 0;
            /*** fall thru ***/

        default:
            if (GetKeyState(VK_CONTROL) < 0)
                wParam |= HK_CONTROL;
            if (GetKeyState(VK_SHIFT) < 0)
                wParam |= HK_SHIFT;
            if (GetKeyState(VK_MENU) < 0)
                wParam |= HK_ALT;
            if (lParam & F_EXT)
                wParam |= HK_EXT;

            // more than one shift key must be specified.  That is,
            // CONTROL+ALT, CONTROL+SHIFT, SHIFT+ALT
            // get the bitmask of shift keys and then determine whether
            // it has at least two bits set via the bitcount trick

    	    // if not enough control things are present we add them
	        // in.  so the user gets the idea.

            if ((wParam & HK_ALT) && !(wParam & HK_CONTROL)
                                  && !(wParam & HK_SHIFT)) {
                break;
            }
            else {
	            wT = (WORD)(wParam & (HK_CONTROL|HK_SHIFT|HK_ALT));
	            if (!wT || !(wT & (wT - 1)))
        		    wParam |= HK_CONTROL | HK_ALT;

	            SetHotKey(hwnd,wParam);
	            break;
            }
        }
        break;

    case WM_SYSKEYUP:
    case WM_CHAR:
    case WM_SYSCHAR:
    case WM_KEYUP:
    if (!LOBYTE((WORD)GetWindowLong(hwnd,HWL_HOTKEY)))
        SetHotKey(hwnd,0);
    break;


    case WM_GETFONT:
        return GetWindowLongPtr(hwnd,HWLP_FONT);

    case WM_SETFONT:
        lParam = GetWindowLongPtr(hwnd,HWLP_FONT);
        SetWindowLongPtr(hwnd,HWLP_FONT,wParam);
        hdc = GetDC(hwnd);
        wParam = (WPARAM) SelectObject(hdc,(HANDLE)wParam);
        GetTextExtentPoint(hdc, TEXT("C"), 1, &size);
        SetWindowLong(hwnd, HWL_CYFONT, size.cy);
        if (wParam){
            SelectObject(hdc,(HANDLE)wParam);
        }
        ReleaseDC(hwnd,hdc);
        InvalidateRect(hwnd,NULL,TRUE);
        return lParam;

    case WM_PAINT:
        PaintHotKey(hwnd);
        break;

    case WM_ERASEBKGND:
        HideCaret(hwnd);
        lParam = DefWindowProc(hwnd,wMsg,wParam,lParam);
        ShowCaret(hwnd);
        return lParam;

    default:
        return DefWindowProc(hwnd,wMsg,wParam,lParam);
    }
    return 0L;
}

/*** RegisterHotKeyClass --
 *
 *
 * BOOL APIENTRY RegisterHotKeyClass(HANDLE hInstance)
 *
 * ENTRY - HWND    HANDLE hInstance
 * EXIT  - BOOL    xxx - returns return code from RegisterClass
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -  This (under 16)  took hInstance.  Under win32, hInstance is
 *                NULL, cause there is only one instance.
 * EFFECTS  -
 *
 */

BOOL APIENTRY RegisterHotKeyClass(HANDLE hInstance)
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = HotKeyWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(HOTKEYWINDOWBYTES);
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szHotKey;

    return RegisterClass(&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmdde.c ===
/****************************************************************************/
/*                                                                          */
/*  PMDDE.C -                                                               */
/*                                                                          */
/*        Windows Program Starter DDE Routines                              */
/*                                                                          */
/****************************************************************************/
#include "progman.h"
#include "dde.h"
#include "uniconv.h"

#define PMPrint(s)  KdPrint(("PROGMAN: ")); \
                         KdPrint(s);            \
                         KdPrint(("\n"));


//
// Define this if you want to know everything about Progman DDE
//

//#define VERBOSE_PROGMANDDE

#ifdef VERBOSE_PROGMANDDE
#define VerbosePrint(s) PMPrint(s)
#else
#define VerbosePrint(s)
#endif



/* DDE window classes */
TCHAR szProgmanDDE[] = TEXT("ProgmanDDE");
TCHAR szAppIconDDE[] = TEXT("AppIconDDE");
TCHAR szAppDescDDE[] = TEXT("AppDescDDE");
TCHAR szAppWDirDDE[] = TEXT("AppWDirDDE");
//
// For compatibility reasons, allow the old WIn3.1 Shell - AppProperties
// DDE connection.
//
TCHAR szAppProperties[] = TEXT("AppProperties");

BOOL bProgmanDDE = TRUE;
BOOL bAppIconDDE = TRUE;
BOOL bAppDescDDE = TRUE;
BOOL bAppWDirDDE = TRUE;

/* application names*/
TCHAR szShell[] = TEXT("Shell");

/* topics*/
TCHAR szAppIcon[] = TEXT("AppIcon");
TCHAR szAppDesc[] = TEXT("AppDescription");
TCHAR szAppWDir[] = TEXT("AppWorkingDir");
TCHAR szSystem[]  = TEXT("System");

/* items*/
TCHAR szGroupList[] = TEXT("Groups");

#define DDE_PROGMAN     0
#define APP_ICON        1
#define APP_DESC        2
#define APP_WDIR        3

#define WCHAR_QUOTE     L'"'

BOOL fForcePoint = FALSE;                /* used for replacement*/
POINT ptForce;

typedef struct _datadde
  {
    unsigned short unused:12,
             fResponse:1,
             fRelease:1,
             reserved:1,
             fAckReq:1;
    WORD  cfFormat;
  } DATADDE;

typedef struct _newicondata
  {
    DATADDE dd;
    DWORD dwResSize;
    DWORD dwVer;
    BYTE iResource;
  } NEWICONDATA;


int NEAR PASCAL myatoi(LPTSTR lp);
LPTSTR NEAR PASCAL SkipWhite(LPTSTR lpsz);
LPTSTR APIENTRY GetOneParameter(LPTSTR lpCmd, WPARAM *lpW, BOOL bSaveQuotes);
LPTSTR NEAR PASCAL GetCommandName(LPTSTR lpCmd, LPTSTR lpFormat, WPARAM *lpW);
HANDLE NEAR PASCAL GetDDECommands(LPTSTR lpCmd, LPTSTR lpFormat);

typedef struct _ddeconversation {
    HWND hwndClient;
    HWND hwndServer;
    DWORD dwType;
    struct _ddeconversation *Next;
} DDECONVERSATION, *PDDECONVERSATION;

PDDECONVERSATION pDdeConversation = NULL;
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InitDDEConverstionStruct() -                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID InitDdeConversationStruct()
{
    pDdeConversation = (PDDECONVERSATION)LocalAlloc(LPTR, sizeof(DDECONVERSATION));
    pDdeConversation->Next = NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddDdeConverstion() -                                                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID AddDdeConversation(HWND hwndServer, HWND hwndClient, DWORD dwType)
{
    PDDECONVERSATION pT = NULL;

    if (!pDdeConversation) {
        return;
    }
    if (pT = (PDDECONVERSATION)LocalAlloc(LPTR, sizeof(DDECONVERSATION))) {
        pT->hwndServer = hwndServer;
        pT->hwndClient = hwndClient;
        pT->dwType = dwType;
        pT->Next = pDdeConversation->Next;
        pDdeConversation->Next = pT;
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RemoveDdeConverstion() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID RemoveDdeConversation(HWND hwndServer, HWND hwndClient, DWORD dwType)
{
    PDDECONVERSATION pT;
    PDDECONVERSATION pFree;

    if (!pDdeConversation) {
        return;
    }
    for (pT = pDdeConversation; pT->Next; pT = pT->Next) {
        if ((pT->Next->hwndClient == hwndClient) &&
                      (pT->Next->hwndServer == hwndServer) &&
                      (pT->Next->dwType == dwType)) {
            pFree = pT->Next;
            pT->Next = pT->Next->Next;
            LocalFree(pFree);
            return;
        }
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsDDEConverstion() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL IsDdeConversation(HWND hwndServer, HWND hwndClient, DWORD dwType)
{
    PDDECONVERSATION pT;

    if (!pDdeConversation) {
        return(FALSE);
    }
    for (pT = pDdeConversation; pT->Next; pT = pT->Next) {
        if ((pT->Next->hwndClient == hwndClient) &&
                      (pT->Next->hwndServer == hwndServer) &&
                      (pT->Next->dwType == dwType)) {
            return(TRUE);
        }
    }
    return(FALSE);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DDEFail() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID APIENTRY DDEFail(HWND hWnd, HWND hwndTo, ATOM aItem)
{
    MPostWM_DDE_ACK(hwndTo, hWnd, ACK_NEG, aItem);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SkipWhite() -                                                           */
/*                                                                          */
/* Returns a pointer to the first non-whitespace character in a string.     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LPTSTR APIENTRY SkipWhite(LPTSTR lpsz)
{
  /* prevent sign extension */
  while (*lpsz && (TUCHAR)*lpsz <= (TUCHAR)TEXT(' '))
      lpsz++;

  return(lpsz);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetCommandName() -                                                      */
/*                                                                          */
/* Extracts an alphabetic string and looks it up in a list of possible
/* commands, returning a pointer to the character after the command and
/* sticking the command index somewhere.
/*
/* lpFormat string syntax:
/*     cmd\0cmd\0...\0\0
/*
/*--------------------------------------------------------------------------*/

LPTSTR APIENTRY GetCommandName(LPTSTR lpCmd, LPTSTR lpFormat, WPARAM *lpW)
{
  register TCHAR chT;
  register WORD iCmd = 0;
  LPTSTR         lpT;

  /* Eat any white space. */
  lpT = lpCmd = SkipWhite(lpCmd);

  /* Find the end of the token. */
  while (IsCharAlpha(*lpCmd))
      lpCmd++;

  /* Temporarily NULL terminate it. */
  chT = *lpCmd;
  *lpCmd = TEXT('\0');

  /* Look up the token in a list of commands. */
  *lpW = (DWORD_PTR)0xFFFF;
  while (*lpFormat) {
      if (!lstrcmpi(lpFormat, lpT)) {
          *lpW = iCmd;
          break;
      }
      iCmd++;
      while (*lpFormat++)
          ;
  }

  *lpCmd = chT;

  return(lpCmd);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ValidateFileName() -                                                    */
/*                                                                          */
/*  Checks if the given filename really exists.  The filename passed        */
/*  in will have quotes around it, so this routine removes the quotes       */
/*  first.  Returns TRUE if it is a valid file.                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL APIENTRY ValidateFileName (LPTSTR lpFileName)
{
    TCHAR           chT;
    WORD            wLen;
    LPTSTR          lpEnd;
    BOOL            bResult = FALSE;
    HANDLE          hFile;
    WIN32_FIND_DATA fd;

    // Save the last character (better be a quote), and move
    // the terminating NULL one character forward.
    wLen = (WORD)lstrlen (lpFileName);
    lpEnd = lpFileName + wLen - 1;
    chT = *lpEnd;

    // MarkTa fix for spaces at the end of a filename
    // Remove the spaces by moving the quote forward.
    while (*(lpEnd-1) == TEXT(' '))
        lpEnd--;

    *lpEnd = TEXT('\0');

    // Test if this is a file.
    hFile = FindFirstFile(lpFileName+1, &fd);

    if (hFile != INVALID_HANDLE_VALUE)
       {
       FindClose (hFile);
       bResult = TRUE;
       }


    // Put back the character we removed eariler, and NULL terminate
    *lpEnd = chT;
    *(lpEnd+1) = TEXT('\0');

    return (bResult);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetOneParameter() -                                                     */
/*                                                                          */
/*  Reads a parameter out of a string removing leading and trailing whitespace.
/*  Terminated by , or ).  ] [ and ( are not allowed.  Exception: quoted
/*  strings are treated as a whole parameter and may contain []() and ,.
/*  Places the offset of the first character of the parameter into some place
/*  and NULL terminates the parameter.
/*
/*--------------------------------------------------------------------------*/

LPTSTR APIENTRY GetOneParameter(LPTSTR lpCmd, WPARAM *lpW, BOOL bSaveQuotes)
{
    LPTSTR          lpT;
    LPTSTR          lpTemp;
    TCHAR           chT;
    WORD            wLen;
    LPTSTR          lpEnd;

    switch (*lpCmd) {
    case TEXT(','):
        *lpW = (DWORD_PTR)lpCmd;
        *lpCmd++ = 0;                /* comma: becomes a NULL string */
        break;

    case TEXT('"'):                         /* quoted string... trim off " */

        VerbosePrint (("Quoted parameter before parsing: %S", lpCmd));
        VerbosePrint (("bSaveQuotes = %d", bSaveQuotes));

        if (bSaveQuotes)
           {
           // Set the beginning marker at the quote then increment.
           *lpW = (DWORD_PTR)lpCmd;
           ++lpCmd;
           }
        else
           {
           // Increment first to skip the quote
           ++lpCmd;
           *lpW = (DWORD_PTR)lpCmd;
           }

        while (*lpCmd && *lpCmd != TEXT('"'))
            lpCmd++;
        if (!*lpCmd)
            return(NULL);

        lpTemp = lpCmd;  // lpTemp should point at the quote
        lpCmd++;

        if (bSaveQuotes)
           {
           chT = *lpCmd;
           *lpCmd = TEXT('\0');

           VerbosePrint (("Checking %S to confirm that it really is a file.", *lpW));
           if (!ValidateFileName ((LPTSTR) *lpW))
              {
              // file doesn't exist.  Remove the quotes.
              VerbosePrint (("No, this isn't a file.  Removing the quotes."));
              *lpW = *lpW + sizeof (TCHAR);
              lpTemp = (LPTSTR)(*lpW) + lstrlen((LPTSTR) (*lpW)) - 1;
              *lpTemp = TEXT('\0');
              VerbosePrint (("New string after removing the quotes: %S", *lpW));
              }
            else
              {

              //
              // The quoted filename is valid, so now we want to test if
              // the quotes are really necessary.  To do this, remove
              // the quotes, and then call CheckEscapes to look for funny
              // characters.
              //

              VerbosePrint (("Yes, %S is a file.  Checking if we really need these quotes", *lpW));
              SheRemoveQuotes ((LPTSTR) *lpW);
              CheckEscapes ((LPTSTR) *lpW, lstrlen ((LPTSTR) *lpW) + 2);
              VerbosePrint (("After checking quotes we have %S", *lpW));
              }

           *lpCmd = chT;
           }
        else
           *lpTemp = TEXT(' ');


        while (*lpCmd && *lpCmd != TEXT(')') && *lpCmd != TEXT(','))
            lpCmd++;
        if (!*lpCmd)
            return(NULL);

        if (*lpCmd == TEXT(','))
           {
           *lpCmd = TEXT('\0');
           lpCmd++;
           }
        else
           *lpCmd = TEXT('\0');


        // Remove the space at the end of the string if the parser
        // added it.
        wLen = (WORD)lstrlen ((LPTSTR)(*lpW));
        lpEnd = (LPTSTR)(*lpW) + wLen - 1;
        if (*lpEnd == TEXT (' '))
           *lpEnd = TEXT('\0');

        VerbosePrint (("Quoted parameter after parsing: %S", *lpW));
        break;

    case TEXT(')'):
        return(lpCmd);                /* we ought not to hit this */

    case TEXT('('):
    case TEXT('['):
    case TEXT(']'):
        return(NULL);                 /* these are illegal */

    default:
        lpT = lpCmd;
        *lpW = (DWORD_PTR)lpT;

        while (*lpCmd && *lpCmd != TEXT(',') && *lpCmd != TEXT(')')) {
            /* Check for illegal characters. */
            if (*lpCmd == TEXT(']') || *lpCmd == TEXT('[') || *lpCmd == TEXT('(') )
                return(NULL);

            /* Remove trailing whitespace */
            /* prevent sign extension */
            if ((TUCHAR)*lpCmd > (TUCHAR)TEXT(' '))
                lpT = lpCmd;
            lpCmd = CharNext(lpCmd);
        }

        /* Eat any trailing comma. */
        if (*lpCmd == TEXT(','))
            lpCmd++;

        /* NULL terminator after last nonblank character -- may write over
         * terminating ')' but the caller checks for that because this is
         * a hack.
         */
        lpT = CharNext(lpT);
        *lpT = TEXT('\0');

        break;
    }

    /* Return next unused character. */
    return(lpCmd);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetDDECommands() -                                                      */
/*                                                                          */
/*  Called with: far pointer to a string to parse and a far pointer to a
/*  list of sz's containing the allowed function names.
/*  The function returns a global handle to an array of words containing
/*  one or more command definitions.  A command definition consists of
/*  a command index, a parameter count, and that number of offsets.  Each
/*  offset is an offset to a parameter in lpCmd which is now zero terminated.
/*  The list of command is terminated with -1.
/*  If there was a syntax error the return value is NULL.
/*  Caller must free block.
/*
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL GetDDECommands(LPTSTR lpCmd, LPTSTR lpFormat)
{
  register WORD     cParm;
  WORD              cCmd = 0;
  register HANDLE   hDDECmds;
  DWORD_PTR *       lpW = NULL;
  BOOL              bAddItem = FALSE;

  /* Will allow up to 128 words, 64 single command (less with parms). */
  /*
   * Now these are 32bit, since the offset is now replaced by the
   * full pointer which is 32 bit.
   *
   * (And if they are 64bit, they get even bigger.)
   */
  hDDECmds = GlobalAlloc(GHND, 128 * sizeof(DWORD_PTR));
  if (!hDDECmds)
      return(NULL);

  /* Get pointer to array. */
  lpW = (DWORD_PTR *)GlobalLock(hDDECmds);
  while (*lpCmd) {
      /* Skip leading whitespace. */
      lpCmd = SkipWhite(lpCmd);

      /* Are we at a NULL? */
      if (!*lpCmd) {
          /* Did we find any commands yet? */
          if (cCmd)
              goto GDEExit;
          else
              goto GDEErrExit;
      }

      /* Each command should be inside square brackets. */
      if (*lpCmd != TEXT('['))
          goto GDEErrExit;
      lpCmd++;

      /* Get the command name. */
      lpCmd = GetCommandName(lpCmd, lpFormat, lpW);
      if (*lpW == (DWORD_PTR)0xFFFF)
          goto GDEErrExit;

      if (*lpW == 1)
         bAddItem = TRUE;

      lpW++;

      /* Start with zero parms. */
      cParm = 0;
      lpCmd = SkipWhite(lpCmd);

      /* Check for opening '(' */
      if (*lpCmd == TEXT('(')) {
          lpCmd++;

          /* Skip white space and then find some parameters (may be none). */
          lpCmd = SkipWhite(lpCmd);

          while (*lpCmd != TEXT(')')) {
              if (!*lpCmd)
                  goto GDEErrExit;

              /* Get the parameter. */
              if (bAddItem && (cParm == 0 || cParm == 2 || cParm == 6))
                 {
                 // In this case, we are working with filenames of
                 // the command line, icon path, or default directory of
                 // the AddItem command.
                 // We don't want to strip the quotes if they exist.
                 if (!(lpCmd = GetOneParameter(lpCmd, lpW + (++cParm), TRUE)))
                     goto GDEErrExit;
                 }
              else
                 {
                 // This is for every other parameter.  The quotes will be
                 // stripped.
                 if (!(lpCmd = GetOneParameter(lpCmd, lpW + (++cParm), FALSE)))
                     goto GDEErrExit;
                 }

              /* HACK: Did GOP replace a ')' with a NULL? */
              if (!*lpCmd)
                  break;

              /* Find the next one or ')' */
              lpCmd = SkipWhite(lpCmd);
          }

          lpCmd++;

          /* Skip the terminating stuff. */
          lpCmd = SkipWhite(lpCmd);
      }

      /* Set the count of parameters and then skip the parameters. */
      *lpW++ = cParm;
      lpW += cParm;

      /* We found one more command. */
      cCmd++;

      /* Commands must be in square brackets. */
      if (*lpCmd != TEXT(']'))
          goto GDEErrExit;
      lpCmd++;
  }

GDEExit:
  /* Terminate the command list with -1. */
  *lpW = (DWORD_PTR)0xFFFF;

  GlobalUnlock(hDDECmds);
  return(hDDECmds);

GDEErrExit:
  GlobalUnlock(hDDECmds);
  GlobalFree(hDDECmds);
  return(NULL);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsParameterANumber() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL APIENTRY IsParameterANumber(LPTSTR lp)
{
  while (*lp) {
      if (*lp < TEXT('0') || *lp > TEXT('9'))
          return(FALSE);
      lp++;
  }
  return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  myatoi() -                                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int APIENTRY myatoi(LPTSTR lp)
{
  register int        i = 0;

  while (*lp >= TEXT('0') && *lp <= TEXT('9')) {
      i *= 10;
      i += (int)(*lp-TEXT('0'));
      lp++;
  }
  return(i);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ExecuteHandler() -                                                      */
/*                                                                          */
/* Handles WM_DDE_EXECUTE messages...                                       */
/*                                                                          */
/*  return 0 if it fails                                                    */
/*         1 if it succeeds                                                 */
/*         2 if it succeeds and the command was ExitProgman                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/

DWORD APIENTRY ExecuteHandler(HANDLE hString)
{
  register HWND     hwndT;
  LPTSTR             lpT;
  LPTSTR             lpString;
  register HANDLE   hCmd;
  DWORD_PTR *       lpwCmd;
  DWORD             dwRet = 0;
  PGROUP            pGroup;
  LPGROUPDEF        lpgd;
  WCHAR		    lpFmtinit[] = TEXT("CreateGroup#AddItem#DeleteGroup#ExitProgman#ShowGroup#DeleteItem#ReplaceItem#Reload#ChangeINIFile#");
  LPTSTR	    lpFmt ;

  lpFmt = lpFmtinit;
  /* Lock the command string. */
  lpString = (LPTSTR)GlobalLock(hString);
  if(!lpString)
      return(0);

  VerbosePrint(("Execute Handler received: %S", lpString));

#ifdef DEBUG_PROGMAN_DDE
  {
  TCHAR szDebug[300];

  wsprintf (szDebug, TEXT("%d   PROGMAN:   Execute Handler recived:  %s\r\n"),
            GetTickCount(), lpString);
  OutputDebugString(szDebug);
  }
#endif

  bInDDE = TRUE;

  /* Parse the commands. */

// the following line does not work on build 363! TEXT string is truncated
// after "CreateGroup".
  //hCmd = GetDDECommands(lpString, (LPTSTR)TEXT("CreateGroup\0AddItem\0DeleteGroup\0ExitProgman\0ShowGroup\0DeleteItem\0ReplaceItem\0Reload\0ChangeINIFile\0"));


  // substitute nulls for '#'
  while (*lpFmt) {
      if (*lpFmt == TEXT('#'))
	 *lpFmt = (TCHAR) 0;
      lpFmt++ ;
  }
  lpFmt = lpFmtinit; // reset the pointer back to the begining
  hCmd = GetDDECommands(lpString, lpFmt) ;
  if (!hCmd)
      goto DEHErrExit1;

  /* Lock the list of commands and parameter offsets. */
  lpwCmd = (DWORD_PTR *)GlobalLock(hCmd);

  /* Execute each command. */
  while (*lpwCmd != (DWORD_PTR)0xFFFF) {

      switch (*lpwCmd++) {
      case 0:
      {
          INT   cParm;
          INT   nCommonGrp = -1;
          LPTSTR lpCommonGrp = NULL;
          LPTSTR lpGroupName;


          /* [ CreateGroup ( groupname [, groupfile] [, common_group_flag] ) ] */
          /*
           * The groups are now in the registry thus no more group files
           * and therefore this is now replaced by
           *   [ CreateGroup ( groupname ) ]
           * The groupfile is specified is ignored. This will cause an error
           * for compatability reasons.
           */

          /*
           * A new optional parameter is added to specify whether to create
           * a Common group  or a Personal group.
           *     1 for Common Group
           *     0 for Personal Group
           * Only users with administrative rights can create/delete Common
           * groups. The default if this parameter is not specified is:
           *     Common group if user has admin rights
           *     Personal group if not
           */

          /* Make sure that we have 1, 2 or 3 parameters, ignore the 2nd one
           * if it represents a groupfile name.
           */
          cParm = (INT)*lpwCmd++;
          if ((cParm < 1) || (cParm > 3))
              goto DEHErrExit;

          /* Get a pointer to the group name. */
          lpT = (LPTSTR) *lpwCmd++;

          VerbosePrint (("CreateGroup received: %S", lpT));

          if (cParm == 3) {
              // skip group file parameter
              lpwCmd++;
          }


          if (cParm > 1) {
              //
              // Test if the 2nd parameter is a groupfile name or the
              // common group flag
              //

              if (IsParameterANumber((LPTSTR)*lpwCmd)) {

                  // get the common group flag
                  if ((nCommonGrp = myatoi((LPTSTR) *lpwCmd++)) &&
                                              !AccessToCommonGroups)
                      goto DEHErrExit;

              }
              else {
                  lpwCmd++;
              }
          }

          /* Search for the group... if it already exists, activate it. */
          hwndT = GetWindow(hwndMDIClient, GW_CHILD);
          while (hwndT) {
              /* Skip icon titles. */
              if (!GetWindow(hwndT, GW_OWNER)) {

                  /* Compare the group title with the request. */
                  pGroup = (PGROUP)GetWindowLongPtr(hwndT, GWLP_PGROUP);
                  if (lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup)) {

                      lpGroupName = (LPTSTR) PTR(lpgd, lpgd->pName);
                      GlobalUnlock(pGroup->hGroup);
                      if (!lstrcmpi(lpT, lpGroupName)) {
                          BOOL bContinueSearch = TRUE;

                          //
                          // First case is the app didn't request
                          // a specific type of group.
                          //

                          if (nCommonGrp == -1) {

                              //
                              // If the user has access to
                              // common groups (thus also has
                              // access to personal groups), or
                              // the existing group is personal,
                              // then we are finished.
                              //

                              if (AccessToCommonGroups || !pGroup->fCommon) {
                                  bContinueSearch = FALSE;
                              }
                          }

                          //
                          // Second case the app requested
                          // a common group match.
                          //

                          else if (nCommonGrp == 1) {

                              //
                              // If user has access to the common groups
                              // and the group found is common, then we
                              // are finished.
                              //

                              if (AccessToCommonGroups && pGroup->fCommon) {
                                  bContinueSearch = FALSE;
                              }
                          }

                          //
                          // Third case is the app requested
                          // a personal group match.
                          //

                          else if (nCommonGrp == 0) {

                              //
                              // Check to see if the group is also
                              // personal.
                              //

                              if (!pGroup->fCommon) {
                                 bContinueSearch = FALSE;
                              }
                          }

                          if (bContinueSearch) {
                              hwndT = GetWindow(hwndT, GW_HWNDNEXT);
                              continue;
                          } else {

                              VerbosePrint (("CreateGroup: Activing group"));
                              BringWindowToTop(hwndT);
                              break;
                          }
                      }
                  }
              }
              hwndT = GetWindow(hwndT, GW_HWNDNEXT);
          }

          /* If we didn't find it, add it. */
          if (!hwndT) {
              TCHAR szTemp[MAXITEMPATHLEN+1];         // Group name.

              //
              // If the app does care what type of group to create,
              // the default is to create a common group if the
              // user has admin privilages.  Otherwise they get a
              // personal group.
              //

              if (nCommonGrp == -1) {

                  if (AccessToCommonGroups) {
                      nCommonGrp = 1;
                  } else {
                      nCommonGrp = 0;
                  }
              }

              lstrcpy(szTemp, lpT);
              VerbosePrint (("CreateGroup: Creating new group"));
              CreateNewGroup(szTemp, (nCommonGrp == 1));
          }

          break;
      }

      case 1:
      {
          INT      cParm;
          WORD      iIconIndex;
          POINT     pt;
          LPPOINT   lppt;
          DWORD     dwFlags = CI_SET_DOS_FULLSCRN;
          BOOL      fMinimize;
          WORD      wHotKey;
          TCHAR      szExpPath[MAXITEMPATHLEN+1];
          TCHAR      szExpDir[MAXITEMPATHLEN+1];
          HICON     hIcon;
    	  TCHAR     szT[MAX_PATH];
	      WORD      id;

          /* [ AddItem (command,name,icopath,index,pointx,pointy,
                            defdir,hotkey,fminimize) ] */
          //
          // pActiveGroup is non NULL when the user
          // has an item or group properties dialog up in
          // progman i.e. the user is working in progman
          // while some other app is doing DDE.
          // We can't have both play on the same group at
          // the same time.
          // johannec 5-13-93 bug 9513
          //
          if (pCurrentGroup == pActiveGroup) {
              PMPrint (("AddItem:  DDE converstation started with the group you have open! Exiting."));
              goto DEHErrExit;
          }

          /* There must be at least a command string. */
          if ((cParm = (INT)*lpwCmd++) < 1) {
              PMPrint (("AddItem:  No command string!"));
              goto DEHErrExit;
          }

          /* Make sure we have a reasonable number of parameters. */
          if (cParm == 5 || cParm > 10) {
              PMPrint (("AddItem:  Not enough or too many parameters!"));
              goto DEHErrExit;
          }

          /* If all else fails, there must be a command string! */
          lpT = (LPTSTR) *lpwCmd++;
          if (!*lpT) {
              PMPrint (("AddItem:  Null pointer for command string!"));
              goto DEHErrExit;
          }

          VerbosePrint (("AddItem:  szPathField = %S", lpT));
          lstrcpy(szPathField, lpT);
          lstrcpy(szExpPath, szPathField);
          DoEnvironmentSubst(szExpPath, CharSizeOf(szExpPath));

          VerbosePrint (("AddItem:  Expanded path = %S", szExpPath));

          StripArgs(szExpPath);

          VerbosePrint (("AddItem:  Path after StripArgs call = %S", szExpPath));

          if (*szExpPath != WCHAR_QUOTE)
            CheckEscapes(szExpPath, CharSizeOf(szExpPath));

          VerbosePrint (("AddItem:  Path after CheckEscapes call = %S", szExpPath));

          /* Look for the name field. */
          szNameField[0] = TEXT('\0');
          if (cParm > 1) {
              /* Get the next parameter. */
              lpT = (LPTSTR)*lpwCmd++;

              if (lstrlen (lpT) > MAXITEMNAMELEN)
                  lpT[MAXITEMNAMELEN] = TEXT('\0');

              lstrcpy(szNameField, lpT);
          }

          /* If none given, generate one from the command. */
          if (szNameField[0] == TEXT('\0')) {
              // NB Use the unexpanded path.
              BuildDescription(szNameField, szPathField);
          }

          VerbosePrint (("AddItem:  Name field will be: %S", szNameField));

          /* Look for the icon's path. */
          szIconPath[0] = TEXT('\0');
          if (cParm > 2) {
              lpT = (LPTSTR)*lpwCmd++;
              lstrcpy(szIconPath,lpT);

              VerbosePrint(("AddItem:  An icon path was given of: %S", szIconPath));
              StripArgs(szIconPath);
              // I am removing this call to CheckEscapes because
              // the filenames could now have quotes around them.
              // This call will automaticly add another set of quotes
              // thus causing the wrong icon to be displayed.
              // ericflo 2/25/94
              //CheckEscapes(szIconPath, CharSizeOf(szIconPath));
              VerbosePrint (("AddItem:  After stripping args the icon path = %S", szIconPath));
          }
          else
              szIconPath[0] = TEXT('\0');

          /* Get the icon index. */
          if (cParm > 3) {
              lpT = (LPTSTR)*lpwCmd++;
              iIconIndex = (WORD)myatoi(lpT);
          }
          else
              iIconIndex = 0;

          if (iIconIndex >= 666) {
              iIconIndex -= 666;
          }
	  else {
	      dwFlags |= CI_ACTIVATE;
	  }

          //
          // If there is no icon path, check if we have an executable associated
          // with the command path.
          //
	  if (!*szIconPath) {
    	      FindExecutable(szExpPath, szExpDir, szT);
    	      if (!*szT) {
        	  dwFlags |= CI_NO_ASSOCIATION;
    	      }
	  }
	  else {
    	      //
    	      // convert the icon index to the icon id which is what progman
    	      // uses.
    	      //
    	      lstrcpy(szT, szIconPath);
    	      id = iIconIndex;
    	      hIcon = ExtractAssociatedIcon(hAppInstance, szT, &id);
    	      if (lstrcmpi(szT, szIconPath)) {
        	  id = iIconIndex;
    	      }
	  }

          VerbosePrint (("AddItem:  Icon index = %d", id));

          /* Get the point :)  Note x cannot be specified alone. */
          if (cParm > 4) {
              lpT = (LPTSTR)*lpwCmd++;
              if (*lpT) {
                  pt.x = myatoi(lpT);
              }
              else {
                  pt.x = -1;
              }
              lpT = (LPTSTR)*lpwCmd++;
              if (*lpT) {
                  pt.y = myatoi(lpT);
              }
              else {
                  pt.x = -1;
              }
              lppt = (LPPOINT)&pt;
          }
          else
              lppt = (LPPOINT)NULL;

          if (fForcePoint) {
              lppt = &ptForce;
              fForcePoint = FALSE;
          }

          /* look to see if there is a default directory
           */
          if (cParm > 6) {
              lpT = (LPTSTR)*lpwCmd++;
              VerbosePrint (("AddItem:  Given this default direcotry: %S", lpT));
              lstrcpy(szDirField, lpT);
              lstrcpy(szExpDir, lpT);
              DoEnvironmentSubst(szExpDir, CharSizeOf(szExpDir));
              StripArgs(szExpDir);
              VerbosePrint(("AddItem:  After expanding and strip args, we have: %S", szExpDir));
          }
          else {
              szDirField[0] = TEXT('\0');
          }

          // If the directory is null then use the path bit
          // of the command line.  (Unexpanded)
          if (!*szDirField) {
              GetDirectoryFromPath(szPathField, szDirField);
              if (*szDirField) {
                 CheckEscapes (szDirField, MAXITEMPATHLEN+1);
              }
          }

          VerbosePrint (("AddItem:  Default directory is: %S", szDirField));

          /* hotkey
           */
          if (cParm > 7) {
              lpT = (LPTSTR)*lpwCmd++;
              wHotKey = (WORD)myatoi(lpT);
          }
          else
              wHotKey = 0;

          /* fminimize
           */
          if (cParm > 8) {
              lpT = (LPTSTR)*lpwCmd++;
              fMinimize = myatoi(lpT);
          }
          else
              fMinimize = FALSE;

          /* fseparateVDM
           */
          if (cParm > 9) {
              lpT = (LPTSTR)*lpwCmd++;
              if (myatoi(lpT)) {
                  dwFlags |= CI_SEPARATE_VDM;
                  VerbosePrint (("AddItem:  Separate VDM flag specified"));
              }
          }

          VerbosePrint (("AddItem: Results passed to CreateNewItem are:"));
          VerbosePrint (("         Name Field = %S", szNameField));
          VerbosePrint (("         Path Field = %S", szPathField));
          VerbosePrint (("         Icon Path  = %S", szIconPath));
          VerbosePrint (("         Dir Field  = %S", szDirField));
          VerbosePrint (("         Hot Key    = %d", wHotKey));
          VerbosePrint (("         Minimize   = %d", fMinimize));
          VerbosePrint (("         id         = %d", id));
          VerbosePrint (("         Icon Index = %d", iIconIndex));
          VerbosePrint (("         Flags      = %lx", dwFlags));


          /* Now add the new item!!! */
          if (!CreateNewItem(pCurrentGroup->hwnd,
                      szNameField, szPathField,
                      szIconPath, szDirField, wHotKey, fMinimize,
                      id, iIconIndex, NULL, lppt, dwFlags))
              goto DEHErrExit;

          // Update scrollbars.
          if ((bAutoArrange) && (!bAutoArranging))
              ArrangeItems(pCurrentGroup->hwnd);
          else if (!bAutoArranging)
              CalcGroupScrolls(pCurrentGroup->hwnd);

          break;
      }

      case 2:
      {
          int cParm;
          BOOL fCommonGrp = FALSE;
          BOOL fCommonDefaulted = FALSE;
          LPTSTR lpGroupName;
          HWND hwndPersGrp = NULL;

          /* [ DeleteGroup (group_name [, common_group_flag] ) ] */

          /*
           * A new optional parameter is added to specify whether to delete
           * a Common group  or a Personal group.
           *     1 for Common Group
           *     0 for Personal Group
           * Only users with administrative rights can create/delete Common
           * groups. The default if this parameter is not specified is:
           *     Common group if user has admin rights
           *     Personal group if not
           */

          /* Make sure that we have 1 or 2 parameter. */
          cParm = (int)*lpwCmd++;

          if ((cParm < 1) || (cParm > 2))
              goto DEHErrExit;

          /* Get a pointer to the group name. */
          lpT = (LPTSTR) *lpwCmd++;

          if (cParm == 2) {
              //
              // Get the common group flag. The User must have Write and
              // Delete access to the common groups.
              //
              if ((fCommonGrp = myatoi((LPTSTR) *lpwCmd++)) &&
                                              !AccessToCommonGroups)
                   goto DEHErrExit;
          }
          else if (AccessToCommonGroups) {
              //
              // The default for a user with Write access rights to the Common
              // Groups is deleting a common group.
              //
              fCommonGrp = TRUE;
              fCommonDefaulted = TRUE;
          }

          /* Search for the group... */
          hwndT = GetWindow(hwndMDIClient, GW_CHILD);
          while (hwndT) {
              /* Skip icon titles. */
              if (!GetWindow(hwndT, GW_OWNER)) {

                  /* Compare the group title with the request. */
                  pGroup = (PGROUP)GetWindowLongPtr(hwndT, GWLP_PGROUP);
                  if (lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup)) {

                      lpGroupName = (LPTSTR) PTR(lpgd, lpgd->pName);
                      GlobalUnlock(pGroup->hGroup);
                      if (!lstrcmpi(lpT, lpGroupName)) {
                          if ((fCommonGrp && !pGroup->fCommon) ||
                              (!fCommonGrp && pGroup->fCommon) ) {

                              //
                              // If the app did not specify common nor personal
                              // group and we defaulted to common group (because
                              // the user is an admin), then don't ignore the
                              // personal group that was found. If no common group
                              // is found, we'll default to the personal group.
                              //  5-7-93 johannec bug ????
                              //
                              if (fCommonGrp && fCommonDefaulted) {
                                  hwndPersGrp = hwndT;
                              }

                              hwndT = GetWindow(hwndT, GW_HWNDNEXT);
                              continue;
                          }
                          //
                          // pActiveGroup is non NULL when the user
                          // has an item or group properties dialog up in
                          // progman i.e. the user is working in progman
                          // while some other app is doing DDE.
                          // We can't have both play on the same group at
                          // the same time.
                          // johannec 5-13-93 bug 9513
                          //
                          if (pGroup == pActiveGroup) {
                              goto DEHErrExit;
                          }
                          DeleteGroup(hwndT);
                          break;
                      }
                  }
              }
              hwndT = GetWindow(hwndT, GW_HWNDNEXT);
          }

          /* If we didn't find it, report the error. */
          if (!hwndT) {
              if (hwndPersGrp) {
                  //
                  // If a personal group was found instead of the common group
                  // delete it.
                  //

                  pGroup = (PGROUP)GetWindowLongPtr(hwndPersGrp, GWLP_PGROUP);

                  //
                  // pActiveGroup is non NULL when the user
                  // has an item or group properties dialog up in
                  // progman i.e. the user is working in progman
                  // while some other app is doing DDE.
                  // We can't have both play on the same group at
                  // the same time.
                  // johannec 5-13-93 bug 9513
                  //
                  if (pGroup == pActiveGroup) {
                      goto DEHErrExit;
                  }
                  DeleteGroup(hwndPersGrp);

              } else {
                  goto DEHErrExit;
              }
          }
          break;
      }

      case 3:
          /* [ ExitProgman (bSaveGroups) ] */

          if (bExitWindows)
              goto DEHErrExit;

          /* Make sure that we have 1 parameter. */
          if (*lpwCmd++ != 1)
              goto DEHErrExit;

          /* Get a pointer to the parm. */
          lpT = (LPTSTR) *lpwCmd++;

          bSaveSettings = FALSE;
          if (*lpT == TEXT('1'))
              WriteINIFile();

          //
          // The 2 is a magic return value inside of the
          // DDEMsgProc routine.
          //

          dwRet = 2;
          goto DEHErrExit;
          break;

      case 4:
      {
          INT cParm;
          int iShowCmd;
          BOOL fCommonGrp = FALSE;
          BOOL fCommonDefaulted = FALSE;
          HWND hwndPersGrp = NULL;
          TCHAR szT[MAXKEYLEN + 1];
          TCHAR szCommonGroupSuffix[MAXKEYLEN + 1];
          WINDOWPLACEMENT wp;

          /* [ ShowGroup (group_name, wShowParm [, fCommonGroup] ) ] */

          /*
           * A new optional parameter is added to specify whether to show
           * a Common group  or a Personal group.
           *     1 for Common Group
           *     0 for Personal Group
           * Only users with administrative rights can create/delete Common
           * groups. The default if this parameter is not specified is:
           *     Common group if user has admin rights
           *     Personal group if not
           */

          /* Make sure that we have 2 or 3 parameters. */
          cParm = (INT)*lpwCmd++;
          if ((cParm < 2) || (cParm > 3))
              goto DEHErrExit;

          /* Get a pointer to the group name. */
          lpT = (LPTSTR) *lpwCmd++;

          VerbosePrint (("ShowGroup:  Called with %S", lpT));

          iShowCmd = myatoi((LPTSTR) *lpwCmd++);

          if (cParm == 3) {
              //
              // get the common group flag
              //
              fCommonGrp = myatoi((LPTSTR) *lpwCmd++);
          }
          else if (AccessToCommonGroups) {
              //
              // The default for a user with administrative rights is Common
              // Groups.
              //
              fCommonGrp = TRUE;
              fCommonDefaulted = TRUE;
          }

          /* Search for the group... */
          hwndT = GetWindow(hwndMDIClient, GW_CHILD);
          while (hwndT) {
              //
              // Skip icon titles.
              //
              if (GetWindow(hwndT, GW_OWNER)) {
                   hwndT = GetWindow(hwndT, GW_HWNDNEXT);
                   continue;
              }

              /* Compare the group title with the request. */
              pGroup = (PGROUP)GetWindowLongPtr(hwndT, GWLP_PGROUP);
              if (lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup)) {

                  lstrcpy(szT, (LPTSTR) PTR(lpgd, lpgd->pName));
                  GlobalUnlock(pGroup->hGroup);
                  if (!lstrcmpi(lpT, szT)) {

                      if ((fCommonGrp && !pGroup->fCommon) ||
                          (!fCommonGrp && pGroup->fCommon) ) {
                          //
                          // If the app did not specify common nor personal
                          // group and we defaulted to common group (because
                          // the user is an admin), then don't ignore the
                          // personal group that was found. If no common group
                          // is found, we'll default to the personal group.
                          //  5-7-93 johannec bug ????
                          //
                          if (fCommonGrp && fCommonDefaulted) {
                              hwndPersGrp = hwndT;
                          }

                          hwndT = GetWindow(hwndT, GW_HWNDNEXT);
                          continue;
                      }
                      ShowWindow(hwndT, iShowCmd);
                      //
                      // if the group is common and not being minimized
                      // then must add the common suffix to the group
                      // window title. If the group is being minimized
                      // then make sure the common suffix is not there.
                      //
                      if (fCommonGrp) {
                          wp.length = sizeof(WINDOWPLACEMENT);
                          GetWindowPlacement(hwndT, &wp);
                          if (wp.showCmd != SW_SHOWMINIMIZED &&
                              wp.showCmd != SW_MINIMIZE &&
                              wp.showCmd != SW_SHOWMINNOACTIVE ) {
                              LoadString(hAppInstance, IDS_COMMONGRPSUFFIX,
                                             szCommonGroupSuffix,
                                             CharSizeOf(szCommonGroupSuffix));
                              lstrcat(szT, szCommonGroupSuffix);
                          }
                          SetWindowText(hwndT, szT);
                      }
                      SendMessage(hwndT, WM_ACTIVATE, 1, 0);
                      break;
                  }
              }
              hwndT = GetWindow(hwndT, GW_HWNDNEXT);
          }

          /* If we didn't find it, report the error. */
          if (!hwndT) {
              if (hwndPersGrp) {
                  //
                  // If a personal group was found instead of the common group
                  // show it.
                  //
                  ShowWindow(hwndPersGrp, iShowCmd);
                  SendMessage(hwndPersGrp, WM_ACTIVATE, 1, 0);
              }
              else {
                  goto DEHErrExit;
              }
          }
          break;
      }
      case 6:

          /* [ ReplaceItem (item_name) ] */
          fForcePoint = TRUE;
          ptForce.x = -1;     // in case we don't really find the item
          ptForce.y = -1;

          /* fall thru */

      case 5:
      {
          PITEM pItem;
          LPITEMDEF lpid;

          /* [ DeleteItem (item_name) ] */

          //
          // pActiveGroup is non NULL when the user
          // has an item or group properties dialog up in
          // progman i.e. the user is working in progman
          // while some other app is doing DDE.
          // We can't have both play on the same group at
          // the same time.
          // johannec 5-13-93 bug 9513
          //
          if (pCurrentGroup == pActiveGroup) {
              goto DEHErrExit;
          }

          /* exactly one parameter
           */
          if (*lpwCmd++ != 1)
              goto DEHErrExit;

          lpT = (LPTSTR) *lpwCmd++;

          lpgd = LockGroup(pCurrentGroup->hwnd);
          if (!lpgd)
              goto DEHErrExit;

          for (pItem = pCurrentGroup->pItems; pItem; pItem = pItem->pNext) {
              lpid = ITEM(lpgd,pItem->iItem);
              if (!lstrcmpi((LPTSTR) PTR(lpgd, lpid->pName),lpT)) {
                  ptForce.x = pItem->rcIcon.left;
                  ptForce.y = pItem->rcIcon.top;
                  UnlockGroup(pCurrentGroup->hwnd);
                  DeleteItem(pCurrentGroup,pItem);
                  break;
              }
          }
          if (!pItem) {
              UnlockGroup(pCurrentGroup->hwnd);
              goto DEHErrExit;
          }

          break;
      }

      case 7:
      {
          int cParm;
          BOOL fAll;
          BOOL fCommonGrp = FALSE;

          /* [ Reload [(groupname [, common_group_flag] )] ] */

          /*
           * A new optional parameter is added to specify whether to reload
           * a Common group  or a Personal group.
           *     1 for Common Group
           *     0 for Personal Group
           * Only users with administrative rights can create/delete Common
           * groups. The default if this parameter is not specified is:
           *     Common group if user has admin rights
           *     Personal group if not
           */

          cParm = (int)*lpwCmd++;

          if (!cParm)
              fAll = TRUE;
          else if ((cParm == 1) || (cParm == 2))
              fAll = FALSE;
          else
              goto DEHErrExit;

          if (fAll) {
              HWND hwndT;

              ShowWindow(hwndMDIClient, SW_HIDE);
              ValidateRect(hwndProgman,NULL);

              /* unload all the groups!
               */
              for (hwndT = GetWindow(hwndMDIClient, GW_CHILD);
                   hwndT;
                   hwndT = GetWindow(hwndMDIClient, GW_CHILD)) {

                  /* Skip icon titles. */
                  while (GetWindow(hwndT, GW_OWNER)) {
                      hwndT = GetWindow(hwndT,GW_HWNDNEXT);
                      if (!hwndT)
                          break;
                  }

                  if (hwndT)
                      UnloadGroupWindow(hwndT);
              }

              LoadAllGroups();
              ShowWindow(hwndMDIClient,SW_SHOW);
          }
          else {
              TCHAR szT[120];
              WORD idGroup;
              HWND hwndT;

              /* get the name to reload
               */
              lpT = (LPTSTR) *lpwCmd++;

              if (cParm == 2) {
                  //
                  // Get the common group flag. The User must have Write
                  // access to the reload common groups.
                  //
                  if ((fCommonGrp = myatoi((LPTSTR) *lpwCmd++)) &&
                                              !AccessToCommonGroups)
                      goto DEHErrExit;
              }
              else if (AccessToCommonGroups) {
                  //
                  // The default for a user with administrative rights is Common
                  // Groups.
                  //
                  fCommonGrp = TRUE;
              }

              /* search for it
               */
              for (hwndT = GetWindow(hwndMDIClient, GW_CHILD);
                   hwndT;
                   hwndT = GetWindow(hwndT, GW_HWNDNEXT)) {

                  /* Skip icon titles. */
                  if (GetWindow(hwndT, GW_OWNER))
                      continue;

                  /* Compare the group title with the request. */
                  pGroup = (PGROUP)GetWindowLongPtr(hwndT, GWLP_PGROUP);
                  if (lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup)) {

                      lstrcpy(szT, (LPTSTR) PTR(lpgd, lpgd->pName));
                      GlobalUnlock(pGroup->hGroup);

                      if (lstrcmpi(lpT, szT))
                          continue;

                      if ((fCommonGrp && !pGroup->fCommon) ||
                          (!fCommonGrp && pGroup->fCommon) )
                          continue;

                      /* we found the group.  Unload and reload it.
                       */
                      lstrcpy(szT,pGroup->lpKey);
                      idGroup = pGroup->wIndex;
                      UnloadGroupWindow(hwndT);
                      LoadGroupWindow(szT, idGroup, fCommonGrp);
                      break;
                  }
              }
              if (!hwndT)
                  goto DEHErrExit;
          }
          break;
      }

      default:
          goto DEHErrExit;
      }
  }

  /* 't all woiked! */
  dwRet = 1;

DEHErrExit:
  GlobalUnlock(hCmd);
  GlobalFree(hCmd);

DEHErrExit1:
  GlobalUnlock(hString);

  bInDDE = FALSE;

  return dwRet;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InitRespond() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL APIENTRY InitRespond( HANDLE hWnd, WPARAM wParam, LPARAM lParam,
                           LPTSTR szApp, LPTSTR szTopic,
                           BOOL fBCReply       // Whether or not to reply to a broadcast message.
                                               // ie a null app string.
                           )
{
    HWND hwndDDE = NULL;
    ATOM atom1, atom2;
    DWORD dwType;

    atom1 = GlobalAddAtom(szApp);
    atom2 = GlobalAddAtom(szTopic);

    if ((!LOWORD(lParam) && fBCReply) || LOWORD(lParam) == atom1) {
        if (!HIWORD(lParam) || HIWORD(lParam) == atom2) {

            if (!lstrcmp(szApp, szProgman)) {  // use Progman's main hwnd
                dwType = DDE_PROGMAN;
                if (IsDdeConversation(hWnd, (HWND)wParam, DDE_PROGMAN)) {
                    MPostWM_DDE_TERMINATE((HWND)wParam, hWnd);
                    hwndDDE = CreateWindow(szProgmanDDE, NULL, WS_CHILD, 0, 0, 0, 0,
                                   hwndProgman, NULL, hAppInstance, NULL);
                }
                else {
                    // use Progman's hwnd for the first DDE conversation
                    hwndDDE = hWnd;
                }
            } else if (!lstrcmp(szApp, szShell)) {
                if (!lstrcmp(szTopic, szAppIcon)) {
                    if (IsDdeConversation(hWnd, (HWND)wParam, APP_ICON)) {
                        return(TRUE);
                    }
                    dwType = APP_ICON;
                    hwndDDE = CreateWindow(szAppIconDDE, NULL, WS_CHILD, 0, 0, 0, 0,
                                   hwndProgman, NULL, hAppInstance, NULL);
                }
                else if (!lstrcmp(szTopic, szAppDesc)) {
                    if (IsDdeConversation(hWnd, (HWND)wParam, APP_DESC)) {
                        return(TRUE);
                    }
                    dwType = APP_DESC;
                    hwndDDE = CreateWindow(szAppDescDDE, NULL, WS_CHILD, 0, 0, 0, 0,
                                   hwndProgman, NULL, hAppInstance, NULL);
                }
                else if (!lstrcmp(szTopic, szAppWDir)) {
                    if (IsDdeConversation(hWnd, (HWND)wParam, APP_WDIR)) {
                        return(TRUE);
                    }
                    dwType = APP_WDIR;
                    hwndDDE = CreateWindow(szAppWDirDDE, NULL, WS_CHILD, 0, 0, 0, 0,
                                   hwndProgman, NULL, hAppInstance, NULL);
                }
            }

            //
            // For compatibility reasons, allow Shell - AppProperties DDE
            // connection.
            //
            if (!lstrcmp(szApp, szShell) &&
                          !lstrcmp(szTopic, szAppProperties) ) {  // use Progman's main hwnd
                dwType = DDE_PROGMAN;
                if (IsDdeConversation(hWnd, (HWND)wParam, DDE_PROGMAN)) {
                    MPostWM_DDE_TERMINATE((HWND)wParam, hWnd);
                    hwndDDE = CreateWindow(szProgmanDDE, NULL, WS_CHILD, 0, 0, 0, 0,
                                   hwndProgman, NULL, hAppInstance, NULL);
                }
                else {
                    // use Progman's hwnd for the first DDE conversation
                    hwndDDE = hWnd;
                }
            }

            if (hwndDDE) {
                SendMessage((HWND)wParam, WM_DDE_ACK, (WPARAM)hwndDDE,
                                                 MAKELONG(atom1, atom2));
                AddDdeConversation(hwndDDE, (HWND)wParam, dwType);
                return(TRUE);
            }
        }
    }
    /*
     * No message sent or
     * Destination won't accept the ACK and so didn't delete
     * the atoms we provided - so we must do it.
     */
//    GlobalDeleteAtom(atom1);
//    GlobalDeleteAtom(atom2);
    return(FALSE);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GroupRequest() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID APIENTRY GroupRequest(HWND hWnd, HWND hwndClient, ATOM fmt, ATOM aItem)
{
    DWORD     cb;
    LPTSTR     lpT;
    register HANDLE   hT;
    register PGROUP   pGroup;
    HANDLE hReAlloc;
    LPGROUPDEF lpgd;

    if (fmt != CF_TEXT && fmt != CF_UNICODETEXT) {
        DDEFail(hWnd, hwndClient, aItem);
        return;
    }

    /*sizeof (WORD) ok, as hT becomes lpT which is LPSTR*/
    cb = 2 * sizeof(WORD) + 2;
    hT = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cb);
    if (!hT) {
        DDEFail(hWnd,hwndClient,aItem);
        return;
    }

    /* Ask the client to release the data and inform him that this
     * is in response to a request message.  Clipboard format is
     * plain text.
     */
    lpT = (LPTSTR)GlobalLock(hT);
    ((WORD FAR *)lpT)[0] = 3 << 12;
    ((WORD FAR *)lpT)[1] = CF_TEXT;
    ((WORD FAR *)lpT)[2] = 0;
    GlobalUnlock(hT);

    /* Go through the list of groups appending the name of each
     * group as a line in the shared memory item.
     */
    for (pGroup=pFirstGroup; pGroup; pGroup = pGroup->pNext) {
        lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

        cb += sizeof(TCHAR) * (2 + lstrlen( (LPTSTR)PTR(lpgd, lpgd->pName) ));
        if (!(hReAlloc = GlobalReAlloc(hT, cb, GMEM_MOVEABLE))) {
            GlobalFree(hT);
            DDEFail(hWnd,hwndClient,aItem);
            return;
        }
        hT = hReAlloc;

        /*sizeof (WORD) ok, as hT becomes lpT which is LPSTR*/
        lpT = (LPTSTR)((LPSTR)GlobalLock(hT) + 2 * sizeof(WORD));
        lpT += lstrlen(lpT);
        /* we've already allocated it to be large enough...
         */
        //
        // The title may contain ' (Common)' at the end if the group is a
        // common group. So get the group title from the group itself not
        // from the window title.
        //
        lstrcpy(lpT, (LPTSTR)PTR(lpgd, lpgd->pName));
        lstrcat(lpT, TEXT("\r\n"));
        GlobalUnlock(pGroup->hGroup);
        GlobalUnlock(hT);
    }

    if (fmt == CF_TEXT) {
        LPSTR lpMultiByteStr = NULL;
        int cchMultiByte = 0;
        HANDLE hMultiByte;

        // convert the string to Ansi
        lpT = GlobalLock(hT) ;
        cchMultiByte = WideCharToMultiByte(CP_ACP, 0,
                    (LPTSTR)((LPBYTE)lpT+ 2*sizeof(WORD)), -1,
                    lpMultiByteStr, cchMultiByte, NULL, NULL);

        hMultiByte = GlobalAlloc(GMEM_MOVEABLE,(++cchMultiByte) + 2 * sizeof(WORD));
        lpMultiByteStr = GlobalLock(hMultiByte);

        ((WORD FAR *)lpMultiByteStr)[0] = 3 << 12;
        ((WORD FAR *)lpMultiByteStr)[1] = CF_TEXT;
        WideCharToMultiByte(CP_ACP, 0,
                            (LPTSTR)((LPBYTE)lpT+ 2*sizeof(WORD)), -1,
                             (LPSTR)(lpMultiByteStr + 2 * sizeof(WORD)),
                             cchMultiByte, NULL, NULL);

        GlobalUnlock(hMultiByte);
        GlobalUnlock(hT);
        GlobalFree(hT);
        hT = hMultiByte;

    }
    MPostWM_DDE_DATA(hwndClient, hWnd, hT, aItem);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindIconProp() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

extern ULONG Color16Palette[];
extern ULONG Color256Palette[];

VOID APIENTRY FindIconProp(HWND hWnd, WPARAM wParam, LPARAM lParam, WORD iProp)
{
    PGROUP pGroup;
    PITEM pItem;
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    UINT uiMsg = WM_DDE_ACK;
    HANDLE hData;
    DDEDATA FAR * lpdd;
    WORD cb;
    NEWICONDATA FAR * lpIconData;
    LPBYTE lpS;
    LPBYTE lpD;
    HWND hwndT;
    TCHAR szCommand[MAXITEMPATHLEN+1];
    TCHAR szDefDir[2 * (MAXITEMPATHLEN+1)];
    ATOM aItem;    // the app.'s id for which the info. is requested.
    TCHAR szId[16]; //to extract the id from the atom.
    DWORD dwId;
    PBITMAPINFOHEADER pbih, pbihNew;
    DWORD colors;
    LPVOID palette;

    if (fInExec) {
        /* we are inside the exec call!  it must have come from the
         * current icon!
         */
        pGroup = pCurrentGroup;
        pItem = pGroup->pItems;
        goto GotIt;
    }

    /* use the mdi window list to get the z-order */
    aItem = HIWORD(lParam);
    if (!GlobalGetAtomName(aItem, (LPTSTR)szId, 16))
        goto Fail;
    dwId = MyAtoi((LPTSTR)szId);
    if (!dwId) {
        goto Fail;
    }

    for (hwndT=GetWindow(hwndMDIClient, GW_CHILD); hwndT; hwndT=GetWindow(hwndT, GW_HWNDNEXT)) {
        if (GetWindow(hwndT, GW_OWNER))
    	  continue;

      	pGroup = (PGROUP)GetWindowLongPtr(hwndT, GWLP_PGROUP);

        for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext) {
            if (pItem->dwDDEId == dwId) {
                goto GotIt;
            }
        }
    }

Fail:
    /* didn't find it; fail
     */
    MPostDDEMsg((HWND)wParam, uiMsg, hWnd, (UINT)0, (UINT)aItem);
    return;

GotIt:
    /* from now on, we say use default instead of not me
     */
    uiMsg = WM_DDE_DATA;

    lpgd = LockGroup(pGroup->hwnd);
    if (!lpgd)
        goto Fail;

    lpid = ITEM(lpgd,pItem->iItem);

    switch (iProp) {

    case APP_ICON:
        cb = (WORD)(sizeof(NEWICONDATA) + lpid->cbIconRes);
        pbih = (PBITMAPINFOHEADER)PTR(lpgd, lpid->pIconRes);
        if (pbih->biClrUsed == -1) {
            colors = (1 << (pbih ->biPlanes * pbih->biBitCount));
            if (colors == 16 || colors == 256) {
                cb += (WORD)(colors * sizeof(RGBQUAD));
            }
        }
        break;

    case APP_DESC:
        cb = (WORD)(sizeof(DDEDATA) + sizeof(TCHAR)*lstrlen((LPTSTR) PTR(lpgd, lpid->pName)));
        break;

    case APP_WDIR:
        GetItemCommand(pGroup, pItem, szCommand, szDefDir);
        cb = (WORD)(sizeof(DDEDATA) + sizeof(TCHAR)*lstrlen(szDefDir));
        break;

    default:
        goto Fail;
    }

    hData = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE | GMEM_ZEROINIT,
            (DWORD)cb);
    if (!hData) {
        UnlockGroup(pGroup->hwnd);
        goto Fail;
    }

    lpdd = (DDEDATA FAR *)GlobalLock(hData);
    if (!lpdd) {
        GlobalFree(hData);
        UnlockGroup(pGroup->hwnd);
        goto Fail;
    }
    lpdd->fResponse = TRUE;
    lpdd->fRelease = TRUE;
    lpdd->cfFormat = CF_TEXT;

    switch (iProp) {
    case APP_ICON:
    	if ((short)lpid->cbIconRes <= 0) {
            // This icon is toast.
            GlobalUnlock(hData);
            UnlockGroup(pGroup->hwnd);
            goto Fail;
        }

        lpIconData = (NEWICONDATA FAR *)lpdd;

        lpIconData->dwResSize = (DWORD)lpid->cbIconRes;
        //lpIconData->dwVer = lpid->dwIconVer;
        lpIconData->dwVer = (lpid->wIconVer == 2) ? 0x00020000 : 0x00030000;

        lpD = (LPBYTE)&(lpIconData->iResource);
        lpS = (LPBYTE)PTR(lpgd, lpid->pIconRes);
        cb = lpid->cbIconRes;
        if ((pbih->biClrUsed == -1) && (colors == 16 || colors == 32)) {
            if (colors == 16) {
                palette = Color16Palette;
            } else if (colors == 256) {
                palette = Color256Palette;
            }

            pbihNew = (PBITMAPINFOHEADER)lpD;
            RtlCopyMemory(pbihNew, pbih, sizeof( *pbih ));
            pbihNew->biClrUsed = 0;
            RtlCopyMemory((pbihNew+1), palette, colors * sizeof(RGBQUAD));
            RtlCopyMemory((PCHAR)(pbihNew+1) + (colors * sizeof(RGBQUAD)),
                          (pbih+1),
                          lpid->cbIconRes - sizeof(*pbih)
                         );
        } else {
            while (cb--) {
                *lpD++ = *lpS++;
            }
        }

        break;

    case APP_DESC:
        lstrcpy((LPTSTR)lpdd->Value,(LPTSTR) PTR(lpgd, lpid->pName));
        break;

    case APP_WDIR:
        lstrcpy((LPTSTR)lpdd->Value,szDefDir);
        break;
    }

    GlobalUnlock(hData);
    UnlockGroup(pGroup->hwnd);

    if (!MPostWM_DDE_DATA((HWND)wParam, hWnd, hData, (ATOM)aItem)){
        GlobalFree(hData);
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindIconPath() -                                                        */
/*     In NT groups the icon path is not stored when it is not specified by */
/*     the user when the item is created. For DDE requests on groups, the   */
/*     icon path needs to be returned. This function will determine the     */
/*     icon path the way it first find the icon.                            */
/*  9/17/93 JOhannec
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID FindIconPath(
    LPTSTR szPathField,
    LPTSTR szDirField,
    LPTSTR szIconPath
    )
{
    TCHAR szIconExe[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    HICON hIcon;
    WORD wIconIndex;
    WORD wIconId;

    lstrcpy(szIconExe, szPathField);
    DoEnvironmentSubst(szIconExe, CharSizeOf(szIconExe));
    StripArgs(szIconExe);
    TagExtension(szIconExe, sizeof(szIconExe));
    if (*szIconExe == TEXT('"') && *(szIconExe + lstrlen(szIconExe)-1) == TEXT('"')) {
        SheRemoveQuotes(szIconExe);
    }

        //
        // if it's a relative path, extractassociatedicon and LoadLibrary don't
        // handle that so find the executable first
        //
        SetCurrentDirectory(szOriginalDirectory);
        FindExecutable(szIconExe, szDirField, szTemp);
        if (*szTemp) {
            lstrcpy(szIconExe, szTemp);
            TagExtension(szIconExe, sizeof(szIconExe));
            if (*szIconExe == TEXT('"') && *(szIconExe + lstrlen(szIconExe)-1) == TEXT('"')) {
		       SheRemoveQuotes(szIconExe);
	        }
        }
        else {
            *szIconExe = 0;    // Use a dummy value so no icons will be found
                               // and progman's item icon will be used instead
                               // This is to make moricons.dll item icon be the
                               // right one.  -johannec 6/4/93
        }
        //
        // reset the current directory to progman's working directory i.e. Windows directory
        //
        SetCurrentDirectory(szWindowsDirectory);

        wIconIndex = 0;
        hIcon = ExtractAssociatedIconEx(hAppInstance, szIconExe, &wIconIndex, &wIconId);
        if (hIcon)
            DestroyIcon(hIcon);

        lstrcpy(szIconPath, szIconExe);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddStringToSeg() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL APIENTRY AddStringToSeg(LPHANDLE lphT, LPINT lpcb, LPTSTR lpsz, WORD wT, BOOL fCR)
{
    TCHAR szT[10];
    INT cb;
    LPTSTR lp;
    HANDLE hReAlloc;

    if (!lpsz) {
        wsprintf(szT,TEXT("%d"),wT);
        lpsz = szT;
        wT = (WORD)0;
    }

    cb = sizeof(TCHAR) * (lstrlen(lpsz) + (wT ? 2 : 0) + (fCR ? 2 : 1));
    if (!(hReAlloc = GlobalReAlloc(*lphT,*lpcb+cb,GMEM_MOVEABLE|GMEM_ZEROINIT))) {
        GlobalFree(*lphT);
        return FALSE;
    }
    else {
        *lphT = hReAlloc;
    }

    lp = (LPTSTR)((LPSTR)GlobalLock(*lphT) + *lpcb - 2);   // this is to go before the null byte
    if (wT)
        *lp++ = TEXT('"');

    lstrcpy(lp,lpsz);
    lp += lstrlen(lp);
    if (wT)
        *lp++ = TEXT('"');

    if (fCR) {
        *lp++ = TEXT('\r');
        *lp++ = TEXT('\n');
    }
    else
        *lp++ = TEXT(',');
    *lp = 0;
    GlobalUnlock(*lphT);

    *lpcb += cb;

    return TRUE;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DumpGroup() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/
VOID APIENTRY DumpGroup(HWND hwnd, ATOM aName, HWND hwndConv, WORD cfFormat)
{
    HWND hwndGroup;
    PGROUP pGroup;
    PITEM pItem;
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    WORD i;
    INT cb;
    HANDLE hT;
    LPTSTR lpT;
    INT state;
    BOOL fActivated;

    if (cfFormat != CF_TEXT && cfFormat != CF_UNICODETEXT)
        goto Fail;

    for (hwndGroup = GetWindow(hwndMDIClient,GW_CHILD);
         hwndGroup;
         hwndGroup = GetWindow(hwndGroup,GW_HWNDNEXT)) {
        if (GetWindow(hwndGroup,GW_OWNER))
            continue;

        lpgd = LockGroup(hwndGroup);
        if (!lpgd)
            goto Fail;

        if (aName == GlobalFindAtom((LPTSTR) PTR(lpgd, lpgd->pName)))
            goto FoundGroup;
        UnlockGroup(hwndGroup);
    }

Fail:
#ifdef ORGCODE
    DDEFail(hwnd,hwndConv,MAKELONG(cfFormat,aName));
#else
    DDEFail(hwnd, hwndConv, aName);
#endif
    return;

FoundGroup:
    pGroup = (PGROUP)GetWindowLongPtr(hwndGroup,GWLP_PGROUP);

        /*sizeof (WORD) ok, as hT becomes lpT which is LPSTR*/
    cb = 2 * sizeof(WORD) + 2;
    hT = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cb);
    if (!hT)
        goto Fail;

    /* Ask the client to release the data and inform him that this
     * is in response to a request message.  Clipboard format is
     * plain text.
     */
    lpT = (LPTSTR)GlobalLock(hT);
    ((WORD FAR *)lpT)[0] = 3 << 12;
    ((WORD FAR *)lpT)[1] = CF_TEXT;
    ((WORD FAR *)lpT)[2] = 0;
    GlobalUnlock(hT);

    /* the first line is group properties
     */
    if (!AddStringToSeg(&hT,&cb,(LPTSTR) PTR(lpgd, lpgd->pName),TRUE,FALSE))
        goto Fail;

#if 1
// don't allow apps to know the group key.

//
// change 2-21-93 johannec
// for compatibilty reasons we must privide the group filename which
// doesn't mean anything in NT so we provide the key name instad.
    if (!AddStringToSeg(&hT,&cb,pGroup->lpKey, FALSE, FALSE))
        goto Fail;
#endif

    /* put the number of items in
     */
    for (i = 0, pItem = pGroup->pItems; pItem; pItem = pItem->pNext)
        i++;

#if 1
    if (!AddStringToSeg(&hT,&cb,NULL,i,FALSE))
    	goto Fail;

    // Return the window state as a SW_ value.
    // REVIEW not all SW_ values are supported.
    // It would be nice if there was some way to query a SW_ value
    // but I guess it would too much to ask for windows to be even remotely
    // orthogonal.  I don't know who "designed" the Windows API but it
    // really is the worst windowing system I have ever used.
    // Luckily orthogonality doesn't affect stock prices :-)
    state = SW_SHOWNORMAL;

    if (pGroup == pCurrentGroup) {
        fActivated = TRUE;
    }
    else {
        fActivated = FALSE;
    }

    if (IsZoomed(hwndGroup)) {
        // Maxed.
        state = SW_SHOWMAXIMIZED;
    }
    else if (IsIconic(hwndGroup)) {
        // Minned.
        if(fActivated)
            state = SW_SHOWMINIMIZED;
        else
            state = SW_SHOWMINNOACTIVE;
    }
    else {
        // It's normal.
        if(fActivated)
            state = SW_SHOWNORMAL;
        else
            state = SW_SHOWNOACTIVATE;
    }

    // Give info on the state.
    if (!AddStringToSeg(&hT,&cb,NULL,(WORD)state, FALSE))
    	goto Fail;
#else
    if (!AddStringToSeg(&hT,&cb,NULL,i,FALSE))
	    goto Fail;
#endif

    if (!AddStringToSeg(&hT,&cb,NULL,(WORD)pGroup->fCommon,TRUE))
        goto Fail;


    /* each additional line is an item
     */
    for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext) {

        lpid = ITEM(lpgd,pItem->iItem);

        /* name
         */
        if (!AddStringToSeg(&hT, &cb, (LPTSTR) PTR(lpgd, lpid->pName), TRUE, FALSE))
            goto Fail;

        /* command line and default directory
         */
        GetItemCommand(pGroup, pItem, szPathField, szDirField);
        if (!AddStringToSeg(&hT, &cb, szPathField, TRUE, FALSE))
            goto Fail;
        if (!AddStringToSeg(&hT, &cb, szDirField, FALSE, FALSE))
            goto Fail;

        /* icon path
         */
        if (!*(LPTSTR)PTR(lpgd, lpid->pIconPath)) {
            FindIconPath(szPathField, szDirField, szIconPath);
        }
        else {
            lstrcpy(szIconPath, (LPTSTR) PTR(lpgd, lpid->pIconPath));
        }
        if (!AddStringToSeg(&hT, &cb, szIconPath, FALSE, FALSE))
            goto Fail;

        /* x-y coordinates
         */
        if (!AddStringToSeg(&hT, &cb, NULL, (WORD)pItem->rcIcon.left, FALSE))
            goto Fail;

        if (!AddStringToSeg(&hT, &cb, NULL, (WORD)pItem->rcIcon.top, FALSE))
            goto Fail;

        /* icon, hotkey, fminimize
         */
        if ((SHORT)lpid->wIconIndex >= 0) {
            //
            // apps requesting group info are expecting icon index not icon id.
            //
            if (!AddStringToSeg(&hT, &cb, NULL, lpid->wIconIndex,FALSE))
                goto Fail;
        }
        else {
            if (!AddStringToSeg(&hT, &cb, NULL, lpid->iIcon, FALSE))
                goto Fail;
        }

        if (!AddStringToSeg(&hT,&cb,NULL,GroupFlag(pGroup,pItem,(WORD)ID_HOTKEY),FALSE))
            goto Fail;

        if (!AddStringToSeg(&hT,&cb,NULL,GroupFlag(pGroup,pItem,(WORD)ID_MINIMIZE),FALSE))
            goto Fail;

        if (!AddStringToSeg(&hT,&cb,NULL,GroupFlag(pGroup,pItem,(WORD)ID_NEWVDM),TRUE))
            goto Fail;
    }

#ifdef ORGCODE
    PostMessage(hwndConv, WM_DDE_DATA, hwnd, MAKELONG(hT,cfFormat));
#else
    if (cfFormat == CF_TEXT) {
        LPSTR lpMultiByteStr = NULL;
        int cchMultiByte = 0;
        HANDLE hMultiByte;

	    // convert the string to Ansi
        lpT = GlobalLock(hT) ;
        cchMultiByte = WideCharToMultiByte(CP_ACP, 0,
                    (LPTSTR)((LPBYTE)lpT+ 2*sizeof(WORD)), -1,
                    lpMultiByteStr, cchMultiByte, NULL, NULL);

        hMultiByte = GlobalAlloc(GMEM_MOVEABLE,(++cchMultiByte) + 2 * sizeof(WORD));
        lpMultiByteStr = GlobalLock(hMultiByte);

        ((WORD FAR *)lpMultiByteStr)[0] = 3 << 12;
        ((WORD FAR *)lpMultiByteStr)[1] = CF_TEXT;
        WideCharToMultiByte(CP_ACP, 0,
                            (LPTSTR)((LPBYTE)lpT+ 2*sizeof(WORD)), -1,
                             (LPSTR)(lpMultiByteStr + 2 * sizeof(WORD)),
                             cchMultiByte, NULL, NULL);

	    GlobalUnlock(hMultiByte);
        GlobalUnlock(hT);
        GlobalFree(hT);
        hT = hMultiByte;


    }
    MPostWM_DDE_DATA(hwndConv, hwnd, hT, (ATOM)aName);
#endif

}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DDEMsgProc() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LRESULT APIENTRY DDEMsgProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg) {
    // should go in ProgmanWndProc
    case WM_DDE_INITIATE:
        //
        // HACK: returning 1 if the WM_DDE_ACK was sent successfully in
        // InitRespond is NOT part of the DDE Protocol BUT for backward
        // compatability with WIndows3.0 and 3.1 this solves
        // some problems with WOW apps' setup.
        //

#ifdef DEBUG_PROGMAN_DDE
        {
        TCHAR szDebug[300];

        wsprintf (szDebug, TEXT("%d   PROGMAN:   Received WM_DDE_INITIATE\r\n"),
                  GetTickCount());
        OutputDebugString(szDebug);
        }
#endif

        if (InitRespond(hWnd,wParam,lParam,szShell,szAppIcon, TRUE))
            return(1L);
        if (InitRespond(hWnd,wParam,lParam,szShell,szAppDesc, TRUE))
            return(1L);
        if (InitRespond(hWnd,wParam,lParam,szShell,szAppWDir, TRUE))
            return(1L);
//      InitRespond(hWnd,wParam,lParam,szShell,szSystem, TRUE);
        if (InitRespond(hWnd,wParam,lParam,szProgman,szProgman, FALSE)) {
#ifdef DEBUG_PROGMAN_DDE
            {
            TCHAR szDebug[300];

            wsprintf (szDebug, TEXT("%d   PROGMAN:   Received WM_DDE_INITIATE.  return 1\r\n"),
                      GetTickCount());
            OutputDebugString(szDebug);
            }
#endif
            return(1L);
        }
        //
        // For compatibility reasons, allow Shell - AppProperties DDE
        // connection
        //
        if (InitRespond(hWnd,wParam,lParam,szShell,szAppProperties, TRUE))
            return(1L);

#ifdef DEBUG_PROGMAN_DDE
        {
        TCHAR szDebug[300];

        wsprintf (szDebug, TEXT("%d   PROGMAN:   Received WM_DDE_INITIATE.  FAILED\r\n"),
                  GetTickCount());
        OutputDebugString(szDebug);
        }
#endif
        break;

    case WM_DDE_REQUEST:
    {
        ATOM fmt;
        ATOM aItem;

        fmt = GET_WM_DDE_REQUEST_FORMAT(wParam, lParam);
        aItem = GET_WM_DDE_REQUEST_ITEM(wParam, lParam);
        if (aItem == GlobalFindAtom(szProgman)
            || aItem == GlobalFindAtom(szGroupList)) {
            GroupRequest(hWnd, (HWND)wParam, fmt, aItem);
        }
        else
            DumpGroup(hWnd, aItem, (HWND)wParam, fmt);
        DDEFREE(WM_DDE_REQUEST, lParam);
        break;
    }

    case WM_DDE_EXECUTE:
    {
        HANDLE hCommands;
        WORD wStatus;
        DWORD ret;
    LPSTR lpCommands ;
    HLOCAL hloc ;
    HLOCAL hlocTemp ;
    int cchMultiByte ;
    LPWSTR lpWideCharStr = NULL ;
    int cchWideChar = 0  ;
    BOOL bIsWindowUnicode ;
        UnpackDDElParam(WM_DDE_EXECUTE, lParam, NULL, (PUINT_PTR)&hCommands);

	// was the sending window a unicode app?
        bIsWindowUnicode=IsWindowUnicode((HWND)wParam) ;
	if (!bIsWindowUnicode) {
	    // convert the string to unicode
            lpCommands = GlobalLock(hCommands) ;
            cchMultiByte=MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpCommands,
                    -1,lpWideCharStr,cchWideChar) ;

            hloc = GlobalAlloc(GMEM_MOVEABLE,(++cchMultiByte)*sizeof(TCHAR)) ;
            lpWideCharStr = GlobalLock(hloc) ;

            MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpCommands,
                            -1,lpWideCharStr,cchMultiByte) ;

	    GlobalUnlock(hloc) ;
            GlobalUnlock(hCommands) ;
            hlocTemp  = hCommands;
            hCommands = hloc ;
	}

        if (ret = ExecuteHandler(hCommands)) {
            wStatus = 0x8000;
        } else {
            wStatus = 0x0000;
        }
	if (!bIsWindowUnicode) {
            hCommands = hlocTemp;
	    GlobalFree(hloc) ;
        }

        MPostWM_DDE_EXECACK((HWND)wParam, hWnd, wStatus, hCommands);
        if (ret == 2) {         // Exit command was executed
            MPostWM_DDE_TERMINATE((HWND)wParam, hWnd);
            PostMessage(hwndProgman, WM_CLOSE, 0, 0L);
        }
//      DDEFREE(WM_DDE_EXECUTE, lParam);    // executes arn't really packed.
        break;
    }

    case WM_DDE_TERMINATE:
#ifdef ORGCODE
        SendMessage(wParam, WM_DDE_TERMINATE, (WPARAM)hWnd, lParam);
#else
        RemoveDdeConversation(hWnd, (HWND)wParam, DDE_PROGMAN);
        MPostWM_DDE_TERMINATE((HWND)wParam, hWnd);
//      DDEFREE(WM_DDE_TERMINATE, lParam);  // terminates arn't packed
#endif
        if (hWnd != hwndProgman) {
            DestroyWindow (hWnd);
        }
        break;

    case WM_DDE_ACK:
        DDEFREE(WM_DDE_ACK, lParam);
        break;

    /* All other DDE messages are unsupported. */
    case WM_DDE_DATA:
    case WM_DDE_ADVISE:
    case WM_DDE_UNADVISE:
    case WM_DDE_POKE:
#ifdef ORGCODE
        DDEFail(hWnd,wParam,lParam);
#else
        {
            UINT_PTR uiHi;

            UnpackDDElParam(wMsg, lParam, NULL, &uiHi);
            DDEFail(hWnd, (HWND)wParam, (ATOM)uiHi);
            DDEFREE(wMsg, lParam);
        }
#endif
        break;

    default:
        return DefWindowProc(hWnd,wMsg,wParam,lParam);
    }
    return(0L);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AppIconDDEMsgProc() -                                                   */
/*                                                                          */
/*        Application = "Shell"                                             */
/*        Topic = "AppIcon"                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LRESULT APIENTRY AppIconDDEMsgProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg) {
    case WM_DDE_REQUEST:
        FindIconProp(hWnd, wParam, lParam, APP_ICON);
        DDEFREE(WM_DDE_REQUEST, lParam);
        break;

    case WM_DDE_TERMINATE:
        RemoveDdeConversation(hWnd, (HWND)wParam, APP_ICON);
        MPostWM_DDE_TERMINATE((HWND)wParam, hWnd);
        DDEFREE(WM_DDE_TERMINATE, lParam);
        DestroyWindow(hWnd);
        break;

    default:
        return DDEMsgProc(hWnd, wMsg, wParam, lParam);
    }
    return 0L;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AppDescriptionDDEMsgProc() -                                            */
/*                                                                          */
/*        Application = "Shell"                                             */
/*        Topic = "AppDescription"                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LRESULT APIENTRY AppDescriptionDDEMsgProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg) {
    case WM_DDE_REQUEST:
        FindIconProp(hWnd, wParam, lParam, APP_DESC);
        DDEFREE(WM_DDE_REQUEST, lParam);
        break;

    case WM_DDE_TERMINATE:
        RemoveDdeConversation(hWnd, (HWND)wParam, APP_DESC);
        PostMessage((HWND)wParam, WM_DDE_TERMINATE, (WPARAM)hWnd, 0L);
        DestroyWindow(hWnd);
        break;

    default:
        return DDEMsgProc(hWnd, wMsg, wParam, lParam);
    }
    return 0L;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AppWorkingDirDDEMsgProc() -                                             */
/*                                                                          */
/*        Application = "Shell"                                             */
/*        Topic = "AppWorkingDir"                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LRESULT APIENTRY AppWorkingDirDDEMsgProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg) {
    case WM_DDE_REQUEST:
        FindIconProp(hWnd, wParam, lParam, APP_WDIR);
        DDEFREE(WM_DDE_REQUEST, lParam);
        break;

    case WM_DDE_TERMINATE:
        RemoveDdeConversation(hWnd, (HWND)wParam, APP_WDIR);
        MPostWM_DDE_TERMINATE((HWND)wParam, hWnd);
        DDEFREE(WM_DDE_TERMINATE, lParam);
        DestroyWindow(hWnd);
        break;

    default:
        return DDEMsgProc(hWnd, wMsg, wParam, lParam);
    }
    return 0L;
}


VOID APIENTRY RegisterDDEClasses(HANDLE hInstance)
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = AppIconDDEMsgProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szAppIconDDE;

    if (!RegisterClass(&wc))
        bAppIconDDE = FALSE;

    wc.lpfnWndProc = AppDescriptionDDEMsgProc;
    wc.lpszClassName = szAppDescDDE;

    if (!RegisterClass(&wc))
        bAppDescDDE = FALSE;

    wc.lpfnWndProc = AppWorkingDirDDEMsgProc;
    wc.lpszClassName = szAppWDirDDE;

    if (!RegisterClass(&wc))
        bAppWDirDDE = FALSE;

    wc.lpfnWndProc = DDEMsgProc;
    wc.lpszClassName = szProgmanDDE;

    if (!RegisterClass(&wc))
        bProgmanDDE = FALSE;

    InitDdeConversationStruct();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmdlg.h ===
/* Dialog IDs */
#define ABOUTDLG                1
#define BROWSEDLG               2
#define CHOOSERDLG              3
#define GROUPDLG                5
#define ICONDLG                 6
#define ITEMDLG                 7
#define MOVECOPYDLG             8
#define RUNDLG                  9
#define HOTKEYDLG               10
#define RUNBROWSEDLG            11
#define NEWLOGOFFDLG            12
#define UPDATEGROUPSDLG         13

#define IDD_TEXT                   -1
#define IDD_NAME		   100
#define IDD_COMMAND		   101
#define IDD_ICON		   102
#define IDD_MINIMIZE	   103
#define IDD_NEXT		   104
#define IDD_LOAD		   105
#define IDD_SAVESETTINGS   111
#define IDD_BROWSE		   112
#define IDD_FILES		   113
#define IDD_DIRS		   114
#define IDD_MOVETITLE1	   115
#define IDD_ITEM		   116
#define IDD_PERSGROUP      117
#define IDD_COMMONGROUP    118
#define IDD_GROUPS		   119
#define IDD_PATH                   IDD_COMMAND
#define IDD_CONFIG		   121
#define IDD_DIR 		   122
#define IDD_PREV		   123
#define IDD_HOTKEY		   124
#define IDD_STARTUP		   125
#define IDD_CURICON		   126
#define IDD_HELP		   127
#define IDD_GROUP          128
#define IDD_LOGOFF         130
#define IDD_SHUTDOWN       131
#define IDOK2              132
#define IDCANCEL2          133
#define IDD_NEWVDM         134

#include "shutdown.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\notify.h ===
/****************************** Module Header ******************************\
* Module Name: notify.h
*
* Copyright (c) 1992, Microsoft Corporation
*
* Handles notification of key value changes in the registry that affect
* the Program Manager.
*
* History:
* 04-16-92 JohanneC       Created.
\***************************************************************************/

//
// 2 watch events: common groups key & personal groups key
//
extern HANDLE gahEvents[2];

BOOL APIENTRY InitializeGroupKeyNotification();
VOID APIENTRY ResetProgramGroupsEvent(BOOL bCommonGroup);
VOID HandleGroupKeyChange(BOOL bPersonalGroup);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmcomman.c ===
/*
 * pmcomman.c - program manager
 *
 *  Copyright (c) 1991,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *                This file is for support of program manager under NT Windows.
 *                This file is/was ported from pmcomman.c (program manager).
 *
 *  MODIFICATION HISTORY
 *      Initial Version: x/x/90        Author Unknown, since he didn't feel
 *                                                                like commenting the code...
 *
 *      NT 32b Version:         1/22/91        Jeff Pack   Intitial port to begin.
 *                              6/15/91        JohanneC    re-ported.
 *
 */

#include "progman.h"

/*** IsRemoteDrive -- tests to see if drive is a remote drive
 *
 *
 * BOOL APIENTRY IsRemoteDrive(wDrive)
 *
 * ENTRY -         int                wDrive - drive number to test
 *
 * EXIT  -        BOOL        xxx -  returns TRUE if remote, false if not.
 *
 * SYNOPSIS -  calls GetDriveType to determine if media is remote or not.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

BOOL APIENTRY IsRemoteDrive(int wDrive)
{

  TCHAR         pszdrive[5] = TEXT("c:\\");       /*default string value*/

  pszdrive[0] = (TCHAR)wDrive + (TCHAR)TEXT('A');  /*convert wDrive (0-25) to drive letter*/
                                           /*and place in string to pass to GetDriveType*/

  return((BOOL) (GetDriveType(pszdrive) == DRIVE_REMOTE));
}


/*** IsRemovableDrive -- tests to see if drive is removable
 *
 *
 * BOOL APIENTRY IsRemovableDrive( int wDrive)
 *
 * ENTRY -         int                wDrive - drive number to test
 *
 * EXIT  -        BOOL        xxx -  returns TRUE if removable, false if not.
 *
 * SYNOPSIS -  calls GetDriveType to determine if media is removable or not.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

BOOL APIENTRY IsRemovableDrive( int wDrive)
{
  TCHAR         pszdrive[5] = TEXT("c:\\");                /*default string value*/


  pszdrive[0] = (TCHAR)wDrive + (TCHAR)TEXT('A');                /*convert wDrive (0-25) to drive letter*/
                                                                        /*and place in string to pass to GetDriveType*/
  return((BOOL)(GetDriveType(pszdrive) == DRIVE_REMOVABLE));
}

/*** BuildDescription --
 *
 *
 * VOID APIENTRY BuildDescription(LPTSTR szName, LPTSTR szPath)
 *
 * ENTRY -         LPTSTR        szName
 *                 LPTSTR        szPath
 *
 * EXIT  -        VOID        xxx -
 *
 * SYNOPSIS -
 *
 * WARNINGS -  sordid coding style  BUG BUG assumes 8.3 filename convention
 * EFFECTS  -
 *
 */

VOID APIENTRY BuildDescription(LPTSTR szName, LPTSTR szPath)
{
  TCHAR      ch;
  TCHAR      ch2 = 0;
  LPTSTR     p;
  LPTSTR     p2;
  LPTSTR     p3  = NULL;

//When User creating new icon with command line added quote (such as "a b.exe")
// and no description, then invalid description ("a b) added new icon.

  BOOL      bQuote = FALSE;

  if (*szPath == TEXT('"') && *(szPath+lstrlen(szPath)-1) == TEXT('"')) {
      bQuote = TRUE;
      *(szPath+lstrlen(szPath)-1) = TEXT('\0');
      szPath++;
  }

  p = p2 = szPath;

  /* Scan the string looking for the last filename. */
  while (*p) {
      if (*p == TEXT('\\'))
          p2 = p+1;
      else if (*p == TEXT('.'))
          p3 = p;
      p = CharNext(p);
  }

  if (!p3)
      p3 = p;

  ch = *p3;
  *p3 = TEXT('\0');

  if (lstrlen(p2) > MAXITEMNAMELEN) {
      ch2 = *(p2 + MAXITEMNAMELEN);
      *(p2 + MAXITEMNAMELEN) = TEXT('\0');
  }

  lstrcpy(szName, p2);
  *p3 = ch;

  if (ch2) {
      *(p2 + MAXITEMNAMELEN) = ch2;
  }

  if( bQuote )
    *(szPath+lstrlen(szPath)) = TEXT('"');

  CharUpper(szName);
  CharLower(CharNext(szName));
}

/* Returns 0 for success.  Otherwise returns a IDS_ string code. */

/*** ExecProgram -- exec program function
 *
 *
 * WORD APIENTRY ExecProgram(LPTSTR lpszPath, LPTSTR lpDir, LPTSTR lpTitle, BOOL bLoadIt)
 *
 * ENTRY -        LPTSTR      lpszPath    -
 *                LPTSTR      lpDir       -
 *                BOOL        bLoadIt     -
 *
 * EXIT  -        BOOL        xxx         -         returns (0)FALSE if successful, else returns
 *                                                                IDS_ string code.
 *
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

WORD APIENTRY ExecProgram (
    LPTSTR lpszPath,
    LPTSTR lpDir,
    LPTSTR lpTitle,
    BOOL bLoadIt,
    DWORD dwDDEId,
    WORD wHotKeyId,
    BOOL bNewVDM
    )
{
  WORD      ret;
  WORD      wNTVDMFlags=0;
  HCURSOR   hCursor;
  LPTSTR     lpP;
  TCHAR cSeparator;
  TCHAR lpReservedFormat[] = TEXT("dde.%d,hotkey.%d,ntvdm.%d");
  TCHAR lpReserved[100];  // used for DDE request of icons from console apps
                         // add for passing the hotkey associated with an item.
  DWORD OldErrorMode;

  ret = 0;
  //hPendingWindow = NULL;

  hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

  /* Don't mess with the mouse state; unless we're on a mouseless system.
   */
  if (!GetSystemMetrics(SM_MOUSEPRESENT))
      ShowCursor(TRUE);

  /* skip leading spaces
   */
  while (*lpszPath == TEXT(' '))
      lpszPath++;

  /* skip past path
   */
  lpP = lpszPath;
  if (*lpszPath == TEXT('"')) {
     cSeparator = TEXT('"');
     lpP++;
  }
  else {
     cSeparator = TEXT(' ');
  }

  for (; *lpP && *lpP != cSeparator; lpP = CharNext(lpP))
      ;
  if (*lpP == TEXT('"')) {
     lpP++;
  }

  /* if stuff on end, separate it
   */
  if (*lpP)
      *lpP++ = 0;

  /* Try to exec 'szCommandLine'. */
  fInExec = TRUE;

  /*changed order, since wPendINstance is a 32b HANDLE, and ret is WORD*/
    if (!lpP)
        lpP = TEXT("");

    // Setup this flags variable so NTVDM can overwrite pif information
    // if user has specified info in the icon properties.

    if (lpDir && *lpDir)
       wNTVDMFlags |= PROPERTY_HAS_CURDIR;

    if (wHotKeyId)
       wNTVDMFlags |= PROPERTY_HAS_HOTKEY;

    if (lpTitle && *lpTitle)
       wNTVDMFlags |= PROPERTY_HAS_TITLE;

    wsprintf(lpReserved, lpReservedFormat, dwDDEId, wHotKeyId, wNTVDMFlags);

    OldErrorMode = SetErrorMode(0);
    ret = (WORD)RealShellExecuteEx(hwndProgman, NULL, lpszPath, lpP,
                            lpDir, NULL, lpTitle, lpReserved,
                            (WORD)(bLoadIt ? SW_SHOWMINNOACTIVE : SW_SHOWNORMAL), NULL,
                            bNewVDM ? EXEC_SEPARATE_VDM : 0);
    SetErrorMode(OldErrorMode);

  fInExec = FALSE;

   // Unfortunately we are still using the 0 - 31 error code
   // combinations instead of the NT error codes.  SE_ERR_OOM
   // is the default case for all errors in RealShellExecuteExW,
   // thus displaying an out of memory error is probably bogus.
   // We can call GetLastError ourselves to get the _real_ error.
   //
   // Special cases:
   //
   // 1)  If you have a really deep directory structure(70 chars), and you
   //     try to spawn a WOW app from it CreateProcess will fail with
   //     and error of ERROR_INVALID_PARAMETER.  We'll grab this case,
   //     and map it into the bad path message since it is the closest.

   if (ret == SE_ERR_OOM)
      {
      DWORD dwResult = GetLastError();

      if (dwResult == ERROR_INVALID_PARAMETER)
         ret = SE_ERR_PNF;
      }


  /*BUG BUG these are DOS exec function return codes, no map yet to NT return codes!*/
  switch (ret) {
      case 0:
      case SE_ERR_OOM:    // 8
          ret = IDS_NOMEMORYMSG;
          break;

      case SE_ERR_FNF:    // 2
          ret = IDS_FILENOTFOUNDMSG;
          break;

      case SE_ERR_PNF:    // 3
          ret = IDS_BADPATHMSG;
          break;

      case 4:
          ret = IDS_MANYOPENFILESMSG;
          break;

      case 5:
          ret = IDS_ACCESSDENIED;
          break;

      case 10:
          ret = IDS_NEWWINDOWSMSG;
          break;

      case 12:
          ret = IDS_OS2APPMSG;
          break;

      case 15:
          /* KERNEL has already put up a messagebox for this one. */
          ret = 0;
          break;

      case 16:
          ret = IDS_MULTIPLEDSMSG;
          break;

      case 18:
          ret = IDS_PMODEONLYMSG;
          break;

      case 19:
          ret = IDS_COMPRESSEDEXE;
          break;

      case 20:
          ret = IDS_INVALIDDLL;
          break;

      case ERROR_NOT_ENOUGH_QUOTA:
      case STATUS_PAGEFILE_QUOTA:
          ret = IDS_INSUFFICIENTQUOTA;
          break;

      case SE_ERR_SHARE:
          ret = IDS_SHAREERROR;
	  break;

      case SE_ERR_ASSOCINCOMPLETE:
          ret = IDS_ASSOCINCOMPLETE;
	  break;

      case SE_ERR_DDETIMEOUT:
      case SE_ERR_DDEFAIL:
      case SE_ERR_DDEBUSY:
          ret = IDS_DDEFAIL;
          break;

      case SE_ERR_NOASSOC:
          ret = IDS_NOASSOCMSG;
          break;

      default:
          if (ret < 32)
              goto EPExit;

          if (bMinOnRun && !bLoadIt)
              ShowWindow(hwndProgman, SW_SHOWMINNOACTIVE);

          ret = 0;
  }

EPExit:

  if (!GetSystemMetrics(SM_MOUSEPRESENT)) {
      /*
       * We want to turn the mouse off here on mouseless systems, but
       * the mouse will already have been turned off by USER if the
       * app has GP'd so make sure everything's kosher.
       */
      if (ShowCursor(FALSE) != -1)
          ShowCursor(TRUE);
  }

  SetCursor(hCursor);

  return(ret);
}


/*** SelectionType --
 *
 *
 * WORD APIENTRY SelectionType(VOID)
 *
 * ENTRY -         VOID
 *
 * EXIT  -        WORD        xxx         -
 *
 *
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

WORD APIENTRY SelectionType(VOID)
{
  /* If no groups, return GROUP type (so user can create one). */
  if (!pCurrentGroup)
      return(TYPE_PERSGROUP);

  if (IsIconic(pCurrentGroup->hwnd))
      if (pCurrentGroup->fCommon)
          return(TYPE_COMMONGROUP);
      else
          return(TYPE_PERSGROUP);

  return(TYPE_ITEM);
}

/*** ExecItem --
 *
 *
 * VOID APIENTRY ExecItem(PGROUP pGroup, PITEM pItem, BOOL fShift, BOOL fStartup)
 *
 * ENTRY -         PGROUP        pGroup                -
 *                        PITEM        pItem                -
 *
 * EXIT  -        VOID
 *
 *
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */
VOID APIENTRY ExecItem(PGROUP pGroup, PITEM pItem, BOOL fShift, BOOL fStartup)
{
    WORD      ret;
    TCHAR      szCommand[MAXITEMPATHLEN + 1];
    TCHAR      szDir[2*(MAXITEMPATHLEN + 1)];
    TCHAR      szTemp[MAXMESSAGELEN+1];
    TCHAR      *szTitle;
    GROUPDEF  *lpgd;

    //
    // Exec the item in the user's home directory.
    //
    SetCurrentDirectory(szOriginalDirectory);

    GetItemCommand(pGroup,pItem,szCommand,szDir);

    if (fShift) {
        fShift = GetKeyState(VK_SHIFT) < (SHORT)0;
    }

    ret = (WORD)((WORD)fShift || GroupFlag(pGroup, pItem, (WORD)ID_MINIMIZE));
    wPendingHotKey = GroupFlag(pGroup, pItem, (WORD)ID_HOTKEY);

    pExecingGroup = pGroup;
    pExecingItem = pItem;
    DoEnvironmentSubst(szCommand, MAXITEMPATHLEN + 1);
    DoEnvironmentSubst(szDir, 2 * (MAXITEMPATHLEN + 1));

    // REVIEW Check the working directory first because the user may
    // still want to try to run the app even with an invalid working
    // dir.
    // Check working directory.
    GetCurrentDirectory(MAXMESSAGELEN+1, szTemp);

    SheRemoveQuotes(szDir);

    // Allow dir field to be NULL without error.
    if (szDir && *szDir) {
        // NB The VPD call is because SCD sometimes returns success even
        // if the drive is invalid. SCD returns FALSE on success.
        if ((!ValidPathDrive(szDir) ||
		     !SetCurrentDirectory(szDir)) &&
		     !fStartup) {
            if (MyMessageBox(hwndProgman, IDS_BADPATHTITLE, IDS_BADPATHMSG3, NULL, MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION) == IDCANCEL)
	        goto Exit;
        }
    }

    SetCurrentDirectory(szTemp);
    //OemToChar(szDir, szDir);

    if ((lpgd = LockGroup(pGroup->hwnd)) == NULL)
        return;
    szTitle = (TCHAR *)PTR(lpgd, ((LPITEMDEF)ITEM(lpgd, pItem->iItem))->pName);

    if (!dwDDEAppId || (dwDDEAppId != pItem->dwDDEId)) {
        dwDDEAppId++;
    }
    pItem->dwDDEId = dwDDEAppId;

    ret = ExecProgram(szCommand, szDir, szTitle, ret, dwDDEAppId,
                      GroupFlag(pGroup, pItem, ID_HOTKEY),
                      GroupFlag(pGroup, pItem, ID_NEWVDM) );

    UnlockGroup(pGroup->hwnd);

    pExecingGroup = NULL;
    pExecingItem = NULL;

    // Check for errors.
    if (ret) {
        if (fStartup) {
             /*
              * This exec is for an item in the startup group, the error
              * message will need to be patched up by adding a comment
              * after the path bit.
              */
             szTemp[0] = TEXT('\'');
             lstrcpy(&szTemp[1], szCommand);
             LoadString(hAppInstance, IDS_STARTUPERR, szCommand, CharSizeOf(szCommand));
             lstrcat(szTemp, szCommand);
             lstrcpy(szCommand, szTemp);
        }
        MyMessageBox(hwndProgman, IDS_EXECERRTITLE, ret, szCommand, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
    }
Exit:
  SetCurrentDirectory(szWindowsDirectory);
}

VOID RemoveAnsiGroups()
{
    HMENU hMenu;
    FILETIME ft;
    TCHAR szGroupKey[MAXKEYLEN];
    DWORD cchGroupKey = CharSizeOf(szGroupKey);
    HCURSOR hCursor;
    INT i = 0;

    if (!MyDialogBox(UPDATEGROUPSDLG, hwndProgman, UpdateGroupsDlgProc)) {
        return;
    }

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szAnsiProgramGroups, 0,
                     KEY_READ | DELETE, &hkeyAnsiProgramGroups) != ERROR_SUCCESS) {
        return;
    }

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    while (!RegEnumKeyEx(hkeyAnsiProgramGroups, i, szGroupKey, &cchGroupKey, 0, 0, 0, &ft)) {
        if (cchGroupKey) {
            if (RegDeleteKey(hkeyAnsiProgramGroups, szGroupKey))
                i++;
        }
        cchGroupKey = CharSizeOf(szGroupKey);
    }
    RegCloseKey(hkeyAnsiProgramGroups);

    if (!RegDeleteKey(HKEY_CURRENT_USER, szAnsiProgramGroups)) {
        //
        // Change Options menu: remove the 'Update Program Groups' menu item
        //
        if (pCurrentGroup &&
              GetWindowLong(pCurrentGroup->hwnd, GWL_STYLE) & WS_MAXIMIZE) {
            hMenu = GetSubMenu(GetMenu(hwndProgman), 2);
        }
        else {
            hMenu = GetSubMenu(GetMenu(hwndProgman), 1);
        }
        DeleteMenu(hMenu, 6, MF_BYPOSITION);
        DeleteMenu(hMenu, 5, MF_BYPOSITION);
        DrawMenuBar(hwndProgman);
    }
    RegDeleteKey(hkeyProgramManager, TEXT("Groups"));
    RegDeleteValue(hkeyPMSettings, szAnsiOrder);

    ShowCursor(FALSE);
    SetCursor(hCursor);

}

/*** ProgmanCommandProc --
 *
 *
 * BOOL APIENTRY ProgmanCommandProc(register HWND hwnd, WORD wMsg,
 *                                                                register WPARAM wParam, LPARAM lParam)
 *
 * ENTRY -         HWND        hWnd
 *                        WORD        wMsg
 *                        WPARAM        wParam
 *                        LPARAM        lParam
 * EXIT  -        BOOL        xxx - returns info, or zero, for nothing to return
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

BOOL APIENTRY ProgmanCommandProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    BOOL  bMaxed;
    WORD  wHelpCmd;
    HMENU hMenu;
    LPTSTR  psz;
    HWND  hwndMdiActive;

    hwndMdiActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwndMdiActive != NULL)
        bMaxed = (GetWindowLong(hwndMdiActive, GWL_STYLE) & WS_MAXIMIZE) ? TRUE : FALSE;
    else
        bMaxed = 0;

    dwContext = (DWORD)(IDH_HELPFIRST + wParam);

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {

    case IDM_OPEN:
        if (!pCurrentGroup)
            break;

        if (SelectionType() == TYPE_ITEM)
            ExecItem(pCurrentGroup,pCurrentGroup->pItems,TRUE, FALSE);
        else
            SendMessage(pCurrentGroup->hwnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
        break;

    case IDM_NEW:
        if (fNoFileMenu)
            break;

        if (dwEditLevel == 1)
            goto PCPNewItem;

        if (dwEditLevel > 1)
            break;

        if (MyDialogBox(CHOOSERDLG, hwndProgman, ChooserDlgProc)) {
            switch (wNewSelection) {

            case TYPE_PERSGROUP:
            case TYPE_COMMONGROUP:
                MyDialogBox(GROUPDLG, hwndProgman, NewGroupDlgProc);
                break;

            case TYPE_ITEM:
PCPNewItem:
                /*
                 * We are creating a new program item.
                 */
                MyDialogBox(ITEMDLG, hwndProgman, NewItemDlgProc);
                break;
            }
        }
        break;

    case IDM_MOVE:
        if (fNoFileMenu)
            break;

        MyDialogBox(MOVECOPYDLG, hwndProgman, MoveItemDlgProc);
        break;

    case IDM_COPY:
        if (fNoFileMenu)
            break;

        MyDialogBox(MOVECOPYDLG, hwndProgman, CopyItemDlgProc);
        break;

    case IDM_DELETE:
        if (fNoFileMenu)
            break;

        switch (SelectionType()) {

        case TYPE_ITEM:

            if (pCurrentGroup->pItems) {
                wParam = IDS_CONFIRMDELITEMMSG;
                GetItemText(pCurrentGroup, pCurrentGroup->pItems, szNameField, 0);
                psz = szNameField;
                break;
            }
                /*** FALL THRU ***/

        case TYPE_PERSGROUP:
        case TYPE_COMMONGROUP:

            wParam = IDS_CONFIRMDELGROUPMSG;
            GetWindowText(pCurrentGroup->hwnd, (LPTSTR)szNameField, MAXITEMPATHLEN);
            psz = szNameField;
            break;
        }

        if (MyMessageBox(hwndProgman, (WORD)IDS_CONFIRMDELTITLE, (WORD)wParam,
                psz, (WORD)(MB_YESNO | MB_ICONEXCLAMATION)) == IDYES) {
            if (wParam == (WPARAM)IDS_CONFIRMDELITEMMSG) {
                DeleteItem(pCurrentGroup,pCurrentGroup->pItems);
            } else {
                DeleteGroup(pCurrentGroup->hwnd);
            }
        }
        break;

    case IDM_PROPS:
        if (fNoFileMenu)
            break;

        switch (SelectionType()) {

        case TYPE_ITEM:
            if (pCurrentGroup->pItems) {
                MyDialogBox(ITEMDLG, hwndProgman, EditItemDlgProc);
                break;
            }
            /*** FALL THRU ***/

        case TYPE_PERSGROUP:
        case TYPE_COMMONGROUP:
            {
                LPGROUPDEF lpgd;

                lpgd = LockGroup(pCurrentGroup->hwnd);
                if (lpgd == 0L) {
                    break;
                }

                lstrcpy(szNameField, (LPTSTR) PTR(lpgd, lpgd->pName));
                UnlockGroup(pCurrentGroup->hwnd);
                MyDialogBox(GROUPDLG, hwndProgman, EditGroupDlgProc);
                break;
            }
        }
        break;

    case IDM_RUN:
        if (fNoFileMenu)
            break;

        MyDialogBox(RUNDLG, hwndProgman, RunDlgProc);
        break;

    case IDM_EXIT:
        if (fNoFileMenu)
              break;

        PostMessage(hwndProgman, WM_CLOSE, 0, (LPARAM)-1);
	    break;

    case IDM_SHUTDOWN:
        if (fNoFileMenu)
              break;

        /* Don't close if restricted. */
        if (fNoClose)
            break;

        if (bExitWindows) {

            fExiting = TRUE;
            SetWindowLong (hwndProgman, GWL_EXITING, 1);

            /* Call the ShutdownDialog API. */
            ShutdownDialog(hAppInstance, hwndProgman);

            /* User clicked cancel or some app refused the ExitWindows... */
            fExiting = FALSE;
            SetWindowLong (hwndProgman, GWL_EXITING, 0);
        }
        break;

    case IDM_AUTOARRANGE:
          bAutoArrange = !bAutoArrange;

          /* Check/Uncheck the menu item. */
          hMenu = GetSubMenu(GetMenu(hwndProgman), IDM_OPTIONS + (int)bMaxed - (int)fNoFileMenu);
          CheckMenuItem(hMenu, GET_WM_COMMAND_ID(wParam, lParam),
                (WORD)(bAutoArrange ? MF_CHECKED : MF_UNCHECKED));
          if (hkeyPMSettings)
              RegSetValueEx(hkeyPMSettings, szAutoArrange, 0, REG_DWORD, (LPBYTE)&bAutoArrange, sizeof(bAutoArrange));
          if (bAutoArrange) {
              HWND hwndT;

              for (hwndT=GetWindow(hwndMDIClient, GW_CHILD); hwndT;
                                    hwndT=GetWindow(hwndT, GW_HWNDNEXT)) {
                  if (GetWindow(hwndT, GW_OWNER))
                      continue;

                  ArrangeItems(hwndT);
              }
          }
          break;

    case IDM_MINONRUN:
          bMinOnRun = !bMinOnRun;

          /* Check/Uncheck the menu item. */
          hMenu = GetSubMenu(GetMenu(hwndProgman), IDM_OPTIONS + (int)bMaxed - (int)fNoFileMenu);
          CheckMenuItem(hMenu, GET_WM_COMMAND_ID(wParam, lParam),
                (WORD)(bMinOnRun ? MF_CHECKED : MF_UNCHECKED));
          if (hkeyPMSettings)
              RegSetValueEx(hkeyPMSettings,
                            szMinOnRun,
                            0,
                            REG_DWORD,
                            (LPBYTE)&bMinOnRun,
                            sizeof(bMinOnRun));
          break;

    case IDM_SAVESETTINGS:
          bSaveSettings = !bSaveSettings;

          /* Check/Uncheck the menu item. */
          hMenu = GetSubMenu(GetMenu(hwndProgman), IDM_OPTIONS + (int)bMaxed - (int)fNoFileMenu);
          CheckMenuItem(hMenu, GET_WM_COMMAND_ID(wParam, lParam),
                (UINT)(bSaveSettings ? MF_CHECKED : MF_UNCHECKED));
          if (hkeyPMSettings)
              RegSetValueEx(hkeyPMSettings,
                            szSaveSettings,
                            0,
                            REG_DWORD,
                            (LPBYTE)&bSaveSettings,
                            sizeof(bSaveSettings));
          break;

      case IDM_SAVENOW:
          WriteINIFile();
          break;

      case IDM_ANSIGROUPS:
          RemoveAnsiGroups();
          break;

      case IDM_CASCADE:
          SendMessage(hwndMDIClient, WM_MDICASCADE, 0, 0L);
          break;

      case IDM_TILE:
          SendMessage(hwndMDIClient, WM_MDITILE, 0, 0L);
          break;

      case IDM_ARRANGEICONS:
          if (SelectionType() != TYPE_ITEM)
              SendMessage(hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
          else
              ArrangeItems(pCurrentGroup->hwnd);
          break;

      case IDM_HELPINDEX:
          wHelpCmd = HELP_INDEX;
          wParam = 0;
          goto ACPCallHelp;

      case IDM_HELPSEARCH:
          wHelpCmd = HELP_PARTIALKEY;
          wParam = (WPARAM)szNULL;
          goto ACPCallHelp;

      case IDM_HELPHELP:
          wHelpCmd = HELP_HELPONHELP;
          wParam = 0;

ACPCallHelp:
          SetCurrentDirectory(szOriginalDirectory);
          if (!WinHelp(hwndProgman, szProgmanHelp, wHelpCmd, (DWORD)wParam)) {
              MyMessageBox(hwndProgman, IDS_APPTITLE, IDS_WINHELPERR, NULL, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
          }
          SetCurrentDirectory(szWindowsDirectory);
          break;

      case IDM_ABOUT:
      {
          TCHAR szTitle[40];

          LoadString(hAppInstance, IDS_APPTITLE, szTitle, CharSizeOf(szTitle));
          if (ShellAbout(hwndProgman, szTitle, NULL, NULL) == -1)
              MessageBox(hwndProgman, szOOMExitMsg, szOOMExitTitle, MB_ICONHAND | MB_SYSTEMMODAL | MB_OK);
          break;
      }

      default:
          return(FALSE);
    }

  return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmdos.c ===
/*
 * pmdos.c
 *
 *  Copyright (c) 1991,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *              This file is for support of program manager under NT Windows.
 *              This file is/was ported from pmdos.asm (program manager).
 *              It was in x86 asm code, and now is in ansi C.
 *              Some functions will be removed, due to they are only needed
 *              by DOS Windows.
 *
 *  MODIFICATION HISTORY
 *      Initial Version: x/x/90 Author Unknown, since he didn't feel
 *                                                              like commenting the code...
 *
 *      NT 32b Version:  1/9/91 Jeff Pack
 *                                                              Intitial port to begin.
 *
 *  WARNING:  since this is NOT for DOS, I'm making it soley 32bit aware.
 *                        Following functions not ported
 *                                      IsRemovable() is in pmcomman.c (already ifdef'd in asm code)
 *                                      IsRemote()  is in pmcomman.c   (ditto!)
 *
 */


#include <io.h>
#include <string.h>
#include <ctype.h>
#include <windows.h>
#include <port1632.h>

#if DBG

#define KdPrint(_x_) OutputDebugStringA _x_;

#else

#define KdPrint(_x_)

#endif

#define LOCALBUFFERSIZE 128


/*** FileTime --        Gets time of last modification.
 *
 *
 *
 * DWORD FileTime(HFILE hFile)
 *
 * ENTRY -      int hFile       - file handle to access
 *
 * EXIT  -      LPWORD   - which is gotten from lpTimeStamp = 0 (ERROR).
 *                                         or lpTimeStamp != 0 (value of timestamp)
 *
 * SYNOPSIS -  calls GetFileTime() to get timestamp. If error, then
 *                              lpTimeStamp = 0, else contains TimeStamp for file.
 * WARNINGS -
 * EFFECTS  -
 *
 */

DWORD FileTime(
    HFILE hFile)
{
    BOOL            bReturnCode;
    FILETIME        CreationTime;
    FILETIME        LastAccessTime;
    FILETIME        LastWriteTime;
    WORD            FatTime;
    WORD            FatDate;

    bReturnCode = GetFileTime((HANDLE)hFile, &CreationTime, &LastAccessTime,
        &LastWriteTime);

    /*
    * Test return code
    */
    if (bReturnCode == FALSE) {
            return 0;               /*set to zero, for error*/
    }

    /*
     * Now convert 64bit time to DOS 16bit time
     */
        FileTimeToDosDateTime( &LastWriteTime, &FatDate, &FatTime);
        return FatTime;
}


/*** IsReadOnly --      determines if file is readonly or not.
 *
 *
 *
 * BOOL IsReadOnly(LPSTR lpszFileString)
 *
 * ENTRY -      LPSTR lpszFileString    - file name to use
 *
 * EXIT  -      BOOL xxx - returns (0) = not readonly  (1) = read only
 *                                         or lpTimeStamp != 0 (value of timestamp)
 *
 * SYNOPSIS -  calls GetAttributes, then tests if file is read only.
 * WARNINGS -
 * EFFECTS  -
 *
 */


BOOL IsReadOnly(LPTSTR lpszFileString)
{

        DWORD   dwReturnedAttributes;
        LPTSTR   lpszLocalBuffer;                                /*local buffer for AnsiToOem()*/
        DWORD   nBufferLength;

        nBufferLength = lstrlen(lpszFileString) + 1;
        /*alloc local, non-moveable, zero filled buffer*/
        lpszLocalBuffer = (LPTSTR)LocalAlloc(0, sizeof(TCHAR)*nBufferLength);
        if(lpszLocalBuffer == NULL){
                KdPrint(("<IsReadOnly> LocalAlloc FAILed\n"));
        }

        lstrcpy(lpszLocalBuffer,lpszFileString);

        /*get attributes of filestring*/
        dwReturnedAttributes = GetFileAttributes(lpszLocalBuffer);
        if(dwReturnedAttributes == -1){
            KdPrint(("<IsReadOnly> - GetFileAttributes() FAILed!\n"));
            LocalFree(lpszLocalBuffer);
            return FALSE;
        } else {
                /*AND with read_only attribute*/
                dwReturnedAttributes = dwReturnedAttributes & FILE_ATTRIBUTE_READONLY;
                switch(dwReturnedAttributes){

                        case FILE_ATTRIBUTE_READONLY:
                                LocalFree(lpszLocalBuffer);
                                return TRUE;
                                break;

                        default:
                                LocalFree(lpszLocalBuffer);
                                return FALSE;
                }

        }

}

/*** GetDOSErrorCode -- returns extended error code
 *
 *
 *
 * DWORD GetDOSErrorCode(VOID)
 *
 * ENTRY -      VOID
 *
 * EXIT  -      DWORD - returned extended code.
 *
 * SYNOPSIS - calls GetLastError() to get error code from OS
 * WARNINGS -
 * EFFECTS  -
 *
 */

DWORD GetDOSErrorCode(VOID)
{

        return( (int) GetLastError());

        /*BUG BUG, pmgseg.c uses this from _lcreat() to determine if returned
                5 (access denied) or 13 (invalid_data).  So this need be tested
                to see if win32 returns these.*/

}

/*** DosDelete -- Delete named file.
 *
 * int DosDelete(LPSTR lpszFileToDelete)
 *
 * ENTRY -      LPSTR lpszFileToDelete - filename to delete.
 *
 * EXIT  -      int xxx - returns (0) if success
 *
 * SYNOPSIS - calls win32 DeleteFile.
 * WARNINGS -
 * EFFECTS  -
 *
 */

int DosDelete(LPTSTR lpszFileToDelete)
{

        BOOL    bReturnCode;
        LPTSTR   lpszLocalBuffer;                                /*local buffer for AnsiToOem()*/
        DWORD   nBufferLength;

        nBufferLength = lstrlen(lpszFileToDelete) + 1;
        /*alloc local, non-moveable, zero filled buffer*/
        lpszLocalBuffer = (LPTSTR)LocalAlloc(0, sizeof(TCHAR)*nBufferLength);
        if(lpszLocalBuffer == NULL){
                KdPrint(("<DosDelete> LocalAlloc FAILed\n"));
        }


        lstrcpy(lpszLocalBuffer,lpszFileToDelete);


        bReturnCode = DeleteFile(lpszLocalBuffer);
        LocalFree(lpszLocalBuffer);
        if(bReturnCode){
                return(0);
        }
        else{
                return(1);
        }
}

/*** DosRename -- Rename file.
 *
 * int DosRename(LPSTR lpszOrgFileName, LPSTR lpszNewFileName)
 *
 * ENTRY -      LPSTR lpszOrgFileName - origianl filename.
 *                      LPSTR lpszNewFileName - New filename.
 *
 * EXIT  -      int xxx - returns (0) if success
 *
 * SYNOPSIS - calls win32 MoveFile.
 * WARNINGS -
 * EFFECTS  -
 *
 */

int DosRename(LPTSTR lpszOrgFileName, LPTSTR lpszNewFileName)
{

        BOOL    bReturnCode;
        LPTSTR   lpszLocalBuffer;                                /*local buffer for AnsiToOem()*/
        LPTSTR   lpszLocalBuffer1;                               /*local buffer for AnsiToOem()*/
        DWORD   nBufferLength;
        DWORD   nBufferLength1;

        nBufferLength = lstrlen(lpszOrgFileName) + 1;
        nBufferLength1 = lstrlen(lpszNewFileName) + 1;
        /*alloc local, non-moveable, zero filled buffer*/
        lpszLocalBuffer = (LPTSTR)LocalAlloc(0, sizeof(TCHAR)*nBufferLength);
        if(lpszLocalBuffer == NULL){
                KdPrint(("<DosRename> LocalAlloc FAILed\n"));
        }
        lpszLocalBuffer1 = (LPTSTR)LocalAlloc(0, sizeof(TCHAR)*nBufferLength1);
        if(lpszLocalBuffer1 == NULL){
                KdPrint(("<DosRename> LocalAlloc FAILed\n"));
        }


        lstrcpy(lpszLocalBuffer,lpszOrgFileName);
        lstrcpy(lpszLocalBuffer1,lpszNewFileName);

        /*rename file*/
        bReturnCode = MoveFile(lpszLocalBuffer, lpszLocalBuffer1);

        LocalFree(lpszLocalBuffer);
        LocalFree(lpszLocalBuffer1);

        if(bReturnCode){
                return(0);
        }
        else{
                return(1);
        }
}

#if 0
#ifdef i386

//
// Returns true if the application exe type is a DOS binary.
//

BOOL IsDOSApplication(LPTSTR lpPath)
{
    DWORD dwBinaryType;
    BOOL bRet;

    bRet = GetBinaryType(lpPath, &dwBinaryType);
    if (bRet) {
        if (dwBinaryType != SCS_DOS_BINARY) {
            bRet = FALSE;
        }
    }
    return(bRet);
}

//
// this routine translates path characters into _ characters because
// the NT registry apis do not allow the creation of keys with
// names that contain path characters.  it allocates a buffer that
// must be freed.
//

LPTSTR TranslateConsoleTitle(LPTSTR ConsoleTitle)
{
    int ConsoleTitleLength,i;
    LPTSTR TranslatedConsoleTitle,Tmp;

    ConsoleTitleLength = lstrlen(ConsoleTitle) + 1;
    Tmp = TranslatedConsoleTitle = (LPTSTR)LocalAlloc(LMEM_FIXED,ConsoleTitleLength * sizeof(TCHAR));
    if (TranslatedConsoleTitle == NULL) {
        return NULL;
    }
    for (i=0;i<ConsoleTitleLength;i++) {
        if (*ConsoleTitle == TEXT('\\')) {
            *TranslatedConsoleTitle++ = (TCHAR)TEXT('_');
            ConsoleTitle++;
        } else {
            *TranslatedConsoleTitle++ = *ConsoleTitle++;
        }
    }
    return Tmp;
}

// DOS apps are no longer set to fullscreen by default in progman
//  5-3-93 johannec (bug 8343)

#define CONSOLE_REGISTRY_STRING TEXT("Console")
#define CONSOLE_REGISTRY_FULLSCR TEXT("FullScreen")


BOOL SetDOSApplicationToFullScreen(LPTSTR lpTitle)
{
    HKEY hkeyConsole,hkeyTitle;
    LPTSTR lpTranslatedTitle;
    DWORD Error;
    DWORD dwFullScreen = 1;

    Error = RegOpenKeyEx(HKEY_CURRENT_USER,
                         CONSOLE_REGISTRY_STRING,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hkeyConsole);

    if (Error) {
        return FALSE;
    }

    lpTranslatedTitle = TranslateConsoleTitle(lpTitle);
    if (lpTranslatedTitle == NULL) {
        return FALSE;
    }

    Error = RegCreateKey(hkeyConsole,
                           lpTranslatedTitle,
                           &hkeyTitle);
    LocalFree(lpTranslatedTitle);
    if (Error) {
        RegCloseKey(hkeyConsole);
        return FALSE;
    }
    Error = RegSetValueEx(hkeyTitle,
                        CONSOLE_REGISTRY_FULLSCR,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwFullScreen,
                        sizeof(dwFullScreen));
    RegCloseKey(hkeyTitle);
    RegCloseKey(hkeyConsole);

    return(!Error);
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmgseg.c ===
/****************************************************************************/
/*                                                                          */
/*  PMGSEG.C -                                                              */
/*                                                                          */
/*      Program Manager Group Handling Routines                             */
/*                                                                          */
/****************************************************************************/

#include "progman.h"
#include "dde.h"
#include "convgrp.h"

#define WORD_MIN -32767
#define WORD_MAX  32767

#ifndef ORGCODE
#include "fcntl.h"
#include "io.h"
#include "stdio.h"
#include <tchar.h>
#define S_IREAD     0000400         /* read permission, owner */
#define S_IWRITE    0000200         /* write permission, owner */
#endif

BOOL fFirstLoad = FALSE;
extern BOOL bHandleProgramGroupsEvent;

#if 0
// DOS apps are no longer set to fullscreen by default in progman
//  5-3-93 johannec (bug 8343)
#ifdef i386
BOOL IsDOSApplication(LPTSTR lpPath);
BOOL SetDOSApplicationToFullScreen(LPTSTR lpTitle);
#endif
#endif

void NEAR PASCAL RemoveItemFromList(PGROUP pGroup, PITEM pItem)
    // Removes a PITEM from the list.
{
    PITEM *ppItem;

    /* Cause it to be repainted later. */
    InvalidateIcon(pGroup, pItem);

    if (pItem == pGroup->pItems) {
        /*
         * first one in list, must invalidate next one so it paints an active
         * title bar.
         */
        InvalidateIcon(pGroup,pItem->pNext);
    }

    /* Remove it from the list. */
    for (ppItem = &pGroup->pItems;*ppItem != pItem;
        ppItem = &((*ppItem)->pNext));

    *ppItem = pItem->pNext;

    /* Lastly free up the memory. */
    LocalFree((HANDLE)pItem);
}

#ifdef DEBUG
void NEAR PASCAL CheckBeforeReAlloc(HANDLE h)
{
        TCHAR buf[100];

        if ((BYTE)GlobalFlags(h)) {
                wsprintf(buf, TEXT("LockCount before realloc %d\r\n"), (BYTE)GlobalFlags(h));
                OutputDebugString(buf);
                DbgBreakPoint();
        }
}
#else
#define CheckBeforeReAlloc(h)
#endif

#ifdef PARANOID
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CheckRange() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void PASCAL CheckRange(
    LPGROUPDEF lpgd,
    LPTSTR lp1,
    WORD *lpw1,
    WORD cb1,
    LPTSTR lp2,
    WORD w2,
    WORD cb2,
    LPTSTR lpThing)
{
    WORD w1 = *lpw1;
    WORD e1, e2;

    if (!w1 || (w1 == w2)) {
        return;
    }

    if (!cb1) {
        cb1 = (WORD)lstrlen((LPTSTR) PTR(lpgd, *lpw1));
    }

    e1 = w1 + cb1;
    e2 = w2 + cb2;

    if ((w1 < e2) && (w2 < e1)) {
        KdPrint(("ERROR: %s overlaps %s in %s!!!!\r\n",lp2,lp1,lpThing));
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  CheckPointer() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

void PASCAL CheckPointer(
    LPGROUPDEF lpgd,
    LPTSTR lp,
    WORD *lpw,
    WORD cb,
    WORD limit)
{
    LPITEMDEF lpid;
    int i;

    if (lpw == NULL || !*lpw) {
        KdPrint(("Warning: %s is NULL\r\n", lp));
        DebugBreak();
    }

    if (!cb) {
        cb = lstrlen((LPTSTR) PTR(lpgd, *lpw));
    }

    if (*lpw + cb > limit) {
        KdPrint(("ERROR: %s runs off end of group\r\n", lp));
        return;
    }

}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  VerifyGroup() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

void PASCAL VerifyGroup(
    LPGROUPDEF lpgd)
{
    int       i;
    LPITEMDEF lpid;
    DWORD     limit = lpgd->cbGroup;

    KdPrint(("\r\nChecking Group %s\r\n",(LPTSTR) PTR(lpgd, lpgd->pName)));
    CheckPointer(lpgd, TEXT("Group Name"), &lpgd->pName, 0, limit);

    for (i = 0; i < (int)lpgd->cItems; i++) {
        if (!lpgd->rgiItems[i]) {
            continue;
        }

        lpid = ITEM(lpgd, i);
        KdPrint(("Checking item %d at %4.4X (%s):\r\n", i, lpgd->rgiItems[i],
                (LPTSTR) PTR(lpgd, lpid->pName)));
        CheckPointer(lpgd, TEXT("Itemdef"), lpgd->rgiItems + i, sizeof(ITEMDEF), limit);
        CheckPointer(lpgd, TEXT("Item name"), &lpid->pName, 0, limit);
        CheckPointer(lpgd, TEXT("item command"), &lpid->pCommand, 0, limit);
        CheckPointer(lpgd, TEXT("item icon path"), &lpid->pIconPath, 0, limit);
    }
}
#endif


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsGroupReadOnly() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL FAR PASCAL IsGroupReadOnly(LPTSTR szGroupKey, BOOL bCommonGroup)
{
    HKEY hkey;
    HKEY hkeyGroups;

    if (bCommonGroup)
       hkeyGroups = hkeyCommonGroups;
    else if (bUseANSIGroups)
        hkeyGroups = hkeyAnsiProgramGroups;
    else
        hkeyGroups = hkeyProgramGroups;

    if (!hkeyGroups)
        return(FALSE);

    if (!RegOpenKeyEx(hkeyGroups, szGroupKey, 0, DELETE | KEY_READ | KEY_WRITE, &hkey)){
        RegCloseKey(hkey);
        return(FALSE);
    }
    return(TRUE);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GroupCheck() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL FAR PASCAL GroupCheck(PGROUP pGroup)
{
    if (!fExiting && IsGroupReadOnly(pGroup->lpKey, pGroup->fCommon)) {
        pGroup->fRO = TRUE;
        return FALSE;
    }
    pGroup->fRO = FALSE;
    return TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyDwordAlign() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT MyDwordAlign(INT wStrLen)
{
    return ((wStrLen + 3) & ~3);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SizeofGroup() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/
DWORD PASCAL SizeofGroup(LPGROUPDEF lpgd)
{
    LPPMTAG lptag;
    DWORD cbSeg;
    DWORD cb;

    cbSeg = (DWORD)GlobalSize(lpgd);

    lptag = (LPPMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((DWORD)((PCHAR)lptag - (PCHAR)lpgd +MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb))+4) <= cbSeg
        && lptag->wID == ID_MAGIC
        && lptag->wItem == (int)0xFFFF
        && lptag->cb == (WORD)(MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) + 4)
        && *(PLONG)lptag->rgb == PMTAG_MAGIC)
      {
        while ((cb = (DWORD)((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)))) <= cbSeg)
          {
            if (lptag->wID == ID_LASTTAG)
                return cb;
            (LPSTR)lptag += lptag->cb;
          }
      }
    return lpgd->cbGroup;
}

/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  LockGroup() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/* Given the handle to the group's window, lock the group segment and return
 * a pointer thereto.  Reloads the group segment if it is not in memory.
 */

LPGROUPDEF FAR PASCAL LockGroup(HWND hwndGroup)

{
  PGROUP     pGroup;
  LPGROUPDEF lpgd;
  WORD       status;
  LPTSTR      lpszKey;
  HKEY       hKey = NULL;
  LONG       err;
  DWORD      cbMaxValueLen = 0;
  FILETIME   ft;
  TCHAR       szClass[64];
  DWORD      dummy = 64;
  DWORD      cbSecDesc;
  HKEY       hkeyGroups;
  BOOL       bCommonGroup;

  wLockError = 0;   // No errors.

  /* Find the handle and try to lock it. */
  pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);
  lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

  /* If we got a non-NULL selector, return the pointer. */
  if (pGroup->fLoaded)
      return(lpgd);

  if (lpgd) {
      GlobalUnlock(pGroup->hGroup);
  }

  NukeIconBitmap(pGroup);        // invalidate the bitmap

  /* The group has been discarded, must reread the file... */
  lpszKey = pGroup->lpKey;

  pGroup->fRO = FALSE;

  bCommonGroup = pGroup->fCommon;
  if (bCommonGroup)
      hkeyGroups = hkeyCommonGroups;
  else if (bUseANSIGroups)
      hkeyGroups = hkeyAnsiProgramGroups;
  else
      hkeyGroups = hkeyProgramGroups;

  if (!hkeyGroups)
      goto RegError;

  /* Try to open the group key. */
  if (err = RegOpenKeyEx(hkeyGroups, lpszKey, 0,
                         DELETE | KEY_READ | KEY_WRITE,
                         &hKey)) {
      /* Try read-only access */
      if (err = RegOpenKeyEx(hkeyGroups, lpszKey, 0,
                         KEY_READ, &hKey) || !hKey) {
          status = IDS_NOGRPFILE;
          goto LGError1;
      }
      if (!bUseANSIGroups) {
          pGroup->fRO = TRUE;
      }
  }

  if (!(err = RegQueryInfoKey(hKey,
                              szClass,
                              &dummy,   // cbClass
                              NULL,     // Title index
                              &dummy,   // cbSubKeys
                              &dummy,   // cb Max subkey length
                              &dummy,   // max class len
                              &dummy,   // values count
                              &dummy,   // max value name length
                              &cbMaxValueLen,
                              &cbSecDesc,   // cb Security Descriptor
                              &ft))) {
      if (!pGroup->ftLastWriteTime.dwLowDateTime &&
                   !pGroup->ftLastWriteTime.dwHighDateTime)
          pGroup->ftLastWriteTime = ft;
      else if (pGroup->ftLastWriteTime.dwLowDateTime != ft.dwLowDateTime ||
               pGroup->ftLastWriteTime.dwHighDateTime != ft.dwHighDateTime ) {
          wLockError = LOCK_FILECHANGED;
          status = IDS_GRPHASCHANGED;
          if (!fExiting)     // Don't reload changed groups on exit.
              PostMessage(hwndProgman,WM_RELOADGROUP,(WPARAM)pGroup,0L);
          goto LGError2;
      }
  }

  /* Find the size of the file by seeking to the end. */
  if (cbMaxValueLen < sizeof(GROUPDEF)) {
      status = IDS_BADFILE;
      goto LGError2;
  }

  /* Allocate some memory for the thing. */
  CheckBeforeReAlloc(pGroup->hGroup);
  if (!GlobalReAlloc(pGroup->hGroup, (DWORD)cbMaxValueLen, GMEM_MOVEABLE)) {
      wLockError = LOCK_LOWMEM;
      status = IDS_LOWMEM;
      lpszKey = NULL;
      goto LGError2;
  }

  pGroup->fLoaded = TRUE;
  lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

  /* Read the whole group data into memory. */
  status = IDS_BADFILE;
  if (err = RegQueryValueEx(hKey, NULL, 0, 0, (LPBYTE)lpgd, &cbMaxValueLen)) {
      goto LGError3;
  }
  //
  // If we start out from the ANSI groups, we need the security description
  // to copy the entire information to the UNICODE groups
  //
  if (bUseANSIGroups) {
      pGroup->pSecDesc = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, cbSecDesc);
      RegGetKeySecurity(hKey, DACL_SECURITY_INFORMATION, pGroup->pSecDesc, &cbSecDesc);
  }
  else {
      pGroup->pSecDesc = NULL;
  }

  //
  // If we loaded an old format ANSI group, then convert it to the
  // UNICODE format and save it back in the registry.
  //
  if (lpgd->dwMagic == GROUP_MAGIC) {
      HANDLE hUNIGroup;

      if (cbMaxValueLen = ConvertToUnicodeGroup((LPGROUPDEF_A)lpgd, &hUNIGroup)) {
          UnlockGroup(hwndGroup);
          /* Free the ANSI group. */
          GlobalFree(pGroup->hGroup);
          pGroup->hGroup = hUNIGroup;
          lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
      }
      else {
          goto LGError3;
      }
  }

  if (lpgd->dwMagic != GROUP_UNICODE)
      goto LGError3;

  if (lpgd->cbGroup > cbMaxValueLen)
      goto LGError3;

  /* Now return the pointer. */
  RegCloseKey(hKey);

  return(lpgd);

LGError3:
  GlobalUnlock(pGroup->hGroup);
  GlobalDiscard(pGroup->hGroup);
  pGroup->fLoaded = FALSE;

LGError2:
  RegCloseKey(hKey);

LGError1:
  if (status != IDS_LOWMEM && status != IDS_GRPHASCHANGED && status != IDS_NOGRPFILE) {
      MyMessageBox(hwndProgman, IDS_GROUPFILEERR, status, pGroup->lpKey,
                   MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
      if (status == IDS_BADFILE) {
          //
          // stop handling of Program Groups key changes.
          //
          bHandleProgramGroupsEvent = FALSE;

          RegDeleteKey(hkeyGroups, lpszKey);

          //
          // reset handling of Program Groups key changes.
          //
          ResetProgramGroupsEvent(bCommonGroup);
          bHandleProgramGroupsEvent = TRUE;
      }
      return(NULL);
  }

  /*
   * Special case the group not being found so we can delete it's entry...
   */
  if (status == IDS_NOGRPFILE) {
      /*
       * If no restrictions then we can fixup progman.ini...
       */
      if (!fNoSave && dwEditLevel < 1) {
          TCHAR szGroup[10];

          if (MyMessageBox(hwndProgman,IDS_GROUPFILEERR,IDS_NOGRPFILE2,lpszKey, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON1 | MB_SYSTEMMODAL) == IDNO) {
              wsprintf(szGroup,TEXT("Group%d"),pGroup->wIndex);
              //
              // stop handling of Program Groups key changes.
              //
              bHandleProgramGroupsEvent = FALSE;
              RegDeleteKey(hkeyProgramGroups, lpszKey);

              //
              // reset handling of Program Groups key changes.
              //
              ResetProgramGroupsEvent(bCommonGroup);
              bHandleProgramGroupsEvent = TRUE;
              RegDeleteValue(hkeyPMGroups, szGroup);

              if (!fFirstLoad)
                  PostMessage(hwndProgman,WM_UNLOADGROUP,(WPARAM)hwndGroup,0L);
          }
      }
      else {
RegError:
          /*
           * Restrictions mean that the user can only OK this error...
           */
          MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_NOGRPFILE, lpszKey,
                           MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
      }
  }

  ShowWindow(hwndGroup, SW_SHOWMINNOACTIVE);

  return(NULL);
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  UnlockGroup() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

void FAR PASCAL UnlockGroup(register HWND hwndGroup)

{
  GlobalUnlock(((PGROUP)GetWindowLongPtr(hwndGroup,GWLP_PGROUP))->hGroup);
}

/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  LockItem() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

LPITEMDEF FAR PASCAL LockItem(PGROUP pGroup, PITEM pItem)
{
  LPGROUPDEF        lpgd;

  lpgd = LockGroup(pGroup->hwnd);

  if (!lpgd)
      return((LPITEMDEF)NULL);

  return ITEM(lpgd,pItem->iItem);
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  KeepGroupAround() -                                                     */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/*
 * Sets or unsets the discardable flag for the given group file.  If setting
 * to non-discard, forces the group to be in memory.
 */

HANDLE PASCAL KeepGroupAround(HWND hwndGroup, BOOL fKeep)
{
    PGROUP pGroup;

    UNREFERENCED_PARAMETER(fKeep);
    pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);
    return pGroup->hGroup;

#ifdef ORGCODE
    PGROUP pGroup;
    WORD flag;

    pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);

    if (fKeep) {
        if (LockGroup(hwndGroup)) {
            UnlockGroup(hwndGroup);  // it is still in memory
        } else {
            return NULL; // failure
        }

        flag = GMEM_MODIFY | GMEM_MOVEABLE;  // make non discardable
    } else {
        flag = GMEM_MODIFY | GMEM_MOVEABLE | GMEM_DISCARDABLE;  // discardable
    }

    return GlobalReAlloc(pGroup->hGroup, 0, flag);
#endif
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SaveGroup() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*
 * Writes out a group file.  It must already be in memory or the operation
 * is meaningless.
 */
BOOL APIENTRY SaveGroup(
    HWND hwndGroup, BOOL bDiscard
    )
{
    LPGROUPDEF lpgd;
    HKEY       hKey;
    PGROUP     pGroup;
    WORD       status = 0;
    DWORD      cb;
    LONG       err;
    HKEY       hkeyGroups;
    BOOL       bCommonGroup;
    DWORD      dwDisposition;

    pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);

    bCommonGroup = pGroup->fCommon;

    if (!bUseANSIGroups && IsGroupReadOnly(pGroup->lpKey, bCommonGroup)) {
        // Don't produce an error message for RO groups.
        return FALSE;
    }

    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
    if (!lpgd) {
        return FALSE;
    }

    if (bCommonGroup)
        hkeyGroups = hkeyCommonGroups;
    else
        hkeyGroups = hkeyProgramGroups;

    if (!hkeyGroups) {
        goto Exit1;
    }

    // it may already exist

    if (err = RegCreateKeyEx(hkeyGroups, pGroup->lpKey, 0, 0, 0,
                     DELETE | KEY_READ | KEY_WRITE | WRITE_DAC,
                     pSecurityAttributes, &hKey, &dwDisposition)) {
    //if (err = RegOpenKeyEx(hkeyGroups, pGroup->lpKey, 0,
    //                              KEY_SET_VALUE, &hKey)) {
        /*
         * We can't open output group key.
         */
        if (err = RegOpenKeyEx(hkeyGroups, pGroup->lpKey, 0,
                                  KEY_READ, &hKey)) {
            status = IDS_NOGRPFILE;
        } else {
            // status = IDS_GRPISRO;
            RegCloseKey(hKey);
        }
        goto Exit1;
    }
    else {
        if (dwDisposition == REG_CREATED_NEW_KEY && bUseANSIGroups) {
            RegSetKeySecurity(hKey, DACL_SECURITY_INFORMATION, pGroup->pSecDesc);
            LocalFree(pGroup->pSecDesc);
            pGroup->pSecDesc = NULL;
        }

    }

    //
    // stop handling Program Groups key changes for a SAveGroup.
    //
    bHandleProgramGroupsEvent = FALSE;

    cb = SizeofGroup(lpgd);
    if (err = RegSetValueEx(hKey, NULL, 0, REG_BINARY, (LPBYTE)lpgd, cb)) {
        status = IDS_CANTWRITEGRP;
    }

    RegFlushKey(hKey);
    RegCloseKey(hKey);

    pGroup->ftLastWriteTime.dwLowDateTime = 0;   // update file time stamp if we need to reload
    pGroup->ftLastWriteTime.dwHighDateTime = 0;

Exit1:
    GlobalUnlock(pGroup->hGroup);

    if (status && !fExiting) {
        MyMessageBox(hwndProgman, IDS_GROUPFILEERR, status, pGroup->lpKey,
                MB_OK | MB_ICONEXCLAMATION);

        /*
         * Force the group to be reset.
         */
        if (bDiscard) {
            GlobalDiscard(pGroup->hGroup);
            pGroup->fLoaded = FALSE;
            InvalidateRect(pGroup->hwnd, NULL, TRUE);
        }
    }

    //
    // reset handling of Program Groups key changes.
    //
    ResetProgramGroupsEvent(bCommonGroup);
    bHandleProgramGroupsEvent = TRUE;
    return (status == 0);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AdjustPointers() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*
 * Adjusts pointers in the segment after a section is moved up or down.
 */
void PASCAL AdjustPointers(LPGROUPDEF lpgd, DWORD iFirst, DWORD di)
{
    WORD i;
    LPITEMDEF lpid;

    if (lpgd->pName >= iFirst) {
        lpgd->pName += di;
    }

    for (i = 0; i < lpgd->cItems; i++) {
        if (!lpgd->rgiItems[i]) {
            continue;
        }

        if (lpgd->rgiItems[i] >= iFirst) {
            lpgd->rgiItems[i] += di;
        }

        lpid = ITEM(lpgd, i);

        if (lpid->pIconRes >= iFirst)
            lpid->pIconRes += di;
        if (lpid->pName >= iFirst)
            lpid->pName += di;
        if (lpid->pCommand >= iFirst)
            lpid->pCommand += di;
        if (lpid->pIconPath >= iFirst)
            lpid->pIconPath += di;
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindFreeItemIndex() -                                                   */
/*                                                                          */
/* Returns the index of a free slot in the item offset array.  If necessary,*/
/* moves stuff around.                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

WORD PASCAL FindFreeItemIndex(HWND hwndGroup)
{
    LPGROUPDEF lpgd;
    PGROUP     pGroup;
    WORD       i;
    LPTSTR      lp1;
    LPTSTR      lp2;
    DWORD      cb;

    lpgd = LockGroup(hwndGroup);
    if (!lpgd) {
        return(0xFFFF);
    }

    for (i = 0; i < lpgd->cItems; i++) {
        if (!lpgd->rgiItems[i]) {
            UnlockGroup(hwndGroup);
            return(i);
        }
    }

    /*
     * Didn't find an empty slot... make some new ones.
     */
    pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);

    // Current groups+tags size.
    cb = SizeofGroup(lpgd);

    // Increase space reserved item info.
    lpgd->cbGroup += NSLOTS*sizeof(DWORD);

    // Increase size of whole group.
    cb += NSLOTS*sizeof(DWORD);

    UnlockGroup(hwndGroup);

    CheckBeforeReAlloc(pGroup->hGroup);
    if (!GlobalReAlloc(pGroup->hGroup, cb, GMEM_MOVEABLE)) {
        return 0xFFFF;
    }

    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

    /*
     * Copy tags junk (which starts at the end of the rgiItems array)
     * up a bit to make room for the bigger array..
     */
    lp1 = (LPTSTR)&(lpgd->rgiItems[lpgd->cItems]);
    lp2 = (LPTSTR)&(lpgd->rgiItems[lpgd->cItems + NSLOTS]);

    /*
     * Copy everything down in the segment.
     */
    RtlMoveMemory(lp2, lp1, (WORD)(cb - (DWORD)((LPSTR)lp2 - (LPSTR)lpgd)));

    /*
     * Zero out the new offsets.
     */
    for (i = (WORD)lpgd->cItems; i < (WORD)(lpgd->cItems + NSLOTS); i++) {
        lpgd->rgiItems[i] = 0;
    }

    i = lpgd->cItems;

    /* Record that we now have more slots */
    lpgd->cItems += NSLOTS;

    /*
     * Fix up all the offsets in the segment.  Since the rgiItems array is
     * part of the group header, all the pointers will change.
     */
    AdjustPointers(lpgd, (WORD)1, NSLOTS * sizeof(DWORD));

    GlobalUnlock(pGroup->hGroup);

    return i;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DeleteThing() -                                                         */
/*                                                                          */
/*                                                                          */
/* Removes a part of the group segment.  Updates everything in the segment  */
/* but does not realloc.                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void NEAR PASCAL DeleteThing(LPGROUPDEF lpgd, LPDWORD lpiThing, WORD cbThing)
{
  DWORD       dwThingOffset;
  LPTSTR      lp1;
  LPTSTR      lp2;
  INT        cb;
  WORD       cbThingSize;

  if (cbThing == 0xFFFF) {
      return;
  }

  dwThingOffset = *lpiThing;

  if (!dwThingOffset)
      return;

  *lpiThing = 0;

  lp1 = (LPTSTR) PTR(lpgd, dwThingOffset);

  /* If its a string we're removing, the caller can pass 0 as the length
   * and have it calculated!!!
   */
  if (!cbThing) {
      cbThing = (WORD)sizeof(TCHAR)*(1 + lstrlen(lp1));
  }

  cbThingSize = (WORD)MyDwordAlign((int)cbThing);

  lp2 = (LPTSTR)((LPBYTE)lp1 + cbThingSize);

  cb = (int)SizeofGroup(lpgd);

  RtlMoveMemory(lp1, lp2, (cb - (DWORD)((LPSTR)lp2 - (LPSTR)lpgd)));

  lpgd->cbGroup -= cbThingSize;

  AdjustPointers(lpgd, dwThingOffset, -cbThingSize);

}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddThing() -                                                            */
/*                                                                          */
/* in:                                                                      */
/*	hGroup	group handle, must not be discardable                           */
/*	lpStuff	pointer to data or NULL to init data to zero                    */
/*	cbStuff	count of item (may be 0) if lpStuff is a string                 */
/*                                                                          */
/* Adds an object to the group segment and returns its offset.	Will        */
/* reallocate the segment if necessary.                                     */
/*                                                                          */
/* Handle passed in must not be discardable                                 */
/*                                                                          */
/* returns:                                                                 */
/*	0	failure                                                             */
/*	> 0	offset to thing in the segment                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

DWORD PASCAL AddThing(HANDLE hGroup, LPTSTR lpStuff, DWORD cbStuff)
{
    DWORD        cb;
    LPGROUPDEF  lpgd;
    DWORD        offset;
    LPTSTR       lpT;
    DWORD        cbStuffSize;
    DWORD        cbGroupSize;
    DWORD        myOffset;

    if (cbStuff == 0xFFFFFFFF) {
        return 0xFFFFFFFF;
    }

    if (!cbStuff) {
        cbStuff = sizeof(TCHAR)*(DWORD)(1 + lstrlen(lpStuff));
    }

    cbStuffSize = MyDwordAlign((int)cbStuff);

    lpgd = (LPGROUPDEF)GlobalLock(hGroup);
    cb = SizeofGroup(lpgd);
    cbGroupSize = MyDwordAlign((int)cb);

    offset = lpgd->cbGroup;
    myOffset = (DWORD)MyDwordAlign((int)offset);

    GlobalUnlock(hGroup);

    CheckBeforeReAlloc(hGroup);
    if (!GlobalReAlloc(hGroup,(DWORD)(cbGroupSize + cbStuffSize), GMEM_MOVEABLE))
        return 0;

    lpgd = (LPGROUPDEF)GlobalLock(hGroup);

    /*
     * Slide the tags up
     */
    RtlMoveMemory((LPSTR)lpgd + myOffset + cbStuffSize, (LPSTR)lpgd + myOffset,
                            (cbGroupSize - myOffset));
    lpgd->cbGroup += cbStuffSize;

    lpT = (LPTSTR)((LPSTR)lpgd + myOffset);
    if (lpStuff) {
        RtlMoveMemory(lpT, lpStuff, cbStuff);

    } else {
        /*
         * Zero it
         */
        while (cbStuffSize--) {
            *((LPSTR)lpT)++ = 0;
        }
    }


    GlobalUnlock(hGroup);

    return myOffset;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindTag() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LPPMTAG NEAR PASCAL FindTag(LPGROUPDEF lpgd, int item, WORD id)
{
    LPPMTAG lptag;
    int cbSeg;
    int cb;

    cbSeg = (DWORD)GlobalSize(lpgd);

    lptag = (LPPMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) + 4 <= cbSeg
        && lptag->wID == ID_MAGIC
        && lptag->wItem == (int)0xFFFF
        && lptag->cb == (WORD)(MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) +4)
        && *(LONG FAR *)lptag->rgb == PMTAG_MAGIC) {

        while ((cb = (int)((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)))) <= cbSeg)
        {
            if ((item == lptag->wItem)
                && (id == 0 || id == lptag->wID)) {
                return lptag;
            }

            if (lptag->wID == ID_LASTTAG)
                return NULL;

            (LPSTR)lptag += lptag->cb;
        }
    }
    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CopyTag() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT FAR PASCAL CopyTag(LPGROUPDEF lpgd, int item, WORD id, LPTSTR lpbuf, int cb)
{
    LPTSTR lpt;
    LPPMTAG lptag;
    WORD cbT;

    lptag = FindTag(lpgd,item,id);

    if (lptag == NULL)
        return 0;

    if (cb > (int)lptag->cb)
        cb = lptag->cb;

    cbT = (WORD)cb;

    lpt = (LPTSTR) lptag->rgb;

    while (*lpt && cbT) {
       *lpbuf++=*lpt++;
       cbT--;
    }

    if (!(*lpt) && cbT) {
        *lpbuf = TEXT('\0');
    }

    return cb;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DeleteTag() -                                                           */
/*                                                                          */
/* in:                                                                      */
/*	hGroup	group handle, can be discardable (alwayws shrink object)        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID FAR PASCAL DeleteTag(HANDLE hGroup, int item, WORD id)
{
    LPPMTAG lptag;
    LPTSTR lp1, lp2;
    LPTSTR lpend;
    LPGROUPDEF lpgd;

    lpgd = (LPGROUPDEF) GlobalLock(hGroup);

    lptag = FindTag(lpgd,item,id);

    if (lptag == NULL) {
        GlobalUnlock(hGroup);
        return;
    }

    lp1 = (LPTSTR)lptag;

    lp2 = (LPTSTR)((LPSTR)lptag + lptag->cb);

    lpend = (LPTSTR)((LPSTR)lpgd + SizeofGroup(lpgd));

    while (lp2 < lpend) {
        *lp1++ = *lp2++;
    }

    /* always reallocing smaller
     */
    GlobalUnlock(hGroup);
    CheckBeforeReAlloc(hGroup);
    GlobalReAlloc(hGroup, (DWORD)((LPSTR)lp1 - (LPSTR)lpgd), 0);

    return;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddTag() -                                                              */
/*                                                                          */
/* in:                                                                      */
/*	h	group handle, must not be discardable!                              */
/*                                                                          */
/* returns:                                                                 */
/*  0	failure                                                             */
/*	1	success                                                             */
/*--------------------------------------------------------------------------*/
INT PASCAL AddTag(HANDLE h, int item, WORD id, LPTSTR lpbuf, int cb)
{
    LPPMTAG lptag;
    WORD fAddFirst;
    LPGROUPDEF lpgd;
    int cbNew;
    int cbMyLen;
    LPGROUPDEF lpgdOld;


    if (!cb && lpbuf) {
        cb = sizeof(TCHAR)*(lstrlen(lpbuf) + 1);
    }
    cbMyLen = MyDwordAlign(cb);

    if (!lpbuf) {
        cb = 0;
        cbMyLen = 0;
    }

    /*
     * Remove the old version of the tag, if any.
     */
    DeleteTag(h, item, id);

    lpgd = (LPGROUPDEF)GlobalLock(h);

    lptag = FindTag(lpgd, (int)0xFFFF, (WORD)ID_LASTTAG);

    if (!lptag) {
        /*
         * In this case, there are no tags at all, and we have to add
         * the first tag, the interesting tag, and the last tag
         */
        cbNew = 3 * (MyDwordAlign(sizeof(PMTAG)) - MyDwordAlign(sizeof(lptag->rgb))) + 4 + cbMyLen;
        fAddFirst = TRUE;
        lptag = (LPPMTAG)((LPSTR)lpgd + lpgd->cbGroup);

    } else {
        /*
         * In this case, only the interesting tag needs to be added
         * but we count in the last because the delta is from lptag
         */
        cbNew = 2 * (MyDwordAlign(sizeof(PMTAG)) - MyDwordAlign(sizeof(lptag->rgb))) + cbMyLen;
        fAddFirst = FALSE;
    }

    /*
     * check for 64K limit
     */
    if ((DWORD_PTR)lptag + cbNew < (DWORD_PTR)lptag) {
        return 0;
    }

    cbNew += (int)((PCHAR)lptag -(PCHAR)lpgd);
    lpgdOld = lpgd;
    GlobalUnlock(h);
    CheckBeforeReAlloc(h);
    if (!GlobalReAlloc(h, (DWORD)cbNew, GMEM_MOVEABLE)) {
        return 0;
    }

    lpgd = (LPGROUPDEF)GlobalLock(h);
    lptag = (LPPMTAG)((LPSTR)lpgd + ((LPSTR)lptag - (LPSTR)lpgdOld));
    if (fAddFirst) {
        /*
         * Add the first tag
         */
        lptag->wID = ID_MAGIC;
        lptag->wItem = (int)0xFFFF;
        *(LONG FAR *)lptag->rgb = PMTAG_MAGIC;
        lptag->cb = (WORD)(MyDwordAlign(sizeof(PMTAG)) - MyDwordAlign(sizeof(lptag->rgb)) + 4);
        (LPSTR)lptag += lptag->cb;
    }

    /*
     * Add the tag
     */
    lptag->wID = id;
    lptag->wItem = item;
    lptag->cb = (WORD)(MyDwordAlign(sizeof(PMTAG)) - MyDwordAlign(sizeof(lptag->rgb)) + cbMyLen);
    if (lpbuf) {
        RtlMoveMemory(lptag->rgb, lpbuf, (WORD)cb);
    }
    (LPSTR)lptag += lptag->cb;

    /*
     * Add the end tag
     */
    lptag->wID = ID_LASTTAG;
    lptag->wItem = (int)0xFFFF;
    lptag->cb = 0;

    GlobalUnlock(h);

    return 1;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  NukeIconBitmap -- Deletes the icon bitmap if one exists for the group   */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void PASCAL NukeIconBitmap(PGROUP pGroup)
{
    if (pGroup->hbm) {
        DeleteObject(pGroup->hbm);
        pGroup->hbm = NULL;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GroupFlag() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

WORD PASCAL GroupFlag(PGROUP pGroup, PITEM pItem, WORD wFlag)
{
    LPGROUPDEF lpgd;
    LPPMTAG lptag;
    WORD wT = 0;
    int wItem;

    if (pItem) {
        wItem = pItem->iItem;
    } else {
        wItem = (int)0xFFFF;
    }

    lpgd = LockGroup(pGroup->hwnd);
    if (!lpgd)
        return 0;

    lptag = FindTag(lpgd, wItem, wFlag);

    if (!lptag)
        wT = 0;
    else if (lptag->cb == (WORD)(MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb))))
        wT = 1;
    else if (lptag->cb == (WORD)(MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) + 1))
        wT = lptag->rgb[0];
    else if (lptag->cb == (WORD)(MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) + 4))
        wT = *(LPWORD)lptag->rgb;
    UnlockGroup(pGroup->hwnd);

    return wT;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetGroupTag() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

WORD PASCAL GetGroupTag(
    PGROUP pGroup,
    PITEM pItem,
    WORD id,
    LPTSTR lpT,
    WORD cb)
{
    WORD wT;
    LPGROUPDEF lpgd;
    int wItem;

    if (pItem)
        wItem = pItem->iItem;
    else
        wItem = (int)0xFFFF;

    lpgd = LockGroup(pGroup->hwnd);
    if (!lpgd)
        return 0;

    wT = (WORD)CopyTag(lpgd, wItem, id, lpT, cb);

    UnlockGroup(pGroup->hwnd);
    return wT;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ChangeTagID() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void PASCAL ChangeTagID(
    LPGROUPDEF lpgd,
    int iOld,
    int iNew)
{
    LPPMTAG lptag;

    while (lptag = FindTag(lpgd,iOld,0)) {
        lptag->wItem = iNew;
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  LoadItem() -                                                            */
/*                                                                          */
/* Creates an item window (iconic) within a group window.  Assumes that the */
/* group segment is up to date.                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

PITEM PASCAL LoadItem(HWND hwndGroup, WORD iItem, BOOL bActivate)
{
    LPGROUPDEF lpgd;
    LPITEMDEF  lpid;
    PGROUP     pGroup;
    PITEM      pItem;
    PITEM      *ppItem;

    lpgd = LockGroup(hwndGroup);
    if (!lpgd)
        return NULL;

    pItem = (PITEM)LocalAlloc(LPTR, sizeof(ITEM));
    if (!pItem) {
        UnlockGroup(hwndGroup);
        return NULL;
    }

    pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);

    NukeIconBitmap(pGroup);

    if (bActivate) {
        InvalidateIcon(pGroup, pGroup->pItems);
        pItem->pNext = pGroup->pItems;
        pGroup->pItems = pItem;
    } else {
        ppItem = &pGroup->pItems;
        while (*ppItem) {
            ppItem = &((*ppItem)->pNext);
        }
        pItem->pNext = NULL;
        *ppItem = pItem;
    }

    lpid = ITEM(lpgd, iItem);

    pItem->iItem = iItem;
    pItem->dwDDEId = 0;
    SetRectEmpty(&pItem->rcTitle);
    SetRectEmpty(&pItem->rcIcon);

    ComputeIconPosition(pGroup, lpid->pt, &pItem->rcIcon, &pItem->rcTitle,
            (LPTSTR) PTR(lpgd, lpid->pName));

    UnlockGroup(hwndGroup);

    InvalidateIcon(pGroup, pItem);

    return pItem;
}


PITEM FindItemName(LPGROUPDEF lpgd, register PITEM pItem, LPTSTR lpTitle)
{
  LPITEMDEF  lpid;

  while (pItem) {
      lpid = ITEM(lpgd, pItem->iItem);

      if (!lstrcmp(lpTitle, (LPTSTR) PTR(lpgd, lpid->pName)))
        return pItem;

      pItem = pItem->pNext;
  }

  return NULL;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateNewItem() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*
 * Creates a new item in the file, and adds a window for it.
 */
PITEM PASCAL CreateNewItem(
    HWND    hwndGroup,
    LPTSTR   lpTitle,
    LPTSTR   lpCommand,
    LPTSTR   lpIconPath,
    LPTSTR   lpDefDir,
    WORD    wHotKey,
    BOOL    fMinimize,
    WORD    wIconId,
    WORD    wIconIndex,
    HICON   hIcon,
    LPPOINT lppt,
    DWORD   dwFlags)
{
    LPGROUPDEF lpgd;
    LPITEMDEF  lpid;
    WORD       id;
    DWORD      offset;
    PGROUP     pGroup;
    LPTSTR     lpIconRes;
    WORD       cbIconRes;
    //DWORD    dwVer;
    WORD       wVer;
    WORD       idError = IDS_LOWMEM;
    PITEM      pItem;
    DWORD      cb;
    TCHAR      szCommand[3*MAX_PATH];
    TCHAR      szExeDir[MAXITEMPATHLEN + 1];
    TCHAR      szIconExe[MAX_PATH];
    TCHAR      szTemp[MAXITEMPATHLEN+1];
    LPTSTR     lp1, lp2, lp3;
    HANDLE     hIconRes;
    HANDLE     hModule;
    BOOL       fWin32App = FALSE;
    BOOL       fUseDefaultIcon = FALSE;
    BOOL       bNoIconPath = TRUE;
    TCHAR      cSeparator;

    /*
     * Before we do anything, whack the command line and exedir
     */
    lp1 = lpCommand;
    if (*lpCommand == TEXT('"') && wcschr(lpCommand + 1, TEXT('"'))) {
        cSeparator = TEXT('"');
        //lp1++;
    }
    else {
        cSeparator = TEXT(' ');
    }
    for (lp2=lp3=szExeDir; *lp1 && *lp1 != cSeparator; lp1 = CharNext(lp1))
    {
        *lp2++ = *lp1;

        /*
         * We know we're looking at the first byte
         */
        if ((*lp1 == TEXT(':')) || (*lp1 == TEXT('\\'))) {
            lp3 = lp2;
        }
    }

    *lp2 = 0;

    /*
     * If the default dir pointer is NULL then we use the directory
     * component of the command line.  Otherwise we do the normal
     * path whacking stuff to get everything into 3.0 format.
     */
    if (lpDefDir) {
        LPTSTR lpT;

        lpT = lpDefDir;
        // We have a valid pointer.
    	lstrcpy(szCommand,lpDefDir);
#if 0
/* spaces are allowed in LFN.
 */
        RemoveLeadingSpaces(szCommand);
#endif

        // If a default dir was supplied then go ahead and whack it
        // into 3.0 format otherwise leave it blank.
        if (*lpDefDir)
        {
            LPTSTR lpNextChar;

            // locate the character before the NULL
            while ( *(lpNextChar = CharNext(lpDefDir)) )
                lpDefDir = lpNextChar;

            // If there is no '\' seperator, add one.
            if (lpDefDir[0] != TEXT('\\')) {
                lstrcat(szCommand,TEXT("\\"));
            }
        }

        /*
         * Now add the filename itself.  this puts the command in the
         * 3.0 format: defdir\exename
         */
        lstrcat(szCommand, lp3);

        /*
         * Append the arguments
         */
        lstrcat(szCommand, lp1);
        lpDefDir = lpT;

    } else {
        /*
         * Use the same command line (note def dir is assigned exe dir
         */
        lstrcpy(szCommand, lpCommand);
    }

    /*
     * Now truncate exedir so that it does not include the command filename
     */
    *lp3 = 0;

    pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);
    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

    if (!GroupCheck(pGroup)) {
    	MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_GROUPRO,
                     (LPTSTR) PTR(lpgd, lpgd->pName),
                     MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
	GlobalUnlock(pGroup->hGroup);
        return NULL;
    }
    GlobalUnlock(pGroup->hGroup);

    if (*lpIconPath) {
	    bNoIconPath = FALSE;
    }

    lstrcpy(szIconExe, lpIconPath);
    if (bNoIconPath && !(dwFlags & CI_NO_ASSOCIATION)) {
        lstrcpy(szIconExe, lpCommand);
    }
    DoEnvironmentSubst(szIconExe, (WORD)CharSizeOf(szIconExe));
    StripArgs(szIconExe);
    if (!bNoIconPath) {
        TagExtension(szIconExe, sizeof(szIconExe));
    }

    if (*szIconExe == TEXT('"') && *(szIconExe + lstrlen(szIconExe)-1) == TEXT('"')) {
        SheRemoveQuotes(szIconExe);
    }

    if (bNoIconPath) {
        //
        // if it's a relative path, extractassociatedicon and LoadLibrary don't
        // handle that so find the executable first
        //
        SetCurrentDirectory(szOriginalDirectory);
        FindExecutable(szIconExe, lpDefDir, szTemp);
        if (*szTemp) {
            lstrcpy(szIconExe, szTemp);
            TagExtension(szIconExe, sizeof(szIconExe));
            if (*szIconExe == TEXT('"') && *(szIconExe + lstrlen(szIconExe)-1) == TEXT('"')) {
		        SheRemoveQuotes(szIconExe);
	        }
        }
        else {
            *szIconExe = 0;    // Use a dummy value so no icons will be found
                               // and progman's item icon will be used instead
                               // This is to make moricons.dll item icon be the
                               // right one.  -johannec 6/4/93
        }
        //
        // reset the current directory to progman's working directory i.e. Windows directory
        //
        SetCurrentDirectory(szWindowsDirectory);

        wIconId = 0;
        wIconIndex = 0;
    }


NoIcon:

    if (!wIconId) {
        TCHAR szOldIconExe[MAX_PATH];

        lstrcpy(szOldIconExe, szIconExe);
        hIcon = ExtractAssociatedIconEx(hAppInstance, szIconExe, &wIconIndex, &wIconId);
        if (lstrcmp(szOldIconExe, szIconExe)) {
            /* using default icon from Progman.exe */
            fUseDefaultIcon = TRUE;
        }
        if (hIcon)
            DestroyIcon(hIcon);
    }

    lpIconRes = NULL;
    hIconRes = NULL;
    if (hModule = LoadLibrary(szIconExe)) {
        fWin32App = TRUE;
        hIconRes = FindResource(hModule, (LPTSTR) MAKEINTRESOURCE(wIconId), (LPTSTR) MAKEINTRESOURCE(RT_ICON));
        if (hIconRes) {
            //dwVer = 0x00030000;  // resource version is windows 3.x
            wVer = 3;  // resource version is windows 3.x
            cbIconRes = (WORD)SizeofResource(hModule, hIconRes);
            hIconRes = LoadResource(hModule, hIconRes);
            lpIconRes = LockResource(hIconRes);
        }
        if (fUseDefaultIcon) {
            wIconId = 0;
        }
    }
    else { // Win 3.1 app

        if (wVer = ExtractIconResInfo(hAppInstance, szIconExe, wIconIndex, &cbIconRes, &hIconRes)){
            lpIconRes = GlobalLock(hIconRes);
        }
    }

    if (!lpIconRes) {
       wIconId = 0;
       wIconIndex = 0;

       // ToddB: I see no harm in always setting the current directory to the WinDir
       //   before jumping back to NoIcon.  Seems to be required to fix a Japanese bug.
       //   The WinDir is the default directory of Progman anyhow, I really don't see
       //   where it's possible for us to not already be in this directory.
       SetCurrentDirectory(szWindowsDirectory);

       goto NoIcon;
    }

    if (!KeepGroupAround(hwndGroup, TRUE)) {
        goto FreeIcon;
    }

    id = FindFreeItemIndex(hwndGroup);
    if (id == 0xFFFF) {
        goto FreeIcon;
    }

    if (id >= CITEMSMAX) {                      // check group size limit
        idError = IDS_TOOMANYITEMS;
        goto FreeIcon;
    }

    offset = AddThing(pGroup->hGroup, (TCHAR)0, (WORD)sizeof(ITEMDEF));
    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

    if (!offset) {
        goto QuitThis;
    }

    lpgd->rgiItems[id] = offset;
    lpid = ITEM(lpgd, id);

    GlobalUnlock(pGroup->hGroup);
    offset = AddThing(pGroup->hGroup, lpTitle, (WORD)0);
    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
    lpid = ITEM(lpgd, id);
    if (!offset) {
        goto PuntCreation;
    }

    lpid->pName = offset;

    GlobalUnlock(pGroup->hGroup);
    offset = AddThing(pGroup->hGroup, szCommand,(WORD) 0);
    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
    lpid = ITEM(lpgd, id);
    if (!offset) {
        goto PuntCreation;
    }
    lpid->pCommand = offset;

    GlobalUnlock(pGroup->hGroup);
    CheckEscapes(szIconExe, CharSizeOf(szIconExe));
    offset = AddThing(pGroup->hGroup, szIconExe,(WORD) 0);
    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
    lpid = ITEM(lpgd, id);
    if (!offset)
        goto PuntCreation;
    lpid->pIconPath = offset;

    GlobalUnlock(pGroup->hGroup);
    offset = AddThing(pGroup->hGroup, lpIconRes, cbIconRes);
    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
    lpid = ITEM(lpgd, id);
    if (!offset)
        goto PuntCreation;
    lpid->pIconRes = offset;

    if (lppt) {
        lpid->pt = *lppt;
    } else {
        lpid->pt.x = lpid->pt.y = -1;
    }

    lpid->iIcon = wIconId;
    lpid->wIconIndex = wIconIndex;
    //lpid->dwIconVer = dwVer;
    lpid->wIconVer = wVer;
    lpid->cbIconRes = cbIconRes;

    if (cbIconRes != 0xFFFF)
    if (fWin32App) {
        UnlockResource(hIconRes);
        FreeResource(hIconRes);
        FreeLibrary(hModule);
    }
    else {
        GlobalUnlock(hIconRes);
        GlobalFree(hIconRes);
    }
    GlobalUnlock(pGroup->hGroup);

    if (wHotKey) {
        AddTag(pGroup->hGroup, (int)id, (WORD)ID_HOTKEY, (LPTSTR)&wHotKey, sizeof(wHotKey));
    }
    if (fMinimize) {
        AddTag(pGroup->hGroup, (int)id, (WORD)ID_MINIMIZE, NULL, 0);
    }
    if (dwFlags & CI_SEPARATE_VDM) {
        AddTag(pGroup->hGroup, (int)id, (WORD)ID_NEWVDM, NULL, 0);
    }
    if (*szExeDir) {
        AddTag(pGroup->hGroup, (int)id, (WORD)ID_APPLICATIONDIR, szExeDir, 0);
    }

    pItem = LoadItem(hwndGroup, id, dwFlags & CI_ACTIVATE);

    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
    lpid = ITEM(lpgd, id);

    if (!pItem) {
        goto PuntCreation;
    }

    lpid->pt.x = pItem->rcIcon.left;
    lpid->pt.y = pItem->rcIcon.top;

    GlobalUnlock(pGroup->hGroup);

#if 0
// DOS apps are no longer set to fullscreen by default in progman
//  5-3-93 johannec (bug 8343)
#ifdef i386
    //
    // If this is a new DOS application, set the default to full screen.
    // This is only done for x86, since mips doesn't have full screen.
    //
    lstrcpy(szCommand, lpCommand);
    DoEnvironmentSubst(szCommand, (WORD)lstrlen(szCommand));
    StripArgs(szCommand);
    TagExtension(szCommand, sizeof(szCommand));
    *szTemp = 0;
    FindExecutable(szCommand, lpDefDir, szTemp);

    if ((dwFlags & CI_SET_DOS_FULLSCRN) && *szTemp && IsDOSApplication(szTemp)) {
        SetDOSApplicationToFullScreen(lpTitle);
    }
#endif
#endif

    KeepGroupAround(hwndGroup, FALSE);

    // We need to save the current group to disk now
    // in case a setup program is doing DDE with us,
    // and they reboot the system when finished.

    if (!SaveGroup (hwndGroup, FALSE)) {
        idError = 0;
        DeleteItem(pGroup, pItem);
        goto FreeIcon;
    }

    return pItem;

PuntCreation:
    /*
     * Note, must set lpid after each because it may move
     */
    DeleteThing(lpgd, (LPDWORD)&lpid->pName, 0);
    DeleteThing(lpgd, (LPDWORD)&lpid->pCommand, 0);
    DeleteThing(lpgd, (LPDWORD)&lpid->pIconPath, 0);
    DeleteThing(lpgd, (LPDWORD)&lpid->pIconRes, lpid->cbIconRes);
    DeleteThing(lpgd, (LPDWORD)&lpgd->rgiItems[id], sizeof(ITEMDEF));

QuitThis:
    cb = SizeofGroup(lpgd);
    UnlockGroup(pGroup->hwnd);

    CheckBeforeReAlloc(pGroup->hGroup);
    GlobalReAlloc(pGroup->hGroup, cb, GMEM_MOVEABLE);

    KeepGroupAround(hwndGroup, FALSE);

FreeIcon:
    if (cbIconRes != 0xFFFF)
    if (fWin32App) {
        UnlockResource(hIconRes);
        FreeResource(hIconRes);
        FreeLibrary(hModule);
    }
    else {
        GlobalUnlock(hIconRes);
        GlobalFree(hIconRes);
    }

    if (idError != 0)
        MyMessageBox(hwndProgman, IDS_GROUPFILEERR, idError, NULL,
                        MB_OK | MB_ICONEXCLAMATION);
    // Force re-read of group.
    //GlobalDiscard(pGroup->hGroup);
    //pGroup->fLoaded = FALSE ;
    //LockGroup(pGroup->hwnd);
    //UnlockGroup(pGroup->hwnd);

    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DeleteItem() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID FAR PASCAL DeleteItem(PGROUP pGroup, PITEM pItem)
{
  LPGROUPDEF lpgd;
  LPITEMDEF  lpid;
  DWORD      cb;
  LPPMTAG    lptag;

  lpgd = LockGroup(pGroup->hwnd);
  if (!lpgd)
      return;

  if (!GroupCheck(pGroup)) {
      MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_GROUPRO,
                   (LPTSTR) PTR(lpgd, lpgd->pName),
                   MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
      InvalidateIcon(pGroup, pItem);
      return;
  }

  NukeIconBitmap(pGroup);

  lpid = ITEM(lpgd,pItem->iItem);

  if ( (lpgd->cbGroup != (DWORD)MyDwordAlign((int)lpgd->cbGroup)) ||
       (lpid->pName != (DWORD)MyDwordAlign((int)lpid->pName)) ||
       (lpid->pCommand != (DWORD)MyDwordAlign((int)lpid->pCommand)) ||
       (lpid->pIconPath != (DWORD)MyDwordAlign((int)lpid->pIconPath)) ||
       (lpgd->rgiItems[pItem->iItem] != (DWORD)MyDwordAlign((int)lpgd->rgiItems[pItem->iItem])) ) {

      MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_BADFILE,
                   (LPTSTR) PTR(lpgd, lpgd->pName),
                   MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
      return;
  }


  /* note, must set lpid after each because it may move
   */
  DeleteThing(lpgd, (LPDWORD)&lpid->pName, 0);
  DeleteThing(lpgd, (LPDWORD)&lpid->pCommand, 0);
  DeleteThing(lpgd, (LPDWORD)&lpid->pIconPath, 0);
  DeleteThing(lpgd, (LPDWORD)&lpid->pIconRes, lpid->cbIconRes);
  DeleteThing(lpgd, (LPDWORD)&lpgd->rgiItems[pItem->iItem], sizeof(ITEMDEF));

  while (lptag = FindTag(lpgd,pItem->iItem,0)) {
      /* delete all tags associated with this item
       */
      UnlockGroup(pGroup->hwnd);
      DeleteTag(pGroup->hGroup, lptag->wItem, lptag->wID);
      lpgd = LockGroup(pGroup->hwnd);
  }

  /* Don't need Item anymore so delete it. */
  RemoveItemFromList(pGroup, pItem);

  cb = SizeofGroup(lpgd);

  UnlockGroup(pGroup->hwnd);

  CheckBeforeReAlloc(pGroup->hGroup);
  GlobalReAlloc(pGroup->hGroup, cb, GMEM_MOVEABLE);

  if (bAutoArrange && !bAutoArranging)
      ArrangeItems(pGroup->hwnd);
  else if (!bAutoArranging)
      CalcGroupScrolls(pGroup->hwnd);

}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateItemIcons() -                                                     */
/*                                                                          */
/* Creates all the item windows...                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID PASCAL CreateItemIcons(HWND hwndGroup)
{
    LPGROUPDEF lpgd;
    int        i;

    lpgd = LockGroup(hwndGroup);

    if (!lpgd) {
        return;
    }

    /*
     * Create the items in reverse Z-Order.
     */
    for (i = lpgd->cItems - 1; i >= 0; i--) {
        if (lpgd->rgiItems[i]) {
            LoadItem(hwndGroup, (WORD)i, TRUE);
        }
    }

    UnlockGroup(hwndGroup);

  // REVIEW This may be not be needed because LoadGroupWindow does a
  // SetInternalWindowPos which MIGHT already be generating the messages
  // to do this.
  if (bAutoArrange && !bAutoArranging)
      ArrangeItems(hwndGroup);
  else if (!bAutoArranging)
      CalcGroupScrolls(hwndGroup);
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CheckIconResolution() -                                                 */
/*                                                                          */
/* Makes sure we have the right icons loaded... reextracts and saves        */
/* the file if not.                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL CheckIconResolution(HWND hwndGroup)

{
  LPGROUPDEF        lpgd;
  LPITEMDEF         lpid;
  register PGROUP   pGroup;
  HANDLE            hGroup;
  BOOL              fGottaDoIt;
  register HDC      hdc;
  int               i;
  HICON             hIcon;
  WORD              cbIconRes;
  DWORD             pIconRes;
  LPTSTR            lpIconRes;
  WORD              wFormat;
  TCHAR             szTemp[MAXITEMPATHLEN];
  HANDLE            hModule;
  BOOL              fWin32App;
  //DWORD             dwVer;
  WORD              wVer;

  lpgd = LockGroup(hwndGroup);
  if (!lpgd)
      return;

  hdc = GetDC(hwndGroup);

  wFormat = (WORD)GetDeviceCaps(hdc, BITSPIXEL) |
        (WORD)GetDeviceCaps(hdc, PLANES) * (WORD)256;

  ReleaseDC(hwndGroup,hdc);

  fGottaDoIt = lpgd->wIconFormat != wFormat ||
               lpgd->cxIcon != (WORD)GetSystemMetrics(SM_CXICON) ||
               lpgd->cyIcon != (WORD)GetSystemMetrics(SM_CYICON);

  if (!fGottaDoIt) {
      goto CleanUpAndLeave;
  }

  pGroup = (PGROUP)GetWindowLongPtr(hwndGroup,GWLP_PGROUP);

  NukeIconBitmap(pGroup);

  /* Save the new resolution parameters in the group file. */
  lpgd->wIconFormat = wFormat;
  lpgd->cxIcon = (WORD)GetSystemMetrics(SM_CXICON);
  lpgd->cyIcon = (WORD)GetSystemMetrics(SM_CYICON);

  hGroup = pGroup->hGroup;

  for (i = 0; i < (int)lpgd->cItems; ++i) {
      if (!lpgd->rgiItems[i])
          continue;

      lpid = ITEM(lpgd, i);
      DeleteThing(lpgd, (LPDWORD)&lpid->pIconRes, lpid->cbIconRes);
      lpid = ITEM(lpgd, i);

      lstrcpy(szTemp, (LPTSTR) PTR(lpgd, lpid->pIconPath));
      if (!*szTemp) {
          /* Get default icon path */
          lstrcpy(szTemp, (LPTSTR) PTR(lpgd, lpid->pCommand));
          DoEnvironmentSubst(szTemp, (WORD)(MAXITEMPATHLEN+1));
          StripArgs(szTemp);
      }
      SheRemoveQuotes(szTemp);
    cbIconRes = 0xFFFF;
    lpIconRes = NULL;
    hIcon = NULL;

    if (hModule = LoadLibrary(szTemp)) {
        // if WIN32 app
        fWin32App = TRUE;
        hIcon = (HICON)FindResource(hModule, (LPTSTR) MAKEINTRESOURCE(lpid->iIcon), (LPTSTR) MAKEINTRESOURCE(RT_ICON));
        if (hIcon) {
            //dwVer = 0x00030000;
            wVer = 3;
            cbIconRes = (WORD)SizeofResource(hModule, (HRSRC)hIcon);
            hIcon = (HICON)LoadResource(hModule, (HRSRC)hIcon);
            lpIconRes = LockResource(hIcon);
        }
    }
    else { // Win 3.1 app
        fWin32App = FALSE;
        if (wVer = ExtractIconResInfo(hAppInstance, szTemp, lpid->iIcon, &cbIconRes, (LPHANDLE)&hIcon)){
            lpIconRes = GlobalLock(hIcon);
        }
    }


      UnlockGroup(hwndGroup);

      pIconRes = AddThing(pGroup->hGroup, lpIconRes, cbIconRes);
      lpgd = LockGroup(hwndGroup);
      if (!lpgd)
          continue;

      /* In case the segment got moved... */
      lpid = ITEM(lpgd, i);

      if (hIcon)
      if (fWin32App) {
          UnlockResource(hIcon);
          FreeResource(hIcon);
          FreeLibrary(hModule);
      }
      else {
          GlobalUnlock(hIcon);
          GlobalFree(hIcon);
      }

      lpid->pIconRes = pIconRes;
      //lpid->dwIconVer = dwVer;
      lpid->wIconVer = wVer;
      lpid->cbIconRes = cbIconRes;
    }

#ifdef ORGCODE
      // Check everythings OK.
      if (!pHdr || !pAND || !pXOR)
        {
          // FU - delete icon stuff for this item..
          // REVIEW UNDONE - warn user about memory problem  ?

#ifdef DEBUG
          KdPrint(("PM.CIR: Corrupted icon %s \n\r", (LPTSTR) PTR(lpid->pName)));
#endif
          lpid = ITEM(lpgd, i);
          DeleteThing(lpgd, (LPDWORD)&lpid->pIconRes, lpid->cbIconRes);

          // Mark item as being effed - the header is checked by
          // GetItemIcon.
          lpid = ITEM(lpgd, i);
          lpid->pIconRes = NULL;
          lpid->wIconVer = 0;           // This is the important one.
          lpid->cbIconRes = 0;

          // Warn user when we're through, not right in the middle.
          fErrorOnExtract = TRUE;
        }
    }
#endif

  if (!GroupCheck(pGroup))
      MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_EEGROUPRO,
                   (LPTSTR) PTR(lpgd, lpgd->pName),
                   MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);


CleanUpAndLeave:
  UnlockGroup(hwndGroup);

//REVIEW See above.
  KeepGroupAround(hwndGroup, FALSE);
  return;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateGroupHandle() -                                                   */
/*                                                                          */
/* Creates a discarded handle for use as a group handle... on the first     */
/* LockGroup() the file will be loaded.                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL CreateGroupHandle(void)
{
  register HANDLE   hGroup;

  if (hGroup = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE, 1L))
      GlobalDiscard(hGroup);

  return(hGroup);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StartupGroup() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID FAR PASCAL StartupGroup(HWND hwnd)
{
  PITEM pItemCur, pItemExec;
  LPGROUPDEF lpgd;
  INT xLast, yLast;    // Coord of icon to exec.
  INT xBest, yBest;    // Coord of next topmost-leftmost icon.
  MSG msg;             // Peek a message.
  PGROUP pGroup;       // The group.

  pGroup = (PGROUP)GetWindowLongPtr(hwnd, GWLP_PGROUP);

  /*
   * Handle Startup group in icon position order - not Z-order.
   */
  lpgd = LockGroup(hwnd);
  if (!lpgd)
      return;

  /*
   * Starts with the top left and works from left to right then
   * top to bottom.
   * This is really naff in terms of speed, but groups are usually
   * small and the time cost is still small compared to that of execing.
   */
  yLast = WORD_MIN;
  xLast = WORD_MIN;
  for (;;) {
      /*
       * Init
       */
      xBest = WORD_MAX;
      yBest = WORD_MAX;
      pItemExec = NULL;
      /*
       * Find next icon to the right of this one.
       */
      for (pItemCur = pGroup->pItems; pItemCur; pItemCur = pItemCur->pNext) {
          /*
           * Look for Icon to the right of this one.
           * REVIEW This will ignore icons stacked on top of each other.
           */
          if (pItemCur->rcIcon.top >= yLast
            && pItemCur->rcIcon.top <= yLast + (cyArrange/2)
            && pItemCur->rcIcon.left < xBest
            && pItemCur->rcIcon.left > xLast) {
              pItemExec = pItemCur;
              xBest = pItemCur->rcIcon.left;
          }
          /*
           * Check if it'll be suitable for the next row.
           */
          else if (pItemCur->rcIcon.top > yLast + (cyArrange/2)
            && pItemCur->rcIcon.top < yBest) {
              yBest = pItemCur->rcIcon.top;
          }

      }

      if (pItemExec) {
          /*
           * Found one on the current row.
           */

          xLast = xBest;
          /*
           * Move this item to the top of the z-order so that any searches
           * done during DDE will find the last execed item first.
           * REVIEW This messes with the z-odrder of the startup group.
           */
          BringItemToTop(pGroup, pItemExec, TRUE);
          /* Start it up. */
          ExecItem(pGroup,pItemExec,FALSE, TRUE);
          /*
           * Handle any DDE before doing anything else to stop
           * the message queue from over-flowing.
           */
          while(PeekMessage(&msg, hwndProgman, 0, 0, PM_REMOVE|PM_NOYIELD)) {
              TranslateMessage(&msg);
              DispatchMessage(&msg);
          }


      }
      else if (yBest != WORD_MAX) {
          /*
           * Nothing left on the current row but there is another row.
           */
          yLast = yBest;
          xLast = WORD_MIN;

      }
      else {
          /*
           * Nothing left.
           */
          goto Quit;
      }
  }

Quit:
  UnlockGroup(pGroup->hwnd);
}


/*---------------------------------------------------------------------------
 * Check for null item pointers and item pointers that go out of the group.
 * REVIEW UNDONE this doesn't check that the pointers point to things
 * after the end of the items array.
 */
BOOL NEAR PASCAL ValidItems(LPGROUPDEF lpgd)
{
    INT i;
    LPITEMDEF lpid;
    DWORD cbGroup;

    if (!lpgd)
        return FALSE;


    cbGroup = lpgd->cbGroup;

    for (i = 0; (WORD)i < lpgd->cItems; i++) {
        if (!lpgd->rgiItems[i])
	        continue;

        lpid = ITEM(lpgd,i);
        if (!lpid)
            return FALSE;

        if (lpid->pName > cbGroup)
            return FALSE;
        if (lpid->pCommand > cbGroup)
            return FALSE;
        if (lpid->pIconPath > cbGroup)
            return FALSE;
        if ((lpid->cbIconRes != (WORD)-1) && (lpid->pIconRes > cbGroup))
            return FALSE;

    }

    return(TRUE);
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsGroupAlreadyLoaded() -                                                */
/*                                                                          */
/* Determines if the user is trying to load a currently loaded group.       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HWND NEAR PASCAL IsGroupAlreadyLoaded(LPTSTR lpGroupKey, BOOL bCommonGroup)
{
  HWND     hwndT;
  PGROUP   pGroup;

  for (hwndT=GetWindow(hwndMDIClient, GW_CHILD); hwndT; hwndT=GetWindow(hwndT, GW_HWNDNEXT)) {
      if (GetWindow(hwndT, GW_OWNER))
          continue;

      pGroup = (PGROUP)GetWindowLongPtr(hwndT, GWLP_PGROUP);
      if (!lstrcmpi(lpGroupKey, pGroup->lpKey)) {

          if (bCommonGroup) {

              if (pGroup->fCommon)
                  return(hwndT);

          } else {

              if (!pGroup->fCommon)
                  return(hwndT);

          }
      }
  }
  return(NULL);
}


BOOL NEAR PASCAL IndexUsed(WORD wIndex, BOOL bCommonGroup)
{
    PGROUP pGroup;

    for (pGroup = pFirstGroup; pGroup; pGroup = pGroup->pNext)
        if ((pGroup->wIndex == wIndex) && (pGroup->fCommon == bCommonGroup))
            return TRUE;

    return FALSE;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  LoadGroupWindow() -                                                     */
/*                                                                          */
/* Creates a group window by sending an MDI create message to the MDI client. */
/* The MDICREATESTRUCT contains a parameter pointer to the name of the group  */
/* key.                                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
// GroupFile must be ANSI.

HWND PASCAL LoadGroupWindow(LPTSTR lpKey, WORD wIndex, BOOL bCommonGroup)
{
    MDICREATESTRUCT mdics;
    PGROUP          pGroup;
    TCHAR           szGroupClass[64];
    LPGROUPDEF      lpgd;
    HWND            hwnd;
    TCHAR           szCommonGroupSuffix[MAXKEYLEN];
    TCHAR           szCommonGroupTitle[2*MAXKEYLEN];
    WINDOWPLACEMENT wp;

    //
    // Check if the group is already loaded. This will prevent duplicate groups.
    //
    if (hwnd = IsGroupAlreadyLoaded(lpKey, bCommonGroup)) {
        return(hwnd);
    }

    if (!wIndex) {
        while (IndexUsed(++wIndex, bCommonGroup))
                ;
    }

    if (!LoadString(hAppInstance, IDS_GROUPCLASS, szGroupClass,
            CharSizeOf(szGroupClass))) {
        return NULL;
    }

    pGroup = (PGROUP)LocalAlloc(LPTR,sizeof(GROUP));
    if (!pGroup) {
        return NULL;
    }

    pGroup->hGroup = CreateGroupHandle();
    pGroup->pItems = NULL;
    pGroup->hbm    = NULL;
    pGroup->wIndex = wIndex;
    pGroup->fCommon = bCommonGroup;
    pGroup->ftLastWriteTime.dwLowDateTime = 0;
    pGroup->ftLastWriteTime.dwHighDateTime = 0;

    pGroup->lpKey = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpKey) + 1));
    pGroup->fLoaded = FALSE;

    if (!pGroup->lpKey) {
GoAway:
        GlobalFree(pGroup->hGroup);
        LocalFree((HANDLE)pGroup);
        if (!fLowMemErrYet) {
            MyMessageBox(hwndProgman, IDS_APPTITLE, IDS_LOWMEMONINIT,
                    lpKey, MB_OK|MB_ICONEXCLAMATION);
            fLowMemErrYet = TRUE;
        }
        return NULL;
    }

    lstrcpy(pGroup->lpKey, lpKey);

    mdics.szTitle = TEXT("");
    mdics.hOwner = hAppInstance;
    mdics.szClass = szGroupClass;
    mdics.style = WS_VSCROLL|WS_HSCROLL;
    mdics.x = mdics.y = mdics.cx = mdics.cy = CW_USEDEFAULT;
    mdics.lParam = (LPARAM)pGroup;

    /*
     * REVIEW HACK - Set the auto arranging flag to stop the group being
     * loaded by ArrangingIcons doing a LockGroup  and then producing
     * an error if something goes wrong. We're going to do a lock
     * later on anyway and we don't want two error messages.
     */
    bAutoArranging = TRUE;
    pGroup->hwnd = (HWND)SendMessage(hwndMDIClient, WM_MDICREATE, 0, (LPARAM)(LPTSTR)&mdics);
    bAutoArranging = FALSE;

    if (!pGroup->hwnd) {
        LocalFree((HANDLE)pGroup->lpKey);
        goto GoAway;
    }

    /*
     * Note that we're about to load a group for the first time.
     * NB Stting this tells LockGroup that the caller can handle the errors.
     */
    fFirstLoad = TRUE;
    lpgd = LockGroup(pGroup->hwnd);
    /*
     * The group has been loaded or at least we tried.
     */
    fFirstLoad = FALSE;
    if (!lpgd) {
LoadFail:
        /* Loading the group failed somehow... */
        SendMessage(hwndMDIClient, WM_MDIDESTROY, (WPARAM)pGroup->hwnd, 0L);
        //
        // stop handling of Program Groups key changes.
        //
        bHandleProgramGroupsEvent = FALSE;
        RegDeleteKey(hkeyProgramGroups, pGroup->lpKey);

        //
        // reset handling of Program Groups key changes.
        //
        ResetProgramGroupsEvent(bCommonGroup);
        bHandleProgramGroupsEvent = TRUE;

        LocalFree((HANDLE)pGroup->lpKey);
        GlobalFree(pGroup->hGroup);
        LocalFree((HANDLE)pGroup);
        return NULL;
    }

    /*
     * test if it is a Windows 3.1 group file format. If so it is not
     * valid in WIN32. In Windows 3.1 RECT and POINT are WORD instead of LONG.
     */

    if ( (lpgd->rcNormal.left != (INT)(SHORT)lpgd->rcNormal.left) ||
         (lpgd->rcNormal.right != (INT)(SHORT)lpgd->rcNormal.right) ||
         (lpgd->rcNormal.top != (INT)(SHORT)lpgd->rcNormal.top) ||
         (lpgd->rcNormal.bottom != (INT)(SHORT)lpgd->rcNormal.bottom) ){
        /* The group is invalid. */
        MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_BADFILE,
                                (LPTSTR) PTR(lpgd, lpgd->pName),
                                MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
        UnlockGroup(pGroup->hwnd);
        goto LoadFail;
    }

    if (!ValidItems(lpgd)) {
        MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_BADFILE,
                                (LPTSTR) PTR(lpgd, lpgd->pName),
                                MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
        UnlockGroup(pGroup->hwnd);
        goto LoadFail;
    }


    if (lpgd->nCmdShow) {
        SetInternalWindowPos(pGroup->hwnd, (UINT)lpgd->nCmdShow, &lpgd->rcNormal,
                &lpgd->ptMin);
    }

    if (pGroup->fCommon) {

        //
        // Add the common group suffix to the name of the group e.g. (Common)
        // Only do this if the group window is not minimized.
        //

        wp.length = sizeof(WINDOWPLACEMENT);
        GetWindowPlacement(pGroup->hwnd, &wp);
        if ((wp.showCmd == SW_MINIMIZE) ||
            (wp.showCmd == SW_SHOWMINIMIZED) ||
            (wp.showCmd == SW_SHOWMINNOACTIVE) ) {
            SetWindowText(pGroup->hwnd, (LPTSTR) PTR(lpgd, lpgd->pName));
        }
        else {
            lstrcpy(szCommonGroupTitle, (LPTSTR) PTR(lpgd, lpgd->pName));
            if (LoadString(hAppInstance, IDS_COMMONGRPSUFFIX, szCommonGroupSuffix,
                           CharSizeOf(szCommonGroupSuffix))) {
                lstrcat(szCommonGroupTitle, szCommonGroupSuffix);
            }
            SetWindowText(pGroup->hwnd, szCommonGroupTitle);
            if (!UserIsAdmin) {
                pGroup->fRO = TRUE;
            }
        }
    }
    else {
        SetWindowText(pGroup->hwnd, (LPTSTR) PTR(lpgd, lpgd->pName));
    }


    UnlockGroup(pGroup->hwnd);

    //CheckIconResolution(pGroup->hwnd);

    CreateItemIcons(pGroup->hwnd);

    /*
     * Link the group.
     */
    pGroup->pNext = NULL;
    *pLastGroup = pGroup;
    pLastGroup = &pGroup->pNext;
    pCurrentGroup = pGroup;

#ifdef NOTINUSER
    CalcChildScroll(pGroup->hwnd, SB_BOTH);
#endif

    GroupCheck(pGroup);

    return(pGroup->hwnd);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  UnloadGroupWindow() -                                                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void FAR PASCAL UnloadGroupWindow(HWND hwnd)
{
    PGROUP pGroup, *ppGroup;
    PITEM pItem, pItemNext;

    pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);

    /* Destroy the window. */
    SendMessage(hwndMDIClient,WM_MDIDESTROY,(WPARAM)hwnd,0L);

    /* Free the group segment. */
    GlobalFree(pGroup->hGroup);

    /* Free the local stuff. */
    LocalFree((HANDLE)pGroup->lpKey);

    /* The cached bitmap if there is one. */
    if (pGroup->hbm) {
        DeleteObject(pGroup->hbm);
        pGroup->hbm = NULL;
    }

    /* The item data. */
    for (pItem = pGroup->pItems; pItem; pItem = pItemNext) {
        pItemNext = pItem->pNext;
        LocalFree((HANDLE) pItem);
    }

    /* Remove the group from the linked list. */
    for (ppGroup = &pFirstGroup; *ppGroup; ppGroup = &((*ppGroup)->pNext)) {
        if (*ppGroup == pGroup) {
            *ppGroup = pGroup->pNext;
            break;
        }
    }
    if (pLastGroup == &pGroup->pNext)
	pLastGroup = ppGroup;

    /* Lastly, free the group structure itself. */
    LocalFree((HANDLE)pGroup);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RemoveBackslashFromKeyName() -                                          */
/*                                                                          */
/*  replace the invalid characters for a key name by some valid charater.   */
/*  the same characters that are invalid for a file name are invalid for a  */
/*  key name.                                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void RemoveBackslashFromKeyName(LPTSTR lpKeyName)
{
    LPTSTR lpt;

    for (lpt = lpKeyName; *lpt; lpt++) {
        if ((*lpt == TEXT('\\')) || (*lpt == TEXT(':')) || (*lpt == TEXT('>')) || (*lpt == TEXT('<')) ||
             (*lpt == TEXT('*')) || (*lpt == TEXT('?')) ){
            *lpt = TEXT('.');
        }
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateNewGroup() -                                                      */
/*                                                                          */
/*  This function creates a new, empty group.                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HWND PASCAL CreateNewGroup(LPTSTR pGroupName, BOOL bCommonGroup)
{
    HANDLE      hT;
    LPGROUPDEF  lpgd;
    PGROUP      pGroup;
    HDC         hdc;
    int         i;
    int         cb;
    TCHAR       szKeyName[MAXKEYLEN+1];
    HWND        hwnd;
    DWORD       status = 0;
    WORD        cGroups;
    INT         wGroupNameLen;   //length of pGroupName DWORD aligned.
    HKEY        hkeyGroups;
    HKEY        hKey;
    HWND        hwndT;
    PSECURITY_ATTRIBUTES pSecAttr;

    /*
     * Check we're not trying to create too many groups.
     * Count the current number of groups.
     */
    cGroups = 0;

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {
        if (GetWindow(hwnd, GW_OWNER))
            continue;
        //
        // count the common groups seperately from the personal group.
        // Both have a maximum of CGROUPSMAX groups.
        //
        pGroup = (PGROUP)GetWindowLongPtr(hwnd, GWLP_PGROUP);
        if (bCommonGroup && pGroup->fCommon ||
                             !bCommonGroup && !pGroup->fCommon) {
            cGroups++;
        }
    }

    // Compare with limit.
    if (cGroups >= CGROUPSMAX) {
        status = bCommonGroup ? IDS_TOOMANYCOMMONGROUPS : IDS_TOOMANYGROUPS;
        goto Exit;
    }

    if (bCommonGroup) {

        hkeyGroups = hkeyCommonGroups;
        pSecAttr = pAdminSecAttr;
        if (!hkeyGroups) {
            if (MyMessageBox(hwndProgman,
                             IDS_COMMONGROUPERR,
                             IDS_NOCOMMONGRPS,
                             pGroupName,
                             MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)
                       == IDOK) {

                hkeyGroups = hkeyProgramGroups;
                pSecAttr = pSecurityAttributes;
                bCommonGroup = FALSE;

            } else {
                return(NULL);
            }
        }

    } else {

        hkeyGroups = hkeyProgramGroups;
        pSecAttr = pSecurityAttributes;

    }

    if (!hkeyGroups) {
        status = IDS_NOGRPFILE;
        goto Exit;
    }

    //
    // Replace backslash in the group name because the registry does not
    // allow key names with backslash, bckslash is used to separate keys.
    //
    lstrcpy(szKeyName, pGroupName);
    RemoveBackslashFromKeyName(szKeyName);

    //
    // Test for existing key.
    //
    while (!RegOpenKeyEx(hkeyGroups, szKeyName, 0, KEY_READ, &hKey)) {
        /* a group with this name already exists */
        if (hwndT = IsGroupAlreadyLoaded(szKeyName, bCommonGroup)) {
            if (lstrlen(szKeyName) < MAXKEYLEN) {
                lstrcat(szKeyName, TEXT("."));
                GlobalUnlock(pGroup->hGroup);
                RegCloseKey(hKey);
                continue;
            }
        }
        RegCloseKey(hKey);
        goto LoadGroupFile;
    }

    wGroupNameLen = MyDwordAlign(sizeof(TCHAR)*(lstrlen(pGroupName) + 1));
    cb = sizeof(GROUPDEF) + (NSLOTS * sizeof(DWORD)) +  wGroupNameLen;

    /*
     * In CreateNewGroup before GlobalAlloc.
     */
    hT = GlobalAlloc(GHND, (DWORD)cb);
    if (!hT) {
        status = IDS_LOWMEM;
        goto Exit;
    }

    lpgd = (LPGROUPDEF)GlobalLock(hT);

    lpgd->dwMagic = GROUP_UNICODE;
    lpgd->cbGroup = (DWORD)cb;
    lpgd->nCmdShow = 0;            /* use MDI defaults  */
    lpgd->pName = sizeof(GROUPDEF) + NSLOTS * sizeof(DWORD);
    hdc = GetDC(NULL);
    lpgd->wIconFormat = (WORD)GetDeviceCaps(hdc, BITSPIXEL) + (WORD)256 *
            (WORD)GetDeviceCaps(hdc, PLANES);
    ReleaseDC(NULL, hdc);
    lpgd->cxIcon = (WORD)GetSystemMetrics(SM_CXICON);
    lpgd->cyIcon = (WORD)GetSystemMetrics(SM_CYICON);
    lpgd->Reserved1 = (WORD)-1;
    lpgd->Reserved2 = (DWORD)-1;

    lpgd->cItems = NSLOTS;

    for (i = 0; i < NSLOTS; i++) {
        lpgd->rgiItems[i] = 0;
    }

    lstrcpy((LPTSTR)((LPSTR)lpgd + sizeof(GROUPDEF) + NSLOTS * sizeof(DWORD)),
            pGroupName);

    /*
     * In CreateNewGroup before SizeofGroup.
     */
    cb = (int)SizeofGroup(lpgd);


    //
    // stop handling of Program Groups key changes when creating groups.
    //
    bHandleProgramGroupsEvent = FALSE;

    //
    // REARCHITECT: pSecurityAttributes might change for Common groups.
    //

    if (!RegCreateKeyEx(hkeyGroups, szKeyName, 0, 0, 0,
                     DELETE | KEY_READ | KEY_WRITE,
                     pSecAttr, &hKey, NULL)) {
        if (RegSetValueEx(hKey, NULL, 0, REG_BINARY, (LPBYTE)lpgd, cb))
            status = IDS_CANTWRITEGRP;
        RegCloseKey(hKey);
    }
    else
        status = IDS_NOGRPFILE;

    GlobalUnlock(hT);
    GlobalFree(hT);

Exit:
    if (status) {
        MyMessageBox(hwndProgman, IDS_GROUPFILEERR, (WORD)status, pGroupName,
                MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
        ResetProgramGroupsEvent(bCommonGroup);
	bHandleProgramGroupsEvent = TRUE;
        return NULL;
    }

LoadGroupFile:
    /*
     * The group file now exists on the disk... load it in!
     */
    fLowMemErrYet = FALSE;
    fErrorOnExtract = FALSE;
    hwnd = LoadGroupWindow(szKeyName, 0, bCommonGroup);

    if (fErrorOnExtract) {
        // On observed problem with icon extraction has been to do
        // with a low memory.
        MyMessageBox(hwndProgman, IDS_OOMEXITTITLE, IDS_LOWMEMONEXTRACT,
            NULL, MB_OK|MB_ICONHAND|MB_SYSTEMMODAL);
    }

    // Save the group section even if SaveSettings is off to stop
    // users from themselves.
    if (!bCommonGroup) {
        WriteGroupsSection();
    }
    ResetProgramGroupsEvent(bCommonGroup);
    bHandleProgramGroupsEvent = TRUE;
    return hwnd;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DeleteGroup() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID FAR PASCAL DeleteGroup(HWND hwndGroup)
{
  PGROUP pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);
  PGROUP *ppGroup;
  PITEM  pItem;
  TCHAR   szT[10];
  BOOL   bCommonGroup;
  HKEY   hkeyGroups;

  //
  // stop handling of Program Groups key changes when deleting groups.
  //
  bHandleProgramGroupsEvent = FALSE;

  bCommonGroup = pGroup->fCommon;
  if (bCommonGroup)
      hkeyGroups = hkeyCommonGroups;
  else
      hkeyGroups = hkeyProgramGroups;

  if (pGroup->fRO || RegDeleteKey(hkeyGroups, pGroup->lpKey) != ERROR_SUCCESS) {
      MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_ERRORDELETEGROUP,
                                                      pGroup->lpKey, MB_OK);
      //
      // reset handling of Program Groups key changes.
      //
      ResetProgramGroupsEvent(bCommonGroup);
      bHandleProgramGroupsEvent = TRUE;
      return;   // cannot delete the group
  }

  //
  // reset handling of Program Groups key changes.
  //
  ResetProgramGroupsEvent(bCommonGroup);
  bHandleProgramGroupsEvent = TRUE;

  /* Destroy the window, the global memory block, and the file. */
  SendMessage(hwndMDIClient, WM_MDIDESTROY, (WPARAM)hwndGroup, 0L);
  NukeIconBitmap(pGroup);
  GlobalFree(pGroup->hGroup);

  if (!bCommonGroup) {

      //
      // Remove the program manager's settings for that personal group.
      //

      wsprintf(szT,TEXT("Group%d"),pGroup->wIndex);
      RegDeleteValue(hkeyPMGroups, szT);
  }

  /* Unlink the group structure. */
  for (ppGroup=&pFirstGroup; *ppGroup && *ppGroup != pGroup; ppGroup = &(*ppGroup)->pNext)
      ;

  if (*ppGroup)
      *ppGroup = pGroup->pNext;

  if (pLastGroup == &pGroup->pNext)
      pLastGroup = ppGroup;

  /* Destroying the window should activate another one, but if it is the
   * last one, nothing will get activated, so to make sure punt the
   * current group pointer...
   */
  if (pCurrentGroup == pGroup)
      pCurrentGroup = NULL;

  /* Lastly, toss out the group and item structures. */
  while (pGroup->pItems) {
      pItem = pGroup->pItems;
      pGroup->pItems = pItem->pNext;
      LocalFree((HANDLE)pItem);
  }
  LocalFree((HANDLE)pGroup->lpKey);
  LocalFree((HANDLE)pGroup);

  if (!bCommonGroup) {

      //
      // Change the program manager's settings for that personal group.
      //

      WriteGroupsSection();
  }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ChangeGroupTitle() -                                                    */
/*                                                                          */
/*  Modifies the name of a program group, on the screen and in the file.    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID FAR PASCAL ChangeGroupTitle(HWND hwndGroup, LPTSTR lpName, BOOL bCommonGroup)
{
  LPGROUPDEF lpgd;
  PGROUP pGroup;
  DWORD pName;
  TCHAR szCommonGroupSuffix[MAXKEYLEN];
  TCHAR szCommonGroupTitle[2*MAXKEYLEN];
  WINDOWPLACEMENT wp;

  if (!hwndGroup)
      return;

  //
  // Change the title of the window.
  //

  if (bCommonGroup) {

      //
      // Add the common group suffix to the name of the group e.g. (Common),
      // do not append the common suffix if the group window is minimized.
      //
      wp.length = sizeof(WINDOWPLACEMENT);
      GetWindowPlacement(hwndGroup, &wp);
      if (wp.showCmd == SW_MINIMIZE || wp.showCmd == SW_SHOWMINIMIZED ||
          wp.showCmd == SW_SHOWMINNOACTIVE) {
          SetWindowText(hwndGroup, lpName);
      }
      else {

          lstrcpy(szCommonGroupTitle, lpName);
          if (LoadString(hAppInstance, IDS_COMMONGRPSUFFIX, szCommonGroupSuffix,
                         CharSizeOf(szCommonGroupSuffix))) {
              lstrcat(szCommonGroupTitle, szCommonGroupSuffix);
          }
          SetWindowText(hwndGroup, szCommonGroupTitle);
      }
  }
  else {
      SetWindowText(hwndGroup, lpName);
  }

  //
  // Remove the old name.
  //

  lpgd = LockGroup(hwndGroup);
  if (!lpgd)
      return;

  DeleteThing(lpgd, (LPDWORD)&lpgd->pName, 0);
  UnlockGroup(hwndGroup);

  //
  // Insert the new one.
  //

  pGroup = (PGROUP)GetWindowLongPtr(hwndGroup,GWLP_PGROUP);
  pName = AddThing(pGroup->hGroup, lpName ,(WORD)0);

  //
  // Set the new offset...
  //

  if (lpgd = LockGroup(hwndGroup)) {
      lpgd->pName = pName;
      UnlockGroup(hwndGroup);
  }

}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SetGroupDimensions() -                                                  */
/*                                                                          */
/*  Saves the size and position of the group file in the group segment, as  */
/*  as well as the positions of all the item icons                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL SetGroupDimensions(HWND hwndGroup)
{
  LPGROUPDEF        lpgd;
  LPITEMDEF        lpid;
  PGROUP pGroup;
  PITEM pItem;
  WORD i;

  lpgd = LockGroup(hwndGroup);
  if (!lpgd)
      return;

  lpgd->nCmdShow = (WORD)GetInternalWindowPos(hwndGroup, &lpgd->rcNormal,
            &lpgd->ptMin);

  pGroup = (PGROUP)GetWindowLongPtr(hwndGroup,GWLP_PGROUP);
  NukeIconBitmap(pGroup);	// invalidate the bitmap

  for (pItem=pGroup->pItems; pItem; pItem=pItem->pNext) {
      lpid = ITEM(lpgd,pItem->iItem);
      lpid->pt.x = pItem->rcIcon.left;
      lpid->pt.y = pItem->rcIcon.top;

      /* save offset of ITEMDEF for each item
       */
      ChangeTagID(lpgd,pItem->iItem,(int)lpgd->rgiItems[pItem->iItem]);
      pItem->iItem = (int)lpgd->rgiItems[pItem->iItem];
  }

  for (i=0, pItem=pGroup->pItems; pItem; pItem=pItem->pNext, i++) {
      /* write offsets back out in Z order and update the index
       */
      ChangeTagID(lpgd,pItem->iItem,(int)i);
      lpgd->rgiItems[i] = (DWORD)pItem->iItem;
      pItem->iItem = (int)i;
  }

  /* Clear out remaining pointers to prevent duped item wierdness. */
  while (i < lpgd->cItems)
      lpgd->rgiItems[i++] = 0;

  UnlockGroup(hwndGroup);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WriteGroupsSection() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void PASCAL WriteGroupsSection(VOID)
{
    PGROUP      pGroup;
    HCURSOR     hCursor;
    HWND        hwndGroup;
    LPGROUPDEF  lpgd;
    TCHAR        szT[66];
    TCHAR        szOrd[CGROUPSMAX*8+7];
    TCHAR szFmt[] = TEXT("Group%d");
    TCHAR szFmtCommonGrp[] = TEXT("GroupC%d");
    INT cGroups;
    TCHAR szGroupKey[MAXKEYLEN];
    INT i;
    RECT rc;
    POINT ptMin;
    TCHAR szCGrpInfo[MAXKEYLEN];
    INT cbValueName;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    if (!(hwndGroup = GetWindow(hwndMDIClient, GW_CHILD))) {
        goto WPIExit;
    }

    hwndGroup = GetWindow(hwndGroup, GW_HWNDLAST);

    szOrd[0] = 0;
    cGroups = 0;

    //
    // Clear user's previous positioning of common groups.
    //
    if (hkeyPMCommonGroups) {
        cbValueName = CharSizeOf(szGroupKey);
        while (!RegEnumValue(hkeyPMCommonGroups, 0, szGroupKey, &cbValueName, 0, 0,
                             0, 0)) {
            RegDeleteValue(hkeyPMCommonGroups, szGroupKey);
            cbValueName = CharSizeOf(szGroupKey);
        }
    }

    for (; hwndGroup; hwndGroup = GetWindow(hwndGroup, GW_HWNDPREV)) {
        /*
         * Check to make sure we're not out of room for the order string.
         */
        if (cGroups > CGROUPSMAX) {
            MessageBeep(0);
            break;
        }

        if (GetWindow(hwndGroup, GW_OWNER)) {
            continue;
        }

        pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);

        if (!pGroup->lpKey || !*pGroup->lpKey) {
            if (pGroup->lpKey) {
                LocalFree((HANDLE)pGroup->lpKey);
            }

            lpgd = LockGroup(hwndGroup);
            if (!lpgd) {
                continue;
            }

            lstrcpy(szGroupKey, (LPTSTR) PTR(lpgd, lpgd->pName));
            pGroup->lpKey = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szGroupKey) + 1));
            lstrcpy(pGroup->lpKey, szGroupKey);
            UnlockGroup(hwndGroup);
        }

        if (pGroup->fCommon) {
            wsprintf(szT, szFmtCommonGrp, pGroup->wIndex);
            lstrcat(szOrd, TEXT(" C"));
            lstrcat(szOrd, szT + CCHCOMMONGROUP);
            if (hkeyPMCommonGroups) {
                i = GetInternalWindowPos(hwndGroup, &rc, &ptMin);

                if (i==SW_SHOWMINNOACTIVE)
                    i = SW_SHOWNORMAL;

                wsprintf(szCGrpInfo, TEXT("%d %d %d %d %d %d %d "),
                          rc.left, rc.top, rc.right, rc.bottom,
                          ptMin.x, ptMin.y, i);
                lstrcat(szCGrpInfo, pGroup->lpKey);
                RegSetValueEx(hkeyPMCommonGroups, szT, 0, REG_SZ, (LPBYTE)szCGrpInfo, sizeof(TCHAR)*(lstrlen(szCGrpInfo)+1));
            }
        }
        else {
            wsprintf(szT, szFmt, pGroup->wIndex);
            lstrcat(szOrd, TEXT(" "));
            lstrcat(szOrd, szT + CCHGROUP);
            if (hkeyPMGroups) {
                RegSetValueEx(hkeyPMGroups, szT, 0, REG_SZ, (LPBYTE)pGroup->lpKey, sizeof(TCHAR)*(lstrlen(pGroup->lpKey)+1));
            }
        }

        cGroups++;
    }

    if (hkeyPMSettings) {
        RegSetValueEx(hkeyPMSettings, szOrder, 0, REG_SZ, (LPBYTE)szOrd, sizeof(TCHAR)*(lstrlen(szOrd) + 1));
    }

WPIExit:
    ShowCursor(FALSE);
    SetCursor(hCursor);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SaveGroupsContent() -
/*
/*  Save the contents of the all the groups, doesn't save changes in
/*  size or position if bSaveGroupSettings is FALSE, only the group items.
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL SaveGroupsContent(BOOL bSaveGroupSettings)
{
    HWND hwndGroup;

    hwndGroup = GetWindow(hwndMDIClient, GW_CHILD);
    if (!hwndGroup)
        return FALSE;

    for (hwndGroup=GetWindow(hwndGroup, GW_HWNDLAST); hwndGroup; hwndGroup=GetWindow(hwndGroup, GW_HWNDPREV)) {
        if (GetWindow(hwndGroup, GW_OWNER))
            continue;

        /* Save the latest sizes and positions. */
        if (bSaveGroupSettings) {
            SetGroupDimensions(hwndGroup);
            if (wLockError == LOCK_LOWMEM && !fLowMemErrYet) {
                // No more error messages.
                fLowMemErrYet = TRUE;
                wLockError = 0;
                // Warn user that some settings couldn't be saved.
                MyMessageBox(hwndProgman, IDS_OOMEXITTITLE, IDS_LOWMEMONEXIT, NULL,
                     MB_OK | MB_ICONHAND | MB_SYSTEMMODAL);
            }
        }

        SaveGroup(hwndGroup, TRUE);
    }

    RegFlushKey(HKEY_CURRENT_USER);

    return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WriteINIFile() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void FAR PASCAL WriteINIFile()
{
    register int  i;
    RECT          rc;
    TCHAR          szT[40];
    HANDLE        hCursor;

    //
    // Don't save if restricted. But force save if we've just converted the
    // ansi groups to unicode so we can work from unicode the next time around.
    //
    if (fNoSave && !bUseANSIGroups)
        return;

    fLowMemErrYet = FALSE;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    i = GetInternalWindowPos(hwndProgman, &rc, NULL);

    if (i==SW_SHOWMINNOACTIVE)
        i = SW_SHOWNORMAL;

    wsprintf(szT, TEXT("%d %d %d %d %d"), rc.left, rc.top, rc.right, rc.bottom, i);
    if (hkeyPMSettings) {
        RegSetValueEx(hkeyPMSettings, szWindow, 0, REG_SZ, (LPBYTE)szT, sizeof(TCHAR)*(lstrlen(szT)+ 1));
    }

    if (!bLoadEvil)
        WriteGroupsSection();
    //
    // Save all groups content, TRUE means we want the size and position saved
    // as well.
    //
    SaveGroupsContent(TRUE);

    ShowCursor(FALSE);
    SetCursor(hCursor);
}




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetItemCommand() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void FAR PASCAL GetItemCommand(
    PGROUP pGroup,
    PITEM pItem,
    LPTSTR lpCommand,
    LPTSTR lpDir)
{
    BYTE b=0;
    LPTSTR lp1, lp2, lp3;
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    BOOL bNoFirstQuote = TRUE;

    if (!GetGroupTag(pGroup,pItem,(WORD)ID_APPLICATIONDIR,lpCommand,MAXITEMPATHLEN)) {
        // the application directory is not defined
        *lpCommand = 0;
    }

    lpgd = LockGroup(pGroup->hwnd);
    if (!lpgd) {
        *lpCommand = 0;
        *lpDir = 0;
        return;
    }
    lpid = ITEM(lpgd,pItem->iItem);

    // init working directory
    lp3 = lpDir;
    *lp3 = 0;

    // item command
    lp1 = (LPTSTR) PTR(lpgd, lpid->pCommand);
    if (*lp1 == TEXT('"')) {
        lp2 = lp1;
        while (lp2 && (lp2 = wcschr(lp2+1, TEXT('"'))) && *(lp2+1) != TEXT('\\')) { //go to next quote
             ;
        }
        if (!lp2) {
            //
            // The directory is not in quotes and since the command path starts
            // with a quote, there's no working directory.
            //
            lp2 = lpDir;
	    *lp2 = 0;
        }
        else {
            if (*(lp2+1) == TEXT('\\')) {
                //
                // the working directory is in quotes
                //
                *lp3++ = *lp1++; //write first quote

                for (; *lp1 && lp1 != lp2; lp1 = CharNext(lp1)) {
                    *lp3++ = *lp1;
                }
                if (*lp1 == TEXT('"')) {
                   *lp3++ = *lp1++; //write last quote
                   lp1++;
                   *lp3 = 0;
                }
            }
            lp2 = lp3 + lstrlen(lp3);
	}
    }
    else {
        //
        // if there's a working directory, it is not in quotes
        //

        for (lp2 = lp3 = lpDir; *lp1 && *lp1 != TEXT(' ') && *lp1 != TEXT('"'); // the command line might be in quotes
                                               lp1 = CharNext(lp1)) {

            *lp3++ = *lp1;

            if (*lp1 == TEXT(':') || *lp1 == TEXT('\\'))
                lp2 = lp3;
        }
        *lp3 = 0;
    }

    /* we are assuming the exe dir contains the necessary separator
     * add the filename to the command line
     */
    lstrcat(lpCommand,lp2);
    /* add the arguments to the command line
     */
    lstrcat(lpCommand,lp1);


    /* truncate the command name from the exe path.  note this implies
     * that if there is no path, lpDir will be empty
     */
    *lp2 = 0;
    lp2 = CharPrev(lpDir,lp2);
    if (*lp2 == TEXT('\\') && *CharPrev(lpDir,lp2) != TEXT(':'))
        *lp2 = 0;

    UnlockGroup(pGroup->hwnd);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DuplicateItem() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

PITEM PASCAL DuplicateItem(
    PGROUP pGroup,
    PITEM pItem,
    PGROUP pGNew,
    LPPOINT lppt)
{
    WORD       wIconId;
    WORD       wIconIndex;
    LPITEMDEF  lpid;
    LPGROUPDEF lpgd;
    TCHAR       szCommand[MAXITEMPATHLEN + 1];
    TCHAR       szDefDir[2 * (MAXITEMPATHLEN + 1)];
    TCHAR       szIconPath[MAXITEMPATHLEN + 1];
    TCHAR       szName[64];
    TCHAR       szExpPath[MAXITEMPATHLEN+1];
    TCHAR       szExpDir[MAXITEMPATHLEN+1];
    DWORD       dwFlags = CI_ACTIVATE;

    lpid = LockItem(pGroup, pItem);
    if (lpid == 0L) {
        UnlockGroup(pGroup->hwnd);
        return NULL;
    }

    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

    lstrcpy(szName, (LPTSTR) PTR(lpgd, lpid->pName));
    lstrcpy(szIconPath, (LPTSTR) PTR(lpgd, lpid->pIconPath));
    wIconId = lpid->iIcon;
    wIconIndex = lpid->wIconIndex;
    GlobalUnlock(pGroup->hGroup);
    UnlockGroup(pGroup->hwnd);

    GetItemCommand(pGroup, pItem, szCommand, szDefDir);

    //
    // I f there's no icon path, check if we have an executable associated
    // with the command path.
    //
    if (!*szIconPath) {
        lstrcpy(szExpPath, szCommand);
        DoEnvironmentSubst(szExpPath, CharSizeOf(szExpPath));
        StripArgs(szExpPath);
        lstrcpy(szExpDir, szDefDir);
        DoEnvironmentSubst(szExpDir, CharSizeOf(szExpDir));
        FindExecutable(szExpPath, szExpDir, szIconPath);
        if (!*szIconPath) {
            dwFlags |= CI_NO_ASSOCIATION;
        }
        else
            *szIconPath = 0;
    }
    if (GroupFlag(pGroup, pItem, (WORD)ID_NEWVDM)) {
        dwFlags |= CI_SEPARATE_VDM;
    }

    return CreateNewItem(pGNew->hwnd,
                         szName,
                         szCommand,
                         szIconPath,
                         szDefDir,
                         GroupFlag(pGroup, pItem, (WORD)ID_HOTKEY),
                         GroupFlag(pGroup, pItem, (WORD)ID_MINIMIZE),
                         wIconId,
                         wIconIndex,
                         NULL,
                         lppt,
                         dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmdlgs.c ===
/*
 * pmdlgs.c - program manager dialog procedures
 *
 *  Copyright (c) 1991,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *                This file is for support of program manager under NT Windows.
 *                This file is/was ported from pmdlgs.c (program manager).
 *
 *  MODIFICATION HISTORY
 *      Initial Version: x/x/90        Author Unknown, since he didn't feel
 *                                                                like lettings us know...
 *
 *      NT 32b Version:        2/1/91        Jeff Pack
 *                                                                Intitial port to begin.
 *
 *
 */

#include "progman.h"
#include "commdlg.h"
#include "io.h"
#include "stdio.h"
#include <vdmapi.h>

#define CBCUSTFILTER 40         // Max size of custom filter.

BOOL fFirstPass;                // For IconDlgProc so we can fill the list
                                // with stuff from progman if the first
                                // file given has no icons.
BOOL fNewIcon;                  // Flags if the icon has been explicitely
                                // set.

extern BOOL bHandleProgramGroupsEvent;

TCHAR szDotPIF[] = TEXT(".pif");
TCHAR szCommdlg[] = TEXT("comdlg32.dll");       // The name of the common dialog.
typedef BOOL (APIENTRY *OPENFILENAME_PROC)(LPOPENFILENAME);      // Commdlgs GetOpenFileName routine.
OPENFILENAME_PROC lpfnGOFN;

#define szGetOpenFileName "GetOpenFileNameW"

/* from pmgseg.c */
DWORD PASCAL SizeofGroup(LPGROUPDEF lpgd);
void RemoveBackslashFromKeyName(LPTSTR lpKeyName);

VOID CentreWindow(HWND hwnd);
VOID FreeIconList(HANDLE hIconList, int iKeepIcon);

#define CHECK_BINARY_EVENT_NAME TEXT("CheckBinaryEvent")
#define CHECK_BINARY_ID           1
BOOL    bCheckBinaryType;
HANDLE  hCheckBinaryEvent;
UINT    uiCheckBinaryTimeout;
BOOL    bCheckBinaryDirtyFlag;
void    CheckBinaryThread (LPVOID);
extern TCHAR szCheckBinaryType[];
extern TCHAR szCheckBinaryTimeout[];


//#ifdef JAPAN
//BOOL CheckPortName(HWND,LPTSTR );
//BOOL PortName(LPTSTR );
//#endif

BOOL APIENTRY InQuotes(LPTSTR sz)
{
    if (*sz == TEXT('"') && *(sz + lstrlen(sz) - 1) == TEXT('"')) {
        return(TRUE);
    }
    return(FALSE);
}

//-------------------------------------------------------------------------
// Removes leading and trailing spaces.
VOID APIENTRY RemoveLeadingSpaces(LPTSTR sz)
{
    TCHAR *pChr2;
    LPTSTR lpTmp;

    while(*sz == TEXT(' ')) {
        // First Char is a space.
        // Move them all down one.
        for (pChr2 = sz; *pChr2; pChr2++) {
            *pChr2 = *(pChr2+1);
        }
    }
    if (!*sz) {
        return;
    }
    lpTmp = sz + lstrlen(sz) - 1;
    while (*lpTmp && *lpTmp == TEXT(' ')) {
        *lpTmp-- = TEXT('\0');
    }
}

/*** GroupFull  -  Check for full group. Returns FALSE if the group isn't full.
 *
 *
 * BOOL PASCAL GroupFull(PGROUP pGroup)
 *
 * ENTRY -    PGROUP pGroup
 *
 * EXIT  -    BOOL  - returns TRUE if group is full
 *
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 *  08-08-91  JohanneC  - ported from Windows 3.1
 *
 */
BOOL PASCAL GroupFull(PGROUP pGroup)
{
    WORD i=0;
    PITEM pItem;
    BOOL ret;

    // Count the items in the group.
    for (pItem = pGroup->pItems;pItem;pItem = pItem->pNext)
        i++;

    if (i >= CITEMSMAX) {
        MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_TOOMANYITEMS, NULL,
          MB_OK | MB_ICONEXCLAMATION|MB_SYSTEMMODAL);
        ret = TRUE;
    }
    else
        ret = FALSE;

    return ret;
}


/*** ValidPathDrive
 *
 *
 * BOOL APIENTRY ValidPathDrive(LPTSTR lpPath)
 *
 * ENTRY -    LPTSTR lpPath  - pointer to path
 *
 * EXIT  -    BOOL  - returns TRUE if drive path is valid
 *
 * SYNOPSIS - Check the drive letter of the given path (if it has one).
 *
 * WARNINGS -
 * EFFECTS  -
 *
 *  08-08-91  JohanneC  - ported from Windows 3.1
 *
 */
BOOL APIENTRY PASCAL ValidPathDrive(LPTSTR lpPath)
{
    int nValid;
    TCHAR szDriveRoot[4] = TEXT("?:\\");

    // Store first letter of path.
    *szDriveRoot = *lpPath;
    lpPath = CharNext(lpPath);
    if (*lpPath == TEXT(':')) {
        //
        // It's got a drive letter. Test the drive type with the root directory.
        //
        nValid = GetDriveType(szDriveRoot);
        if ( nValid == 1 || nValid == 0) {
            return FALSE;
        }
        else {
            return TRUE;
        }
    }
    return TRUE;
}


/*** StripArgs        -- strip everything after a space
 *
 *
 * VOID APIENTRY StripArgs(LPTSTR szCmmdLine)
 *
 * ENTRY -  LPTSTR  szCmmdLine  -   Pointer to command line
 *          int     index
 *
 *
 * EXIT  -        VOID
 *
 * SYNOPSIS -  This searches for first space, and places NULL there, stripping
 *                                everything after that
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */
void NEAR PASCAL StripArgs(LPTSTR szCmmdLine)
{
    TCHAR *pch;

    //
    // first skip leading spaces
    //
    for (pch = szCmmdLine; *pch && *pch == TEXT(' '); pch = CharNext(pch))
         ;

    //
    // check if we have a quote, if so look for second quote.
    //
    if (*pch == TEXT('"')) {
        for (pch++; *pch; pch = CharNext(pch)) {
            if (*pch == TEXT('"')) {
                // Found it, limit string at this point.
                pch++;
                *pch = TEXT('\0');
                break;
            }
        }
    }
    else {
        // Search forward to find the first space in the cmmd line.
        for (; *pch; pch = CharNext(pch)) {
            if (*pch == TEXT(' ')) {
                // Found it, limit string at this point.
                *pch = TEXT('\0');
                break;
            }
        }
    }
}


/*** GetPathInfo       -- tokenizes string to path/name/extension components
 *
 *
 * VOID APIENTRY GetPathInfo(LPTSTR szPath, LPTSTR *pszLastSlash, LPTSTR *pszExt, DWORD *pich)
 *
 * ENTRY -  LPTSTR      szPath              -        pointer to path stuff
 *          LPTSTR      *pszLastSlash       -        last slash in path
 *          LPTSTR      *pszExt             -        pointer to extension
 *          WORD        *plich              -        index of last slash
 *
 *
 * EXIT  -  VOID
 *
 * SYNOPSIS -  This searches for first space, and places NULL there, stripping
 *                                everything after that
 *
 * WARNINGS -  BUG BUG , NOT LFN aware!
 * EFFECTS  -
 *
 */
void PASCAL GetPathInfo(LPTSTR szPath,
    LPTSTR *pszFileName,
    LPTSTR *pszExt,
    WORD *pich,
    BOOL *pfUnc)
{
    TCHAR *pch;          // Temp variable.
    WORD ich = 0;       // Temp.
    BOOL InQuotes;

    *pszExt = NULL;         // If no extension, return NULL.
    *pszFileName = szPath;  // If no seperate filename component, return path.
    *pich = 0;
    *pfUnc = FALSE;         // Default to not UNC style.

    //
    // Check if path is in quotes.
    //
    if (InQuotes = (*szPath == TEXT('"'))) {
       szPath++;
    }

    // Check for UNC style paths.
    if (*szPath == TEXT('\\') && *(szPath+1) == TEXT('\\'))
        *pfUnc = TRUE;

    // Search forward to find the last backslash or colon in the path.
    // While we're at it, look for the last dot.
    for (pch = szPath; *pch; pch = CharNext(pch)) {

        if ((*pch == TEXT(' ')) && (!InQuotes)) {
            // Found a space - stop here.
            break;
        }
        if (*pch == TEXT('"')) {
            // Found a the second quote - stop here.
            pch++;
            break;
        }
        if (*pch == TEXT('\\') || *pch == TEXT(':')) {
            // Found it, record ptr to it and it's index.
            *pszFileName = pch+1;
            *pich = ich + (WORD)1;
        }
        if (*pch == TEXT('.')) {
            // Found a dot.
            *pszExt = pch;
        }
        ich++;
    }

    /* Check that the last dot is part of the last filename. */
    if (*pszExt < *pszFileName)
        *pszExt = NULL;
}


/*** TagExtension
 *
 *
 * void APIENTRY TagExtension(PSTR pszPath, UINT cbPath)
 *
 * ENTRY -    PSTR pszPath  -
 *            UINT cbPath   - length of path in bytes
 *
 * EXIT  -
 *
 * SYNOPSIS -  Checks a string to see if it has an extension.
 *             If it doesn't then .exe will be appended.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 *  08-08-91  JohanneC  - ported from Windows 3.1
 *
 */
void FAR PASCAL TagExtension(LPTSTR szPath, UINT cbPath)
{
    DWORD dummy;
    LPTSTR szFileName;
    LPTSTR pszExt;
    LPTSTR pch;

    GetPathInfo(szPath, &szFileName, &pszExt, (WORD*) &dummy, (BOOL*) &dummy);
    if (!pszExt && (sizeof(TCHAR) * (lstrlen(szPath) + 5)) < cbPath) {
        // No extension, tag on a ".exe"
        // but first check if the path is in quotes
        pch = szPath + lstrlen(szPath);
        if (InQuotes(szPath)) {
            *pch = TEXT('\0');
            lstrcat(szPath, TEXT(".exe\""));
        }
        else {
            lstrcat(szPath, TEXT(".exe"));
        }
    }
}

// PIF stuff added 1/9/92

#define PTITLELEN      30
#define PPATHLEN       63
#define PATHMAX        64
#define COMMAX         64
#define PIFEDITMAXPIFL 1024L

typedef struct tagPIFFILE
  {
    TCHAR Reserved1[2];
    TCHAR PTITLE[PTITLELEN];
    WORD MAXMEMWORD;
    WORD MINMEMWORD;
    TCHAR PPATHNAME[PPATHLEN];
    TCHAR MSFLAGS;
    TCHAR Reserved2;
    TCHAR INITIALDIR[PATHMAX];
    TCHAR INITIALCOM[COMMAX];
    TCHAR SCREENTYPE;
    TCHAR SCREENPAGES;
    TCHAR INTVECLOW;
    TCHAR INTVECHIGH;
    TCHAR ROWS;
    TCHAR COLUMNS;
    TCHAR ROWOFFS;
    TCHAR COLOFFS;
    WORD SYSTEMMEM;
    TCHAR SHAREDPROG[64];
    TCHAR SHAREDDATA[64];
    TCHAR BEHAVBYTE;
    TCHAR SYSTEMFLAGS;
  } PIFFILE ;

void NEAR PASCAL GetTheString(LPTSTR pDst, LPTSTR pSrc, UINT iLen)
{
  TCHAR cTemp;

  /* Ensure there is NULL termination, and then copy the description
   */
  cTemp = pSrc[iLen];
  pSrc[iLen] = TEXT('\0');
  lstrcpy(pDst, pSrc);
  pSrc[iLen] = cTemp;

  /* Strip off trailing spaces
   */
  for (pSrc=NULL; *pDst; pDst=CharNext(pDst))
      if (*pDst != TEXT(' '))
	      pSrc = pDst;
  if (pSrc)
      *CharNext(pSrc) = TEXT('\0');
}

void NEAR PASCAL GetStuffFromPIF(LPTSTR szPath, LPTSTR szName, LPTSTR szDir)
{
  TCHAR szTemp[MAXITEMPATHLEN+1];
  DWORD dummy;
  LPTSTR pszExt;
  LPTSTR pszFileName;
  PIFFILE pfTemp;
  HANDLE fh;
  DWORD dwBytesRead ;


  /* Do nothing if the user has filled in these fields
   */
  if (*szName && *szDir)
      return;

  /* Check for the ".pif" extension
   */
  lstrcpy(szTemp, szPath);
  StripArgs(szTemp);
  GetPathInfo(szTemp, &pszFileName, &pszExt, (WORD*) &dummy,
                      (BOOL*) &dummy);
  if (!pszExt || lstrcmpi(pszExt, szDotPIF))
      return;

  /* There is no real way to verify the PIF format, like the COM format,
   * so we are assuming that the extension is our verification
   */
  fh = CreateFile(szTemp,
                GENERIC_READ,FILE_SHARE_READ, NULL,
                OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0)  ;

  if ( fh == INVALID_HANDLE_VALUE)
      return;

  ReadFile(fh,(LPTSTR)&pfTemp,sizeof(pfTemp),&dwBytesRead,NULL) ;
  if (dwBytesRead == sizeof(pfTemp)
	     && SetFilePointer(fh, 0L, NULL, FILE_END) < PIFEDITMAXPIFL) {
      if (!*szName) {
	      GetTheString(szName, pfTemp.PTITLE, CharSizeOf(pfTemp.PTITLE));
	      DoEnvironmentSubst(szName, CharSizeOf(szNameField));
	  }

      if (!*szDir) {
	      GetTheString(szDir, pfTemp.INITIALDIR, CharSizeOf(pfTemp.INITIALDIR));
	  }
  }
  CloseHandle(fh);
}



/*** GetDirectoryFromPath
 *
 *
 * VOID APIENTRY GetDirectoryFromPath (PSTR szFilePath, PSTR szDir)
 *
 * ENTRY -    PSTR szFilePath   -  Full path to a file.
 *            PSTR szDir        -  Directory returned in here, the buffer
 *                                 is assumed to be as big as szFilePath.
 *
 * EXIT  -
 *
 * SYNOPSIS - Given a full path, returns the directory of the file specified
 *            by the path.  If the path is UNC style or the path is just a
 *            filename then the directory returned will be a NULL.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 *  08-08-91  JohanneC  - ported from Windows 3.1
 *
 */
VOID FAR PASCAL GetDirectoryFromPath(LPTSTR szFilePath, LPTSTR szDir)
{
    LPTSTR pFileName;
    LPTSTR pExt;
    WORD ich;
    BOOL fUnc;

    *szDir = TEXT('\0');

    /* Get info about file path. */
    GetPathInfo(szFilePath, &pFileName, &pExt, &ich, &fUnc);

    /* UNC paths don't (conceptually to Progman) have a directory component. */
    if (fUnc)
        return;

    /* Does it have a directory component ? */
    if (pFileName != szFilePath) { // Yep.
        /* copy path to temp. */
        if (*szFilePath == TEXT('"')) {
            szFilePath++;
        }
        lstrcpy(szDir, szFilePath);
        /* check path style. */

        if (ich <= 3 && *(szDir+1) == TEXT(':')){

            /*
             * The path is "c:\foo.c" or "c:foo.c" style.
             * Don't remove the last slash/colon, just the filename.
             */
            szDir[pFileName-szFilePath] = TEXT('\0');
        }
        else if (ich == 1) {
            /*
             * something like "\foo.c"
             * Don't remove the last slash/colon, just the filename.
             */
            szDir[pFileName-szFilePath] = TEXT('\0');
        }
        else {
            /*
             * The filepath is a full normal path.
             * Could be something like "..\foo.c" or ".\foo.c" though.
             * Stomp on the last slash to get just the path.
             */
            szDir[pFileName-szFilePath-1] = TEXT('\0');
        }
    }

    /* else just a filename with no path. */
}

/*** GetFilenameFromPath
 *
 *
 * PSTR APIENTRY GetFilenameFromPath (PSTR szPath)
 *
 * ENTRY -    PSTR szPath  -
 *
 * EXIT  -    PSTR  -
 *
 * SYNOPSIS -  Given a full path returns a ptr to the filename bit.
 *             Unless it's a UNC style path in which case it returns the path.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 *  08-08-91  JohanneC  - ported from Windows 3.1
 *
 */
VOID FAR PASCAL GetFilenameFromPath(LPTSTR szPath, LPTSTR szFilename)
{
    DWORD dummy;
    LPTSTR pFileName;
    LPTSTR pExt;
    BOOL fUNC;


    GetPathInfo(szPath, &pFileName, &pExt, (WORD*) &dummy, &fUNC);

    /* If it's a UNC then the 'filename' part is the whole thing. */
    if (fUNC || (szPath == pFileName))
        lstrcpy(szFilename, szPath);
    else {
        if (*szPath == TEXT('"')) {
            *szFilename++ = TEXT('"');
        }
        lstrcpy(szFilename, pFileName);
    }
}

/*** HandleDosApps
 *
 *
 * void HandleDosApps (PSTR sz)
 *
 * ENTRY -    PSTR sz  -  full path sans arguments
 *
 * EXIT  -
 *
 * SYNOPSIS - Takes a full path to a file and checks if it's a dos app mentioned
 *            in the pif.inf file.
 *            If it isn't in the pif.inf file then the the routine returns without
 *            doing anything.
 *            If it is then it looks for a pif file with the same base name
 *            in the same directory.
 *            If there isn't one then it checks the windows directory.
 *            If that fails it calls setup to create a new one giving the full
 *            path to the app in question. - NOT supported in NTSetup.
 *            The procedure doesn't alter the input string.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 *  08-08-91  JohanneC  - ported from Windows 3.1
 *
 */
void FAR PASCAL HandleDosApps(LPTSTR sz)
{
    TCHAR szPath[MAXITEMPATHLEN+1];  // Copy of path so we can stomp all over
                                    // it.
    LPTSTR pszFileName;               // The file filename part.
    LPTSTR pszExt;                    // The extension.
    WORD ich;                       // Index to filename.
    TCHAR szPifSection[32];          // Section in file to search,
    TCHAR szPifIniFile[16];          // Ini file to check.
    TCHAR szSystemDir[MAXITEMPATHLEN+1]; // Path to system dir.
    TCHAR szReturnString[2];         // Mini buffer to check return from GPPS.
    //OFSTRUCT of;                    // OF struct.
    TCHAR szExecSetup[MAXITEMPATHLEN+1]; // String used to WinExec setup to
                                        // create the pif for this app.
    BOOL dummy;                     // Dummy variable.
    DWORD   dwResult ;
    TCHAR   szPathFieldTemp[MAXITEMPATHLEN+1] ;
    LPTSTR  FilePart ;

    /* Get system dir. */
    GetSystemDirectory(szSystemDir, CharSizeOf(szSystemDir));

    /* Load ini file info. */
    LoadString(hAppInstance, IDS_PIFINIFILE, szPifIniFile, CharSizeOf(szPifIniFile));
    LoadString(hAppInstance, IDS_PIFSECTION, szPifSection, CharSizeOf(szPifSection));
    LoadString(hAppInstance, IDS_EXECSETUP, szExecSetup, CharSizeOf(szExecSetup));

    /* Set up path to inf file. */
    if (lstrlen(szSystemDir) > 3) {
        lstrcat(szSystemDir, TEXT("\\"));
    }
    lstrcat(szSystemDir, szPifIniFile);

    /* Copy path */
    lstrcpy(szPath, sz);

    /* Get info about the path. */
    GetPathInfo(szPath, &pszFileName, &pszExt, &ich, &dummy);

#ifdef DEBUG
    OutputDebugString(TEXT("\n\rLooking in apps.ini for "));
    OutputDebugString(pszFileName);
    OutputDebugString(TEXT("\n\r"));
#endif

    /* Init the default to null. */
    szReturnString[0] = TEXT('\0');

    /*
     * Check in pif.ini file.
     * GPPS([section], keyname, szDef, szResultString, cbResString, FileName);
     */
    GetPrivateProfileString(szPifSection, pszFileName, szReturnString,
        szReturnString, CharSizeOf(szReturnString), szSystemDir);
    if (szReturnString[0] == TEXT('\0')) {
        /* It's not there. */
#ifdef DEBUG
        OutputDebugString(TEXT("App not in inf file"));
        OutputDebugString(TEXT("\n\r"));
#endif
        return;
    }

#ifdef DEBUG
    OutputDebugString(TEXT("App in inf file"));
    OutputDebugString(TEXT("\n\r"));
#endif

    /*
     * It's in the pif file, there should be a .pif for it somewhere.
     * Change extension to .pif
     */
    if (pszExt) {
        // copy .pif\0 over the existing extension.
        lstrcpy(pszExt, TEXT(".pif"));
    }
    else {
        // cat .pif\0 onto the end.
        lstrcat(szPath,TEXT(".pif"));
    }

    // Check given directory first.
#ifdef DEBUG

    OutputDebugString(TEXT("Checking "));
    OutputDebugString(szPath);
    OutputDebugString(TEXT("\n\r"));
#endif

//SearchPath!!!
    dwResult = SearchPath(NULL,szPath,NULL,MAXITEMPATHLEN+1,
                szPathFieldTemp,&FilePart) ;
    if (dwResult == 0 && GetLastError() != 0x20) {
    //if (OpenFile(szPath, &of, OF_EXIST) == (HFILE)-1 && of.nErrCode != 0x20) {
        // It's not there.

#ifdef DEBUG
        OutputDebugString(TEXT("Checking "));
        OutputDebugString(pszFileName);
        OutputDebugString(TEXT("\n\r"));
#endif

        // Check path.
        dwResult = SearchPath(NULL,pszFileName,NULL,MAXITEMPATHLEN+1,
                szPathFieldTemp,&FilePart) ;
        if (dwResult == 0 && GetLastError() != 0x20) {
        //if (! (OpenFile(pszFileName, &of, OF_EXIST) == (HFILE)-1 && of.nErrCode !=0x20) ) {
            // Found it on path - winoldapp app will find it,
#ifdef DEBUG
            OutputDebugString(TEXT("Found it on path. "));
            OutputDebugString(szPathFieldTemp);
            OutputDebugString(TEXT("\n\r"));
#endif
        }
        else {
#ifdef LATER
            //
            // NT Setup does not support this.
            // sunilp said so 9-9-92
            //

            // It's not anywhere so get setup to create it.
            lstrcat(szExecSetup, sz);

            // Exec setup - REVIEW silently ignore any errors from win exec.
            WinExec(szExecSetup, SW_SHOWNORMAL);
#endif
        }
    }
}



/*** FixUpNulls        -- replace "#" with NULL
 *
 *
 * VOID APIENTRY FixUpNulls(PSTR p)
 *
 * ENTRY -         PSTR        p                        -        pointer to string to replaces chars
 *
 *
 * EXIT  -        VOID
 *
 * SYNOPSIS -  seraches for any "#" chars, and replaces them with NULL
 *
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */
void NEAR PASCAL FixupNulls(LPTSTR p)
{
    while (*p) {
        if (*p == TEXT('#'))
            *p = TEXT('\0');
        p++;
    }
}


/*** GetFileNameFromBrowser        --
 *
 *
 * BOOL APIENTRY GetFileNameFromBrowse(HWND, PSTR, WORD, PSTR, WORD, PSTR)
 *
 * ENTRY -  HWND hwnd          -  Owner for browse dialog.
 *          PSTR szFilePath    -  Path to file
 *          WORD cbFilePath    -  Max length of file path buffer, in bytes.
 *          PSTR szWorkingDir  -  Working directory
 *          WORD wId           -  Id for filters string.
 *          PSTR szDefExt      -  Default extension to use if the user doesn't
 *                                specify enter one.
 * EXIT  -  BOOL
 *
 * SYNOPSIS - Use the common browse dialog to get a filename. The working
 *            directory of the common dialog will be set to the directory
 *            part of the file path if it is more than just a filename.
 *            If the filepath consists of just a filename then the working
 *            directory will be used. The full path to the selected file will
 *            be returned in szFilePath.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */
BOOL GetFileNameFromBrowse(
             HWND hwnd,
             LPTSTR szFilePath,
             WORD cbFilePath,
             LPTSTR szWorkingDir,
             WORD wId,
             LPTSTR szDefExt)
{
    OPENFILENAME ofn;   // Structure used to init dialog.
    TCHAR szFilters[200];// Filters string.
    TCHAR szTitle[80];   // Title for dialog.
    TCHAR szBrowserDir[MAXITEMPATHLEN+1];  // Directory to start browsing from.
    BOOL fBrowseOK;     // Result from browser.

    szBrowserDir[0] = TEXT('\0'); // By default use CWD.

    // Try to set the directory in the user's home directory.
    SetCurrentDirectory(szOriginalDirectory);

    // Load filter for the browser.
    LoadString(hAppInstance, wId, szFilters, CharSizeOf(szFilters));

    // Convert the hashes in the filter into NULLs for the browser.
    FixupNulls(szFilters);

    // Load the title for the browser.
    LoadString(hAppInstance, IDS_BROWSE, szTitle, CharSizeOf(szTitle));

    // Set up info for browser. */

    GetDirectoryFromPath(szFilePath, szBrowserDir);

    if (*szBrowserDir == TEXT('\0') && szWorkingDir) {
        lstrcpy(szBrowserDir, szWorkingDir);
    }

    /*
     * Stomp on the file path so that the dialog doesn't
     * try to use it to initialise the dialog. The result is put
     * in here.
     */
    szFilePath[0] = TEXT('\0');

    /* Setup info for comm dialog. */
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = szFilters;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex = 1;
    ofn.nMaxCustFilter = 0;
    ofn.lpstrFile = szFilePath;
    ofn.nMaxFile =  cbFilePath/sizeof(TCHAR);
    ofn.lpstrInitialDir = szBrowserDir;
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_SHOWHELP | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                                                            OFN_NOCHANGEDIR;
    ofn.lpfnHook = NULL;
    ofn.lpstrDefExt = szDefExt;
    ofn.lpstrFileTitle = NULL;

    /*
     * Get a filename from the dialog...
     * Load the commdlg dll.
     */
    if (!hCommdlg) {
        hCommdlg = LoadLibrary(szCommdlg);
        if (!hCommdlg) {
            /* Commdlg not available. */
            MyMessageBox(hwnd, IDS_APPTITLE, IDS_COMMDLGLOADERR, NULL, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
            hCommdlg = NULL;
            fBrowseOK = FALSE;
            goto ProcExit;
        }
        else {
            lpfnGOFN = (OPENFILENAME_PROC)GetProcAddress(hCommdlg, (LPSTR)szGetOpenFileName);
            if (!lpfnGOFN) {
                MyMessageBox(hwnd, IDS_APPTITLE, IDS_COMMDLGLOADERR, NULL, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
                hCommdlg = NULL;
                fBrowseOK = FALSE;
                goto ProcExit;
            }
        }
    }
    /*
     * Commdlg is loaded...
     * Call it.
     */
    fBrowseOK = (*lpfnGOFN)(&ofn);

ProcExit:

    // restore the current dir
    SetCurrentDirectory(szWindowsDirectory);

    return fBrowseOK;
}

/*** PMHelp        --
 *
 *
 * VOID APIENTRY PMHelp(HWND hwnd)
 *
 * ENTRY -         HWND        hwnd
 *
 *
 * EXIT  -        VOID
 *
 * SYNOPSIS -
 *
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */
void FAR PASCAL PMHelp(HWND hwnd)
{
    SetCurrentDirectory(szOriginalDirectory);
    if (!WinHelp(hwnd, szProgmanHelp, HELP_CONTEXT, dwContext)) {
        MyMessageBox(hwnd, IDS_APPTITLE, IDS_WINHELPERR, NULL, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
    }
    SetCurrentDirectory(szWindowsDirectory);
}


/*** MyDialogBox        --
 *
 *
 * WORD APIENTRY MyDialogBox(WORD idd, HWND hwndParent, FARPROC lpfnDlgProc)
 *
 * ENTRY -  WORD        idd
 *          HWND        hwnd
 *          FARPROC     lpfnDlgProc
 *
 * EXIT  -  WORD        xxx
 *
 * SYNOPSIS -
 *
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */
WORD APIENTRY MyDialogBox(WORD idd, HWND hwndParent, DLGPROC lpfnDlgProc)
{
  WORD          wRet;
  DWORD dwSave = dwContext;

  dwContext = IDH_DLGFIRST + idd;

  wRet = (WORD)DialogBox(hAppInstance, (LPTSTR) MAKEINTRESOURCE(idd), hwndParent,
        lpfnDlgProc);
  dwContext = dwSave;
  return(wRet);
}


/*** ChooserDlgProc --         Dialog Procedure for chooser
 *
 *
 *
 * ChooserDlgProc(HWND hwnd, UINT uiMsg, DWORD wParam, LPARAM lParam)
 *
 * ENTRY -  HWND hhwnd      - handle to dialog box.
 *          UINT uiMsg       - message to be acted upon.
 *          WPARAM wParam   - value specific to uiMsg.
 *          LPARAM lParam   - value specific to uiMsg.
 *
 * EXIT  -  True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */
INT_PTR APIENTRY ChooserDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
  register WORD wTempSelection;

  switch (uiMsg)
    {
  case WM_INITDIALOG:
          if (!AccessToCommonGroups) {
              EnableWindow(GetDlgItem(hwnd, IDD_COMMONGROUP), FALSE);
          }
          wNewSelection = SelectionType();
          if (wNewSelection == TYPE_ITEM)
              wTempSelection = IDD_ITEM;
          else {
              wTempSelection = IDD_PERSGROUP;
              wNewSelection = TYPE_PERSGROUP;
	  }

          /* Grey out illegal items. */
          if (!pCurrentGroup || !GroupCheck(pCurrentGroup)) {
              /* Group is RO - can't create new items. */
              EnableWindow(GetDlgItem(hwnd,IDD_ITEM), FALSE);
              wTempSelection = IDD_PERSGROUP;
              wNewSelection = TYPE_PERSGROUP;
          }

          if (dwEditLevel == 1) {
              /* Not allowed to create new groups. */
              EnableWindow(GetDlgItem(hwnd,IDD_PERSGROUP), FALSE);
              wTempSelection = IDD_ITEM;
              wNewSelection = TYPE_ITEM;
          }

          CheckRadioButton(hwnd, IDD_ITEM, IDD_COMMONGROUP, wTempSelection);
          break;

      case WM_COMMAND:
          switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
              case IDD_HELP:
                        goto DoHelp;

              case IDD_ITEM:
                  if (IsWindowEnabled(GetDlgItem(hwnd,IDD_ITEM)))
                      wNewSelection = TYPE_ITEM;
                  break;

              case IDD_PERSGROUP:
                  if (IsWindowEnabled(GetDlgItem(hwnd,IDD_PERSGROUP)))
                      wNewSelection = TYPE_PERSGROUP;
                  break;

              case IDD_COMMONGROUP:
                  if (IsWindowEnabled(GetDlgItem(hwnd,IDD_COMMONGROUP)))
                      wNewSelection = TYPE_COMMONGROUP;
                  break;

              case IDOK:
                  EndDialog(hwnd, TRUE);
                  break;

              case IDCANCEL:
                  EndDialog(hwnd, FALSE);
                  break;

              default:
                  return(FALSE);
            }
          break;

      default:

          if (uiMsg == uiHelpMessage) {
DoHelp:
              PMHelp(hwnd);

              return TRUE;
          } else
              return FALSE;
    }
  UNREFERENCED_PARAMETER(lParam);
  return(TRUE);
}


/*** MoveItemDlgProc --         Dialog Procedure
 *
 *
 *
 * INT_PTR APIENTRY MoveItemDlgProc(HWND hwnd, UINT uiMsg, DWORD wParam, LONG lParam)
 *
 * ENTRY -  HWND hwnd       - handle to dialog box.
 *          UINT uiMsg       - message to be acted upon.
 *          WPARAM wParam   - value specific to uiMsg.
 *          LPARAM lParam   - value specific to uiMsg.
 *
 * EXIT  -     True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT_PTR APIENTRY MoveItemDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)

{
  int               iSel;
  HWND              hwndCB;
  register PGROUP   pGroup;

  hwndCB = GetDlgItem(hwnd, IDD_GROUPS);

  switch (uiMsg) {
      case WM_INITDIALOG:
      {
          LPITEMDEF  lpid;
          LPGROUPDEF lpgd;
          int i=0;

          lpgd = LockGroup(pCurrentGroup->hwnd);

          if (lpgd == 0L)
              goto MoveDlgExit;

          lpid = ITEM(lpgd,pCurrentGroup->pItems->iItem);

          SetDlgItemText(hwnd, IDD_ITEM, (LPTSTR) PTR(lpgd, lpid->pName));
          SetDlgItemText(hwnd, IDD_GROUP, (LPTSTR) PTR(lpgd, lpgd->pName));

          UnlockGroup(pCurrentGroup->hwnd);

          pGroup = pFirstGroup;
          while (pGroup) {
              if (IsGroupReadOnly(pGroup->lpKey, pGroup->fCommon))
                  pGroup->fRO = TRUE;
              else
                  pGroup->fRO = FALSE;
              if (!pGroup->fRO) {

                  if (pGroup != pCurrentGroup) {
                      GetWindowText(pGroup->hwnd, (LPTSTR)szMessage, MAXGROUPNAMELEN + 1);
                      iSel = (int)SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szMessage);
                      SendMessage(hwndCB, CB_SETITEMDATA, iSel, (LPARAM)(LPTSTR)pGroup);
                      i++;
                  }
              }
              pGroup = pGroup->pNext;
          }
          SendMessage(hwndCB, CB_SETCURSEL, 0, 0L);
          if (i==0) {
              /* No items in list box - Kill the OK button. */
              EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);
          }
          break;
      }

      case WM_COMMAND:
          switch(GET_WM_COMMAND_ID(wParam, lParam)) {
              case IDD_HELP:
                  goto DoHelp;

              case IDOK:
              {
                  int       nIndex;
                  PGROUP    pGTemp;

                  /* Get the pointer to the selected group. */
                  nIndex = (int)SendMessage(hwndCB, CB_GETCURSEL, 0, 0L);
                  pGroup = (PGROUP)SendMessage(hwndCB, CB_GETITEMDATA, nIndex, 0L);

                  /* Check pointer. */
                  if (!pGroup)
                      goto ExitCase;

                  pGTemp = pCurrentGroup;

                  /*
                   * Only do this operation if the user actually had a
                   * group selected.  CB_GETITEMDATA will return -1 if
                   * an item wasn't selected.  This happens if the user
                   * tries to do a move when there's only one group around.
                   */
                  if (pGroup != (PGROUP)(-1)) {
                      if (DuplicateItem(pGTemp,pGTemp->pItems,pGroup,NULL)) {

                          // OK to delete the original.
                          DeleteItem(pGTemp,pGTemp->pItems);
// It's messy to change the focus when using the keyboard.
// SendMessage(hwndMDIClient, WM_MDIACTIVATE, (WPARAM)(pGroup->hwnd), 0L);
                          CalcGroupScrolls(pGroup->hwnd);
                      }
                  }

ExitCase:
                  EndDialog(hwnd, TRUE);
                  break;
              }

              case IDCANCEL:
MoveDlgExit:
                  EndDialog(hwnd, FALSE);
                  break;

              default:
                  return(FALSE);
          }
          break;

      default:

          if (uiMsg == uiHelpMessage)
DoHelp:
          {
              DWORD dwSave = dwContext;

              dwContext = IDH_MOVEDLG;
              PMHelp(hwnd);
              dwContext = dwSave;
              return TRUE;
          } else
              return FALSE;
    }
  UNREFERENCED_PARAMETER(lParam);
  return(TRUE);
}


/*** CopyItemDlgProc --         Dialog Procedure
 *
 *
 *
 * INT_PTR APIENTRY CopyItemDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
 *
 * ENTRY -         HWND hhwnd                 - handle to dialog box.
 *                        UINT uiMsg                  - message to be acted upon.
 *                 WPARAM wParam        - value specific to uiMsg.
 *                 LPARAM lParam        - value specific to uiMsg.
 *
 * EXIT  -           True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT_PTR APIENTRY CopyItemDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)

{
    int               iSel;
    HWND              hwndCB;
    register PGROUP   pGroup;
    LPITEMDEF         lpid;
    LPGROUPDEF        lpgd;

    hwndCB = GetDlgItem(hwnd, IDD_GROUPS);

    switch (uiMsg) {
    case WM_INITDIALOG:
    {
        int i=0;

        LoadString(hAppInstance, IDS_COPYDLGTITLE, (LPTSTR)szTitle, MAXTITLELEN);
        SetWindowText(hwnd, szTitle);
        LoadString(hAppInstance, IDS_COPYDLGTITLE1, (LPTSTR)szTitle, MAXTITLELEN);
        SetDlgItemText(hwnd, IDD_MOVETITLE1, szTitle);

        lpgd = LockGroup(pCurrentGroup->hwnd);

        if (lpgd == 0L)
            goto CopyDlgExit;

        lpid = ITEM(lpgd,pCurrentGroup->pItems->iItem);

        SetDlgItemText(hwnd, IDD_ITEM, (LPTSTR) PTR(lpgd, lpid->pName));
        SetDlgItemText(hwnd, IDD_GROUP, (LPTSTR) PTR(lpgd, lpgd->pName));

        UnlockGroup(pCurrentGroup->hwnd);

        pGroup = pFirstGroup;
        while (pGroup) {
            if (IsGroupReadOnly(pGroup->lpKey, pGroup->fCommon))
                pGroup->fRO = TRUE;
            else
                pGroup->fRO = FALSE;

            if (!pGroup->fRO) {

                GetWindowText(pGroup->hwnd, (LPTSTR)szMessage, MAXGROUPNAMELEN + 1);
                iSel = (int)SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szMessage);
                SendMessage(hwndCB, CB_SETITEMDATA, iSel, (LPARAM)(LPTSTR)pGroup);
                i++;
            }
            pGroup = pGroup->pNext;
        }
        SendMessage(hwndCB, CB_SETCURSEL, 0, 0L);
        if (i==0) {
            // No items in list box - Kill the OK button.
            EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);
        }
        break;
    }

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDD_HELP:
            goto DoHelp;

        case IDOK:
        {
            int            nIndex;

            /* Get the pointer to the selected group. */
            nIndex = (int)SendMessage(hwndCB, CB_GETCURSEL, 0, 0L);
            pGroup = (PGROUP)SendMessage(hwndCB, CB_GETITEMDATA, nIndex, 0L);

            /* Check pointer. */
            if (!pGroup)
                goto ExitCase;

            DuplicateItem(pCurrentGroup,pCurrentGroup->pItems,
                                pGroup,NULL);
// Don't change focus to destination on a copy, very messy if you have a
// group maximised and you want to copy a whole bunch of stuff to another
// group using the keyboard.
// SendMessage(hwndMDIClient, WM_MDIACTIVATE, (WPARAM)(pGroup->hwnd), 0L);

            /* Redo scroll bars for destination. */
            CalcGroupScrolls(pGroup->hwnd);
            /* Redo scroll bars for source. */
            CalcGroupScrolls(pCurrentGroup->hwnd);

ExitCase:
            EndDialog(hwnd, TRUE);
            break;
        }

        case IDCANCEL:
CopyDlgExit:
            EndDialog(hwnd, FALSE);
            break;

        default:
            return(FALSE);
        }
        break;

    default:

        if (uiMsg == uiHelpMessage)
DoHelp:
        {
            DWORD dwSave = dwContext;

            dwContext = IDH_COPYDLG;
            PMHelp(hwnd);
            dwContext = dwSave;
            return TRUE;
        } else
            return FALSE;
    }
    UNREFERENCED_PARAMETER(lParam);
    return(TRUE);
}

/*** SaveRecentFileList --    Save the list of recently used files
 *
 * void APIENTRY SaveRecentFileList (HWND hwnd, LPTSTR szCurrentFile);
 *
 *
 *
 * ENTRY - HWND   hwnd            - handle to dialog box.
 *         LPTSTR szCurrentFile   - pointer to selected filename
 *         WORD   idControl       - control id
 *
 * EXIT  -
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */


void APIENTRY SaveRecentFileList (HWND hwnd, LPTSTR szCurrentFile, WORD idControl)
{
    HKEY  hKey;
    DWORD dwDisp;
    DWORD dwDataType, dwMaxFiles=INIT_MAX_FILES, dwMaxFilesSize, dwCount;
    TCHAR szFileEntry[20];
    DWORD dwEnd=0;
    DWORD dwFileNum=0;
    DWORD dwDup;
    static TCHAR szRecentFilePath[MAXITEMPATHLEN+1];

    //
    // Open registry key
    //

    if ( RegCreateKeyEx (HKEY_CURRENT_USER, FILES_KEY, 0, 0,
                             REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                             NULL, &hKey, &dwDisp) != ERROR_SUCCESS) {
        return;
    }


    //
    // Query the max number of files to save first.
    //

    dwMaxFilesSize = sizeof (DWORD);

    RegQueryValueEx (hKey, MAXFILES_ENTRY, NULL, &dwDataType,
                    (LPBYTE)&dwMaxFiles, &dwMaxFilesSize);

    //
    // If the user request 0 entries, then exit now.
    //
    if (dwMaxFiles == 0) {
        RegCloseKey (hKey);
        return;
    }

    //
    // Find out how many items are in the list box.
    //

    dwEnd = (DWORD)SendDlgItemMessage (hwnd, idControl, CB_GETCOUNT, 0, 0);

    //
    // If the max number of items we want to save is less than the
    // number of entries, then change the ending point.
    //

    if (dwMaxFiles < dwEnd) {
        dwEnd = dwMaxFiles;
    }

    //
    // Add the first entry (the current file)
    //

    wsprintf (szFileEntry, FILE_ENTRY, dwFileNum++);
    dwMaxFilesSize = MAXITEMPATHLEN+1;

    RegSetValueEx (hKey, szFileEntry, 0, REG_SZ, (CONST BYTE *)szCurrentFile,
                   sizeof (TCHAR) * (lstrlen (szCurrentFile)+1));


    //
    // Check for a duplicate string.
    //

    dwDup = (DWORD)SendDlgItemMessage (hwnd, idControl, CB_FINDSTRING,
                                       (WPARAM) -1, (LPARAM) szCurrentFile);

    //
    // If we already have dwMaxFiles in the list and we don't have any
    // duplicates, then we only want to save dwMaxFiles - 1 entries
    // (drop the last entry).
    //
    //

    if ( (dwEnd == dwMaxFiles) && (dwDup == CB_ERR) ) {
        dwEnd--;
    }

    //
    // Now loop through the remaining entries
    //

    for (dwCount=0; dwCount < dwEnd; dwCount++) {

        //
        // Check to see if we are at the duplicate entry.  If
        // so skip on to the next item.
        //

        if ((dwDup != CB_ERR) && (dwCount == dwDup)) {
            continue;
        }

        //
        // Get an entry out of the listbox.
        //

        SendDlgItemMessage (hwnd, idControl, CB_GETLBTEXT, (WPARAM) dwCount,
                            (LPARAM) szRecentFilePath);

        //
        // If we get a NULL string, break out of the loop.
        //

        if (!(*szRecentFilePath) || !szRecentFilePath) {
            break;
        }

        //
        // Build the entry name
        //

        wsprintf (szFileEntry, FILE_ENTRY, dwFileNum);
        dwMaxFilesSize = MAXITEMPATHLEN+1;

        //
        // Save the entry
        //

        RegSetValueEx (hKey, szFileEntry, 0, REG_SZ,(CONST BYTE *) szRecentFilePath,
                       sizeof (TCHAR) * (lstrlen (szRecentFilePath)+1));

        //
        // Increment our current file number
        //

        dwFileNum++;
    }

    //
    // Close the key
    //

    RegCloseKey (hKey);

}


/*** RunDlgProc --         Dialog Procedure
 *
 *
 *
 * INT_PTR APIENTRY RunDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
 *
 * ENTRY - HWND hhwnd    - handle to dialog box.
 *         UINT uiMsg    - message to be acted upon.
 *         WPARAM wParam - value specific to uiMsg.
 *         LPARAM lParam  - value specific to uiMsg.
 *
 * EXIT  - True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT_PTR APIENTRY RunDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    WORD ret;
    TCHAR szFullPath[MAXITEMPATHLEN+1];
    HKEY  hKey;
    DWORD dwDisp;
    DWORD dwDataType, dwMaxFiles=INIT_MAX_FILES, dwMaxFilesSize, dwCount;
    TCHAR szFileEntry[20];
    DWORD dwThreadID;
    HANDLE hThread;
    DWORD dwBinaryInfo, cbData;
    BOOL  bDoit;


    switch (uiMsg) {
    case WM_INITDIALOG:
        SendDlgItemMessage(hwnd, IDD_PATH, EM_LIMITTEXT, CharSizeOf(szPathField)-1, 0L);
        szPathField[0] =TEXT('\0');  // initialize the path to null
	SetDlgItemText(hwnd, IDD_PATH, szPathField);
        CheckDlgButton(hwnd, IDD_NEWVDM, 1);
        EnableWindow(GetDlgItem(hwnd,IDD_NEWVDM), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);

        //
        // Load the combobox with recently used files from the registry.
        //
        // Query the max number of files first.
        //

        if (RegCreateKeyEx (HKEY_CURRENT_USER, FILES_KEY, 0, 0,
                            REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                            NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

            if (dwDisp == REG_OPENED_EXISTING_KEY) {

                //
                //  Query the max number of entries
                //

                dwMaxFilesSize = sizeof (DWORD);

                if (RegQueryValueEx (hKey, MAXFILES_ENTRY, NULL, &dwDataType,
                               (LPBYTE)&dwMaxFiles, &dwMaxFilesSize) == ERROR_SUCCESS) {

                    //
                    //  Now Query each entry and add it to the list box.
                    //

                    for (dwCount=0; dwCount < dwMaxFiles; dwCount++) {

                        wsprintf (szFileEntry, FILE_ENTRY, dwCount);
                        dwMaxFilesSize = MAXITEMPATHLEN+1;

                        if (RegQueryValueEx (hKey, szFileEntry, NULL, &dwDataType,
                                         (LPBYTE) szFullPath, &dwMaxFilesSize) == ERROR_SUCCESS) {

                            //
                            // Found an entry.  Add it to the combo box.
                            //

                            SendDlgItemMessage (hwnd, IDD_PATH,
                                                CB_ADDSTRING, 0,
                                                (LPARAM)szFullPath);

                        } else {
                            break;
                        }
                    }
                }
            } else {
                //
                // We are working with a new key, so we need to
                // set the default number of files.
                //

                RegSetValueEx (hKey, MAXFILES_ENTRY, 0, REG_DWORD,
                               (CONST BYTE *) &dwMaxFiles, sizeof (DWORD));
            }

            //
            //  Close the registry key
            //

            RegCloseKey (hKey);

        }

        //
        //  Set the inital state for the thread which checks the binary
        //  type.
        //

        //
        // Query if the binary type checking is enabled.
        //

        cbData = sizeof(dwBinaryInfo);
        if (RegQueryValueEx(hkeyPMSettings, szCheckBinaryType, 0, &dwDataType,
                     (LPBYTE)&dwBinaryInfo, &cbData) == ERROR_SUCCESS) {
            bCheckBinaryType = (BOOL) dwBinaryInfo;
        } else {
            bCheckBinaryType = BINARY_TYPE_DEFAULT;
        }

        //
        // Query the binary type checking timeout value.
        //

        cbData = sizeof(dwBinaryInfo);
        if (RegQueryValueEx(hkeyPMSettings, szCheckBinaryTimeout, 0, &dwDataType,
                     (LPBYTE)&dwBinaryInfo, &cbData) == ERROR_SUCCESS) {
            uiCheckBinaryTimeout = (UINT) dwBinaryInfo;
        } else {
            uiCheckBinaryTimeout = BINARY_TIMEOUT_DEFAULT;
        }


        //
        // Create the worker thread, and the signal event.  If appropriate.
        //

        if (bCheckBinaryType) {
            hCheckBinaryEvent = CreateEvent (NULL, FALSE, FALSE,
                                             CHECK_BINARY_EVENT_NAME);

            hThread = CreateThread (NULL, 0,
                                   (LPTHREAD_START_ROUTINE) CheckBinaryThread,
                                   (LPVOID) hwnd, 0, &dwThreadID);

            bCheckBinaryDirtyFlag = FALSE;
        }

        if (!hCheckBinaryEvent || !hThread || !bCheckBinaryType) {
            //
            // If this statement is true, either we failed to create
            // the event, the thread, or binary type checking is disabled.
            // In this case, enable the separate memory checkbox, and let
            // the user decide on  his own.
            //

            CheckDlgButton(hwnd, IDD_NEWVDM, 0);
            EnableWindow(GetDlgItem(hwnd,IDD_NEWVDM), TRUE);

            //
            // Clean up either item that succeeded
            //
            if (hCheckBinaryEvent) {
                CloseHandle (hCheckBinaryEvent);
            }

            if (hThread) {
                TerminateThread (hThread, 0);
            }

            //
            // Setting this variable to NULL will prevent the second
            // thread from trying to check the binary type.
            //

            hCheckBinaryEvent = NULL;
        }

        break;

    case WM_TIMER:
        if (hCheckBinaryEvent && bCheckBinaryDirtyFlag) {
            bCheckBinaryDirtyFlag = FALSE;
            SetEvent (hCheckBinaryEvent);
        }
        break;

    case MYCBN_SELCHANGE:
        if (bCheckBinaryType) {
            bCheckBinaryDirtyFlag = TRUE;
            SetTimer (hwnd, CHECK_BINARY_ID, uiCheckBinaryTimeout, NULL);
        }
        bDoit = (GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1) > 0);
        EnableWindow(GetDlgItem(hwnd, IDOK), bDoit);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDD_HELP:
                goto DoHelp;

            case IDD_PATH:
                if ((GET_WM_COMMAND_CMD(wParam, lParam) != CBN_EDITCHANGE) &&
                   (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE) )
                    break;

                PostMessage (hwnd, MYCBN_SELCHANGE, wParam, lParam);
                break;


            case IDOK:
            {
                TCHAR szFilename[MAXITEMPATHLEN+3]; // added chars for ".\"
                BOOL  bNewVDM;

                //
                // Run this app in the user's home directory
                //
                SetCurrentDirectory(szOriginalDirectory);

                GetDlgItemText(hwnd, IDD_PATH, szPathField, CharSizeOf(szPathField));

//#ifdef JAPAN
//                if (CheckPortName(hwnd,szPathField))
//                    break;
//#endif

                DoEnvironmentSubst(szPathField, CharSizeOf(szPathField));

                GetDirectoryFromPath(szPathField, szDirField);
                if (*szDirField) {
                    // Convert path into a .\foo.exe style thing.
                    lstrcpy(szFilename, TEXT(".\\"));
                    // Tag the filename and params on to the end of the dot slash.
                    GetFilenameFromPath(szPathField, szFilename+2);
		            if (*(szFilename+2) == TEXT('"') ) {
			            SheRemoveQuotes(szFilename+2);
			            CheckEscapes(szFilename, CharSizeOf(szFilename));
		            }
                }
                else {
                    GetFilenameFromPath(szPathField, szFilename);
                }

                bNewVDM = ( IsWindowEnabled(GetDlgItem(hwnd,IDD_NEWVDM)) &&
                            IsDlgButtonChecked(hwnd, IDD_NEWVDM) );

                ret = ExecProgram(szFilename, szDirField, szFilename,
                                  IsDlgButtonChecked(hwnd, IDD_LOAD),
                                  0, 0, bNewVDM);

                //
                // reset Progman's working directory.
                //
                SetCurrentDirectory(szWindowsDirectory);

                if (ret) {
                    MyMessageBox(hwnd, IDS_EXECERRTITLE, ret, szPathField, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

                } else {
                    GetDlgItemText(hwnd, IDD_PATH, szPathField, CharSizeOf(szPathField));
                    SaveRecentFileList (hwnd, szPathField, IDD_PATH);

                    if (bCheckBinaryType) {
                        //
                        // Setting this variable to false, and signaling the event
                        // will cause the binary checking thread to terminate.
                        //

                        bCheckBinaryType = FALSE;
                        SetEvent (hCheckBinaryEvent);
                        KillTimer (hwnd, CHECK_BINARY_ID);
                    }

                    EndDialog(hwnd, TRUE);
                }
                break;
            }
            case IDD_BROWSE:
            {
                DWORD dwSave = dwContext;
                TCHAR szPathField[MAXITEMPATHLEN+1];

                dwContext = IDH_RUNBROWSEDLG;

                GetDlgItemText(hwnd,IDD_PATH,szPathField,MAXITEMPATHLEN+1);
                wParam = GetFileNameFromBrowse(hwnd, szPathField, sizeof(szPathField),
                                        NULL, IDS_PROPERTIESPROGS, TEXT("exe"));

                dwContext = dwSave;

                if (wParam) {
                    //
                    // if filename or directory have spaces, put the path
                    // between quotes.
                    //

                    CheckEscapes(szPathField, MAXITEMPATHLEN+1);
                    SetDlgItemText(hwnd, IDD_PATH, szPathField);
                    PostMessage (hwnd, MYCBN_SELCHANGE, wParam, lParam);
                    // Set default button to OK.
                    PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hwnd, IDOK), TRUE);
                }
                break;
            }


            case IDCANCEL:
                if (bCheckBinaryType) {
                    //
                    // Setting this variable to false, and signaling the event
                    // will cause the binary checking thread to terminate.
                    //

                    bCheckBinaryType = FALSE;
                    SetEvent (hCheckBinaryEvent);
                    KillTimer (hwnd, CHECK_BINARY_ID);
                }

                EndDialog(hwnd, FALSE);
                break;

            default:
                return(FALSE);
        }
        break;

    default:

        if (uiMsg == uiHelpMessage || uiMsg == uiBrowseMessage)
DoHelp:
        {
            PMHelp(hwnd);

            return TRUE;
        } else
            return FALSE;
    }
    UNREFERENCED_PARAMETER(lParam);
    return(TRUE);
}

/*** CheckBinaryThread --
 *
 *
 *
 * void CheckBinaryThread (HWND, INT)
 *
 * ENTRY -  HWND hDlg       - handle to dialog box.
 *          INT  idCheckBox - Checkbox control id
 *
 * EXIT  -  void
 *
 *  05-18-94 Eric Flo  - created
 *
 */

void CheckBinaryThread (LPVOID hwndDlg)
{
    HWND   hwnd = (HWND) hwndDlg;
    TCHAR  szFullPath[MAXITEMPATHLEN+1];
    LPTSTR FilePart ;
    DWORD  dwBinaryType;


    while (bCheckBinaryType) {

        WaitForSingleObject (hCheckBinaryEvent, INFINITE);

        if (bCheckBinaryType) {

            DoEnvironmentSubst(szPathField, CharSizeOf(szPathField));
            StripArgs(szPathField);
            TagExtension(szPathField, sizeof(szPathField));
            SheRemoveQuotes(szPathField);
            if (SearchPath(NULL, szPathField, NULL, MAXITEMPATHLEN+1,
                           szFullPath, &FilePart) &&
                           GetBinaryType(szFullPath, &dwBinaryType) &&
                           dwBinaryType == SCS_WOW_BINARY) {
                CheckDlgButton(hwnd, IDD_NEWVDM, 0);
                EnableWindow(GetDlgItem(hwnd,IDD_NEWVDM), TRUE);

            } else {
                CheckDlgButton(hwnd, IDD_NEWVDM, 1);
                EnableWindow(GetDlgItem(hwnd,IDD_NEWVDM), FALSE);
            }

        }

    }

    //
    // Close our event handle and exit the thread.
    //

    CloseHandle (hCheckBinaryEvent);
    ExitThread (0);
}



/*** ValidatePath --
 *
 *
 *
 * DWORD APIENTRY ValidatePath(HWND, PSTR, PSTR, PSTR)
 *
 * ENTRY -  HWND hDlg       - handle to dialog box.
 *          PSTR szPath     - path to item.
 *          PSTR szDir      -  path to working directory.
 *          PSTR szExePath  -  path to associated exe.
 *
 * EXIT  -  DWORD       - returns PATH_VALID is path is valid.
 *                        if path is not valid returns PATH_INVALID_OK
 *                        if user hits OK to invalid message box,
 *                        otherwise returns PATH_VALID
 *
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 *  08-08-91 JohanneC  - updated to Windows 3.1
 *
 */

DWORD APIENTRY ValidatePath(HWND hDlg, LPTSTR szPath, LPTSTR szDir, LPTSTR szExePath)
{
  int cDrive;
  TCHAR szTemp[MAXITEMPATHLEN+1];
  int err;
  BOOL bOriginalDirectory;  // using original directory
  DWORD dwRet = PATH_VALID;
  BOOL fOK = TRUE;      // If the path or the dir check fail
                        // then don't bother with the assoc check.

  /* Check working directory. */
  GetCurrentDirectory(MAXITEMPATHLEN, szTemp);
  SetCurrentDirectory(szOriginalDirectory);

  //CharToOem(szDir, szDir);
  /* Allow dir field to be NULL without error. */
  if (szDir && *szDir) {

      /* Remove leading spaces. */
      // RemoveLeadingSpaces(szDir);
      SheRemoveQuotes(szDir);


      //
      // Test if the directory szDir is valid.
      //
      if (!ValidPathDrive(szDir) ||  !SetCurrentDirectory(szDir)) {
          if (MyMessageBox(hDlg, IDS_BADPATHTITLE, IDS_BADPATHMSG3, NULL, MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION) == IDCANCEL)
              goto ExitFalse;
          fOK = FALSE;
      }
  }

  //
  // Before searching for the executable, check the validity of the szPath
  // drive if there's one specified.
  //
  if (!ValidPathDrive(szPath)) {
      if (MyMessageBox(hDlg, IDS_BADPATHTITLE, IDS_BADPATHMSG, szPath, MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION) == IDCANCEL)
          goto ExitFalse;
      fOK = FALSE;
  }
  else {
      err = (int)((DWORD_PTR)FindExecutable(szPath, szDir, szExePath));
  }

  /* Check if the file exists if there is no associated exe. */
  if (fOK && !*szExePath) {
      if (err == SE_ERR_FNF) {
          /* File doesn't exist. */
          if (MyMessageBox(hDlg, IDS_BADPATHTITLE, IDS_BADPATHMSG, szPath, MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION) == IDCANCEL)
              goto ExitFalse;
      }
      else {
          /* Association is bogus. */
          if (MyMessageBox(hDlg, IDS_BADPATHTITLE, IDS_BADPATHMSG2, szPath, MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION) == IDCANCEL)
              goto ExitFalse;
          else
	      dwRet = PATH_INVALID_OK;
      }
  }

  /* Warn people against using removable or remote paths. */

  /* HACK:  Hard code UNC path format.  Yuck. */
  if (szPath[0] == TEXT('\\') && szPath[1] == TEXT('\\'))
      goto VPWarnNet;

  if (szPath[1] != TEXT(':') ) {
      cDrive = (int)((DWORD_PTR)CharUpper((LPTSTR)szTemp[0]));
      cDrive = cDrive - (INT)TEXT('A');
      bOriginalDirectory = TRUE;
  }
  else {
      cDrive = (int)((DWORD_PTR)CharUpper((LPTSTR)szPath[0]));
      cDrive = cDrive - (INT)TEXT('A');
      bOriginalDirectory = FALSE;
  }

  /* Change back to old directory. */
  SetCurrentDirectory(szTemp);
  //OemToChar(szDir, szDir);

  if (IsRemovableDrive(cDrive)) {
      if (MyMessageBox(hDlg, IDS_REMOVEPATHTITLE, IDS_PATHWARNING, NULL, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) == IDNO)
          return(PATH_INVALID);
      else
          return(dwRet);
  }

  if (IsRemoteDrive(cDrive) && !bOriginalDirectory) {
VPWarnNet:
      if (MyMessageBox(hDlg, IDS_NETPATHTITLE, IDS_PATHWARNING, NULL, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) == IDNO)
          return(PATH_INVALID);
  }
  return(dwRet);

ExitFalse:
  // Change back to old directory.
  SetCurrentDirectory(szTemp);
  //OemToChar(szDir, szDir);
  return(PATH_INVALID);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  BrowseOK() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL NEAR PASCAL BrowseOK(HWND hWnd)
{
    DWORD dwSave = dwContext;
    TCHAR szPathField[MAXITEMPATHLEN+1];
    BOOL ret;

    dwContext = IDH_ICONBROWSEDLG;
    GetDlgItemText(hWnd, IDD_NAME, szPathField, CharSizeOf(szPathField));
    if (GetFileNameFromBrowse(hWnd, szPathField, sizeof(szPathField),
                                     NULL, IDS_CHNGICONPROGS, TEXT("ico"))) {
        //
        // if filename or directory have spaces, put the path
        // between quotes.
        //

        CheckEscapes(szPathField, MAXITEMPATHLEN+1);
        SetDlgItemText(hWnd, IDD_NAME, szPathField);
        /* Set default button to OK. */
        PostMessage(hWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hWnd, IDOK), TRUE);
        ret = TRUE;
	}
    else
        ret = FALSE;

    dwContext = dwSave;
    return ret;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IconFileExists() -                                                      */
/*                                                                          */
/* Checks if the file exists, if it doesn't it tries tagging on .exe and    */
/* if that fails it reports an error. The given path is environment expanded. */
/* If it needs to put up an error box, it changes the cursor back.          */
/* Path s assumed to be MAXITEMPATHLEN long.                                */
/* The main reason for moving this out of the DlgProc was because we're     */
/* running out of stack space on the call to the comm dlg.                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL NEAR PASCAL IconFileExists(HWND hWnd, HCURSOR hCur, LPTSTR szPath)
{
    TCHAR   szExtended[MAXITEMPATHLEN+1];  // Path with .exe if needed.
    BOOL   ret = TRUE;
    //OFSTRUCT of;
    HCURSOR hCursor;
    DWORD   dwResult ;
    TCHAR   szPathFieldTemp[MAXITEMPATHLEN+1] ;
    LPTSTR  FilePart ;

    /* Check Files existance. */
    DoEnvironmentSubst(szPath, MAXITEMPATHLEN+1);
    StripArgs(szPath);
    if (*szPath == TEXT('"')) {
        SheRemoveQuotes(szPath);
    }
    lstrcpy(szExtended, szPath);

    // use SearchPath instead of MOpenFile(OF_EXIST) to see if a file exists

    dwResult = SearchPath(NULL,szPath,NULL,MAXITEMPATHLEN+1,
                szPathFieldTemp,&FilePart) ;

    if (dwResult == 0 && GetLastError() != 0x20) {

        dwResult = SearchPath(NULL,szExtended,TEXT(".exe"),MAXITEMPATHLEN+1,
                szPathFieldTemp,&FilePart) ;
        if (dwResult == 0 && GetLastError() != 0x20) {

    	    ShowCursor(FALSE);
    	    hCursor = SetCursor(hCur);
            /*
             * File doesn't exist,tidier if we report the error with the
             * unextended path only.
             */
    	    MyMessageBox(hWnd, IDS_NOICONSTITLE, IDS_BADPATHMSG,
                                        szPath, MB_OK | MB_ICONEXCLAMATION);
            ret = FALSE;
    	    ShowCursor(TRUE);
    	    SetCursor(hCursor);
        }
        else {
            lstrcpy(szPath, FilePart);
        }
    }
    return ret;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IconDlgProc() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* NOTE: Returns Icon's path in 'szIconPath' and number in 'iDlgIconId'.
 *
 *         INPUT:
 *         'szIconPath' has the default icon's path.
 *         'iDlgIconId' is set to the default icon's id.
 *
 *         'szMessage' is used as a temporary variable.
 *         'szPathField' is used as a temporary variable.
 *
 *         OUTPUT:
 *         'szIconPath' contains the icon's path.
 *         'iDlgIconId' contains the icon's resource id.
 *         'iDlgIconIndex' contains the icon's index.
 */

INT_PTR APIENTRY IconDlgProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
  int    i;
  int    iIconSelected = 0;
static  HANDLE hIconList = NULL;
static  LPMYICONINFO lpIconList;
static  INT cIcons;

  switch (uiMsg) {
      case WM_INITDIALOG:
      {
          RECT   rc;
          int    cy;
          TCHAR   szExpanded[MAXITEMPATHLEN+1];

          /*
           * All this first pass stuff is so that the first time something
           * bogus happens (file not found, no icons) we give the user
           * a list of icons from progman.
           */
          fFirstPass = TRUE;

          SetDlgItemText(hwnd, IDD_NAME, (LPTSTR)szIconPath);
          SendDlgItemMessage(hwnd, IDD_NAME, EM_LIMITTEXT, MAXITEMPATHLEN, 0L);

          SendDlgItemMessage(hwnd,IDD_ICON,LB_SETCOLUMNWIDTH,
                            GetSystemMetrics(SM_CXICON) + 12,0L);

          wParam = (WPARAM)GetDlgItem(hwnd,IDD_ICON);

          /* compute the height of the listbox based on icon dimensions
           */
          GetClientRect((HWND) wParam,&rc);
          cy = GetSystemMetrics(SM_CYICON)
                + GetSystemMetrics(SM_CYHSCROLL)
                + GetSystemMetrics(SM_CYBORDER)
                + 4;

          SetWindowPos((HWND)wParam, NULL, 0, 0, rc.right, cy,
                                            SWP_NOMOVE | SWP_NOZORDER);
          cy = rc.bottom - cy;

          GetWindowRect(hwnd,&rc);
          rc.bottom -= rc.top;
          rc.right -= rc.left;

          /* FE FONTS are taller than US Font */
          if ( GetSystemMetrics( SM_DBCSENABLED ) )
            rc.bottom = rc.bottom - cy;

          SetWindowPos(hwnd,NULL,0,0,rc.right,rc.bottom,SWP_NOMOVE);

          wParam = (WPARAM)iDlgIconId;

PutIconsInList:
          if (!GetDlgItemText(hwnd, IDD_NAME, (LPTSTR)szPathField, CharSizeOf(szPathField))) {
              szPathField[0] = TEXT('\0');
          }

	       wParam = (WPARAM)SetCursor(LoadCursor(NULL, IDC_WAIT));
	       ShowCursor(TRUE);
	       SendDlgItemMessage(hwnd, IDD_ICON, LB_RESETCONTENT, 0, 0L);

          lstrcpy(szExpanded, szPathField);
          if (!IconFileExists(hwnd, (HCURSOR)wParam, szExpanded)) {
              if (fFirstPass) {
                  /* Icon File doesn't exist, use progman. */
                  fFirstPass = FALSE;    // Only do this bit once.
                  GetModuleFileName(hAppInstance, (LPTSTR)szPathField, CharSizeOf(szPathField));
	               SetDlgItemText(hwnd, IDD_NAME, (LPTSTR)szPathField);
                  lstrcpy(szExpanded, szPathField);
              }
              else {
                  ShowCursor(FALSE);
                  SetCursor((HCURSOR)wParam);
                  break;
              }
          }

          if (hIconList) {
              FreeIconList(hIconList, -1);
              hIconList = NULL;
          }
          cIcons = (INT)((DWORD_PTR)ExtractIcon(hAppInstance, szExpanded, (UINT)-1));

          if (!cIcons) {
              if (fFirstPass) {
                  TCHAR szFilename[MAXITEMPATHLEN+1];

                  fFirstPass = FALSE;  // Only do this bit once.
                  ShowCursor(FALSE);
                  SetCursor((HCURSOR)wParam);
                  MyMessageBox(hwnd, IDS_NOICONSTITLE, IDS_NOICONSMSG1, NULL, MB_OK | MB_ICONEXCLAMATION);
                  /*
                   * No icons here - change the path do somewhere where we
                   * know there are icons.
                   * Get the path to progman.
                   */
                  GetModuleFileName(hAppInstance, (LPTSTR)szPathField, CharSizeOf(szPathField));
                  GetFilenameFromPath((LPTSTR)szPathField, szFilename);
                  SetDlgItemText(hwnd, IDD_NAME, szFilename);
                  goto PutIconsInList;
              }

              ShowCursor(FALSE);
              SetCursor((HCURSOR) wParam);
              MyMessageBox(hwnd, IDS_NOICONSTITLE, IDS_NOICONSMSG, NULL, MB_OK | MB_ICONEXCLAMATION);
              break;
          }

          SendDlgItemMessage(hwnd,IDD_ICON,WM_SETREDRAW,FALSE,0L);

          // Get shell.dll to return a list of icons.
          if (hIconList = InternalExtractIconList(hAppInstance, szExpanded, &cIcons)) {
              if (lpIconList = (LPMYICONINFO)GlobalLock(hIconList)) {
                  for (i = 0; i < cIcons; i++) {
                      if (!(lpIconList+i)->hIcon) {
                          cIcons = i;
                          break;
                      }
                      SendDlgItemMessage(hwnd,IDD_ICON,LB_ADDSTRING,0,
                                     (LPARAM)((lpIconList+i)->hIcon));
                      if ((lpIconList+i)->iIconId == iDlgIconId)
                          iIconSelected = i;
                  }
                  GlobalUnlock(hIconList);
              }
              else {
                  cIcons = 0;
              }
          }
          else {
              cIcons = 0;
          }

          if (SendDlgItemMessage(hwnd,IDD_ICON,LB_SETCURSEL,(WPARAM)iIconSelected,0L)
              == LB_ERR)
            {
              // select the first.
              SendDlgItemMessage(hwnd,IDD_ICON,LB_SETCURSEL,0,0L);
            }

          SendDlgItemMessage(hwnd,IDD_ICON,WM_SETREDRAW,TRUE,0L);
          InvalidateRect(GetDlgItem(hwnd,IDD_ICON),NULL,TRUE);

          ShowCursor(FALSE);
          SetCursor((HCURSOR)wParam);
          break;
      }

      case WM_DRAWITEM:
          #define lpdi ((DRAWITEMSTRUCT FAR *)lParam)

          if ((HANDLE)lpdi->itemData == (HANDLE)NULL)
              break;
          InflateRect(&lpdi->rcItem,-4,0);

          if (lpdi->itemState & ODS_SELECTED)
              SetBkColor(lpdi->hDC,GetSysColor(COLOR_HIGHLIGHT));
          else
              SetBkColor(lpdi->hDC,GetSysColor(COLOR_WINDOW));

          /* repaint the selection state
           */
          ExtTextOut(lpdi->hDC,0,0,ETO_OPAQUE,&lpdi->rcItem,NULL,0,NULL);

          /* draw the icon
           */
          DrawIcon(lpdi->hDC,
                   lpdi->rcItem.left+2,
                   lpdi->rcItem.top+2,
                   (HICON) lpdi->itemData);

          /* if it has the focus, draw the focus
           */
#ifdef NOTINUSER
          if (lpdi->itemState & ODS_FOCUS)
              DrawFocusRect(lpdi->hDC,&lpdi->rcItem);
#endif
          #undef lpdi
          break;

      case WM_MEASUREITEM:
          #define lpmi ((MEASUREITEMSTRUCT FAR *)lParam)

          lpmi->itemWidth = (WORD)(GetSystemMetrics(SM_CXICON) + 12);
          lpmi->itemHeight = (WORD)(GetSystemMetrics(SM_CYICON) + 4);

          #undef lpmi
          break;

      case WM_COMMAND:
          switch(GET_WM_COMMAND_ID(wParam, lParam)){
          case IDD_HELP:
              goto DoHelp;

	      case IDD_BROWSE:
              if (BrowseOK(hwnd))
                  goto PutIconsInList;
              else
                  break;

          case IDD_NAME:
              if (!GetDlgItemText(hwnd, IDD_NAME, (LPTSTR)szMessage, MAXITEMPATHLEN+1)) {
                  szMessage[0] = TEXT('\0');
              }

              /* Did any thing change since we hit 'Next' last? */
              if (lstrcmpi(szMessage, szPathField)) {
                  SendDlgItemMessage(hwnd,IDD_ICON,LB_SETCURSEL,(WPARAM)-1,0L);
              }
              break;

          case IDD_ICON:
              GetDlgItemText(hwnd, IDD_NAME, (LPTSTR)szMessage, MAXITEMPATHLEN+1);

              /* Did any thing change since we hit 'Next' last? */
              if (lstrcmpi(szMessage, szPathField)) {
                  lstrcpy(szPathField, szMessage);
                  wParam = MAKELONG(0, HIWORD(wParam));
                  goto PutIconsInList;
              }

              if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
                  break;
              /*** FALL THRU on double click ***/

          case IDOK:
              if(!GetDlgItemText(hwnd, IDD_NAME, szMessage, MAXITEMPATHLEN+1))
                 goto PutIconsInList;

//#ifdef JAPAN
//              if (CheckPortName(hwnd,szMessage))
//                  break;
//#endif

              /* Did any thing change since we hit 'Next' last? */
              if (lstrcmpi(szMessage, szPathField)) {
                  lstrcpy(szPathField, szMessage);
                  wParam = MAKELONG(0, HIWORD(wParam));
                  goto PutIconsInList;
              }
              else {
                  iIconSelected = (int)SendDlgItemMessage(hwnd,IDD_ICON,
                                                          LB_GETCURSEL,0,0L);
                  if (iIconSelected < 0)
                      iIconSelected = 0;
              }

              if (hDlgIcon)
                  hIconGlobal = hDlgIcon;
              if (cIcons > 0) {  /* if there is at least one icon */
                  hDlgIcon = (lpIconList+iIconSelected)->hIcon;
                  iDlgIconId = (lpIconList+iIconSelected)->iIconId;
                  iDlgIconIndex = iIconSelected;
                  GlobalUnlock(hIconList);
                  FreeIconList(hIconList,iIconSelected);
                  hIconList = NULL;
              }
              else {
                  hDlgIcon = NULL;
                  iDlgIconId = 0;
                  iDlgIconIndex = 0;
              }
              lstrcpy(szIconPath, szPathField);

              EndDialog(hwnd, TRUE);
              break;

          case IDCANCEL:
              if (hIconList) {
                  FreeIconList(hIconList , -1);
                  hIconList = NULL;
              }
              EndDialog(hwnd, FALSE);
              break;

          default:
              return(FALSE);
          }
          break;

      default:

          if (uiMsg == uiHelpMessage || uiMsg == uiBrowseMessage) {
DoHelp:
              PMHelp(hwnd);

              return TRUE;
          } else
              return FALSE;
    }
  return(TRUE);
}


/*** GetRidOfIcon --
 *
 *
 *
 * VOID APIENTRY GetRidOfIcon(VOID)
 *
 * ENTRY -         VOID
 *
 * EXIT  -        VOID
 *
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID APIENTRY GetRidOfIcon(VOID)
{

    if (hDlgIcon && (hDlgIcon != hItemIcon) &&
                    (hDlgIcon != hProgmanIcon) &&
                    (hDlgIcon != hGroupIcon))
        DestroyIcon(hDlgIcon);
    hDlgIcon = NULL;
}

/*** GetCurrentIcon --
 *
 *
 *
 * HICON APIENTRY GetCurrentIcon(VOID)
 *
 * ENTRY -         VOID
 *
 * EXIT  -        HICON
 *
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

HICON APIENTRY GetCurrentIcon(VOID)
{
  TCHAR szExpanded[MAXITEMPATHLEN+1];
  HANDLE hModule;
  HANDLE h;
  PBYTE p;
  int cb;


// BUG BUG this was just added and I don't know if it's OK
  if (hDlgIcon) {
      DestroyIcon(hDlgIcon);
      hDlgIcon = NULL;
  }
  lstrcpy(szExpanded, szIconPath);
  DoEnvironmentSubst(szExpanded, CharSizeOf(szExpanded));
  StripArgs(szExpanded);
  TagExtension(szExpanded, sizeof(szExpanded));
  SheRemoveQuotes(szExpanded);

  if (hModule = LoadLibrary(szExpanded)) {
      h = FindResource(hModule, (LPTSTR) MAKEINTRESOURCE(iDlgIconId), (LPTSTR) MAKEINTRESOURCE(RT_ICON));
      if (h) {
        cb = SizeofResource(hModule, h);
        h = LoadResource(hModule, h);
        p = LockResource(h);
        hDlgIcon = CreateIconFromResource(p, cb, TRUE, 0x00030000);
        UnlockResource(h);
        FreeResource(h);
      }
      FreeLibrary(hModule);
      if (hDlgIcon) {
         return(hDlgIcon);
      }
  }
  else {
      hDlgIcon = ExtractIcon(hAppInstance, szExpanded, (UINT)iDlgIconId);
      if (hDlgIcon && hDlgIcon != (HANDLE)1) {
         return(hDlgIcon);
      }
  }

  iDlgIconId = 0;
  if (hDlgIcon == NULL) {
      if (h = FindResource(hAppInstance, (LPTSTR) MAKEINTRESOURCE(ITEMICON), RT_GROUP_ICON)) {
          h = LoadResource(hAppInstance, h);
          p = LockResource(h);
          iDlgIconId = (WORD)LookupIconIdFromDirectory(p, TRUE);
          iDlgIconIndex = ITEMICONINDEX;
          UnlockResource(h);
          FreeResource(h);
      }
  }
  if (hDlgIcon == (HANDLE)1) {
      if (h = FindResource(hAppInstance, (LPTSTR) MAKEINTRESOURCE(DOSAPPICON), RT_GROUP_ICON)) {
          h = LoadResource(hAppInstance, h);
          p = LockResource(h);
          iDlgIconId = (WORD)LookupIconIdFromDirectory(p, TRUE);
          iDlgIconIndex = DOSAPPICONINDEX;
          UnlockResource(h);
          FreeResource(h);
      }
  }

  h = FindResource(hAppInstance, (LPTSTR) MAKEINTRESOURCE(iDlgIconId), (LPTSTR) MAKEINTRESOURCE(RT_ICON));
  if (h) {
      cb = (WORD)SizeofResource(hAppInstance, h);
      h = LoadResource(hAppInstance, h);
      p = LockResource(h);
      hDlgIcon = CreateIconFromResource(p, cb, TRUE, 0x00030000);
      UnlockResource(h);
      FreeResource(h);
  }

  if (hModule)
      FreeLibrary(hModule);

  return(hDlgIcon);
}


/*--------------------------------------------------------------------------*/
/*									                                        */
/*  CheckHotKeyInUse() - Return of TRUE means no-dup or user says OK anyway.*/
/*      fNewItem is TRUE if your about to create a new item, FALSE if your  */
/*      just editing an old one.                                            */
/*									                                        */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL CheckHotKeyInUse(WORD wHotKey, BOOL fNewItem)
{
    PGROUP pGroup;
    PITEM pItem;
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    TCHAR szTemp1[64];
    TCHAR szTemp2[MAXMESSAGELEN+1];
    int ret;

    for (pGroup = pFirstGroup; pGroup; pGroup = pGroup->pNext) {
        for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext) {
            /*
             * If we're editing an existing item in then ignore the one
             * we're editing (the first item in the current group).
             */
            if (!fNewItem && pGroup == pCurrentGroup && pItem == pCurrentGroup->pItems)
                continue;

            if (wHotKey && (wHotKey == GroupFlag(pGroup,pItem,(WORD)ID_HOTKEY)))
                goto Duplicate;
        }
    }

    return TRUE;

Duplicate:
    if (!(lpgd = LockGroup(pGroup->hwnd)))
        return TRUE;      // Crash out without error.

    lpid = ITEM(lpgd, pItem->iItem);

    if (!LoadString(hAppInstance, IDS_ITEMINGROUP, szTemp1, CharSizeOf(szTemp1)))
        return TRUE;

    wsprintf(szTemp2, szTemp1, (LPTSTR) PTR(lpgd, lpid->pName),  (LPTSTR) PTR(lpgd, lpgd->pName));

    ret  = MyMessageBox(hwndProgman,
                        IDS_DUPHOTKEYTTL, IDS_DUPHOTKEYMSG, szTemp2,
                        MB_OKCANCEL|MB_DEFBUTTON2|MB_ICONEXCLAMATION);
    UnlockGroup(pGroup->hwnd);
    if (ret == IDOK)
        return TRUE;
    else
        return FALSE;
}

/* NOTE:
 *         'szIconPath' has the icon's path.
 *         'iDlgIconId' is set to the icon's id.
 *         'iDlgIconIndex' is set to the icon's index.
 *
 *         'szNameField' is used as a temporary variable.
 *         'szPathField' is used as a temporary variable.
 */

/*** NewItemDlgProc --         Dialog Procedure
 *
 *
 *
 * INT_PTR APIENTRY NewItemDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
 *
 * ENTRY -         HWND hhwnd                 - handle to dialog box.
 *                 UINT uiMsg                 - message to be acted upon.
 *                 WPARAM wParam              - value specific to uiMsg.
 *                 LPARAM lParam              - value specific to uiMsg.
 *
 * EXIT  -           True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */
INT_PTR APIENTRY NewItemDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
static BOOL bIsWOWApp = FALSE;
  DWORD dwThreadID;
  HANDLE hThread;
  HWND  hIcon;
  DWORD dwBinaryInfo, cbData, dwDataType;
  BOOL  bDoit;



  switch (uiMsg) {
      case WM_INITDIALOG:
          if (GroupFull(pCurrentGroup)) {
              EndDialog(hwnd, FALSE);
              break;
          }

          SendDlgItemMessage(hwnd, IDD_NAME, EM_LIMITTEXT, MAXITEMNAMELEN, 0L);
          SendDlgItemMessage(hwnd, IDD_COMMAND, EM_LIMITTEXT, MAXITEMPATHLEN, 0L);
          SendDlgItemMessage(hwnd, IDD_DIR, EM_LIMITTEXT, MAXITEMPATHLEN, 0L);
          szNameField[0] = TEXT('\0');
          szPathField[0] = TEXT('\0');
          szDirField[0] = TEXT('\0');
          szIconPath[0] = TEXT('\0');
          iDlgIconId = 0;
          iDlgIconIndex = 0;
          if (hDlgIcon)
              DestroyIcon(hDlgIcon);
          hDlgIcon = NULL;
          EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);
          EnableWindow(GetDlgItem(hwnd, IDD_ICON), FALSE);
          CheckDlgButton(hwnd, IDD_NEWVDM, 1);
          EnableWindow(GetDlgItem(hwnd, IDD_NEWVDM), FALSE);
          fNewIcon = FALSE;

          //
          //  Set the inital state for the thread which checks the binary
          //  type.
          //

          //
          // Query if the binary type checking is enabled.
          //

          cbData = sizeof(dwBinaryInfo);
          if (RegQueryValueEx(hkeyPMSettings, szCheckBinaryType, 0, &dwDataType,
                       (LPBYTE)&dwBinaryInfo, &cbData) == ERROR_SUCCESS) {
              bCheckBinaryType = (BOOL) dwBinaryInfo;
          } else {
              bCheckBinaryType = BINARY_TYPE_DEFAULT;
          }

          //
          // Query the binary type checking timeout value.
          //

          cbData = sizeof(dwBinaryInfo);
          if (RegQueryValueEx(hkeyPMSettings, szCheckBinaryTimeout, 0, &dwDataType,
                       (LPBYTE)&dwBinaryInfo, &cbData) == ERROR_SUCCESS) {
              uiCheckBinaryTimeout = (UINT) dwBinaryInfo;
          } else {
              uiCheckBinaryTimeout = BINARY_TIMEOUT_DEFAULT;
          }

          //
          // Create the worker thread, and the signal event.  If appropriate.
          //

          if (bCheckBinaryType) {
              hCheckBinaryEvent = CreateEvent (NULL, FALSE, FALSE,
                                               CHECK_BINARY_EVENT_NAME);

              hThread = CreateThread (NULL, 0,
                                     (LPTHREAD_START_ROUTINE) CheckBinaryThread,
                                     (LPVOID) hwnd, 0, &dwThreadID);

              bCheckBinaryDirtyFlag = FALSE;
          }

          if (!bCheckBinaryType || !hThread || !hCheckBinaryEvent) {
              //
              // If this statement is true, either binary type checking 
              // is disabled or we failed to create the event or the thread.
              // In this case, enable the separate memory checkbox, and let
              // the user decide on his own.
              //

              CheckDlgButton(hwnd, IDD_NEWVDM, 0);
              EnableWindow(GetDlgItem(hwnd,IDD_NEWVDM), TRUE);

              //
              // Clean up either item that succeeded
              //
              if (hCheckBinaryEvent) {
                  CloseHandle (hCheckBinaryEvent);
              }

              if (hThread) {
                  TerminateThread (hThread, 0);
              }

              //
              // Setting this variable to NULL will prevent the second
              // thread from trying to check the binary type.
              //

              hCheckBinaryEvent = NULL;
          }

          break;

      case WM_TIMER:
          if (hCheckBinaryEvent && bCheckBinaryDirtyFlag) {
              bCheckBinaryDirtyFlag = FALSE;
              SetEvent (hCheckBinaryEvent);
          }
          break;

      case WM_COMMAND:
          switch(GET_WM_COMMAND_ID(wParam, lParam)) {
          case IDD_HELP:
              goto DoHelp;

          case IDD_COMMAND:
          {
              if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_UPDATE)
                  break;

              if (bCheckBinaryType) {
                  bCheckBinaryDirtyFlag = TRUE;
                  SetTimer (hwnd, CHECK_BINARY_ID, uiCheckBinaryTimeout, NULL);
              }
              bDoit = (GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1) > 0);
              EnableWindow(GetDlgItem(hwnd, IDOK), bDoit);
              if ( (hIcon = GetDlgItem(hwnd, IDD_ICON)) ) {
                  EnableWindow(hIcon, bDoit);
              }

              break;
          }

          case IDD_BROWSE:
          {
              DWORD dwSave = dwContext;
              TCHAR szPathField[MAXITEMPATHLEN+1];

              dwContext = IDH_PROPBROWSEDLG;
              GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1);
              GetDlgItemText(hwnd, IDD_DIR, szDirField, MAXITEMPATHLEN+1);
              /* Get PathField using browser dlg. */
              if (GetFileNameFromBrowse(hwnd, szPathField, sizeof(szPathField),
                               szDirField, IDS_PROPERTIESPROGS, TEXT("exe"))) {
                  // OK.
                  //
                  // if filename or directory have spaces, put the path
                  // between quotes.
                  //
                  CheckEscapes(szPathField, MAXITEMPATHLEN+1);

                  SetDlgItemText(hwnd, IDD_COMMAND, szPathField);
                  EnableWindow(GetDlgItem(hwnd, IDOK), TRUE);
                  EnableWindow(GetDlgItem(hwnd, IDD_ICON), TRUE);
                  /* Set default button to OK. */
                  PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hwnd, IDOK), TRUE);
              }
              dwContext = dwSave;
              break;
          }

          case IDD_ICON:
          {
              TCHAR szTempField[MAXITEMPATHLEN+1];

              GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1);

//#ifdef JAPAN
//              if (CheckPortName(hwnd,szPathField))
//                  break;
//#endif

              GetDlgItemText(hwnd, IDD_DIR, szDirField, MAXITEMPATHLEN+1);

              // Expand env variables.
              DoEnvironmentSubst(szPathField, MAXITEMPATHLEN+1)
                && DoEnvironmentSubst(szDirField, MAXITEMPATHLEN+1);

              // Get a full path to the icon.
              StripArgs(szPathField);
	          //
	          // Change to original directory in case the use entered a
	          // relative path.
	          //
	          SetCurrentDirectory(szOriginalDirectory);
              FindExecutable(szPathField, szDirField, szTempField);
              SetCurrentDirectory(szWindowsDirectory);

              /* Discard the old Icon Path. */
              lstrcpy(szIconPath, szTempField);
              iDlgIconId = 0;
              iDlgIconIndex = 0;

              if (fNewIcon = MyDialogBox(ICONDLG, hwnd, IconDlgProc)) {
                  SendDlgItemMessage(hwnd, IDD_CURICON, STM_SETICON, (WPARAM)hDlgIcon, 0L);
                  if (hIconGlobal) {
                      DestroyIcon(hIconGlobal);
                      hIconGlobal = NULL;
                  }
              }
              else { /* Cancel/ESC was selected, reset Icon Path to NULL. */
                  *szIconPath = TEXT('\0');
                  iDlgIconId = 0;
                  iDlgIconIndex = 0;
              }

              break;
          }

          case IDOK:
          {
              WORD hk;
              TCHAR szHackField[MAXITEMPATHLEN + 1];
	          DWORD dwRet;
	          DWORD dwFlags = CI_ACTIVATE | CI_SET_DOS_FULLSCRN;

              if(!GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN + 1)) {
                 szPathField[0] = TEXT('\0');
                 break;
              }

              //RemoveLeadingSpaces(szPathField);
              hk = (WORD) SendDlgItemMessage(hwnd,IDD_HOTKEY, WM_GETHOTKEY,0,0L);
              if (!CheckHotKeyInUse(hk, TRUE))
                  break;

              GetDlgItemText(hwnd, IDD_DIR, szDirField, MAXITEMPATHLEN+1);

              //RemoveLeadingSpaces(szDirField)
              /* Expand env variables. */
              DoEnvironmentSubst(szPathField, MAXITEMPATHLEN+1);
              DoEnvironmentSubst(szDirField, MAXITEMPATHLEN+1);

              /* Now remove the arguments from the command line. */
              StripArgs(szPathField);

              dwRet = ValidatePath(hwnd, szPathField, szDirField, szHackField);
              if (dwRet == PATH_INVALID) {
                  break;
	          }
	          else if (dwRet == PATH_INVALID_OK) {
		          dwFlags |= CI_NO_ASSOCIATION;
              }

              /* Special case DOS apps. */
              HandleDosApps(szHackField);


              /* If the user hasn't supplied a description then build one. */
              if (!GetDlgItemText(hwnd, IDD_NAME, szNameField, MAXITEMNAMELEN+1)) {
                  szNameField[0] = TEXT('\0');
              }

              /* Get the original command line with arguments. */
              GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1);

//#ifdef JAPAN
//              if (CheckPortName(hwnd,szPathField))
//                  break;
//#endif

              /* Get original (unexpanded) directory. */
              if (!GetDlgItemText(hwnd, IDD_DIR, szDirField, MAXITEMPATHLEN+1)) {
                  szDirField[0] = TEXT('\0');
              } else {
                  LPTSTR lpEnd;
                  TCHAR  chT;

                  // Remove trailing spaces (inside of quote if applicable)
                  lpEnd = szDirField + lstrlen (szDirField) - 1;
                  chT = *lpEnd;

                  if ( (chT == TEXT('\"')) || (chT == TEXT(' ')) ) {
                     // MarkTa fix for spaces at the end of a filename
                     // Remove the spaces by moving the last character forward.
                     while (*(lpEnd-1) == TEXT(' '))
                         lpEnd--;

                     *lpEnd = chT;
                     *(lpEnd+1) = TEXT ('\0');

                     // In case the character we saved was a space, we can
                     // NULL terminate it because now we know the next character
                     // to the left is valid, and the character to the right is
                     // already NULL.

                     if (*lpEnd == TEXT(' '))
                       *lpEnd = TEXT('\0');
                  }
              }

		      GetStuffFromPIF(szPathField, szNameField, szDirField);

              if (!*szNameField) {
                  BuildDescription(szNameField, szPathField);
              }

              /* If there's no default directory then add one. */
              if (!*szDirField) {
                  GetDirectoryFromPath(szPathField, szDirField);
              }

              if (!InQuotes(szDirField)) {

                    //
                    // if szDirField needs quotes and the work dir is too
                    // long than we need to truncate it.
                    //
                    if (lstrlen(szDirField) >= MAXITEMPATHLEN-2) {
                        TCHAR chT;

                        chT = szDirField[MAXITEMPATHLEN-2];
                        szDirField[MAXITEMPATHLEN-2] = 0;
                        CheckEscapes(szDirField, MAXITEMPATHLEN+1);
                        if (*szDirField != TEXT('"')) {
                            szDirField[MAXITEMPATHLEN-2] = chT;
                        }
                    }
                    else {
                        CheckEscapes(szDirField, MAXITEMPATHLEN+1);
                    }
              }

              if (IsWindowEnabled(GetDlgItem(hwnd, IDD_NEWVDM)) &&
                                  IsDlgButtonChecked(hwnd, IDD_NEWVDM)) {
                  dwFlags |= CI_SEPARATE_VDM;
              }

              /* Create new item using UNICODE strings. */
              CreateNewItem(pCurrentGroup->hwnd,
                            szNameField,
                            szPathField,
                            szIconPath,
                            szDirField,
                            hk,
                            (BOOL)IsDlgButtonChecked(hwnd, IDD_LOAD),
                            (WORD)iDlgIconId,
                            (WORD)iDlgIconIndex,
                            hDlgIcon,
                            NULL,
                            dwFlags);

              }


              // Update scroll bars for new item
              if ((bAutoArrange) && (!bAutoArranging))
                  ArrangeItems(pCurrentGroup->hwnd);
              else if (!bAutoArranging)
                  CalcGroupScrolls(pCurrentGroup->hwnd);

              // fall through...

          case IDCANCEL:

              if (bCheckBinaryType) {
                  //
                  // Setting this variable to false, and signaling the event
                  // will cause the binary checking thread to terminate.
                  //

                  bCheckBinaryType = FALSE;
                  SetEvent (hCheckBinaryEvent);
                  KillTimer (hwnd, CHECK_BINARY_ID);
              }

              EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam) == IDOK);
              GetRidOfIcon();
              break;

          default:
              return(FALSE);
          }
          break;

      default:

          if (uiMsg == uiHelpMessage || uiMsg == uiBrowseMessage) {
DoHelp:
              PMHelp(hwnd);

              return TRUE;
          } else
              return FALSE;
    }
    UNREFERENCED_PARAMETER(lParam);
    return(TRUE);
}


/*** NewGroupDlgProc --         Dialog Procedure
 *
 *
 *
 * INT_PTR APIENTRY NewGroupDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
 *
 * ENTRY -         HWND hhwnd                 - handle to dialog box.
 *                        UINT uiMsg                  - message to be acted upon.
 *                        DWORD wParam        - value specific to uiMsg.
 *                        LPARAM lParam       - value specific to uiMsg.
 *
 * EXIT  -           True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT_PTR APIENTRY NewGroupDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bDoit;
    HWND hwndGroup;

    switch (uiMsg) {

    case WM_INITDIALOG:
        if (wNewSelection == TYPE_COMMONGROUP) {
            TCHAR szCommonGroupTitle[64];

            if (LoadString(hAppInstance, IDS_COMMONGROUPPROP,
                           szCommonGroupTitle, CharSizeOf(szCommonGroupTitle))) {
                SetWindowText(hwnd, szCommonGroupTitle);
            }
        }
        SendDlgItemMessage(hwnd, IDD_NAME, EM_LIMITTEXT, MAXGROUPNAMELEN, 0L);
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam)) {
        HCURSOR hCursor;

        case IDD_NAME:
        case IDD_PATH:
            /* Allow OK if either of the two fields have anything in them. */
            bDoit = (GetDlgItemText(hwnd, IDD_NAME, szPathField, CharSizeOf(szPathField)) > 0);
            EnableWindow(GetDlgItem(hwnd, IDOK), bDoit);
		    break;

        case IDD_HELP:
            goto DoHelp;

        case IDOK:
            if(!GetDlgItemText(hwnd, IDD_NAME, szNameField, MAXITEMNAMELEN + 1)) {
               szNameField[0] = TEXT('\0');
               break;
            }

            hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            ShowCursor(TRUE);

		      hwndGroup = CreateNewGroup(szNameField, (wNewSelection == TYPE_COMMONGROUP));

            ShowCursor(FALSE);
            SetCursor(hCursor);
            if (hwndGroup) {
                EndDialog(hwnd, TRUE);
            }
            break;

        case IDCANCEL:
            EndDialog(hwnd, FALSE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        if (uiMsg == uiHelpMessage) {
DoHelp:
            PMHelp(hwnd);

            return TRUE;
        } else {
            return FALSE;
        }
    }

    return TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  EditBrowseOK() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/
BOOL NEAR PASCAL EditBrowseOK(HWND hDlg)
{
    DWORD dwSave = dwContext;
    TCHAR szPathField[MAXITEMPATHLEN+1];
    BOOL ret;

    dwContext = IDH_PROPBROWSEDLG;
    GetDlgItemText(hDlg, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1);
    GetDlgItemText(hDlg, IDD_DIR, szDirField, MAXITEMPATHLEN+1);
    /* Get PathField using browser dlg. */
    if (GetFileNameFromBrowse(hDlg, szPathField,sizeof(szPathField) ,
                              szDirField, IDS_PROPERTIESPROGS, TEXT("exe"))) {
	    /* OK. */
        //
        // if filename or directory have spaces, put the path
        // between quotes.
        //
        CheckEscapes(szPathField, MAXITEMPATHLEN+1);

	    SetDlgItemText(hDlg, IDD_COMMAND, szPathField);
	    EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
	    EnableWindow(GetDlgItem(hDlg, IDD_ICON), TRUE);
	    /* Set default button to OK. */
        PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
        ret = TRUE;
	}
    else
        ret = FALSE;
    dwContext = dwSave;
    return ret;
}

/*** EditItemDlgProc --         Dialog Procedure
 *
 *
 *
 * INT_PTR APIENTRY EditItemDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
 *
 * ENTRY -         HWND hhwnd                 - handle to dialog box.
 *                        UINT uiMsg                  - message to be acted upon.
 *                 WPARAM wParam              - value specific to uiMsg.
 *                 LPARAM lParam              - value specific to uiMsg.
 *
 * EXIT  -           True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

/* NOTE:
 *         'szIconPath' has the icon's path.
 *         'iDlgIconId' is set to the icon's id.
 *         'iDlgIconIndex' is set to the icon's index.
 *
 *         'szNameField' is used as a temporary variable.
 *         'szPathField' is used as a temporary variable.
 */
INT_PTR APIENTRY EditItemDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPITEMDEF lpid;
    LPGROUPDEF lpgd;
    TCHAR szTempField[MAXITEMPATHLEN + 1];
    DWORD dwFlags = CI_ACTIVATE;
    DWORD dwBinaryType;
    TCHAR szFullPath[MAXITEMPATHLEN+1] ;
    LPTSTR FilePart ;
static    BOOL bIsWOWApp = FALSE;
static    WORD wHotKey;
static    TCHAR szDescription[MAXITEMNAMELEN + 1];
    DWORD dwThreadID;
    HANDLE hThread;
    HWND  hIcon;
    DWORD dwBinaryInfo, cbData, dwDataType;
    BOOL  bDoit;


    switch (uiMsg) {

    case WM_INITDIALOG:
        /*
         * Get current item information.
         */
        pActiveGroup = pCurrentGroup;
        lpgd = (LPGROUPDEF)GlobalLock(pActiveGroup->hGroup);
        lpid = LockItem(pActiveGroup,pActiveGroup->pItems);
        if (lpid == 0L)
            goto EditDlgExit;
        fNewIcon = FALSE;

        SendDlgItemMessage(hwnd, IDD_NAME, EM_LIMITTEXT, MAXITEMNAMELEN, 0L);
        SetDlgItemText(hwnd, IDD_NAME, (LPTSTR) PTR(lpgd, lpid->pName));
	    lstrcpy(szDescription, (LPTSTR) PTR(lpgd, lpid->pName));

        GetItemCommand(pActiveGroup, pActiveGroup->pItems, szPathField, szDirField);

        /* Keep a copy of what the old item was refering to.
         * A full expanded OEM path to the executable
         */
        DoEnvironmentSubst(szPathField, MAXITEMPATHLEN+1);
        DoEnvironmentSubst(szDirField, MAXITEMPATHLEN+1);
        StripArgs(szPathField);
        // Find exe will toast on ansi strings.
	    //
	    // Change to original Directory in case the user entered a relative path
        //
        //
	    SetCurrentDirectory(szOriginalDirectory);
        FindExecutable(szPathField, szDirField, szNameField);
	    SetCurrentDirectory(szWindowsDirectory);

        lstrcpy(szIconPath, (LPTSTR) PTR(lpgd, lpid->pIconPath));
        if (!*szIconPath) {
            /* use default icon path */
            lstrcpy(szIconPath, szNameField);
        }
        iDlgIconId = lpid->iIcon;
        iDlgIconIndex = lpid->wIconIndex;

        TagExtension(szPathField, sizeof(szPathField));
        SheRemoveQuotes (szPathField);
        if (SearchPath(NULL,
                        szPathField,
                        NULL,
                        MAXITEMPATHLEN+1,
                        szFullPath,
                        &FilePart) &&
            GetBinaryType(szFullPath, &dwBinaryType) &&
                                  dwBinaryType == SCS_WOW_BINARY) {
                bIsWOWApp = TRUE;
                if (GroupFlag(pActiveGroup,pActiveGroup->pItems,(WORD)ID_NEWVDM)) {
                    CheckDlgButton(hwnd, IDD_NEWVDM, 1);
                }
        }
        else {
            CheckDlgButton(hwnd, IDD_NEWVDM, 1);
            EnableWindow(GetDlgItem(hwnd, IDD_NEWVDM), FALSE);
        }

        /* Re-get the fields so that the dlg is initialized with
         * the environment variables intact.
         */
        GetItemCommand(pActiveGroup,pActiveGroup->pItems,szPathField,szDirField);

        SendDlgItemMessage(hwnd, IDD_COMMAND, EM_LIMITTEXT, MAXITEMPATHLEN, 0L);
        SetDlgItemText(hwnd, IDD_COMMAND, szPathField);

        SendDlgItemMessage(hwnd, IDD_DIR, EM_LIMITTEXT, MAXITEMPATHLEN, 0L);
        SetDlgItemText(hwnd, IDD_DIR, szDirField);

        if (GroupFlag(pActiveGroup,pActiveGroup->pItems,(WORD)ID_MINIMIZE))
            CheckDlgButton(hwnd, IDD_LOAD, TRUE);

        SendDlgItemMessage(hwnd,IDD_HOTKEY,WM_SETHOTKEY,
                           (WPARAM)GroupFlag(pActiveGroup,pActiveGroup->pItems,(WORD)ID_HOTKEY),
                           0L);

        GetCurrentIcon();        // use szIconPath from above
        GlobalUnlock(pActiveGroup->hGroup);

        UnlockGroup(pActiveGroup->hwnd);
        SendDlgItemMessage(hwnd, IDD_CURICON, STM_SETICON, (WPARAM)hDlgIcon, 0L);

        if (pActiveGroup->fRO || dwEditLevel >= 4) {
            /* if readonly, we can only view... */
            EnableWindow(GetDlgItem(hwnd,IDOK), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_ICON), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_HOTKEY), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_NAME), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_DIR), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_LOAD), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_NEWVDM), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_COMMAND), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_BROWSE), FALSE);
        }
        else if (dwEditLevel == 3) {
            EnableWindow(GetDlgItem(hwnd,IDD_COMMAND), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_BROWSE), FALSE);
        }
        //
        //  Set the inital state for the thread which checks the binary
        //  type.
        //

        //
        // Query if the binary type checking is enabled.
        //

        cbData = sizeof(dwBinaryInfo);
        if (RegQueryValueEx(hkeyPMSettings, szCheckBinaryType, 0, &dwDataType,
                     (LPBYTE)&dwBinaryInfo, &cbData) == ERROR_SUCCESS) {
            bCheckBinaryType = (BOOL) dwBinaryInfo;
        } else {
            bCheckBinaryType = BINARY_TYPE_DEFAULT;
        }

        //
        // Query the binary type checking timeout value.
        //

        cbData = sizeof(dwBinaryInfo);
        if (RegQueryValueEx(hkeyPMSettings, szCheckBinaryTimeout, 0, &dwDataType,
                     (LPBYTE)&dwBinaryInfo, &cbData) == ERROR_SUCCESS) {
            uiCheckBinaryTimeout = (UINT) dwBinaryInfo;
        } else {
            uiCheckBinaryTimeout = BINARY_TIMEOUT_DEFAULT;
        }

        //
        // Create the worker thread, and the signal event.  If appropriate.
        //

        if (bCheckBinaryType) {
            hCheckBinaryEvent = CreateEvent (NULL, FALSE, FALSE,
                                             CHECK_BINARY_EVENT_NAME);

            hThread = CreateThread (NULL, 0,
                                   (LPTHREAD_START_ROUTINE) CheckBinaryThread,
                                   (LPVOID) hwnd, 0, &dwThreadID);

            bCheckBinaryDirtyFlag = FALSE;
        }

        if (!hCheckBinaryEvent || !hThread || !bCheckBinaryType) {
            //
            // If this statement is true, either we failed to create
            // the event, the thread, or binary type checking is disabled.
            // In this case, enable the separate memory checkbox, and let
            // the user decide on his own.
            //

            CheckDlgButton(hwnd, IDD_NEWVDM, 0);
            EnableWindow(GetDlgItem(hwnd,IDD_NEWVDM), TRUE);

            //
            // Clean up either item that succeeded
            //
            if (hCheckBinaryEvent) {
                CloseHandle (hCheckBinaryEvent);
            }

            if (hThread) {
                TerminateThread (hThread, 0);
            }

            //
            // Setting this variable to NULL will prevent the second
            // thread from trying to check the binary type.
            //

            hCheckBinaryEvent = NULL;
        }

        break;

    case WM_TIMER:
        if (hCheckBinaryEvent && bCheckBinaryDirtyFlag) {
            bCheckBinaryDirtyFlag = FALSE;
            SetEvent (hCheckBinaryEvent);
        }
        break;


    case WM_COMMAND:
    {
        switch(GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDD_HELP:
            goto DoHelp;

        case IDD_COMMAND:
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_UPDATE)
                break;

            if (bCheckBinaryType) {
                bCheckBinaryDirtyFlag = TRUE;
                SetTimer (hwnd, CHECK_BINARY_ID, uiCheckBinaryTimeout, NULL);
            }
            bDoit = (GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1) > 0);
            EnableWindow(GetDlgItem(hwnd, IDOK), bDoit);
            if ( (hIcon = GetDlgItem(hwnd, IDD_ICON)) ) {
                EnableWindow(hIcon, bDoit);
            }

            break;
        }

        case IDD_BROWSE:
            EditBrowseOK(hwnd);
            break;

        case IDD_ICON:
        {
            LPITEMDEF lpid;

            if (!GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1))
                break;

//#ifdef JAPAN
//            if (CheckPortName(hwnd,szPathField))
//                break;
//#endif

            GetDlgItemText(hwnd, IDD_DIR, szDirField, MAXITEMPATHLEN+1);

            /* Expand env variables. */
            DoEnvironmentSubst(szPathField, MAXITEMPATHLEN+1)
              && DoEnvironmentSubst(szDirField, MAXITEMPATHLEN+1);

            /* Get a full path to the icon. */
            StripArgs(szPathField);
	        SetCurrentDirectory(szOriginalDirectory);
            FindExecutable(szPathField, szDirField, szTempField);
            SetCurrentDirectory(szWindowsDirectory);


            /*
             * If the icon path hasn't been explicitly set then
             * use a default one.
             */
            if (!fNewIcon) {
                /* Has the items path been changed? */
                if (lstrcmpi(szNameField, szTempField)) {
                    /* Yup, it's changed, discard the old Icon Path. */
                    lstrcpy(szIconPath, szTempField);
                    iDlgIconId = 0;
                    iDlgIconIndex = 0;
                }
                else {
                    /* The path hasn't changed so use the old icon path. */
                    lpid = LockItem(pActiveGroup,pActiveGroup->pItems);
                       // BUG BUG! should have LockItem unlock the group
                       // before returning. JohanneC 7/5/91
                    UnlockGroup(pActiveGroup->hwnd);
                    if (lpid == 0L)
                        goto EditDlgExit;
                    lpgd = LockGroup(pActiveGroup->hwnd);
                    lstrcpy(szIconPath, (LPTSTR) PTR(lpgd, lpid->pIconPath));
                    UnlockGroup(pActiveGroup->hwnd);
                }
            }

            /* Check if we have a default icon. */
            if (!*szIconPath) {
                /* Invalid path, use the executable's path. */
                lstrcpy(szIconPath, szTempField);
            }

            if (fNewIcon = MyDialogBox(ICONDLG, hwnd, IconDlgProc)) {
                // Set default button to OK.
                PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hwnd, IDOK), TRUE);
                SendDlgItemMessage(hwnd, IDD_CURICON, STM_SETICON, (WPARAM)hDlgIcon, 0L);
                if (hIconGlobal) {
                    DestroyIcon(hIconGlobal);
                    hIconGlobal = NULL;
                }
            }
            else {
                /* They hit cancel, get the old path back. */
                lpid = LockItem(pActiveGroup,pActiveGroup->pItems);
                    // BUG BUG! should have LockItem unlock the group
                    // before returning. JohanneC 7/5/91
                UnlockGroup(pActiveGroup->hwnd);
                if (lpid == 0L)
                    goto EditDlgExit;
                lpgd = LockGroup(pActiveGroup->hwnd);
                lstrcpy(szIconPath, (LPTSTR) PTR(lpgd, lpid->pIconPath));
                UnlockGroup(pActiveGroup->hwnd);
            }
            break;
        }

        case IDOK:
        {
            RECT rc;
            WORD hk;
            BOOL bARTmp; //AutoArrangeFlag
            BOOL fNewItem = FALSE;
	        DWORD dwRet;

            hk = (WORD) SendDlgItemMessage(hwnd,IDD_HOTKEY, WM_GETHOTKEY,0,0L);
            if (!CheckHotKeyInUse(hk, FALSE))
                break;

            /* Get the non-parm part of the new command line. */
            GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1);

//#ifdef JAPAN
//            if (CheckPortName(hwnd,szPathField))
//                break;
//#endif

            GetDlgItemText(hwnd, IDD_DIR, szDirField, MAXITEMPATHLEN+1);

            /* Expand env variables. */
            DoEnvironmentSubst(szPathField, MAXITEMPATHLEN+1)
                  && DoEnvironmentSubst(szDirField, MAXITEMPATHLEN+1);

            /* Remove arguments before validating path. */
            StripArgs(szPathField);

            dwRet = ValidatePath(hwnd, szPathField, szDirField, szTempField);
            if (dwRet == PATH_INVALID) {
                break;
	        }
	        else if (dwRet == PATH_INVALID_OK) {
		        dwFlags |= CI_NO_ASSOCIATION;
	        }


            if (bCheckBinaryType) {
                //
                // Setting this variable to false, and signaling the event
                // will cause the binary checking thread to terminate.
                //

                bCheckBinaryType = FALSE;
                SetEvent (hCheckBinaryEvent);
                KillTimer (hwnd, CHECK_BINARY_ID);
            }


            EndDialog(hwnd, TRUE);

            /*
             * If the item refers to a different exe then we need
             * to update a few things.
             */
            if (lstrcmpi(szNameField, szTempField)) {
                /* Things have changed. */
                if (!fNewIcon) {
                    /*
                     * The icon hasn't been expicitely set.
                     * So use the new exe path for
                     * the icon.
                     */
                    // lstrcpy(szIconPath, szPathField);
                    szIconPath[0] = TEXT('\0'); /* reset icon path */
                    iDlgIconId = 0;
                    iDlgIconIndex = 0;
                }
                fNewItem = TRUE;
                /* Check if the new thing is a DOS app. */
                HandleDosApps(szTempField);
            }
            else {
                /* test if icon has changed. If not, reset iconpath.*/
                if (!fNewIcon) {
                    lpgd = LockGroup(pActiveGroup->hwnd);
                    lpid = LockItem(pActiveGroup,pActiveGroup->pItems);
                    lstrcpy(szIconPath, (LPTSTR) PTR(lpgd, lpid->pIconPath));
                       // LockItem locks the group, must unlock
                       // after returning. JohanneC
                    UnlockGroup(pActiveGroup->hwnd);
                    UnlockGroup(pActiveGroup->hwnd);
                }
            }

            CopyRect(&rc, &pActiveGroup->pItems->rcIcon);

            /* Re-get the new command line. */
            GetDlgItemText(hwnd, IDD_COMMAND, szPathField, MAXITEMPATHLEN+1);

            /* Use unexpanded path for the item info. */
            if (!GetDlgItemText(hwnd, IDD_DIR, szDirField, MAXITEMPATHLEN+1)) {
                szDirField[0] = TEXT('\0');
            } else {
                LPTSTR lpEnd;
                TCHAR  chT;

                // Remove trailing spaces (inside of quote if applicable)
                lpEnd = szDirField + lstrlen (szDirField) - 1;
                chT = *lpEnd;

                if ( (chT == TEXT('\"')) || (chT == TEXT(' ')) ) {
                   // MarkTa fix for spaces at the end of a filename
                   // Remove the spaces by moving the last character forward.
                   while (*(lpEnd-1) == TEXT(' '))
                       lpEnd--;

                   *lpEnd = chT;
                   *(lpEnd+1) = TEXT ('\0');

                   // In case the character we saved was a space, we can
                   // NULL terminate it because now we know the next character
                   // to the left is valid, and the character to the right is
                   // already NULL.

                   if (*lpEnd == TEXT(' '))
                     *lpEnd = TEXT('\0');
                }
            }

            if (!InQuotes(szDirField)) {

                    //
                    // if szDirField needs quotes and the work dir is too
                    // long than we need to truncate it.
                    //
                    if (lstrlen(szDirField) >= MAXITEMPATHLEN-2) {
                        TCHAR chT;

                        chT = szDirField[MAXITEMPATHLEN-2];
                        szDirField[MAXITEMPATHLEN-2] = 0;
                        CheckEscapes(szDirField, MAXITEMPATHLEN+1);
                        if (*szDirField != TEXT('"')) {
                            szDirField[MAXITEMPATHLEN-2] = chT;
                        }
                    }
                    else {
                        CheckEscapes(szDirField, MAXITEMPATHLEN+1);
                    }
            }

            /* Check if the Desc line has been filled. */
            if (!GetDlgItemText(hwnd, IDD_NAME, szNameField, MAXITEMNAMELEN+1)) {
                BuildDescription(szNameField, szPathField);
                SetDlgItemText(hwnd, IDD_NAME, szNameField);
            }

            /*
             * Stop ARing for a mo because we're going to do a
             * delete and the an add and there's no point in doing
             * the auto arrange stuff twice.
             */
            bARTmp = bAutoArrange;
            bAutoArrange = FALSE;
            DeleteItem(pActiveGroup,pActiveGroup->pItems);
            bAutoArrange = bARTmp;
	        if (fNewItem || lstrcmpi(szDescription, szNameField)) {
		        dwFlags |= CI_SET_DOS_FULLSCRN;
	        }
            if (IsWindowEnabled(GetDlgItem(hwnd, IDD_NEWVDM)) &&
                                IsDlgButtonChecked(hwnd, IDD_NEWVDM)) {
                dwFlags |= CI_SEPARATE_VDM;
            }

            CreateNewItem(pActiveGroup->hwnd,
                          szNameField,
                          szPathField,
                          szIconPath,
                          szDirField,
                          hk,
                          (BOOL)IsDlgButtonChecked(hwnd, IDD_LOAD),
                          (WORD)iDlgIconId,
                          (WORD)iDlgIconIndex,
                          hDlgIcon,
                          (LPPOINT)&rc.left,
                          dwFlags);

            GetRidOfIcon();
            pActiveGroup = NULL;
            break;
        }

        case IDCANCEL:
EditDlgExit:
            if (bCheckBinaryType) {
                //
                // Setting this variable to false, and signaling the event
                // will cause the binary checking thread to terminate.
                //

                bCheckBinaryType = FALSE;
                SetEvent (hCheckBinaryEvent);
                KillTimer (hwnd, CHECK_BINARY_ID);
            }

            pActiveGroup = NULL;
            EndDialog(hwnd, FALSE);
            GetRidOfIcon();
            break;

        default:
            return(FALSE);
        }
        break;
    }

    default:

        if (uiMsg == uiHelpMessage || uiMsg == uiBrowseMessage) {
DoHelp:
            PMHelp(hwnd);
            return TRUE;
        } else
            return FALSE;
    }
    UNREFERENCED_PARAMETER(lParam);
    return(TRUE);
}


/*** EditGroupDlgProc --         Dialog Procedure
 *
 *
 *
 * INT_PTR APIENTRY EditGroupDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
 *
 * ENTRY -  HWND  hwnd          - handle to dialog box.
 *          UINT uiMsg           - message to be acted upon.
 *          WPARAM wParam       - value specific to uiMsg.
 *          LPARAM lParam       - value specific to uiMsg.
 *
 * EXIT  -  True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */
INT_PTR APIENTRY EditGroupDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPGROUPDEF lpgd;
    static TCHAR     szGroupName[MAXGROUPNAMELEN + 1];

    switch (uiMsg) {
    case WM_INITDIALOG:
        pActiveGroup = pCurrentGroup;

        lpgd = LockGroup(pActiveGroup->hwnd);

        if (lpgd == 0L) {
            EndDialog(hwnd, FALSE);
            break;
        }

        if (pActiveGroup->fCommon) {
            TCHAR szCommonGroupTitle[64];

            if (LoadString(hAppInstance, IDS_COMMONGROUPPROP,
                           szCommonGroupTitle, CharSizeOf(szCommonGroupTitle))) {
                SetWindowText(hwnd, szCommonGroupTitle);
            }
        }

        lstrcpy(szGroupName, (LPTSTR) PTR(lpgd, lpgd->pName));
        SetDlgItemText(hwnd, IDD_NAME, (LPTSTR) PTR(lpgd, lpgd->pName));
        UnlockGroup(pActiveGroup->hwnd);

        SendDlgItemMessage(hwnd, IDD_NAME, EM_LIMITTEXT, MAXGROUPNAMELEN, 0L);

        if (pActiveGroup->fRO || dwEditLevel >= 1) {
            EnableWindow(GetDlgItem(hwnd,IDOK), FALSE);
            EnableWindow(GetDlgItem(hwnd,IDD_NAME), FALSE);
        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDD_HELP:
            goto DoHelp;

        case IDOK:
        {
            INT err = 0;
#if 0
            HKEY hkey;
            HKEY hkeyGroups;
            TCHAR szKeyName[MAXGROUPNAMELEN + 1];
            PSECURITY_ATTRIBUTES pSecAttr;

            if (!hkeyProgramGroups || !hkeyPMGroups) {
                err = TRUE;
                goto Exit;
            }
#endif

            GetDlgItemText(hwnd, IDD_NAME, szNameField, MAXITEMNAMELEN+1);
            /* maybe should strip leading and trailing blanks? */
	    //
	    // If all spaces or null string do not change it, but if WIn3.1 does.
	    //

            if (lstrcmp(szGroupName, szNameField)) {

                ChangeGroupTitle(pActiveGroup->hwnd, szNameField, pActiveGroup->fCommon);
            }
#if 0
                //
                // stop handling of Program Groups key changes.
                //
                bHandleProgramGroupsEvent = FALSE;
                //
                // Determine if we're about to change the name of Personal
                // group and a Common group.
                //
                if (pActiveGroup->fCommon) {
                    hkeyGroups = hkeyCommonGroups;
                    pSecAttr = pAdminSecAttr;
                }
                else {
                    hkeyGroups = hkeyProgramGroups;
                    pSecAttr = pSecurityAttributes;
                }

                //
                // If the group name contains backslashes (\) remove them
                // from the key name. Can not have key names with backslash
                // in the registry.
                //
                lstrcpy(szKeyName, szNameField);
                RemoveBackslashFromKeyName(szKeyName);
                /* create a new key, and delete the old key */
                if (err = RegCreateKeyEx(hkeyGroups, szKeyName, 0, 0, 0,
                         DELETE | KEY_SET_VALUE | KEY_QUERY_VALUE | KEY_NOTIFY,
                         pSecAttr, &hkey, NULL)) {
                    goto Exit;
                }


                lpgd = (LPGROUPDEF)GlobalLock(pActiveGroup->hGroup);
                if (err = RegSetValueEx(hkey, NULL, 0, REG_BINARY, (LPTSTR)lpgd,
                                                      SizeofGroup(lpgd))) {
                    RegCloseKey(hkey);
                    goto Exit;
                }

                RegDeleteKey(hkeyGroups, pActiveGroup->lpKey);

                //
                // Now that it all worked, do the actually name change:
                // Change the group window title and the group key name.
                //
                ChangeGroupTitle(pActiveGroup->hwnd, szNameField, pActiveGroup->fCommon);

                LocalFree((HANDLE)pActiveGroup->lpKey);
                pActiveGroup->lpKey = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szKeyName) + 1));
                lstrcpy(pActiveGroup->lpKey, szKeyName);

                if (bSaveSettings) {
                    RegFlushKey(hkey);
                }
                RegCloseKey(hkey);

                if (!pActiveGroup->fCommon) {
                    WriteGroupsSection();
                }
            }
Exit:
            //
            // reset handling of Program Groups key changes.
            //
            ResetProgramGroupsEvent(pActiveGroup->fCommon);
            bHandleProgramGroupsEvent = TRUE;
            if (err) {
                MyMessageBox(hwnd,IDS_CANTRENAMETITLE,
                            IDS_CANTRENAMEMSG,NULL, MB_OK|MB_ICONEXCLAMATION);
            }
            GlobalUnlock(pActiveGroup->hGroup);
#endif
            pActiveGroup = NULL;

            EndDialog(hwnd, TRUE);
            break;
        }

        case IDCANCEL:
            pActiveGroup = NULL;
            EndDialog(hwnd, FALSE);
            break;

        default:
            return(FALSE);
        }
        break;

    default:

        if (uiMsg == uiHelpMessage) {
DoHelp:
            PMHelp(hwnd);

            return TRUE;
        } else
            return FALSE;
    }
    UNREFERENCED_PARAMETER(lParam);
    return(TRUE);
}

/******************************************************************************

   UpdateGroupsDlgProc

   10-18-93  Created by Johannec

******************************************************************************/
INT_PTR APIENTRY
UpdateGroupsDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (message) {

    case WM_INITDIALOG:
        //
        // Position ourselves
        //
        CentreWindow(hDlg);

        return(TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDOK:

             // fall through...

        case IDCANCEL:
             EndDialog(hDlg, LOWORD(wParam) == IDOK);
             break;
        case IDD_HELP:
             goto DoHelp;
             break;
        }
        break;

    default:

        if (message == uiHelpMessage)
DoHelp:
            {
            DWORD dwSave = dwContext;

            dwContext = IDH_UPDATEGRPDLG;

            PMHelp(hDlg);

            dwContext = dwSave;
            return TRUE;
        } else
            return FALSE;
    }

    // We didn't process the message
    return(FALSE);
}

//#ifdef JAPAN
/******************************************************************************

   CheckPortName(HWND,LPTSTR)

   This function check filename of path is reserveed as device name.

        1993/1/18   by yutakas

******************************************************************************/
//BOOL CheckPortName(HWND hDlg, LPTSTR lpszPath)
//{
//  LPTSTR lpT;
//
//  lpT = lpszPath + lstrlen(lpszPath);
//  while (lpT != lpszPath)
//  {
//      lpT = CharPrev(lpszPath,lpT);
//  }
//
//  if (PortName(lpT))
//  {
//      MyMessageBox(hDlg, IDS_BADPORTPATHTITLE, IDS_BADPORTPATHMSG, lpszPath,
//                   MB_OK | MB_ICONEXCLAMATION);
//      return TRUE;
//  }
//
//  return FALSE;
//
//}
//
//BOOL PortName(LPTSTR lpszFileName)
//{
//#define PORTARRAY 22
//  static TCHAR *szPorts[PORTARRAY] = {TEXT("LPT1"), TEXT("LPT2"), TEXT("LPT3"), TEXT("LPT4"), TEXT("LPT5"),
//                                     TEXT("LPT6"), TEXT("LPT7"), TEXT("LPT8"), TEXT("LPT9"),
//                                     TEXT("COM1"), TEXT("COM2"), TEXT("COM3"), TEXT("COM4"), TEXT("COM5"),
//                                     TEXT("COM6"), TEXT("COM7"), TEXT("COM8"), TEXT("COM9"),
//                                     TEXT("NUL"),  TEXT("PRN"), TEXT("CON"), TEXT("AUX")};
//  short i;
//  TCHAR cSave;
//
//  cSave = *(lpszFileName + 4);
//  if (cSave == TEXT('.'))
//      *(lpszFileName + 4) = TEXT('\0');
//  for (i = 0; i < PORTARRAY; i++) {
//      if (!lstrcmpi(szPorts[i], lpszFileName))
//          break;
//  }
//  *(lpszFileName + 4) = cSave;
//  return(i != PORTARRAY);
//}
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmgroup.c ===
#include "progman.h"
#include "ime.h"

BOOL FAR PASCAL IMEStringWindow(HWND,HANDLE);
int FAR PASCAL IMEWindowGetCnt(LPTSTR,LPTSTR);

#define HK_SHIFT    0x0100
#define HK_CONTROL  0x0200
#define HK_ALT      0x0400
#define HK_EXT      0x0800

#define F_EXT       0x01000000L

#define OBJ_ITEM                1


BOOL bNoScrollCalc = FALSE;
RECT rcArrangeRect;
HWND hwndScrolling = NULL;

BOOL APIENTRY InQuotes(LPTSTR sz);
void NEAR PASCAL ViewActiveItem(PGROUP pGroup);

/* Make the first item in a list the last and return a pointer to it.*/

PITEM PASCAL MakeFirstItemLast(PGROUP pGroup)
{
    PITEM pItemCur;

    /* Just quit if there's no list.*/

    if ((pItemCur = pGroup->pItems) == NULL)
        return NULL;

    /* Find the end of the list.*/
    for( ; pItemCur->pNext ; pItemCur = pItemCur->pNext)
    ;

    /* End of the list.*/
    /* This works even if there is only one item in the */
    /* list, it's a waste of time though.*/
    pItemCur->pNext = pGroup->pItems;
    pGroup->pItems = pGroup->pItems->pNext;
    pItemCur->pNext->pNext = NULL;

    return pItemCur->pNext;
}


VOID PASCAL GetItemText(PGROUP pGroup, PITEM pItem, LPTSTR lpT, int index)
{
    LPITEMDEF lpid;
    LPGROUPDEF lpgd;

    lpid = LockItem(pGroup,pItem);
    if (!lpid) {
        UnlockGroup(pGroup->hwnd);
        *lpT = 0;
        return;
    }

    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

    switch (index) {

    case 0:
        lstrcpy(lpT, (LPTSTR) PTR(lpgd, lpid->pName));
        break;

    case 1:
        lstrcpy(lpT, (LPTSTR) PTR(lpgd, lpid->pCommand));
        break;

    case 2:
        lstrcpy(lpT, (LPTSTR) PTR(lpgd, lpid->pIconPath));
        break;

    default:
        *lpT = 0;
        break;
    }

    GlobalUnlock(pGroup->hGroup);

    UnlockGroup(pGroup->hwnd);
}


ULONG Color16Palette[] = {
    0x00000000, 0x00800000, 0x00008000, 0x00808000,
    0x00000080, 0x00800080, 0x00008080, 0x00808080,
    0x00c0c0c0, 0x00ff0000, 0x0000ff00, 0x00ffff00,
    0x000000ff, 0x00ff00ff, 0x0000ffff, 0x00ffffff
};

ULONG Color256Palette[] = {
    0x00000000, 0x00800000, 0x00008000, 0x00808000, 0x00000080, 0x00800080, 0x00008080, 0x00c0c0c0,
    0x00c0dcc0, 0x00a6caf0, 0x00cccccc, 0x00580800, 0x00600800, 0x00680800, 0x00700800, 0x00780800,
    0x00801000, 0x00881000, 0x00901000, 0x00981000, 0x00a01000, 0x00a81000, 0x00b01000, 0x00b81000,
    0x00c01800, 0x00c81800, 0x00d01800, 0x00d81800, 0x00e01800, 0x00e81800, 0x00f01800, 0x00f81800,
    0x00002000, 0x00082000, 0x00102000, 0x00182000, 0x00202000, 0x00282000, 0x00302000, 0x00382000,
    0x00402800, 0x00482800, 0x00502800, 0x00582800, 0x00602800, 0x00682800, 0x00702800, 0x00782800,
    0x00803000, 0x00883000, 0x00903000, 0x00983000, 0x00a03000, 0x00a83000, 0x00b03000, 0x00b83000,
    0x00c03800, 0x00c83800, 0x00d03800, 0x00d83800, 0x00e03800, 0x00e83800, 0x00f03800, 0x00f83800,
    0x00004010, 0x00084010, 0x00104010, 0x00184010, 0x00204010, 0x00284010, 0x00304010, 0x00384010,
    0x00404810, 0x00484810, 0x00504810, 0x00584810, 0x00604810, 0x00684810, 0x00704810, 0x00784810,
    0x00805010, 0x00885010, 0x00905010, 0x00985010, 0x00a05010, 0x00a85010, 0x00b05010, 0x00b85010,
    0x00c05810, 0x00c85810, 0x00d05810, 0x00d85810, 0x00e05810, 0x00e85810, 0x00f05810, 0x00f85810,
    0x00006010, 0x00086010, 0x00106010, 0x00186010, 0x00206010, 0x00286010, 0x00306010, 0x00386010,
    0x00406810, 0x00486810, 0x00506810, 0x00586810, 0x00606810, 0x00686810, 0x00706810, 0x00786810,
    0x00807010, 0x00887010, 0x00907010, 0x00987010, 0x00a07010, 0x00a87010, 0x00b07010, 0x00b87010,
    0x00c07810, 0x00c87810, 0x00d07810, 0x00d87810, 0x00e07810, 0x00e87810, 0x00f07810, 0x00f87810,
    0x00008020, 0x00088020, 0x00108020, 0x00188020, 0x00208020, 0x00288020, 0x00308020, 0x00388020,
    0x00408820, 0x00488820, 0x00508820, 0x00588820, 0x00608820, 0x00688820, 0x00708820, 0x00788820,
    0x00809020, 0x00889020, 0x00909020, 0x00989020, 0x00a09020, 0x00a89020, 0x00b09020, 0x00b89020,
    0x00c09820, 0x00c89820, 0x00d09820, 0x00d89820, 0x00e09820, 0x00e89820, 0x00f09820, 0x00f89820,
    0x0000a020, 0x0008a020, 0x0010a020, 0x0018a020, 0x0020a020, 0x0028a020, 0x0030a020, 0x0038a020,
    0x0040a820, 0x0048a820, 0x0050a820, 0x0058a820, 0x0060a820, 0x0068a820, 0x0070a820, 0x0078a820,
    0x0080b020, 0x0088b020, 0x0090b020, 0x0098b020, 0x00a0b020, 0x00a8b020, 0x00b0b020, 0x00b8b020,
    0x00c0b820, 0x00b820c8, 0x00b820d0, 0x00b820d8, 0x00b820e0, 0x00b820e8, 0x00b820f0, 0x00b820f8,
    0x0000c030, 0x00c03008, 0x00c03010, 0x00c03018, 0x00c03020, 0x00c03028, 0x00c03030, 0x00c03038,
    0x0040c830, 0x00c83048, 0x00c83050, 0x00c83058, 0x00c83060, 0x00c83068, 0x00c83070, 0x00c83078,
    0x0080d030, 0x00d03088, 0x00d03090, 0x00d03098, 0x00d030a0, 0x00d030a8, 0x00d030b0, 0x00d030b8,
    0x00c0d830, 0x00c8d830, 0x00d0d830, 0x00d8d830, 0x00e0d830, 0x00e8d830, 0x00f0d830, 0x00f8d830,
    0x0000e030, 0x0008e030, 0x0010e030, 0x0018e030, 0x0020e030, 0x0028e030, 0x0030e030, 0x0038e030,
    0x0040e830, 0x0048e830, 0x0050e830, 0x0058e830, 0x0060e830, 0x0068e830, 0x0070e830, 0x0078e830,
    0x0080f030, 0x0088f030, 0x0090f030, 0x0098f030, 0x00a0f030, 0x00a8f030, 0x00fffbf0, 0x00a0a0a4,
    0x00808080, 0x00ff0000, 0x0000ff00, 0x00ffff00, 0x000000ff, 0x00ff00ff, 0x0000ffff, 0x00ffffff
};


HICON APIENTRY GetItemIcon(HWND hwnd, PITEM pitem)
{

    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    HICON hIcon = NULL;
    DWORD dwVer;
    HANDLE h;
    LPBYTE p;
    INT id = 0;
    INT cb;
    DWORD colors, size;
    PBITMAPINFOHEADER pbih, pbihNew;
    LPVOID palette;

    lpgd = LockGroup(hwnd);
    if (!lpgd)
        return DuplicateIcon(hAppInstance, hItemIcon);
        //return hItemIcon;
    lpid = ITEM(lpgd,pitem->iItem);

    if ((SHORT)lpid->cbIconRes > 0) {
        if (lpid->wIconVer == 2)
            dwVer = 0x00020000;
        else
            dwVer = 0x00030000;

        pbihNew = NULL;
        pbih = (PBITMAPINFOHEADER)PTR(lpgd, lpid->pIconRes);
        size = lpid->cbIconRes;

        if (pbih->biClrUsed == -1) {
            colors = (1 << (pbih->biPlanes * pbih->biBitCount));
            size += colors * sizeof(RGBQUAD);

            if (colors == 16) {
                palette = Color16Palette;
            } else if (colors == 256) {
                palette = Color256Palette;
            } else {
                palette = NULL;
            }

            if (palette != NULL)
                pbihNew = (PBITMAPINFOHEADER)LocalAlloc(LPTR, size);

            if (pbihNew != NULL) {
                RtlCopyMemory(pbihNew, pbih, sizeof( *pbih ));
                pbihNew->biClrUsed = 0;
                RtlCopyMemory((pbihNew+1), palette, colors * sizeof(RGBQUAD));
                RtlCopyMemory((PCHAR)(pbihNew+1) + (colors * sizeof(RGBQUAD)),
                              (pbih+1),
                              lpid->cbIconRes - sizeof(*pbih)
                             );

                pbih = pbihNew;
            }
            else {
                //
                // reset size
                //
                size = lpid->cbIconRes;
            }
        }

        hIcon = CreateIconFromResource((PBYTE)pbih, size, TRUE, dwVer);
        if (pbihNew != NULL)
            LocalFree(pbihNew);
    }

    if (!hIcon) {
      if (h = FindResource(hAppInstance, (LPTSTR) MAKEINTRESOURCE(ITEMICON), RT_GROUP_ICON)) {
          h = LoadResource(hAppInstance, h);
          p = LockResource(h);
          id = LookupIconIdFromDirectory(p, TRUE);
          UnlockResource(h);
          FreeResource(h);
      }
      if (h = FindResource(hAppInstance, (LPTSTR)  MAKEINTRESOURCE(id), (LPTSTR) MAKEINTRESOURCE(RT_ICON))) {
          cb = SizeofResource(hAppInstance, h);
          h = LoadResource(hAppInstance, h);
          p = LockResource(h);
          hIcon = CreateIconFromResource(p, cb, TRUE, 0x00030000);
          UnlockResource(h);
          FreeResource(h);
      }

    }
    UnlockGroup(hwnd);
    return hIcon;
}


COLORREF PASCAL GetTitleTextColor(VOID)
{
    COLORREF color;

    color = GetSysColor(COLOR_WINDOW);
    if (((WORD)LOBYTE(LOWORD(color)) +
             (WORD)HIBYTE(LOWORD(color)) +
         (WORD)LOBYTE(HIWORD(color))) >= 3*127)
      {
        return RGB(0,0,0);
      }
    else
      {
        return RGB(255,255,255);
      }
}

#define REVERSEPAINT

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/


void NEAR PASCAL ReverseGroupList(PGROUP pGroup)
{
    PITEM pitem, p1, p2;

    for (p1 = pGroup->pItems, p2 = p1->pNext, p1->pNext = NULL; p2; ) {
	    pitem = p2->pNext;
	    p2->pNext = p1;
	    p1 = p2;
	    p2 = pitem;
	}
    pGroup->pItems = p1;
}

VOID PASCAL PaintGroup(HWND hwnd)
{
    register HDC hdc;
    PGROUP pGroup;
    PITEM pitem;
    PAINTSTRUCT ps;
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    int fontheight;
    HBRUSH hbrTitle;
    HFONT hFontT;
    RECT rcWin;
    TEXTMETRIC tm;

    HDC hdcMem;
    HBITMAP hbmTemp;
    HBRUSH hbr, hbrTemp;
    INT nMax;
    HICON hIcon;

    pGroup = (PGROUP)GetWindowLongPtr(hwnd, GWLP_PGROUP);

    hdc = BeginPaint(hwnd, &ps);
    if (!pGroup->pItems) {
        goto Exit;
    }

    GetClientRect(hwnd, &rcWin);
#ifdef WEIRDBUG
/* DavidPe - 05/15/91
 *  For some reason RectVisible() will return FALSE in
 *  situations it shouldn't.  Since this is only a
 *  performance optimization, we can ignore the problem
 *  for now.
 */
    if (!RectVisible(hdc, &rcWin))
        goto Exit;
#endif

    if (!(lpgd = LockGroup(hwnd)))
        goto Exit;

    hFontT = SelectObject(hdc, hFontTitle);

    GetTextMetrics(hdc, &tm);

    // ToddB: This seems like a good point, I don't see why tmExternalLeading should ever
    //      need to be considered.  The result of decreasing the FontHeight is that DrawText
    //      will be used instead of TextOut in some cases, which should be harmless but might
    //      effect the apearence of some single line icon titles.

//#ifdef JAPAN
    // Why we should think about ExternalLeading though we calculate the
    // title rectange by DrawText() without DT_EXTERNALLEADING. -YN
    fontheight = tm.tmHeight;
//#else
//    fontheight = tm.tmHeight + tm.tmExternalLeading;
//#endif

    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, GetTitleTextColor());
    hbrTitle = NULL;

    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem)
        goto BitmapSetupComplete;

    if (pGroup->hbm) {
        hbmTemp = SelectObject(hdcMem, pGroup->hbm);
        if (hbmTemp)
            goto BitmapSetupComplete;
        else
            DeleteObject(pGroup->hbm);
    }

    for (nMax = 1, pitem = pGroup->pItems; pitem; pitem = pitem->pNext) {
	    if (nMax <= pitem->iItem)
	        nMax = pitem->iItem + 1;
    }

    pGroup->hbm = CreateDiscardableBitmap(hdc, cxIcon*lpgd->cItems, cyIcon);
    if (!pGroup->hbm)
        goto NukeMemDC;

    hbmTemp = SelectObject(hdcMem, pGroup->hbm);
    if (!hbmTemp)
        goto NukeBitmap;

    hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    if (!hbr)
        goto NukeBitmap;

    hbrTemp = SelectObject(hdcMem, hbr);
    if (!hbrTemp)
        goto NukeBrush;

    PatBlt(hdcMem, 0, 0, cxIcon * lpgd->cItems, cyIcon, PATCOPY);
    SelectObject(hdcMem, hbrTemp);
    DeleteObject(hbr);

    for (pitem = pGroup->pItems; pitem != NULL; pitem = pitem->pNext) {
        if (hIcon = GetItemIcon(hwnd, pitem)) {
            DrawIcon(hdcMem, pitem->iItem * cxIcon, 0, hIcon);
            DestroyIcon(hIcon);
        } else {
            goto DeselectAndNukeBitmap;
        }
    }

    goto BitmapSetupComplete;

NukeBrush:
     DeleteObject(hbr);

DeselectAndNukeBitmap:
    SelectObject(hdcMem, hbmTemp);

NukeBitmap:
     DeleteObject(pGroup->hbm);
     pGroup->hbm = NULL;

NukeMemDC:
     DeleteDC(hdcMem);
     hdcMem = NULL;

BitmapSetupComplete:

    ReverseGroupList(pGroup); // reverse the icon list

    /* Paint the icons */
    for (pitem = pGroup->pItems; pitem; pitem = pitem->pNext) {
      	if (!pitem->pNext
    	      && pGroup == pCurrentGroup
	          && hwndProgman == GetActiveWindow()) {
	        hbrTitle = (HANDLE)1;       // Use it as a flag
    	}
    	else
    	    hbrTitle = (HANDLE)0;

    	lpid = ITEM(lpgd,pitem->iItem);

	    if (!bMove || !hbrTitle) {
	        if (hdcMem) {
        		BitBlt(hdc, pitem->rcIcon.left + cxOffset,
		               pitem->rcIcon.top + cyOffset,
        		       lpgd->cxIcon, lpgd->cyIcon, hdcMem,
		               lpgd->cxIcon*pitem->iItem, 0,
        		       SRCCOPY);
	        }
            else {
	    	    if (RectVisible(hdc,&pitem->rcIcon)) {
		            if (hIcon = GetItemIcon(hwnd,pitem)) {
		            	DrawIcon(hdc, pitem->rcIcon.left + cxOffset,
                				 pitem->rcIcon.top + cyOffset, hIcon);
        		    }
                    else {
		            	PatBlt(hdc,pitem->rcIcon.left + cxOffset,
            			       pitem->rcIcon.top + cyOffset,
			                   cxIcon, cyIcon, BLACKNESS);
        		    }
		        }
    	    }
	    }
    }

    /* Paint the titles. */
    for (pitem = pGroup->pItems; pitem; pitem = pitem->pNext) {
        /* test for the active icon */

      	if (!pitem->pNext
    	      && pGroup == pCurrentGroup
	          && hwndProgman == GetActiveWindow()) {
    	    SetTextColor(hdc, GetSysColor(COLOR_CAPTIONTEXT));
	        hbrTitle = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
    	}
        else {
	        hbrTitle = (HANDLE)0;
    	}

	    lpid = ITEM(lpgd,pitem->iItem);

    	if (!bMove || !hbrTitle) {
	        if (hbrTitle)
        		FillRect(hdc, &(pitem->rcTitle), hbrTitle);

	        /* draw multi line titles like USER does */

    	    if (pitem->rcTitle.bottom - pitem->rcTitle.top < fontheight*2)
                TextOut(hdc, pitem->rcTitle.left+cxOffset, pitem->rcTitle.top,
                        (LPTSTR) PTR(lpgd, lpid->pName), lstrlen((LPTSTR) PTR(lpgd, lpid->pName)));
            else {
                if (RectVisible(hdc,&pitem->rcTitle)) {
	            DrawText(hdc,
                             (LPTSTR)PTR(lpgd, lpid->pName), -1,
                             &(pitem->rcTitle),
                       	     bIconTitleWrap ?
                    	        DT_CENTER | DT_WORDBREAK | DT_NOPREFIX :
                                DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);

                }
    	    }
        }


        if (hbrTitle) {
            SetTextColor(hdc, GetTitleTextColor());
            DeleteObject(hbrTitle);
            hbrTitle = NULL;
        }
    }

    ReverseGroupList(pGroup);	// re-reverse the icon list

    if (hFontT) {
        SelectObject(hdc, hFontT);
    }

    if (hdcMem) {
        SelectObject(hdcMem, hbmTemp);
        DeleteDC(hdcMem);
    }

    UnlockGroup(hwnd);

Exit:
    SetBkMode(hdc, OPAQUE);
    EndPaint(hwnd, &ps);

#ifdef DEBUG
    ProfStop();
    {
    TCHAR buf[80];
    wsprintf(buf, TEXT("msec to paint group = %ld\r\n"), GetTickCount() - dwStartTime);
    OutputDebugString(buf);
    }
#endif
}

/*-------------------------------------------------------------------------*/
/*                                                                         */
/* Draw the group icon.                                                    */
/*                                                                         */
/*-------------------------------------------------------------------------*/
VOID DrawGroupIcon(HWND hwnd)
{
    PAINTSTRUCT ps;
    HDC hDC;
    PGROUP pGroup;

    hDC = BeginPaint(hwnd, &ps);
    pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);
    if (pGroup->fCommon) {
        DrawIcon(hDC, cxOffset, cyOffset, hCommonGrpIcon);
    }
    else {
        DrawIcon(hDC, cxOffset, cyOffset, hGroupIcon);
    }
    EndPaint(hwnd, &ps);
}


PITEM PASCAL ItemHitTest(
    PGROUP pGroup,
    POINTS pts)
{
    PITEM pItem;
    POINT pt;

    pt.x = (int)pts.x;
    pt.y = (int)pts.y;

    for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext) {
        if (PtInRect(&pItem->rcIcon, pt) || PtInRect(&pItem->rcTitle, pt)) {
            break;
        }
    }

    return pItem;
}


HRGN PASCAL IconExcludedRgn(PGROUP pGroup, PITEM pItem)
{
    RECT rc;
    PITEM pItemT;
    HRGN hrgn, hrgnT;

    hrgn = CreateRectRgn(0,0,0,0);

    if (!hrgn)
        return NULL;

    hrgnT = CreateRectRgn(0,0,0,0);
    if (!hrgnT)
      {
        return hrgn;
      }

    for (pItemT = pGroup->pItems;
         pItemT && pItemT != pItem;
         pItemT = pItemT->pNext)
      {
        if (IntersectRect(&rc,&pItem->rcIcon,&pItemT->rcIcon))
          {
            SetRectRgn(hrgnT,rc.left,rc.top,rc.right,rc.bottom);
            CombineRgn(hrgn,hrgn,hrgnT,RGN_OR);
          }
        if (IntersectRect(&rc,&pItem->rcIcon,&pItemT->rcTitle))
          {
            SetRectRgn(hrgnT,rc.left,rc.top,rc.right,rc.bottom);
            CombineRgn(hrgn,hrgn,hrgnT,RGN_OR);
          }
      }

    DeleteObject(hrgnT);

    return hrgn;
}

VOID APIENTRY InvalidateIcon(PGROUP pGroup, PITEM pItem)
{
    RECT rc;

    if (!pGroup || !pItem)
        return;
    UnionRect(&rc, &pItem->rcIcon, &pItem->rcTitle);
    if (bAutoArranging)
        UnionRect(&rcArrangeRect, &rcArrangeRect, &rc);
    else
        InvalidateRect(pGroup->hwnd,&rc,TRUE);
}

VOID PASCAL BringItemToTop(PGROUP pGroup, PITEM pItem, BOOL fUpdate)
{
    PITEM pItemT;
    HRGN hrgn;

    if (pItem == pGroup->pItems) {
        return;
    }

    if (hrgn = IconExcludedRgn(pGroup, pItem)) {
        InvalidateRgn(pGroup->hwnd, hrgn, TRUE);
        DeleteObject(hrgn);
    }

    /*
     * At this point we know there is at least two items, and we're not the
     * first one...
     */

    for (pItemT = pGroup->pItems; pItemT->pNext != pItem; pItemT = pItemT->pNext)
        ;

    pItemT->pNext = pItem->pNext;
    pItem->pNext = pGroup->pItems;
    pGroup->pItems = pItem;

    /*
     * Invalidate the whole titles in order to change the color.
     */
    if (fUpdate) {
        InvalidateRect(pGroup->hwnd, &pItem->rcTitle, TRUE);
        InvalidateRect(pGroup->hwnd, &pItem->pNext->rcTitle, TRUE);
    }
}

VOID PASCAL ClickOn(HWND hwnd, POINTS pts)
{
    PGROUP pGroup;
    PITEM pItem;
    POINT pt;

    pGroup = (PGROUP)GetWindowLongPtr(hwnd, GWLP_PGROUP);

    pItem = ItemHitTest(pGroup, pts);
    if (!pItem) {
        return;
    }

    BringItemToTop(pGroup, pItem, TRUE);
    ViewActiveItem(pGroup);

    pt.x = (int)pts.x;
    pt.y = (int)pts.y;

    *(LPPOINT)&rcDrag.left = pt;
    *(LPPOINT)&rcDrag.right = pt;
    hwndDrag = hwnd;

    InflateRect(&rcDrag, GetSystemMetrics(SM_CXDOUBLECLK) / 2,
            GetSystemMetrics(SM_CYDOUBLECLK) / 2);
}


VOID PASCAL DragItem(HWND hwnd)
{
    PGROUP pGroup;
    PITEM pItem;
    HICON hIcon;

    pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);
    pItem = pGroup->pItems;

    if (!pItem || hwndDrag != hwnd)
        goto ProcExit;

    /* If the control key isn't down, do a Move operation. */
    bMove = !(GetKeyState(VK_CONTROL) & 0x8000);

    /* Don't allow "moves" from RO groups. */
    if (pGroup->fRO && bMove == TRUE)
        goto ProcExit;

    /*
     * Redraw the window minus the item we're moving.
     * REVIEW - if you just painted the background colour into the
     * pItem->rcIcon area then you could remove the bMove code from
     * PaintGroup().
     */
    if (bMove) {
        InvalidateIcon(pGroup,pItem);
        UpdateWindow(hwnd);
    }

    hIcon = GetItemIcon(hwnd,pItem);

    // BUG BUG  MAKELONG(pGroup,pItem) doesn't make sense since all
    // pointers all LOMG in WIN32. Will need to change the parameters!
    // johannec 08-19-91
    if (DragObject(hwndMDIClient, hwnd, (UINT)OBJ_ITEM,
                   MAKELONG(pGroup,pItem), hIcon) == DRAG_COPY) {
        if (bMove)
            DeleteItem(pGroup,pItem);
    }
    else {
        /* Drag was SWP or drag failed... just show the item. */
        if (bMove) {
            bMove = FALSE;
            InvalidateIcon(pGroup,pItem);
        }
    }
    DestroyIcon(hIcon);
ProcExit:
    bMove = FALSE;
}


void PASCAL GetRealClientRect(
    HWND   hwnd,
    DWORD  dwStyle,
    LPRECT lprcClient)
{
    DWORD Style;

    Style = GetWindowLong(hwnd, GWL_STYLE);

        /*BUG BUG will GWL_STYLE work???*/

    SetWindowLong(hwnd,GWL_STYLE,dwStyle);
    GetWindowRect(hwnd,lprcClient);
    ScreenToClient(hwnd,(LPPOINT)&lprcClient->left);
    ScreenToClient(hwnd,(LPPOINT)&lprcClient->right);
    SendMessage(hwnd,WM_NCCALCSIZE,0,(LPARAM)lprcClient);
}


VOID APIENTRY CalcGroupScrolls(HWND hwnd)
{
    register PGROUP pGroup;
    register PITEM pItem;
    RECT rcClient;
    RECT rcRange;
    RECT rcT;
    DWORD dwStyle, dwStyleNew, dwStyleT;
    int iMinPos, iMaxPos;

    if (bNoScrollCalc || IsIconic(hwnd))
        return;

    // Stop re-entrance of this routine.
    bNoScrollCalc = TRUE;

    pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);

    if (!pGroup->pItems) {
        // No items...
        SetRectEmpty(&rcRange);
    	goto ChangeStyle;
    }

    hwndScrolling = hwnd;

    // If the user has selected auto arranging then make
    // the next item in the z-order visable.
    if (bAutoArrange)
        ViewActiveItem(pGroup);

    SetRectEmpty(&rcRange);

    for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext)
      {
        UnionRect(&rcRange,&rcRange,&pItem->rcIcon);
    	rcT.top = pItem->rcTitle.top;		// don't include the
	    rcT.bottom = pItem->rcTitle.bottom;	// title overhang part
    	rcT.left = pItem->rcIcon.left;
	    rcT.right = pItem->rcIcon.right;
        UnionRect(&rcRange,&rcRange,&rcT);
      }

    if (rcRange.left != rcRange.right)
      {
        // Add on a bit for the left border here.
        rcRange.left -= ((cxArrange-cxIconSpace)/2)+cxOffset;
        // Don't add on a right border so we can cram as many icons in as poss.
        // rcRange.right += ((cxArrange-cxIconSpace)/2);

        // ADJUST THE RECT SO THAT WE DON'T GET SCROLL BARS IF ONLY THE BORDERS
        // OF TEXT ARE NOT VISIBLE ~~~
      }

ChangeStyle:

    dwStyleNew = dwStyle = GetWindowLong(hwnd,GWL_STYLE);

    dwStyleNew &= ~(WS_HSCROLL | WS_VSCROLL);

    for (;;)
      {
        dwStyleT = dwStyleNew;
        GetRealClientRect(hwnd, dwStyleNew, &rcClient);

        if (rcRange.left < rcClient.left || rcRange.right > rcClient.right)
            dwStyleNew |= WS_HSCROLL;
        if (rcRange.top < rcClient.top || rcRange.bottom > rcClient.bottom)
            dwStyleNew |= WS_VSCROLL;

        if (dwStyleNew == dwStyleT)
            break;
      }

    if (dwStyleNew == dwStyle && !(dwStyle & (WS_VSCROLL|WS_HSCROLL)))
      {
        /* none there and don't need to add 'em!
         */
        goto ProcExit;
      }

    UnionRect(&rcRange,&rcClient,&rcRange);

    /* union garantees that left==right or top==bottom in case of no
     * scrollbar.
     */
    rcRange.right -= rcClient.right-rcClient.left;
    rcRange.bottom -= rcClient.bottom-rcClient.top;

    /* if the style changed, don't redraw in sb code, just redraw the
     * frame at the end cause the whole ncarea has to be repainted
     * if it hasn't changed, just move the thumb
     */

    if (dwStyleNew==dwStyle)
      {
        if (dwStyleNew & WS_HSCROLL)
          {
            if (GetScrollPos(hwnd,SB_HORZ)!=0)
                goto SetScrollInfo;
            GetScrollRange(hwnd,SB_HORZ,&iMinPos,&iMaxPos);
            if ((iMinPos != rcRange.left) || (iMaxPos != rcRange.right))
                goto SetScrollInfo;
          }
        if (dwStyleNew & WS_VSCROLL)
          {
            if (GetScrollPos(hwnd,SB_VERT)!=0)
                goto SetScrollInfo;
            GetScrollRange(hwnd,SB_VERT,&iMinPos,&iMaxPos);
            if ((iMinPos != rcRange.top) || (iMaxPos != rcRange.bottom))
                goto SetScrollInfo;
          }
        goto ProcExit;
      }

SetScrollInfo:
    SetScrollPos(hwnd,SB_HORZ,0,FALSE);
    SetScrollPos(hwnd,SB_VERT,0,FALSE);
    SetScrollRange(hwnd,SB_HORZ,rcRange.left,rcRange.right,FALSE);
    SetScrollRange(hwnd,SB_VERT,rcRange.top,rcRange.bottom,FALSE);

    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOSIZE
                                         | SWP_NOMOVE | SWP_NOACTIVATE
                                         | SWP_DRAWFRAME);
ProcExit:
    // Allow other scroll calculations.
    bNoScrollCalc = FALSE;
}


VOID PASCAL ScrollGroup(PGROUP pGroup, int xMove, int yMove, BOOL fCalc)
{
    register PITEM pItem;

    for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext)
      {
        OffsetRect(&pItem->rcIcon,xMove,yMove);
        OffsetRect(&pItem->rcTitle,xMove,yMove);
      }
    ScrollWindow(pGroup->hwnd,xMove,yMove,NULL,NULL);

    UpdateWindow(pGroup->hwnd);

    if (fCalc)
        CalcGroupScrolls(pGroup->hwnd);
}

VOID APIENTRY ViewActiveItem(PGROUP pGroup)
{
    RECT rcClient, rc;
    int xMove = 0, yMove = 0;

    GetClientRect(pGroup->hwnd,&rcClient);

    UnionRect(&rc, &pGroup->pItems->rcIcon, &pGroup->pItems->rcTitle);
    // Clip width to that of icon i.e. ignore width of text.
    rc.left = pGroup->pItems->rcIcon.left;
    rc.right = pGroup->pItems->rcIcon.right;


    if (rc.left < rcClient.left)
        xMove = rcClient.left - rc.left;
    else if (rc.right > rcClient.right)
        xMove = rcClient.right - rc.right;

    if (rc.top < rcClient.top)
        yMove = rcClient.top - rc.top;
    else if (rc.bottom > rcClient.bottom)
        yMove = rcClient.bottom - rc.bottom;

    if (xMove || yMove)
        ScrollGroup(pGroup, xMove, yMove,TRUE);
}


BOOL FAR PASCAL CheckHotKey(WPARAM wParam, LPARAM lParam)
{
    HWND hwndT;
    PGROUP pGroup;
    PITEM pItem;

    switch (wParam)
    {
    case VK_SHIFT:
    case VK_CONTROL:
    case VK_MENU:
    case VK_RETURN:
        return FALSE;
    }

    if (GetKeyState(VK_SHIFT) < 0) {
    	// DBG((" + SHIFT"));
	    wParam |= HK_SHIFT;
    }
    if (GetKeyState(VK_CONTROL) < 0) {
    	// DBG((" + CONTROL"));
	    wParam |= HK_CONTROL;
    }
    if (GetKeyState(VK_MENU) < 0) {
    	// DBG((" + ALT"));
	    wParam |= HK_ALT;
    }
    if (lParam & F_EXT) {
    	// DBG((" EXTENDED"));
	    wParam |= HK_EXT;
    }

    // DBG(("... Full code %4.4X...\r\n",wParam));

    for (hwndT = GetWindow(hwndMDIClient,GW_CHILD);
          hwndT;
          hwndT = GetWindow(hwndT,GW_HWNDNEXT)) {
        if (GetWindow(hwndT,GW_OWNER))
            continue;

        pGroup = (PGROUP)GetWindowLongPtr(hwndT,GWLP_PGROUP);

        for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext) {
    	    // DBG(("Checking (%4.4X,%4.4X)...\r\n",pGroup,pItem));
            if (GroupFlag(pGroup,pItem,(WORD)ID_HOTKEY) == (WORD)wParam) {
	        	// DBG(("F*O*U*N*D\r\n"));
                ExecItem(pGroup,pItem,FALSE,FALSE);
                return TRUE;
            }
        }
    }

    return FALSE;
}


VOID APIENTRY KeyWindow(HWND hwnd, WORD wDirection)
{
    int     wT;
    int     wNext;
    RECT    rc;
    RECT    rcT;
    POINT   ptA;
    POINT   ptT;
    PGROUP  pGroup;
    PITEM   pItem, pItemNext;

    pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);

    if (!pGroup->pItems)
        return;

    wNext = 0x7FFF;
    pItemNext = NULL;
    CopyRect(&rc,&pGroup->pItems->rcIcon);

    for (pItem = pGroup->pItems->pNext; pItem; pItem = pItem->pNext) {
        CopyRect(&rcT,&pItem->rcIcon);
        ptT.x = rcT.left - rc.left;
        ptT.y = rcT.top - rc.top;
        ptA.x = (ptT.x < 0) ? -ptT.x : ptT.x;
        ptA.y = (ptT.y < 0) ? -ptT.y : ptT.y;

        switch (wDirection) {
            case VK_LEFT:
                if ((ptT.x >= 0) || (ptA.x < ptA.y))
                    continue;
                break;

            case VK_RIGHT:
                if ((ptT.x <= 0) || (ptA.x < ptA.y))
                    continue;
                break;

            case VK_DOWN:
                if ((ptT.y <= 0) || (ptA.y < ptA.x))
                    continue;
                break;

            case VK_UP:
                if ((ptT.y >= 0) || (ptA.y < ptA.x))
                    continue;
                break;

            default:
                /* illegal key
                 */
                return;
        }

        wT = ptA.y + ptA.x;

        if (wT <= wNext) {
            wNext = wT;
            pItemNext = pItem;
        }
    }

    if (pItemNext) {
        BringItemToTop(pGroup,pItemNext, TRUE);
        ViewActiveItem(pGroup);
    }
}


VOID APIENTRY CharWindow(register HWND hwnd, register WORD wChar)
{
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    PGROUP pGroup;
    PITEM pItem, pItemLast;

    pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);

    if (!pGroup->pItems)
        return;

    lpgd = LockGroup(hwnd);
    if (!lpgd)
        return;

    /* Search for item, skip the currently selected one.*/
    for ( pItem = pGroup->pItems->pNext; pItem; pItem=pItem->pNext)
      {
        lpid = ITEM(lpgd,pItem->iItem);
        if (CharUpper((LPTSTR)(DWORD_PTR)wChar)
          == CharUpper((LPTSTR)(DWORD_PTR)(BYTE)*PTR(lpgd, lpid->pName)))
          {
            pItemLast = MakeFirstItemLast(pGroup);
            BringItemToTop(pGroup,pItem, FALSE);
            /* Handle updates.*/
            InvalidateRect(pGroup->hwnd,&pItem->rcTitle,TRUE);
            InvalidateRect(pGroup->hwnd,&pItemLast->rcTitle,TRUE);
            ViewActiveItem(pGroup);
            break;
          }
      }
    UnlockGroup(hwnd);
}


VOID APIENTRY ScrollMessage(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int           wMin;
    int           wMax;
    int           wPos;
    int           wInc;
    int           wPage;
    int           wNewPos;
    RECT          rcClient;
    int           yMove;
    int           xMove;
    BOOL          fTemp;

    GetClientRect(hwnd, &rcClient);

    if (uiMsg == WM_HSCROLL) {
        GetScrollRange(hwnd, SB_HORZ, &wMin, &wMax);
        wPos = GetScrollPos(hwnd, SB_HORZ);
        wInc = cxIconSpace + cxArrange / 2;
        wPage = rcClient.right-rcClient.left;
    }
    else {
        GetScrollRange(hwnd, SB_VERT, &wMin, &wMax);
        wPos = GetScrollPos(hwnd, SB_VERT);
        wInc = cyArrange;
        wPage = rcClient.bottom-rcClient.top;
    }

    switch (GET_WM_VSCROLL_CODE(wParam, lParam)) {
        case SB_BOTTOM:
            wNewPos = wMax;
            break;

        case SB_TOP:
            wNewPos = wMin;
            break;

        case SB_LINEDOWN:
            wNewPos = wPos + wInc;
            break;

        case SB_LINEUP:
            wNewPos = wPos - wInc;
            break;

        case SB_PAGEDOWN:
            wNewPos = wPos + wPage;
            break;

        case SB_PAGEUP:
            wNewPos = wPos - wPage;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            wNewPos = (INT)(SHORT)GET_WM_VSCROLL_POS(wParam, lParam);
            break;

        case SB_ENDSCROLL:
            // We might suddenly not need the scroll bars anymore so
            // check now.
            // Stop CGS from moving the view.
            fTemp = bAutoArrange;
            bAutoArrange = FALSE;
    	    CalcGroupScrolls(hwnd);
            bAutoArrange = fTemp;

            /*** FALL THRU ***/

        default:
            return;
    }

    if (wNewPos < wMin)
        wNewPos = wMin;
    else if (wNewPos > wMax)
        wNewPos = wMax;

    if (uiMsg == WM_VSCROLL) {
        SetScrollPos(hwnd, SB_VERT, wNewPos, TRUE);
        yMove = wPos - wNewPos;
        xMove = 0;
    }
    else {
        SetScrollPos(hwnd, SB_HORZ, wNewPos, TRUE);
        yMove = 0;
        xMove = wPos - wNewPos;
    }

    ScrollGroup((PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP),xMove,yMove,FALSE);
}


VOID PASCAL OfficialRect(
    LPRECT lprc,
    int x,
    int y,
    int xOffset,
    int yOffset)
{
    // Work out were the icon should go in the icon grid, taking
    // note of where the scroll bars are.

    lprc->right = (lprc->left = x-xOffset + (cxIconSpace - cxArrange) / 2) +
            cxArrange - 1;
    lprc->bottom = (lprc->top = y-yOffset) + cyArrange - 1;
}


BOOL PASCAL IconOverlaps(
    PGROUP pGroup,
    LPRECT lprc,
    int xOffset,
    int yOffset)
{
    PITEM pItem;
    RECT rcT;

    for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext) {
        // Ignore icons at -1. This is where icon's get put when
        // we don't know where to put them and they will get moved
        // later.
        if (pItem->rcIcon.left == -1) {
            continue;
        }

        OfficialRect(&rcT, pItem->rcIcon.left, pItem->rcIcon.top, xOffset, yOffset);
        if (IntersectRect(&rcT, &rcT, lprc)) {
            return TRUE;
        }
    }
    return FALSE;
}


/*
 * NB This is called for every icon at init time so put anything to do with
 * finding icon positions inside the `if' because that's skipped on init.
 * If you don't it'll get tres slow.
 */

VOID PASCAL ComputeIconPosition(
    PGROUP pGroup,
    POINT pt,
    LPRECT lprcIcon,
    LPRECT lprcTitle,
    LPTSTR lpText)
{
    HDC hdc;
    int cch;
    RECT rcClient, rcT;
    HFONT hFontT;
    int xsp, ysp;       // Current position of scrollbar.
    int vMax, vMin;     // Range.
    int hMax, hMin;     // Range.
    int xOffset, yOffset;
    DWORD dwStyle;

    if (pt.x == -1) {
        /*
         * Icon is in "find me a default position" mode...
         * so search the icon space for it...
         */
        // Get the current window style.
        dwStyle = GetWindowLong(pGroup->hwnd,GWL_STYLE);

        if (dwStyle & WS_MINIMIZE) {
            // DBG(("PM.CIP: Window Minimised\n\r"));
            // We want to use the restored state of the window.
            GetInternalWindowPos(pGroup->hwnd, &rcClient, NULL);
            // Convert from screen coords to client coords.
            OffsetRect(&rcClient, -rcClient.left, -rcClient.top);
        }
        else {
            // DBG(("PM.CIP: Window normal or maxed.\n\r"));
            // Take into account scroll bars.
            GetClientRect(pGroup->hwnd, &rcClient);
        }

        if (dwStyle & WS_HSCROLL) {
             xsp = GetScrollPos(pGroup->hwnd, SB_HORZ);
             GetScrollRange(pGroup->hwnd, SB_HORZ, &hMin, &hMax);
             xOffset = xsp-hMin;     // Offset icon grid to match scroll bar pos.
        }
        else {
             xOffset = 0;
        }

        if (dwStyle & WS_VSCROLL) {
             ysp = GetScrollPos(pGroup->hwnd, SB_VERT);
             GetScrollRange(pGroup->hwnd, SB_VERT, &vMin, &vMax);
             yOffset = ysp-vMin;     // Offset icon grid.
        }
        else {
             yOffset = 0;
        }

        pt.x = (cxArrange - cxIconSpace) / 2 + cxOffset - xOffset;
        pt.y = 0 - yOffset;
        /* Set this icon's left to -1 so that it'll be excluded
         * by the IconOverlaps check.
         */
        lprcIcon->left = -1;

        for (;;) {
            OfficialRect(&rcT, pt.x, pt.y, xOffset, yOffset);

            if (!IconOverlaps(pGroup, &rcT, xOffset, yOffset)) {
                break;
            }

            if (rcT.right + cxArrange > rcClient.right) {
                pt.x = (cxArrange-cxIconSpace)/2 + cxOffset - xOffset;
                pt.y += cyArrange;
            }
            else {
                pt.x += cxArrange;
            }
        }
    }

    SetRect(lprcIcon, pt.x, pt.y, pt.x+cxIconSpace, pt.y+cyIconSpace);

    if (IsRectEmpty(lprcTitle)) {
        cch = lstrlen(lpText);

        hdc = GetDC(pGroup->hwnd);
        hFontT = SelectObject(hdc, hFontTitle);

        /*
         * Compute the icon rect using DrawText.
         */
        lprcTitle->right = cxArrange - (2 * cxOffset);
        DrawText(hdc, lpText, -1, lprcTitle, bIconTitleWrap ?
            (WORD)(DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX) :
            (WORD)(DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE));

        if (hFontT) {
            SelectObject(hdc, hFontT);
        }
        ReleaseDC(pGroup->hwnd, hdc);
        lprcTitle->right += cxOffset * 2;
        lprcTitle->bottom += dyBorder * 2;

    }
    else {
        SetRect(lprcTitle, 0, 0, lprcTitle->right - lprcTitle->left,
                lprcTitle->bottom - lprcTitle->top);
    }


    OffsetRect(lprcTitle, pt.x+(cxIconSpace/2)-((lprcTitle->right-lprcTitle->left)/2),
                  pt.y + cyIconSpace - dyBorder);

// REVIEW Very expensive to do this here.
//    if ((bAutoArrange) && (!bAutoArranging))
//	      ArrangeItems(pGroup->hwnd);
}

VOID APIENTRY MoveItem(PGROUP pGroup, PITEM pItem, POINT pt)
{
    LPITEMDEF lpid;
    LPGROUPDEF lpgd;

    lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

    /*
     * If the position is the same, ignore
     */
    if ((pt.x == pItem->rcIcon.left) && (pt.y == pItem->rcIcon.top)) {
        GlobalUnlock(pGroup->hGroup);
        return;
    }

    /*
     * Repaint the original position
     */
    InvalidateIcon(pGroup, pItem);

    lpid = LockItem(pGroup,pItem);
    if (!lpid) {
        GlobalUnlock(pGroup->hGroup);
        return;
    }

    ComputeIconPosition(pGroup, pt, &pItem->rcIcon, &pItem->rcTitle,
            (LPTSTR) PTR(lpgd, lpid->pName));


    UnlockGroup(pGroup->hwnd);
    GlobalUnlock(pGroup->hGroup);

    /*
     * Repaint the new position
     */
    InvalidateIcon(pGroup,pItem);

//  CalcGroupScrolls(pGroup->hwnd);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DropObject() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LONG NEAR PASCAL DropObject(HWND hWnd, LPDROPSTRUCT lpds)
{
  BOOL          fNC;
  BOOL          fOk;
  POINT         pt;
  LPPOINT       lppt;
  PGROUP        pGroup;
  PITEM         pItem;
  RECT          rcClient;

  pGroup = pCurrentGroup;
  pItem = pGroup->pItems;

  pt = lpds->ptDrop;

  // A drop anywhere in the window is valid.
  GetWindowRect(hWnd, &rcClient);
  // Convert to client coords.
  ScreenToClient(hWnd,(LPPOINT)&(rcClient.left));
  ScreenToClient(hWnd,(LPPOINT)&(rcClient.right));

  if (pt.x >= rcClient.left && pt.y >= rcClient.top && pt.x <= rcClient.right
                                                && pt.y <= rcClient.bottom) {
      /* Dropped in given point of client area. */
      fNC = FALSE;
      pt.x -= (GetSystemMetrics(SM_CXICON) / 2) + 2;
      pt.y -= (GetSystemMetrics(SM_CYICON) / 2) + 2;
      lppt = &pt;
  }
  else {
      /* Dropped in nonclient area. */
      fNC = TRUE;
      lppt = NULL;
  }

  /* Are we iconic ? */
  if (IsIconic(hWnd)) {
      // Yep, we'll need to use default positioning.
      fNC = TRUE;
      lppt = NULL;
  }

#if 0
  // this if statement code if obsolete, it is never called. - johannec 8/11/93
  if (lpds->wFmt == DOF_EXECUTABLE || lpds->wFmt == DOF_DOCUMENT) {

      BuildDescription(szNameField, szPathName);

      return((LONG)(CreateNewItem(hWnd,
                szNameField, szPathName, szPathName, TEXT(""),
                0, FALSE, 0, 0, NULL, lppt, CI_SET_DOS_FULLSCRN) != NULL));
  }
#endif

  if ((hWnd == pGroup->hwnd) && (bMove)) {
      /* Don't drop on our own non-client area. */
      if (fNC)
          return 0L;

      /* We are just moving the item within its own group.
       * Hide it first so the icon title is treated correctly.
       */
      MoveItem(pGroup,pItem, pt);
      if ((bAutoArrange) && (!bAutoArranging))
          ArrangeItems(pGroup->hwnd);
      else if (!bAutoArranging)
          CalcGroupScrolls(pGroup->hwnd);

      return(DRAG_SWP);
  }
  else {
      /* Copy the item to the new group...  Set the hourglass
       * cursor (it will get unset after the message returns),
       * select the new group, and add the item at the specified
       * point.
       */
      fOk = DuplicateItem(pGroup,pItem,
                  (PGROUP)GetWindowLongPtr(hWnd,GWLP_PGROUP),lppt) != NULL;

      /*
       * Re-Arrange items within the destination group.
       * NB The source will been taken care of by the DeleteItem routine
       * called from DragItem.
       */
      if ((bAutoArrange) && (!bAutoArranging)) {
          /* Destination */
          ArrangeItems(hWnd);
      }
      else if (!bAutoArranging) {
          /* Destination */
          CalcGroupScrolls(hWnd);
      }

      /* View the current item. */
      BringItemToTop(pGroup,pItem, TRUE);
      ViewActiveItem(pGroup);

      /* If the dest isn't minimised then move the focus to it. */
      if (!IsIconic(hWnd))
           SetFocus(hWnd);
      return (fOk ? DRAG_COPY : 0L);
  }
}

LONG APIENTRY DropFiles(HWND hwnd, HANDLE hDrop)
{
    POINT pt;
    LPPOINT lppt;
    UINT i;
    HCURSOR hCursor;
    DWORD dwRet;
    DWORD dwFlags = CI_ACTIVATE | CI_SET_DOS_FULLSCRN;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    if (!DragQueryPoint(hDrop, &pt) ||
                   DragQueryFile(hDrop, (UINT)-1, NULL, 0) != 1) {
        lppt = NULL;
    }
    else {
        pt.x -= (GetSystemMetrics(SM_CXICON) / 2) + 2;
        pt.y -= (GetSystemMetrics(SM_CYICON) / 2) + 2;
        lppt = &pt;
    }

    for (i=0; DragQueryFile(hDrop, i, szPathField, MAXITEMPATHLEN); i++) {
        //
        // if filename or directory have spaces, put the path
        // between quotes.
        //
        CheckEscapes(szPathField, MAXITEMPATHLEN+1);

        /* Verify the file's existance... */
        dwRet = ValidatePath(hwndProgman, szPathField, NULL, szIconPath);
        if (dwRet == PATH_INVALID) {
            continue;
	    }
	else if (dwRet == PATH_INVALID_OK) {
	    dwFlags |= CI_NO_ASSOCIATION;
	    }

        BuildDescription(szNameField,szPathField);

        GetDirectoryFromPath(szPathField, szDirField);
        if (!InQuotes(szDirField)) {
            CheckEscapes(szDirField, MAXITEMPATHLEN+1);
        }

        HandleDosApps(szIconPath);

        if (!CreateNewItem(hwnd,
                      szNameField,                /* name*/
                      szPathField,                /* command*/
                      szIconPath ,                /* icon path*/
                      szDirField,                 /* no default dir*/
                      0,0,                        /* no hotkey, no min on run*/
                      0,0,0,                      /* default icon*/
                      lppt,                       /* at this point*/
                      dwFlags))
                break;
    }

    DragFinish(hDrop);

    ShowCursor(FALSE);
    SetCursor(hCursor);

    if ((bAutoArrange) && (!bAutoArranging))
        ArrangeItems(hwnd);
    else if (!bAutoArranging)
        CalcGroupScrolls(hwnd);

    return 1L;
}

LRESULT APIENTRY GroupWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    POINT pt;

    switch (uiMsg) {

    case WM_CREATE:
    {
        LPMDICREATESTRUCT lpmdics;

        lpmdics = (LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams);
        SetWindowLongPtr(hwnd, GWLP_PGROUP, lpmdics->lParam);
        DragAcceptFiles(hwnd,TRUE);
        SetFocus(hwnd);
        break;
    }

    case WM_ERASEBKGND:
        if (IsIconic(hwnd)) {
            //
            // Erase background with the APPWORKSPACE color
            //
            RECT rc;

	    if (!hbrWorkspace)
		hbrWorkspace = CreateSolidBrush(GetSysColor(COLOR_APPWORKSPACE));
            GetUpdateRect(hwnd, &rc, FALSE);
            if (IsRectEmpty(&rc)) {
                GetClientRect(hwnd, &rc);
            }
            FillRect((HDC)wParam, &rc, hbrWorkspace);
        }
        else {
            goto DefProc;
        }
        break;

    case WM_PAINT:
        if (IsIconic(hwnd)) {
            DrawGroupIcon(hwnd);
        }
        else {
            PaintGroup(hwnd);
        }
        break;

    case WM_QUERYDRAGICON:
    {
        PGROUP pGroup;
        HICON hIcon = NULL;

        pGroup = (PGROUP)GetWindowLongPtr(hwnd, GWLP_PGROUP);

        if (pGroup->fCommon) {
            hIcon = LoadIcon(hAppInstance, (LPTSTR) MAKEINTRESOURCE(COMMGROUPICON));
        }
        else {
            hIcon = LoadIcon(hAppInstance, (LPTSTR) MAKEINTRESOURCE(PERSGROUPICON));
        }

        if (hIcon) {
            return((LRESULT)hIcon);
        }
        else {
            goto DefProc;
        }

        break;
    }

    case WM_LBUTTONDOWN:
        ClickOn(hwnd, MAKEPOINTS(lParam));
        break;

    case WM_MOUSEMOVE:
        if (wParam & MK_LBUTTON) {
            pt.x = (int)(MAKEPOINTS(lParam).x);
            pt.y = (int)(MAKEPOINTS(lParam).y);
            if (!IsRectEmpty(&rcDrag) && !PtInRect(&rcDrag, pt)
                                    && !fNoFileMenu && (dwEditLevel < 2)) {
                SetRect(&rcDrag,0,0,0,0);
                DragItem(hwnd);
            }
        }
        else {
            SetRect(&rcDrag,0,0,0,0);
        }
        break;

    case WM_LBUTTONUP:
        SetRect(&rcDrag,0,0,0,0);
        break;

    case WM_NCLBUTTONDBLCLK:
        if (IsIconic(hwnd) && (GetKeyState(VK_MENU) < 0)) {
            PostMessage(hwndProgman, WM_COMMAND, IDM_PROPS, 0L);
        } else {
            goto DefProc;
        }
        break;

    case WM_LBUTTONDBLCLK:

        if (ItemHitTest((PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP),
                        MAKEPOINTS(lParam))) {
            if (GetKeyState(VK_MENU) < 0) {
                if (!fNoFileMenu)
                    PostMessage(hwndProgman,WM_COMMAND,IDM_PROPS,0L);
            } else {
                PostMessage(hwndProgman,WM_COMMAND,IDM_OPEN,0L);
            }

        } else {
            /*
             * Check for Alt-dblclk on nothing to get new item.
             */
            if (GetKeyState(VK_MENU) < 0 && !fNoFileMenu &&
                             (dwEditLevel <= 1) && !(pCurrentGroup->fRO) ) {
                MyDialogBox(ITEMDLG, hwndProgman, NewItemDlgProc);
            }
        }
        break;

    case WM_VSCROLL:
    case WM_HSCROLL:
        ScrollMessage(hwnd,uiMsg,wParam,lParam);
        break;

    case WM_CLOSE:
        SendMessage(hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0L);
        break;

    case WM_SYSCOMMAND:
    {
        PGROUP pGroup;
        LPGROUPDEF lpgd;
        TCHAR szCommonGroupSuffix[MAXKEYLEN];
        TCHAR szCommonGroupTitle[2*MAXKEYLEN];

        if (wParam == SC_MINIMIZE) {
            //
            // if the group is common remove the common suffix from the group
            // window title
            //
            pGroup = (PGROUP)GetWindowLongPtr(hwnd, GWLP_PGROUP);
            if (pGroup->fCommon) {
                lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
                SetWindowText(hwnd, (LPTSTR) PTR(lpgd, lpgd->pName));
                GlobalUnlock(pGroup->hGroup);
            }
        }

        if (wParam == SC_RESTORE) {
            if (!LockGroup(hwnd)) {
                if (wLockError == LOCK_LOWMEM) {
                    MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_LOWMEM, NULL, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
                    break;
                }
                else {
                    /*
                     * Lock failed for some other reason - hopefully just
                     * a group change.  Stop the icon group from being
                     * restored.
                     */
                    break;
                }
            }
            else {
        		    UnlockGroup(hwnd);
		      }
        }
    	  if ((wParam == SC_MAXIMIZE) || (wParam == SC_RESTORE)) {
            //
            // if the group is common add the common suffix to the group
            // window title
            //
            pGroup = (PGROUP)GetWindowLongPtr(hwnd, GWLP_PGROUP);
            if (pGroup->fCommon) {
                lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

                if (!lpgd)
                   goto DefProc;

                lstrcpy(szCommonGroupTitle, (LPTSTR) PTR(lpgd, lpgd->pName));
                GlobalUnlock(pGroup->hGroup);
                if (LoadString(hAppInstance, IDS_COMMONGRPSUFFIX, szCommonGroupSuffix,
                               CharSizeOf(szCommonGroupSuffix))) {
                    lstrcat(szCommonGroupTitle, szCommonGroupSuffix);
                }
                SetWindowText(pGroup->hwnd, szCommonGroupTitle);
           }
	        InvalidateRect(hwnd, NULL, 0);
        }
        if (wParam == SC_MAXIMIZE)
	         SetWindowLong(hwnd, GWL_STYLE,
	              (GetWindowLong(hwnd,GWL_STYLE) & ~(WS_HSCROLL | WS_VSCROLL)));
    	  goto DefProc;
			
    }
    case WM_SYSKEYDOWN:
        if (!CheckHotKey(wParam,lParam))
            goto DefProc;
        break;

    case WM_KEYDOWN:
        if (!CheckHotKey(wParam,lParam))
            KeyWindow(hwnd,(WORD)wParam);
        break;

    //IME Support
    //by yutakas 1992.10.22
    // When user input DBCS, go and activate icon which has that
    // DBCS charcter in the first of description.
    case WM_IME_REPORT:
        switch (wParam)
        {
            case IR_STRING:
                IMEStringWindow(hwnd,(HANDLE)lParam);
                return TRUE;
            default:
                goto DefProc;
        }
        break;

    case WM_CHAR:
        CharWindow(hwnd, (WORD) wParam);
        break;

    case WM_QUERYDROPOBJECT:
    {
        #define lpds ((LPDROPSTRUCT)lParam)

        PGROUP pGroup;

        pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);

        if (pGroup->fRO) {
            return FALSE;
        }

    	if (lpds->wFmt == OBJ_ITEM) {
    	    return TRUE;
        }
        #undef lpds
    	goto DefProc;
    }

    case WM_DROPOBJECT:
        #define lpds ((LPDROPSTRUCT)lParam)

        if (lpds->wFmt == OBJ_ITEM)
            return DropObject(hwnd, lpds);
        #undef lpds
        goto DefProc;

    case WM_DROPFILES:
        return DropFiles(hwnd,(HANDLE)wParam);

    case WM_NCACTIVATE:
    {
        PGROUP pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);

        if (pGroup->pItems != NULL) {
            InvalidateRect(hwnd,&pGroup->pItems->rcTitle,TRUE);
        }
        goto DefProc;
    }

    case WM_QUERYOPEN:
    {
        PGROUP pGroup;
        LPGROUPDEF lpgd;
        TCHAR szCommonGroupSuffix[MAXKEYLEN];
        TCHAR szCommonGroupTitle[2*MAXKEYLEN];

        //
        // if the group is common add the common suffix to the group
        // window title
        //
        pGroup = (PGROUP)GetWindowLongPtr(hwnd, GWLP_PGROUP);
        if (pGroup->fCommon) {
            lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);

            if (!lpgd)
               goto DefProc;

            lstrcpy(szCommonGroupTitle,(LPTSTR) PTR(lpgd, lpgd->pName));
            GlobalUnlock(pGroup->hGroup);
            if (LoadString(hAppInstance, IDS_COMMONGRPSUFFIX, szCommonGroupSuffix,
                           CharSizeOf(szCommonGroupSuffix))) {
                lstrcat(szCommonGroupTitle, szCommonGroupSuffix);
            }
            SetWindowText(pGroup->hwnd, szCommonGroupTitle);
        }
        goto DefProc;
    }

    case WM_SIZE:
        lParam = DefMDIChildProc(hwnd, uiMsg, wParam, lParam);
        if (wParam != SIZEICONIC) {
            if ((bAutoArrange) && (!bAutoArranging)) {
                ArrangeItems(hwnd);
            } else if (!bArranging) {
                CalcGroupScrolls(hwnd);
            }
        }
        else {
            PGROUP pGroup;
            LPGROUPDEF lpgd;

            //
            // reset window text of common groups
            //
            pGroup = (PGROUP)GetWindowLongPtr(hwnd, GWLP_PGROUP);
            if (pGroup->fCommon) {
                lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup);
                SetWindowText(pGroup->hwnd, (LPTSTR) PTR(lpgd, lpgd->pName));
                GlobalUnlock(pGroup->hGroup);
            }
        }
        return lParam;

    case WM_MDIACTIVATE:
        if (!pCurrentGroup) {
            goto DefProc;
        }

        /*
         * If we are de-activating this window...
         */
        if (lParam == 0) {
            /*
             * We're the last window... punt.
             */
            pCurrentGroup = NULL;

        } else if (hwnd == (HWND)wParam) {
            /*
             * We're being deactivated.  Update pCurrentGroup
             * to the node being activated.
             */
            pCurrentGroup = (PGROUP)GetWindowLongPtr((HWND)lParam, GWLP_PGROUP);

        } else {
            SetFocus(hwnd);
        }

        goto DefProc;

    case WM_MENUSELECT:
        //
        // to handle F1 on group window system menu
        //

        if (lParam) {        /*make sure menu handle isn't null*/
            wMenuID =  GET_WM_COMMAND_ID(wParam, lParam);    /*get cmd from loword of wParam*/
            hSaveMenuHandle = (HANDLE)lParam;    /*Save hMenu into one variable*/
            wSaveFlags = HIWORD(wParam);/*Save flags into another*/
            bFrameSysMenu = FALSE;
        }

        break;

    default:
DefProc:
        return DefMDIChildProc(hwnd, uiMsg, wParam, lParam);
    }

    return 0L;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ArrangeItems() -                                                        */
/*                                                                          */
/* Arranges iconic windows within a group.                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID FAR PASCAL ArrangeItems(HWND hwnd)
{
    PGROUP pGroup;
    register PITEM pItem;
    PITEM pItemT;
    int xSlots;
    register int i;
    int j,k;
    RECT rc;
    LPGROUPDEF lpgd;
    PITEM rgpitem[CITEMSMAX];
    POINT pt;
    int t1, t2;
    LONG style;

    if (bAutoArranging || IsIconic(hwnd))
        return;

    pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);
    if (!pGroup)
        return;

    /*
     * If the group is RO then don't rearrange the items, just update the
     * scroll bars
     */
    if (!GroupCheck(pGroup)) {
        CalcGroupScrolls(hwnd);
        return;
    }

    bAutoArranging = TRUE;
    SetRectEmpty(&rcArrangeRect);

    style = GetWindowLong(hwnd,GWL_STYLE);
    GetRealClientRect(hwnd,style&~(WS_VSCROLL|WS_HSCROLL),&rc);
    SetWindowLong(hwnd,GWL_STYLE,style);

    xSlots = (rc.right - rc.left)/cxArrange;
    if (xSlots < 1)
        xSlots = 1;

    /* sort the items by x location within a row, or by row if the
     * rows are different
     */
    k = 0;
    for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext) {
        /* find nearest row
         */
        t1 = pItem->rcIcon.top + cyArrange/2;
        if (t1 >= 0)
	        t1 -= t1 % cyArrange;
        else
	        t1 += t1 % cyArrange;

        for (i = 0; i < k; i++) {
            pItemT = rgpitem[i];

            t2 = pItemT->rcIcon.top + cyArrange/2;
            if (t2 >= 0)
	            t2 -= t2 % cyArrange;
            else
	            t2 += t2 % cyArrange;

            if (t2 > t1)
                break;
            else if (t2 == t1 && pItemT->rcIcon.left > pItem->rcIcon.left)
                break;
        }

        for (j = k; j > i; j--) {
            rgpitem[j] = rgpitem[j-1];
        }

        rgpitem[i] = pItem;

        k++;
    }

    lpgd = LockGroup(hwnd);
    if (!lpgd) {
        bAutoArranging = FALSE;
        return;
    }

    bNoScrollCalc = TRUE;
    for (i = 0; i < k; i++) {
        pItem = rgpitem[i];

        /* cxOffset necessary to match (buggy???) win 3 USER
         */
        pt.x = (i%xSlots)*cxArrange + (cxArrange-cxIconSpace)/2 + cxOffset;
        pt.y = (i/xSlots)*cyArrange;

        MoveItem(pGroup,pItem,pt);
    }

    if (!IsRectEmpty(&rcArrangeRect))
        InvalidateRect(pGroup->hwnd,&rcArrangeRect,TRUE);

    UnlockGroup(hwnd);
    bNoScrollCalc = FALSE;
    CalcGroupScrolls(hwnd);

    bAutoArranging = FALSE;
}

/****************************************************************************
 *
 *  IMEStringWindow(hwnd,hstr)
 *
 *  Change activate item by the strings come from IME.
 *  When Get WM_IME_REPORT with IR_STRING,this function is called.
 *
 *                         by yutakas 1992.10.22
 *
 ****************************************************************************/
BOOL FAR PASCAL IMEStringWindow(HWND hwnd, HANDLE hStr)
{
    LPTSTR lpStr;
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    PGROUP pGroup;
    PITEM pItem = NULL;
    PITEM pItemLast,pTItem;
    int nCnt = 0;
    int nTCnt = 0;
    BOOL ret = FALSE;

    if (!hStr)
        return ret;

    if (!(lpStr = GlobalLock(hStr)))
        return ret;

    pGroup = (PGROUP)GetWindowLongPtr(hwnd,GWLP_PGROUP);

    if (!pGroup->pItems)
        return ret;

    lpgd = LockGroup(hwnd);
    if (!lpgd)
        return ret;

#ifdef _DEBUG
{
TCHAR szDev[80];
OutputDebugString((LPTSTR)TEXT("In IME Winsdow\r\n"));
wsprintf ((LPTSTR)szDev,TEXT("IMEStringWindow: lpStr is %s \r\n"),lpStr);
OutputDebugString((LPSTR)szDev);
}
#endif


    // Search for item, skip the currently selected one.
    for ( pTItem = pGroup->pItems->pNext; pTItem; pTItem=pTItem->pNext)
    {
        lpid = ITEM(lpgd,pTItem->iItem);
        nTCnt = IMEWindowGetCnt(lpStr,(LPTSTR)PTR(lpgd,lpid->pName));
        if (nCnt < nTCnt)
        {
            nCnt = nTCnt;
            pItem = pTItem;
        }
    }

    lpid = ITEM(lpgd,pGroup->pItems->iItem);
    nTCnt = IMEWindowGetCnt(lpStr,(LPTSTR)PTR(lpgd,lpid->pName));

    if ((nCnt >= nTCnt) && pItem)
      {
        pItemLast = MakeFirstItemLast(pGroup);
        BringItemToTop(pGroup,pItem, FALSE);
        // Handle updates.
        InvalidateRect(pGroup->hwnd,&pItem->rcTitle,TRUE);
        InvalidateRect(pGroup->hwnd,&pItemLast->rcTitle,TRUE);
        ViewActiveItem(pGroup);
        ret = TRUE;
      }


    GlobalUnlock(hStr);
    UnlockGroup(hwnd);

#ifdef _DEBUG
{
TCHAR szDev[80];
wsprintf ((LPTSTR)szDev,TEXT("IMEStringWindow: ret is %s \r\n"),ret);
OutputDebugString((LPTSTR)szDev);
}
#endif
    return ret;
}

/****************************************************************************
 *
 *  IMEWindowGetCnt(LPSTR,LPSTR)
 *
 *  Compare strings from ahead and return the number of same character
 *
 *                         by yutakas 1992.10.22
 *
 *
 ****************************************************************************/
int FAR PASCAL IMEWindowGetCnt(LPTSTR lp1, LPTSTR lp2)
{
    int cnt = 0;

    while (*lp1 && *lp2)
    {
        // ToddB: This typecasting is to prevent lp1 and lp2 from being modified
        //      by CharUpper'ing one char at a time instead of the whole string
        if (CharUpper((LPTSTR)(DWORD_PTR)(BYTE)*lp1) ==
                CharUpper((LPTSTR)(DWORD_PTR)(BYTE)*lp2))
        {
            cnt++;
        }
        else
            break;

        lp1++;
        lp2++;
    }

    return (*lp1 ? 0 : cnt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmreg.h ===
/* for Program Groups in Registry */
#define MAXKEYLEN      100

extern TCHAR           szAnsiProgramGroups[MAXKEYLEN+1];
extern HKEY            hkeyProgramManager;
extern HKEY            hkeyPMSettings;
extern HKEY            hkeyPMRestrict;
extern HKEY            hkeyPMGroups;
extern HKEY            hkeyPMCommonGroups;
extern HKEY            hkeyPMAnsiGroups;
extern HKEY            hkeyAnsiProgramGroups;
extern HKEY            hkeyProgramGroups;
extern HKEY            hkeyCommonGroups;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\sec.h ===
/****************************** Module Header ******************************\
* Module Name: winlogon.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Main header file for winlogon
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winuserp.h>

//
// Include individual module header files
//
#include "secdesc.h"
#include "security.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\secdesc.h ===
/****************************** Module Header ******************************\
* Module Name: secdesc.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines apis and types used to implement security descriptor helper routines
*
* History:
* 02-06-92 Davidc       Created.
\***************************************************************************/

//
// Types used by security descriptor helper routines
//

typedef LONG    ACEINDEX;
typedef ACEINDEX *PACEINDEX;

typedef struct _MYACE {
    PSID    Sid;
    ACCESS_MASK AccessMask;
    UCHAR   InheritFlags;
} MYACE;
typedef MYACE *PMYACE;


//
// Exported function prototypes
//

PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    PMYACE  MyAce,
    ACEINDEX AceCount
    );

BOOL
DeleteSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmhelp.h ===
#define IDH_HELPFIRST		5000

#define IDH_SYSMENU	        (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST	        (IDH_HELPFIRST + 2001)
#define IDH_RUNBROWSEDLG	(IDH_HELPFIRST + 2001)
#define IDH_PROPBROWSEDLG	(IDH_HELPFIRST + 2002)
#define IDH_ICONBROWSEDLG	(IDH_HELPFIRST + 2003)
#define IDH_MOVEDLG         (IDH_HELPFIRST + 2004)
#define IDH_COPYDLG         (IDH_HELPFIRST + 2005)
#define IDH_PROG_NOT_FOUND	(IDH_HELPFIRST + 2006)
#define IDH_PROG_NOT_FOUND_BROWSE	(IDH_HELPFIRST + 2007)
#define IDH_MBLAST	        (IDH_HELPFIRST + 2099)

#define IDH_SYSMENUCHILD        (IDH_HELPFIRST + 2100)

#define IDH_DLGFIRST	(IDH_HELPFIRST + 3000)
#define IDH_ABOUTDLG 	(IDH_DLGFIRST + ABOUTDLG)
#define IDH_BROWSEDLG 	(IDH_DLGFIRST + BROWSEDLG)
#define IDH_CHOOSERDLG 	(IDH_DLGFIRST + CHOOSERDLG)
#define IDH_EXITDLG 	(IDH_DLGFIRST + EXITDLG)
#define IDH_GROUPDLG 	(IDH_DLGFIRST + GROUPDLG)
#define IDH_ICONDLG 	(IDH_DLGFIRST + ICONDLG)
#define IDH_ITEMDLG 	(IDH_DLGFIRST + ITEMDLG)
#define IDH_RUNDLG 	    (IDH_DLGFIRST + RUNDLG)
#define IDH_UPDATEGRPDLG (IDH_HELPFIRST + UPDATEGROUPSDLG);


#define IDH_FILE 	    (IDH_HELPFIRST + IDM_FILE)
#define IDH_NEW  	    (IDH_HELPFIRST + IDM_NEW )
#define IDH_OPEN 	    (IDH_HELPFIRST + IDM_OPEN)
#define IDH_MOVE	    (IDH_HELPFIRST + IDM_MOVE)
#define IDH_COPY	    (IDH_HELPFIRST + IDM_COPY)
#define IDH_DELETE 	    (IDH_HELPFIRST + IDM_DELETE)
#define IDH_PROPS 	    (IDH_HELPFIRST + IDM_PROPS)
#define IDH_RUN		    (IDH_HELPFIRST + IDM_RUN)
#define IDH_EXIT 	    (IDH_HELPFIRST + IDM_EXIT)
#define IDH_SHUTDOWN	    (IDH_HELPFIRST + IDM_SHUTDOWN)
#define IDH_SAVE 	    (IDH_HELPFIRST + IDM_SAVE)
#define IDH_OPTIONS 	(IDH_HELPFIRST + IDM_OPTIONS)
#define IDH_AUTOARRANGE (IDH_HELPFIRST + IDM_AUTOARRANGE )
#define IDH_MINONRUN 	(IDH_HELPFIRST + IDM_MINONRUN)
#define IDH_SAVESETTINGS 	(IDH_HELPFIRST + IDM_SAVESETTINGS)
#define IDH_SAVENOW 	(IDH_HELPFIRST + IDM_SAVENOW)
#define IDH_WINDOW 	    (IDH_HELPFIRST + IDM_WINDOW)
#define IDH_CASCADE 	(IDH_HELPFIRST + IDM_CASCADE)
#define IDH_TILE 	    (IDH_HELPFIRST + IDM_TILE)
#define IDH_ARRANGEICONS 	(IDH_HELPFIRST + IDM_ARRANGEICONS)

#define IDH_CHILDSTART 	(IDH_HELPFIRST + IDM_CHILDSTART)
#define IDH_HELPGENERAL	(IDH_HELPFIRST + IDM_HELP)
#define IDH_HELPINDEX 	(IDH_HELPFIRST + IDM_HELPINDEX)
#define IDH_HELPSEARCH 	(IDH_HELPFIRST + IDM_HELPSEARCH)
#define IDH_HELPHELP 	(IDH_HELPFIRST + IDM_HELPHELP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pmwprocs.c ===
/*
 * pmwprocs.c - window procs for program manager
 *
 *  Copyright (c) 1991,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *        This file is for support of program manager under NT Windows.
 *        This file is/was ported from pmwprocs.c (program manager).
 *
 *  MODIFICATION HISTORY
 *      Initial Version: x/x/90    Author Unknown, since he didn't feel
 *                                like commenting the code...
 *
 *      NT 32b Version:     1/18/91    Jeff Pack
 *                                Intitial port to begin.
 *
 *
 */

#include "progman.h"
#include "dde.h"

extern BOOL bInNtSetup;

/****************************************************************************
 *
 * SetProgmanProperties(DWORD dwDdeId, WORD wHotKey)
 *
 * Called when a new instance of progman was started from a Progman group
 * item. This will set the properties of the first instance of Progman,
 * setting the hotkey, the window title, the icon, and minimize Progman
 * if the item has Run Mimimized set.
 *
 * Called when Progman receives WM_EXECINSTANCE message send from 2nd progman
 * instance.
 *
 * 08-28-92 JohanneC   Created.
 *
 ****************************************************************************/


BOOL SetProgmanProperties(DWORD dwDdeId, WORD wHotKey)
{
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    PGROUP pGroup = NULL;
    PITEM pItem = NULL;
    HWND hwndT;
    BOOL Found = FALSE;
    HICON hIcon;
    BOOL bWasIconic = FALSE;

    //
    // Set Progman's hotkey.
    //
    SendMessage(hwndProgman, WM_SETHOTKEY, wHotKey, 0L);

    //
    // Find the group and the item corresponding to this information.
    //
    for (hwndT = GetWindow(hwndMDIClient, GW_CHILD);
         hwndT;
         hwndT = GetWindow(hwndT, GW_HWNDNEXT)) {

        if (GetWindow(hwndT, GW_OWNER))
            continue;

        pGroup = (PGROUP)GetWindowLongPtr(hwndT, GWLP_PGROUP);
        for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext) {
            if (pItem->dwDDEId == dwDdeId) {

                //
                // Found a match.
                //
                Found = TRUE;
                break;
            }
        }
        if (Found)
            break;
    }

    if (!Found)
        return(FALSE);

    //
    // Set Progman Properties using the properties of its item.
    //

    //
    // Set the new icon.
    //
    hIcon = DuplicateIcon(hAppInstance, GetItemIcon(pGroup->hwnd, pItem));
    if (hIcon) {
        HICON hiconOld = (HICON)GetClassLongPtr(hwndProgman, GCLP_HICON);
        if (hiconOld)
        {
            DestroyIcon(hiconOld);
        }
        SetClassLongPtr(hwndProgman, GCLP_HICON, (LONG_PTR)hIcon);
    }

    if (IsIconic(hwndProgman))
        bWasIconic = TRUE;

    //
    // Check the minimize flag.
    //
    lpgd = GlobalLock(pGroup->hGroup);
    if (lpgd) {
        lpid = ITEM(lpgd, pItem->iItem);
        SetWindowText(hwndProgman, (LPTSTR) PTR(lpgd, lpid->pName));
        if (GroupFlag(pGroup, pItem, (WORD)ID_MINIMIZE))
            ShowWindow(hwndProgman, SW_SHOWMINNOACTIVE);
        GlobalUnlock(pGroup->hGroup);
    }

    if (bWasIconic) {
        //
        // to update the icon and text.
        //
        ShowWindow(hwndProgman, SW_HIDE);
        ShowWindow(hwndProgman, SW_SHOW);
    }

    return(TRUE);
}

void NEAR PASCAL RedoAllIconTitles()
    // Stomps on all the title rects.
    {
    HWND hwndGroup;
    PGROUP pGroup;
    PITEM  pItem;
    HDC hdc;
    int cch;
    HFONT hFontT;
    LPRECT lprcTitle;
    LPTSTR lpText;
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    POINT pt;

    for (hwndGroup=GetWindow(hwndMDIClient, GW_CHILD); hwndGroup; hwndGroup=GetWindow(hwndGroup, GW_HWNDNEXT))
        {
        if (GetWindow(hwndGroup, GW_OWNER))
    	    continue;

        pGroup = (PGROUP)GetWindowLongPtr(hwndGroup, GWLP_PGROUP);

        lpgd = LockGroup(hwndGroup);
        if (!lpgd)
            {
            continue;
            }

        for (pItem = pGroup->pItems; pItem; pItem = pItem->pNext)
            {
    	    lprcTitle = &(pItem->rcTitle);
            lpid = ITEM(lpgd, pItem->iItem);
            lpText = (LPTSTR) PTR(lpgd, lpid->pName);
            pt.x = pItem->rcIcon.left;
            pt.y = pItem->rcIcon.top;

            cch = lstrlen(lpText);

    	    hdc = GetDC(pGroup->hwnd);
	        hFontT = SelectObject(hdc,hFontTitle);

	        // compute the icon rect using DrawText
            SetRectEmpty(lprcTitle);
    	    lprcTitle->right = cxArrange - (2 * cxOffset);
            DrawText(hdc, lpText, -1,
                lprcTitle, bIconTitleWrap ?
                DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX :
                DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);

            if (hFontT)
                SelectObject(hdc,hFontT);
    	    ReleaseDC(pGroup->hwnd,hdc);
            lprcTitle->right += cxOffset*2;
            lprcTitle->bottom+= dyBorder*2;
            OffsetRect
                (
                lprcTitle,
                (pt.x+(cxIconSpace/2)-((lprcTitle->right
                    -lprcTitle->left)/2)),
                (pt.y+cyIconSpace-dyBorder)
                );
            }
            UnlockGroup(hwndGroup);

        }
    }

/*** GetRealParent --
 *
 *
 * HWND APIENTRY GetRealParent(HWND hWnd)
 *
 * ENTRY -     HWND    hWnd
 *
 * EXIT  -    HWND
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

HWND APIENTRY GetRealParent(HWND hwnd)
{
    /* run up the parent chain until you find a hwnd */
    /* that doesn't have WS_CHILD set*/

    /* BUG BUG, these should work as is????*/
    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD){
        hwnd = (HANDLE) GetWindowLongPtr(hwnd, GWLP_HWNDPARENT);
    }
    return hwnd;
}

/*** AnyWriteable --
 *
 *
 * BOOL APIENTRY AnyWriteable()
 *
 * ENTRY -     none
 *
 * EXIT  -    BOOL    xxx -  TRUE if read only, FALSE if not
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

BOOL APIENTRY AnyWriteable()
{
    PGROUP pGroup;

    for (pGroup=pFirstGroup; pGroup; pGroup = pGroup->pNext)
    if (!pGroup->fRO){
        return TRUE;
    }

    return FALSE;
}

/*** ProgmanProc -- window procedure for program manager
 *
 *
 * LONG APIENTRY ProgmanWndProc(register HWND hwnd, UINT uiMsg,
 *                                register WPARAM wParam, LONG lParam)
 *
 * ENTRY -    HWND    hWnd
 *            WORD    uiMsg
 *            WPARAM  wParam
 *            LONG    lParam
 * EXIT  -    LONG    xxx - returns info, or zero, for nothing to return
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

LRESULT APIENTRY ProgmanWndProc(
    HWND hWnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uiMsg) {

    case WM_CREATE:
    {
        RECT rc;
        CLIENTCREATESTRUCT ccs;

        hwndProgman = hWnd;

        ccs.hWindowMenu = GetSubMenu(GetMenu(hWnd), IDM_WINDOW);
        ccs.idFirstChild = IDM_CHILDSTART;

        GetClientRect(hwndProgman, &rc);

	    /*
         * Don't show the MDI client until all groups have
	     * been created to avoid ungly painting.
         */

        hwndMDIClient = CreateWindow(TEXT("MDIClient"),
                                NULL,
                                WS_CLIPCHILDREN | WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_BORDER,
                                rc.left - 1, rc.top - 1,
                                rc.right + 2, rc.bottom + 2,
                                hWnd, (HMENU)1, hAppInstance,
                                (LPTSTR)&ccs);
        if (!hwndMDIClient) {
            return -1;
        }
        break;
    }

    case WM_ENDSESSION:
        if (wParam != 0) {  // nonzero means the session is being ended.
EndSession:
            /* Don't close if restricted. */
            if (fNoClose)
                break;

            if (bSaveSettings)
                WriteINIFile();
            else
                SaveGroupsContent(FALSE);

            //
            // should Flush and close all registry keys here.
            //
            RegFlushKey(HKEY_CURRENT_USER);
            if (hkeyProgramManager) {
                if (hkeyPMSettings) {
                    RegCloseKey(hkeyPMSettings);
                }
                if (hkeyPMGroups) {
                    RegCloseKey(hkeyPMGroups);
                }
                RegCloseKey(hkeyProgramManager);
            }

            if (hkeyProgramGroups) {
                RegCloseKey(hkeyProgramGroups);
            }

            if (hkeyCommonGroups) {
                RegFlushKey(hkeyCommonGroups);
                RegCloseKey(hkeyCommonGroups);
            }

            /* Free the commdlg */
            if (hCommdlg)
                FreeLibrary(hCommdlg);

	        ExitProcess(0);
            }

        break;

    case WM_CLOSE:
        /*
	 * if wParam != 0, then this is shutdown. We don't want to logoff
	 * again in this case, because we're already in the middle of
	 * logoff. We just want to exit now.
         */

        if (wParam != 0)
            goto EndSession;

        /* Don't close if restricted. */
        if (fNoClose)
            return FALSE;

	    if (GetKeyState(VK_SHIFT) < 0) {
            WriteINIFile();
    	    return TRUE;
        }

        /* Check if we've already tried to exit once... */
        if (fExiting) {
            SetCurrentDirectory(szOriginalDirectory);
            ExitWindows(0, 0);
        }

        fExiting = TRUE;      // Stop LockGroup from trying to do a RELOAD
                              // if the a lock fails due to group being
                              // out of date.
        SetWindowLong (hwndProgman, GWL_EXITING, 1);

    	if (bExitWindows) {

            if (lParam != (LPARAM)-1) {
                //
                // The user double-clicked on the system menu, use the new
                // logoff dialog.
                //

                if (MyDialogBox(NEWLOGOFFDLG,
                             hwndProgman,
                             NewLogoffDlgProc)) {
                }
            }
            else {
                if (MyDialogBox(IDD_END_WINDOWS_SESSION,
                             hwndProgman,
                             ExitDlgProc)) {
                    SetCurrentDirectory(szOriginalDirectory);
                    ExitWindows(0, 0);
                }
            }

            /* User clicked cancel or some app refused the ExitWindows... */
            fExiting = FALSE;
            SetWindowLong (hwndProgman, GWL_EXITING, 0);
            break;
        }
        else {

            if (bSaveSettings)
                WriteINIFile();
            else {
                //
                // If we are in setup, the groups and settings
                // will have already been saved in the
                // ExitProgman(1) dde handler.
                //

                if (!bInNtSetup)
                    SaveGroupsContent(FALSE);
            }

            goto CallDFP;
        }

    case WM_LOGOFF:
        DestroyWindow(hwndProgman);
        return 0;

    case WM_DESTROY:
        if (!WinHelp(hwndProgman, szProgmanHelp, HELP_QUIT, 0L)) {
            MyMessageBox(hwndProgman, IDS_APPTITLE, IDS_WINHELPERR, NULL, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
        }

        /* Free font. */
        DeleteObject(hFontTitle);

        /* Free the commdlg junk. */
        if (hCommdlg)
            FreeLibrary(hCommdlg);

        /*
         * If user hit CTRL-ALT-DEL to logoff, restart or shutdown,
         * we still need to save the settings.
         */
        if (!fExiting && bSaveSettings) {
            WriteINIFile();
        }
        else
            SaveGroupsContent(FALSE);

	    if (hbrWorkspace) {
	        DeleteObject(hbrWorkspace);
	        hbrWorkspace = NULL;
	    }

        /*
         * Stop all translations
         */
        hwndMDIClient = NULL;
        hwndProgman = NULL;
        PostQuitMessage(0);
        break;

    case WM_DDE_TERMINATE:
    case WM_DDE_EXECUTE:
    case WM_DDE_ACK:
    case WM_DDE_REQUEST:
    case WM_DDE_DATA:
    case WM_DDE_ADVISE:
    case WM_DDE_UNADVISE:
    case WM_DDE_POKE:
    case WM_DDE_INITIATE:
#ifdef DEBUG_PROGMAN_DDE
        {
        TCHAR szDebug[300];

        wsprintf (szDebug, TEXT("%d   PROGMAN:   Received DDE msg 0x%x\r\n"),
                  GetTickCount(), uiMsg);
        OutputDebugString(szDebug);
        }
#endif
        if (!bDisableDDE)
        {
            return (DDEMsgProc(hWnd, uiMsg, wParam, lParam));
        }
        goto CallDFP;

    case WM_INITMENU:
    {
        BOOL bGroup;
        WORD wEnable;
        INT i;
        PGROUP pGroup;

        bGroup = (SelectionType() != TYPE_ITEM);

        /*
         * Disable Delete/Properties if there aren't any groups.
         */
        if (!pCurrentGroup) {
            wEnable = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
        } else {
            wEnable = MF_BYCOMMAND | MF_ENABLED;
        }

        EnableMenuItem((HMENU)wParam, IDM_PROPS,  wEnable);

        if ((pCurrentGroup && pCurrentGroup->fRO) || dwEditLevel >= 2
               || (dwEditLevel == 1 && bGroup)) {
            wEnable = MF_BYCOMMAND | MF_GRAYED | MF_DISABLED;
        }

        EnableMenuItem((HMENU)wParam, IDM_DELETE, wEnable);

        /* Handle ArrangeItems menu... */
	    if (pCurrentGroup && pCurrentGroup->fRO && !bGroup)
	        wEnable = MF_BYCOMMAND | MF_GRAYED | MF_DISABLED;
        else
	        wEnable = MF_BYCOMMAND | MF_ENABLED;
	    EnableMenuItem((HMENU)wParam, IDM_ARRANGEICONS, wEnable);

        /*
         * Disable Move/Copy if 1. There aren't any groups,
         *                      2. There aren't any items in the group,
         *                      3. A group is selected.
         *                      4. The group is read only.
         *                      5. Restrictions do not permit it.
         *                      6.There is only one group - just move
         *                        disabled.
         */
        if (!pCurrentGroup || !pCurrentGroup->pItems ||
                    bGroup || !AnyWriteable() || dwEditLevel >= 2) {
            wEnable = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
        } else {
            wEnable = MF_BYCOMMAND | MF_ENABLED;
        }

        EnableMenuItem((HMENU)wParam, IDM_COPY, wEnable);

        if (pCurrentGroup && pCurrentGroup->fRO) {
            wEnable = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
        }
        EnableMenuItem((HMENU)wParam, IDM_MOVE, wEnable);

        i = 0;
        for (pGroup=pFirstGroup; pGroup; pGroup = pGroup->pNext) {
            if (!pGroup->fRO)
                i++;
        }
        if (i<2) {
	        wEnable = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
	        EnableMenuItem((HMENU)wParam, IDM_MOVE, wEnable);
        }

        /*
         * Disable Open if  1. There aren't any groups,
         *                  2. An empty, non-minimized group is selected.
         */
        if ((!pCurrentGroup) || (!bGroup && (!pCurrentGroup->pItems)
                && (!IsIconic(pCurrentGroup->hwnd)))) {
            wEnable = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
        } else {
            wEnable = MF_BYCOMMAND | MF_ENABLED;
        }
        EnableMenuItem((HMENU)wParam, IDM_OPEN, wEnable);

        /*
         * Grey new if
         *   can't create items, or
         *   can't create groups and either the group is read only (can't
         *     create an item in it) or a group is selected
         */
        if (dwEditLevel >= 2 || (dwEditLevel >= 1 &&
                    (bGroup || pCurrentGroup->fRO))) {
            wEnable = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
        } else {
            wEnable = MF_BYCOMMAND | MF_ENABLED;
        }
        EnableMenuItem((HMENU)wParam, IDM_NEW, wEnable);

        if (fNoRun) {
            EnableMenuItem((HMENU)wParam, IDM_RUN,
                        MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        if (fNoClose) {
            EnableMenuItem((HMENU)wParam, IDM_EXIT,
                        MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

            wParam = (WPARAM)GetSystemMenu(hWnd, FALSE);
            EnableMenuItem((HMENU)wParam, (WORD)SC_CLOSE,
                        MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }
        break;
    }

    case WM_SIZE:
        if (wParam != SIZEICONIC) {
            MoveWindow(hwndMDIClient, -1, -1, LOWORD(lParam) + 2,
                    HIWORD(lParam) + 2, TRUE);
        }
        break;

    case WM_SYSCOLORCHANGE:
	    if (hbrWorkspace) {
    	    DeleteObject(hbrWorkspace);
	    }
	    hbrWorkspace = CreateSolidBrush(GetSysColor(COLOR_APPWORKSPACE));

	    //
	    // Fall thru
	    //

    case WM_WININICHANGE:
    {
	    PGROUP pGroup;
        BOOL bOldIconTitleWrap;
        PVOID pEnv ;

        if (lstrcmpi((LPTSTR)lParam,TEXT("Environment")) ==0) {
	    //
            // Check if the user's environment variables have changed, if so
            // regenerate the environment.
            //
            RegenerateUserEnvironment(&pEnv, TRUE);
            break;
        }

        bOldIconTitleWrap = bIconTitleWrap;

        SystemParametersInfo(SPI_ICONHORIZONTALSPACING, 0, (PVOID)&cxArrange, FALSE);
        SystemParametersInfo(SPI_ICONVERTICALSPACING, 0, (PVOID)&cyArrange, FALSE);
        SystemParametersInfo(SPI_GETICONTITLEWRAP, 0, (PVOID)&bIconTitleWrap, FALSE);

        // Handle title wrapping.
        if (bOldIconTitleWrap != bIconTitleWrap)
            RedoAllIconTitles();
	    for (pGroup = pFirstGroup; pGroup; pGroup = pGroup->pNext) {
	        NukeIconBitmap(pGroup);
            if (bAutoArrange) {
                ArrangeItems(pGroup->hwnd);
            }
	    }

        InvalidateRect(hWnd, NULL, TRUE);
        break;
    }

    case WM_MENUSELECT:

        if (lParam) {        /*make sure menu handle isn't null*/
            wMenuID =  GET_WM_COMMAND_ID(wParam, lParam);    /*get cmd from loword of wParam*/
            hSaveMenuHandle = (HANDLE)lParam;    /*Save hMenu into one variable*/
            wSaveFlags = HIWORD(wParam);/*Save flags into another*/
            if (wMenuID >= IDM_CHILDSTART && wMenuID < IDM_HELPINDEX)  {
                wMenuID = IDM_CHILDSTART;
            }
            bFrameSysMenu = (hSaveMenuHandle == GetSystemMenu(hwndProgman, FALSE));
            if (!bFrameSysMenu && wMenuID >= 0xf000) {
                //
                // According to winhelp: GetSystemMenu, uMenuID >= 0xf000
                // means system menu items!
                //
                // The group window is maximized, and group system menu
                // was selected
                //
                wSaveFlags |= MF_SYSMENU;
            }
        }
        break;

    case WM_EXECINSTANCE:
    {
        /*
         * Another instance of program manager has been started.
         * This can not be checked using the Windows 3.1 way because
         * starting apps is done asynchronously in NT, and the values
         * of pExecingGroup, pExecingItem and fInExec will always be FALSE.
         *
         * So we use the lpReserved field in the startupInfo structure
         * of the other instance to make sure is was called from progman.
         * This string is of the format "dde.%d,hotkey.%d" and it is
         * parsed in the other instance to extract the dde id and the hotkey.
         * These are passed as wParam and lParam respectively in the
         * WM_EXECINSTANCE message.
         *
         * - johannec 8/28/92
         */
        if (wParam) {
            SetProgmanProperties((DWORD)wParam, (WORD)lParam);
        }
        else {
            /*
             * The user isn't trying to run progman from within progman
             * so just show them that there's a progman already running...
             */
	        if (IsIconic(hWnd))
	            ShowWindow(hWnd,SW_SHOWNORMAL);
           SetForegroundWindow(hWnd);
	        BringWindowToTop(hWnd);
	        BringWindowToTop(GetLastActivePopup(hWnd));
        }
        break;
    }

    case WM_UNLOADGROUP:
        UnloadGroupWindow((HWND)wParam);
        break;

    case WM_RELOADGROUP:
    {
        TCHAR szGroupKey[MAXKEYLEN+1];
        WORD idGroup;
        BOOL bCommonGroup;

        lstrcpy(szGroupKey,((PGROUP)wParam)->lpKey);
        idGroup = ((PGROUP)wParam)->wIndex;
        bCommonGroup = ((PGROUP)wParam)->fCommon;
        UnloadGroupWindow(((PGROUP)wParam)->hwnd);
        fLowMemErrYet = FALSE;
        LoadGroupWindow(szGroupKey,idGroup, bCommonGroup);
        MyMessageBox(hwndProgman, IDS_GROUPFILEERR, IDS_GRPHASCHANGED,
                    /* szGroupKey */ NULL, MB_OK | MB_ICONEXCLAMATION);
        break;
    }

    case WM_SYSCOMMAND:
        if (fNoClose && wParam == SC_CLOSE ||
            fNoClose && wParam == IDM_EXIT ||
            fNoClose && wParam == IDM_SHUTDOWN ) {
            break;
        }
        if (wParam == IDM_EXIT) {
            if (fNoFileMenu)
                break;

            PostMessage(hwndProgman, WM_CLOSE, 0, (LPARAM)-1);
	        break;
        }
        if (wParam == IDM_SHUTDOWN) {
            if (fNoFileMenu)
                break;

            if (bExitWindows) {

                fExiting = TRUE;
                SetWindowLong (hwndProgman, GWL_EXITING, 1);

                /* Call the ShutdownDialog API. */
                ShutdownDialog(hAppInstance, hwndProgman);

                /* User clicked cancel or some app refused the ExitWindows... */
                fExiting = FALSE;
                SetWindowLong (hwndProgman, GWL_EXITING, 0);
	        }
            break;
        }
        goto CallDFP;

    case WM_COMMAND:
        if (ProgmanCommandProc(hWnd, wParam, lParam)) {
            break;
        }
        goto CallDFP;

    default:

        if (uiMsg == uiActivateShellWindowMessage) {
	        if (IsIconic(hwndProgman))
	            ShowWindow(hwndProgman, SW_RESTORE);
	        else
                BringWindowToTop(hwndProgman);

        } else if (uiMsg == uiConsoleWindowMessage) {
            PostMessage((HWND)wParam, uiConsoleWindowMessage, (WPARAM)hWnd, 0);

        } else if (uiMsg == uiSaveSettingsMessage) {
            WriteINIFile();

        } else if (uiMsg == uiHelpMessage) {
               if (wParam == MSGF_MENU) {
                /*
                 * Get outta menu mode if help for a menu item.
                 */

                if (wMenuID && hSaveMenuHandle) {
                    wSaveMenuIDAroundSendMessage = wMenuID;    /* save*/
                    hSaveMenuHandleAroundSendMessage = hSaveMenuHandle;
                    wSaveFlagsAroundSendMessage = wSaveFlags;

                    SendMessage(hWnd, WM_CANCELMODE, 0, 0L);
                    wMenuID = wSaveMenuIDAroundSendMessage;    /* restore*/
                    hSaveMenuHandle = hSaveMenuHandleAroundSendMessage;
                    wSaveFlags = wSaveFlagsAroundSendMessage;
                }

                if (!(wSaveFlags & MF_POPUP)) {

                    if (wSaveFlags & MF_SYSMENU){
                        dwContext = bFrameSysMenu ? IDH_SYSMENU : IDH_SYSMENUCHILD;
                    }
                    else {
                        dwContext = wMenuID + IDH_HELPFIRST;
                    }

                    PMHelp(hWnd);
                }
            }
            else if (wParam == MSGF_DIALOGBOX) {
                /* context range for message boxes*/

                if (dwContext >= IDH_MBFIRST && dwContext <= IDH_MBLAST){
                    PMHelp(hWnd);
                }

                /* let dialog box deal with it*/
                PostMessage(GetRealParent((HWND)lParam), uiHelpMessage, 0, 0L);
            }
        }
        else{
CallDFP:
            return DefFrameProc(hWnd, hwndMDIClient, uiMsg, wParam, lParam);
        }
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\progman.c ===
/*
 * progman.c
 *
 *  Copyright (c) 1991,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *                This file is for support of program manager under NT Windows.
 *                This file is/was ported from progman.c (program manager).
 *
 *  MODIFICATION HISTORY
 *      Initial Version: x/x/90        Author Unknown, since he didn't feel
 *                                                                like commenting the code...
 *
 *      NT 32b Version: 1/16/91        Jeff Pack
 *                                                                Intitial port to begin.
 *
 *
 */

#include "progman.h"
#include "uniconv.h"

BOOL        UserIsAdmin         = FALSE;
BOOL        AccessToCommonGroups= FALSE;
BOOL        bLoadIt             = FALSE;
BOOL        bMinOnRun           = FALSE;
BOOL        bArranging          = FALSE;
BOOL        bAutoArrange        = FALSE;
BOOL        bAutoArranging      = FALSE;
BOOL        bExitWindows        = FALSE;
BOOL        bScrolling          = FALSE;
BOOL        bSaveSettings       = TRUE;
BOOL        bLoadEvil           = FALSE;
BOOL        bMove               = FALSE;
BOOL        bInDDE              = FALSE;
BOOL        bIconTitleWrap      = TRUE;
BOOL        fInExec             = FALSE;
BOOL        fNoRun              = FALSE;
BOOL        fNoClose            = FALSE;
BOOL        fNoSave             = FALSE;
BOOL        fNoFileMenu         = FALSE;
BOOL        fExiting            = FALSE;
BOOL        fLowMemErrYet       = FALSE;
BOOL        fErrorOnExtract     = FALSE;
BOOL	    bFrameSysMenu       = FALSE;

TCHAR        szNULL[]            = TEXT("");
TCHAR        szProgman[]         = TEXT("progman");
//
// Program Manager's Settings keys
//
TCHAR        szWindow[]          = TEXT("Window");
TCHAR        szOrder[]           = TEXT("UNICODE Order");
TCHAR        szAnsiOrder[]       = TEXT("Order");
TCHAR        szStartup[]         = TEXT("startup");
TCHAR        szAutoArrange[]     = TEXT("AutoArrange");
TCHAR        szSaveSettings[]    = TEXT("SaveSettings");
TCHAR        szMinOnRun[]        = TEXT("MinOnRun");
TCHAR        szFocusOnCommonGroup[] = TEXT("FocusOnCommonGroup");

TCHAR        szProgmanHelp[]     = TEXT("PROGMAN.HLP");
TCHAR        szTitle[MAXTITLELEN+1];
TCHAR        szMessage[MAXMESSAGELEN+1];
TCHAR        szNameField[MAXITEMPATHLEN+1];
TCHAR        szPathField[MAXITEMPATHLEN+1];
TCHAR        szDirField[MAXITEMPATHLEN+1];
TCHAR        szIconPath[MAXITEMPATHLEN+1];
TCHAR        szOriginalDirectory[MAXITEMPATHLEN+1];
TCHAR        szWindowsDirectory[MAXITEMPATHLEN+1];

TCHAR        szOOMExitMsg[64];
TCHAR        szOOMExitTitle[32];

/* for Program Groups in Registry */
HKEY        hkeyProgramManager  = NULL;  // progman.ini key
HKEY        hkeyPMSettings      = NULL;  // keys corresponding to progman.ini sections
HKEY        hkeyPMRestrict      = NULL;
HKEY        hkeyPMGroups        = NULL;
HKEY        hkeyPMCommonGroups  = NULL;

TCHAR       szAnsiProgramGroups[]   = TEXT("Program Groups");   // registry key for groups
HKEY        hkeyProgramGroups   = NULL;
HKEY        hkeyAnsiProgramGroups   = NULL;
HKEY        hkeyCommonGroups    = NULL;
PSECURITY_ATTRIBUTES pSecurityAttributes = NULL;
PSECURITY_ATTRIBUTES pAdminSecAttr = NULL;

HANDLE      hAccel;
HINSTANCE   hAppInstance;
HANDLE      hCommdlg            = NULL;

HICON       hDlgIcon            = NULL;
HICON       hItemIcon           = NULL;
HICON       hGroupIcon          = NULL;
HICON       hCommonGrpIcon      = NULL;
HICON       hProgmanIcon        = NULL;
HICON       hIconGlobal         = NULL;

HFONT       hFontTitle          = NULL;

HWND        hwndProgman         = NULL;
HWND        hwndMDIClient       = NULL;

HBRUSH      hbrWorkspace        = NULL;

WORD        wPendingHotKey      = 0;
DWORD       dwDDEAppId          = 0;
//HANDLE      hPendingWindow      = 0;
DWORD       dwEditLevel         = 0;
WORD        wLockError          = 0;
UINT        uiActivateShellWindowMessage = 0;
UINT        uiConsoleWindowMessage = 0;
UINT        uiSaveSettingsMessage = 0;   // for upedit.exe: User Profile Editor

int         nGroups             = 0;
int         dyBorder;
int         iDlgIconId;
int         iDlgIconIndex;
int         cxIconSpace;
int         cyIconSpace;
int         cxOffset;
int         cyOffset;
int         cxArrange;
int         cyArrange;
int         cxIcon;
int         cyIcon;

PGROUP      pFirstGroup         = NULL;
PGROUP      pCurrentGroup       = NULL;
PGROUP      pActiveGroup        = NULL;
PGROUP      *pLastGroup         = &pFirstGroup;
PGROUP      pExecingGroup       = NULL;

PITEM       pExecingItem        = NULL;

RECT        rcDrag              = { 0,0,0,0 };
HWND        hwndDrag            = 0;

WORD        wNewSelection;

UINT        uiHelpMessage;                // stuff for help
UINT        uiBrowseMessage;              // stuff for help
WORD        wMenuID = 0;
HANDLE      hSaveMenuHandle = 0L;           /*Save hMenu into one variable*/
WORD        wSaveFlags = 0;                /*Save flags into another*/
HANDLE      hSaveMenuHandleAroundSendMessage;   /*Save hMenu into one variable*/
WORD        wSaveFlagsAroundSendMessage;        /*Save flags into another*/
WORD        wSaveMenuIDAroundSendMessage;
DWORD       dwContext = 0L;
HHOOK       hhkMsgFilter = NULL;
BOOL        bUseANSIGroups = FALSE;

extern BOOL bInNtSetup;
extern VOID TMMain(void);
HANDLE hTMThread = NULL;

BOOL FAR PASCAL CheckHotKey(WPARAM wParam, LPARAM lParam);

/*** main --         Program entry point (was WinMain).
 *
 *
 *
 * int APIENTRY main(int argc, char *argv[], char *envp[])
 *
 * ENTRY -         int argc                - argument count.
 *                        char *argv[]        - argument list.
 *                        char *envp[]        - environment.
 *
 * EXIT  -           TRUE if success, FALSE if not.
 * SYNOPSIS -
 * WARNINGS -
 * EFFECTS  -
 *
 */

int __cdecl main(
    int argc,
    char *argv[],
    char *envp[])
{
    MSG msg;
    HANDLE hInst;
    LPTSTR  lpszCmdLine = NULL;
    int    nCmdShow = SW_SHOWNORMAL;
    DWORD dwThreadID;
    DWORD dwEvent;

#ifdef DEBUG_PROGMAN_DDE
    {
    TCHAR szDebug[300];

    wsprintf (szDebug, TEXT("%d   PROGMAN:   Starting\r\n"),
              GetTickCount());
    OutputDebugString(szDebug);
    }
#endif

    hInst = GetModuleHandle(NULL);

    if (argc > 1) {
        //
        // Get the command line, sans program name.
        //
        lpszCmdLine = SkipProgramName(GetCommandLine());

    }

    /*
     * Initialize the window classes and other junk.
     */
    if (!AppInit(hInst, lpszCmdLine, nCmdShow)) {
        return FALSE;
    }

    //
    // Don't start the taskman thread if progman is started from NTSETUP.
    //

    if (!bInNtSetup) {
        HKEY hkeyWinlogon;
        DWORD dwType;
        TCHAR szBuffer[MAX_PATH];
        DWORD cbBuffer;
        BOOL  bUseDefaultTaskman = TRUE;

        //
        // Check if a replacement taskman exits.  First open the Taskman
        // entry in winlogon's settings.
        //

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                     0,
                     KEY_READ,
                     &hkeyWinlogon) == ERROR_SUCCESS) {

            //
            // Query the taskman name.
            //

            cbBuffer = sizeof(szBuffer);
            if (RegQueryValueEx(hkeyWinlogon,
                                TEXT("Taskman"),
                                0,
                                &dwType,
                                (LPBYTE)szBuffer,
                                &cbBuffer) == ERROR_SUCCESS) {

                //
                // The taskman entry exits.  Confirm that it is not NULL.
                //

                if (szBuffer[0] != TEXT('\0')) {

                    //
                    // Try to spawn the taskman replacement.  If
                    // the spawning succeeds, ExecProgram will return 0.
                    //

                    if (ExecProgram (szBuffer, NULL, NULL, FALSE,
                                     0, 0, FALSE) == 0) {
                        bUseDefaultTaskman = FALSE;
                    }
                }
            }

            //
            // Close the registry key.
            //

            RegCloseKey (hkeyWinlogon);
        }

        //
        // Check to see if we should spawn the default taskman.
        //

        if (bUseDefaultTaskman) {
            hTMThread = CreateThread(NULL, (DWORD)0,
                                    (LPTHREAD_START_ROUTINE)TMMain,
                                    (LPVOID)NULL, 0, &dwThreadID);
        }
    }

#ifdef DEBUG_PROGMAN_DDE
    {
    TCHAR szDebug[300];

    wsprintf (szDebug, TEXT("%d   PROGMAN:   Entering message loop\r\n"),
              GetTickCount());
    OutputDebugString(szDebug);
    }
#endif

    //
    // Messaging Loop.
    //

    while (TRUE) {

        while (PeekMessage(&msg, (HWND)NULL, 0, 0, PM_REMOVE)) {

            if (msg.message == WM_QUIT) {
#ifdef DEBUG_PROGMAN_DDE
               {
               TCHAR szDebug[300];

               wsprintf (szDebug, TEXT("%d   PROGMAN:   Exiting\r\n"),
                         GetTickCount());
               OutputDebugString(szDebug);
               }
#endif
               return (int)msg.wParam;
            }

            /*
             * First test if this is a hot key.
             *
             */

            if (msg.message == WM_SYSKEYDOWN || msg.message == WM_KEYDOWN) {
                if (CheckHotKey(msg.wParam, msg.lParam))
                    continue;
            }

            /*
             * Since we use RETURN as an accelerator we have to manually
             * restore ourselves when we see VK_RETURN and we are minimized.
             */
            if (msg.message == WM_SYSKEYDOWN && msg.wParam == VK_RETURN &&
                    IsIconic(hwndProgman)) {
                ShowWindow(hwndProgman, SW_NORMAL);

            } else {
                if ((hwndMDIClient == NULL ||
                        !TranslateMDISysAccel(hwndMDIClient, &msg)) &&
                        (hwndProgman == NULL ||
                        !TranslateAccelerator(hwndProgman, hAccel, &msg))) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        dwEvent = MsgWaitForMultipleObjects(2, gahEvents, FALSE,
            INFINITE, QS_ALLINPUT);

        if (dwEvent < (WAIT_OBJECT_0 + 2)) {
           HandleGroupKeyChange((dwEvent == (WAIT_OBJECT_0 + 1)));
        }
    }

    // return msg.wParam;
}

/*** MyMessageBox --
 *
 *
 * int APIENTRY MyMessageBox(HWND hWnd, WORD idTitle, WORD idMessage, LPSTR lpsz, WORD wStyle)
 *
 * ENTRY -         HWND        hWnd
 *                        WORD        idTitle
 *                        WORD        idMessage
 *                        LPSTR        lpsz
 *                        WORD        wStyle
 *
 * EXIT  -        int         xx                        - Looks like -1 is error, otherwise result.
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

int APIENTRY MyMessageBox(HWND hWnd, WORD idTitle, WORD idMessage, LPTSTR psz, WORD wStyle)
{
    TCHAR szTempField[MAXMESSAGELEN];
    int iMsgResult;

    if (bInDDE){
        return(1);
    }
    if (!LoadString(hAppInstance, idTitle, szTitle, CharSizeOf(szTitle))){
        goto MessageBoxOOM;
    }
    if (idMessage < 32){
        if (!LoadString(hAppInstance, IDS_UNKNOWNMSG, szTempField, CharSizeOf(szTempField))){
            goto MessageBoxOOM;
        }
        wsprintf(szMessage, szTempField, idMessage);
    }
    else{
        if (!LoadString(hAppInstance, idMessage, szTempField, CharSizeOf(szTempField)))
            goto MessageBoxOOM;

        if (psz)
            wsprintf(szMessage, szTempField, (LPTSTR)psz);
        else
            lstrcpy(szMessage, szTempField);
    }

    if (hWnd){
        hWnd = GetLastActivePopup(hWnd);
    }

    iMsgResult = MessageBox(hWnd, szMessage, szTitle, wStyle );

    if (iMsgResult == -1){

MessageBoxOOM:
        MessageBox(GetLastActivePopup(hwndProgman), szOOMExitMsg, szOOMExitTitle, MB_SYSTEMMODAL | MB_ICONHAND | MB_OK);
    }

    return(iMsgResult);
}


/*** MessageFilter --
 *
 *
 * int APIENTRY MessageFilter(int nCode, WPARAM wParam, LPMSG lpMsg)
 *
 * ENTRY -         int                nCode
 *                        WPARAM        wParam
 *                        WORD        idMessage
 *                        LPMSG        lpMsg
 *
 * EXIT  -        int         xx                        - Looks like 0 is error, otherwise 1 is success
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

LRESULT APIENTRY MessageFilter(int nCode, WPARAM wParam, LPARAM lParam)

{
    LPMSG lpMsg = (LPMSG)lParam;
    if (nCode < 0){
        goto DefHook;
    }
    if (nCode == MSGF_MENU) {

        if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1) {
            /* Window of menu we want help for is in loword of lParam.*/
            PostMessage(hwndProgman, uiHelpMessage, MSGF_MENU, (LPARAM)lpMsg->hwnd);
            return(1);
        }

    } else if (nCode == MSGF_DIALOGBOX) {

        if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1) {
            /* Dialog box we want help for is in loword of lParam */
            PostMessage(hwndProgman, uiHelpMessage, MSGF_DIALOGBOX, (LPARAM)lpMsg->hwnd);
            return(1);
        }

    }
    else{

DefHook:
        return DefHookProc(nCode, wParam, lParam, &hhkMsgFilter);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\pminit.c ===
/*
 * pminit.c - program manager
 *
 *  Copyright (c) 1991,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *                This file is for support of program manager under NT Windows.
 *                This file is/was ported from pminit.c (program manager).
 *
 *  MODIFICATION HISTORY
 *      Initial Version: x/x/90        Author Unknown, since he didn't feel
 *                                                                like commenting the code...
 *
 *      NT 32b Version:        1/25/91        Jeff Pack
 *                                                                Intitial port to begin.
 *
 *
 */

#include "progman.h"
#include "util.h"
#include "commdlg.h"
//#ifdef FE_IME
#include "winnls32.h"
//#endif
#include "uniconv.h"
#include "security.h"

#define MAX_USERNAME_LENGTH 256
#define PROGMAN_KEY  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager"
#define WINDOWS_KEY  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows"

//#define MYDEBUG 1
SECURITY_ATTRIBUTES SecurityAttributes;
SECURITY_ATTRIBUTES AdminSecAttr;       // security attributes for common groups

BOOL bInitialArrange;
BOOL bInNtSetup;
TCHAR szProgramGroups[]   = TEXT("UNICODE Program Groups");   // registry key for groups
TCHAR szRestrict[]        = TEXT("Restrictions");
TCHAR szNoRun[]           = TEXT("NoRun");
TCHAR szNoClose[]         = TEXT("NoClose");
TCHAR szEditLevel[]       = TEXT("EditLevel");
TCHAR szNoFileMenu[]      = TEXT("NoFileMenu");
TCHAR szNoSave[]          = TEXT("NoSaveSettings");
TCHAR szShowCommonGroups[]= TEXT("ShowCommonGroups");
TCHAR szSettings[]        = TEXT("Settings");
TCHAR szGroups[]          = TEXT("UNICODE Groups");
TCHAR szAnsiGroups[]      = TEXT("Groups");
TCHAR szCommonGroups[]    = TEXT("Common Groups");
TCHAR szSystemBoot[]      = TEXT("Boot");
TCHAR szSystemDisplay[]   = TEXT("display.drv");
TCHAR szDefPrograms[]     = TEXT("EXE COM BAT PIF");
TCHAR szSystemIni[]       = TEXT("system.ini");
TCHAR szWindows[]         = TEXT("Windows");
TCHAR szCheckBinaryType[] = TEXT("CheckBinaryType");
TCHAR szCheckBinaryTimeout[] = TEXT("CheckBinaryTimeout");
TCHAR szMigrateAnsi[] =     TEXT("Migrate ANSI");

BOOL bDisableDDE = FALSE;

/* in hotkey.c */
BOOL APIENTRY RegisterHotKeyClass(HANDLE hInstance);
/* in pmgseg.c */
HWND NEAR PASCAL IsGroupAlreadyLoaded(LPTSTR lpGroupKey, BOOL bCommonGroup);

/*---------------------------------------------------------------------------
 *
 * A fixed buffer case and space insensative compare...
 * Returns true if they compare the same.
 *
 *--------------------------------------------------------------------------*/

BOOL NEAR PASCAL StartupCmp(LPTSTR szSrc1, LPTSTR szSrc2)
{
    TCHAR sz1[MAXGROUPNAMELEN+1];
    TCHAR sz2[MAXMESSAGELEN+1];
    LPTSTR lp1, lp2;

    lstrcpy(sz1, szSrc1);
    CharUpper(sz1);
    lstrcpy(sz2, szSrc2);
    CharUpper(sz2);
    lp1 = sz1;
    lp2 = sz2;

    for (;;) {
        while(*lp1 == TEXT(' '))
            lp1++;
        while(*lp2 == TEXT(' '))
            lp2++;
        if (*lp1 != *lp2)
            return FALSE;
        if (!*lp1)
            break;
        while (*lp1 == *lp2 && *lp1)
            lp1++, lp2++;
    }
    return TRUE;
}


/*---------------------------------------------------------------------------
 *
 * Handles finding and execing the items in the startup group.
 *
 *--------------------------------------------------------------------------*/

VOID NEAR PASCAL HandleStartupGroup(int nCmdShow)
{
    TCHAR szGroupTitle[MAXGROUPNAMELEN+1];
    HWND hwndT;
    DWORD cbData = sizeof(TCHAR)*(MAXGROUPNAMELEN+1);
    PGROUP pGroup;
    LPGROUPDEF lpgd;
    TCHAR szCommonStartupGroup[MAXGROUPNAMELEN+1];
    TCHAR szDefaultStartup[MAXGROUPNAMELEN+1] = TEXT("startup");

    TCHAR        szStartupKana[]         = TEXT("^?X^?^^?[^?g^?A^?b^?v");

    if (nCmdShow != SW_SHOWMINNOACTIVE) {
        //
        // Daytona security weenies decreed that GetAsyncKeyState only work
        // if threads window is foreground, so make it so.
        //
        hwndT = GetForegroundWindow();
        if (hwndProgman != hwndT)
            SetForegroundWindow( hwndProgman );
        if (GetAsyncKeyState(VK_SHIFT) < 0)   // SHIFT will cancel the startup group
            return;
    }

    //
    // The Default startup group name is "Startup", for personal and common
    // groups.
    //
    LoadString(hAppInstance,IDS_DEFAULTSTARTUP,szDefaultStartup,CharSizeOf(szDefaultStartup));
    lstrcpy(szGroupTitle, szDefaultStartup);
    lstrcpy(szCommonStartupGroup, szDefaultStartup);

    //
    // Get the Personal startup group name.
    //
    if (hkeyPMSettings) {
        if ( RegQueryValueEx(hkeyPMSettings, szStartup, 0, 0, (LPBYTE)szGroupTitle, &cbData) != ERROR_SUCCESS ) {
            lstrcpy(szGroupTitle, szDefaultStartup);
        }
    }

    // Search for the startup group.
    hwndT = GetWindow(hwndMDIClient, GW_CHILD);
    while (hwndT) {
        //
        // Skip icon titles.
        //
        if (!GetWindow(hwndT, GW_OWNER)) {

            /* Compare the group name with the startup. */
            pGroup = (PGROUP)GetWindowLongPtr(hwndT, GWLP_PGROUP);
            if (lpgd = (LPGROUPDEF)GlobalLock(pGroup->hGroup)) {
                // ToddB: We want to check for three things here:
                // 1.) A common group with the name szCommonStartupGroup
                // 2.) Any group with the name szGroupTitle (which is a copy of szDefaultStartup)
                // 3.) If we are in Japan then we also search for two hardcoded strings,
                //      szStartupKana AND szStartup.  I think this special Japanese
                //      check is a bug and should be removed.

                if (pGroup->fCommon) {
                    if (StartupCmp(szCommonStartupGroup, (LPTSTR) PTR(lpgd, lpgd->pName)))
                        StartupGroup(hwndT);
                }
                else if (StartupCmp(szGroupTitle, (LPTSTR) PTR(lpgd, lpgd->pName))) {
                    StartupGroup(hwndT);
                }
#ifdef JAPAN_HACK_WHICH_TODDB_THINKS_IS_A_BUG
                else if (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_JAPANESE)
                {
                    if (StartupCmp(szStartupKana,(LPTSTR)PTR(lpgd,lpgd->pName)) ||  // search for hardcoded localized startup
                        StartupCmp(szStartup,(LPTSTR)PTR(lpgd,lpgd->pName)))        // search for hardcoded non-localized "startup"
                    {
                        StartupGroup( hwndT );
                    }
                }
#endif
                GlobalUnlock(pGroup->hGroup);
            }
        }
        hwndT = GetWindow(hwndT, GW_HWNDNEXT);
    }
}

/*** BoilThatDustSpec --         strips string to program name
 *
 *
 * VOID APIENTRY BoilThatDustSpec(PSTR pStart, BOOL bLoadIt)
 *
 * ENTRY - PSTR pStart - Program to exec, and possible parameters
 *         BOOL LoadIt -
 *
 * EXIT  - VOID
 *
 * SYNOPSIS -  strips everything after program name, then exec's program.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID APIENTRY BoilThatDustSpec(LPTSTR pStart, BOOL bLoadIt)
{
    register LPTSTR pEnd;
    WORD ret;
    BOOL bFinished;
    TCHAR szText[MAXMESSAGELEN+1];
    TCHAR szExtra[MAXMESSAGELEN+1];
    TCHAR szFilename[MAXITEMPATHLEN+1];
    TCHAR szWindowsDirectory2[MAXITEMPATHLEN+1];

    if (*pStart == TEXT('\0')) {                  /*test for null string*/
        return;
    }

    // Used to massage any errors.
    LoadString(hAppInstance,IDS_WININIERR,szExtra, CharSizeOf(szExtra));

    // skip first spaces
    while (*pStart == ' ') {
        pStart = CharNext(pStart);
    }
    bFinished = !*pStart;

    GetWindowsDirectory(szWindowsDirectory2, CharSizeOf(szWindowsDirectory2));

    while (!bFinished){
        pEnd = pStart;
        /* strip anything after execprogram name*/
        while ((*pEnd) && (*pEnd != TEXT(' ')) && (*pEnd != TEXT(','))){
            pEnd = CharNext(pEnd);
        }
        if (*pEnd == TEXT('\0'))
            bFinished = TRUE;
        else
            *pEnd = TEXT('\0');

        if (!*pStart) {
            pStart = pEnd+1;
            continue;
        }

        if (GetFreeSpace(GMEM_NOT_BANKED) < 65535L)
            break;

        GetDirectoryFromPath(pStart, szDirField);

        // Load and Run lines are done relative to windows directory.
        SetCurrentDirectory(szWindowsDirectory2);

        GetFilenameFromPath(pStart, szFilename);
        ret = ExecProgram(szFilename, szDirField, NULL, bLoadIt, 0, 0, 0);
        if (ret) {
           // Insert a phrase mentioning win.ini after the file name.
           szText[0] = TEXT('\'');
           lstrcpy(&szText[1], pStart);
           lstrcat(szText, szExtra);
	       MyMessageBox(NULL, IDS_APPTITLE, ret, szText, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
        }

        pStart = pEnd+1;
    }

    SetCurrentDirectory(szWindowsDirectory); // in fact system32 directory
}

/*** DoRunEquals --
 *
 *
 * VOID APIENTRY DoRunEquals(PINT pnCmdShow)
 *
 * ENTRY -         PINT        pnCmdShow        -        point to cmdshow
 *
 * EXIT  -        VOID
 *
 * SYNOPSIS -  ???
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID APIENTRY DoRunEquals(PINT pnCmdShow)
{
  TCHAR szBuffer[MAX_PATH];
  DWORD dwType;
  DWORD cbData;
  HKEY hkeyWindows;

  /* "Load" apps before "Run"ning any. */
  if (RegOpenKeyEx(HKEY_CURRENT_USER,
                   WINDOWS_KEY,
                   0,
                   KEY_READ,
                   &hkeyWindows) != ERROR_SUCCESS) {
      return;
  }

  *szBuffer = 0;
  cbData = sizeof(szBuffer);
  RegQueryValueEx(hkeyWindows,
                      L"Load",
                      0,
                      &dwType,
                      (LPBYTE)szBuffer, &cbData);
  if (*szBuffer)
      BoilThatDustSpec(szBuffer, TRUE);

  *szBuffer = 0;
  cbData = sizeof(szBuffer);
  RegQueryValueEx(hkeyWindows,
                      L"Run",
                      0,
                      &dwType,
                      (LPBYTE)szBuffer, &cbData);
  if (*szBuffer) {
      BoilThatDustSpec(szBuffer, FALSE);
      *pnCmdShow = SW_SHOWMINNOACTIVE;
  }

  RegCloseKey(hkeyWindows);
}


/*** GetSettings        --
 *
 *
 * PSTR APIENTRY GetSettings(VOID)
 *
 * ENTRY -         VOID
 *
 * EXIT  -        PSTR         - if NULL then error.
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

LPTSTR APIENTRY GetSettings()
{
  LPTSTR pszT;
  TCHAR szGroups[32];
  TCHAR szAppTitle[MAXKEYLEN + 1];
  DWORD cbData;
  DWORD dwType;
  DWORD rc;
  DWORD dwBinaryInfo;

  #define SETTING_SIZE        160

  /* Get the flags out of the INI file. */
  LoadString(hAppInstance, IDS_GROUPS, szGroups, CharSizeOf(szGroups));
  LoadString(hAppInstance, IDS_APPTITLE, szAppTitle, CharSizeOf(szAppTitle));

  /*
   * Use direct registry call.
   */
  if (hkeyPMSettings) {
      cbData = sizeof(bMinOnRun);
      RegQueryValueEx(hkeyPMSettings, szMinOnRun, 0, &dwType, (LPBYTE)&bMinOnRun, &cbData);
      cbData = sizeof(bAutoArrange);
      RegQueryValueEx(hkeyPMSettings, szAutoArrange, 0, &dwType, (LPBYTE)&bAutoArrange, &cbData);
      cbData = sizeof(bSaveSettings);
      RegQueryValueEx(hkeyPMSettings, szSaveSettings, 0, &dwType, (LPBYTE)&bSaveSettings, &cbData);
      cbData = sizeof(bInitialArrange);
      bInitialArrange = FALSE;
      rc = RegQueryValueEx(hkeyPMSettings, TEXT("InitialArrange"), 0, &dwType, (LPBYTE)&bInitialArrange, &cbData);
      if (bInitialArrange) {
          RegDeleteValue(hkeyPMSettings, TEXT("InitialArrange"));
      }

      //
      // Check if the binary type checking information exists.  If not,
      // add it.
      //
      // First check for the enabled / disabled entry.
      //

      cbData = sizeof(dwBinaryInfo);
      if (RegQueryValueEx(hkeyPMSettings, szCheckBinaryType, 0, &dwType,
                     (LPBYTE)&dwBinaryInfo, &cbData) == ERROR_FILE_NOT_FOUND) {
          //
          // Key doesn't exist, so create the default case.
          //

          dwBinaryInfo = BINARY_TYPE_DEFAULT;
          RegSetValueEx (hkeyPMSettings, szCheckBinaryType, 0, REG_DWORD,
                         (LPBYTE) &dwBinaryInfo, cbData);
      }

      //
      // Now check for the timeout value.  This is the number of milliseconds
      // of delay after the lastkeystroke and before the background thread
      // is signaled to check the type.
      //

      cbData = sizeof(dwBinaryInfo);
      if (RegQueryValueEx(hkeyPMSettings, szCheckBinaryTimeout, 0, &dwType,
                     (LPBYTE)&dwBinaryInfo, &cbData) == ERROR_FILE_NOT_FOUND) {
          //
          // Key doesn't exist, so create the default case.
          //

          dwBinaryInfo = BINARY_TIMEOUT_DEFAULT;
          RegSetValueEx (hkeyPMSettings, szCheckBinaryTimeout, 0, REG_DWORD,
                         (LPBYTE) &dwBinaryInfo, cbData);
      }

  }
  if (hkeyPMRestrict && !UserIsAdmin) {
      cbData = sizeof(fNoRun);
      RegQueryValueEx(hkeyPMRestrict, szNoRun, 0, &dwType, (LPBYTE)&fNoRun, &cbData);
      cbData = sizeof(fNoClose);
      RegQueryValueEx(hkeyPMRestrict, szNoClose, 0, &dwType, (LPBYTE)&fNoClose, &cbData);
      cbData = sizeof(fNoSave);
      RegQueryValueEx(hkeyPMRestrict, szNoSave, 0, &dwType, (LPBYTE)&fNoSave, &cbData);
      cbData = sizeof(dwEditLevel);
      RegQueryValueEx(hkeyPMRestrict, szEditLevel, 0, &dwType, (LPBYTE)&dwEditLevel, &cbData);
  }


  pszT = (LPTSTR)LocalAlloc(LPTR, SETTING_SIZE);
  if (!pszT)
      return(NULL);

  /*
   * Use direct registry call.
   */
  if (hkeyPMSettings) {
      cbData = SETTING_SIZE;
      if (RegQueryValueEx(hkeyPMSettings, szWindow, 0, &dwType, (LPBYTE)pszT, &cbData)) {
          LocalFree((HANDLE)pszT);
          return NULL;
      }
  }
  else {
      return(NULL);
  }

  return pszT;
}

//#if 0
BOOL GetUserAndDomainName(LPTSTR lpBuffer, DWORD cb)
{
  HANDLE hToken;
  DWORD cbTokenBuffer = 0;
  PTOKEN_USER pUserToken;
  LPTSTR lpUserName = NULL;
  LPTSTR lpUserDomain = NULL;
  DWORD cbAccountName = 0;
  DWORD cbUserDomain = 0;
  SID_NAME_USE SidNameUse;

  if (!OpenProcessToken(GetCurrentProcess(),
                       TOKEN_QUERY,
                       &hToken) ){
      return(FALSE);
  }

  //
  // Get space needed for token information
  //
  if (!GetTokenInformation(hToken,
                           TokenUser,
                           NULL,
                           0,
                           &cbTokenBuffer) ) {

      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
          return(FALSE);
      }
  }

  //
  // Get the actual token information
  //
  pUserToken = (PTOKEN_USER)Alloc(cbTokenBuffer);
  if (pUserToken == NULL) {
      return(FALSE);
  }
  if (!GetTokenInformation(hToken,
                           TokenUser,
                           pUserToken,
                           cbTokenBuffer,
                           &cbTokenBuffer) ) {
      Free(pUserToken);
      return(FALSE);
  }

  //
  // Get the space needed for the User name and the Domain name
  //
  if (!LookupAccountSid(NULL,
                       pUserToken->User.Sid,
                       NULL, &cbAccountName,
                       NULL, &cbUserDomain,
                       &SidNameUse
                       ) ) {
      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
          Free(pUserToken);
          return(FALSE);
      }
  }
  lpUserName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(cbAccountName+1));
  if (!lpUserName) {
      Free(pUserToken);
    return(FALSE);
  }
  lpUserDomain = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(1+cbUserDomain));
  if (!lpUserDomain) {
      LocalFree(lpUserName);
      Free(pUserToken);
      return(FALSE);
  }

  //
  // Now get the user name and domain name
  //
  if (!LookupAccountSid(NULL,
                       pUserToken->User.Sid,
                       lpUserName, &cbAccountName,
                       lpUserDomain, &cbUserDomain,
                       &SidNameUse
                       ) ) {

      LocalFree(lpUserName);
      LocalFree(lpUserDomain);
      Free(pUserToken);
      return(FALSE);
  }

  if (*lpUserName &&
      ((int)sizeof(TCHAR)*(lstrlen(lpBuffer) + lstrlen(lpUserName) + lstrlen(lpUserDomain)) < (int)(cb+4)) ) {

      lstrcat(lpBuffer, TEXT(" - "));
      lstrcat(lpBuffer, lpUserDomain);
      lstrcat(lpBuffer, TEXT("\\"));
      lstrcat(lpBuffer, lpUserName);
  }
  Free(pUserToken);
  LocalFree(lpUserName);
  LocalFree(lpUserDomain);
  return(TRUE);
}
//#endif

/*** CreateFrameWindow --
 *
 *
 * HWND APIENTRY CreateFrameWindow(register PRECT prc, WORD nCmdShow)
 *
 * ENTRY -         PRECT        prc                        -
 *                        WORD        nCmdShow        -
 *
 * EXIT  -        HWND                                -  (NULL = Error)
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

HWND APIENTRY CreateFrameWindow(register PRECT prc, WORD nCmdShow)
{
  HDC    hdc;
  HBRUSH hbr;
  HMENU  hMenu;
  HMENU  hSystemMenu;
  TCHAR   szBuffer[40 + MAX_USERNAME_LENGTH];
  TCHAR   szProgmanClass[16];
  TCHAR   szUserName[MAX_USERNAME_LENGTH + 1] = TEXT("");
  TCHAR   szUserDomain[MAX_USERNAME_LENGTH + 1] = TEXT("");
  DWORD  dwType, cbData;

  /* Create the Desktop Manager window. */
  LoadString(hAppInstance, IDS_APPTITLE, szBuffer, CharSizeOf(szBuffer));
  LoadString(hAppInstance, IDS_PMCLASS, szProgmanClass, CharSizeOf(szProgmanClass));
#if 1
  GetUserAndDomainName(szBuffer,sizeof(szBuffer));
#else
  cbData = CharSizeOf(szUserName);
  GetUserName(szUserName, &cbData) ;
  cbData = CharSizeOf(szUserDomain);
  GetEnvironmentVariable(TEXT("USERDOMAIN"), szUserDomain, cbData);
  if (*szUserName){
      lstrcat(szBuffer, TEXT(" - "));
      lstrcat(szBuffer, szUserDomain);
      lstrcat(szBuffer, TEXT("\\"));
      lstrcat(szBuffer, szUserName);
  }
#endif
  hwndProgman = CreateWindow(szProgmanClass,
                             szBuffer,
			                 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                             prc->left, prc->top,
                             prc->right-prc->left,
                             prc->bottom-prc->top,
                             NULL,               /* No Parent           */
                             NULL,               /* Use Class Menu   */
                             hAppInstance,
                             NULL);

  if (!hwndProgman)
      return NULL;

  SetWindowLong (hwndProgman, GWL_EXITING, 0);

  hMenu = GetMenu(hwndProgman);
  hSystemMenu = GetSystemMenu(hwndProgman, FALSE);

  if (!bExitWindows) {
      LoadString(hAppInstance,IDS_EXIT,szBuffer,CharSizeOf(szBuffer));
      ModifyMenu(hMenu,IDM_EXIT,MF_BYCOMMAND|MF_STRING,IDM_EXIT,szBuffer);
      DeleteMenu(hMenu,IDM_SHUTDOWN,MF_BYCOMMAND);
  }
  else {
      // replace Close menu item with Logoff and Shutdown
      LoadString(hAppInstance,IDS_LOGOFF,szBuffer,CharSizeOf(szBuffer));
      InsertMenu(hSystemMenu, SC_CLOSE, MF_BYCOMMAND|MF_STRING, SC_CLOSE, szBuffer);
      LoadString(hAppInstance,IDS_SHUTDOWN,szBuffer,CharSizeOf(szBuffer));
      ModifyMenu(hSystemMenu, SC_CLOSE, MF_BYCOMMAND|MF_STRING, IDM_SHUTDOWN, szBuffer);
  }

  if (hkeyPMRestrict && !UserIsAdmin) {
      cbData = sizeof(fNoFileMenu);
      RegQueryValueEx(hkeyPMRestrict, szNoFileMenu, 0, &dwType, (LPBYTE)&fNoFileMenu, &cbData);
  }

  if (fNoFileMenu) {
      DeleteMenu(hMenu, IDM_FILE, MF_BYPOSITION);
  }

  if (fNoSave) {
      bSaveSettings = FALSE;
      EnableMenuItem(hMenu, IDM_SAVESETTINGS, MF_BYCOMMAND|MF_GRAYED|MF_DISABLED);
      EnableMenuItem(hMenu, IDM_SAVENOW, MF_BYCOMMAND|MF_GRAYED|MF_DISABLED);
  }

  /* Update the menu items here (no maximized kids to deal with). */
  if (bMinOnRun)
      CheckMenuItem(hMenu, IDM_MINONRUN, MF_CHECKED);
  if (bAutoArrange)
      CheckMenuItem(hMenu, IDM_AUTOARRANGE, MF_CHECKED);
  if (bSaveSettings)
      CheckMenuItem(hMenu, IDM_SAVESETTINGS, MF_CHECKED);

  if (bInNtSetup) {
      EnableWindow(hwndProgman, FALSE);
  }
  ShowWindow(hwndProgman, nCmdShow);
  UpdateWindow(hwndProgman);

  /* fake-paint the client area with the color of the MDI client so users
   * have something pleasent to stare at while we hit the disk for the
   * group files
   */
  hdc = GetDC(hwndProgman);
  GetClientRect(hwndProgman, prc);
  hbr = CreateSolidBrush(GetSysColor(COLOR_APPWORKSPACE));
  if (hbr) {
      FillRect(hdc, prc, hbr);
      DeleteObject(hbr);
  }
  ReleaseDC(hwndProgman, hdc);

  return hwndProgman;
}

/*** IsGroup        --
 *
 *
 * BOOL APIENTRY IsGroup(PSTR p)
 *
 * ENTRY -         PSTR        p        -
 *
 * EXIT  -        BOOL                - (FALSE == ERROR)
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

BOOL PASCAL IsGroup(LPTSTR p)
{
    if (_wcsnicmp(p, TEXT("GROUP"), CCHGROUP) != 0) {
        return FALSE;
    }

    /*
     * Can't have 0 for first digit
     */
    if (p[5] == TEXT('0')) {
        return FALSE;
    }

    /*
     * Everything else must be a number
     */
    for (p += CCHGROUP; *p; p++) {
        if (*p != TEXT('C') && (*p < TEXT('0') || *p > TEXT('9'))) {
            return FALSE;
        }
    }

    return TRUE;
}


/*** RemoveString --
 *
 *
 * VOID APIENTRY RemoveString(PSTR pString)
 *
 * ENTRY -         PSTR        pString                -
 *
 * EXIT  -        VOID
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID APIENTRY RemoveString(LPTSTR pString)
{

    LPTSTR pT = pString + lstrlen(pString) + 1;

    while (*pT) {
        while (*pString++ = *pT++)
            ;
    }
    *pString = 0;
}

/*** StringToEnd --
 *
 *
 * VOID APIENTRY StringToEnd(PSTR pString)
 *
 * ENTRY -         PSTR        pString                -
 *
 * EXIT  -        VOID
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID PASCAL StringToEnd(LPTSTR pString)
{
    TCHAR *pT,*pTT;

    for (pT = pString; *pT; )           //go to end of strings
        while (*pT++)
            ;
    for (pTT = pString; *pT++ = *pTT++;)  // copy first string to the end
        ;
    *pT = 0;

    RemoveString(pString);                // remove first string
}

/*** GetGroupList --
 *
 *
 * VOID APIENTRY GetGroupList(PSTR szList)
 *
 * ENTRY -         PSTR        szList                -
 *
 * EXIT  -        VOID
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID PASCAL GetGroupList(LPTSTR szList, HKEY hkeyPMGroups)
{
    TCHAR szOrd[CGROUPSMAX*8+7];
    TCHAR szT[20];
    LPTSTR pT, pTT, pS;
    INT cGroups;   // The number of Groups= lines.
    LPTSTR  lpList;
    DWORD  dwType;
    DWORD  dwIndex = 0;
    DWORD  cbValueName = 8;
    DWORD  cbData;
    INT    cbList = (CGROUPSMAX+1)*18;
    LPTSTR lpOrder;

    lpList = szList;
    //
    // Get the user's list of personal groups.
    //
    if (hkeyPMGroups) {
        cbValueName = cbList;
        while (!RegEnumValue(hkeyPMGroups, dwIndex, lpList, &cbValueName, 0, 0,
                             0, 0)) {
            dwIndex++; cbValueName++;
            lpList += cbValueName;
            cbList -= cbValueName;
            cbValueName = cbList;
        }
    }
    //
    // Now get the user's list of common groups.
    //
    if (hkeyPMCommonGroups) {
        cbValueName = cbList;
        dwIndex = 0;
        while (!RegEnumValue(hkeyPMCommonGroups, dwIndex, lpList, &cbValueName, 0, 0,
                             0, 0)) {
            dwIndex++; cbValueName++;
            lpList += cbValueName;
            cbList -= cbValueName;
            cbValueName = cbList;
        }
    }
    *lpList = TEXT('\0');

    cbData = sizeof(szOrd);
    if (bUseANSIGroups)
        lpOrder = szAnsiOrder;
    else
        lpOrder = szOrder;

    if (!hkeyPMSettings || RegQueryValueEx(hkeyPMSettings, lpOrder, 0, &dwType, (LPBYTE)szOrd, &cbData))
        *szOrd = TEXT('\0');

    cGroups = 0;

    /*
     * Filter out anything that isn't group#.
     */
    for (pT = szList; *pT; ) {
        CharUpper(pT);

        if (IsGroup(pT)) {
            pT += lstrlen(pT) + 1;
            cGroups++;
        } else {
            RemoveString(pT);
        }
    }

    /*
     * Sort the groups
     */
    lstrcpy(szT, TEXT("Group"));
    for (pT = szOrd; *pT; ) {
        while (*pT == TEXT(' ')) {
            pT++;
        }

        if ((*pT == TEXT('C') && (*(pT+1) < TEXT('0') || *(pT+1) > TEXT('9'))) ||
             (*pT != TEXT('C') && (*pT < TEXT('0') || *pT > TEXT('9'))) ) {
            break;
        }

        pTT = szT + CCHGROUP;
        while (*pT == TEXT('C') || (*pT >= TEXT('0') && *pT <= TEXT('9'))) {
            *pTT++ = *pT++;
        }
        *pTT=0;

        for (pS = szList; *pS; pS += lstrlen(pS) + 1) {
            if (!lstrcmpi(pS,szT)) {
                StringToEnd(pS);
                cGroups--;
                break;
            }
        }
    }

    /*
     * Move any remaining groups to the end of the list so that they load
     * last and appear on top of everything else - keeps DOS based install
     * programs happy.
     * If bInitialArrange is set then the remaining groups come from the
     * Windows 3.1 migration and we want these groups to be loaded before
     * the remaining groups so they appear below the regular groups.
     * 10-15-93 johannec
     */
    if (!bInitialArrange) {
        while (cGroups>0) {
            StringToEnd(szList);
            cGroups--;
        }
    }

}

/*** LoadCommonGroups --
 *
 *
 * VOID APIENTRY LoadCommonGroups(LPTSTR)
 *
 * ENTRY - LPTSTR the key name of the common group that should have the focus.
 *
 * EXIT  - HWND  hwnd of the common group which should have the focus.
 *
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

HWND LoadCommonGroups(LPTSTR lpFocusGroup)
{
    int i = 0;
    TCHAR szGroupKey[MAXKEYLEN];
    DWORD cchGroupKey = CharSizeOf(szGroupKey);
    BOOL bRealArrange;
    FILETIME ft;
    HWND hwnd;


    if (!hkeyCommonGroups) {  // cannot access registry.
        return(NULL);
    }

    /*
     * Set global to note that we haven't run out of memory yet.
     */
    fLowMemErrYet = FALSE;
    /*
     * Flag for extraction problems.
     */
    fErrorOnExtract = FALSE;

    // REVIEW - Why stop AutoArrange on load ? Switch it off for now.
    bRealArrange = bAutoArrange;

    //
    // For mow, just load the groups in whatever order they are enumerated
    // in the registry.
    //
    while (!RegEnumKeyEx(hkeyCommonGroups, i, szGroupKey, &cchGroupKey, 0, 0, 0, &ft)) {
        if (cchGroupKey) {
            hwnd = LoadGroupWindow(szGroupKey, 0, TRUE);
        }
        cchGroupKey = CharSizeOf(szGroupKey);
        i++;
    }

    bAutoArrange = bRealArrange;

    /*
     * Check to see if there was any trouble.
     */
    if (fErrorOnExtract) {
        /*
         * On observed problem with icon extraction has been to do
         * with a low memory.
         */
        MyMessageBox(hwndProgman, IDS_OOMEXITTITLE, IDS_LOWMEMONEXTRACT,
        NULL, MB_OK|MB_ICONHAND|MB_SYSTEMMODAL);
    }
    return(hwnd);
}


/*** LoadAllGroups --
 *
 *
 * VOID APIENTRY LoadAllGroups(VOID)
 *
 * ENTRY -         VOID
 *
 * EXIT  -        VOID
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID PASCAL LoadAllGroups()
{
    LPTSTR pT, pszT;
    TCHAR szGroupList[(CGROUPSMAX+1)*18];
    WORD wIndex;
    TCHAR szPath[120];
    TCHAR szGroupKey[MAXKEYLEN];
    BOOL bRealArrange;
    DWORD cbData;
    DWORD dwType;
    BOOL fShowCommonGrps = TRUE;
    HKEY hkeyPMAnsiGroups = NULL;
    HKEY hkeyGroups;
    TCHAR szCommonGrpInfo[MAXKEYLEN];
    INT i;
    BOOL bDefaultPosition = FALSE;
    INT rgiPos[7];
    HWND hwndGroup;


    if (bUseANSIGroups) {
        RegCreateKeyEx(hkeyProgramManager, szAnsiGroups, 0, szProgman, 0,
                         KEY_READ | KEY_WRITE,
                         pSecurityAttributes, &hkeyPMAnsiGroups, NULL);
        hkeyGroups = hkeyPMAnsiGroups;
    }
    else {
        hkeyGroups = hkeyPMGroups;
    }
    if (!hkeyGroups) {  // cannot access registry.
        return;
    }

    /*
     * Set global to note that we haven't run out of memory yet.
     */
    fLowMemErrYet = FALSE;
    /*
     * Flag for extraction problems.
     */
    fErrorOnExtract = FALSE;

    // REVIEW - Why stop AutoArrange on load ? Switch it off for now.
    bRealArrange = bAutoArrange;

    //
    // If the user is allowed to see the common program groups, load them.
    //

    if (hkeyPMRestrict) {
        cbData = sizeof(fShowCommonGrps);
        RegQueryValueEx(hkeyPMRestrict, szShowCommonGroups, 0, &dwType, (LPBYTE)&fShowCommonGrps, &cbData);
    }
    if (fShowCommonGrps || AccessToCommonGroups) {

        RegCreateKeyEx(hkeyProgramManager, szCommonGroups, 0, szProgman, 0,
                         KEY_READ | KEY_WRITE,
                         pSecurityAttributes, &hkeyPMCommonGroups, NULL);
        //
        // Load all common program groups
        //
        LoadCommonGroups(szNULL);
    }

    //
    // Now load the user's personal program groups.
    //

    pT = szGroupList;
    for (GetGroupList(pT, hkeyGroups); *pT; pT += (lstrlen(pT) + 1)) {

        *szGroupKey = TEXT('\0');
        cbData = sizeof(szCommonGrpInfo);
        //
        // If we're loading a common group...
        //
        if (*(pT+CCHGROUP) == TEXT('C') && hkeyPMCommonGroups) {
            if (RegQueryValueEx(hkeyPMCommonGroups, pT, 0, 0,
                                 (LPBYTE)szCommonGrpInfo, &cbData))
                continue;
            wIndex = 0;
            for (pszT = pT + CCHCOMMONGROUP; *pszT; pszT++) {
                wIndex *= 10;
                wIndex += *pszT - TEXT('0');
            }
            //
            // Get the window coordinates of this common group.
            //
            pszT = szCommonGrpInfo;
            for (i=0; i < 7; i++) {
                 rgiPos[i] = 0;
                 while (*pszT && !((*pszT >= TEXT('0') && *pszT <= TEXT('9')) || *pszT == TEXT('-')))
                    pszT++;

                if (!*pszT) {
                    bDefaultPosition = TRUE;
                    break;
                }
                rgiPos[i] = MyAtoi(pszT);

                while (*pszT && ((*pszT >= TEXT('0') && *pszT <= TEXT('9')) || *pszT == TEXT('-')))
                    pszT++;
            }
            //
            // Now get the common group's name.
            //
            if (*pszT) {
                while(*pszT && *pszT == TEXT(' ')) pszT++;
                lstrcpy(szGroupKey, pszT);
            }

            hwndGroup = IsGroupAlreadyLoaded(szGroupKey, TRUE);
            if (!hwndGroup) {
                //
                // The common group no longer exists, remove this entry from
                // the user's list.
                //
                RegDeleteValue(hkeyPMCommonGroups, pT);
            }
            if (hwndGroup && !bDefaultPosition) {
                //
                // Position the common group according to the user's choice.
                //
                SetInternalWindowPos(hwndGroup, (UINT)rgiPos[6],
                                    (LPRECT)&rgiPos[0], (LPPOINT)&rgiPos[4]);
            }

        }
        else {
            if (RegQueryValueEx(hkeyGroups, pT, 0, 0, (LPBYTE)szGroupKey, &cbData))
                continue;
            wIndex = 0;
            for (pszT = pT + CCHGROUP; *pszT; pszT++) {
                wIndex *= 10;
                wIndex += *pszT - TEXT('0');
            }

            LoadGroupWindow(szGroupKey, wIndex, FALSE);
        }
    }
    bAutoArrange = bRealArrange;

    //
    // If we started with ANSI groups, save the newly converted unicode
    // groups now.
    //
    if (bUseANSIGroups) {
        WriteINIFile();
    }

    if (hkeyPMAnsiGroups) {
        RegCloseKey(hkeyPMAnsiGroups);
    }

    /*
     * Record the current display driver.
     */
    GetPrivateProfileString(szSystemBoot, szSystemDisplay, szPath, szPath, CharSizeOf(szPath), szSystemIni);
    RegSetValueEx(hkeyPMSettings, szSystemDisplay, 0, REG_SZ, (LPBYTE)szPath, sizeof(TCHAR)*(lstrlen(szPath)+1));

    /*
     * Check to see if there was any trouble.
     */
    if (fErrorOnExtract) {
        /*
         * On observed problem with icon extraction has been to do
         * with a low memory.
         */
        MyMessageBox(hwndProgman, IDS_OOMEXITTITLE, IDS_LOWMEMONEXTRACT,
        NULL, MB_OK|MB_ICONHAND|MB_SYSTEMMODAL);
    }
}

//*************************************************************
//
//  UseAnsiGroups()
//
//  Purpose:    Determine if we should convert the ANSI groups
//              to Unicode groups.
//
//  Parameters: DWORD dwDisp - disposition from RegCreateKeyEx
//                             on UNICODE Program Groups
//
//  Return:     BOOL  TRUE if the groups should be converted
//                    FALSE if not
//
//*************************************************************

BOOL UseAnsiGroups(DWORD dwDisp)
{
    DWORD dwType, dwMigrateValue, dwSize, dwAnsiValue = 0;
    LONG  lResult;
    BOOL  bRet = FALSE;
    HKEY  hKeyAnsiPG;


    //
    // If the dwDisp is a new key, then we return immediately and use
    // the ANSI groups if they exist.
    //

    if (dwDisp == REG_CREATED_NEW_KEY) {
        return TRUE;
    }

    //
    // dwDisp is an existing key.
    // If the "Migrate Ansi" value exist and the ANSI groups exist,
    // then use them otherwise use the current UNICODE information.
    //

    dwSize = sizeof (DWORD);
    lResult = RegQueryValueEx (hkeyProgramGroups, szMigrateAnsi,
                               NULL, &dwType, (LPBYTE) &dwMigrateValue,
                               &dwSize);

    //
    // Check the return value of registry call.  If it fails
    // then we are working with a machine that has UNICODE Program
    // Groups, and does not need to be updated from the ANSI groups.
    // Most of the time, we will exit here.
    //

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    //
    // Now we need to know if any ANSI groups exist.
    //

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER, szAnsiProgramGroups,
                            0, KEY_READ, &hKeyAnsiPG);

    if (lResult == ERROR_SUCCESS) {
        TCHAR szName[MAX_PATH];
        DWORD dwNameSize = MAX_PATH;
        FILETIME ft;

        //
        // The "Program Groups" key exists, check to see if there is
        // really something in it.
        //

        lResult = RegEnumKeyEx (hKeyAnsiPG, 0, szName, &dwNameSize, NULL,
                                NULL, NULL, &ft);

        //
        // If the return value is success, then there is one or more
        // items in the ANSI key.
        //

        if (lResult == ERROR_SUCCESS) {
            dwAnsiValue = 1;
        } else {
            dwAnsiValue = 0;
        }

        //
        // Close the key
        //

        RegCloseKey (hKeyAnsiPG);
    }

    //
    // If the MigrateValue is set, then we want to delete this entry
    // so the next time the user logs we don't try to convert the ANSI
    // groups again (and this function will execute faster).
    //

    if (dwMigrateValue) {
        RegDeleteValue (hkeyProgramGroups, szMigrateAnsi);
    }

    //
    // Determine the return value.
    //

    if (dwMigrateValue && dwAnsiValue) {
        bRet = TRUE;
    } else {
        bRet = FALSE;
    }


    return (bRet);

}


/*** ReadConfigFile --
 *
 *
 * BOOL APIENTRY ReadConfigFile(int nCmdShow)
 *
 * ENTRY -         int                CmdShow        -
 *
 * EXIT  -        void
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID NEAR PASCAL ReadConfigFile(int nCmdShow)
{
  int       j;
  int       rgiPos[5];
  LPTSTR    pszT, pT;
  HCURSOR   hCursor;
  BOOL      bErrorMsgDisplayed = FALSE;
  TCHAR     szCommonGroupsKey[MAXKEYLEN];
  DWORD     dwDisposition;
  HKEY      hkey = NULL;

  hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
  ShowCursor(TRUE);

  /*
   * Create/Open the registry keys corresponding to progman.ini sections.
   */
  if (!RegCreateKeyEx(HKEY_CURRENT_USER, PROGMAN_KEY, 0, szProgman, 0,
                         KEY_READ | KEY_WRITE,
                         pSecurityAttributes, &hkeyProgramManager, NULL)) {

      RegCreateKeyEx(hkeyProgramManager, szSettings, 0, szProgman, 0,
                         KEY_READ | KEY_WRITE,
                         pSecurityAttributes, &hkeyPMSettings, NULL);

      RegCreateKeyEx(hkeyProgramManager, szRestrict, 0, szProgman, 0,
                         KEY_READ,
                         pSecurityAttributes, &hkeyPMRestrict, NULL);

      RegCreateKeyEx(hkeyProgramManager, szGroups, 0, szProgman, 0,
                         KEY_READ | KEY_WRITE,
                         pSecurityAttributes, &hkeyPMGroups, NULL);
  }
  else {
      MyMessageBox(NULL, IDS_APPTITLE, IDS_REGISTRYERROR, NULL, MB_OK | MB_ICONEXCLAMATION);
      bErrorMsgDisplayed = TRUE;
  }

  /* Get the global variable settings out of the INI file. */
  if (pszT = GetSettings()) {
      /* Get the window coordinates for PROGMAN's main window. */
      pT = pszT;
      for (j=0; j < 5; j++) {
          rgiPos[j] = 0;
          while (*pT && !((*pT >= TEXT('0') && *pT <= TEXT('9')) || *pT == TEXT('-')))
              pT++;

          if (!*pT) {
              LocalFree((HANDLE)pszT);
              goto DefaultPosition;
          }

          rgiPos[j] = MyAtoi(pT);

          while (*pT && ((*pT >= TEXT('0') && *pT <= TEXT('9')) || *pT == TEXT('-')))
              pT++;
      }
      LocalFree((HANDLE)pszT);
  }
  else {

DefaultPosition:
      /* NOTE: cx = 0 - CW_USEDEFAULT == CW_USEDEFAULT (0x8000) */
      rgiPos[0] = rgiPos[1] = CW_USEDEFAULT;
      rgiPos[2] = rgiPos[3] = 0;
      rgiPos[4] = SW_SHOWNORMAL;
  }

  if (nCmdShow != SW_SHOWNORMAL)
      rgiPos[4] = nCmdShow;

  /*
   * We don't want an invisible Program Manager!
   */
  if (!(rgiPos[4]))
      rgiPos[4] = SW_SHOWNORMAL;

  /* Create and paint the top-level frame window. */
  if (!CreateFrameWindow((PRECT)rgiPos, (WORD)rgiPos[4]))
      goto RCFErrExit;

  /*
   * Will create/open the key Program Groups, parent of all groups.
   */
  if (RegCreateKeyEx(HKEY_CURRENT_USER, szProgramGroups, 0, szGroups, 0,
                     KEY_READ | KEY_WRITE,
                     pSecurityAttributes, &hkeyProgramGroups, &dwDisposition)) {
      if (!bErrorMsgDisplayed) {
          MyMessageBox(NULL, IDS_APPTITLE, IDS_REGISTRYERROR, NULL, MB_OK | MB_ICONEXCLAMATION);
      }
      goto RCFErrExit;
  }
  if (UseAnsiGroups(dwDisposition)) {
      //
      // There are no UNICODE groups, so convert the ANSI groups and save
      // them as UNICODE groups.
      //
      bUseANSIGroups = TRUE;
      if (RegCreateKeyEx(HKEY_CURRENT_USER, szAnsiProgramGroups, 0, szGroups, 0,
                     KEY_READ,
                     pSecurityAttributes, &hkeyAnsiProgramGroups, &dwDisposition)) {
          if (!bErrorMsgDisplayed) {
              MyMessageBox(NULL, IDS_APPTITLE, IDS_REGISTRYERROR, NULL, MB_OK | MB_ICONEXCLAMATION);
          }
          goto RCFErrExit;
      }
  }


  /*
   * Will create/open the key Program Groups for common groups on the local
   * machine.
   */

  lstrcpy(szCommonGroupsKey, TEXT("SOFTWARE\\"));
  lstrcat(szCommonGroupsKey, szAnsiProgramGroups);

  //
  // Try opening/creating the common groups key with Write access
  //
OpenCommonGroupsKey:

  if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szCommonGroupsKey, 0, szGroups, 0,
                         KEY_READ | KEY_WRITE | DELETE,
                         pAdminSecAttr, &hkeyCommonGroups, &dwDisposition)
               == ERROR_SUCCESS) {
      if (dwDisposition == REG_CREATED_NEW_KEY) {
          //
          // need to close and reopen the key to make sure we have the
          // right access
          //
          RegCloseKey(hkeyCommonGroups);
          goto OpenCommonGroupsKey;
      }
      AccessToCommonGroups = TRUE;

  } else {

      RegOpenKeyEx(HKEY_LOCAL_MACHINE, szCommonGroupsKey, 0, KEY_READ,
                         &hkeyCommonGroups);
  }

  //
  // If we have Ansi groups in the profile, add a menu item under the Options menu
  // to remove the old NT1.0 ANSI groups. This menu item will be deleted we the
  // user selects to remove the old groups
  //
  if (!fNoSave && (bUseANSIGroups || !RegOpenKeyEx(HKEY_CURRENT_USER,
                                      szAnsiProgramGroups,
                                      0,
                                      DELETE | KEY_READ | KEY_WRITE, &hkey))){

      HMENU hMenu = GetSubMenu(GetMenu(hwndProgman), 1);

      AppendMenu(hMenu, MF_SEPARATOR, 0, NULL);
      LoadString(hAppInstance, IDS_ANSIGROUPSMENU, szMessage, CharSizeOf(szMessage));
      AppendMenu(hMenu, MF_STRING | MF_ENABLED, IDM_ANSIGROUPS, szMessage);
      if (hkey) {
          RegCloseKey(hkey);
      }
  }


  /* The main frame window's been created, shown, and filled.
   * It's time to read the various group files, by enumerating group#
   * lines in PROGMAN.INI
   */
  LoadAllGroups();

  /*
   * Restriction key is no longer needed.
   */
  if (hkeyPMRestrict) {
      RegCloseKey(hkeyPMRestrict);
      hkeyPMRestrict = NULL;
  }


RCFErrExit:
  //
  // We've got the Ansi groups, reset this value.
  //
  bUseANSIGroups = FALSE;
  RegCloseKey(hkeyAnsiProgramGroups);
  hkeyAnsiProgramGroups = NULL;

  ShowCursor(FALSE);
  SetCursor(hCursor);
  ShowWindow(hwndMDIClient,SW_SHOWNORMAL);
}

/****************************************************************************
 *
 *   FUNCTION: ParseReserved(LPTSTR lpReserved, LPDWORD lpDdeId, LPDWORD lpHotKey)
 *
 *   PURPOSE: Parses the lpReserved field of the StartupInfo structure to
 *            get the Progman's new instance DDE id and its Hot key.
 *            The lpReserved field is a string of thee following format:
 *            "dde.%d,hotkey.%d"
 *
 *            Returns the dde id and hotkey.
 *
 *   COMMENTS: This is to be compatible with Win3.1 by allowing users to
 *             set a hotkey for Progman, and to allow them to change
 *             Progman's icon and window title (see SetProgmanProperties in
 *             pmwprocs.c)
 *
 *
 *   HISTORY:  08-28-92 JohanneC   Created.
 *
 ****************************************************************************/

void  ParseReserved(LPTSTR lpReserved, LPDWORD lpDdeId, LPDWORD lpHotKey)
{
   TCHAR *pch, *pchT, ch;

    //
    // The string will be of the format "dde.%d,hotkey.%d"
    //

    //
    // Get the DDE id.
    //
    if ((pch = wcsstr(lpReserved, TEXT("dde."))) != NULL) {
        pch += 4;

        pchT = pch;
        while (*pchT >= TEXT('0') && *pchT <= TEXT('9'))
            pchT++;

        ch = *pchT;
        *pchT = 0;
        *lpDdeId = MyAtoi(pch);
        *pchT = ch;

    }

    //
    // Get the hot key.
    //
    if ((pch = wcsstr(lpReserved, TEXT("hotkey."))) != NULL) {
        pch += 7;

        pchT = pch;
        while (*pchT >= TEXT('0') && *pchT <= TEXT('9'))
            pchT++;

        ch = *pchT;
        *pchT = 0;
        *lpHotKey = MyAtoi(pch);
        *pchT = ch;

    }
}

/*** IsHandleReallyProgman --
 *
 *
 * BOOL IsHandleReallyProgman (HWND hProgman, LPTSTR lpClassName)
 *
 * ENTRY -  HWND        hProgman
 *
 * EXIT  -  BOOL        TRUE if it is progman
 *                      FALSE if not
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

BOOL IsHandleReallyProgman(HWND hwndProgman)
{

    //
    // Test to see if we found Progman or Explorer.
    //

    if ((GetClassLong (hwndProgman, GCL_STYLE) == 0) &&
        (GetClassLongPtr (hwndProgman, GCLP_HICON) != 0) &&
        (GetClassLongPtr (hwndProgman, GCLP_MENUNAME) != 0)) {

        return TRUE;
    }

    return FALSE;
}


/*** AppInit --
 *
 *
 * BOOL APIENTRY AppInit(HANDLE hInstance, HANDLE hPrevInstance,
 *                                                  LPTSTR lpszCmdLine, int nCmdShow)
 *
 * ENTRY -  HANDLE        hInstance
 *          HANDLE        hPrevInstance
 *          LPTSTR        lpszCmdLine
 *          int                nCmdSHow
 *
 * EXIT  -  BOOL        xxx                - (FALSE == ERROR)
 *
 * SYNOPSIS -          ??
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

BOOL APIENTRY AppInit(HANDLE hInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
  WORD              ret;
  WNDCLASS          wndClass;
  TCHAR              szClass[16];
  TCHAR              szBuffer[MAX_PATH];
  LOGFONT           lf;
  TCHAR              szText[MAXMESSAGELEN+1];
  STARTUPINFO       si;
  HWND hwndPrev;
  INT               nTempCmdShow = nCmdShow;

#ifdef DEBUG_PROGMAN_DDE
  {
  TCHAR szDebug[300];

  wsprintf (szDebug, TEXT("%d   PROGMAN:   Enter AppInit\r\n"),
            GetTickCount());
  OutputDebugString(szDebug);
  }
#endif


  //
  // Preserve this instance's module handle.
  //
  hAppInstance = hInstance;

  //
  // Specify the shutdown order of the progman process.
  // 2 means Porgman will shutdown before taskman (level = 1) and
  // ntsd or windbg (level = 0)
  //
  SetProcessShutdownParameters(2,0);

#ifndef MYDEBUG
  LoadString(hAppInstance, IDS_PMCLASS, szClass, CharSizeOf(szClass));
  if (hwndPrev = FindWindow(szClass, NULL)) {

      bDisableDDE = TRUE;           // Only 1 "PROGMAN" should respond to dde

      if (IsHandleReallyProgman(hwndPrev)) {
          DWORD dwDdeId = 0;
          DWORD dwHotKey = 0;
          LONG  lExiting;

          GetStartupInfo(&si);
          if (si.lpReserved) {
              ParseReserved(si.lpReserved, &dwDdeId, &dwHotKey);
          }

          PostMessage(hwndPrev, WM_EXECINSTANCE, (WPARAM)dwDdeId, dwHotKey);

          //
          // Need to check the other progman to see if it is exiting currently.
          // If so, then we will continue.  GetWindowLong returns 0 as a
          // failure case and as the "Not exiting" case (1 if we are exiting),
          // so we need to confirm that the last error is also
          // zero.
          //

          lExiting = GetWindowLong (hwndPrev, GWL_EXITING);

          if (lExiting != 1) {
              return FALSE;
          }
      }
  }
#endif

  /*
   * Compute general constants.
   */
  dyBorder = GetSystemMetrics(SM_CYBORDER);
  hItemIcon = LoadIcon(hAppInstance, (LPTSTR) MAKEINTRESOURCE(ITEMICON));
  if (!hItemIcon) {
      return FALSE;
  }

  /*
   * Load the accelerator table.
   */
  hAccel = LoadAccelerators(hAppInstance, (LPTSTR) MAKEINTRESOURCE(PMACCELS));
  if (!hAccel)
      return FALSE;

  cxIcon = GetSystemMetrics(SM_CXICON);
  cyIcon = GetSystemMetrics(SM_CYICON);

  cxOffset = 2 * GetSystemMetrics(SM_CXBORDER);
  cyOffset = 2 * GetSystemMetrics(SM_CYBORDER);

  cxIconSpace = cxIcon + 2 * cxOffset;
  cyIconSpace = cyIcon + 2 * cyOffset;

  SystemParametersInfo(SPI_ICONHORIZONTALSPACING, 0, (PVOID)(LPINT)&cxArrange, FALSE);
  SystemParametersInfo(SPI_ICONVERTICALSPACING, 0, (PVOID)(LPINT)&cyArrange, FALSE);
  SystemParametersInfo(SPI_GETICONTITLEWRAP, 0, (PVOID)(LPWORD)&bIconTitleWrap, FALSE);
  SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (PVOID)(LPLOGFONT)&lf, FALSE);


  // lhb tracks check this out !!!! save this one for later! 1/21/93
  //lf.lfCharSet = ANSI_CHARSET ;
  //lstrcpy (lf.lfFaceName, TEXT("Lucida Sans Unicode"));

  hFontTitle = CreateFontIndirect(&lf);

  if (!hFontTitle)
      return FALSE;

  hIconGlobal = LoadIcon(hAppInstance,(LPTSTR) MAKEINTRESOURCE(WORDICON));
  if (!hIconGlobal) {
      return FALSE;
  }

  /*
   * Remember the original directory.
   */
  GetCurrentDirectory(MAXITEMPATHLEN+1, szOriginalDirectory);

  //
  // Set Progman's working directory to system32 directory instead of the
  // windows directory. johannec 5-4-93 bug 8364
  //
  //GetWindowsDirectory(szWindowsDirectory, MAXITEMPATHLEN+1);
  GetSystemDirectory(szWindowsDirectory, MAXITEMPATHLEN+1);

  /*
   * Make sure drive letter is upper case.
   */
  CharUpperBuff(szWindowsDirectory, 1);

  bInNtSetup = FALSE;

  if (lpszCmdLine && *lpszCmdLine &&
      !lstrcmpi(lpszCmdLine, TEXT("/NTSETUP"))) {
          //
          // Progman was started from ntsetup.exe, so it can be exited
          // without causing NT Windows to exit.
          //
          bExitWindows = FALSE;
          bInNtSetup = TRUE;
          *lpszCmdLine = 0;

  }
  else {
      HKEY hkeyWinlogon;
      DWORD dwType;
      DWORD cbBuffer;
      LPTSTR lpt;

      /* Check if we should be the shell by looking at shell= line for WInlogon
       */
      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                   0,
                   KEY_READ,
                   &hkeyWinlogon) == ERROR_SUCCESS) {
          cbBuffer = sizeof(szBuffer);
          if (RegQueryValueEx(hkeyWinlogon,
                              TEXT("Shell"),
                              0,
                              &dwType,
                              (LPBYTE)szBuffer,
                              &cbBuffer) == ERROR_SUCCESS) {
              CharLower(szBuffer);
              lpt = szBuffer;
              while (lpt = wcsstr(lpt, szProgman)) {
                  //
                  // we probably found progman
                  //
                  lpt += lstrlen(szProgman);
                  if (*lpt == TEXT(' ') || *lpt == TEXT('.') || *lpt == TEXT(',') || !*lpt)
                      bExitWindows = TRUE;
              }
          }
          else {
              //
              // assume that progman is the shell.
              //
              bExitWindows = TRUE;
          }
          RegCloseKey(hkeyWinlogon);
      }
      else {
          //
          // assume that progman is the shell.
          //
          bExitWindows = TRUE;
      }

  }

  if (lpszCmdLine && *lpszCmdLine) {
      nCmdShow = SW_SHOWMINNOACTIVE;
  }


    /*
     * call private api to mark task man as a system app. This causes
     * it to be killed after all other non-system apps during shutdown.
     */
//  MarkProcess(MP_SYSTEMAPP);


  /*
   * Load these strings now.  If we need them later,
   * we won't be able to load them at that time.
   */
  LoadString(hAppInstance, IDS_OOMEXITTITLE, szOOMExitTitle, CharSizeOf(szOOMExitTitle));
  LoadString(hAppInstance, IDS_OOMEXITMSG, szOOMExitMsg, CharSizeOf(szOOMExitMsg));

  LoadString(hAppInstance, IDS_PMCLASS, szClass, CharSizeOf(szClass));

  SetCurrentDirectory(szWindowsDirectory);

  SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS); // Bounce errors to us, not fs.

  // Set global exit flag.
  fExiting = FALSE;

  uiHelpMessage = RegisterWindowMessage(TEXT("ShellHelp"));
  uiBrowseMessage = RegisterWindowMessage(HELPMSGSTRING);
  uiActivateShellWindowMessage = RegisterWindowMessage(TEXT("ACTIVATESHELLWINDOW"));
  uiConsoleWindowMessage = RegisterWindowMessage(TEXT("ConsoleProgmanHandle"));
  uiSaveSettingsMessage = RegisterWindowMessage(TEXT("SaveSettings"));  // for UPEDIT.exe : User Profile Editor

  hhkMsgFilter = SetWindowsHook(WH_MSGFILTER, MessageFilter);
  if (hhkMsgFilter == 0) {
      GetLastError();
  }
  /*
   * Register the Frame window class.
   */
  wndClass.lpszClassName    = szClass;
  wndClass.style            = 0;
  wndClass.lpfnWndProc      = ProgmanWndProc;
  wndClass.cbClsExtra       = 0;
  wndClass.cbWndExtra       = sizeof(LONG);
  wndClass.hInstance        = hAppInstance;
  wndClass.hIcon            = hProgmanIcon = LoadIcon(hAppInstance, (LPTSTR) MAKEINTRESOURCE(PROGMANICON));
  wndClass.hCursor          = LoadCursor(NULL, IDC_ARROW);
  wndClass.hbrBackground    = NULL;
  wndClass.lpszMenuName     = (LPTSTR) MAKEINTRESOURCE(PROGMANMENU);

  if (!RegisterClass(&wndClass))
      return(FALSE);

  /*
   * Register the Program Group window class.
   */
  LoadString(hAppInstance, IDS_GROUPCLASS, szClass, 16);
  wndClass.lpszClassName    = szClass;
  wndClass.style            = CS_DBLCLKS;
  wndClass.lpfnWndProc      = GroupWndProc;
/*wndClass.cbClsExtra       = 0;*/
  wndClass.cbWndExtra       = sizeof(PGROUP);                    /* <== PGROUP */
/*wndClass.hInstance        = hAppInstance;*/
  wndClass.hIcon            = NULL;
/*wndClass.hCursor          = LoadCursor(NULL, IDC_ARROW);*/
  wndClass.hbrBackground    = (HBRUSH)(COLOR_WINDOW + 1);
  wndClass.lpszMenuName     = NULL;

  if (!RegisterClass(&wndClass))
      return(FALSE);

  {
      //
      // Set the working set size to 300k.
      //

      QUOTA_LIMITS QuotaLimits;
      NTSTATUS status;

      status = NtQueryInformationProcess( NtCurrentProcess(),
                                          ProcessQuotaLimits,
                                          &QuotaLimits,
                                          sizeof(QUOTA_LIMITS),
                                          NULL );
      if (NT_SUCCESS(status)) {
          QuotaLimits.MinimumWorkingSetSize = 400 * 1024;
          QuotaLimits.MaximumWorkingSetSize = 508 * 1024;

          NtSetInformationProcess( NtCurrentProcess(),
                                   ProcessQuotaLimits,
                                   &QuotaLimits,
                                   sizeof(QUOTA_LIMITS) );
      }
  }

  hGroupIcon = LoadIcon(hAppInstance, (LPTSTR) MAKEINTRESOURCE(PERSGROUPICON));
  hCommonGrpIcon = LoadIcon(hAppInstance, (LPTSTR) MAKEINTRESOURCE(COMMGROUPICON));

  if (!RegisterHotKeyClass((HANDLE)hAppInstance))
      return FALSE;

  RegisterDDEClasses((HANDLE)hAppInstance);

  /*
   * Initialize the security descriptor for the registry keys that
   * will be added to the user's personal profile.
   */
  pSecurityAttributes = &SecurityAttributes;
  if (!InitializeSecurityAttributes(pSecurityAttributes, TRUE))
      pSecurityAttributes = NULL;

  /*
   * Initialize the security descriptor for the registry keys that
   * will be added to the local machine program groups. Only
   * Administrators, Power Users and Server Operators
   * have all access to these keys, other users have only read access.
   */
  pAdminSecAttr = &AdminSecAttr;
  if (!InitializeSecurityAttributes(pAdminSecAttr, FALSE))
      pAdminSecAttr = NULL;


  /*
   * Test if the current user is an admin. If so, ignore restrictions
   * from the profile.
   */

  UserIsAdmin = TestUserForAdmin();

  /*
   * Read in the Group/Item data structures and create the windows.
   */
#ifdef DEBUG_PROGMAN_DDE
  {
  TCHAR szDebug[300];

  wsprintf (szDebug, TEXT("%d   PROGMAN:   Before ReadConfigFile\r\n"),
            GetTickCount());
  OutputDebugString(szDebug);
  }
#endif

  ReadConfigFile(nCmdShow);

#ifdef DEBUG_PROGMAN_DDE
  {
  TCHAR szDebug[300];

  wsprintf (szDebug, TEXT("%d   PROGMAN:   After ReadConfigFile\r\n"),
            GetTickCount());
  OutputDebugString(szDebug);
  }
#endif
  if (hwndProgman == NULL)
      return FALSE;

  /*
   * NOTE: the nCmdShow stuff from here down is bogus
   *
   * Do load/run lines, then the command line, then the startup group...
   */
  if (bExitWindows)
      DoRunEquals(&nCmdShow);

  /* Process the Command Line */
  if (lpszCmdLine && *lpszCmdLine) {
      WORD cbText;
      TCHAR szFilename[MAXITEMPATHLEN+1];

      lstrcpy(szPathField, lpszCmdLine);
      // win foo.bar is done relative to the original directory.
      SetCurrentDirectory(szOriginalDirectory);
      GetDirectoryFromPath(szPathField, szDirField);

      // now kernel converts the DOS cmd line to Ansi for us!
      GetFilenameFromPath(szPathField, szFilename);
      ret = ExecProgram(szFilename, szDirField, NULL, FALSE, 0, 0, 0);
      if (ret) {
          szText[0] = TEXT('\'');
          lstrcpy(&szText[1],szPathField);
          cbText = (WORD)lstrlen(szText);
          LoadString(hAppInstance,IDS_CMDLINEERR,&szText[cbText],CharSizeOf(szText)-cbText);
          MyMessageBox(NULL, IDS_APPTITLE, ret, szText, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
      } else
 	      nCmdShow = SW_SHOWMINNOACTIVE;
      SetCurrentDirectory(szWindowsDirectory);
  }

  /*
   * See if we have a startup group last.
   */
#ifndef MYDEBUG
  if (bExitWindows || GetAsyncKeyState(VK_CONTROL) < 0)
#endif
      HandleStartupGroup(nTempCmdShow);

  /*
   * create an event for monitoring the ProgramGroups key.
   */
  InitializeGroupKeyNotification();

  if (bInitialArrange) {
      PostMessage(hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
      PostMessage(hwndProgman, WM_COMMAND, IDM_SAVENOW, 0L);
  }

#ifdef DEBUG_PROGMAN_DDE
  {
  TCHAR szDebug[300];

  wsprintf (szDebug, TEXT("%d   PROGMAN:   Leave AppInit\r\n"),
            GetTickCount());
  OutputDebugString(szDebug);
  }
#endif

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\progman.h ===
/*++ BUILD Version: 0002    - Increment this if a change has global effects

/****************************************************************************/
/*                                                                          */
/*  PROGMAN.H -                                                             */
/*                                                                          */
/*      Include for the Windows Program Manager                             */
/*                                                                          */
/****************************************************************************/

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <setjmp.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <winuserp.h>

#ifndef RC_INVOKED
#include "port1632.h"
#undef RDW_VALIDMASK
#endif

#include <pmvdm.h>

#include "pmhelp.h"
#include "shellapi.h"
#include "shlapip.h"

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Typedefs                                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

typedef struct tagITEM {
    struct tagITEM *pNext;              /* link to next item */
    int             iItem;              /* index in group */
    DWORD           dwDDEId;            /* id used for Apps querying Progman */
                                        /* for its properties via DDE */
    RECT            rcIcon;             /* icon rectangle */
    HICON           hIcon;              /* the actual icon */
    RECT            rcTitle;            /* title rectangle */
} ITEM, *PITEM;

typedef struct tagGROUP {
    struct tagGROUP *pNext;               /* link to next group            */
    HWND            hwnd;                 /* hwnd of group window          */
    HANDLE          hGroup;               /* global handle of group object */
    PITEM           pItems;               /* pointer to first item         */
    LPTSTR          lpKey;                /* name of group key             */
    WORD            wIndex;               /* index in PROGMAN.INI of group */
    BOOL            fRO;                  /* group file is readonly        */
    BOOL            fCommon;              /* group is a common group vs a personal group */
    FILETIME        ftLastWriteTime;
    HBITMAP         hbm;                  /* bitmap 'o icons               */
    WORD            fLoaded;
    PSECURITY_DESCRIPTOR pSecDesc;
} GROUP, *PGROUP;

/*
 * .GRP File format structures -
 */
typedef struct tagGROUPDEF {
    DWORD   dwMagic;        /* magical bytes 'PMCC' */
    DWORD   cbGroup;        /* length of group segment */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    nCmdShow;       /* min, max, or normal state */
    DWORD   pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */

    WORD    cItems;         /* number of items in group */
    WORD    Reserved1;
    DWORD   Reserved2;
    DWORD   rgiItems[1];    /* array of ITEMDEF offsets */
} GROUPDEF, *PGROUPDEF;
typedef GROUPDEF *LPGROUPDEF;

typedef struct tagITEMDEF {
    POINT   pt;             /* location of item icon in group */
    WORD    iIcon;          /* id of item icon */
    WORD    wIconVer;       /* icon version */
    WORD    cbIconRes;      /* size of icon resource */
    WORD    wIconIndex;     /* index of the item icon (not the same as the id) */
    DWORD   pIconRes;       /* offset of icon resource */
    DWORD   pName;          /* offset of name string */
    DWORD   pCommand;       /* offset of command string */
    DWORD   pIconPath;      /* offset of icon path */
} ITEMDEF, *PITEMDEF;
typedef ITEMDEF *LPITEMDEF;


/* the pointers in the above structures are short pointers relative to the
 * beginning of the segments.  This macro converts the short pointer into
 * a long pointer including the proper segment/selector value.        It assumes
 * that its argument is an lvalue somewhere in a group segment, for example,
 * PTR(lpgd->pName) returns a pointer to the group name, but k=lpgd->pName;
 * PTR(k) is obviously wrong as it will use either SS or DS for its segment,
 * depending on the storage class of k.
 */
#define PTR(base, offset) (LPBYTE)((PBYTE)base + offset)

/* PTR2 is used for those cases where a variable already contains an offset
 * (The "case that doesn't work", above)
 */
#define PTR2(lp,offset) ((LPBYTE)MAKELONG(offset,HIWORD(lp)))

/* this macro is used to retrieve the i-th item in the group segment.  Note
 * that this pointer will NOT be NULL for an unused slot.
 */
#define ITEM(lpgd,i) ((LPITEMDEF)PTR(lpgd, lpgd->rgiItems[i]))

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Tag Stuff                                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

typedef struct _tag
  {
    WORD wID;                   // tag identifier
    WORD dummy1;                // need this for alignment!
    int wItem;                  // (unde the covers 32 bit point!)item the tag belongs to
    WORD cb;                    // size of record, including id and count
    WORD dummy2;                // need this for alignment!
    BYTE rgb[1];
  } PMTAG, FAR * LPPMTAG;

#define PMTAG_MAGIC GROUP_MAGIC

    /* range 8000 - 80FF > global
     * range 8100 - 81FF > per item
     * all others reserved
     */

#define ID_MAINTAIN             0x8000
    /* bit used to indicate a tag that should be kept even if the writer
     * doesn't recognize it.
     */

#define ID_MAGIC                0x8000
    /* data: the string 'TAGS'
     */

#define ID_WRITERVERSION        0x8001
    /* data: string in the form [9]9.99[Z].99
     */

#define ID_APPLICATIONDIR       0x8101
    /* data: ASCIZ string of directory where application may be
     * located.
     * this is defined as application dir rather than default dir
     * since the default dir is explicit in the 3.0 command line and
     * must stay there.  The true "new information" is the application
     * directory.  If not present, search the path.
     */

#define ID_HOTKEY               0x8102
    /* data: WORD hotkey index
     */

#define ID_MINIMIZE             0x8103
    /* data none
     */

#define ID_NEWVDM               0x8104
    /* data none
     */

#define ID_LASTTAG              0xFFFF
    /* the last tag in the file
     */


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  For Icon Extraction                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

typedef struct _MyIconInfo {
    HICON hIcon;
    INT iIconId;
} MYICONINFO, *LPMYICONINFO;

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Function Templates                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/


BOOL  FAR PASCAL IsRemoteDrive(int);
BOOL  FAR PASCAL IsRemovableDrive(int);

int   FAR PASCAL MyMessageBox(HWND, WORD, WORD , LPTSTR , WORD);
BOOL  FAR PASCAL AppInit(HANDLE, LPTSTR , int);
void  FAR PASCAL BuildDescription(LPTSTR, LPTSTR);
WORD  FAR PASCAL ExecProgram(LPTSTR, LPTSTR, LPTSTR, BOOL, DWORD, WORD, BOOL);
void  FAR PASCAL ExecItem(PGROUP,PITEM,BOOL,BOOL);
WORD  FAR PASCAL SelectionType(void);
BOOL  APIENTRY ProgmanCommandProc(HWND, WPARAM, LPARAM);
void  FAR PASCAL WriteINIFile(void);
void  FAR PASCAL ArrangeItems(HWND);
void  FAR PASCAL WriteGroupsSection(void);
LRESULT APIENTRY DDEMsgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY AppIconDDEMsgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY AppDescriptionDDEMsgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY AppWorkingDirDDEMsgProc(HWND, UINT, WPARAM, LPARAM);

BOOL FAR PASCAL IsGroupReadOnly(LPTSTR szGroupKey, BOOL bCommonGroup);
LPGROUPDEF FAR PASCAL LockGroup(HWND);
void  FAR PASCAL UnlockGroup(HWND);
LPITEMDEF FAR PASCAL LockItem(PGROUP, PITEM);
HICON FAR PASCAL GetItemIcon(HWND, PITEM);
HWND  FAR PASCAL LoadGroupWindow(LPTSTR, WORD, BOOL);
PITEM FAR PASCAL CreateNewItem(HWND,LPTSTR,LPTSTR,LPTSTR,LPTSTR,WORD,BOOL,WORD,WORD,HICON,LPPOINT,DWORD);
HWND  FAR PASCAL CreateNewGroup(LPTSTR, BOOL);
void  FAR PASCAL DeleteItem(PGROUP, PITEM);
void  FAR PASCAL DeleteGroup(HWND);
void  FAR PASCAL ChangeGroupTitle(HWND, LPTSTR, BOOL);
void  FAR PASCAL CreateItemIcons(HWND);
void  FAR PASCAL GetItemText(PGROUP,PITEM,LPTSTR,int);
void  FAR PASCAL InvalidateIcon(PGROUP,PITEM);
void  FAR PASCAL ComputeIconPosition(PGROUP,POINT,LPRECT,LPRECT,LPTSTR);
void  FAR PASCAL CalcGroupScrolls(HWND);
BOOL  FAR PASCAL GroupCheck(PGROUP);
void  FAR PASCAL UnloadGroupWindow(HWND);
void  FAR PASCAL NukeIconBitmap(PGROUP pGroup);

WORD  FAR PASCAL GroupFlag(PGROUP, PITEM, WORD);
WORD  FAR PASCAL GetGroupTag(PGROUP, PITEM, WORD, LPTSTR, WORD);

VOID FAR PASCAL LoadAllGroups(VOID);

PITEM FAR PASCAL DuplicateItem(PGROUP,PITEM,PGROUP,LPPOINT);

void  FAR PASCAL GetItemCommand(PGROUP,PITEM,LPTSTR,LPTSTR);

VOID  APIENTRY RegisterDDEClasses(HANDLE);
INT MyDwordAlign(INT);

LRESULT APIENTRY GroupWndProc(HWND , UINT, WPARAM, LPARAM);
LRESULT APIENTRY ProgmanWndProc(HWND , UINT , WPARAM,  LPARAM );
WORD  FAR PASCAL MyDialogBox(WORD, HWND , DLGPROC );

INT_PTR APIENTRY ChooserDlgProc(HWND , UINT , WPARAM , LPARAM );
INT_PTR APIENTRY BrowseDlgProc(HWND, UINT , WPARAM , LPARAM );
INT_PTR APIENTRY RunDlgProc(HWND , UINT , WPARAM , LPARAM );
INT_PTR APIENTRY ExitDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY IconDlgProc(HWND , UINT , WPARAM , LPARAM );
INT_PTR APIENTRY NewItemDlgProc(HWND , UINT , WPARAM , LPARAM );
INT_PTR APIENTRY NewGroupDlgProc(HWND , UINT , WPARAM , LPARAM );
INT_PTR APIENTRY MoveItemDlgProc(HWND , UINT , WPARAM , LPARAM );
INT_PTR APIENTRY CopyItemDlgProc(HWND , UINT , WPARAM , LPARAM );
INT_PTR APIENTRY EditItemDlgProc(HWND , UINT , WPARAM , LPARAM );
INT_PTR APIENTRY EditGroupDlgProc(HWND, UINT , WPARAM , LPARAM );
INT_PTR APIENTRY AboutDlgProc(HWND , UINT , WPARAM , LPARAM );
INT_PTR APIENTRY HotKeyDlgProc(HWND , UINT , WPARAM , LPARAM );
BOOL  APIENTRY ShutdownDialog(HANDLE, HWND);
INT_PTR APIENTRY NewLogoffDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY UpdateGroupsDlgProc(HWND, UINT, WPARAM, LPARAM);
VOID  APIENTRY HandleDosApps
    (
    LPTSTR sz  // Full path sans arguments.
    );
DWORD  APIENTRY ValidatePath
    (
    HWND hDlg,
    LPTSTR szPath,        // Path to item
    LPTSTR szExePath,     // Path to associated exe.
    LPTSTR szDir          // Path to working directory.
    );
VOID APIENTRY GetDirectoryFromPath
    (
    LPTSTR szFilePath,    // Full path to a file.
    LPTSTR szDir          // Directory returned in here, the buffer is assumed
                        // to be as big as szFilePath.
    );
VOID APIENTRY GetFilenameFromPath
    (
    LPTSTR szPath,
    LPTSTR szFilename
    );
void APIENTRY TagExtension
    (
    LPTSTR szPath,
    UINT cbPath
    );
void APIENTRY StripArgs
    (
    LPTSTR szCmmdLine     // A command line.
    );
BOOL APIENTRY ValidPathDrive
    (
    LPTSTR lpstr
    );

LRESULT APIENTRY MessageFilter(int , WPARAM , LPARAM) ;

BOOL APIENTRY SaveGroup(HWND, BOOL);
BOOL SaveGroupsContent(BOOL);
BOOL IsReadOnly(LPTSTR);
VOID FAR PASCAL StartupGroup(HWND hwnd);
VOID APIENTRY PMHelp(HWND);
VOID FAR PASCAL RemoveLeadingSpaces(LPTSTR sz);
VOID FAR PASCAL BringItemToTop(PGROUP pGroup, PITEM pItem, BOOL fUpdate);
VOID APIENTRY SaveRecentFileList (HWND hwnd, LPTSTR szCurrentFile, WORD idControl);

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Defines                                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

#define CITEMSMAX 50
//
// CreateNewItem flags
//
#define CI_ACTIVATE            0x1
#define CI_SET_DOS_FULLSCRN    0x2
#define CI_NO_ASSOCIATION      0x4
#define CI_SEPARATE_VDM        0x8

/* magic number for .GRP file validation
 */
#define GROUP_MAGIC             0x43434D50L  /* 'PMCC' */
#define GROUP_UNICODE           0x43554D50L  /* 'PMUC' */

#define MAXTITLELEN             50        /* Length of MessageBox titles */
#define MAXMESSAGELEN           512        /* Length of MessageBox messages */

#define MAXITEMNAMELEN          40
//#define MAXITEMPATHLEN          64+16+48 /* Path + 8.3 + Drive(colon) + arguments */
#define MAXITEMPATHLEN          MAX_PATH - 1 // -1 for backward compatibility
                                             // with shell32.dll
#define MAXGROUPNAMELEN         30

#define NSLOTS                  16        /* initial number of items entries */

#define PATH_INVALID            0
#define PATH_INVALID_OK         1
#define PATH_VALID              2

#define CCHGROUP                5 // length of the string "Group"
#define CCHCOMMONGROUP          6 // length of the string "CGroup"

#define CGROUPSMAX              40      // The max number of groups allowed.

#define TYPE_ITEM               0
#define TYPE_PERSGROUP          1
#define TYPE_COMMONGROUP        2

/* Resource Numbers */
#define PROGMANICON             1
#define DOSAPPICON              2
#define WORDICON                3
#define SHEETICON               4
#define DATAICON                5
#define COMMICON                6
#define ITEMICON                7
#define PERSGROUPICON           8
#define COMMGROUPICON           9
#define WINDOWSICON             10                /* Should be large ? */
#define MSDOSICON               11
#define PMACCELS                1004
#define PROGMANMENU             1005
#define GROUPICON               146

#define DOSAPPICONINDEX         1
#define ITEMICONINDEX           6

#define ITEMLISTBOX             1

#define GWLP_PGROUP             0       // Used in the Group window frames
#define GWL_EXITING             0       // Used in the main window frame

#define DRAG_SWP                1
#define DRAG_COPY               2

/* DDE Messaging Stuff */
#define ACK_POS                 0x8000
#define ACK_NEG                 0x0000

// message sent to indicate another instance has been exec'd
#define WM_EXECINSTANCE         (WM_USER+100)

// message sent to reload a group
#define WM_RELOADGROUP          (WM_USER+101)
// message sent to delete a group
#define WM_UNLOADGROUP	    	(WM_USER+102)

// Lock errors
#define LOCK_LOWMEM             1
#define LOCK_FILECHANGED        2

// Binary type defins
#define BINARY_TYPE_DEFAULT     1
#define BINARY_TIMEOUT_DEFAULT  500

// Recent file list defines
#define MYCBN_SELCHANGE     (WM_USER+5)

#define INIT_MAX_FILES 4
#define FILES_KEY  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager\\Recent File List"
#define MAXFILES_ENTRY L"Max Files"
#define FILE_ENTRY L"File%lu"


/* Menu Command Defines */
#define IDM_FILE                0
#define IDM_NEW                 101
#define IDM_OPEN                102
#define IDM_MOVE                103
#define IDM_COPY                104
#define IDM_DELETE              105
#define IDM_PROPS               106
#define IDM_RUN                 107
#define IDM_EXIT                108
#define IDM_SAVE                109
#define IDM_SHUTDOWN            110
#define IDM_OPTIONS             1
#define IDM_AUTOARRANGE         201
#define IDM_MINONRUN            202
#define IDM_HOTKEY              203
#define IDM_SAVESETTINGS        204
#define IDM_SAVENOW             205
#define IDM_ANSIGROUPS          206
#define IDM_WINDOW              2
#define IDM_CASCADE             301
#define IDM_TILE                302
#define IDM_ARRANGEICONS        303

#define IDM_CHILDSTART          310

#define IDM_HELP                3
#define IDM_HELPINDEX           401
#define IDM_HELPHELP            402
#define IDM_ABOUT               403
#define IDM_HELPSEARCH          404


/* StringTable Defines */
#define IDS_APPTITLE            1
#define IDS_PMCLASS             2
#define IDS_GROUPCLASS          3
#define IDS_ITEMCLASS           4
#define IDS_DATAFILE            5
#define IDS_SETTINGS            7
#define IDS_CONFIRMDELTITLE     40        /* Must be > 32 */
#define IDS_CONFIRMDELITEMMSG   41
#define IDS_CONFIRMDELGROUPMSG  42
#define IDS_NOICONSTITLE        50
#define IDS_NOICONSMSG          51
#define IDS_BADPATHTITLE        52
#define IDS_BADPATHMSG          53
#define IDS_NETPATHTITLE        54
#define IDS_REMOVEPATHTITLE     55
#define IDS_PATHWARNING         56
#define IDS_EXECERRTITLE        60
#define IDS_UNKNOWNMSG          61
#define IDS_NOMEMORYMSG         62
#define IDS_FILENOTFOUNDMSG     63
#define IDS_MANYOPENFILESMSG    64
#define IDS_NOASSOCMSG          65
#define IDS_MULTIPLEDSMSG       66
#define IDS_ASSOCINCOMPLETE     67
#define IDS_COPYDLGTITLE        70
#define IDS_COPYDLGTITLE1       71
#define IDS_GROUPS              72
#define IDS_NOGRPFILE           73
#define IDS_LOWMEM              74
#define IDS_BADFILE             75
#define IDS_CANTWRITEGRP        76
#define IDS_GROUPFILEERR        77
#define IDS_GRPISRO             78
#define IDS_EXTRACTERROR        79
#define IDS_EEGROUPRO           80
#define IDS_CANTWRITEGRPS       81
#define IDS_OOMEXITTITLE        110
#define IDS_OOMEXITMSG          111
#define IDS_GROUPRO             112
#define IDS_CANTRENAMETITLE     113
#define IDS_CANTRENAMEMSG       114
#define IDS_TOOMANYITEMS        115
#define IDS_OS2APPMSG           116
#define IDS_NEWWINDOWSMSG       117
#define IDS_PMODEONLYMSG        118
#define IDS_ALREADYLOADED       119
#define IDS_STARTUP             120
#define IDS_PLUS                121
#define IDS_GRPHASCHANGED       122
#define IDS_NONE                123
#define IDS_EXIT                124
#define IDS_DUPHOTKEYTTL        125
#define IDS_DUPHOTKEYMSG        126
#define IDS_BROWSE              127
#define IDS_NEWITEMPROGS        128
#define IDS_PROPERTIESPROGS     129
#define IDS_CHNGICONPROGS       130
#define IDS_TOOMANYGROUPS       131
#define IDS_ACCESSDENIED        133
#define IDS_DDEFAIL             134
#define IDS_LOWMEMONINIT        135
#define IDS_PIFINIFILE          136
#define IDS_PIFSECTION          137
#define IDS_EXECSETUP           138
#define IDS_WINHELPERR          139
#define IDS_PIFADDINFO          140

#define IDS_BADPATHMSG2	        141
#define IDS_BADPATHMSG3	        142
#define IDS_LOWMEMONEXIT        143
#define IDS_WININIERR           144
#define IDS_STARTUPERR          145
#define IDS_CMDLINEERR          146
#define IDS_ITEMINGROUP         147
#define IDS_LOWMEMONEXTRACT     148
#define IDS_DEFICONSFILE        149
#define IDS_COMPRESSEDEXE       150
#define IDS_INVALIDDLL          151
#define IDS_SHAREERROR          152
#define IDS_CANTWRITEGRPDISK	153
#define IDS_COMMDLGLOADERR      154
#define IDS_NOICONSMSG1	    	155
#define IDS_NOGRPFILE2          156

#define IDS_REGISTRYERROR       164
#define IDS_ERRORDELETEGROUP    165
#define IDS_LOGOFFERROR         166

#define IDS_COMMONGRPSUFFIX     167
#define IDS_COMMONGROUPPROP     168
#define IDS_COMMONGROUPERR      169
#define IDS_NOCOMMONGRPS        170

#define IDS_NO_PERMISSION_SHUTDOWN 171
#define IDS_SHUTDOWN_MESSAGE    172


#define IDS_DEFAULTSTARTUP      173
#define IDS_TOOMANYCOMMONGROUPS 174

#define IDS_LOGOFF              175
#define IDS_SHUTDOWN            176

#define IDS_MSGBOXSTR1          177
#define IDS_MSGBOXSTR2          178

#define IDS_INSUFFICIENTQUOTA   179

#define IDS_ANSIGROUPSMENU      180

//#ifdef JAPAN
//#define IDS_BADPORTPATHTITLE    1102
//#define IDS_BADPORTPATHMSG      1103
//#endif //JAPAN

#include "pmdlg.h"
#include "pmreg.h"
#include "notify.h"

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Global Externs                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

extern BOOL            UserIsAdmin;
extern BOOL            AccessToCommonGroups;
extern BOOL            bLoadIt;
extern BOOL            bMinOnRun;
extern BOOL            bArranging;
extern BOOL            bAutoArrange;
extern BOOL            bAutoArranging;
extern BOOL            bExitWindows;
extern BOOL            bSaveSettings;
extern BOOL            bIconTitleWrap;
extern BOOL            bScrolling;
extern BOOL            bLoadEvil;
extern BOOL            bMove;
extern BOOL            bInDDE;
extern BOOL            fInExec;
extern BOOL            fNoRun;
extern BOOL            fNoClose;
extern BOOL            fNoSave;
extern BOOL            fNoFileMenu;
extern BOOL            fLowMemErrYet;
extern BOOL            fExiting;
extern BOOL            fErrorOnExtract;
extern BOOL	           bFrameSysMenu;

extern TCHAR            szNULL[];
extern TCHAR            szProgman[];
extern TCHAR            szTitle[];
//
// Program Manager's Settings keys
//
extern TCHAR            szWindow[];
extern TCHAR            szOrder[];
extern TCHAR            szAnsiOrder[];
extern TCHAR            szStartup[];
extern TCHAR            szAutoArrange[];
extern TCHAR            szSaveSettings[];
extern TCHAR            szMinOnRun[];
extern TCHAR            szFocusOnCommonGroup[];

extern TCHAR            szMessage[MAXMESSAGELEN+1];
extern TCHAR            szNameField[MAXITEMPATHLEN+1];
extern TCHAR            szPathField[MAXITEMPATHLEN+1];
extern TCHAR            szIconPath[MAXITEMPATHLEN+1];
extern TCHAR            szDirField[];
extern TCHAR            szOriginalDirectory[];
extern TCHAR            szWindowsDirectory[];
extern TCHAR            szOOMExitMsg[64];
extern TCHAR            szOOMExitTitle[32];

extern HANDLE          hAccel;
extern HINSTANCE       hAppInstance;
extern HANDLE          hCommdlg;

extern HICON           hDlgIcon;
extern HICON           hItemIcon;
extern HICON           hProgmanIcon;
extern HICON           hGroupIcon;
extern HICON           hCommonGrpIcon;
extern HICON           hIconGlobal;


extern HWND            hwndProgman;
extern HWND            hwndMDIClient;

extern HBRUSH          hbrWorkspace;

extern int            nGroups;
extern int            dyBorder;
extern int            iDlgIconId;
extern int            iDlgIconIndex;
extern int            cxIcon;
extern int            cyIcon;
extern int            cxIconSpace;
extern int            cyIconSpace;
extern int            cxArrange;
extern int            cyArrange;
extern int            cxOffset;
extern int            cyOffset;

extern WORD         wPendingHotKey;

extern DWORD        dwDDEAppId;
extern DWORD        dwEditLevel;
extern WORD         wLockError;
extern UINT         uiActivateShellWindowMessage;
extern UINT         uiConsoleWindowMessage;
extern UINT         uiSaveSettingsMessage; // for User Profile Editor: upedit.exe

extern PGROUP       pFirstGroup;
extern PGROUP       pCurrentGroup;
extern PGROUP       pActiveGroup;
extern PGROUP       *pLastGroup;
extern PGROUP       pExecingGroup;

extern PITEM        pExecingItem;

extern RECT         rcDrag;
extern HWND         hwndDrag;

extern WORD         wNewSelection;

extern HFONT        hFontTitle;

extern UINT         uiHelpMessage;                // stuff for help
extern UINT         uiBrowseMessage;              // stuff for help
extern WORD         wMenuID;
extern HANDLE       hSaveMenuHandle;                /*Save hMenu into one variable*/
extern WORD         wSaveFlags;                                /*Save flags into another*/
extern HANDLE       hSaveMenuHandleAroundSendMessage;/*Save hMenu into one variable*/
extern WORD         wSaveFlagsAroundSendMessage;     /*Save flags into another*/
extern WORD         wSaveMenuIDAroundSendMessage;

extern DWORD        dwContext;
extern HHOOK        hhkMsgFilter;
extern TCHAR        szProgmanHelp[];

extern BOOL         bUseANSIGroups;

extern PSECURITY_ATTRIBUTES pSecurityAttributes;
extern PSECURITY_ATTRIBUTES pAdminSecAttr;

extern BOOL bDisableDDE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\security.h ===
/****************************** Module Header ******************************\
* Module Name: security.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define various winlogon security-related routines
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


BOOL
SetWorldSecurity(
    PSID    UserSid,
    PSECURITY_DESCRIPTOR *pSecDesc,
    BOOL bWriteAccess
    );

BOOL InitializeSecurityAttributes(
    PSECURITY_ATTRIBUTES pSecurityAttributes,
    BOOL bWriteAccess
    );

BOOL TestUserForAdmin();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\security.c ===
/****************************** Module Header ******************************\
* Module Name: security.c
*
* Copyright (c) 1992, Microsoft Corporation
*
* Handles security aspects of progman operation.
*
* History:
* 01-16-92 JohanneC       Created - mostly taken from old winlogon.c
\***************************************************************************/

#include "sec.h"
#include <string.h>
#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#include <lm.h>


/***************************************************************************\
* SetMyAce
*
* Helper routine that fills in a MYACE structure.
*
* History:
* 02-06-92 Davidc       Created
\***************************************************************************/
VOID
SetMyAce(
    PMYACE MyAce,
    PSID Sid,
    ACCESS_MASK Mask,
    UCHAR InheritFlags
    )
{
    MyAce->Sid = Sid;
    MyAce->AccessMask= Mask;
    MyAce->InheritFlags = InheritFlags;
}


/***************************************************************************\
* SetWorldSecurity
*
* Sets the security given the logon sid passed.
*
* If the UserSid = NULL, no access is given to anyone other than world
* Users will have read access and if bWriteAccess is TRUE, they will also
* have write access.
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 04-16-91 Johannec       Created
\***************************************************************************/
BOOL
SetWorldSecurity(
    PSID    UserSid,
    PSECURITY_DESCRIPTOR *pSecDesc,
    BOOL bWriteAccess
    )
{
    MYACE   Ace[4];
    ACEINDEX AceCount = 0;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSID    WorldSid = NULL;
    PSID    AdminAliasSid = NULL;
    PSID    PowerUserAliasSid = NULL;
    PSID    SystemOpsAliasSid = NULL;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    ACCESS_MASK AccessMask;

    // Create the world Sid
    Status = RtlAllocateAndInitializeSid(
                         &WorldSidAuthority,
                         1,                   // Sub authority count
                         SECURITY_WORLD_RID,  // Sub authorities
                         0, 0, 0, 0, 0, 0, 0,
                         &WorldSid);

    if (!NT_SUCCESS(Status)) {
        DbgOnlyPrint("progman failed to allocate memory for world sid\n");
        return(FALSE);
    }

    Status = RtlAllocateAndInitializeSid(
                         &NtAuthority,
                         2,                            // Sub authority count
                         SECURITY_BUILTIN_DOMAIN_RID,  // Sub authority[0]
                         DOMAIN_ALIAS_RID_ADMINS,      // Sub authority[1]
                         0, 0, 0, 0, 0, 0,
                         &AdminAliasSid);

    Status = RtlAllocateAndInitializeSid(
                         &NtAuthority,
                         2,                            // Sub authority count
                         SECURITY_BUILTIN_DOMAIN_RID,  // Sub authority[0]
                         DOMAIN_ALIAS_RID_POWER_USERS, // Sub authority[1]
                         0, 0, 0, 0, 0, 0,
                         &PowerUserAliasSid);

    Status = RtlAllocateAndInitializeSid(
                         &NtAuthority,
                         2,                            // Sub authority count
                         SECURITY_BUILTIN_DOMAIN_RID,  // Sub authority[0]
                         DOMAIN_ALIAS_RID_SYSTEM_OPS,  // Sub authority[1]
                         0, 0, 0, 0, 0, 0,
                         &SystemOpsAliasSid);


    if (!NT_SUCCESS(Status)) {
        DbgOnlyPrint("progman failed to allocate memory for admin sid\n");
        return(FALSE);
    }



    //
    // Define the World ACEs
    //

    if (bWriteAccess) {
        AccessMask = KEY_READ | KEY_WRITE | DELETE;
    }
    else {
        AccessMask = KEY_READ;
    }

    SetMyAce(&(Ace[AceCount++]),
             WorldSid,
	          AccessMask,
             NO_PROPAGATE_INHERIT_ACE
             );

    //
    // Define the Admins ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             AdminAliasSid,
             GENERIC_ALL,
             NO_PROPAGATE_INHERIT_ACE
             );

    //
    // Define the Power Users ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             PowerUserAliasSid,
             GENERIC_ALL,
             NO_PROPAGATE_INHERIT_ACE
             );

    //
    // Define the System Operators ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             SystemOpsAliasSid,
             GENERIC_ALL,
             NO_PROPAGATE_INHERIT_ACE
             );

    // Check we didn't goof
    ASSERT((sizeof(Ace) / sizeof(MYACE)) >= AceCount);

    //
    // Create the security descriptor
    //

    SecurityDescriptor = CreateSecurityDescriptor(Ace, AceCount);
    if (SecurityDescriptor == NULL) {
        DbgOnlyPrint("Progman failed to create security descriptor\n\r");
        return(FALSE);
    }

#if 0
// Keep security descriptor global
// delete only when exiting the program

    //
    // Free up the security descriptor
    //

    DeleteSecurityDescriptor(SecurityDescriptor);
#endif

    //
    // Return success status
    //

    *pSecDesc = SecurityDescriptor;
    return(TRUE);
}

/***************************************************************************\
* InitializeSecurityAttributes
*
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 04-14-92 JohanneC       Created
\***************************************************************************/
BOOL InitializeSecurityAttributes(PSECURITY_ATTRIBUTES pSecurityAttributes,
                                  BOOL bWriteAccess)
{
    PSECURITY_DESCRIPTOR pSecDesc;

    if (!SetWorldSecurity(NULL, &pSecDesc, bWriteAccess)) {
        return(FALSE);
    }

    pSecurityAttributes->nLength = sizeof(SECURITY_ATTRIBUTES);
    pSecurityAttributes->lpSecurityDescriptor = pSecDesc;
    pSecurityAttributes->bInheritHandle = TRUE;

    return(TRUE);
}

BOOL
TestTokenForAdmin(
    HANDLE Token
    );

/***************************************************************************\
* TestUserForAdmin
*
*
* Returns TRUE if the current user is part of the ADMIN group,
* FALSE otherwise
*
* History:
* 07-15-92 JohanneC       Created
\***************************************************************************/
BOOL TestUserForAdmin()
{
    BOOL UserIsAdmin = FALSE;
    HANDLE Token;
#if 0
    ACCESS_MASK GrantedAccess;
    GENERIC_MAPPING GenericMapping;
    PPRIVILEGE_SET pPrivilegeSet;
    DWORD dwPrivilegeSetLength;
    MYACE   Ace[1];
    PSECURITY_DESCRIPTOR pSecDesc;
    NTSTATUS Status;
#endif
    PSID    AdminAliasSid = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Get the token of the current process.
    //

    if (!OpenProcessToken(
                          GetCurrentProcess(),
                          TOKEN_QUERY,
                          &Token
                         ) ) {
        DbgOnlyPrint("Progman: Can't open own process token for token_query access\n\r");
        return(FALSE);
    }

#if 0

// not working because of error = STATUS_NO_IMPERSONATION_TOKEN
   so use the code from winlogon instead (see #else)

    Status = RtlAllocateAndInitializeSid(
                         &NtAuthority,
                         2,                            // Sub authority count
                         SECURITY_BUILTIN_DOMAIN_RID,  // Sub authority[0]
                         DOMAIN_ALIAS_RID_ADMINS,      // Sub authority[1]
                         0, 0, 0, 0, 0, 0,
                         &AdminAliasSid);

    if (!NT_SUCCESS(Status)) {
        DbgOnlyPrint(TEXT("progman failed to allocate memory for admin sid\n"));
        goto Exit;
    }

    //
    // Define the Admins ACEs
    //

    SetMyAce(&(Ace[0]),
             AdminAliasSid,
             GENERIC_ALL,
             NO_PROPAGATE_INHERIT_ACE
             );

    //
    // Create the security descriptor
    //

    pSecDesc = CreateSecurityDescriptor(Ace, 1);
    if (pSecDesc == NULL) {
        DbgOnlyPrint(TEXT("Progman failed to create security descriptor\n\r"));
        goto Exit;
    }

    //
    // Allocate memory for the PrivilegeSet buffer
    //

    dwPrivilegeSetLength = 256;
    pPrivilegeSet = Alloc(dwPrivilegeSetLength);
    if (!pPrivilegeSet) {
        DbgOnlyPrint(TEXT("Progman: Can't alloc memory for privilege set\n\r"));
        goto FreeSecDesc;
    }

    //
    // Test if user has admin privileges.
    //

    if(!AccessCheck(pSecDesc,
                Token,
                STANDARD_RIGHTS_ALL,
                &GenericMapping,
                pPrivilegeSet,
                &dwPrivilegeSetLength,
                &GrantedAccess,
                &UserIsAdmin) ){

        DbgOnlyPrint(TEXT("Progman: AccessCheck failed, error = %d\n\r"), GetLastError());
    }


    //
    // Free up the the PrivilegeSet
    //

    Free(pPrivilegeSet);

FreeSecDesc:

    //
    // Free up the security descriptor
    //

    DeleteSecurityDescriptor(pSecDesc);

#else

    UserIsAdmin = TestTokenForAdmin(Token);

#endif

//Exit:

    //
    // We are finished with the token.
    //

    CloseHandle(Token);

    return(UserIsAdmin);
}
/***************************************************************************\
* TestTokenForAdmin
*
* Returns TRUE if the token passed represents an admin user, otherwise FALSE
*
* The token handle passed must have TOKEN_QUERY access.
*
* History:
* 08-01-92 JohanneC     Extracted code from winlogon
* 05-06-92 Davidc       Created
\***************************************************************************/
BOOL
TestTokenForAdmin(
    HANDLE Token
    )
{
    NTSTATUS    Status;
    DWORD       InfoLength;
    PTOKEN_GROUPS TokenGroupList;
    DWORD       GroupIndex;
    PSID        AdminSid;
    BOOL        FoundAdmin;
SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    //
    // Get a list of groups in the token
    //

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenGroups,              // TokenInformationClass
                 NULL,                     // TokenInformation
                 0,                        // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if ((Status != STATUS_SUCCESS) && (Status != STATUS_BUFFER_TOO_SMALL)) {

        DbgOnlyPrint("Winlogon failed to get group info for admin token, status = 0x%lx\n", Status);
        return(FALSE);
    }


    TokenGroupList = Alloc(InfoLength);

    if (TokenGroupList == NULL) {
        DbgOnlyPrint("Winlogon unable to allocate memory for token groups\n");
        return(FALSE);
    }

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenGroups,              // TokenInformationClass
                 TokenGroupList,           // TokenInformation
                 InfoLength,               // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if (!NT_SUCCESS(Status)) {
        DbgOnlyPrint("Winlogon failed to query groups for admin token, status = 0x%lx\n", Status);
        Free(TokenGroupList);
        return(FALSE);
    }



    //
    // Create the admin sid
    //

    Status = RtlAllocateAndInitializeSid(
                    &SystemSidAuthority, 2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &AdminSid);

    if (!NT_SUCCESS(Status)) {
        DbgOnlyPrint("Winlogon failed to initialize admin alias sid\n");
        Free(TokenGroupList);
        return(FALSE);
    }


    //
    // Search group list for admin alias
    //

    FoundAdmin = FALSE;

    for (GroupIndex=0; GroupIndex < TokenGroupList->GroupCount; GroupIndex++ ) {

        if (RtlEqualSid(TokenGroupList->Groups[GroupIndex].Sid, AdminSid)) {
            FoundAdmin = TRUE;
            break;
        }
    }

    //
    // Tidy up
    //

    RtlFreeSid(AdminSid);
    Free(TokenGroupList);



    return(FoundAdmin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\shutdown.c ===
/****************************** Module Header ******************************\
* Module Name: shutdown.c
*
* Copyright (c) 1992, Microsoft Corporation
*
* Handles shutdown dialog.
*
* History:
* 2-25-92 JohanneC       Created - extracted from old pmdlgs.c with security
*                                  added.
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "progman.h"

#define LOGOFF_SETTING L"Logoff Setting"

INT_PTR WINAPI
ShutdownDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

VOID
CentreWindow(
    HWND    hwnd
    );


/***************************************************************************\
* ShutdownDialog
*
* Creates the shutdown dialog
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL
ShutdownDialog(
    HANDLE hInst,
    HWND hwnd
    )
{
    INT_PTR nResult;
    BOOLEAN WasEnabled;
    NTSTATUS Status;
    TCHAR szMessage[MAXMESSAGELEN];
    TCHAR szTitle[MAXMESSAGELEN];

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                (BOOLEAN)TRUE,
                                (BOOLEAN)FALSE,
                                &WasEnabled);

    if (!NT_SUCCESS(Status)) {

        //
        // We don't have permission to shutdown
        //

        LoadString(hInst, IDS_NO_PERMISSION_SHUTDOWN, szMessage, CharSizeOf(szMessage));
        LoadString(hInst, IDS_SHUTDOWN_MESSAGE, szTitle, CharSizeOf(szTitle));

        nResult = MessageBox(hwnd, szMessage, szTitle, MB_OK | MB_ICONSTOP);

        return(FALSE);
    }

    //
    // Put up the shutdown dialog
    //

    nResult = DialogBox(hInst, (LPTSTR) MAKEINTRESOURCE(IDD_SHUTDOWN_QUERY), hwnd, ShutdownDlgProc);

    //
    // Restore the shutdown privilege state
    //

    if (!WasEnabled) {

        Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                    (BOOLEAN)WasEnabled,
                                    (BOOLEAN)FALSE,
                                    &WasEnabled);
    }

    return(FALSE);
}


/***************************************************************************\
* FUNCTION: ShutdownDlgProc
*
* PURPOSE:  Processes messages for shutdown confirmation dialog
*
* RETURNS:  if user decided not to shutdown or reboot.
*
* HISTORY:
*
*   05-17-92 Davidc       Created.
*
\***************************************************************************/

INT_PTR WINAPI
ShutdownDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    UINT uiOptions;
static DWORD dwShutdown = 1;
static HKEY hkeyShutdown = NULL;

    switch (message) {

    case WM_INITDIALOG:
        {
        DWORD dwType;
        DWORD cbData;
        DWORD dwDisposition;
        BOOL bPowerdown;

        bPowerdown = GetProfileInt(TEXT("Winlogon"), TEXT("PowerdownAfterShutdown"), 0);
        if (!bPowerdown) {
            ShowWindow(GetDlgItem(hDlg, IDD_POWEROFF), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDOK2), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDCANCEL2), SW_HIDE);
            SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
        }
        else {
            ShowWindow(GetDlgItem(hDlg, IDOK), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDCANCEL), SW_HIDE);
        }

        //
        // Check the button that was the user's last shutdown selection.
        //
        if (RegCreateKeyEx(HKEY_CURRENT_USER, SHUTDOWN_SETTING_KEY, 0, 0, 0,
                     KEY_READ | KEY_WRITE | DELETE,
                     NULL, &hkeyShutdown, &dwDisposition) == ERROR_SUCCESS) {
           cbData = sizeof(dwShutdown);
           RegQueryValueEx(hkeyShutdown, SHUTDOWN_SETTING, 0, &dwType, (LPBYTE)&dwShutdown, &cbData);
        }
        switch(dwShutdown) {
        case DLGSEL_SHUTDOWN_AND_RESTART:
            CheckDlgButton(hDlg, IDD_RESTART, 1);
            break;
        case DLGSEL_SHUTDOWN_AND_POWEROFF:
            if (bPowerdown) {
                CheckDlgButton(hDlg, IDD_POWEROFF, 1);
                break;
            }
            //
            // Fall thru.
            // Default to shutdown.
            //
        default:
            CheckDlgButton(hDlg, IDD_SHUTDOWN, 1);
            break;
        }

        //
        // Position ourselves
        //
        CentreWindow(hDlg);

        return(TRUE);
        }
    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDOK:
        case IDOK2:
            if (IsDlgButtonChecked(hDlg, IDD_SHUTDOWN)) {
                uiOptions = EWX_SHUTDOWN;
                dwShutdown = DLGSEL_SHUTDOWN;
            }
            else if (IsDlgButtonChecked(hDlg, IDD_RESTART)) {
                uiOptions = EWX_SHUTDOWN | EWX_REBOOT;
                dwShutdown = DLGSEL_SHUTDOWN_AND_RESTART;
            }
            else {
                uiOptions = EWX_SHUTDOWN | EWX_POWEROFF;
                dwShutdown = DLGSEL_SHUTDOWN_AND_POWEROFF;
            }

            if (hkeyShutdown) {
                RegSetValueEx(hkeyShutdown, SHUTDOWN_SETTING, 0, REG_DWORD, (LPBYTE)&dwShutdown, sizeof(dwShutdown));
                RegCloseKey(hkeyShutdown);
                hkeyShutdown = NULL;
            }

            ExitWindowsEx(uiOptions, (DWORD)-1);

        case IDCANCEL2:
        case IDCANCEL:
            if (hkeyShutdown) {
                RegCloseKey(hkeyShutdown);
                hkeyShutdown = NULL;
            }
            EndDialog(hDlg, 0);
            return(TRUE);
        }
        break;
    }

    // We didn't process the message
    return(FALSE);
}

/***************************************************************************\
* FUNCTION: NewLogoffDlgProc
*
* PURPOSE:  Processes messages for logoff/shutdown confirmation dialog
*
* RETURNS:  if user decided not to logoff, shutdown or reboot.
*
* HISTORY:
*
*   10-05-93 Johannec       Created.
*
\***************************************************************************/

INT_PTR APIENTRY
NewLogoffDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    UINT uiOptions;
    BOOLEAN WasEnabled = FALSE;
    NTSTATUS Status;
static DWORD dwShutdown = 0;
static HKEY hkeyShutdown = NULL;

    switch (message) {

    case WM_INITDIALOG:
        {
        DWORD dwType;
        BOOL bPowerdown;
        DWORD cbData;
        DWORD dwDisposition;

        bPowerdown = GetProfileInt(TEXT("Winlogon"), TEXT("PowerdownAfterShutdown"), 0);
        if (!bPowerdown) {
            ShowWindow(GetDlgItem(hDlg, IDD_POWEROFF), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDOK2), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDCANCEL2), SW_HIDE);
            SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
        }
        else {
            ShowWindow(GetDlgItem(hDlg, IDOK), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDCANCEL), SW_HIDE);
        }

        //
        // Initial setting is User's last selection
        //
        if (RegCreateKeyEx(HKEY_CURRENT_USER, SHUTDOWN_SETTING_KEY, 0, 0, 0,
                     KEY_READ | KEY_WRITE | DELETE,
                     NULL, &hkeyShutdown, &dwDisposition) == ERROR_SUCCESS) {
           cbData = sizeof(dwShutdown);
           RegQueryValueEx(hkeyShutdown, LOGOFF_SETTING, 0, &dwType, (LPBYTE)&dwShutdown, &cbData);
        }
        switch(dwShutdown) {
        case DLGSEL_SHUTDOWN:
            CheckDlgButton(hDlg, IDD_SHUTDOWN, 1);
            break;
        case DLGSEL_SHUTDOWN_AND_RESTART:
            CheckDlgButton(hDlg, IDD_RESTART, 1);
            break;
        case DLGSEL_SHUTDOWN_AND_POWEROFF:
            if (bPowerdown) {
                CheckDlgButton(hDlg, IDD_POWEROFF, 1);
            }
            else {
                CheckDlgButton(hDlg, IDD_SHUTDOWN, 1);
            }
            break;
        default:
            CheckDlgButton(hDlg, IDD_LOGOFF, 1);
            break;
        }

        //
        // Make sure the user has the privileges to shutdown the computer.
        //

        Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                    (BOOLEAN)TRUE,
                                    (BOOLEAN)FALSE,
                                    &WasEnabled);

        if (!NT_SUCCESS(Status)) {

            //
            // We don't have permission to shutdown
            //
            EnableWindow(GetDlgItem(hDlg, IDD_SHUTDOWN), 0);
            EnableWindow(GetDlgItem(hDlg, IDD_RESTART), 0);
            EnableWindow(GetDlgItem(hDlg, IDD_POWEROFF), 0);
        }

        //
        // Position ourselves
        //
        CentreWindow(hDlg);

        return(TRUE);
        }
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDOK2:
            if (IsDlgButtonChecked(hDlg, IDD_LOGOFF)) {
                uiOptions = EWX_LOGOFF;
                dwShutdown = DLGSEL_LOGOFF;
            }
            else if (IsDlgButtonChecked(hDlg, IDD_SHUTDOWN)) {
                uiOptions = EWX_SHUTDOWN;
                dwShutdown = DLGSEL_SHUTDOWN;
            }
            else if (IsDlgButtonChecked(hDlg, IDD_RESTART)) {
                uiOptions = EWX_SHUTDOWN | EWX_REBOOT;
                dwShutdown = DLGSEL_SHUTDOWN_AND_RESTART;
            }
            else {
                uiOptions = EWX_SHUTDOWN | EWX_POWEROFF;
                dwShutdown = DLGSEL_SHUTDOWN_AND_POWEROFF;
            }

            //
            // Save user's shutdown selection.
            //
            if (hkeyShutdown) {
                RegSetValueEx(hkeyShutdown, LOGOFF_SETTING, 0, REG_DWORD, (LPBYTE)&dwShutdown, sizeof(dwShutdown));
                RegCloseKey(hkeyShutdown);
                hkeyShutdown = NULL;
            }

            //
            // Make sure the user has the privileges to shutdown the computer.
            //

            ExitWindowsEx(uiOptions, (DWORD)-1);
            //
            // Restore the shutdown privilege state
            //

            if (!WasEnabled) {

                Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                    (BOOLEAN)WasEnabled,
                                    (BOOLEAN)FALSE,
                                    &WasEnabled);
            }


        case IDCANCEL:
        case IDCANCEL2:
            if (hkeyShutdown) {
                RegCloseKey(hkeyShutdown);
                hkeyShutdown = NULL;
            }
            EndDialog(hDlg, 0);
            return(TRUE);
        }
        break;
    }

    // We didn't process the message
    return(FALSE);
}

/***************************************************************************\
* CentreWindow
*
* Purpose : Positions a window so that it is centred in its parent
*
* !!! WARNING this code is duplicated in winlogon\winutil.c
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/
VOID
CentreWindow(
    HWND    hwnd
    )
{
    RECT    rect;
    RECT    rectParent;
    HWND    hwndParent;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;

    // Get window rect
    GetWindowRect(hwnd, &rect);

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;

    // Get parent rect
    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0) {

        // Return the desktop windows size (size of main screen)
        dxParent = GetSystemMetrics(SM_CXSCREEN);
        dyParent = GetSystemMetrics(SM_CYSCREEN);
    } else {
        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL) {
            hwndParent = GetDesktopWindow();
        }
        GetWindowRect(hwndParent, &rectParent);

        dxParent = rectParent.right - rectParent.left;
        dyParent = rectParent.bottom - rectParent.top;
    }

    // Centre the child in the parent
    rect.left = (dxParent - dx) / 2;
    rect.top  = (dyParent - dy) / 3;

    // Move the child into position
    SetWindowPos(hwnd, NULL, rect.left, rect.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

    SetForegroundWindow(hwnd);
}

INT_PTR APIENTRY ExitDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
 {
     switch (uiMsg) {
     case WM_INITDIALOG:
         CentreWindow(hwnd);
         break;

     case WM_COMMAND:
         switch (LOWORD(wParam)) {

         case IDOK:

             // fall through...

         case IDCANCEL:
             EndDialog(hwnd, LOWORD(wParam) == IDOK);
             break;

         default:
             return(FALSE);
         }
         break;

     default:
         return(FALSE);
     }
     UNREFERENCED_PARAMETER(lParam);
     return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\secdesc.c ===
/****************************** Module Header ******************************\
* Module Name: secdesc.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Routines that support creation and deletion of security descriptors
*
* History:
* 02-06-92 Davidc       Created.
\***************************************************************************/

#include "sec.h"

//
// Private prototypes
//

PVOID
CreateAccessAllowedAce(
    PSID  Sid,
    ACCESS_MASK AccessMask,
    UCHAR AceFlags,
    UCHAR InheritFlags
    );

VOID
DestroyAce(
    PVOID   Ace
    );



/***************************************************************************\
* CreateSecurityDescriptor
*
* Creates a security descriptor containing an ACL containing the specified ACEs
*
* A SD created with this routine should be destroyed using
* DeleteSecurityDescriptor
*
* Returns a pointer to the security descriptor or NULL on failure.
*
* 02-06-92 Davidc       Created.
\***************************************************************************/

PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    PMYACE  MyAce,
    ACEINDEX AceCount
    )
{
    NTSTATUS Status;
    ACEINDEX AceIndex;
    PACCESS_ALLOWED_ACE *Ace;
    PACL    Acl = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    DWORD   LengthAces;
    DWORD   LengthAcl;
    DWORD   LengthSd;

    //
    // Allocate space for the ACE pointer array
    //

    Ace = (PACCESS_ALLOWED_ACE *)Alloc(sizeof(PACCESS_ALLOWED_ACE) * AceCount);
    if (Ace == NULL) {
        DbgOnlyPrint("progman failed to allocated ACE array\n\r");
        return(NULL);
    }

    //
    // Create the ACEs and calculate total ACE size
    //

    LengthAces = 0;
    for (AceIndex=0; AceIndex < AceCount; AceIndex ++) {
        Ace[AceIndex] = CreateAccessAllowedAce(MyAce[AceIndex].Sid,
                                               MyAce[AceIndex].AccessMask,
                                               0,
                                               MyAce[AceIndex].InheritFlags);
        if (Ace[AceIndex] == NULL) {
            DbgOnlyPrint("progman : Failed to allocate ace\n\r");
        } else {
            LengthAces += Ace[AceIndex]->Header.AceSize;
        }
    }

    //
    // Calculate ACL and SD sizes
    //

    LengthAcl = sizeof(ACL) + LengthAces;
    LengthSd  = SECURITY_DESCRIPTOR_MIN_LENGTH;

    //
    // Create the ACL
    //

    Acl = Alloc(LengthAcl);

    if (Acl != NULL) {

        Status = RtlCreateAcl(Acl, LengthAcl, ACL_REVISION);

        if (NT_SUCCESS(Status))
        {
            //
            // Add the ACES to the ACL and destroy the ACEs
            //

            for (AceIndex = 0; AceIndex < AceCount; AceIndex ++) {

                if (Ace[AceIndex] != NULL) {

                    Status = RtlAddAce(Acl, ACL_REVISION, 0, Ace[AceIndex],
                                       Ace[AceIndex]->Header.AceSize);

                    if (!NT_SUCCESS(Status)) {
                        DbgOnlyPrint("progman : AddAce failed, status = 0x%lx\n\r", Status);
                    }

                    DestroyAce(Ace[AceIndex]);
                }
            }
        }
        else
        {
            Free(Acl);
            Acl = NULL;
        }

    } else {
        DbgOnlyPrint("progman : Failed to allocate ACL\n\r");
    }

    //
    // Free the ACE pointer array
    //
    Free(Ace);

    //
    // Create the security descriptor
    //

    SecurityDescriptor = Alloc(LengthSd);

    if (SecurityDescriptor != NULL) {

        Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
        ASSERT(NT_SUCCESS(Status));

        //
        // Set the DACL on the security descriptor
        //
        Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor, TRUE, Acl, FALSE);
        if (!NT_SUCCESS(Status)) {
            DbgOnlyPrint("progman : SetDACLSD failed, status = 0x%lx\n\r", Status);
        }
    } else {
        DbgOnlyPrint("progman : Failed to allocate security descriptor\n\r");
    }

    //
    // Return with our spoils
    //
    return(SecurityDescriptor);
}


/***************************************************************************\
* DeleteSecurityDescriptor
*
* Deletes a security descriptor created using CreateSecurityDescriptor
*
* Returns TRUE on success, FALSE on failure
*
* 02-06-92 Davidc       Created.
\***************************************************************************/

BOOL
DeleteSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    NTSTATUS Status;
    PACL    Acl;
    BOOLEAN Present;
    BOOLEAN Defaulted;

    ASSERT(SecurityDescriptor != NULL);

    //
    // Get the ACL
    //
    Status = RtlGetDaclSecurityDescriptor(SecurityDescriptor,
                                          &Present, &Acl, &Defaulted);
    if (NT_SUCCESS(Status)) {

        //
        // Destroy the ACL
        //
        if (Present && (Acl != NULL)) {
            Free(Acl);
        }
    } else {
        DbgOnlyPrint("progman : Failed to get DACL from security descriptor being destroyed, Status = 0x%lx\n\r", Status);
    }

    //
    // Destroy the Security Descriptor
    //
    Free(SecurityDescriptor);

    return(TRUE);
}


/***************************************************************************\
* CreateAccessAllowedAce
*
* Allocates memory for an ACCESS_ALLOWED_ACE and fills it in.
* The memory should be freed by calling DestroyACE.
*
* Returns pointer to ACE on success, NULL on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PVOID
CreateAccessAllowedAce(
    PSID  Sid,
    ACCESS_MASK AccessMask,
    UCHAR AceFlags,
    UCHAR InheritFlags
    )
{
    DWORD   LengthSid = RtlLengthSid(Sid);
    DWORD   LengthACE = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + LengthSid;
    PACCESS_ALLOWED_ACE Ace;

    Ace = (PACCESS_ALLOWED_ACE)Alloc(LengthACE);
    if (Ace == NULL) {
        DbgOnlyPrint("progman : CreateAccessAllowedAce : Failed to allocate ace\n\r");
        return NULL;
    }

    Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize = (USHORT)LengthACE;
    Ace->Header.AceFlags = AceFlags | InheritFlags;
    Ace->Mask = AccessMask;
    RtlCopySid(LengthSid, (PSID)(&(Ace->SidStart)), Sid );

    return(Ace);
}


/***************************************************************************\
* DestroyAce
*
* Frees the memory allocate for an ACE
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
VOID
DestroyAce(
    PVOID   Ace
    )
{
    Free(Ace);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\shutdown.h ===
//
//  The Shutdown Query dialog and Logoff Windows NT dialog
//  are shared by Progman (included in windows\shell\progman\progman.dlg),
//  and therefore changes to them or the filename should not be made
//  unless tested with Progman first.
//  This header file is included in windows\shell\progman\pmdlg.h
//
//  11/10/92  johannec
//

#define IDD_SHUTDOWN_QUERY          1200
#define IDD_CLOSEAPPS               1201
#define IDD_RESTART                 1202
#define IDD_END_WINDOWS_SESSION     1203
#define IDD_POWEROFF                1204

#define DLGSEL_LOGOFF                  0
#define DLGSEL_SHUTDOWN                1
#define DLGSEL_SHUTDOWN_AND_RESTART    2
#define DLGSEL_SHUTDOWN_AND_POWEROFF   3

#define WINLOGON_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHUTDOWN_SETTING_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Shutdown"
#define SHUTDOWN_SETTING L"Shutdown Setting"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\taskman.h ===
// Need this so progman.c can include it in
// a meaningful way.

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winuserp.h>

// Taskman prototyes

INT_PTR APIENTRY TaskmanDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
WORD APIENTRY TMExecProgram(LPTSTR lpszPath, LPTSTR lpDir, LPTSTR lpTitle);

VOID GetPathInfo(PTSTR szPath,PTSTR *pszFileName,PTSTR *pszExt,WORD *pich,BOOL *pfUnc);
VOID GetFilenameFromPath(PTSTR szPath, PTSTR szFilename);
VOID GetDirectoryFromPath(PTSTR szFilePath, PTSTR szDir);
BOOL TestTokenForAdmin(HANDLE Token);

WINUSERAPI VOID SwitchToThisWindow(HWND, BOOL);
INT TMMessageBox(HWND hWnd,WORD idTitle,WORD idMessage,PTSTR psz,WORD wStyle);

// Taskman global variables

HWND ghwndTMDialog;
BOOL fTMActive;
INT dxTaskman;
INT dyTaskman;
INT dxScreen;
INT dyScreen;

#define MAXTASKNAMELEN      512
#define MAXMSGBOXLEN        513

#define PWRTASKMANDLG       10
#define WMPTASKMANDLG       11

#define IDD_TMTEXT          499
#define IDD_TASKLISTBOX     500
#define IDD_TERMINATE       501
#define IDD_CASCADE         502
#define IDD_TILE            503
#define IDD_ARRANGEICONS    504
#define IDD_RUN             505
#define IDD_TMPATH          506
#define IDD_CLTEXT          507
#define IDD_SWITCH          508
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\util.c ===
/****************************** Module Header ******************************\
* Module Name: winutil.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implements windows specific utility functions
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

#include "sec.h"
#include <string.h>
#include <stdio.h>


/****************************************************************************

   FUNCTION: Alloc

   PURPOSE: Allocates memory to hold the specified number of bytes

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID Alloc(
    DWORD   Bytes)
{
    HANDLE  hMem;
    PVOID   Buffer;

    hMem = LocalAlloc(LMEM_MOVEABLE, Bytes + sizeof(hMem));

    if (hMem == NULL) {
        return(NULL);
    }

    // Lock down the memory
    //
    Buffer = LocalLock(hMem);
    if (Buffer == NULL) {
        LocalFree(hMem);
        return(NULL);
    }

    //
    // Store the handle at the start of the memory block and return
    // a pointer to just beyond it.
    //

    *((PHANDLE)Buffer) = hMem;

    return (PVOID)(((PHANDLE)Buffer)+1);
}


/****************************************************************************

   FUNCTION: Free

   PURPOSE: Frees the memory previously allocated with Alloc

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL Free(
    PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    LocalUnlock(hMem);

    return(LocalFree(hMem) == NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\taskman.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    taskman.c

Abstract:

    This file contains the source for the windows Task Manager.
    Taskman basically is a dialog box, which enumerates active windows
    keep in the user window manager, then sets active focus to the selected
    dialog box element(ie active window).

--*/

// Has to be unicode because InternalGetWindowText
// user routine is strictly so.

#include "taskman.h"
#include "progman.h"
#include "security.h"

//#ifdef FE_IME // 2-Jun-92, by eichim
#include <winnls32.h>
//#endif

#include <port1632.h>

extern HINSTANCE hAppInstance;

#define MAXPATHFIELD 260

TCHAR szTMPathField[MAXPATHFIELD];
TCHAR szTMDirField[MAXPATHFIELD];
TCHAR szTMTitle[MAXPATHFIELD];
TCHAR szTMMessage[MAXMSGBOXLEN];

TCHAR szTMUserHomeDir[MAXPATHFIELD];
TCHAR szTMWindowsDirectory[MAXPATHFIELD];

TCHAR szTMOOMExitMsg[64];
TCHAR szTMOOMExitTitle[32];

VOID SetDefButton(HWND hwndDlg, INT  idButton);

// registry key for groups

BOOL bChangedDefaultButton;

INT MyX = 0;
INT MyY = 0;

BOOL fMsgBox = FALSE;

VOID
HideWindow(HWND hwnd)
{
   if (!fMsgBox) {

      if (!fNoRun) {
         SetDlgItemText(ghwndTMDialog, IDD_TMPATH, TEXT(""));
      }

      // redundant?  why do they do the reverse twice for show below?
      ShowWindow(ghwndTMDialog, SW_HIDE);

      SetWindowPos(ghwndTMDialog, HWND_NOTOPMOST, 0, 0, 0, 0,
         SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);

      // Erase dark border from depressed pushbuttons
      SendMessage(GetDlgItem(hwnd, IDCANCEL), // IDCANCEL
         BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
      SendMessage(GetDlgItem(hwnd, IDD_TERMINATE),
         BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
      SendMessage(GetDlgItem(hwnd, IDD_CASCADE),
         BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
      SendMessage(GetDlgItem(hwnd, IDD_TILE),
         BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
      SendMessage(GetDlgItem(hwnd, IDD_ARRANGEICONS),
         BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));

   }
}

/*
 * We call HideTasklist() when we want to remove the tasklist window
 * from the screen but not select another window (ie. when we're about
 * to select another app.  We call ShowWindow(SW_HIDE) directly when
 * we're doing something like tiling or cascading so a window other than
 * the tasklist will become the foreground window.
 */
VOID HideTasklist(VOID)
{
    if (!fNoRun) {
       SetDlgItemText(ghwndTMDialog, IDD_TMPATH, TEXT(""));
    }

    SetWindowPos(ghwndTMDialog, HWND_TOP, 0, 0, 0, 0, SWP_HIDEWINDOW |
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);

}


VOID ShowTasklist(
   POINT pt)
{
    if (!fMsgBox) {
        /*
         * Retract the drop down listbox.
         */

         if (!fNoRun) {
            SendDlgItemMessage(ghwndTMDialog, IDD_TMPATH,
                               CB_SHOWDROPDOWN,0,0);
         }

        SetWindowPos(ghwndTMDialog, HWND_TOPMOST, pt.x, pt.y, 0, 0,
           SWP_NOSIZE | SWP_NOACTIVATE );

        //
        // WinCim disables the Taskman window which make it behave strangely on NT
        //
        EnableWindow(ghwndTMDialog, TRUE);
        SetForegroundWindow(ghwndTMDialog);

        ShowWindow(ghwndTMDialog, SW_NORMAL);

    }
}


/*** ActivateSelectedWindow --         Calls user, to set active window, selected
 *                                                                 by the user.
 *
 *
 * ActivateSelectedWindow(HWND hwndLB)
 *
 * ENTRY -         HWND hwndLB - handle to window, which is to become the active
 *                                                  window, with focus.
 * EXIT  -
 * SYNOPSIS -  This function takes the hwnd passed into it, calls user
 *                                to set active focus to that window.
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID ActivateSelectedWindow(
    HWND hwndLB)
{
   INT nIndex;
   HWND hwndT;
   HWND hwndLastActive;
   DWORD lTemp;

    /*
     * Get the hwnd of the item which was selected.
     */
    nIndex = (int)SendMessage(hwndLB, LB_GETCURSEL, 0, 0);
    hwndT = (HWND)SendMessage(hwndLB, LB_GETITEMDATA, nIndex, 0);

    if (!IsWindow(hwndT)) {
        /*
         * We gotta make sure the window is valid before doing stuff with it.
         * An app may terminate itself in the background rendering these
         * window handles invalid.
         */
        goto Beep;
    }

    /*
     * Switch to that task.
     * HACK! Activate the window in the hwndLastActive field of the WndStruct.
     */
    hwndLastActive = GetLastActivePopup(hwndT);

    if (!IsWindow(hwndLastActive)) {
        goto Beep;
    }

    /*
     * But only if it isn't disabled.
     */
    lTemp = GetWindowLong(hwndLastActive, GWL_STYLE);
    if (!(lTemp & WS_DISABLED)) {
        /*
         * HACK!! Use SwitchToThisWindow() to bring dialog parents as well.
         */
        SwitchToThisWindow(hwndLastActive, TRUE);

    } else {
Beep:
        MessageBeep(0);
    }
}

/*** DoEndTask --
 *
 * void DoEndTask( HWND hwnd )
 */
VOID DoEndTask(
   HWND hwnd )
{
   TCHAR szMsgBoxText[MAXMSGBOXLEN];
   TCHAR szTempField[MAXTASKNAMELEN];
   INT nch;
   DWORD dwProcessId = 0;

   /*
    * We don't want to let someone do an EndTask on progman or EndTask of
    * a EndTask dialog (which would make progman die)
    */
   GetWindowThreadProcessId(hwnd, &dwProcessId);

   if (dwProcessId == GetCurrentProcessId()) {
      MessageBeep(MB_OK);
      return;
   }


   if (!EndTask(hwnd, FALSE, FALSE)) {
      /* App does not want to close, ask user if
       * he wants to blow it away
       */

       InternalGetWindowText(hwnd, szTempField, MAXTASKNAMELEN);

       /* Load the message box string, it is very long (greater than 255 chars
        * which is why we load it in two pieces
        */
        nch = LoadString(NULL, IDS_MSGBOXSTR1, szMsgBoxText, MAXMSGBOXLEN);
        LoadString(NULL, IDS_MSGBOXSTR2, &szMsgBoxText[nch], MAXMSGBOXLEN-nch);

        if( MessageBox( NULL, szMsgBoxText, szTempField,
                MB_SETFOREGROUND | MB_SYSTEMMODAL | MB_YESNO ) == IDYES) {
            EndTask(hwnd, FALSE, TRUE);
        }
    }
}


/*** CallEndTask --                 A separate thread to instigate EndTask
 *
 * CallEndTask( HWND hwnd );
 *
 * ENTRY -      HWND hwnd - window handle for the task to be killed
 * EXIT  -
 * SYNOPSIS -  This function calls EndTask on the given window to kill the
 *              task that owns that window.
 *
 * WARNINGS -
 * EFFECTS  -   Kills the task that owns hwnd.
 *
 */

DWORD CallEndTask(
    HWND hwnd)
{
    DoEndTask(hwnd);

    return 0;
}

/*** TaskmanDlgProc --         Dialog Procedure for Taskman Window
 *
 *
 *
 * TaskmanDlgProc(HWND hDlg, WORD wMSG, DWORD wParam, LPARAM lparam)
 *
 * ENTRY -         HWND hhDlg                 - handle to dialog box.
 *                        WORD wMsg                  - message to be acted upon.
 *                        DWORD wParam        - value specific to wMsg.
 *                        LPARAM lparam                - value specific to wMsg.
 *
 * EXIT  -           True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT_PTR TaskmanDlgProc(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lparam)
{
    int nIndex;
    RECT rc;
    HWND hwndLB;
    HWND hwndNext;
    TCHAR szTempField[MAXTASKNAMELEN];
    POINT pt;
    HKEY  hKey;
    DWORD dwDisp;
    DWORD dwDataType, dwMaxFiles=INIT_MAX_FILES, dwMaxFilesSize, dwCount;
    TCHAR szFileEntry[20];
    TCHAR szFullPath[MAXPATHFIELD];


    hwndLB = GetDlgItem(hwnd, IDD_TASKLISTBOX);

    switch (wMsg) {

    case WM_INITDIALOG:
        /*
         * call private api to mark task man as a system app. This causes
         * it to be killed after all other non-system apps during shutdown.
         */
        GetWindowRect(hwnd, &rc);
        dxTaskman = rc.right - rc.left;
        dyTaskman = rc.bottom - rc.top;
        dxScreen = GetSystemMetrics(SM_CXSCREEN);
        dyScreen = GetSystemMetrics(SM_CYSCREEN);

        pt.x = (dxScreen - dxTaskman) / 2;
        pt.y = (dyScreen - dyTaskman) / 2;

        SetWindowPos(hwnd, HWND_NOTOPMOST, pt.x, pt.y, 0, 0,
           SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

        SendDlgItemMessage(hwnd, IDD_TMPATH, EM_LIMITTEXT, MAXPATHFIELD-4, 0L);
        szTMPathField[0] = TEXT('\0');

        bChangedDefaultButton = FALSE;

        return FALSE;

    case WM_SHOWWINDOW:
        /*
         * If we're being shown fill in the listbox.  We do this here
         * rather than in WM_ACTIVATE process so we can do it while the
         * dialog is still invisible.
         */
        if (wParam != 0) {

            /*
             * First delete any previous entries.
             */
            while ((int)SendMessage(hwndLB, LB_DELETESTRING, 0, 0) != LB_ERR);

            /*
             * Search the window list for enabled top level windows.
             */
            hwndNext = GetWindow(hwnd, GW_HWNDFIRST);
            while (hwndNext) {

                /*
                 * Only add non-owned, visible, non-Taskman, Top Level Windows.
                 */
                if ((hwndNext != hwnd) && (IsWindowVisible(hwndNext)) &&
                        (!GetWindow(hwndNext, GW_OWNER))) {
                    if (InternalGetWindowText(hwndNext, szTempField, MAXTASKNAMELEN )) {
                        nIndex = (int)SendMessage(hwndLB, LB_ADDSTRING, 0,
                                (LPARAM)(LPTSTR)szTempField);
                        SendMessage(hwndLB, LB_SETITEMDATA, nIndex,
                                (LPARAM)hwndNext);
                    }
                }

                hwndNext = GetWindow(hwndNext, GW_HWNDNEXT);
            }
            SendMessage(hwndLB, LB_SETCURSEL, 0, 0);

            //
            // Set the default button to "Switch To"
            //

            SetDefButton(hwnd,IDD_SWITCH);

            //
            // Load the combobox with the recently used files.
            //

            if (GetDlgItem(hwnd, IDD_TMPATH)) {

                //
                // FIrst empty the combo box from the last time.
                //

                SendDlgItemMessage (hwnd, IDD_TMPATH,
                                    CB_RESETCONTENT, 0, 0);


                //
                // Load the combobox with recently used files from the registry.
                //
                // Query the max number of files first.
                //

                if (RegCreateKeyEx (HKEY_CURRENT_USER, FILES_KEY, 0, 0,
                                    REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

                    if (dwDisp == REG_OPENED_EXISTING_KEY) {

                        //
                        //  Query the max number of entries
                        //

                        dwMaxFilesSize = sizeof (DWORD);

                        if (RegQueryValueEx (hKey, MAXFILES_ENTRY, NULL, &dwDataType,
                                       (LPBYTE)&dwMaxFiles, &dwMaxFilesSize) == ERROR_SUCCESS) {

                            //
                            //  Now Query each entry and add it to the list box.
                            //

                            for (dwCount=0; dwCount < dwMaxFiles; dwCount++) {

                                wsprintf (szFileEntry, FILE_ENTRY, dwCount);
                                dwMaxFilesSize = MAXPATHFIELD+1;

                                if (RegQueryValueEx (hKey, szFileEntry, NULL, &dwDataType,
                                                 (LPBYTE) szFullPath, &dwMaxFilesSize) == ERROR_SUCCESS) {

                                    //
                                    // Found an entry.  Add it to the combo box.
                                    //

                                    SendDlgItemMessage (hwnd, IDD_TMPATH,
                                                        CB_ADDSTRING, 0,
                                                        (LPARAM)szFullPath);

                                } else {
                                    break;
                                }
                            }
                        }
                    } else {
                        //
                        // We are working with a new key, so we need to
                        // set the default number of files.
                        //

                        RegSetValueEx (hKey, MAXFILES_ENTRY, 0, REG_DWORD,
                                       (CONST BYTE *) &dwMaxFiles, sizeof (DWORD));
                    }

                    //
                    //  Close the registry key
                    //

                    RegCloseKey (hKey);

                }
            }

            //
            // Disable the Run button and set the focus to the
            // listbox.
            //

            EnableWindow(GetDlgItem(hwnd, IDD_RUN), FALSE);

            SetFocus(hwndLB);
        }
        break;

    case WM_ACTIVATE:
        /*
         * If we're being deactivated clear the listbox so we
         * can fill it in afresh when we're re-activated.
         */
        if (wParam == 0) {
            /*
             * If we're not already invisible, hide ourself.
             */
            if (IsWindowVisible(hwnd)) {
                HideWindow(hwnd);
            }
        }

        if (!bChangedDefaultButton) {
           SetDefButton(hwnd,IDD_SWITCH);
        }

        break;

    case WM_ACTIVATEAPP:
        if (wParam)
            return FALSE;

        /*
         * If we are not visible when we get this message it is because
         * we are already in the process of terminating.  If we don't
         * ignore this we get into a weird race condition and the frame
         * of the window being activated doesn't get fully drawn.  (BG)
         */
        if (IsWindowVisible(hwnd)) {
            HideWindow(hwnd);
        }
        break;

    case WM_WININICHANGE:
        //
        // Check if the user's environment variables have changed, if so
        // regenerate the environment, so that new apps started from
        // taskman will have the latest environment.
        //
        if (lparam && (!lstrcmpi((LPTSTR)lparam, (LPTSTR) TEXT("Environment")))) {
            PVOID pEnv;

            RegenerateUserEnvironment(&pEnv, TRUE);
            break;
        }
        else {
            return FALSE;
        }

    case MYCBN_SELCHANGE:
       if (!fNoRun) {
          if (GetDlgItemText(hwnd, IDD_TMPATH, (LPTSTR)szTMPathField, MAXPATHFIELD)) {
             EnableWindow(GetDlgItem(hwnd, IDD_RUN), TRUE);
             if (!bChangedDefaultButton) {
                SetDefButton (hwnd, IDD_RUN);
                bChangedDefaultButton = TRUE;
             }
          } else {
             EnableWindow(GetDlgItem(hwnd, IDD_RUN), FALSE);
             if (bChangedDefaultButton) {
                SetDefButton (hwnd, IDD_SWITCH);
                bChangedDefaultButton = FALSE;
             }
          }
       }
       break;


    case WM_COMMAND:
        switch(LOWORD(wParam)) {

        case IDD_TASKLISTBOX:

            switch(HIWORD(wParam)) {

            case LBN_DBLCLK:
                HideTasklist();
                ActivateSelectedWindow(hwndLB);
                break;

//#ifdef FE_IME // 2-Jun-92, by eichim
//	    {
            // NOTE: bOpen should be TRUE and the ime should be disabled
            // for the tasklistbox but when we tab to the edit control it
            // needs to be enabled.
            case LBN_SETFOCUS:
                WINNLSEnableIME((HWND)NULL, FALSE);
                break;

            case LBN_KILLFOCUS:
                WINNLSEnableIME((HWND)NULL, TRUE);
                break;
//	    }
//#endif // FE_IME

            default:
                // Always change the default button to Switch when we tab to
                // the task listbox
                //

                if (!fNoRun) {
                    if (bChangedDefaultButton) {
                       SetDefButton (hwnd, IDD_SWITCH);
                       bChangedDefaultButton = FALSE;
                    }
                }

                return FALSE;
            }
            break;

        case IDD_TMPATH:
           PostMessage (hwnd, MYCBN_SELCHANGE, 0, 0);
           break;

        case IDOK:
           if (!bChangedDefaultButton) {
              goto Switchem;
           }

        case IDD_RUN:
           if (!fNoRun) {
              TCHAR szFilename[MAXPATHFIELD];
              WORD ret;
              BOOL bMinOnRunSave;

              //
              // Run this app in the user's home directory
              //
              SetCurrentDirectory(szOriginalDirectory);

              GetDlgItemText(hwnd, IDD_TMPATH, szTMPathField, MAXPATHFIELD);
              DoEnvironmentSubst(szTMPathField, MAXPATHFIELD);
              GetDirectoryFromPath(szTMPathField, szTMDirField);
              if (*szTMDirField) {
                  // Convert path into a .\foo.exe style thing.
                  lstrcpy(szFilename, TEXT(".\\"));
                  // Tag the filename and params on to the end of the dot slash.
                  GetFilenameFromPath(szTMPathField, szFilename+2);
                  if (*(szFilename+2) == TEXT('"') ) {
                      SheRemoveQuotes(szFilename+2);
                      CheckEscapes(szFilename, CharSizeOf(szFilename));
                  }
              }
              else {
                  GetFilenameFromPath(szTMPathField, szFilename);
              }

              //
              // Don't minimize ProgMan when exec'ing a program from taskman.
              //
              bMinOnRunSave = bMinOnRun;
              bMinOnRun = FALSE;

              ret = ExecProgram(szFilename, szTMDirField, szFilename, FALSE, 0, 0, 0);

              //
              // Reset Minimized on Run
              //
              bMinOnRun = bMinOnRunSave;


              //
              // reset Progman's working directory.
              //
              SetCurrentDirectory(szWindowsDirectory);

              if (ret) {
                 fMsgBox = TRUE;
                 MyMessageBox( hwnd, IDS_EXECERRTITLE, ret, szTMPathField,
                    MB_SYSTEMMODAL | MB_OK | MB_ICONEXCLAMATION );
                 fMsgBox = FALSE;

                 SetFocus(GetDlgItem(hwnd, IDD_TMPATH));
              } else {
                 GetDlgItemText(hwnd, IDD_TMPATH, szTMPathField, MAXPATHFIELD);
                 SaveRecentFileList (hwnd, szTMPathField, IDD_TMPATH);
                 HideWindow(hwnd);
              }

           }
           break;

Switchem:

        case IDD_SWITCH:
            HideTasklist();
            ActivateSelectedWindow(hwndLB);
            break;

        case IDCANCEL:
           HideWindow(hwnd);
           break;

        case IDD_TERMINATE:
            /*
             * Get the hwnd of the item which was selected.
             */
            nIndex = (int)SendMessage(hwndLB, LB_GETCURSEL, 0, 0);
            hwndNext = (HWND)SendMessage(hwndLB, LB_GETITEMDATA, nIndex, 0);

            if (!IsWindow(hwndNext)) {
                HideWindow(hwnd);
                MessageBeep(0);
                break;
            }

            {
                /* Always activate the window first.  This prevents
                 * apps from going to Beep mode.  Failing to do this
                 * can cause re-entrancy problems in the app if we
                 * do this again before activating the app.
                 *
                 * However, don't do this if it is a old app task.
                 */

#ifdef WIN16    /* if NTWIN, then always do this, as is no winoldapp */
                if (!IsWinoldapTask(GetTaskFromHwnd(hwndNext)))
#endif
                HideWindow(hwnd);
                ActivateSelectedWindow(hwndLB);
                {
                    DWORD idt;
                    HANDLE hThread;

                    hThread = CreateThread(NULL, 0,
                             (LPTHREAD_START_ROUTINE)CallEndTask,
                             (LPVOID)hwndNext, 0,
                             &idt);

                    if (hThread == NULL) {
                        /*
                         * Can not create thread, just call EndTask
                         * syncronously
                         */
                        DoEndTask( hwndNext );
                    } else {
                        CloseHandle(hThread);
                    }
                }
            }
            break;

        case IDD_TILE:
        case IDD_CASCADE:
            {
                HWND hwndDesktop;

                HideWindow(hwnd);

                hwndDesktop = GetDesktopWindow();

                if (wParam == IDD_CASCADE) {
                    CascadeChildWindows(hwndDesktop, 0);

                } else {
                    /*
                     * If shift is down, tile vertically, else horizontally.
                     */
                    TileChildWindows(hwndDesktop, ((GetKeyState(VK_SHIFT) &
                            0x8000) ? MDITILE_HORIZONTAL : MDITILE_VERTICAL));
                }
                break;
            }

        case IDD_ARRANGEICONS:
            /*
             * Let's restore the saved bits before ArrangeIcons
             * FIX for Bug #4884; --SANKAR-- 10-02-89
             */
            HideWindow(hwnd);
            ArrangeIconicWindows(GetDesktopWindow());
            break;
        }

        break;


    case WM_CLOSE:
        /*
         * If wParam != 0, this is a shutdown request, so exit.
         */
        if (wParam != 0)
            ExitProcess(0);
        return FALSE;
        break;

    case WM_HOTKEY:
        if (wParam == 1) {
            pt.x = (dxScreen - dxTaskman) / 2;
            pt.y = (dyScreen - dyTaskman) / 2;
            ShowTasklist(pt);
        }
        break;

    case WM_LOGOFF:
        PostQuitMessage(0);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  SetDefButton()
//
//  Purpose:    Sets the default button
//
//  Parameters: HWND hDlg     - Window handle of dialog box
//              INT  idButton - ID of button
//
//  Return:     void
//
//*************************************************************

VOID SetDefButton(HWND hwndDlg, INT  idButton)
{
    LRESULT lr;

    if (HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(BS_PUSHBUTTON, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                 MAKELPARAM( TRUE, 0 ));
}


BOOL
InitTaskman()
{
   WNDCLASS wc;

   /*
    * First set the priority of taskman so it is higher than foreground apps
    * that spin in loops - this way it'll always come up when you hit
    * ctrl-esc.
    */

   SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

   wc.style = 0;
   wc.lpfnWndProc = DefDlgProc;
   wc.cbClsExtra = 0;
   wc.cbWndExtra = DLGWINDOWEXTRA;
   wc.hInstance = hAppInstance;
   wc.hIcon = LoadIcon(hAppInstance, MAKEINTRESOURCE(PROGMANICON));
   wc.hCursor = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground = NULL;
   wc.lpszMenuName =  NULL;
   wc.lpszClassName = TEXT("TakoHachi");

   RegisterClass(&wc);

   {
       //
       // Set the working set size to 200k.
       //

       QUOTA_LIMITS QuotaLimits;
       NTSTATUS status;

       status = NtQueryInformationProcess( NtCurrentProcess(),
                                           ProcessQuotaLimits,
                                           &QuotaLimits,
                                           sizeof(QUOTA_LIMITS),
                                           NULL );
       if (NT_SUCCESS(status)) {
           QuotaLimits.MinimumWorkingSetSize = 300 * 1024;
           QuotaLimits.MaximumWorkingSetSize = 372 * 1024;

           NtSetInformationProcess( NtCurrentProcess(),
                                    ProcessQuotaLimits,
                                    &QuotaLimits,
                                    sizeof(QUOTA_LIMITS) );
       }
   }

   /*
    * Taskman will work in the windows directory, and switch to the
    * original directory (home directory) before execing programs.
    * This is to prevent weird popups if a UNC original directory is
    * disconnected.
    */

   GetCurrentDirectory(MAXPATHFIELD, szTMUserHomeDir);
   GetWindowsDirectory(szTMWindowsDirectory, MAXPATHFIELD);
   SetCurrentDirectory(szTMWindowsDirectory);

   if (fNoRun) {
      ghwndTMDialog = CreateDialog(hAppInstance, MAKEINTRESOURCE(WMPTASKMANDLG), NULL,
         TaskmanDlgProc);
   } else {
      ghwndTMDialog = CreateDialog(hAppInstance, MAKEINTRESOURCE(PWRTASKMANDLG), NULL,
         TaskmanDlgProc);
   }

   if (ghwndTMDialog == NULL)
       return(FALSE);

   LoadString(hAppInstance, IDS_OOMEXITTITLE, szTMOOMExitTitle, 32);
   LoadString(hAppInstance, IDS_OOMEXITMSG, szTMOOMExitMsg, 64);

   if (!RegisterHotKey(ghwndTMDialog, 1, MOD_CONTROL, VK_ESCAPE) ||
           !RegisterTasklist(ghwndTMDialog)) {

       DestroyWindow(ghwndTMDialog);
       return(FALSE);
   }

   return(TRUE);
}

VOID
TMMain()
{
    MSG msg;
    LPSTR  lpszCmdLine = NULL;
    int    nCmdShow = SW_SHOWNORMAL;

    if (InitTaskman()) {
        while (GetMessage(&msg, (HWND)NULL, (UINT)0, (UINT)0)) {
            if (!IsDialogMessage(ghwndTMDialog, &msg)) {
                if ((msg.message == WM_SYSCOMMAND) && (msg.wParam == SC_TASKLIST)) {
                    POINT pt;

                    GetCursorPos(&pt);
                    pt.x = max(pt.x - (dyTaskman / 2), 0);
                    pt.x = min(pt.x, dxScreen - dxTaskman);
                    pt.y = max(pt.y - (GetSystemMetrics(SM_CYCAPTION) * 2), 0);
                    pt.y = min(pt.y, dyScreen - dyTaskman);

                    ShowTasklist(pt);

                    continue;
                } else {

                    //
                    //  We need to have a regular message loop in order
                    //  to handle the DDE messages generated by spawning
                    //  an application via an association.
                    //

                    TranslateMessage (&msg);
                    DispatchMessage (&msg);
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\unicrt.c ===
/****************************************************************************/
/*                                                                          */
/*  MYCRT.C -                                                               */
/*                                                                          */
/*       My special Unicode workaround file for CRT functions calls         */
/*       from WIN32 Shell applications.                                     */
/*                                                                          */
/*       Created by      :       Diane K. Oh                                */
/*       On Date         :       June 11, 1992                              */
/*                                                                          */
/*       This is a temporary fix and needs to be modified when Unicode      */
/*       is fully supported by CRT.                                         */
/*                                                                          */
/****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <direct.h>

#ifdef UNICODE
#include <wchar.h>
#else
#include <string.h>
#endif


#define INT_SIZE_LENGTH   20
#define LONG_SIZE_LENGTH  40

//*****************************************************************
//
//   MyAtoi and MyAtol
//
//   Purpose     : To convert from Unicode to ANSI string before
//                 calling CRT atoi and atol functions.
//
//*****************************************************************

INT MyAtoi (LPTSTR  string)
{
   CHAR   szAnsi [INT_SIZE_LENGTH];
   BOOL   fDefCharUsed;
#ifdef UNICODE
   BOOL   bDBCS;
   LCID   lcid = GetThreadLocale();

   bDBCS = ( (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE) ||
             (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)   ||
             (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE)
            );

    if (bDBCS)
    {
        //fix mskkbug: #3871
        //When Control panel calling this function, the string to be converted
        //has extra charcters (not able to be converted integer value, such as 'a','b'.
        //In that case, memory allocation error causes. So we have to make sure of it.

        int  iCnt, rValue;
        LPBYTE   mptr;

        if( !(iCnt = WideCharToMultiByte (CP_ACP, 0, string, -1, szAnsi,
                                    INT_SIZE_LENGTH, NULL, &fDefCharUsed)) )
        {

            iCnt = WideCharToMultiByte (CP_ACP, 0, string, -1, NULL,
                                       0, NULL, &fDefCharUsed );

            mptr = (LPBYTE)LocalAlloc( LMEM_FIXED, iCnt );

            WideCharToMultiByte (CP_ACP, 0, string, -1, mptr,
                                       iCnt, NULL, &fDefCharUsed );
            rValue = atoi(mptr);
            LocalFree( (HLOCAL)mptr );
            return( rValue);
         }
         else
         {
             //on the safe side
             if( iCnt >= INT_SIZE_LENGTH ) szAnsi[INT_SIZE_LENGTH-1] = 0;
             return( atoi(szAnsi) );
         }
    }
    else
    {
        WideCharToMultiByte (CP_ACP, 0, string, INT_SIZE_LENGTH,
                             szAnsi, INT_SIZE_LENGTH, NULL, &fDefCharUsed);

        return (atoi (szAnsi));
    }
#else
   return (atoi (string));
#endif

} // end of MyAtoi()

LONG MyAtol (LPTSTR  string)
{
   CHAR   szAnsi [LONG_SIZE_LENGTH];
   BOOL   fDefCharUsed;
#ifdef UNICODE
   BOOL   bDBCS;
   LCID   lcid = GetThreadLocale();

   bDBCS = ( (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE) ||
             (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)   ||
             (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE)
            );

   if (bDBCS)
   {
       int  iCnt;

       if( !(iCnt = WideCharToMultiByte (CP_ACP, 0, string, -1,
                            szAnsi, LONG_SIZE_LENGTH, NULL, &fDefCharUsed)) )
       {
          return FALSE;
       }

       //on the safe side
       if( iCnt >= LONG_SIZE_LENGTH )
           szAnsi[LONG_SIZE_LENGTH-1] = 0;

   }
   else
   {
       WideCharToMultiByte (CP_ACP, 0, string, LONG_SIZE_LENGTH,
                            szAnsi, LONG_SIZE_LENGTH, NULL, &fDefCharUsed);
   }

   return (atol (szAnsi));
#else
   return (atol (string));
#endif

} // end of MyAtol()

//*****************************************************************
//
//   MyItoa
//
//   Purpose     : To convert from ANSI to Unicode string after
//                 calling CRT itoa function.
//
//*****************************************************************

LPTSTR MyItoa (INT  value, LPTSTR  string, INT  radix)
{
   CHAR   szAnsi [INT_SIZE_LENGTH];

#ifdef UNICODE
   _itoa (value, szAnsi, radix);
   MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szAnsi, -1,
                        string, INT_SIZE_LENGTH);
#else
   _itoa (value, string, radix);
#endif

   return (string);

} // end of MyItoa()

LPTSTR MyUltoa (unsigned long  value, LPTSTR  string, INT  radix)
{
   CHAR   szAnsi [LONG_SIZE_LENGTH];

#ifdef UNICODE
   _ultoa (value, szAnsi, radix);
   MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szAnsi, -1,
                        string, LONG_SIZE_LENGTH);
#else
   _ultoa (value, string, radix);
#endif

   return (string);

} // end of MyUltoa()


//*****************************************************************
//
//   MySplitpath
//
//   Purpose     : To convert from ANSI to Unicode string before
//                 calling CRT strtok function.
//
//*****************************************************************

VOID MySplitpath (LPTSTR  path,
                  LPTSTR  drive,
                  LPTSTR  dir,
                  LPTSTR  fname,
                  LPTSTR  ext)
{
  register LPTSTR p;
  LPTSTR   last_slash = NULL, dot = NULL;
  WORD     len;

    /* we assume that the path argument has the following form, where any
     * or all of the components may be missing.
     *
     *      <drive><dir><fname><ext>
     *
     * and each of the components has the following expected form(s)
     *
     *  drive:
     *      0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
     *      ':'
     *  dir:
     *      0 to _MAX_DIR-1 characters in the form of an absolute path
     *      (leading '/' or '\') or relative path, the last of which, if
     *      any, must be a '/' or '\'.  E.g -
     *      absolute path:
     *          \top\next\last\     ; or
     *          /top/next/last/
     *      relative path:
     *          top\next\last\      ; or
     *          top/next/last/
     *      Mixed use of '/' and '\' within a path is also tolerated
     *  fname:
     *      0 to _MAX_FNAME-1 characters not including the '.' character
     *  ext:
     *      0 to _MAX_EXT-1 characters where, if any, the first must be a
     *      '.'
     *
     */

    /* extract drive letter and :, if any */

    if (*(path + _MAX_DRIVE - 2) == TEXT(':'))
    {
       if (drive)
       {
          _tcsncpy(drive, path, _MAX_DRIVE - 1);
          *(drive + _MAX_DRIVE-1) = TEXT('\0');
       }
       path += _MAX_DRIVE - 1;
    }
    else if (drive)
       *drive = TEXT('\0');

    /* extract path string, if any.  Path now points to the first character
     * of the path, if any, or the filename or extension, if no path was
     * specified.  Scan ahead for the last occurence, if any, of a '/' or
     * '\' path separator character.  If none is found, there is no path.
     * We will also note the last '.' character found, if any, to aid in
     * handling the extension.
     */

    for (last_slash = NULL, p = path; *p; p++)
    {
       if (*p == TEXT('/') || *p == TEXT('\\')) /* point to one beyond for later copy */
          last_slash = p + 1;
       else if (*p == TEXT('.'))
          dot = p;
    }

    if (last_slash)
    {
       /* found a path - copy up through last_slash or max. characters
        * allowed, whichever is smaller
        */

       if (dir)
       {
          len = (WORD)__min((WORD)(last_slash - path) / sizeof(TCHAR), _MAX_DIR - 1);
          _tcsncpy(dir, path, len);
          *(dir + len) = TEXT('\0');
       }
       path = last_slash;
    }
    else if (dir)  /* no path found */
       *dir = TEXT('\0');

    /* extract file name and extension, if any.  Path now points to the
     * first character of the file name, if any, or the extension if no
     * file name was given.  Dot points to the '.' beginning the extension,
     * if any.
     */

    if (dot && (dot >= path))
    {
       /* found the marker for an extension - copy the file name up to
        * the '.'.
        */

       if (fname)
       {
          len = (WORD)__min((WORD)(dot - path) / sizeof(TCHAR), _MAX_FNAME - 1);
          _tcsncpy(fname, path, len);
          *(fname + len) = TEXT('\0');
       }

       /* now we can get the extension - remember that p still points
        * to the terminating nul character of path.
        */

       if (ext)
       {
          len = (WORD)__min((WORD)(p - dot) / sizeof(TCHAR), _MAX_EXT - 1);
          _tcsncpy(ext, dot, len);
          *(ext + len) = TEXT('\0');
       }
    }
    else
    {
        /* found no extension, give empty extension and copy rest of
         * string into fname.
         */
        if (fname)
        {
           len = (WORD)__min((WORD)(p - path) / sizeof (TCHAR), _MAX_FNAME - 1);
           _tcsncpy(fname, path, len);
           *(fname + len) = TEXT('\0');
        }
        if (ext)
           *ext = TEXT('\0');
    }

} // end of MySplitpath()


LPTSTR SkipProgramName (LPTSTR lpCmdLine)
{
    LPTSTR  p = lpCmdLine;
    BOOL    bInQuotes = FALSE;

    //
    // Skip executable name
    //
    for (p; *p; p = CharNext(p))
    {
       if ((*p == TEXT(' ') || *p == TEXT('\t')) && !bInQuotes)
          break;

       if (*p == TEXT('\"'))
          bInQuotes = !bInQuotes;
    }

    while (*p == TEXT(' ') || *p == TEXT('\t'))
       p++;

    return (p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\atk_inet.h ===
//  File	 : ATK_INET.h
//  Author       : Suresh Krishnan 
//  Date         : 08/05/97
//  Wrapper for INetCFG.DLL exported functions
//  related  function declarations
//
//
#ifndef __ATH_INET__
#define __ATK_INET__

#include <windows.h>
#include <tchar.h>
#include <winnt.h>
#include <wininet.h>
#include <stdio.h>
#include "rw_common.h"

HRESULT ATK_InetGetAutoDial(LPBOOL lpEnable, LPSTR lpszEntryName, DWORD cbEntryName);
HRESULT ATK_InetSetAutoDial(BOOL fEnable, LPCSTR lpszEntryName);
HRESULT ATK_InetConfigSystem( HWND hwndParent, DWORD dwfOptions,
			 LPBOOL lpfNeedsRestart);
HRESULT ATK_InetGetProxy( LPBOOL lpfEnable,
			  LPSTR  lpszServer,
			  DWORD  cbServer,
			  LPSTR  lpszOverride,
			  DWORD  cbOverride);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\progman\util.h ===
/****************************** Module Header ******************************\
* Module Name: winutil.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define windows utility functions
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//


PVOID
Alloc(
    DWORD
    );

BOOL
Free(
    PVOID
    );
//
// Define a print routine that only prints on a debug system
//
#if DBG
#define DbgOnlyPrint    DbgPrint
#else
#define DbgOnlyPrint
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\cbitmap.h ===
/*********************************************************************
Registration Wizard
CBitmap.h

11/14/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#ifndef __CBitmap__
#define __CBitmap__


class CBitmap
{
public:
	CBitmap(HINSTANCE hInstance, HWND hwndDlg,int idDlgCtl, int idBitmap);
	virtual ~CBitmap();
	LRESULT PASCAL CtlWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
private:
	HBITMAP   GetBmp();
	HINSTANCE m_hInstance;
	FARPROC m_lpfnOrigWndProc;
	HBITMAP m_hBitmap;
	int		m_nIdBitmap;
	HPALETTE m_hPal;
	BOOL    m_isActivePal;
	
};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\credits.h ===
180, 148, 77, 34, 102, 18, 238, 143,
201, 172, 128, 228, 86, 32, 202, 166,
189, 205, 181, 208, 230, 146, 116, 84,
81, 35, 133, 230, 151, 183, 140, 233,
201, 187, 165, 192, 39, 42, 20, 57,
128, 208, 201, 166, 118, 4, 194, 175,
128, 237, 133, 235, 22, 113, 202, 167,
149, 251, 209, 235, 2, 70, 194, 180,
165, 193, 128, 199, 246, 152, 244, 149,
177, 212, 233, 228, 160, 141, 64, 17,
213, 180, 177, 216, 71, 62, 64, 33,
205, 190, 213, 167, 22, 120, 198, 163,
232, 200, 53, 84, 39, 75, 202, 164,
149, 181, 53, 84, 71, 51, 26, 16,
180, 148, 77, 61, 86, 53, 210, 179,
177, 145, 209, 185, 22, 120, 214, 165,
128, 244, 189, 135, 2, 71, 236, 137,
177, 200, 185, 153, 22, 120, 200, 232,
49, 80, 213, 167, 86, 56, 26, 16, 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\atk_ras.h ===
/*
	File : ASTRA_RAS.h

*/
//typedef DWORD  (WINAPI *RASGETENTRYPROPERTIES) ( LPTSTR, LPTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD );
//typedef DWORD  (APIENTRY  *RASGETENTRYPROPERTIES) ( LPTSTR, LPTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD );
#ifndef __ASTRATEK_RAS_WRAPPER
#define __ASTRATEK_RAS_WRAPPER

#include <windows.h>
#include <tchar.h>
#include <ras.h>
#include <raserror.h>
#include <rasdlg.h>


#define  ERROR_LOADING_RAS_DLL   -1
#define  RAS_DLL_LOADED           1
#define  RAS_DLL_NOT_LOADED        0 

typedef DWORD  (APIENTRY *RASGETENTRYPROPERTIES) ( LPTSTR, LPTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD );
typedef DWORD  (APIENTRY *RASSETENTRYPROPERTIES) ( LPTSTR, LPTSTR, LPRASENTRY, DWORD, LPBYTE, DWORD );
typedef DWORD  (APIENTRY *RASDELETEENTRY)      ( LPTSTR, LPTSTR );

typedef DWORD (APIENTRY *RASGETERRORSTRING) (UINT, LPTSTR, DWORD );
typedef DWORD (APIENTRY *RASDIAL)  ( LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD,
                   LPVOID, LPHRASCONN );

typedef DWORD (APIENTRY* RASHANGUP) ( HRASCONN );
typedef DWORD (APIENTRY* RASENUMDEVICES) ( LPRASDEVINFO, LPDWORD, LPDWORD );
typedef DWORD (APIENTRY* RASENUMCONNECTIONS) (LPRASCONN , LPDWORD, LPDWORD);
typedef DWORD (APIENTRY* RASGETCOUNTRYINFO)( LPRASCTRYINFO, LPDWORD );
typedef DWORD (APIENTRY* RASGETCONNECTIONSTATUS)( HRASCONN, LPRASCONNSTATUS );


int ATK_IsRasDllOk();

DWORD ATK_RasDial( LPRASDIALEXTENSIONS lpRasDial, 
			 LPTSTR  lpPhBk, 
			 LPRASDIALPARAMS lpDialParam,
			 DWORD dwNotifyType,
			 LPVOID lpNotifier,
			 LPHRASCONN lphRasConn);

DWORD ATK_RasHangUp ( HRASCONN hrasconn );

DWORD ATK_RasGetEntryProperties(
		LPTSTR lpszPhonebook, 
		LPTSTR lpszEntry, 
		LPRASENTRY lpRasEntry, 
		LPDWORD lpdwEntryInfoSize, 
		LPBYTE lpbDeviceInfo, 
		LPDWORD lpdwDeviceInfoSize );

DWORD ATK_RasSetEntryProperties(
		LPTSTR lpszPhonebook, 
		LPTSTR lpszEntry, 
		LPRASENTRY lpRasEntry, 
		DWORD dwEntryInfoSize, 
		LPBYTE lpbDeviceInfo, 
		DWORD dwDeviceInfoSize );

DWORD ATK_RasDeleteEntry( LPTSTR lpszPhonebook,
					   LPTSTR lpszEntry);

DWORD ATK_RasGetErrorString( UINT uErrorValue, 
							 LPTSTR lpszErrorString, 
							 DWORD cBufSize );

DWORD ATK_RasEnumDevices( LPRASDEVINFO lpRasDevInfo, 
						  LPDWORD lpcb, 
						  LPDWORD lpcDevices);
DWORD ATK_RasEnumConnections ( LPRASCONN lprasconn, 
							   LPDWORD lpcb, 
							   LPDWORD lpcConnections);
DWORD ATK_RasGetCountryInfo( LPRASCTRYINFO lpRasCtryInfo, 
					LPDWORD lpdwSize );

DWORD ATK_RasGetCountryInfoA( LPRASCTRYINFO lpRasCtryInfo, 
					LPDWORD lpdwSize );
DWORD ATK_RasGetConnectionStatus( HRASCONN hrasconn,
		LPRASCONNSTATUS lprasconnstatus );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\cntryinf.h ===
/*********************************************************************
Registration Wizard
cntryinf.h

10/12/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
*********************************************************************/
//#define TAPI_CURRENT_VERSION 0x00010004
#ifndef __CNTRYINF__
#define __CNTRYINF__


#include <tchar.h>
#include <tapi.h>
#define kCountryCodeUnitedStates 1

BOOL CountryCodeFromSzCountryCode(HINSTANCE hInstance,LPTSTR szCountry,DWORD* lpCountry);
DWORD GetCountryCodeUsingTapiId(DWORD dwCountryId, DWORD *dwCountryCode) ;
BOOL GetTapiCurrentCountry(HINSTANCE hInstance,DWORD* dwpCountry);
BOOL FFillCountryList(HINSTANCE hInstance,HWND hwndCB,LPTSTR szCountry,DWORD* lpCountry);


class CCntryInfo {
public :
#ifdef _TAPI
	LINECOUNTRYLIST  *m_pCountry;
#endif
	CCntryInfo();
	~CCntryInfo();
	int  GetCountryCode(_TCHAR *czCountryName);
	int  GetCountryCode( DWORD  dwTapiId);
	_TCHAR * GetCountryName(int iCode =0);
	void FillCountryList(HINSTANCE hInstance,HWND hwndCB);
	int  GetTapiCountryCode(_TCHAR * czCountryName);
	int  GetTapiIDForTheCountryIndex(int iCntryIndex=0); // Useful to Get the Actual TAPI Country Index 

};

extern CCntryInfo     gTapiCountryTable;

#endif //__CNTRYINF__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\atkinternet.h ===
/*
	File : AtkInternet.h
	Date :
	
	This is a wrapper function declaration for Winows Internet API.
	This Warpper is to handle the UNICODE as the present Windows Internet API does not support UNICODE
	

*/
#ifndef __ASTRATEK_INTERNET_HEADER
#define __ASTRATEK_INTERNET_HEADER

#include <tchar.h>
#include <windows.h>
#include <wininet.h>
#define USE_ASTRATEK_WRAPPER 1

//
// INTERNET_PROXY_INFO - structure supplied with INTERNET_OPTION_PROXY to get/
// set proxy information on a InternetOpen() handle
//
typedef struct {
    // dwAccessType - INTERNET_OPEN_TYPE_DIRECT, INTERNET_OPEN_TYPE_PROXY, or
    // INTERNET_OPEN_TYPE_PRECONFIG (set only)
    DWORD dwAccessType;
    // lpszProxy - proxy server list
    LPCSTR lpszProxy;
    // lpszProxyBypass - proxy bypass list
    LPCSTR lpszProxyBypass;
} ATK_INTERNET_PROXY_INFOW;

#ifdef _UNICODE
	#ifdef USE_ASTRATEK_WRAPPER
	#define ATK_INTERNET_PROXY_INFO  ATK_INTERNET_PROXY_INFOW
	#else
	#define ATK_INTERNET_PROXY_INFO  INTERNET_PROXY_INFO
	#endif
#else
	#define ATK_INTERNET_PROXY_INFO  INTERNET_PROXY_INFO
#endif // !UNICODE
				 

HINTERNET
ATK_InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );				  

#ifdef _UNICODE

	#ifdef USE_ASTRATEK_WRAPPER
	#define ATK_InternetOpen  ATK_InternetOpenW
	#else
	#define ATK_InternetOpen  InternetOpen
	#endif
#else
	#define ATK_InternetOpen  InternetOpenA
#endif // !UNICODE




HINTERNET
ATK_InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef _UNICODE
	#ifdef USE_ASTRATEK_WRAPPER
	#define ATK_InternetConnect  ATK_InternetConnectW
	#else
	#define ATK_InternetConnect  InternetConnect
	#endif
#else
	#define ATK_InternetConnect  InternetConnectA
#endif // !UNICODE


HINTERNET
ATK_HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_HttpOpenRequest  ATK_HttpOpenRequestW
	#else
	#define ATK_HttpOpenRequest  HttpOpenRequest
	#endif
#else
	#define ATK_HttpOpenRequest  HttpOpenRequestA
#endif // !UNICODE



BOOL
ATK_HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_HttpSendRequest  ATK_HttpSendRequestW
	#else
	#define ATK_HttpSendRequest  HttpSendRequest
	#endif
#else
	#define ATK_HttpSendRequest  HttpSendRequestA
#endif // !UNICODE





BOOL
ATK_InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_InternetGetLastResponseInfo  ATK_InternetGetLastResponseInfoW
	#else
	#define ATK_InternetGetLastResponseInfo  InternetGetLastResponseInfo
	#endif
#else
	#define ATK_InternetGetLastResponseInfo  InternetGetLastResponseInfoA
#endif



BOOL
ATK_HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
	);

#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_HttpQueryInfo  ATK_HttpQueryInfoW
	#else
	#define ATK_HttpQueryInfo  HttpQueryInfo
	#endif
#else
	#define ATK_HttpQueryInfo  HttpQueryInfoA
#endif

//
//  In this functin declaration we have modified the first
//  parameter type as TCHAR to have uniformity in coding in tha APP 
//  
BOOL ATK_InternetGetCookieW(IN TCHAR *lpszUrl,
					       IN TCHAR *lpszCookieName,
					  	   OUT TCHAR *lpCookieData,
						   OUT LPDWORD lpdwSize);
#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_InternetGetCookie  ATK_InternetGetCookieW
	#else
	#define ATK_InternetGetCookie  InternetGetCookie
	#endif

#else
	#define ATK_InternetGetCookie  InternetGetCookieA
#endif

BOOL
ATK_InternetQueryOptionW(IN HINTERNET hInternet,
						 IN DWORD dwOption,
						 OUT LPVOID lpBuffer,
						 IN OUT LPDWORD lpdwBufferLength);

#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_InternetQueryOption  ATK_InternetQueryOptionW
	#else
	#define ATK_InternetQueryOption  InternetQueryOption
	#endif
#else
	#define ATK_InternetQueryOption  InternetQueryOptionA
#endif





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\devcfg.h ===
// Terminal mode setting
//
#define TERMINAL_NONE   0x00000000
#define TERMINAL_PRE    0x00000001
#define TERMINAL_POST   0x00000002
#define MANUAL_DIAL     0x00000004

#pragma pack( push,4)

// Device Setting Information
//
typedef struct  tagDEVCFGGDR  {
    DWORD       dwSize;
    DWORD       dwVersion;
    DWORD       fTerminalMode;
}   DEVCFGHDR;

typedef struct  tagDEVCFG  {
    DEVCFGHDR   dfgHdr;
    COMMCONFIG  commconfig;
}   DEVCFG, *PDEVCFG, FAR* LPDEVCFG;

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\cstattxt.h ===
/*********************************************************************
Registration Wizard
CStaticText.h

11/14/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#ifndef __CStaticText__
#define __CStaticText__
#include <tchar.h>

class CStaticText
{
public:
	CStaticText(HINSTANCE hInstance, HWND hwndDlg,int idControl,int idString1,int idString2);
	virtual ~CStaticText();

	LRESULT PASCAL CtlWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
	static LPTSTR LoadExtendedString(HINSTANCE hInstance,int idString1,int idString2);

private:
	HINSTANCE m_hInstance;
	LPTSTR m_szText;
	FARPROC m_lpfnOrigWndProc;
	HFONT m_hFont;
};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\cregwiz.h ===
/*********************************************************************
Registration Wizard
CRegWiz.h

11/3/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#ifndef __CRegWizard__
#define __CRegWizard__

#include <tchar.h>

const kMaxProductCount = 12;
const kSystemInventoryItemCount = 13;
const kMaxCountryCount = 250;

typedef enum
{
	kInfoFirstName = 0,
	kInfoLastName,
	kInfoCompany,
	kInfoMailingAddress,
	kInfoAdditionalAddress,
	kInfoCity,
	kInfoState,
	kInfoZip,
	kInfoCountry,
	kInfoPhoneNumber,
	kInfoDeclinesNonMSProducts,
	kInfoProductID,
	kInfoProcessor,
	kInfoMathCoProcessor,
	kInfoTotalRAM,
	kInfoTotalDiskSpace,
	kInfoRemoveableMedia,
	kInfoDisplayResolution,
	kInfoDisplayColorDepth,
	kInfoPointingDevice,
	kInfoNetwork,
	kInfoModem,
	kInfoSoundCard,
	kInfoCDROM,
	kInfoOperatingSystem,
	kInfoIncludeSystem,
	kInfoIncludeProducts,
	kInfoApplicationName,
	kInfoOEM,
	kInfoVersion,
	kInfoMakerCompany,
	kInfoResultPath,
	kInfoDate,
	kInfoLanguage,
	kInfoEmailName,
	kInfoResellerName,
	kInfoResellerCity,
	kInfoResellerState,
	kInfoHWID,
	kInfoMSID,
	kInfoPhoneExt,
	kDivisionName, // Division name and User Id is added for FE 3/3/98
	kUserId, 
	kAreaCode,
	kHomeSwKnow,
	kHomeExcited,
	kHomePcSwKnow,
	kBusinessRole,
	kScsiAdapterInfo, // System Inventory
	kComputerManufacturer, // Sysinv Dlg , entry
	kMiddleName,
	kInfoLastIndex
}InfoIndex;

#define kFirstSystemIndex	kInfoProcessor
#define kLastSystemIndex	kInfoOperatingSystem

typedef enum
{
	kTriStateFalse,
	kTriStateTrue,
	kTriStateUndefined
}TriState;

// Typedefs for JumpTableElement;  kMaxAddrSpecTableSize can be
// no larger than the largest value representable by JTE
typedef _TUCHAR JTE;
#define kMaxAddrSpecTableSize 255
#define kMaxLenSize 127
#define kAddrSpecCount 19
//typedef _TSCHAR MAXLEN;
typedef char MAXLEN;
typedef struct
{
	MAXLEN maxLen[kAddrSpecCount];
}ADDRSPEC,*PADDRSPEC;

typedef enum
{
	kAddrSpecFirstName = 0,
	kAddrSpecLastName,
	kAddrSpecCompanyName,
	kAddrSpecAddress,
	kAddrSpecAddress2,
	kAddrSpecCity,
	kAddrSpecState,
	kAddrSpecPostalCode,
	kAddrSpecPhone,
	kAddrSpecEmailName,
	kAddrSpecResellerName,
	kAddrSpecResellerCity,
	kAddrSpecResellerState,
	kAddrSpecExtension,
	kAddrSpecDivision,
	kAddrSpecAreaCode,
	kAddrSpecUserId,
	kSIComputerManufacturer,
	kAddrMiddleName
}ADDRSPEC_FIELD;

class CRegWizard
{
public:
	CRegWizard(HINSTANCE hInstance, LPTSTR szParamRegKey);
	virtual ~CRegWizard();

	void StartRegWizardDialog(int wDlgResID, DLGPROC lpDialogProc);
	void ActivateRegWizardDialog( void );
	INT_PTR ProcessRegWizardDialog( void );
	void EndRegWizardDialog(INT_PTR wExitID);
	BOOL IsDialogActive( void );
	
	void SetWindowCaption(LPTSTR lpszWindowsCaption);
	LPTSTR GetWindowCaption();
	
	INT_PTR GetDialogExitButton( void );
	
	BOOL GetInputParameterStatus( void );
	BOOL GetInputParameterString(short paramID, LPTSTR szParam);

	BOOL IsRegistered( void );
	int AddProduct(LPTSTR szProductName,LPTSTR szProductPath);

	void SetInformationString(InfoIndex index, LPTSTR szInfo);
	BOOL GetInformationString(InfoIndex index, LPTSTR szInfo);
	void SetTriStateInformation(InfoIndex index, TriState infoValue);
	TriState GetTriStateInformation(InfoIndex index);
	void WriteEnableInformation(InfoIndex index, BOOL shouldWrite);
	BOOL IsInformationWriteEnabled(InfoIndex index);

	TriState GetProductSearchLibraryStatus( void );
	BOOL GetProductSearchProcAddress(FARPROC* lpfnProductSearch);
	void SetProductSearchStatus(TriState searchCompleted);
	TriState GetProductSearchStatus( void );
	void SetSystemInventoryStatus(BOOL invCompleted);
	BOOL GetSystemInventoryStatus( void );

	void GetProductName(LPTSTR szProductName,INT_PTR index);
	HICON GetProductIcon(INT_PTR index);
	short GetProductCount( void );
	void WriteInfoToRegistry( void );
	BOOL GetInfoRegValueName(InfoIndex infoIndex,LPTSTR szValueName);
	void GetInfoRegistrationParentKey(LPTSTR szRegKey);
	HINSTANCE GetInstance( void );
	void SetCountryCode(DWORD countryCode);
	DWORD GetCountryCode( void );
	void GetCountryAddrSpec(LONG lCountryID,ADDRSPEC* addrSpec );
	void GetAddrSpecProperties(DWORD dwCountryCode, ADDRSPEC_FIELD addrSpecField, MAXLEN* maxLen,BOOL* isRequired);
	void ConfigureEditTextField(HWND hwndDlg,int editFieldID,ADDRSPEC_FIELD addrSpecField,int iAttachedStrID);
	void SetLogFileName(LPTSTR lpszLogFilePath);
    void DestroyOpenedWindow()
	{
		if (m_hwndCurrDialog)
		{
			DestroyWindow(m_hwndCurrDialog);
			m_hwndCurrDialog = NULL;
		}

	}
	void GetRegKey(LPTSTR szRegKey);
	HWND GetCurrDialog(void );
	void SetDialogHide(HWND hDialogToHide);
	BOOL ShowPrevDialog(void);
	void SetPrevDialog(void);
	void SetDialogExitButton( int nButton );
	static BOOL IsEditTextFieldValid(HWND hwndDlg,int editID);
	static void GetEditTextFieldAttachedString(HWND hwndDlg,int editID,LPTSTR szAttached,int cbBufferSize);
	void ResolveCurrentCountryCode( void );
	BOOL GetMSIDfromCookie(LPTSTR);

	_TCHAR 		m_szParamRegKey[256];

private:
	void BuildAddrSpecTables( void );
	void ReadInfoFromRegistry( void );
	void CreateLogFile( void );
	void WriteToLogFile(LPTSTR lpszLine);
	void CloseLogFile( void );

	HINSTANCE 	m_hInstance;
	HACCEL      m_hAccel;
	LPTSTR 		m_rgszProductName[kMaxProductCount];
	LPTSTR 		m_rgszProductPath[kMaxProductCount];
	HICON		m_rghProductIcon[kMaxProductCount];
	LPTSTR 		m_rgszInfoArray[kInfoLastIndex];
	BOOL 		m_writeEnable[kInfoLastIndex];
	short 		m_productNameCount;
	TriState 	m_searchCompleted;
	BOOL 		m_systemInventoryCompleted;
	_TCHAR 		m_szWindowsCaption[256];
	_TCHAR 		m_szInfoParentKey[256];
	_TCHAR		m_szLogFilePath[_MAX_PATH];
	FARPROC 	m_lpfnProductSearch;
	DWORD 		m_countryCode;
	HANDLE		m_addrJumpTable;
	HANDLE		m_addrSpecTable;
	HANDLE 		m_hLogFile;

	BOOL		m_dialogActive;
	HWND		m_hwndStartDialog;
	HWND		m_hwndCurrDialog;
	INT_PTR		m_wDialogExitButton;
	HWND		m_hwndDialogToHide;
	HWND		m_hwndPrevDialog;
	HINSTANCE	m_ccpLibrary; 
};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\mcm.h ===
#ifndef MCM_H
#define MCM_H

#ifndef TAPI_H
//#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>
#endif

#include <tchar.h>

#define INVALID_PORTID	0xFFFFFFFF
#define fTrue			1
#define fFalse			0
#define Try				__try
#define Leave			__leave
#define Finally			__finally

typedef enum _MODEMSTATUS
{
	kMsModemOk,
	kMsModemNotFound,
	kMsModemTooSlow
}MODEMSTATUS;

#ifdef __cplusplus
extern "C"
{
#endif
MODEMSTATUS MSEnsureModemTAPI (HINSTANCE hInstance, HWND hwnd);
BOOL FGetModemSpeed(HINSTANCE hInstance, DWORD dwDevice, PDWORD pdwSpeed);
BOOL FGetDeviceID(HINSTANCE hInstance, HLINEAPP *phLineApp, PDWORD pdwAPI, PDWORD pdwDevice, DWORD dwIndex);
MODEMSTATUS MSDetectModemTAPI(HINSTANCE hInstance);
#ifdef __cplusplus
}
#endif
#endif // _TAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\dialogs.h ===
/*********************************************************************
Registration Wizard
Dialogs.h

10/13/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
*********************************************************************/

#include <tchar.h>

INT_PTR WelcomeDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NameDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AddressDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ResellerDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
//INT_PTR CALLBACK PIDDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK InformDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SystemInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProdInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RegisterDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CancelRegWizard(HINSTANCE hInstance,HWND hwndParentDlg);
int RegWizardMessage(HINSTANCE hInstance,HWND hwndParent, int dlgID);
int RegWizardMessageEx(HINSTANCE hInstance,HWND hwndParent, int dlgID, LPTSTR szSub);
void RefreshInventoryList(CRegWizard* pclRegWizard);

//
// The Below Dialog procedures are for Far East countries
INT_PTR CALLBACK AddressForFEDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NameForFEDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\fe_util.h ===
/*
	FE_UTIL.H
	Far East Countries helper 
	03/02/98

*/

#ifndef __FE_UTIL__

#define __FE_UTIL__
#include <windows.h>

#define JAPAN_LCID   			411
#define KOREAN_LCID   			412
#define TRADITIONAL_CHINA_LCID  404
#define SIMPLIFIED_CHINA_LCID   804
#define MAX_FE_COUNTRIES_SUPPORTED 256
typedef enum
{
	kNotInitialised,
	kFarEastCountry,   
	kNotAFECountry,
	UnknownCountry
}FeCountriesIndex;

typedef enum {
	kFEWithNonJapaneaseScreen,
	kFEWithJapaneaseScreen // Returned for screen type
}FeScreenType;


extern  FeCountriesIndex   gWhatFECountry; // This is a global variable
										   // Which holds the present FE Country	
extern  FeScreenType       gWhichFEScreenTye; // This is a global variable
										   // Which holds the FE Screen Type	
FeCountriesIndex  IsFarEastCountry(HINSTANCE hIns);
FeScreenType      GetFeScreenType();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\regpage.h ===
/*

	File    : RegPage.h
	Date    : 12/31/97
	Author  : Suresh Krishnan
	Regsitration Wizard Page info using Wizard 97 control
	Modification History:
	4/29/98 : Removed Reseller screen constant
	4/28/98 : Added constants for Business user and Homer user screen



*/
#ifndef __REGWIZPAGE__
#define __REGWIZPAGE__

//
//
//
//
#include <Windows.h>
#include <windowsx.h>
#include <PRSHT.H>



class	 CRegWizard;
class    DialupHelperClass;
//
//  CONTROL ID of the Wizard 97 control
//  This is got using the SPY
//


#define  RWZ_WIZ97_STATIC_ID  3027
#define  RWZ_WIZ97_FINISH_ID  3025
#define  RWZ_WIZ97_NEXT_ID    3024
#define  RWZ_WIZ97_BACK_ID    3023
#define  RWZ_WIZ97_CANCEL_ID     2
#define  RWZ_WIZ97_HELP_ID       9


// for iLastKeyOperation
#define RWZ_UNRECOGNIZED_KEYPESS   0
#define RWZ_BACK_PRESSED	1
#define RWZ_NEXT_PRESSED	2
#define RWZ_CANCEL_PRESSED  3

//
//
//iCancelledByUser can have the following
#define  RWZ_SKIP_AND_GOTO_NEXT 3
#define  RWZ_ABORT_TOFINISH     2
#define  RWZ_CANCELLED_BY_USER  1
#define  RWZ_PAGE_OK            0
struct PageInfo
{

    UINT		CurrentPage;
    UINT		TotalPages;
	HFONT		hBigBoldFont;
	HFONT		hBoldFont;
	HINSTANCE 	hInstance;
	UINT        ErrorPage;  // Set By the Page exiting
	INT_PTR		iError;    // Error
	DWORD       dwConnectionType; // Via Network or Dialup
					// Set in the Welcome Screen and used in the Register Screen
	DWORD       dwMsgId;  // Msg COntext Id to be  displayed on the last page
	HPROPSHEETPAGE  *ahpsp ;  // Handle of Property sheet pages created
	CRegWizard* pclRegWizard;
	DialupHelperClass  *pDialupHelper; // This is Dialup helper class used in Dialup Screen
	int         iCancelledByUser;
	int         iLastKeyOperation;
      LPTSTR   pszProductPath;
};

//
//	Dialog Index of Registration Wizard
//

typedef enum
{	kWelcomeDialog,
	kInformDialog,
	kNameDialog,
	kAddressDialog,
	//kResellerDialog,
	kBusinessUserDialog,
	kHomeUserDialog,
	kSysInventoryDialog,
	kProductInventoryDialog,
	kRegisterDialog,
	kDialupDialog,
	kDialogExit
}RegWizScreenIndex;

//
// Used by System Inventory and Product Inventory
//
#define DO_NOT_SHOW_THIS_PAGE 1
#define DO_SHOW_THIS_PAGE     2

BOOL
Is256ColorSupported(
    VOID
    );



INT_PTR CALLBACK
WizardDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

VOID
SetControlFont(
    IN HFONT    hFont,
    IN HWND     hwnd,
    IN INT      nId
    );

VOID
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    );

VOID
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    );

INT_PTR
DoRegistrationWizard(
                     HINSTANCE hInstance,
                     CRegWizard* clRegWizard,
                     LPTSTR szProductPath
                     );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\regutil.h ===
/*********************************************************************
Registration Wizard
regutil.h

12/7/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
*********************************************************************/
#include <tchar.h>
#define  RWZ_MAKE_BOLD 1
void InitDlgNormalBoldFont();
void DeleteDlgNormalBoldFont();
HFONT NormalizeDlgItemFont(HWND hwndDlg,int idControl, int iMakeBold=0);
void ReplaceDialogText(HWND hwndDlg,int idControl,LPTSTR szText);
BOOL ValidateInvDialog(HWND hwndDlg,int iStrID);
void GetEditFieldProperties(HWND hwndDlg,int stringID,short* maxLen,BOOL* isRequired);
void UpgradeDlg(HWND hwndDlg);
void LoadAndCombineString(HINSTANCE hInstance,LPCTSTR szTarget,int idReplacementString,LPTSTR szString);
void StripCharFromString(LPTSTR szInString, LPTSTR szOutString, _TCHAR charToStrip);

BOOL GetIndexedRegKeyValue(HINSTANCE hInstance, int enumIndex, LPTSTR szBaseKey,int valueStrID, LPTSTR szValue);
BOOL FileExists(LPTSTR szPathName);
void UppercaseString(LPTSTR sz);
LONG GetResNumber(HINSTANCE hInstance, int iStrResID);
BOOL Windows95OrGreater( void );
void DrawTransparentBitmap(HDC hdc, HBITMAP hBitmap, int xStart,int yStart, 
	int xWidth, int yWidth, int xSrc, int ySrc, COLORREF cTransparentColor);
BOOL GetSystemLanguageInfo(LPTSTR lpszLanguage, DWORD dwBufferSize,LANGID* lpLangId);
void GetRegWizardVersionString(HINSTANCE hIns, LPTSTR lpszVersion);
void RegWizardInfo(HWND hwndDlg);
UINT GetRegKeyValue32 ( HKEY hRootKey, LPTSTR const cszcSubKey, LPTSTR const cszcValueName,
	 PDWORD pdwType, PTBYTE pbData, UINT cbData );

BOOL FResSetDialogTabOrder(HWND hwndDlg, UINT wResStringID);
BOOL FSetDialogTabOrder(HWND hwndDlg, LPTSTR szTabOrder);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\mcx.h ===
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1994, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _MCX_H_
#define _MCX_H_

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // product and version identification
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    // local option capabilities
    DWORD   dwDialOptions;          // bitmap of supported values
    DWORD   dwCallSetupFailTimer;   // maximum in seconds
    DWORD   dwInactivityTimeout;    // maximum in deciseconds
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // maximum value in bit/s
    DWORD   dwMaxDCERate;           // maximum value in bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // static local options (read/write)
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // deciseconds
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap
    
    // negotiated options (read only) for current or last call
    DWORD   dwNegotiatedModemOptions;   // bitmap
    DWORD   dwNegotiatedDCERate;        // bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options
#define DIALOPTION_BILLING  0x00000040  // Supports wait for bong "$"
#define DIALOPTION_QUIET    0x00000080  // Supports wait for quiet "@"
#define DIALOPTION_DIALTONE 0x00000100  // Supports wait for dial tone "W"

// SpeakerVolume for MODEMDEVCAPS
#define MDMVOLFLAG_LOW      0x00000001
#define MDMVOLFLAG_MEDIUM   0x00000002 
#define MDMVOLFLAG_HIGH     0x00000004 

// SpeakerVolume for MODEMSETTINGS
#define MDMVOL_LOW          0x00000000
#define MDMVOL_MEDIUM       0x00000001 
#define MDMVOL_HIGH         0x00000002

// SpeakerMode for MODEMDEVCAPS
#define MDMSPKRFLAG_OFF         0x00000001 
#define MDMSPKRFLAG_DIAL        0x00000002 
#define MDMSPKRFLAG_ON          0x00000004 
#define MDMSPKRFLAG_CALLSETUP   0x00000008

// SpeakerMode for MODEMSETTINGS
#define MDMSPKR_OFF         0x00000000 
#define MDMSPKR_DIAL        0x00000001 
#define MDMSPKR_ON          0x00000002 
#define MDMSPKR_CALLSETUP   0x00000003 
 
// Modem Options
#define MDM_COMPRESSION      0x00000001
#define MDM_ERROR_CONTROL    0x00000002
#define MDM_FORCED_EC        0x00000004
#define MDM_CELLULAR         0x00000008
#define MDM_FLOWCONTROL_HARD 0x00000010
#define MDM_FLOWCONTROL_SOFT 0x00000020
#define MDM_CCITT_OVERRIDE   0x00000040
#define MDM_SPEED_ADJUST     0x00000080
#define MDM_TONE_DIAL        0x00000100
#define MDM_BLIND_DIAL       0x00000200

#endif /* _MCX_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\regwizmain.h ===
/*********************************************************************
Registration Wizard
RegWizard.h

10/12/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
*********************************************************************/
#ifndef __regwiz__
#define __regwiz__

#ifndef __CRegWizard__
#include "CRegWiz.h"
#endif

#include <tchar.h>
// Global variable references
extern vDialogInitialized;
typedef enum
{
	kNoneFound = 0,
	kModemFound = 1,
	kConfigErr = 2,
	kModemTooSlow = 3
}ModemStatus;




ModemStatus DetectModem(HINSTANCE hInstance);
extern INT_PTR  DoRegistrationWizard(HINSTANCE hInstance, CRegWizard* clRegWizard, LPTSTR szProductPath);

BOOL CheckOEMdll(void);
typedef	int		(*pfnDialogFunc)(HWND,int,LPCTSTR );

int DisplayDialog(HWND,int nDialogType, LPCTSTR lpszFieldName);

typedef	int		(WINAPI *OEMStartDialog)(WORD,HBITMAP,HPALETTE,HWND *,pfnDialogFunc);

typedef	BOOL	(WINAPI *OEMValidate)(LPSTR,LPTSTR,WORD,LPBOOL,LPWORD);

typedef	BOOL	(WINAPI *OEMGetData)(WORD,LPBOOL,LPBYTE,WORD);

typedef	int		(WINAPI *OEMDataCount)();

typedef	void	(WINAPI *OEMRegistered)(BOOL);

static HBITMAP hOemBitmap;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\rwwin95.h ===
/*********************************************************************
Registration Wizard
rwWin95.h

This file contains special definitions needed by RegWizard that are
found only in the Windows95 SDK.
12/15/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#ifndef __rwWin95__
#define __rwWin95__

#include <tchar.h>

#ifndef SS_ETCHEDFRAME
#define SS_ETCHEDFRAME      0x00000012L
#endif

#ifndef VER_PLATFORM_WIN32s
#define VER_PLATFORM_WIN32s             0
#endif

#ifndef VER_PLATFORM_WIN32_WINDOWS
#define VER_PLATFORM_WIN32_WINDOWS      1
#endif

#ifndef VER_PLATFORM_WIN32_NT
#define VER_PLATFORM_WIN32_NT           2
#endif

#ifndef WM_DEVICECHANGE
#define WM_DEVICECHANGE		0x0219
#endif

#ifndef WM_HELP
#define WM_HELP             0x0053
#endif

#ifndef WM_SETICON
#define WM_SETICON          0x0080
#endif

WINUSERAPI BOOL WINAPI DrawIconEx(HDC, int, int, HICON, int, int, UINT, HBRUSH, UINT);

#endif	//rwWin95.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\rwpost.h ===
#ifndef _RWPOST_H_
#define	_RWPOST_H_

/**************************************************************************
   File:          RWPOST.h
   Description:   
**************************************************************************/
#define MAX_BUFFER	5*1024

#ifdef __cplusplus
extern "C" 
{
#endif
DWORD CheckInternetConnectivityExists( HWND hWnd, HINSTANCE hInstance);
DWORD_PTR CheckWithDisplayInternetConnectivityExists(HINSTANCE hIns,HWND hwnd,int iMsgType=0);
//DWORD SendHTTPData(HINSTANCE hInstance,LPTSTR czB, DWORD *dwBufSize);
DWORD SendHTTPData(HWND hWnd, HINSTANCE hInstance);
DWORD PostHTTPData(HINSTANCE hInstance);
DWORD_PTR PostDataWithWindowMessage( HINSTANCE hIns);
void  InitializeInetThread(HINSTANCE hInstance);

#ifdef __cplusplus
}
#endif

#define  RWZ_SITE_CONNECTED   1
#define  RWZ_FAIL_TOCONNECTTOSITE  0
#define  RWZ_SITE_REQUIRES_AUTHENTICATION 2

DWORD  ChkSiteAvailability( HWND hWnd,
			   LPCTSTR szIISServer,
			   DWORD   dwTimeOut,
			   LPTSTR szProxyServer,
               LPTSTR	szUserName ,
   			   LPTSTR  szPassword);

extern RECT gRect;


#endif	//_INTERFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\sudefs.h ===
//--------------------------------------------------------------------------------
//sudefs.h    
//started - Umesh Madan
//(c)Microsoft Corporation 1995
//standard alert ids etc 
//--------------------------------------------------------------------------------


#ifndef _SUDEFS_
#define _SUDEFS_

//Return codes.
#define DIALFAILED			0
#define DIALSUCCESS			1
#define DIALCANCEL			2
#define	SIGNUPTHROTTLED		3
#define SIGNUPWANTED		4		//do signup
#define	SIGNUPDECLINED		5		//don't do signup
#define SIGNUPSETUPONLY		6		//only do setup
#define TOLLFREECANCEL		7		
#define TOLLFREEOK			8
#define PHONESYNCOK			9
#define PHONESYNCCANCEL		10
#define AUTOPICKOK			11
#define AUTOPICKCANCEL		12
#define SIGNUPDONE			16
#define SIGNUPCONTINUE		17
#define JOINOK				18
#define JOINCANCEL			19
#define JOINFAILED			20
#define LEGALAGREE			21
#define LEGALREFUSE			22
#define PRODINFOOK 			23
#define PRODINFOFAILED		24
#define USERPASSOK			25
#define USERPASSCANCEL		26
#define USERPASSFAILED		27
#define USERPASSRETRY		28
#define USERPASSACCTERROR	29	  
#define USERPASSBADCREDIT	30
#define LOCKOUTOK			31
#define LOCKOUTFAILED		32 

//Alerts - tells the inherited class what alerts to put up.
#define ALERTIDCANCEL		1						//do a cancellation alert
#define ALERTIDRETRY		ALERTIDCANCEL + 1		//do a general retry this action alert
#define ALERTIDSETTINGS		ALERTIDRETRY + 1		//display connection settings etc..
#define ALERTIDGENERAL		ALERTIDSETTINGS + 1		//general no retry alert.. 
#define ALERTIDNOMODEM		ALERTIDGENERAL + 1		//no modem alert
#define ALERTIDLINEDROPPED	ALERTIDNOMODEM + 1		//line dropped alert.
#define ALERTIDOOM			ALERTIDLINEDROPPED + 1	//out of memory
#define ALERTIDFTMERROR		ALERTIDOOM + 1			//ftm error
#define ALERTIDNOTEXT		ALERTIDFTMERROR + 1		//blank edit field
#define ALERTIDDBCS			ALERTIDNOTEXT + 1		//DBCS characters found... 
#define ALERTIDLESSTEXT		ALERTIDDBCS + 1			//not enough text in edit field 
#define ALERTIDHASSPACES    ALERTIDLESSTEXT + 1		//string has spaces

//Status - tells the inherited class the status of the call
#define STATUSIDINIT		1		//initializing..
#define STATUSIDDIAL		2		//dialing..
#define STATUSIDCONNECT		3		//connected..
#define STATUSIDDISCONNECT	4		//disconnected..
#define STATUSIDCANCELLING	5		//cancelling..
#define STATUSIDCANCEL		6		//cancelled..
#define STATUSTRANSFER		7		//transferring data..

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\sysinv.h ===
#ifndef __sysinv__
#define __sysinv__

#ifdef  __cplusplus
extern "C" {
#endif

/*
 * Function:
 *	BOOL WINAPI GetSystemInventory(INT type, LPTSTR szInventory);
 *
 * Description:
 *	Get system inventory information by type caller asked
 *
 * Parameters:
 *	INT type:	specify what type information caller.  Should be one of INV_* constants
 *	LPTSTR szInventory:	The description of specific item information on return.  The contents depends on item type.
 *						The length of the buffer has to be at least 256.
 *
 * Return Value:
 *	TRUE on success.
 *	FALSE on failure.  szInventory[0] is also assigned 0
 */
BOOL WINAPI GetSystemInventory(INT, LPTSTR);

#define SYSINV_DLL_PRESENT  1
#define SYSINV_DLL_NOTPRESENT  2

int  CheckSysInvDllPresent();

void GetOEMString(HINSTANCE hInstance, LPTSTR szOEM);
void GetProcessorTypeString(HINSTANCE hInstance, LPTSTR szProcessor);
void GetTotalMemoryString(HINSTANCE hInstance, LPTSTR szTotalMemory);
void GetTotalHardDiskSpaceString(HINSTANCE hInstance, LPTSTR szTotalHardDiskSpace);
void GetDisplayResolutionString(HINSTANCE hInstance, LPTSTR szDisplayResolution);
void GetDisplayColorDepthString(HINSTANCE hInstance, LPTSTR szDisplayColorDepth);
void GetWindowsVersionString(HINSTANCE hInstance, LPTSTR szVersion);
void GetNetworkCardString(HINSTANCE hInstance, LPTSTR szNetwork);
void GetModemString(HINSTANCE hInstance, LPTSTR szModem);
void GetPointingDeviceString(HINSTANCE hInstance, LPTSTR szPointingDevice);
void GetCDRomString(HINSTANCE hInstance, LPTSTR szCDRom);
void GetSoundCardString(HINSTANCE hInstance, LPTSTR szSoundCard);
void GetRemoveableMediaString(HINSTANCE hInstance, LPTSTR szRemoveableMedia, int iBufSize);
void GetSCSIAdapterString(HINSTANCE hInstance, LPTSTR szScsi);

BOOL IsCoProcessorAvailable( HINSTANCE hInstance );
LONG GetTotalHardDiskSpace( void );
void GetDisplayCharacteristics(PINT horizResolution, PINT vertResolution,PINT colorDepth);
void GetWindowsVersion(LONG* lpPlatform, LONG* lpMajorVersion,LONG* lpMinorVersion,LONG* lpBuildNumber);

#define INV_OEM				1	// szInventory: Descriptive string
#define INV_PROCESSORTYPE	2	// szInventory: Descriptive string
#define INV_TOTALMEMORY		3	// szInventory: Descriptive string
#define INV_TOTALHDSPACE	4	// szInventory: Descriptive string
#define INV_DISPRESOLUTION	5	// szInventory: Descriptive string
#define INV_DISPCOLORDEPTH	6	// szInventory: Descriptive string
#define INV_WINVERSION		7	// szInventory: Descriptive string
#define INV_NETCARD			8	// szInventory: Descriptive string
#define INV_MODEM			9	// szInventory: Descriptive string
#define INV_POINTDEVICE		10	// szInventory: Descriptive string
#define INV_CDROM			11	// szInventory: Descriptive string
#define INV_SOUNDCARD		12	// szInventory: Descriptive string
#define INV_REMOVEABLEMEDIA	13	// szInventory: Descriptive string
#define INV_COPRECESSOR		14	// szInventory[0] = 1 for available, 0 for nonavailable
#define INV_SCSIADAPTER     15  
#define INV_DISPLAY_ADAPTER 16  // Display Adapter with Driver
#define INV_DISPLAY_WITH_RESOLUTION 17 // Display Adapter and Color resolution        //
#ifdef __cplusplus
}   /* ... extern "C" */
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\version.h ===
#include <tchar.h>
#define rmj		3
#define rmm		0
#define rup		0
#define szVerName	_T""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\include\rw_common.h ===
#ifndef __RW_COMMON__
#define __RW_COMMON__

#include <windows.h>
#include  <stdio.h>
//#include <iostream.h>
//#include <fstream.h>
#include <tchar.h>
#include <wininet.h>

#ifdef __cplusplus
extern "C" 
{
#endif

int  InvokeRegistration ( HINSTANCE hInstance  , LPCTSTR  czPath);
void TransmitRegWizInfo ( HINSTANCE hInstance , LPCTSTR szParams,BOOL fOEM);
void DisplayInterNetConnectingMsg(HINSTANCE hIns);
void CloseDisplayInetrnetConnecting();
DWORD CheckWithDisplayInterNetConnectingMsg(HINSTANCE hIns);

void SetMSID(HINSTANCE hInstance);
BOOL GetMSIDfromRegistry(HINSTANCE hInstance,LPTSTR szValue);
BOOL GetMSIDfromCookie(HINSTANCE hInstance,LPTSTR szMSID);

DWORD_PTR GetProxyAuthenticationInfo(HINSTANCE hIns,TCHAR *czProxy,
								 TCHAR *czUserName,TCHAR *czPswd);
void  RemoveMSIDEntry(HINSTANCE hIns);

#ifdef __cplusplus
}
#endif

TCHAR * GetModemDeviceInformation(HINSTANCE hIns, int iModemIndex);
//
// Status returend while finding the removable media and cdrom
//
#define     REGFIND_ERROR      1
#define     REGFIND_RECURSE    2
#define     REGFIND_FINISH     3

//
// Status returend while Cheching for InternetConnection
//
#define     DIALUP_NOT_REQUIRED      1
#define     DIALUP_REQUIRED          2
//#define     CONNECTION_CANNOT_BE_ESTABLISHED  3

//
// HTTP Post related status messages
//
#define  RWZ_NOERROR  0
#define  RWZ_NO_INFO_AVAILABLE			1
#define  RWZ_INVALID_INFORMATION		2 
#define  RWZ_BUFFER_SIZE_INSUFFICIENT	3
#define  RWZ_INTERNAL_ERROR				4 // Internal Programming Error 
#define  RWZ_POST_SUCCESS               5
#define  RWZ_POST_FAILURE               6    
#define  RWZ_POST_WITH_SSL_FAILURE      7    
#define  RWZ_POST_MSN_SITE_BUSY         8   
#define  RWZ_ERROR_NOTCPIP              9
//
//  Error Values returned by the Signup Dialogue
//

#define  RWZ_ERROR_LOCATING_MSN_FILES       10
#define  RWZ_ERROR_LOCATING_DUN_FILES       11 
#define  RWZ_ERROR_MODEM_IN_USE             12  
#define  RWZ_ERROR_MODEM_CFG_ERROR			13 
#define  RWZ_ERROR_TXFER_CANCELLED_BY_USER	14  
#define  RWZ_ERROR_CANCELLED_BY_USER		14 
#define  RWZ_ERROR_SYSTEMERROR				15
#define  RWZ_ERROR_NODIALTONE				16
// Environment Not proper 
#define  RWZ_ERROR_MODEM_NOT_FOUND		   17
#define  RWZ_ERROR_NO_ANSWER               18    // no response engaged tone
#define  RWZ_ERROR_RASDLL_NOTFOUND         19

#define     CONNECTION_CANNOT_BE_ESTABLISHED  20 // Mdem cfg error
// Error in Invoking 
#define  RWZ_ERROR_INVALID_PARAMETER	    30
#define  RWZ_ERROR_INVALID_DLL              31
#define  REGWIZ_ALREADY_CONFIGURED			32 
#define  RWZ_ERROR_PREVIOUSCOPY_FOUND       33 

#define  RWZ_ERROR_REGISTERLATER            34   


// Status of Ping

#define   RWZ_PINGSTATUS_NOTCPIP    40
#define   RWZ_PINGSTATUS_SUCCESS    41
#define   RWZ_PINGSTATUS_FAIL       42





//
//  The below defines  is for creating a Log File 
//
#define _LOG_IN_FILE                 //	 uses a file 

class RWDebug {
public:
	RWDebug() {
		m_iError = 0;
		fp       = NULL;
	};
	~RWDebug(){};
	void     UseStandardOutput();
	void     CreateLogFile(char *czFile);
	inline  RWDebug& operator<<(RWDebug& (__cdecl * _f)(RWDebug&));
	RWDebug& operator <<( int  iv) ;
	RWDebug& operator <<( unsigned int  iv) ;
	RWDebug& operator <<( short sv) ;
	RWDebug& operator <<( unsigned short usv) ;
	RWDebug& operator <<( unsigned short *usv) ;
	RWDebug& operator <<( void *  pVoid) ;
	RWDebug& operator <<( long  lv) ;
	RWDebug& operator <<( unsigned long ulv) ;
	RWDebug& operator <<( float  fv) ;
	RWDebug& operator <<( char   cv) ;
	//RWDebug& operator <<( bool  bv) ;
	RWDebug& operator <<( char *  sv) ;
	RWDebug& operator <<( unsigned char *  sv) ;
	RWDebug& operator <<( const char *  sv) ;
	RWDebug& flush() {return *this;};
	RWDebug& Write (char *czT); 
private :
	FILE *fp;
	char czTemp[48];
	int m_iError;
	

};
inline RWDebug& RWDebug::operator<<(RWDebug& (__cdecl * _f)(RWDebug&)) { (*_f)(*this); return *this; }
inline RWDebug& __cdecl flush(RWDebug& _outs) { return _outs.flush(); }
inline RWDebug& __cdecl endl(RWDebug& _outs) { return _outs << '\n' << flush; }

//ostream &GetDebugLogStream();
RWDebug &GetDebugLogStream();

REGSAM RW_GetSecDes() ;
int  GetProductRoot (TCHAR * pPath , PHKEY  phKey);

#define RW_DEBUG  GetDebugLogStream()



/* 
 Function name	: RegFindValueInAllSubKey
 Description	: It searches the subkey for the presence of the ValueName "Type" which has 
				  value given by szValueToFind.It returns the value of "Identifier" 
				  ValueName present along with the type in szIdentifier.
 Return Value	: TRUE if Successful else FALSE
*/
int RegFindValueInAllSubKey(HINSTANCE hInstance,HKEY key ,LPCTSTR szSubKeyNameToFind,LPCTSTR szValueToFind,LPTSTR szIdentifier,int nType );

/* 
 Function name	: RegFindTheSubKey
 Description	: Finds the key specified within the subkey. 
 Return Value	: TRUE if Successful else FALSE 
*/
BOOL RegFindTheSubKey(HKEY key,LPCTSTR szSubKeyName,LPCTSTR szSubKeyNameToFind,LPTSTR szData);
/*
 Function name	: RegGetPointingDevice
 Description	: Get the pointing device. 
 Return Value	: TRUE if Successful else FALSE 
*/
BOOL RegGetPointingDevice(HKEY hKey,LPCTSTR szSubKeyName,LPTSTR szData);


LPCTSTR BstrToSz(BSTR pszW);

#ifdef _UNICODE
	TCHAR* ConvertToUnicode(char FAR* szA);
#else
	TCHAR * ConvertToUnicode(TCHAR * szW) ;
#endif

char * ConvertToANSIString (LPCTSTR  szW);

int IsDialupConnectionActive();

HRESULT GetNewGUID(PSTR pszGUID);
//
//
//  Internet connection settings related  function
//  define ATK_INET.CPP  
int  DisableAutoDial(); // Disables Auto Dial
int  ResetAutoDialConfiguration();
void GetAutoDialConfiguration();
void UnLoadInetCfgLib();
//
//
//  product Info related function
void SetProductBeingRegistred(TCHAR *szProduct);
TCHAR *GetProductBeingRegistred();

//
// OEM DLL Validation 
#define OEM_NO_ERROR		0
#define OEM_VALIDATE_FAILED 1
#define OEM_INTERNAL_ERROR  2
int CheckOEMdll(); // This checks if Registration is with OEM
int GetOemManufacturer (TCHAR *szProductregKey, TCHAR *szBuf );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\ccsv.h ===
#ifndef _CCSV
#define _CCSV

#include <windows.h>
#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for phone books
class CCSVFile
{
	
	public:
		void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
		void operator delete( void far * p ) {GlobalFree(p); };

		CCSVFile();
		~CCSVFile();
		BOOLEAN Open(LPCSTR pszFileName);
		BOOLEAN ReadToken(LPSTR pszDest, DWORD cbMax);	// reads up to comma or newline, returns fFalse on EOF
		void Close(void);
		inline int ILastRead(void)
			{
			return m_iLastRead;
			}

	private:
		BOOL 	FReadInBuffer(void);
		inline int 	ChNext(void);
		char 	m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
		LPSTR 	m_pchBuf;			//pointer to the next item in the buffer to read
		LPSTR	m_pchLast;			//pointer to the last item in the buffer
		int  	m_iLastRead;		//the character last read.
		DWORD 	m_cchAvail;
		HANDLE 	m_hFile;

}; // ccsv
#endif //_CCSV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\ccsv.cpp ===
// ############################################################################
// INCLUDES
#include "pch.hpp"

#include "ccsv.h"
#include "debug.h"

// ############################################################################
// DEFINES
#define chComma ','
#define chNewline '\n'
#define chReturn '\r'

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
	m_hFile = 0;
	m_iLastRead = 0;
	m_pchLast = m_pchBuf = NULL;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
	AssertSz(!m_hFile,"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCSTR pszFileName)
{
	AssertSz(!m_hFile, "a file is already open.");
		
	m_hFile = CreateFile((LPCTSTR)pszFileName, 
							GENERIC_READ, FILE_SHARE_READ, 
							0, OPEN_EXISTING, 0, 0);
	if (INVALID_HANDLE_VALUE == m_hFile)
	{
		return FALSE;
	}
	m_pchLast = m_pchBuf = NULL;
	return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(LPSTR psz, DWORD cbMax)
{
	LPSTR	pszLast;
	char		ch;

	ch = (char) ChNext();
	if (-1 == ch)
		{
		return FALSE;
		}

	pszLast = psz + (cbMax - 1);
	while (psz < pszLast && chComma != ch && chNewline != ch && -1 != ch)
		{
		*psz++ = ch;
		ch = (char) ChNext(); //Read in the next character
		}

	*psz++ = '\0';

	return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
	if (m_hFile)
		CloseHandle(m_hFile);
#ifdef DEBUG
	if (!m_hFile) Dprintf("CCSVFile::Close was called, but m_hFile was already 0\n");
#endif
	m_hFile = 0;
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
	//Read another buffer
#ifdef WIN16
	if ((m_cchAvail = _read(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE)) <= 0)
		return FALSE;
#else
	if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
		{
		return FALSE;	 //nothing more to read
		}
#endif

	m_pchBuf = m_rgchBuf;
	m_pchLast = m_pchBuf + m_cchAvail;
	
	return TRUE; //success
}

// ############################################################################
inline int CCSVFile::ChNext(void)
{

LNextChar:
	if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
		return -1;	 //nothing more to read

	m_iLastRead = *m_pchBuf++;
	if (chReturn == m_iLastRead)
		goto LNextChar;		//faster to NOT make extra function call

	return m_iLastRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\debug.cpp ===
/*-----------------------------------------------------------------------------

  debug.cpp

	This file implements the debuggin features

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
		7/31/96 ValdonB Changes for Win16
	
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>





BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(LPCSTR psz)
{
#if defined(DEBUG)
	OutputDebugString(psz);
#endif	
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(LPCSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

	wvsprintf(szBuf, pcsz, argp);

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(LPCSTR szFile,  DWORD dwLine, LPCSTR szMsg, DWORD dwFlags)
{

	BOOL fAssertIntoDebugger = FALSE;

	char szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	//BYTE	szTime[80];
#if !defined(WIN16)
	CHAR	szTime[80];
	HANDLE	hAssertTxt;
	SYSTEMTIME st;
	DWORD	cbWritten;
#endif
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz("***Recursive Assert***\r\n");
		return(FALSE);
		}

	fInAssert = TRUE;
	
#if defined(WIN16)
	GetModuleFileName(g_hInstDll, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%ld\r\n%s,\r\n%s", szFile, dwLine, szFileName, szMsg);
#else
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s",
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
#endif
	wsprintf(szTitle,"Assertion Failed");

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
#if !defined(WIN16)
	hAssertTxt = CreateFile("assert.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);   
		wsprintf(szTime, "\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}
#endif

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
#if defined(WIN16)
			abort();
#else
    		ExitProcess(0);
#endif
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;  
	
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\misc.h ===
// ############################################################################
// PROTOTYPES
LPSTR GetSz(WORD wszID);
void SzCanonicalFromAE (LPSTR psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE);
int __cdecl CompareIDLookUpElements(const void *e1, const void *e2);
int __cdecl CompareCntryNameLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2);
int __cdecl Compare950Entry(const void*e1, const void*e2);
BOOL FSz2Dw(LPCSTR pSz,DWORD far *dw);
BOOL FSz2W(LPCSTR pSz,WORD far *w);
BOOL FSz2B(LPCSTR pSz,BYTE far *pb);
HRESULT MakeBold (HWND hwnd);
HRESULT ReleaseBold(HWND hwnd);
#if !defined(WIN16)
DWORD DWGetWin32Platform();
DWORD DWGetWin32BuildNumber();
#endif
/*
inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw);
inline BOOL FSz2W(PCSTR pSz,WORD *w);
inline BOOL FSz2B(PCSTR pSz,BYTE *pb);
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\debug.h ===
#ifndef _PHBKDEBUG
#define _PHBKDEBUG

//extern "C" {
	void Dprintf(LPCSTR pcsz, ...);
//}

#ifdef DEBUG
//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	BOOL FAssertProc(LPCSTR szFile,  DWORD dwLine, LPCSTR szMsg, DWORD dwFlags);
	void DebugSz(LPCSTR psz);
//#ifdef __cplusplus
//}
//#endif // __cplusplus
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
	#define Assert(f)					AssertSz((f), "!(" #f ")")
#else
	#define DebugSz(x)
	#define AssertSzFlg(f, sz, dwFlg) (f)
	#define AssertSz(f, sz) (f)
	#define Assert(f) (f)
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\pch.h ===
#include <windows.h>

#include <tapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\misc.cpp ===
// ############################################################################
// Miscellaneous support routines
#include "pch.hpp"
#include "phbk.h"

#define irgMaxSzs 5
char szStrTable[irgMaxSzs][256];

// ############################################################################
LPSTR GetSz(WORD wszID)
{
	static int iSzTable=0;
	LPSTR psz = (LPSTR)&szStrTable[iSzTable][0];
	
	iSzTable++;
	if (iSzTable >= irgMaxSzs)
		iSzTable = 0;
		
	if (!LoadString(g_hInstDll, wszID, psz, 256))
	{
		Dprintf("LoadString failed %d\n", (DWORD) wszID);
		*psz = 0;
	}
		
	return (psz);
}

// ############################################################################
void SzCanonicalFromAE (LPSTR psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE)
{
	if (NO_AREA_CODE == pAE->dwAreaCode)
	{
		wsprintf(psz, "+%ld %s", pLCE->dwCountryCode, pAE->szAccessNumber);
	}
	else
	{
		wsprintf(psz, "+%ld (%s) %s", pLCE->dwCountryCode, pAE->szAreaCode, pAE->szAccessNumber);
	}
	
	return;
}

// ############################################################################
int MyStrcmp(LPVOID pv1, LPVOID pv2)
{
	LPSTR pc1 = (LPSTR) pv1;
	LPSTR pc2 = (LPSTR) pv2;
	int iRC = 0;
	// loop while not pointed at the ending NULL character and no difference has been found
	while (*pc1 && *pc2 && !iRC)
	{
		iRC = (int)(*pc1 - *pc2);
		pc1++;
		pc2++;
	}

	// if we exited because we got to the end of one string before we found a difference
	// return -1 if pv1 is longer, else return the character pointed at by pv2.  If pv2
	// is longer than pv1 then the value at pv2 will be greater than 0.  If both strings
	// ended at the same time, then pv2 will point to 0.
	if (!iRC)
	{
		iRC = (*pc1) ? -1 : (*pc2);
	}
	return iRC;
}
// ############################################################################
int __cdecl Compare950Entry(const void*pv1, const void*pv2)
{
	return (((NPABLOCK *) pv1)->wAreaCode - ((NPABLOCK *) pv2)->wAreaCode);
}

// ############################################################################
int __cdecl CompareIDLookUpElements(const void *e1, const void *e2)
{
	if (((LPIDLOOKUPELEMENT)e1)->dwID > ((LPIDLOOKUPELEMENT)e2)->dwID)
		return 1;
	if (((LPIDLOOKUPELEMENT)e1)->dwID < ((LPIDLOOKUPELEMENT)e2)->dwID)
		return -1;
	return 0;
}

// ############################################################################
int __cdecl CompareCntryNameLookUpElements(const void *e1, const void *e2)
{
	LPCNTRYNAMELOOKUPELEMENT pCUE1 = (LPCNTRYNAMELOOKUPELEMENT)e1;
	LPCNTRYNAMELOOKUPELEMENT pCUE2 = (LPCNTRYNAMELOOKUPELEMENT)e2;

#ifdef WIN16
	return lstrcmpi(pCUE1->psCountryName, pCUE2->psCountryName);
#else		
	return CompareString(LOCALE_USER_DEFAULT,0,pCUE1->psCountryName,
		pCUE1->dwNameSize,pCUE2->psCountryName,
		pCUE2->dwNameSize) - 2;
//	return CompareString(LOCALE_USER_DEFAULT,0,((LPCNTRYNAMELOOKUPELEMENT)*e1)->psCountryName,
//		((LPCNTRYNAMELOOKUPELEMENT)*e1)->dwNameSize,((LPCNTRYNAMELOOKUPELEMENT)*e2)->psCountryName,
//		((LPCNTRYNAMELOOKUPELEMENT)*e2)->dwNameSize) - 2;
#endif
}

// ############################################################################
int __cdecl CompareIdxLookUpElements(const void *e1, const void *e2)
{
	if (((LPIDXLOOKUPELEMENT)e1)->dwIndex > ((LPIDXLOOKUPELEMENT)e2)->dwIndex)
		return 1;
	if (((LPIDXLOOKUPELEMENT)e1)->dwIndex < ((LPIDXLOOKUPELEMENT)e2)->dwIndex)
		return -1;
	return 0;
}

// ############################################################################
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2)
{
	PACCESSENTRY pae1, pae2;
	int iSort;

	pae1 = ((LPIDXLOOKUPELEMENT)pv1)->pAE;
	pae2 = ((LPIDXLOOKUPELEMENT)pv2)->pAE;

	// sort empty enteries to the end of the list
	if (!(pae1 && pae2))
	{
		return (pae1 ? -1 : (pae2 ? 1 : 0));
	}

	// country ASC, state ASC, city ASC, toll free DESC, flip DESC, con spd max DESC
	if (pae1->dwCountryID != pae2->dwCountryID)
	{
		return (int)(pae1->dwCountryID - pae2->dwCountryID);
	}
	
	if (pae1->wStateID != pae2->wStateID)
	{
		return (pae1->wStateID - pae2->wStateID);
	}

	iSort  = MyStrcmp((LPVOID)pae1->szCity, (LPVOID)pae2->szCity);
	if (iSort)
	{
		return (iSort);
	}

	if (pae1->fType != pae2->fType)
	{
		return (pae2->fType - pae1->fType);
	}

	if (pae1->bFlipFactor != pae2->bFlipFactor)
	{
		return (pae2->bFlipFactor - pae1->bFlipFactor);
	}

	if (pae1->dwConnectSpeedMax != pae2->dwConnectSpeedMax)
	{
		return (int)(pae2->dwConnectSpeedMax - pae1->dwConnectSpeedMax);
	}

	return 0;
}

// ############################################################################
//inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
BOOL FSz2Dw(LPCSTR pSz,DWORD far *dw)
{
	DWORD val = 0;
	while (*pSz)
	{
		if (*pSz >= '0' && *pSz <= '9')
		{
			val *= 10;
			val += *pSz++ - '0';
		}
		else
		{
			return FALSE;  //bad number
		}
	}
	*dw = val;
	return (TRUE);
}

// ############################################################################
//inline BOOL FSz2W(PCSTR pSz,WORD *w)
BOOL FSz2W(LPCSTR pSz,WORD far *w)
{
	DWORD dw;
	if (FSz2Dw(pSz,&dw))
	{
		*w = (WORD)dw;
		return TRUE;
	}
	return FALSE;
}

// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2B(LPCSTR pSz,BYTE far *pb)
{
	DWORD dw;
	if (FSz2Dw(pSz,&dw))
	{
		*pb = (BYTE)dw;
		return TRUE;
	}
	return FALSE;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
	HFONT hfont = NULL;

	hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	if (hfont) DeleteObject(hfont);
	return ERROR_SUCCESS;
}

// ############################################################################
HRESULT MakeBold (HWND hwnd)
{
	HRESULT hr = ERROR_SUCCESS;
	HFONT hfont = NULL;
	HFONT hnewfont = NULL;
	LOGFONT far * plogfont = NULL;

	if (!hwnd) goto MakeBoldExit;

	hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	if (!hfont)
	{
		hr = GetLastError();
		goto MakeBoldExit;
	}
    
	plogfont = (LOGFONT far *)GlobalAlloc(GPTR,sizeof(LOGFONT));
	if (!plogfont)
	{
		hr = GetLastError();
		goto MakeBoldExit;
	}

	if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
	{
		hr = GetLastError();
		goto MakeBoldExit;
	}

	if (plogfont->lfHeight < 24)
	{
		plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
	}

	plogfont->lfWeight = FW_BOLD;

	if (!(hnewfont = CreateFontIndirect(plogfont)))
	{
		hr = GetLastError();
		goto MakeBoldExit;
	}

	SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(FALSE,0));

	GlobalFree(plogfont);
	plogfont = NULL;
	
MakeBoldExit:
	//if (hfont) DeleteObject(hfont);
	// BUG:? Do I need to delete hnewfont at some time?
	return hr;
}

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//	Function:	DWGetWin32Platform
//
//	Synopsis:	Return a value to determine win32 platform
//
//	Arguements:	None
//
//	Returns:	platform enumeration (see GetVersionEx for details)
//
//	History:	8/8/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
DWORD DWGetWin32Platform()
{
	OSVERSIONINFO osver;
	ZeroMemory(&osver,sizeof(osver));
	osver.dwOSVersionInfoSize = sizeof(osver);
	if (GetVersionEx(&osver))
		return osver.dwPlatformId;
	AssertSz(0,"GetVersionEx failed.\r\n");
	return 0;
}

//+----------------------------------------------------------------------------
//
//	Function:	DWGetWin32BuildNumber
//
//	Synopsis:	Return a value to determine win32 build
//
//	Arguements:	None
//
//	Returns:	build number
//
//	History:	9/26/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
DWORD DWGetWin32BuildNumber()
{
	OSVERSIONINFO osver;
	ZeroMemory(&osver,sizeof(osver));
	osver.dwOSVersionInfoSize = sizeof(osver);
	if (GetVersionEx(&osver))
		// dwBuildNumber
		// Identifies the build number of the operating system in the low-order
		// word. (The high-order word contains the major and minor version numbers.)
		return (osver.dwBuildNumber & 0xFFFF);
	AssertSz(0,"GetVersionEx failed.\r\n");
	return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\main.cpp ===
// ############################################################################
#include "pch.hpp"

extern "C" {
HINSTANCE g_hInstDll;	// instance for this DLL  
}


#ifdef WIN16

int CALLBACK LibMain(HINSTANCE hinst, 
						WORD wDataSeg, 
						WORD cbHeap,
						LPSTR lpszCmdLine )
{
	g_hInstDll = hinst;

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   PrivateMalloc()
//
//  Synopsis:   Allocate and initialize memory
//
//  Arguments:  [size	- Size of memory block to be allocated]
//
//	Returns:	pointer to memory block if successful
//				NULL otherwise
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void far *PrivateMalloc(size_t size)
{
	void far * ReturnValue = NULL;
	
	ReturnValue = malloc(size);
	if (NULL != ReturnValue)
		memset(ReturnValue, 0, size);
		
	return ReturnValue;
}

//+---------------------------------------------------------------------------
//
//  Function:   PrivateReAlloc()
//
//  Synopsis:   Reallocate memory
//
//  Arguments:  [lpBlock 	- Block to be reallocated ]
//				[size		- Size of memory block to be allocated]
//
//	Returns:	pointer to memory block if successful
//				NULL otherwise
//
//  History:    7/25/96     ValdonB    Created
//
//----------------------------------------------------------------------------
void far *PrivateReAlloc(void far *lpBlock, size_t size)
{
	void far *lpRetBlock;
	
	lpRetBlock = PrivateMalloc(size);
	if (NULL == lpRetBlock)
		return NULL;
	
	if (NULL != lpBlock)
	{
		size_t OldBlockSize, MoveSize;
		
		OldBlockSize = _msize(lpBlock);
		MoveSize = min(OldBlockSize, size);
		memmove(lpRetBlock, lpBlock, MoveSize);  
		PrivateFree(lpBlock);
	}
	
	return lpRetBlock;
}


//+---------------------------------------------------------------------------
//
//  Function:   PrivateFree
//
//  Synopsis:   Free a block of memory
//
//  Arguments:  [lpBlock - Block to be freed]
//
//	Returns:	Nothing
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void PrivateFree(void far *lpBlock)
{
	free(lpBlock);
}


//+---------------------------------------------------------------------------
//
//  Function:   SearchPath()
//
//  Synopsis:   Searchs for the specified file in the given path
//
//  Arguments:  [lpPath			- Address of search path]
//				[lpFileName		- Address of filename]
//				[lpExtension	- Address of Extension]
//				[nBufferLength	- size, in characters, of buffer]
//				[lpBuffer		- address of buffer for found filename]
//				[lpFilePart		- address of pointer to file component]
//
//	Returns:	Length of string copied to buffer (not including terminating
//					NULL character) if successful
//				0 otherwise
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
DWORD SearchPath(LPCTSTR lpPath,LPCTSTR lpFileName, LPCTSTR lpExtension,
					DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart)
{ 
	
	BOOL bUseExtension = FALSE, bPathContainsFileName = FALSE;
	DWORD dwRequiredLength;
	LPSTR lpszPath = lpPath;
	char szFileName[MAX_PATH+1];
	OFSTRUCT OpenBuf;
		
	
	
	// Check if extension should be used
	//
	if ((NULL != lpExtension) && !strchr(lpFileName, '.'))
		bUseExtension = TRUE;

	//
	// Form Filename
	//
	lstrcpy(szFileName, lpFileName);
	if (bUseExtension)
		lstrcat(szFileName, lpExtension);
	
	
	//
	// If search path is NULL, then try to OpenFile using OF_SEARCH flag
	// get the full path in OpenBuf struct
	//
	if (NULL == lpszPath)
	{
		
		if (HFILE_ERROR != OpenFile(szFileName, &OpenBuf, OF_EXIST | OF_SEARCH))
		{ 
			//
			// This path contains the file name also
			//
			lpszPath = &OpenBuf.szPathName[0];
			bPathContainsFileName = TRUE;
		}
		else
			return 0;
	}
			
	//
	// Check if output buffer length is sufficient
	//
	dwRequiredLength = lstrlen(lpszPath) + 
						(bPathContainsFileName ? 0 :lstrlen(szFileName)) + 1;
	if (nBufferLength < dwRequiredLength)
		return 0;

	//
	// Copy the full name to buffer
	//
	if (bPathContainsFileName)
		lstrcpy(lpBuffer, lpszPath);
	else
		wsprintf(lpBuffer, "%s\\%s", lpszPath, szFileName);

	
	//
	// Do not include the terminating null character in return length
	//
	return dwRequiredLength - 1;
}


#else // WIN16

#ifdef   _NOT_USING_ACTIVEX 
extern "C" __declspec(dllexport) BOOL WINAPI DllMain(
    HINSTANCE  hinstDLL,	// handle to DLL module 
    DWORD  fdwReason,		// reason for calling function 
    LPVOID  lpvReserved 	// reserved 
   )
{
	if (fdwReason == DLL_PROCESS_ATTACH)
		g_hInstDll = hinstDLL;
    
	return TRUE;
}
#if 0
extern "C" __declspec(dllexport) BOOL WINAPI DllMain(
    HINSTANCE  hinstDLL,	// handle to DLL module 
    DWORD  fdwReason,		// reason for calling function 
    LPVOID  lpvReserved 	// reserved 
   )
{
	if (fdwReason == DLL_PROCESS_ATTACH)
		g_hInstDll = hinstDLL;
    
	return TRUE;
}
#endif

#endif
#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\pch.hpp ===
#include <windows.h>


#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>

#include <ras.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\phbk.h ===
#ifndef _PHBK
#define _PHBK

#include "ccsv.h"
#include "debug.h"

#define DllExportH extern "C" HRESULT WINAPI __stdcall
//#define DllExportH extern "C" __declspec(dllexport) HRESULT WINAPI

#if !defined(WIN16)
#define MsgBox(m,s) MessageBox(g_hWndMain,GetSz(m),GetSz(IDS_TITLE),s)
#endif

#define cbAreaCode	6			// maximum number of characters in an area code, not including \0
#define cbCity 19				// maximum number of chars in city name, not including \0
#define cbAccessNumber 15		// maximum number of chars in phone number, not including \0
#define cbStateName 31 			// maximum number of chars in state name, not including \0
								// check this against state.pbk delivered by mktg
#define cbBaudRate 6			// maximum number of chars in a baud rate, not including \0
#if defined(WIN16)
#define cbDataCenter 12			// max length of data center string
#else
#define cbDataCenter (MAX_PATH+1)			// max length of data center string
#endif
#define NO_AREA_CODE 0xFFFFFFFF

#define PHONE_ENTRY_ALLOC_SIZE	500
#define INF_SUFFIX ".ISP"
#define INF_APP_NAME "ISP INFO"
#define INF_PHONE_BOOK "PhoneBookFile"
#define INF_DEFAULT	"SPAM SPAM SPAM SPAM SPAM SPAM EGGS AND SPAM"
#define STATE_FILENAME "STATE.ICW"
#define FILE_NAME_800950 "800950.DAT"
#define TEMP_BUFFER_LENGTH 1024
#define MAX_INFCODE 9

#define TYPE_SIGNUP_TOLLFREE	0x83
#define TYPE_SIGNUP_TOLL		0x82
#define TYPE_REGULAR_USAGE		0x42

#define MASK_SIGNUP_TOLLFREE	0xB3
#define MASK_SIGNUP_TOLL		0xB3
#define MASK_REGULAR_USAGE		0x73

// 8/13/96 jmazner for Normandy bug #4597
// ported from core\client\phbk 10/15/96
#define MASK_TOLLFREE_BIT			0x01	// Bit #1: 1=tollfree, 0=charge
#define TYPE_SET_TOLLFREE			0x01	// usage: type |= TYPE_SET_TOLLFREE
// want TYPE_SET_TOLL to be a DWORD to match pSuggestInfo->fType
#define TYPE_SET_TOLL				~((DWORD)TYPE_SET_TOLLFREE)    // usage: type &= TYPE_SET_TOLL


#define clineMaxATT	16
#define NXXMin		200
#define NXXMax		999
#define cbgrbitNXX	((NXXMax + 1 - NXXMin) / 8)

// Phone number select dialog flags
//

#define FREETEXT_SELECTION_METHOD  0x00000001
#define PHONELIST_SELECTION_METHOD 0x00000002
#define AUTODIAL_IN_PROGRESS       0x00000004
#define DIALERR_IN_PROGRESS        0x00000008

typedef struct
{
	DWORD	dwIndex;								// index number
	BYTE	bFlipFactor;							// for auto-pick
	DWORD	fType;									// phone number type
	WORD	wStateID;								// state ID
	DWORD	dwCountryID;							// TAPI country ID
	DWORD	dwAreaCode;								// area code or NO_AREA_CODE if none
	DWORD	dwConnectSpeedMin;						// minimum baud rate
	DWORD	dwConnectSpeedMax;						// maximum baud rate
	char	szCity[cbCity + sizeof('\0')];			// city name
	char	szAccessNumber[cbAccessNumber + sizeof('\0')];	// access number
	char	szDataCenter[cbDataCenter + sizeof('\0')];				// data center access string
	char	szAreaCode[cbAreaCode + sizeof('\0')];					//Keep the actual area code string around.
} ACCESSENTRY, far *PACCESSENTRY; 	// ae

typedef struct {
	DWORD dwCountryID;								// country ID that this state occurred in
	PACCESSENTRY paeFirst;							// pointer to first access entry for this state
	char szStateName[cbStateName + sizeof('\0')];	// state name
} STATE, far *LPSTATE;

typedef struct tagIDLOOKUPELEMENT {
	DWORD dwID;
	LPLINECOUNTRYENTRY pLCE;
	PACCESSENTRY pFirstAE;
} IDLOOKUPELEMENT, far *LPIDLOOKUPELEMENT;

typedef struct tagCNTRYNAMELOOKUPELEMENT {
	LPSTR psCountryName;
	DWORD dwNameSize;
	LPLINECOUNTRYENTRY pLCE;
} CNTRYNAMELOOKUPELEMENT, far *LPCNTRYNAMELOOKUPELEMENT;

typedef struct tagIDXLOOKUPELEMENT {
	DWORD dwIndex;
	PACCESSENTRY pAE;
} IDXLOOKUPELEMENT,far *LPIDXLOOKUPELEMENT;

typedef struct tagSUGGESTIONINFO
{
	DWORD	dwCountryID;
	DWORD	wAreaCode;
	DWORD	wExchange;
	WORD	wNumber;
	DWORD	fType;  // 9/6/96 jmazner  Normandy
	DWORD	bMask;  // make this struct look like the one in %msnroot%\core\client\phbk\phbk.h
	PACCESSENTRY *rgpAccessEntry;
} SUGGESTINFO, far *PSUGGESTINFO;

typedef struct tagNPABlock
{
	WORD wAreaCode;
	BYTE grbitNXX [cbgrbitNXX];
} NPABLOCK, far *LPNPABLOCK;



class CPhoneBook
{
	//friend HRESULT DllExport PhoneBookLoad(LPCSTR pszISPCode, DWORD_PTR *pdwPhoneID);
	//friend class CDialog;
	
	// 1/9/96  jmazner Normandy #13185
	//friend class CAccessNumDlg;
	
	friend class CSelectNumDlg;

public:
	void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
	void operator delete( void far * p ) {GlobalFree(p); };

	CPhoneBook();
	~CPhoneBook();

	HRESULT Init(LPCSTR pszISPCode);
	HRESULT Merge(LPCSTR pszChangeFilename);
	HRESULT Suggest(PSUGGESTINFO pSuggest);
	HRESULT GetCanonical(PACCESSENTRY pAE, LPSTR psOut);

private:
	PACCESSENTRY			m_rgPhoneBookEntry;
	HANDLE					m_hPhoneBookEntry;	
	DWORD					m_cPhoneBookEntries;
	LPLINECOUNTRYENTRY		m_rgLineCountryEntry;
	LPLINECOUNTRYLIST 		m_pLineCountryList;
	LPIDLOOKUPELEMENT		m_rgIDLookUp;
	LPCNTRYNAMELOOKUPELEMENT m_rgNameLookUp;
	LPSTATE					m_rgState;
	DWORD					m_cStates;
	BOOL              m_bScriptingAvailable;
	char					m_szINFFile[MAX_PATH];
	char					m_szINFCode[MAX_INFCODE];
	char					m_szPhoneBook[MAX_PATH];
	char                    m_szICWDirectoryPath[MAX_PATH];
	// Added on 05/13/97  by Suresh
	// To store the ICW directory Path as it is required by RegWiz
	//
	BOOL ReadPhoneBookDW(DWORD far *pdw, CCSVFile far *pcCSVFile);
	BOOL ReadPhoneBookW(WORD far *pw, CCSVFile far *pcCSVFile);
	BOOL ReadPhoneBookSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile);
	BOOL ReadPhoneBookB(BYTE far *pb, CCSVFile far *pcCSVFile);
	HRESULT ReadOneLine(PACCESSENTRY pAccessEntry, CCSVFile far *pcCSVFile);
	BOOL FixUpFromRealloc(PACCESSENTRY paeOld, PACCESSENTRY paeNew);

};

#ifdef __cplusplus
extern "C" {
#endif
extern HINSTANCE g_hInstDll;	// instance for this DLL
extern HWND g_hWndMain;
#ifdef __cplusplus
}
#endif
#endif // _PHBK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\phbkex.h ===
#ifndef _PHBKEX
#define _PHBKEX

#define TYPE_SIGNUP_ANY			0x82
#define TYPE_SIGNUP_TOLLFREE	0x83
#define TYPE_SIGNUP_TOLL		0x82
#define TYPE_REGULAR_USAGE		0x42

#define MASK_SIGNUP_ANY			0xB2
#define MASK_SIGNUP_TOLLFREE	0xB3
#define MASK_SIGNUP_TOLL		0xB3
#define MASK_REGULAR_USAGE		0x73

#define cbAreaCode	6			// maximum number of characters in an area code, not including \0
#define cbCity 19				// maximum number of chars in city name, not including \0
#define cbAccessNumber 15		// maximum number of chars in phone number, not including \0
#define cbStateName 31 			// maximum number of chars in state name, not including \0
								// check this against state.pbk delivered by mktg
#define cbBaudRate 6			// maximum number of chars in a baud rate, not including \0
#define cbDataCenter 12			// max length of data center string

typedef struct
{
	DWORD	dwIndex;								// index number
	BYTE	bFlipFactor;							// for auto-pick
	BYTE	fType;									// phone number type
	WORD	wStateID;								// state ID
	DWORD	dwCountryID;							// TAPI country ID
	DWORD	dwAreaCode;								// area code or NO_AREA_CODE if none
	DWORD	dwConnectSpeedMin;						// minimum baud rate
	DWORD	dwConnectSpeedMax;						// maximum baud rate
	char	szCity[cbCity + sizeof('\0')];			// city name
	char	szAccessNumber[cbAccessNumber + sizeof('\0')];	// access number
	char	szDataCenter[cbDataCenter + sizeof('\0')];				// data center access string
	char	szAreaCode[cbAreaCode + sizeof('\0')];					//Keep the actual area code string around.
} ACCESSENTRY, FAR  *PACCESSENTRY; 	// ae

typedef struct tagSUGGESTIONINFO
{
	DWORD	dwCountryID;
	DWORD	wAreaCode;
	DWORD	wExchange;
	WORD	wNumber;
	BYTE	fType;
	BYTE	bMask;
	PACCESSENTRY *rgpAccessEntry;
} SUGGESTINFO,FAR *PSUGGESTINFO;

#endif _PHBKEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\phbk.cpp ===
// ############################################################################
// Phone book APIs
#include "pch.hpp"
#include <tchar.h>

#include "phbk.h"
#include "misc.h"
#include "phbkrc.h"
#include "suapi.h"

#define ReadVerifyPhoneBookDW(x)	if (!ReadPhoneBookDW(&(x),pcCSVFile))				\
										{	AssertSz(0,"Invalid DWORD in phone book");	\
											goto ReadError; }
#define ReadVerifyPhoneBookW(x)		if (!ReadPhoneBookW(&(x),pcCSVFile))				\
										{	AssertSz(0,"Invalid DWORD in phone book");	\
											goto ReadError; }
#define ReadVerifyPhoneBookB(x)		if (!ReadPhoneBookB(&(x),pcCSVFile))				\
										{	AssertSz(0,"Invalid DWORD in phone book");	\
											goto ReadError; }
#define ReadVerifyPhoneBookSZ(x,y)	if (!ReadPhoneBookSZ(&x[0],y+sizeof('\0'),pcCSVFile))	\
										{	AssertSz(0,"Invalid DWORD in phone book");		\
											goto ReadError; }

#define CHANGE_BUFFER_SIZE 50

#define TEMP_PHONE_BOOK_PREFIX "PBH"

#define ERROR_USERBACK 32766
#define ERROR_USERCANCEL 32767

char szTempBuffer[TEMP_BUFFER_LENGTH];
char szTempFileName[MAX_PATH];

#ifdef __cplusplus
extern "C" {
#endif
HWND g_hWndMain;
#ifdef __cplusplus
}
#endif


static void GetAbsolutePath( LPTSTR input, LPTSTR output, DWORD chOut)
	{
		if(_tcschr(input,_T('%')) == NULL) {
			_tcsncpy(output, input, chOut);
			return ;
		}

		if(input[0] == _T('%'))
		{
			LPTSTR token = _tcstok(input,_T("%"));
			if(token != NULL)
			{
				LPTSTR sztemp;
				sztemp = getenv( token );
				if(sztemp != NULL)
				{
					_tcsncpy(output, sztemp, chOut);
				}
				token = _tcstok(NULL,_T("\0"));
				if(token != NULL)
				{
					_tcsncat(output, token, chOut - _tcslen(output));
				}
			}
		}
		else
		{
			LPTSTR token = _tcstok(input,_T("%"));
			if(token != NULL)
			{
				_tcsncpy(output, token, chOut);
				token = _tcstok(NULL,_T("%"));
				if(token != NULL)
				{
					LPTSTR sztemp;
					sztemp = getenv( token );
					if(sztemp != NULL)
					{
						_tcsncat(output, sztemp, chOut - _tcslen(output));
					}
					token = _tcstok(NULL,_T("\0"));
					if(token != NULL)
					{
						_tcsncat(output, token, chOut - _tcslen(output));
					}
				}
			}
		}
		
		GetAbsolutePath(output, output, chOut);
	}



// ############################################################################
CPhoneBook::CPhoneBook()
{
	HINSTANCE hInst = NULL;
	LONG lrc;
//	HANDLE   hKey;
	LONG  regStatus;
	char  uszRegKey[]="SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE";
	char  uszR[ ]= "Path";
	DWORD dwInfoSize ;
	HKEY  hKey;

	DWORD dwType;
	DWORD dwSize;
	CHAR  szData[MAX_PATH+1];
	CHAR  czTemp[256];

	m_rgPhoneBookEntry = NULL;
	m_hPhoneBookEntry = NULL;
	m_cPhoneBookEntries =0;
	m_rgLineCountryEntry=NULL;
	m_rgState=NULL;
	m_cStates=0;
	m_rgIDLookUp = NULL;
	m_rgNameLookUp = NULL;
	m_pLineCountryList = NULL;

	ZeroMemory(&m_szINFFile[0],MAX_PATH);
	ZeroMemory(&m_szINFCode[0],MAX_INFCODE);
	ZeroMemory(&m_szPhoneBook[0],MAX_PATH);
	ZeroMemory(&m_szICWDirectoryPath,MAX_PATH);

	

	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					uszRegKey,0,KEY_READ ,&hKey);
	if (regStatus == ERROR_SUCCESS) {
		// Get The Path
		dwInfoSize = MAX_PATH;
		RegQueryValueEx(hKey,uszR,NULL,0,(LPBYTE) czTemp,
			&dwInfoSize);
		GetAbsolutePath(czTemp,m_szICWDirectoryPath, MAX_PATH-1);
		size_t sLen = strlen(m_szICWDirectoryPath);
		m_szICWDirectoryPath[sLen-1] = '\0';
	}
	else {

		MessageBox(NULL,"Error Accessing PAth ","SearchPath",MB_OK);
		// Error
	}


#if !defined(WIN16)
	if (VER_PLATFORM_WIN32_NT == DWGetWin32Platform())
	{
		m_bScriptingAvailable = TRUE;
	}
	else
	{
		//
		// Verify scripting by checking for smmscrpt.dll in RemoteAccess registry key
		//
		if (1111 <= DWGetWin32BuildNumber())
		{
			m_bScriptingAvailable = TRUE;
		}
		else
		{
			m_bScriptingAvailable = FALSE;
			hKey = NULL;
			lrc=RegOpenKey(HKEY_LOCAL_MACHINE,"System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP",&hKey);
			if (ERROR_SUCCESS == lrc)
			{
				dwSize = MAX_PATH;
				lrc = RegQueryValueEx(hKey,"Path",0,&dwType,(LPBYTE)szData,&dwSize);
				if (ERROR_SUCCESS == lrc)
				{
					if (0 == lstrcmpi(szData,"smmscrpt.dll"))
						m_bScriptingAvailable = TRUE;
				}
			}
			if (hKey)
				RegCloseKey(hKey);
			hKey = NULL;
		}

		//
		// Verify that the DLL can be loaded
		//
		if (m_bScriptingAvailable)
		{
			hInst = LoadLibrary("smmscrpt.dll");
			if (hInst)
				FreeLibrary(hInst);
			else
				m_bScriptingAvailable = FALSE;
			hInst = NULL;
		}
	}
#endif // WIN16
}

// ############################################################################
CPhoneBook::~CPhoneBook()
{
#ifdef WIN16
	if (m_rgPhoneBookEntry)
		GlobalFree(m_rgPhoneBookEntry);
#else
	if (m_hPhoneBookEntry)
		GlobalUnlock(m_hPhoneBookEntry);

	if (m_hPhoneBookEntry)
		GlobalFree(m_hPhoneBookEntry);
#endif

	if (m_pLineCountryList)
		GlobalFree(m_pLineCountryList);

	if (m_rgIDLookUp)
		GlobalFree(m_rgIDLookUp);

	if (m_rgNameLookUp)
		GlobalFree(m_rgNameLookUp);

	if (m_rgState)
		GlobalFree(m_rgState);
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookDW(DWORD far *pdw, CCSVFile far *pcCSVFile)
{
	if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
			return FALSE;
	return (FSz2Dw(szTempBuffer,pdw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookW(WORD far *pw, CCSVFile far *pcCSVFile)
{
	if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
			return FALSE;
	return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookB(BYTE far *pb, CCSVFile far *pcCSVFile)
{
	if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
			return FALSE;
	return (FSz2B(szTempBuffer,pb));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile)
{
	if (!pcCSVFile->ReadToken(psz,dwSize))
			return FALSE;
	return TRUE;
}

// ############################################################################
BOOL CPhoneBook::FixUpFromRealloc(PACCESSENTRY paeOld, PACCESSENTRY paeNew)
{
	BOOL bRC = FALSE;
	LONG_PTR lDiff = 0;
	DWORD idx = 0;

	//
	// No starting value or no move, therefore no fix-ups needed
	//
	if ((0 == paeOld) || (paeNew == paeOld))
	{
		bRC = TRUE;
		goto FixUpFromReallocExit;
	}

	Assert(paeNew);
	Assert(((LONG_PTR)paeOld) > 0);	// if these address look like negative numbers
	Assert(((LONG_PTR)paeNew) > 0); // I'm not sure the code would handle them

	lDiff = (LONG_PTR)paeOld - (LONG_PTR)paeNew;

	//
	// fix up STATES
	//
	for (idx = 0; idx < m_cStates; idx++)
	{
		if (m_rgState[idx].paeFirst)
			m_rgState[idx].paeFirst = (PACCESSENTRY )((LONG_PTR)m_rgState[idx].paeFirst - lDiff);
	}

	//
	// fix up ID look up array
	//
	for (idx = 0; idx < m_pLineCountryList->dwNumCountries ; idx++)
	{
		if (m_rgIDLookUp[idx].pFirstAE)
			m_rgIDLookUp[idx].pFirstAE = (PACCESSENTRY )((LONG_PTR)m_rgIDLookUp[idx].pFirstAE - lDiff);
	}

	bRC = TRUE;
FixUpFromReallocExit:
	return bRC;
}
/*
long WINAPI lineGetCountry(unsigned long x,unsigned long y,struct linecountrylist_tag *z)
{
	return 0;
}
*/
// ############################################################################
HRESULT CPhoneBook::Init(LPCSTR pszISPCode)
{
	LPLINECOUNTRYLIST pLineCountryTemp = NULL;
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	DWORD dwLastState = 0;
	DWORD dwLastCountry = 0;
	DWORD dwSizeAllocated;
	PACCESSENTRY pCurAccessEntry;
	PACCESSENTRY pAETemp;
	LPLINECOUNTRYENTRY pLCETemp;
	DWORD idx;
	LPSTR pszTemp;
	CCSVFile far *pcCSVFile=NULL;
	LPSTATE	ps,psLast; //faster to use pointers.
	int iTestSK;
	

	// Get TAPI country list
	m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
	if (!m_pLineCountryList)
		goto InitExit;
	
	m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);

	
	
#if defined(WIN16)
	idx = (DWORD) IETapiGetCountry(0, m_pLineCountryList);
#else
	idx = lineGetCountry(0,0x10003,m_pLineCountryList);
#endif
	if (idx && idx != LINEERR_STRUCTURETOOSMALL)
		goto InitExit;
	
	Assert(m_pLineCountryList->dwNeededSize);

	pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,
														(size_t)m_pLineCountryList->dwNeededSize);
	if (!pLineCountryTemp)
		goto InitExit;
	
	pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;
	GlobalFree(m_pLineCountryList);
	
	m_pLineCountryList = pLineCountryTemp;
	pLineCountryTemp = NULL;

#if defined(WIN16)
	if (IETapiGetCountry(0, m_pLineCountryList))
#else
	if (lineGetCountry(0,0x10003,m_pLineCountryList))
#endif
		goto InitExit;

//#endif	// WIN16

	// Load Look Up arrays
#ifdef DEBUG
	m_rgIDLookUp = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,
		(int)(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries+5));
#else
	m_rgIDLookUp = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,
		(int)(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries));
#endif
	if (!m_rgIDLookUp) goto InitExit;

	pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR)m_pLineCountryList +
		m_pLineCountryList->dwCountryListOffset);

	for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
	{
		m_rgIDLookUp[idx].dwID = pLCETemp[idx].dwCountryID;
		m_rgIDLookUp[idx].pLCE = &pLCETemp[idx];
	}

	qsort(m_rgIDLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
		CompareIDLookUpElements);

	m_rgNameLookUp = (LPCNTRYNAMELOOKUPELEMENT)GlobalAlloc(GPTR,
		(int)(sizeof(CNTRYNAMELOOKUPELEMENT) * m_pLineCountryList->dwNumCountries));

	if (!m_rgNameLookUp) goto InitExit;

	for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
	{
		m_rgNameLookUp[idx].psCountryName = (LPSTR)((LPBYTE)m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
		m_rgNameLookUp[idx].dwNameSize = pLCETemp[idx].dwCountryNameSize;
		m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
	}

	qsort(m_rgNameLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENT),
		CompareCntryNameLookUpElements);
	
	// Load States
	if (!SearchPath(NULL,STATE_FILENAME,NULL,TEMP_BUFFER_LENGTH,szTempBuffer,&pszTemp))
	{
		if(m_szICWDirectoryPath){
			// Try with c:\\ProgramFile\\ICW-INTERNET\\......
			if(! SearchPath(m_szICWDirectoryPath,
				STATE_FILENAME,NULL,TEMP_BUFFER_LENGTH,szTempBuffer,&pszTemp)) {
				AssertSz(0,"STATE.ICW not found");
				hr = ERROR_FILE_NOT_FOUND;
				goto InitExit;

			}else {
				; // OK Th e file is found
				iTestSK=0;

			}
		}
		else {
			AssertSz(0,"STATE.ICW not found");
			hr = ERROR_FILE_NOT_FOUND;
			goto InitExit;
		}
	}

	pcCSVFile = new CCSVFile;
	if (!pcCSVFile) goto InitExit;

	if (!pcCSVFile->Open(szTempBuffer))
	{
		AssertSz(0,"Can not open STATE.ICW");
		delete pcCSVFile;
		pcCSVFile = NULL;
		goto InitExit;
	}

	
	// first token in state file is the number of states
	if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
		goto InitExit;

	if (!FSz2Dw(szTempBuffer,&m_cStates))
	{
		AssertSz(0,"STATE.ICW count is invalid");
		goto InitExit;
	}

	m_rgState = (LPSTATE)GlobalAlloc(GPTR,(int)(sizeof(STATE)*m_cStates));
	if (!m_rgState)
		goto InitExit;

	for (ps = m_rgState, psLast = &m_rgState[m_cStates - 1]; ps <= psLast;++ps)
		{
		pcCSVFile->ReadToken(ps->szStateName,cbStateName);	
		}
	
	pcCSVFile->Close();

	// Locate ISP's INF file
	if (!SearchPath(NULL,(LPCTSTR) pszISPCode,INF_SUFFIX,MAX_PATH,
						m_szINFFile,&pszTemp))
	{
		wsprintf(szTempBuffer,"Can not find:%s%s (%d)",pszISPCode,INF_SUFFIX,GetLastError());
		if(m_szICWDirectoryPath) {
			if(!SearchPath(m_szICWDirectoryPath,(LPCTSTR) pszISPCode,INF_SUFFIX,MAX_PATH,
				m_szINFFile,&pszTemp)) {
					AssertSz(0,szTempBuffer);
					hr = ERROR_FILE_NOT_FOUND;
					goto InitExit;
				//
			}else {
				iTestSK++;

			}

		}else {
			AssertSz(0,szTempBuffer);
			hr = ERROR_FILE_NOT_FOUND;
			goto InitExit;
		}
	}

	//Load Phone Book
	if (!GetPrivateProfileString(INF_APP_NAME,INF_PHONE_BOOK,INF_DEFAULT,
		szTempBuffer,TEMP_BUFFER_LENGTH,m_szINFFile))
	{
		AssertSz(0,"PhoneBookFile not specified in INF file");
		hr = ERROR_FILE_NOT_FOUND;
		goto InitExit;
	}
	
#ifdef DEBUG
	if (!lstrcmp(szTempBuffer,INF_DEFAULT))
	{
		wsprintf(szTempBuffer, "%s value not found in ISP file", INF_PHONE_BOOK);
		AssertSz(0,szTempBuffer);
	}
#endif
	if (!SearchPath(NULL,szTempBuffer,NULL,MAX_PATH,m_szPhoneBook,&pszTemp))
	{
		if(m_szICWDirectoryPath){
			if (!SearchPath(m_szICWDirectoryPath,szTempBuffer,NULL,MAX_PATH,m_szPhoneBook,&pszTemp)){
				AssertSz(0,"ISP phone book not found");
				hr = ERROR_FILE_NOT_FOUND;
				goto InitExit;

			}else {
				;; // OK file Found
				iTestSK++;
			}

		}else {
			AssertSz(0,"ISP phone book not found");
			hr = ERROR_FILE_NOT_FOUND;
			goto InitExit;
		}

		
	}

	if (!pcCSVFile->Open(m_szPhoneBook))
	{
		AssertSz(0,"Can not open phone book");
		hr = GetLastError();
		goto InitExit;
	}
	
	dwSizeAllocated = 0;
	do {
		Assert (dwSizeAllocated >= m_cPhoneBookEntries);
		// check that sufficient memory is allocated
		if (m_rgPhoneBookEntry)
		{
			if (dwSizeAllocated == m_cPhoneBookEntries)
			{
				//
				// we need more memory
				//
//				AssertSz(0,"Out of memory originally allocated for phone book.\r\n");
//				goto InitExit;

				pAETemp = m_rgPhoneBookEntry;
#ifdef WIN16			
				dwSizeAllocated += PHONE_ENTRY_ALLOC_SIZE;
				m_rgPhoneBookEntry = (PACCESSENTRY)GlobalReAlloc(m_rgPhoneBookEntry,
					(int)(dwSizeAllocated * sizeof(ACCESSENTRY)),GHND);
				if (NULL == m_rgPhoneBookEntry)
					goto InitExit;
#else

				// UNLOCK
				Assert(m_hPhoneBookEntry);
				if (FALSE == GlobalUnlock(m_hPhoneBookEntry))
				{
					if (NO_ERROR != GetLastError())
						goto InitExit;
				}

				// REALLOC
				dwSizeAllocated += PHONE_ENTRY_ALLOC_SIZE;
				m_hPhoneBookEntry = GlobalReAlloc(m_hPhoneBookEntry,
					(int)(dwSizeAllocated * sizeof(ACCESSENTRY)),GHND);
				if (NULL == m_hPhoneBookEntry)
					goto InitExit;

				// LOCK
				m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
				if (NULL == m_rgPhoneBookEntry)
					goto InitExit;
				
#endif
				FixUpFromRealloc(pAETemp, m_rgPhoneBookEntry);
				Dprintf("Grow phone book to %d entries\n",dwSizeAllocated);
				pCurAccessEntry = (PACCESSENTRY)((LONG_PTR)pCurAccessEntry -
					((LONG_PTR)pAETemp - (LONG_PTR)(m_rgPhoneBookEntry)));

			}
		}
		else
		{
			//
			// Initialization for the first time through
			//
			
			// ALLOC
#ifdef WIN16
			m_rgPhoneBookEntry = (PACCESSENTRY)GlobalAlloc(GHND,sizeof(ACCESSENTRY) * PHONE_ENTRY_ALLOC_SIZE);
			if(NULL == m_rgPhoneBookEntry)
				goto InitExit;
#else
			m_hPhoneBookEntry = GlobalAlloc(GHND,sizeof(ACCESSENTRY) * PHONE_ENTRY_ALLOC_SIZE);
			if(NULL == m_hPhoneBookEntry)
				goto InitExit;

			// LOCK
			m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
			if(NULL == m_rgPhoneBookEntry)
				goto InitExit;
#endif
			dwSizeAllocated = PHONE_ENTRY_ALLOC_SIZE;
			pCurAccessEntry = m_rgPhoneBookEntry;
		}

		// Read a line from the phonebook
		hr = ReadOneLine(pCurAccessEntry,pcCSVFile);
		if (hr == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (hr != ERROR_SUCCESS)
		{
			goto InitExit;
		}

		hr = ERROR_NOT_ENOUGH_MEMORY;

		// Check to see if this is the first phone number for a given country
		if (pCurAccessEntry->dwCountryID != dwLastCountry)
		{
			LPIDLOOKUPELEMENT lpIDLookupElement;
			// NOTE: Not sure about the first parameter here.
			lpIDLookupElement = (LPIDLOOKUPELEMENT)bsearch(&pCurAccessEntry->dwCountryID,
				m_rgIDLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
				CompareIDLookUpElements);
			if (!lpIDLookupElement)
			{
				// bad country ID, but we can't assert here
				Dprintf("Bad country ID in phone book %d\n",pCurAccessEntry->dwCountryID);
				continue;
			}
			else
			{
				// for a given country ID this is the first phone number
				lpIDLookupElement->pFirstAE = pCurAccessEntry;
				dwLastCountry = pCurAccessEntry->dwCountryID;
			}
		}

		// Check to see if this is the first phone number for a given state
		if (pCurAccessEntry->wStateID && (pCurAccessEntry->wStateID != dwLastState))
		{
			idx = pCurAccessEntry->wStateID - 1;
			m_rgState[idx].dwCountryID = pCurAccessEntry->dwCountryID;
			m_rgState[idx].paeFirst = pCurAccessEntry;
			dwLastState = pCurAccessEntry->wStateID;
		}

		pCurAccessEntry++;
		m_cPhoneBookEntries++;
	} while (TRUE);

	// Trim the phone book for unused memory
	Assert(m_rgPhoneBookEntry && m_cPhoneBookEntries);

	pAETemp = m_rgPhoneBookEntry;

#ifdef WIN16
	m_rgPhoneBookEntry = (PACCESSENTRY)GlobalReAlloc(m_rgPhoneBookEntry,(int)(m_cPhoneBookEntries * sizeof(ACCESSENTRY)),GHND);
	if (!m_rgPhoneBookEntry) goto InitExit;
#else

	// UNLOCK
	Assert(m_hPhoneBookEntry);
	if (FALSE != GlobalUnlock(m_hPhoneBookEntry))
	{
		if (NO_ERROR != GetLastError())
			goto InitExit;
	}

	// REALLOC
	m_hPhoneBookEntry = GlobalReAlloc(m_hPhoneBookEntry,(int)(m_cPhoneBookEntries * sizeof(ACCESSENTRY)),GHND);
	if (NULL == m_hPhoneBookEntry)
		goto InitExit;

	// LOCK
	m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
	if (NULL == m_rgPhoneBookEntry)
		goto InitExit;
#endif
	FixUpFromRealloc(pAETemp, m_rgPhoneBookEntry);

	hr = ERROR_SUCCESS;
InitExit:
	// If something failed release everything
	if (hr != ERROR_SUCCESS)
	{
#ifdef WIN16
		GlobalFree(m_rgPhoneBookEntry);
#else
		GlobalUnlock(m_hPhoneBookEntry);
		GlobalFree(m_hPhoneBookEntry);
#endif
		GlobalFree(m_pLineCountryList);
		GlobalFree(m_rgIDLookUp);
		GlobalFree(m_rgNameLookUp);
		GlobalFree(m_rgState);

		m_cPhoneBookEntries = 0 ;
		m_cStates = 0;

		m_pLineCountryList = NULL;
		m_rgPhoneBookEntry = NULL;
		m_hPhoneBookEntry = NULL;
		m_rgIDLookUp=NULL;
		m_rgNameLookUp=NULL;
		m_rgState=NULL;
	}

	if (pcCSVFile)
	{
		pcCSVFile->Close();
		delete pcCSVFile;
	}
	return hr;
}

// ############################################################################
HRESULT CPhoneBook::Merge(LPCSTR pszChangeFile)
{
	CCSVFile far *pcCSVFile;
	ACCESSENTRY aeChange;
	LPIDXLOOKUPELEMENT rgIdxLookUp;
	LPIDXLOOKUPELEMENT pCurIdxLookUp;
	DWORD dwAllocated;
	DWORD dwUsed;
	DWORD dwOriginalSize;
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	DWORD	dwIdx;
#if !defined(WIN16)
	HANDLE hTemp;
	HANDLE hIdxLookUp;
#else
	// Normandy 11746
	LPVOID rgTemp;  // 16-bit only
#endif
	DWORD cch, cchWritten;
	HANDLE hFile;

	// Pad the phonebook for new entries.
	dwAllocated = m_cPhoneBookEntries + CHANGE_BUFFER_SIZE;
#ifdef WIN16
	Assert(m_rgPhoneBookEntry);
	rgTemp = GlobalReAlloc(m_rgPhoneBookEntry, (int)(sizeof(ACCESSENTRY) * dwAllocated),GHND);
	Assert(rgTemp);
	if (!rgTemp) goto MergeExit;
	m_rgPhoneBookEntry = (PACCESSENTRY)rgTemp;
#else
	Assert(m_hPhoneBookEntry);
	GlobalUnlock(m_hPhoneBookEntry);
	hTemp = (HANDLE)GlobalReAlloc(m_hPhoneBookEntry, sizeof(ACCESSENTRY) * dwAllocated,GHND);
	Assert(hTemp);
	if (!hTemp)
		goto MergeExit;
	m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
	if (!m_rgPhoneBookEntry)
		goto MergeExit;
#endif

	// Create index to loaded phone book, sorted by index
#ifdef WIN16
	rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalAlloc(GHND,(int)(sizeof(IDXLOOKUPELEMENT) * dwAllocated));
#else
	hIdxLookUp = (HANDLE)GlobalAlloc(GHND,sizeof(IDXLOOKUPELEMENT) * dwAllocated);
	rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalLock(hIdxLookUp);
#endif
	Assert(rgIdxLookUp);
	if (!rgIdxLookUp)
		goto MergeExit;

	for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
	{
		rgIdxLookUp[dwIdx].dwIndex = rgIdxLookUp[dwIdx].pAE->dwIndex;
		rgIdxLookUp[dwIdx].pAE = &m_rgPhoneBookEntry[dwIdx];
	}
	dwUsed = m_cPhoneBookEntries;
	dwOriginalSize = m_cPhoneBookEntries;

	qsort(rgIdxLookUp,(int)dwOriginalSize,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);

	// Load changes to phone book
	pcCSVFile = new CCSVFile;
	Assert(pcCSVFile);
	if (!pcCSVFile)
		goto MergeExit;
	if (!pcCSVFile->Open(pszChangeFile))
		goto MergeExit;
	
	do {

		// Read a change record
		ZeroMemory(&aeChange,sizeof(ACCESSENTRY));
		hr = ReadOneLine(&aeChange, pcCSVFile);

		if(hr == ERROR_NO_MORE_ITEMS)
		{
			break; // no more enteries
		}
		else if (hr =! ERROR_SUCCESS)
		{
			goto MergeExit;
		}

		hr = ERROR_NOT_ENOUGH_MEMORY;

		// Determine if this is a delete or add record
		if (aeChange.szAccessNumber[0] == '0' && aeChange.szAccessNumber[1] == '\0')
		{
			// This is a delete record, find matching record
			// NOTE: we only search the numbers that existed before the change file,
			// because they are the only ones that are sorted.
			pCurIdxLookUp = (LPIDXLOOKUPELEMENT)bsearch(&aeChange,rgIdxLookUp,(int)dwOriginalSize,
				sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);
			AssertSz(pCurIdxLookUp,"Attempting to delete a record that does not exist.  The change file and phone book versions do not match.");
			if (pCurIdxLookUp)
				pCurIdxLookUp->pAE = NULL;  //Create a dead entry in the look up table
			m_cPhoneBookEntries--;
		}
		else
		{
			// This is an add entry
			m_cPhoneBookEntries++;
			dwUsed++;
			// Make sure we have enough room
			if (m_cPhoneBookEntries > dwAllocated)
			{
				// Grow phone book
				dwAllocated += CHANGE_BUFFER_SIZE;
#ifdef WIN16
				Assert(m_rgPhoneBookEntry);
				rgTemp = GlobalReAlloc(m_rgPhoneBookEntry,(int)(sizeof(ACCESSENTRY)*dwAllocated),GHND);
				Assert(rgTemp);
				if (!rgTemp)
					goto MergeExit;
				m_rgPhoneBookEntry = (PACCESSENTRY)rgTemp;

				// Grow look up index
				Assert(rgIdxLookUp);
				rgTemp = GlobalReAlloc(rgIdxLookUp,(int)(sizeof(IDXLOOKUPELEMENT)*dwAllocated),GHND);
				Assert(rgTemp);
				if (!rgTemp)
					goto MergeExit;
				rgIdxLookUp = (LPIDXLOOKUPELEMENT)rgTemp;
#else
				Assert(m_hPhoneBookEntry);
				GlobalUnlock(m_hPhoneBookEntry);
				hTemp = (HANDLE)GlobalReAlloc(m_hPhoneBookEntry,sizeof(ACCESSENTRY)*dwAllocated,GHND);
				Assert(hTemp);
				if (!hTemp)
					goto MergeExit;
				m_hPhoneBookEntry = hTemp;
				m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
				Assert(m_rgPhoneBookEntry);
				if (!m_rgPhoneBookEntry)
					goto MergeExit;

				// Grow look up index
				Assert(hIdxLookUp);
				GlobalUnlock(hIdxLookUp);
				hTemp = (HANDLE)GlobalReAlloc(hIdxLookUp,sizeof(IDXLOOKUPELEMENT)*dwAllocated,GHND);
				Assert(hTemp);
				if (!hTemp)
					goto MergeExit;
				hIdxLookUp = hTemp;
				rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalLock(hIdxLookUp);
				Assert(rgIdxLookUp);
				if (!rgIdxLookUp)
					goto MergeExit;
#endif
			}

			//Add entry to the end of the phonebook and to end of look up index
			CopyMemory(&m_rgPhoneBookEntry[m_cPhoneBookEntries],&aeChange,sizeof(ACCESSENTRY));
			rgIdxLookUp[m_cPhoneBookEntries].dwIndex = m_rgPhoneBookEntry[m_cPhoneBookEntries].dwIndex;
			rgIdxLookUp[m_cPhoneBookEntries].pAE = &m_rgPhoneBookEntry[m_cPhoneBookEntries];
			// NOTE: because the entry is added to the end of the list, we can't add
			// and delete entries in the same change file.
		}
	} while (TRUE);

	// resort the IDXLookUp index to reflect the correct order of enteries
	// for the phonebook file, including all of the entries to be deleted.
	qsort(rgIdxLookUp,(int)dwUsed,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElementsFileOrder);

	// Build a new phonebook file
#ifdef WIN16
	GetTempFileName(0, TEMP_PHONE_BOOK_PREFIX, 0, szTempFileName);
#else
	if (!GetTempPath(TEMP_BUFFER_LENGTH,szTempBuffer))
		goto MergeExit;
	if (!GetTempFileName(szTempBuffer,TEMP_PHONE_BOOK_PREFIX,0,szTempFileName))
		goto MergeExit;
#endif
	hFile = CreateFile(szTempFileName,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
		FILE_FLAG_WRITE_THROUGH,0);
	if (hFile == INVALID_HANDLE_VALUE)
		goto MergeExit;

	for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
	{
		cch = wsprintf(szTempBuffer, "%lu,%lu,%lu,%s,%s,%s,%lu,%lu,%lu,%lu,%s\r\n",
			rgIdxLookUp[dwIdx].pAE->dwIndex,
			rgIdxLookUp[dwIdx].pAE->dwCountryID,
			DWORD(rgIdxLookUp[dwIdx].pAE->wStateID),
			rgIdxLookUp[dwIdx].pAE->szCity,
			rgIdxLookUp[dwIdx].pAE->szAreaCode,
			rgIdxLookUp[dwIdx].pAE->szAccessNumber,
			rgIdxLookUp[dwIdx].pAE->dwConnectSpeedMin,
			rgIdxLookUp[dwIdx].pAE->dwConnectSpeedMax,
			DWORD(rgIdxLookUp[dwIdx].pAE->bFlipFactor),
			DWORD(rgIdxLookUp[dwIdx].pAE->fType),
			rgIdxLookUp[dwIdx].pAE->szDataCenter);

		if (!WriteFile(hFile,szTempBuffer,cch,&cchWritten,NULL))
		{
			// something went wrong, get rid of the temporary file
			CloseHandle(hFile);
			DeleteFile(szTempFileName);
			hr = GetLastError();
			goto MergeExit;
		}

		Assert(cch == cchWritten);
	}
	CloseHandle(hFile);
	hFile = NULL;

	// Move new phone book over old
	if (!MoveFileEx(szTempFileName,m_szPhoneBook,MOVEFILE_REPLACE_EXISTING))
	{
		hr = GetLastError();
		goto MergeExit;
	}

	// discard the phonebook in memory
#ifndef WIN16
	Assert(m_hPhoneBookEntry);
	GlobalUnlock(m_hPhoneBookEntry);
#endif
	m_rgPhoneBookEntry = NULL;
	m_cPhoneBookEntries = 0;
	GlobalFree(m_pLineCountryList);
	GlobalFree(m_rgIDLookUp);
	GlobalFree(m_rgNameLookUp);
	GlobalFree(m_rgState);
	m_cStates = 0;

	lstrcpy(szTempBuffer,m_szINFCode);
	m_szINFFile[0] = '\0';
	m_szPhoneBook[0] = '\0';
	m_szINFCode[0] = '\0';

	//  Reload it (and rebuild look up arrays)
	hr = Init(szTempBuffer);

MergeExit:
	if (hr != ERROR_SUCCESS)
	{
		GlobalFree(rgIdxLookUp);
		if (pcCSVFile) delete pcCSVFile;
		CloseHandle(hFile);
	}
	return hr;
}

// ############################################################################
HRESULT CPhoneBook::ReadOneLine(PACCESSENTRY lpAccessEntry, CCSVFile far *pcCSVFile)
{
	HRESULT hr = ERROR_SUCCESS;

#if !defined(WIN16)
ReadOneLineStart:
#endif //WIN16
	if (!ReadPhoneBookDW(&lpAccessEntry->dwIndex,pcCSVFile))
	{
		hr = ERROR_NO_MORE_ITEMS; // no more enteries
		goto ReadExit;
	}
	ReadVerifyPhoneBookDW(lpAccessEntry->dwCountryID);
	ReadVerifyPhoneBookW(lpAccessEntry->wStateID);
	ReadVerifyPhoneBookSZ(lpAccessEntry->szCity,cbCity);
	ReadVerifyPhoneBookSZ(lpAccessEntry->szAreaCode,cbAreaCode);
	// NOTE: 0 is a valid area code and ,, is a valid entry for an area code
	if (!FSz2Dw(lpAccessEntry->szAreaCode,&lpAccessEntry->dwAreaCode))
		lpAccessEntry->dwAreaCode = NO_AREA_CODE;
	ReadVerifyPhoneBookSZ(lpAccessEntry->szAccessNumber,cbAccessNumber);
	ReadVerifyPhoneBookDW(lpAccessEntry->dwConnectSpeedMin);
	ReadVerifyPhoneBookDW(lpAccessEntry->dwConnectSpeedMax);
	ReadVerifyPhoneBookB(lpAccessEntry->bFlipFactor);
	ReadVerifyPhoneBookDW(lpAccessEntry->fType);
	ReadVerifyPhoneBookSZ(lpAccessEntry->szDataCenter,cbDataCenter);
#if !defined(WIN16)
	//
	// If scripting is not available and the phonebook entry has a dun file other than
	// icwip.dun, then ignore the entry and read the one after that.
	//
	if (!m_bScriptingAvailable)
	{
		if (0 != lstrcmpi(lpAccessEntry->szDataCenter,"icwip.dun"))
		{
			ZeroMemory(lpAccessEntry,sizeof(ACCESSENTRY));
			goto ReadOneLineStart;
		}
	}
#endif //WIN16

ReadExit:
	return hr;
ReadError:
	hr = ERROR_INVALID_DATA;
	goto ReadExit;
}

// ############################################################################
HRESULT CPhoneBook::Suggest(PSUGGESTINFO pSuggest)
{
	WORD		wNumFound = 0;
	HRESULT		hr = ERROR_NOT_ENOUGH_MEMORY;

	// Validate parameters
	Assert(pSuggest);
	Assert(pSuggest->wNumber);

	if (wNumFound == pSuggest->wNumber)
		goto SuggestExit;

	LPIDLOOKUPELEMENT pCurLookUp;
	PACCESSENTRY lpAccessEntry;
	
	//REVIEW: double check this
	pCurLookUp = (LPIDLOOKUPELEMENT)bsearch(&pSuggest->dwCountryID,m_rgIDLookUp,
		(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
		CompareIDLookUpElements);

	// Check for invalid country
	if (!pCurLookUp)
		goto SuggestExit;

	// Check if there are any phone numbers for this country
	if (!pCurLookUp->pFirstAE) goto SuggestExit;

	lpAccessEntry = pCurLookUp->pFirstAE;
	do {
		// check for the right area code
		if (lpAccessEntry->dwAreaCode == pSuggest->wAreaCode)
		{
			// check for the right type of number
			if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType)
			{
				pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
				wNumFound++;
			}
		}
		lpAccessEntry++;
	} while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) &&
		(wNumFound < pSuggest->wNumber) &&
		(lpAccessEntry->dwCountryID == pSuggest->dwCountryID));

	// if we couldn't find enough numnbers, try something else
	// 10/15/96  jmazner  ported fixes below from core\client\phbk
	// Do this only if area code is not 0 - Bug #9349 (VetriV)
	// 	if ((pSuggest->wAreaCode != 0) && (wNumFound < pSuggest->wNumber))
	// No, there are some places (Finland?  ChrisK knows) where 0 is a legit area code -- jmazner

	if (wNumFound < pSuggest->wNumber)
	{
		lpAccessEntry = pCurLookUp->pFirstAE;
	
		// Note: we are now only looking for Nationwide phone numbers (state = 0)

		// 8/13/96 jmazner MOS Normandy #4597
		// We want nationwide toll-free numbers to display last, so for this pass,
		// only consider numbers that are _not_ toll free  (fType bit #1 = 0)
		
		// Tweak pSuggest->bMask to let through the toll/charge bit
		pSuggest->bMask |= MASK_TOLLFREE_BIT;

		// Tweak pSuggest->ftype to be charge
		pSuggest->fType &= TYPE_SET_TOLL;

		do {

			// 8/13/96 jmazner MOS Normandy #4598
			// If this entry's area code matches pSuggest->wAreaCode, then we already
			// have included it in the previous pass, so don't duplicate it again here.
			if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType &&
				 lpAccessEntry->wStateID == 0 &&
				 lpAccessEntry->dwAreaCode != pSuggest->wAreaCode)
			{
				pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
				wNumFound++;
			}
			lpAccessEntry++;
		} while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) &&
			(wNumFound < pSuggest->wNumber) &&
			(lpAccessEntry->dwCountryID == pSuggest->dwCountryID) &&
			(lpAccessEntry->wStateID == 0) );
	}


	// 8/13/96 jmazner MOS Normandy #4597
	// if we STILL couldn't find enough numnbers, widen the search to include tollfree #s

	if (wNumFound < pSuggest->wNumber)
	{
		lpAccessEntry = pCurLookUp->pFirstAE;
		
		// Tweak pSuggest->bMask to let through the toll/charge bit
		// REDUNDANT? If we made it to this point, we _should_ have done this above...
		// Better safe than sorry!
		Assert(pSuggest->bMask & MASK_TOLLFREE_BIT);
		pSuggest->bMask |= MASK_TOLLFREE_BIT;

		// Tweak pSuggest->ftype to be tollfree
		pSuggest->fType |= TYPE_SET_TOLLFREE;

		do {

			// 8/13/96 jmazner MOS Normandy #4598
			// If this entry's area code matches pSuggest->wAreaCode, then we already
			// have included it in the first pass, so don't include it here.
			// Any entry that made it in in the 2nd pass will definitely not make it in here
			// (because of tollfree bit), so no need to worry about dups from there.
			if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType &&
		      lpAccessEntry->wStateID == 0 &&
			  lpAccessEntry->dwAreaCode != pSuggest->wAreaCode)
			{
				pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
				wNumFound++;
			}
			lpAccessEntry++;
		} while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) &&
			(wNumFound < pSuggest->wNumber) &&
			(lpAccessEntry->dwCountryID == pSuggest->dwCountryID) &&
			(lpAccessEntry->wStateID == 0) );
	}
	hr = ERROR_SUCCESS;
SuggestExit:
	pSuggest->wNumber = wNumFound;
	return hr;
}

// ############################################################################
HRESULT CPhoneBook::GetCanonical (PACCESSENTRY pAE, LPSTR psOut)
{
	HRESULT hr = ERROR_SUCCESS;
	LPIDLOOKUPELEMENT pIDLookUp;

	pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&pAE->dwCountryID,m_rgIDLookUp,
		(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);

	if (!pIDLookUp)
	{
		hr = ERROR_INVALID_PARAMETER;
	} else {
		SzCanonicalFromAE (psOut, pAE, pIDLookUp->pLCE);
	}

	return hr;
}

// ############################################################################
DllExportH PhoneBookLoad(LPCSTR pszISPCode, DWORD_PTR far *pdwPhoneID)
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	CPhoneBook far *pcPhoneBook;

	if (!g_hInstDll)
		g_hInstDll = GetModuleHandle(NULL);

	// validate parameters
	Assert(pszISPCode && *pszISPCode && pdwPhoneID);
	*pdwPhoneID = NULL;

	// allocate phone book
	pcPhoneBook = new CPhoneBook;

	// initialize phone book
	if (pcPhoneBook)
		hr = pcPhoneBook->Init(pszISPCode);

	// in case of failure
	if (hr && pcPhoneBook)
	{
		delete pcPhoneBook;
	} else {
		*pdwPhoneID = (DWORD_PTR)pcPhoneBook;
	}

#if defined(WIN16)
	if (!hr)
		BMP_RegisterClass(g_hInstDll);
#endif	

	return hr;
}

// ############################################################################
DllExportH PhoneBookUnload(DWORD_PTR dwPhoneID)
{
	Assert(dwPhoneID);

	if (dwPhoneID)
	{
#if defined(WIN16)
		BMP_DestroyClass(g_hInstDll);
#endif
		// Release contents
		delete (CPhoneBook far*)dwPhoneID;
	}

	return ERROR_SUCCESS;
}

// ############################################################################
DllExportH PhoneBookMergeChanges(DWORD_PTR dwPhoneID, LPCSTR pszChangeFile)
{
	return ((CPhoneBook far*)dwPhoneID)->Merge(pszChangeFile);
}

// ############################################################################
DllExportH PhoneBookSuggestNumbers(DWORD_PTR dwPhoneID, PSUGGESTINFO lpSuggestInfo)
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;

	// get suggested numbers
	lpSuggestInfo->rgpAccessEntry = (PACCESSENTRY *)GlobalAlloc(GPTR,sizeof(PACCESSENTRY) * lpSuggestInfo->wNumber);
	if (lpSuggestInfo->rgpAccessEntry)
	{
		hr = ((CPhoneBook far *)dwPhoneID)->Suggest(lpSuggestInfo);
	}

	return hr;
}

// ############################################################################
DllExportH PhoneBookGetCanonical (DWORD_PTR dwPhoneID, PACCESSENTRY pAE, LPSTR psOut)
{
	return ((CPhoneBook far*)dwPhoneID)->GetCanonical(pAE,psOut);
}

// ############################################################################
DllExportH PhoneBookDisplaySignUpNumbers (DWORD_PTR dwPhoneID,
														LPSTR far *ppszPhoneNumbers,
														LPSTR far *ppszDunFiles,
														WORD far *pwPhoneNumbers,
														DWORD far *pdwCountry,
														WORD far *pwRegion,
														BYTE fType,
														BYTE bMask,
														HWND hwndParent,
														DWORD dwFlags)
{
	INT_PTR hr;
	AssertSz(ppszPhoneNumbers && pwPhoneNumbers && pdwCountry &&pwRegion,"invalid parameters");


	//CAccessNumDlg *pcDlg;
	CSelectNumDlg far *pcDlg;
	pcDlg = new CSelectNumDlg;
	if (!pcDlg)
	{
		hr = GetLastError();
		goto DisplayExit;
	}

	// Initialize information for dialog
	//

	pcDlg->m_dwPhoneBook = dwPhoneID;
	pcDlg->m_dwCountryID = *pdwCountry;
	pcDlg->m_wRegion = *pwRegion;
	pcDlg->m_fType = fType;
	pcDlg->m_bMask = bMask;
	pcDlg->m_dwFlags = dwFlags;

	// invoke the dialog
	//
	
	// BUG: NOT THREAD SAFE!!
	g_hWndMain = hwndParent;
	hr = DialogBoxParam(g_hInstDll,MAKEINTRESOURCE(IDD_SELECTNUMBER),
							g_hWndMain,PhbkGenericDlgProc,(LPARAM)pcDlg);
	g_hWndMain = NULL;

	if (hr == IDC_CMDNEXT)
	{
		*pwRegion = pcDlg->m_wRegion;
		*pdwCountry = pcDlg->m_dwCountryID;

		Assert (ppszPhoneNumbers[0] && ppszDunFiles[0]);
		lstrcpy(ppszPhoneNumbers[0],&pcDlg->m_szPhoneNumber[0]);
		lstrcpy(ppszDunFiles[0],&pcDlg->m_szDunFile[0]);

		hr = ERROR_SUCCESS;
	}
	else if (hr == IDC_CMDBACK)
		hr = ERROR_USERBACK;
	else
		hr = ERROR_USERCANCEL;

	//	hr == -1;
DisplayExit:
	if (pcDlg) delete pcDlg;

	return (HRESULT) hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\rnaapi.cpp ===
//-----------------------------------------------------------------------------
// RNAAPI class
// 
// This class provides a series of cover function for the RNAPH/RASAPI32 dlls
//
// Created 1-29-96	ChrisK

// ############################################################################
// INCLUDES
#include "pch.hpp"
//#include "ras.h"
#include <ras.h>
#pragma pack (4)
//#if !defined(WIN16)
//#include <rnaph.h>
//#endif
#pragma pack ()
#include "rnaapi.h"
#include "debug.h"

// ############################################################################
// RNAAPI class 
CRNAAPI::CRNAAPI()
{
	m_hInst = LoadLibrary("RASAPI32.DLL");
	m_hInst2 = LoadLibrary("RNAPH.DLL");

	m_fnRasEnumDeviecs = NULL;
	m_fnRasValidateEntryName = NULL;
	m_fnRasSetEntryProperties = NULL;
	m_fnRasGetEntryProperties = NULL;
}

// ############################################################################
CRNAAPI::~CRNAAPI()
{
	// Clean up
	if (m_hInst) FreeLibrary(m_hInst);
	if (m_hInst2) FreeLibrary(m_hInst2);
}

// ############################################################################
DWORD CRNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
							 LPDWORD lpcDevices)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasEnumDevices",(FARPROC*)&m_fnRasEnumDeviecs);

	if (m_fnRasEnumDeviecs)
		dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

	return dwRet;
}

// ############################################################################
BOOL CRNAAPI::LoadApi(LPSTR pszFName, FARPROC* pfnProc)
{
	if (*pfnProc == NULL)
	{
		// Look for the entry point in the first DLL
		if (m_hInst)
			*pfnProc = GetProcAddress(m_hInst,pszFName);
		
		// if that fails, look for the entry point in the second DLL
		if (m_hInst2 && !(*pfnProc))
			*pfnProc = GetProcAddress(m_hInst2,pszFName);
	}

	return (pfnProc != NULL);
}

// ############################################################################
DWORD CRNAAPI::RasValidateEntryName(LPSTR lpszPhonebook,LPSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasValidateEntryName",(FARPROC*)&m_fnRasValidateEntryName);

	if (m_fnRasValidateEntryName)
		dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

	return dwRet;
}

// ############################################################################
DWORD CRNAAPI::RasSetEntryProperties(LPSTR lpszPhonebook, LPSTR lpszEntry,
									LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
									LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasSetEntryProperties",(FARPROC*)&m_fnRasSetEntryProperties);

	if (m_fnRasSetEntryProperties)
		dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, dwEntryInfoSize,
									lpbDeviceInfo, dwDeviceInfoSize);

	return dwRet;
}

// ############################################################################
DWORD CRNAAPI::RasGetEntryProperties(LPSTR lpszPhonebook, LPSTR lpszEntry,
									LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
									LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasGetEntryProperties",(FARPROC*)&m_fnRasGetEntryProperties);

	if (m_fnRasGetEntryProperties)
		dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, lpdwEntryInfoSize,
									lpbDeviceInfo, lpdwDeviceInfoSize);

	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\phbkrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by phbk.rc
//
#define IDS_950NUMBER                   1
#define IDS_WANTTOEXIT                  2
#define IDS_TITLE                       3
#define IDS_NOTENOUGHMEMORY             4
#define IDS_NATIONWIDE                  5
#define IDS_INVALIDPHONE                6
#define IDS_OK                          7
#define IDD_ACCESSNUMBERS               101
#define IDD_SELECTNUMBER                102
#define IDB_WORLD                       106
#define IDB_PHONE                       107
#define IDC_CMDHELP                     1000
#define IDC_TXTPRIMARY                  1001
#define IDC_TXTSECONDARY                1002
#define IDC_CMDCHANGEPRIMARY            1003
#define IDC_CMDCHANGESECONDARY          1004
#define IDC_CMDEXIT                     1005
#define IDC_CMDOK                       1006
#define IDC_CMBCOUNTRY                  1007
#define IDC_CMBREGION                   1008
#define IDC_LSTNUMBER                   1009
#define IDC_CMDCANCEL                   IDCANCEL
#define IDC_CMBNUMBER                   1011
#define IDC_CMDNEXT                     1012
#define IDC_CMDBACK                     1013
#define IDC_LBLTITLE                    1014
#define IDC_LBLAUTODIAL                 1015
#define IDC_LBLSIGNUP                   1016
#define IDC_LBLDIALERR                  1017
#define IDC_LBLCOUNTRY                  1018
#define IDC_LBLSTATEMSG						 1019
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\rnaapi.h ===
//-----------------------------------------------------------------------------
// RNAAPI class
//
// This class provides a series of cover function for the RNAPH/RASAPI32 dlls
//
// Created 1-29-96	ChrisK

//-----------------------------------------------------------------------------
// TYPEDEF
typedef DWORD (WINAPI* PFNRASENUMDEVICES)(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef DWORD (WINAPI* PFNRASVALIDATEENTRYNAE)(LPSTR lpszPhonebook, LPSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPSTR lpszPhonebook, LPSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASGETENTRYPROPERTIES)(LPSTR lpszPhonebook, LPSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);

//-----------------------------------------------------------------------------
// CLASS
// ############################################################################
class CRNAAPI
{
public:
	void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
	void operator delete( void far * p ) {GlobalFree(p); };

	CRNAAPI();
	~CRNAAPI();

	DWORD RasEnumDevices(LPRASDEVINFO, LPDWORD, LPDWORD);
	DWORD RasValidateEntryName(LPSTR,LPSTR);
	DWORD RasSetEntryProperties(LPSTR lpszPhonebook, LPSTR lpszEntry,
								LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
								LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
	DWORD RasGetEntryProperties(LPSTR lpszPhonebook, LPSTR lpszEntry,
								LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
								LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);


private:
	BOOL LoadApi(LPSTR, FARPROC*);

	HINSTANCE m_hInst;
	HINSTANCE m_hInst2;

	PFNRASENUMDEVICES m_fnRasEnumDeviecs;
	PFNRASVALIDATEENTRYNAE m_fnRasValidateEntryName;
	PFNRASSETENTRYPROPERTIES m_fnRasSetEntryProperties;
	PFNRASGETENTRYPROPERTIES m_fnRasGetEntryProperties;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\addrdlg.cpp ===
/*********************************************************************
Registration Wizard

AddressDialog.cpp
10/19/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <regpage.h>

#include <Winnt.h>
#include <stdio.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "cstattxt.h"
#include "cbitmap.h"
#include "cntryinf.h"
#include <rw_common.h>


static PROPSHEETPAGE  *spAddrSheet=NULL;
void ConfigureAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
void SetRegWizardCountryCode(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateAddrDialog(CRegWizard* pclRegWizard,HWND hwndDlg);
int ValidateAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
//static int vDeclineOffers = -1;
///////////////////////////////
//#define CREATE_TAB_ORDER_FILE
///////////////////////////////

#ifdef CREATE_TAB_ORDER_FILE
void CreateAddrDlgTabOrderString(HWND hwndDlg);
BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam);
#endif
INT_PTR CALLBACK AddressDialogProc(HWND hwndDlg, 
					UINT uMsg, 
					WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the 
user's address,phone, etc.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
	_TCHAR szTemp[256];
    INT_PTR bStatus;
	static int iXY = 0;
	HWND hWnd;
//	TriState shouldInclude;
	
	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}
	
	
    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;	
        case WM_INITDIALOG:
		{	
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
						
	
		
			HWND hwndAddrField = GetDlgItem(hwndDlg,IDC_EDIT1);
			SetFocus(hwndAddrField);
			
			//NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT5);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT6);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT7);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT8);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT9);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT10);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT12);
		
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			
			BOOL boughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
			int stringID1 = boughtByCompany ? IDS_ADDRDLG_TEXT1B : IDS_ADDRDLG_TEXT1A;
			int stringID2 = boughtByCompany ? IDS_ADDRDLG_TEXT2B : IDS_ADDRDLG_TEXT2A;
			LoadString(pi->hInstance,stringID1,szTemp,256);
			HWND hWnd = GetDlgItem(hwndDlg,IDT_TEXT1);
			SetWindowText(hWnd,szTemp);

			LoadString(pi->hInstance,stringID2,szTemp,256);
			hWnd = GetDlgItem(hwndDlg,IDT_TEXT2);
			SetWindowText(hWnd,szTemp);

			//new CStaticText(pclRegWizard->GetInstance(),hwndDlg,IDT_TEXT1,stringID1,NULL);
			//new CStaticText(pclRegWizard->GetInstance(),hwndDlg,IDT_TEXT2,stringID2,NULL);
			if (pclRegWizard->GetInformationString(kInfoMailingAddress,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
			}
/*			if (pclRegWizard->GetInformationString(kInfoAdditionalAddress,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
			}*/
			if (pclRegWizard->GetInformationString(kInfoCity,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoState,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoZip,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoPhoneNumber,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT6,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoPhoneExt,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT8,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			if (pclRegWizard->GetInformationString(kAreaCode,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_AREACODE,WM_SETTEXT,0,(LPARAM) szInfo);
			}

		
			pclRegWizard->ResolveCurrentCountryCode();

			gTapiCountryTable.FillCountryList(pclRegWizard->GetInstance(), 
				GetDlgItem(hwndDlg,IDC_COMBO1)	);
			PTSTR psz = gTapiCountryTable.GetCountryName ( pclRegWizard->GetCountryCode());
			SendMessage(GetDlgItem(hwndDlg,IDC_COMBO1),
			CB_SELECTSTRING, (WPARAM) -1,(LPARAM) psz); //select this country
			if (pclRegWizard->GetInformationString(kInfoCountry,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_SELECTSTRING,(WPARAM) -1,(LPARAM) szInfo);
			}
			ConfigureAddrEditFields(pclRegWizard,hwndDlg);

			#ifdef CREATE_TAB_ORDER_FILE
			CreateAddrDlgTabOrderString(hwndDlg);
			FResSetDialogTabOrder(hwndDlg,IDS_TAB_ADDRESS);
			#endif

//			vDialogInitialized = TRUE;
            return TRUE;
		} // WM_INIT
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
                pi->iCancelledByUser = RWZ_PAGE_OK;

				{
						BOOL boughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
						int stringID1 = boughtByCompany ? IDS_ADDRDLG_TEXT1B : IDS_ADDRDLG_TEXT1A;
						int stringID2 = boughtByCompany ? IDS_ADDRDLG_TEXT2B : IDS_ADDRDLG_TEXT2A;
						LoadString(pi->hInstance,stringID1,szTemp,256);
						HWND hWnd = GetDlgItem(hwndDlg,IDT_TEXT1);
						SetWindowText(hWnd,szTemp);
						LoadString(pi->hInstance,stringID2,szTemp,256);
						hWnd = GetDlgItem(hwndDlg,IDT_TEXT2);
						SetWindowText(hWnd,szTemp);
				}
						

				//if(spAddrSheet) {
				//	spAddrSheet->pszHeaderTitle = MAKEINTRESOURCE(IDS_WELCOME_SCR_TITLE);
				//}

				//  Third Party  info related code 
/*					shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
					if (shouldInclude == kTriStateTrue ){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						vDeclineOffers = 1;
					}
					else if (shouldInclude == kTriStateFalse){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						vDeclineOffers = 0;
					}else if (shouldInclude == kTriStateUndefined){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
						vDeclineOffers = -1;
					}
					// Enable for previpously entred value in screen
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
*/
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;
            case PSN_WIZNEXT:
				iRet=0;
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					if( ValidateAddrDialog(pclRegWizard,hwndDlg)) {
						ConfigureAddrEditFields(pclRegWizard,hwndDlg);
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoMailingAddress,szInfo);
					/*	SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoAdditionalAddress,szInfo);*/
						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCity,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoState,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoZip,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT6,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoPhoneNumber,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT8,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoPhoneExt,szInfo);
						LRESULT selIndex = SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETCURSEL,0,0L);
						SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETLBTEXT,selIndex,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCountry,szInfo);

						// Get Area Code 
						SendDlgItemMessage(hwndDlg,IDC_AREACODE,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kAreaCode,szInfo);
						SetRegWizardCountryCode(pclRegWizard,hwndDlg);
						// 3 rd Party Acceptance
/*						if(vDeclineOffers == -1){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateUndefined);
						}
						else
						if(vDeclineOffers == 0){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateFalse);
						}
						else{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateTrue);
						}
						_stprintf(szInfo,_T("%i"),vDeclineOffers);
						RW_DEBUG << "\n Address Screen Decline Offers " << szInfo << "\n" << flush;
						pclRegWizard->SetInformationString(kInfoDeclinesNonMSProducts,szInfo);
*/						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						pi->CurrentPage++;
					
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet); 
				}
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kAddressDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
		{
			if (HIWORD(wParam) == CBN_KILLFOCUS){
				ConfigureAddrEditFields(pclRegWizard,hwndDlg);
			}
/*			case IDC_RADIO2:
			  case IDC_RADIO1:
				if (vDialogInitialized){
					// If the 'No' button is checked, the user is declining
					// the "Non-Microsoft product" offers
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						vDeclineOffers = 1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						vDeclineOffers = 0;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else{
						vDeclineOffers = -1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
					}

				}
				
*/

		} // WM_COMMAND
		break;
	    default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}



BOOL ValidateAddrDialog(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Address
dialog.  If any required edit field input is empty, ValidateAddrDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateAddrEditFields(pclRegWizard,hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szLabel[128];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szLabel,128);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szLabel,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndAddrField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndAddrField);
		return FALSE;
	}
}


int ValidateAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
ValidateAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the first empty
edit field control will be returned as the function result.  If all 
fields are OK, NULL will be returned.
**********************************************************************/
{
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1; 
//	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2; 
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3; 
	if(pclRegWizard->GetCountryCode() == 0)
	{
		if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT4)) 
			return IDC_EDIT4; 
	}
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT5)) return IDC_EDIT5; 
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT6)) return IDC_EDIT6;
//	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT7)) return IDC_EDIT7;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT8)) return IDC_EDIT8;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_AREACODE)) return IDC_AREACODE;


	return NULL; 
}


void ConfigureAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	SetRegWizardCountryCode(pclRegWizard,hwndDlg);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecAddress,IDT_TEXT2);
//	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecAddress2,IDT_TEXT4);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecCity,IDT_TEXT5);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT4,kAddrSpecState,IDT_TEXT6);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT5,kAddrSpecPostalCode,IDT_TEXT7);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT6,kAddrSpecPhone,IDT_TEXT8);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT8,kAddrSpecExtension,IDT_TEXT9);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_AREACODE,kAddrSpecAreaCode,IDT_AREACODE);
}


void SetRegWizardCountryCode(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
This function determines the country code of the currently selected 
country in the Address dialog combo box, and sends it to the given
CRegWizard object.
**********************************************************************/
{
	_TCHAR szInfo[256];
	LRESULT selIndex = SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETCURSEL,0,0L);
	if (selIndex != CB_ERR)
	{
		SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETLBTEXT,selIndex,(LPARAM) szInfo);
		#ifdef SURESH
		DWORD dwCountryCode;
		if (CountryCodeFromSzCountryCode(pclRegWizard->GetInstance(),szInfo,&dwCountryCode))
		{
			pclRegWizard->SetCountryCode(dwCountryCode);
		}
		#endif 
		pclRegWizard->SetCountryCode(
		gTapiCountryTable.GetCountryCode(szInfo));

	}
}

#ifdef CREATE_TAB_ORDER_FILE
void CreateAddrDlgTabOrderString(HWND hwndDlg)
/*********************************************************************
Creates a comma delimited list of ID's for all controls belonging to
the given dialog, and writes the list to a text file.
**********************************************************************/
{
	HANDLE hFile = CreateFile(_T"c:\\ADDRTAB.TXT",GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		EnumChildWindows(hwndDlg,EnumChildProc,(LPARAM) hFile);
		CloseHandle(hFile);
	}
}
#endif


#ifdef CREATE_TAB_ORDER_FILE
BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	_TCHAR rgch[128];
	int iCtrlId = GetDlgCtrlID(hwndChild);
	LPTSTR sz = GetFocus() == hwndChild ? _T"F" : _T"";
	wsprintf(rgch,_T"%i%s,",iCtrlId,sz);

	HANDLE hFile = (HANDLE) lParam;
	DWORD dwBytesWritten;
	WriteFile(hFile,rgch,_tcslen(rgch) * sizeof(_TCHAR),&dwBytesWritten,NULL);
	return TRUE;
}
#endif

//
//  This function is calles during the creation and deletion of
//  Address Property Sheet 
//  Store the Address of PPROPSHEETPAGE so the Subtitle can be changed
//
//
//
UINT CALLBACK AddressPropSheetPageProc(HWND hwnd, 
								UINT uMsg, 
								LPPROPSHEETPAGE ppsp 
								) 
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
		spAddrSheet = ppsp;
	default:
		break;

	}
	return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\suapi.h ===
// ############################################################################
//#include "ras.h"
#define cbDataCenter (MAX_PATH+1)	// max length of data center string

// ############################################################################
class CDialog
{
public:
	void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
	void operator delete( void far * p ) {GlobalFree(p); };

	CDialog() {};
	~CDialog() {};
	virtual INT_PTR DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT)=0;
};

// ############################################################################
class CSelectNumDlg : public CDialog
{
public:
	CSelectNumDlg();
	INT_PTR DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
	DWORD m_dwCountryID;
	DWORD m_dwCountryIDOrg;
	WORD m_wRegion;
	DWORD_PTR m_dwPhoneBook;
	char m_szPhoneNumber[RAS_MaxPhoneNumber+1];
	char m_szDunFile[cbDataCenter];
	BYTE m_fType;
	BYTE m_bMask;
	DWORD m_dwFlags;
private:
	BOOL FHasPhoneNumbers(LPLINECOUNTRYENTRY pLCE);
	BOOL m_fHasRegions;
	HWND m_hwndDlg;
	HRESULT FillRegion();
	HRESULT FillNumber();
};

// ############################################################################
/********** 1/9/96 jmazner Normandy #13185
class CAccessNumDlg : public CDialog
{
public:
	CAccessNumDlg();
	~CAccessNumDlg() {};
	INT_PTR			DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
	DWORD			m_dwPhoneBook;
	PACCESSENTRY	*m_rgAccessEntry;
	WORD			m_wNumber;
	DWORD			m_dwCountryID;
	WORD			m_wRegion;
	BYTE			m_fType;
	BYTE			m_bMask;
	char	m_szPrimary[RAS_MaxPhoneNumber];
	char	m_szSecondary[RAS_MaxPhoneNumber];
	char	m_szDunPrimary[cbDataCenter + sizeof('\0')];
	char	m_szDunSecondary[cbDataCenter + sizeof('\0')];
};	
**************/

// ############################################################################
#ifdef WIN16
extern "C" INT_PTR CALLBACK __export PhbkGenericDlgProc(
#else
extern "C" __declspec(dllexport) INT_PTR CALLBACK PhbkGenericDlgProc(
#endif
    HWND  hwndDlg,	// handle to dialog box
    UINT  uMsg,	// message
    WPARAM  wParam,	// first message parameter
    LPARAM  lParam 	// second message parameter
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\phbooklib\suapi.cpp ===
// ############################################################################
#include "pch.hpp" 
#include "phbk.h"
#include "debug.h"
#include "phbkrc.h"
#include "misc.h"
//#include "ras.h"
#include <ras.h>
#pragma pack (4)
//#if !defined(WIN16)
//#include <rnaph.h>
//#endif
#pragma pack ()
#include "suapi.h"

#define ERROR_USER_EXIT 0x8b0bffff
#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)

#define NOTIFY_CODE (HIWORD(wParam))

#define WM_SHOWSTATEMSG WM_USER+1

char szTemp[100];

char szValidPhoneCharacters[] = {"0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0"};

// ############################################################################
BOOL CSelectNumDlg::FHasPhoneNumbers(LPLINECOUNTRYENTRY pLCE)
{
	LPIDLOOKUPELEMENT pIDLookUp;
	IDLOOKUPELEMENT LookUpTarget;
	CPhoneBook far *pcPBTemp;
	PACCESSENTRY pAE = NULL, pAELast = NULL;
	DWORD dwCountryID;

	pcPBTemp = ((CPhoneBook far*)m_dwPhoneBook);

	LookUpTarget.dwID = pLCE->dwCountryID;

	pIDLookUp = NULL;
	pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&LookUpTarget,pcPBTemp->m_rgIDLookUp,
		(int)pcPBTemp->m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);

	if (!pIDLookUp) return FALSE; // no such country

	pAE = pIDLookUp->pFirstAE;
	if (!pAE) return FALSE; // no phone numbers at all

	dwCountryID = pAE->dwCountryID;

	pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
	while (pAELast > pAE && 
		   pAE->dwCountryID == dwCountryID)
	{
		if ((pAE->fType & m_bMask) == m_fType) return TRUE;
		pAE++;
	}
	return FALSE; // no phone numbers of the right type

//	return ((BOOL)(pIDLookUp->pFirstAE));
}

// ############################################################################
INT_PTR CSelectNumDlg::DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT lResult)
{
	LRESULT lRet = TRUE;
	unsigned int idx;
	int iCurIndex;
	int iLastIndex;
	PACCESSENTRY pAE = NULL;
	LPSTR p, p2;

	switch (uMsg)
	{
	case WM_INITDIALOG:
		CPhoneBook far *pcPBTemp;
		pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
		m_hwndDlg = hwndDlg;

		// figure out if we are in the middle of an AUTODIAL
		//

		if (m_dwFlags & AUTODIAL_IN_PROGRESS)
		{
			EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDBACK),FALSE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSIGNUP),SW_HIDE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLDIALERR),SW_HIDE);
		} else if (m_dwFlags& DIALERR_IN_PROGRESS){
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSIGNUP),SW_HIDE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLAUTODIAL),SW_HIDE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_CMDBACK),SW_HIDE);
			SetDlgItemText(m_hwndDlg,IDC_CMDNEXT,GetSz(IDS_OK));
		}else {
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLAUTODIAL),SW_HIDE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLDIALERR),SW_HIDE);
		}

		// Fill in country list and select current country
		//

		iCurIndex = -1;		// 0xFFFFFFFF
		// NOTE: it might be nice for INTL testing purposes to fill this combo box with
		// a list sorted by the country ID instead of the country name.
		for (idx=0;idx<pcPBTemp->m_pLineCountryList->dwNumCountries;idx++)
		{
			if (FHasPhoneNumbers(pcPBTemp->m_rgNameLookUp[idx].pLCE))
			{
				wsprintf(szTemp,"%s (%ld)",
							pcPBTemp->m_rgNameLookUp[idx].psCountryName,
							pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID);
				iLastIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,
														CB_ADDSTRING,0,
														(LPARAM)((LPSTR) &szTemp[0]));
				SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETITEMDATA,
									(WPARAM)iLastIndex,
									(LPARAM)pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID);
				if (pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID == m_dwCountryID)
				{
					iCurIndex = iLastIndex;
				}
			}
		}

		if (iCurIndex != -1)	// 0xFFFFFFFF
		{
			SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETCURSEL,(WPARAM)iCurIndex,0);
		} else {
			SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETCURSEL,0,0);
			iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETITEMDATA,0,0);
			if (iCurIndex != CB_ERR) m_dwCountryID = iCurIndex;
		}

		// Copy country to label
		//
		if (GetDlgItemText(m_hwndDlg,IDC_CMBCOUNTRY,szTemp,100))
		{
			SetDlgItemText(m_hwndDlg,IDC_LBLCOUNTRY,szTemp);
		}

		// Initialize Last Selection Method
		//

		m_dwFlags &= (~FREETEXT_SELECTION_METHOD);
		m_dwFlags |= PHONELIST_SELECTION_METHOD;

		// Fill in region list and select current region
		//
		FillRegion();

		// Fill in phone numbers
		//
		FillNumber();

		SetFocus(GetDlgItem(m_hwndDlg,IDC_CMBCOUNTRY));
		lRet = FALSE;
		break;
	case WM_SHOWSTATEMSG:
		if (wParam)
		{
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSTATEMSG),SW_SHOW);
		} else {
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSTATEMSG),SW_HIDE);
		}
		break;
		// 1/9/96 jmazner  added for Normandy #13185
	case WM_CLOSE:
		if ((m_dwFlags & (AUTODIAL_IN_PROGRESS|DIALERR_IN_PROGRESS)) == 0) 
		{
			if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
				MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
				EndDialog(hwndDlg,IDC_CMDCANCEL);
		} else {
			EndDialog(hwndDlg,IDC_CMDCANCEL);
		}
		break;
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
			case IDC_CMBCOUNTRY:
				if (NOTIFY_CODE == CBN_SELCHANGE)
				{
					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETCURSEL,0,0);
					if (iCurIndex == CB_ERR) break;

					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
					if (iCurIndex == CB_ERR) break;
					m_dwCountryID = iCurIndex;  //REVIEW: data type????

					FillRegion();
					m_wRegion = 0;

					FillNumber();
				}
				break;
			case IDC_CMBREGION:
				if (NOTIFY_CODE == CBN_SELCHANGE)
				{
					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_GETCURSEL,0,0);
					if (iCurIndex == CB_ERR) break;

					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
					if (iCurIndex == CB_ERR) break;
					m_wRegion = (WORD) iCurIndex; //REVIEW: data type???

					FillNumber();
				}
				break;
			case IDC_CMBNUMBER:
				if ((NOTIFY_CODE == CBN_SELCHANGE) || (NOTIFY_CODE == CBN_DROPDOWN))
				{
					//iCurIndex = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETCURSEL,0,0);
					//if (iCurIndex == CB_ERR) break;

					EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);

					//iCurIndex = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
					//if (iCurIndex == CB_ERR) break;
					//if (!lstrcpy(&m_szDunFile[0],&((PACCESSENTRY)iCurIndex)->szDataCenter[0]))
					//{
					//	AssertSz(0,"Failed to copy data center from AE\n");
					//	break;
					//}

					// Set Last Selection Method
					//

					m_dwFlags &= (~FREETEXT_SELECTION_METHOD);
					m_dwFlags |= PHONELIST_SELECTION_METHOD;

				} else if (NOTIFY_CODE == CBN_EDITCHANGE) {

					if (SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,WM_GETTEXTLENGTH,0,0))
					{
						EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);
					} else {
						EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),FALSE);
					}

					// Set Last Selection Method
					//

					m_dwFlags &= (~PHONELIST_SELECTION_METHOD);
					m_dwFlags |= FREETEXT_SELECTION_METHOD;
				}

				break;
			case IDC_CMDNEXT:
				if ((m_dwFlags & PHONELIST_SELECTION_METHOD) == PHONELIST_SELECTION_METHOD)
				{
					DWORD_PTR dwItemData;

					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETCURSEL,0,0);
					if (iCurIndex == CB_ERR) break;

					dwItemData = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
					if (iCurIndex == CB_ERR) break;

					// Get the relavant information out of the AE structures
					//

					pAE = (PACCESSENTRY)dwItemData;
					((CPhoneBook far *)m_dwPhoneBook)->GetCanonical(pAE,m_szPhoneNumber);
					lstrcpy(m_szDunFile,pAE->szDataCenter);
				} else {

					// Parse the text that the user entered
					//

					if (GetDlgItemText(m_hwndDlg,IDC_CMBNUMBER,m_szPhoneNumber,RAS_MaxPhoneNumber))
					{
						m_szPhoneNumber[RAS_MaxPhoneNumber] = '\0';
						for (p = m_szPhoneNumber;*p && *p != ':';p++);
						if (*p)
						{
							*p = '\0';
							p++;
							lstrcpy(m_szDunFile,p);
						} else {
							m_szDunFile[0] = '\0';
						}

						// Check that the phone number on contains valid characters
						//

						for (p = m_szPhoneNumber;*p;p++)
						{
							for(p2 = szValidPhoneCharacters;*p2;p2++)
							{
								if (*p == *p2)
									break; // p2 for loop
							}
							if (!*p2) break; // p for loop
						}

						if (*p)
						{
							MessageBox(m_hwndDlg,GetSz(IDS_INVALIDPHONE),GetSz(IDS_TITLE),MB_MYERROR);
							//MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
							break; // switch statement
						}
					} else {
						AssertSz(0,"You should never be able to hit NEXT with nothing in the phone number.\n");
					}
				}
				EndDialog(m_hwndDlg,IDC_CMDNEXT);
				break;
			case IDC_CMDCANCEL:
				if ((m_dwFlags & (AUTODIAL_IN_PROGRESS|DIALERR_IN_PROGRESS)) == 0) 
				{
					if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
						MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
						EndDialog(hwndDlg,IDC_CMDCANCEL);
				} else {
					EndDialog(hwndDlg,IDC_CMDCANCEL);
				}
			break;
				EndDialog(m_hwndDlg,IDC_CMDCANCEL);
				break;
			case IDC_CMDBACK:
				EndDialog(m_hwndDlg,IDC_CMDBACK);
				break;
		}
	default:
		lRet = FALSE;
		break;
	}// switch

	return lRet;
}

// ############################################################################
/***** 1/9/96  jmazner  Normandy #13185
CAccessNumDlg::CAccessNumDlg()
{
	m_szDunPrimary[0] = '\0';
	m_szDunSecondary[0] = '\0';
	m_szPrimary[0] = '\0';
	m_szSecondary[0] = '\0';
	m_rgAccessEntry = NULL;
	m_wNumber = 0;
	m_dwPhoneBook=0;
}
*********/

// ############################################################################
/********* 1/9/96 jmazner  Normandy #13185
                           This was dead code, unused anywhere in icwphbk
INT_PTR CAccessNumDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
										LRESULT lResult)
{
	LRESULT lRet = TRUE;

	switch (uMsg)
	{
	case WM_INITDIALOG:
		SendDlgItemMessage(hwnd,IDC_TXTPRIMARY,EM_SETLIMITTEXT,RAS_MaxPhoneNumber,0);
		SendDlgItemMessage(hwnd,IDC_TXTSECONDARY,EM_SETLIMITTEXT,RAS_MaxPhoneNumber,0);

/ *
		// turn AccessEntries into phone numbers
		if(m_szPrimary[0] == '\0')
		{
			LPIDLOOKUPELEMENT pIDLookUp;
			CPhoneBook *pcPBTemp;
			pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);

			AssertSz(m_dwPhoneBook,"No phonebook set");

			//For the primary phone number
			pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&m_rgAccessEntry[0]->dwCountryID,
				pcPBTemp->m_rgIDLookUp,pcPBTemp->m_pLineCountryList->dwNumCountries,
				sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);
			SzCanonicalFromAE (m_szPrimary, m_rgAccessEntry[0], pIDLookUp->pLCE);

			if (m_rgAccessEntry[1])
			{
				if (m_rgAccessEntry[0]->dwCountryID != m_rgAccessEntry[1]->dwCountryID)
				{
					pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&m_rgAccessEntry[0]->dwCountryID,
						pcPBTemp->m_rgIDLookUp,pcPBTemp->m_pLineCountryList->dwNumCountries,
						sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);
				}
				SzCanonicalFromAE (m_szSecondary, m_rgAccessEntry[1], pIDLookUp->pLCE);
			}
		}
* /
		SendDlgItemMessage(hwnd,IDC_TXTPRIMARY,WM_SETTEXT,0,(LPARAM)&m_szPrimary[0]);
		SendDlgItemMessage(hwnd,IDC_TXTSECONDARY,WM_SETTEXT,0,(LPARAM)&m_szSecondary[0]);
		break;

		
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_CMDOK:
			// Check that we have at least one phone number
			// Leave dialog
			GetDlgItemText(hwnd,IDC_TXTPRIMARY,&m_szPrimary[0],RAS_MaxPhoneNumber);
			GetDlgItemText(hwnd,IDC_TXTSECONDARY,&m_szSecondary[0],RAS_MaxPhoneNumber);

			if (m_szPrimary[0])
				m_wNumber=1;
			else
				m_wNumber=0;

			if (m_szSecondary[0])
				m_wNumber++;

			EndDialog(hwnd,IDC_CMDOK);
			break;
		case IDC_CMDEXIT:
			// Verify with user
			// Get out of Dodge
			if (MessageBox(hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
				MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
				EndDialog(hwnd,IDC_CMDEXIT);
			break;
		case IDC_CMDCHANGEPRIMARY:
			// hide dialog
			ShowWindow(hwnd,SW_HIDE);
			// show new dialog
			CSelectNumDlg far *pcSelectNumDlg;
			pcSelectNumDlg = new CSelectNumDlg;
			if (!pcSelectNumDlg)
			{
				MessageBox(hwnd,GetSz(IDS_NOTENOUGHMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
//				MsgBox(IDS_NOTENOUGHMEMORY,MB_MYERROR);
				ShowWindow(hwnd,SW_SHOW);
				break;
			}
			int irc;
			pcSelectNumDlg->m_dwPhoneBook = m_dwPhoneBook;
			pcSelectNumDlg->m_dwCountryID = m_dwCountryID;
			pcSelectNumDlg->m_wRegion = m_wRegion;
			irc = DialogBoxParam(g_hInstDll,MAKEINTRESOURCE(IDD_SELECTNUMBER),
									g_hWndMain,PhbkGenericDlgProc,
									(LPARAM)pcSelectNumDlg);
			ShowWindow(hwnd,SW_SHOW);
			switch (irc)
			{
				case -1:
					MessageBox(hwnd,GetSz(IDS_NOTENOUGHMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
//					MsgBox(IDS_NOTENOUGHMEMORY,MB_MYERROR);
					goto DlgProcExit;
					// break;
				case IDC_CMDOK:
					m_dwCountryID = pcSelectNumDlg->m_dwCountryID;
					m_wRegion = pcSelectNumDlg->m_wRegion;
					lstrcpy(m_szDunPrimary,pcSelectNumDlg->m_szDunFile);
					SetDlgItemText(hwnd,IDC_TXTPRIMARY,pcSelectNumDlg->m_szPhoneNumber);
					break;
			}
			break;
		}
		break;
	default:
		lRet = FALSE;
		break;
	}
DlgProcExit:
	return lRet;
}

*********************/

#ifdef WIN16
// ############################################################################
// NAME: SetNonBoldDlg
//
//	Set all the child controls in a window to a non-bold version of the
//	current control font.
//
// Parameters: HWND hDlg	Handle to the dialog window
//
// Created 8/12/96	ValdonB (creatively borrowed from IE)
// ############################################################################

void
SetNonBoldDlg(HWND hDlg)
{
    HFONT hfontDlg = (HFONT) NULL;
    LOGFONT lFont;
    HWND hCtl;
    if ((hfontDlg = (HFONT) SendMessage(hDlg, WM_GETFONT, 0, 0L)))
    {
        if (GetObject(hfontDlg, sizeof(LOGFONT), (LPSTR) &lFont))
        {
            lFont.lfWeight = FW_NORMAL;
            if (hfontDlg = CreateFontIndirect((LPLOGFONT) &lFont))
            {
                // apply the font to all the child controls
                for (hCtl = GetWindow(hDlg, GW_CHILD);
                        NULL != hCtl;
                        hCtl = GetWindow(hCtl, GW_HWNDNEXT))
                {
                    SendMessage(hCtl, WM_SETFONT, (WPARAM) hfontDlg, 0);
                }
            }
        }
    }
}


// ############################################################################
// NAME: SetNonBoldDlg
//
// 	The dialog was modified earlier by unbolding the dialog font, and
// 	getting each control in the dialog to use that font. This function
// 	is called when the dialog is being destroyed so the font can be
// 	deleted
//
// Parameters: HWND hDlg	Handle to the dialog window
//
// Created 8/12/96	ValdonB (creatively borrowed from IE)
// ############################################################################

void
DeleteDlgFont
(
    HWND hDlg
)
{
	HFONT hfont = NULL;

	hfont = (HFONT)SendMessage(hDlg,WM_GETFONT,0,0);
	if (hfont) DeleteObject(hfont);
}
#endif	// WIN16



// ############################################################################
#ifdef WIN16
extern "C" INT_PTR CALLBACK __export PhbkGenericDlgProc(
#else
extern "C" __declspec(dllexport) INT_PTR CALLBACK PhbkGenericDlgProc(
#endif
    HWND  hwndDlg,	// handle to dialog box
    UINT  uMsg,	// message
    WPARAM  wParam,	// first message parameter
    LPARAM  lParam 	// second message parameter
   )
{
#if defined(WIN16)
	RECT	MyRect;
	RECT	DTRect;
#endif
//#ifdef DEBUG
//	DebugBreak();
//#endif
	CDialog far *pcDlg = NULL;
	LRESULT lRet;
	switch (uMsg)
	{
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(hwndDlg,IDC_LBLTITLE));
		break;
	case WM_INITDIALOG:
		pcDlg = (CDialog far *)lParam;
		SetWindowLongPtr(hwndDlg,DWLP_USER,lParam);
		lRet = TRUE;
#if defined(WIN16)
		//
		// Move the window to the center of the screen
		//
		GetWindowRect(hwndDlg, &MyRect);
		if (0 == MyRect.left && 0 == MyRect.top)
		{
			GetWindowRect(GetDesktopWindow(), &DTRect);
			MoveWindow(hwndDlg, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
								MyRect.right, MyRect.bottom, FALSE);
		}
		SetNonBoldDlg(hwndDlg);
#endif
		MakeBold(GetDlgItem(hwndDlg,IDC_LBLTITLE));
		break;
#if defined(WIN16)
	case WM_SYSCOLORCHANGE:
		Ctl3dColorChange();
		break;
#endif
	// 1/9/96  jmazner Normandy #13185, moved to CSelectNumDlg::DlgProc
	//case WM_CLOSE:
	//	if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
	//		MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
	//		EndDialog(hwndDlg,IDC_CMDCANCEL);
	//	lRet = TRUE;
	//	break;
//		//PostQuitMessage(0);
//		EndDialog(hwndDlg,FALSE);
//		lRet = TRUE;
//		break;
	default:
		// let the system process the message
		lRet = FALSE;
	}

	if (!pcDlg) pcDlg = (CDialog far*)GetWindowLongPtr(hwndDlg,DWLP_USER);
	if (pcDlg)
		lRet = pcDlg->DlgProc(hwndDlg,uMsg,wParam,lParam,lRet);

	return (INT_PTR)lRet;
}

// ############################################################################
HRESULT CSelectNumDlg::FillRegion()
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	int iCurIndex;
	int iLastIndex;
	unsigned int idx;
	CPhoneBook far *pcPBTemp;
	pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
	int iDebugIdx;
	
	// Fill in region list
	//

	SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_RESETCONTENT,0,0);
	SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_ADDSTRING,0,(LPARAM)GetSz(IDS_NATIONWIDE));
	iCurIndex = -1;		// 0xFFFFFFFF;
	m_fHasRegions = FALSE;
	for (idx=0;idx<pcPBTemp->m_cStates;idx++)
	{
		if (pcPBTemp->m_rgState[idx].dwCountryID == m_dwCountryID)
		{
			PACCESSENTRY pAE = NULL, pAELast = NULL;
			pAE = pcPBTemp->m_rgState[idx].paeFirst;
			Assert(pAE);
			pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
			while (pAELast > pAE && 
				pAE->dwCountryID == m_dwCountryID &&
				pAE->wStateID == idx+1)
			{
				if ((pAE->fType & m_bMask) == m_fType)
					goto AddRegion;
				pAE++;
			}
			continue;

AddRegion:
			m_fHasRegions = TRUE;

			iLastIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_ADDSTRING,0,(LPARAM)&pcPBTemp->m_rgState[idx].szStateName[0]);
			iDebugIdx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETITEMDATA,(WPARAM)iLastIndex,(LPARAM)idx+1);
			if ((idx+1) == m_wRegion)
			{
				iCurIndex = iLastIndex;
			}
		}
	}

	// select current region or nation wide
	//

	if (iCurIndex != -1)	// 0xFFFFFFFF
	{
		SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETCURSEL,(WPARAM)iCurIndex,0);
	} else {
		m_wRegion = 0;	// Nationwide
		SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETCURSEL,0,0);
	}

	EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMBREGION),m_fHasRegions);
	PostMessage(m_hwndDlg,WM_SHOWSTATEMSG,m_fHasRegions,0);

	hr = ERROR_SUCCESS;
	return hr;
}

// ############################################################################
CSelectNumDlg::CSelectNumDlg()
{
	m_dwCountryID = 0;
	m_wRegion = 0;
	m_dwPhoneBook = 0;
	m_szPhoneNumber[0] = '\0';
	m_szDunFile[0] = '\0';
	m_fType = 0;
	m_bMask = 0;
	m_fHasRegions = FALSE;
	m_hwndDlg = NULL;
	m_dwFlags = 0;
}

// ############################################################################
HRESULT CSelectNumDlg::FillNumber()
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	PACCESSENTRY pAELast, pAE = NULL;
	CPhoneBook far *pcPBTemp;
	unsigned int idx;
	pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
	
	// Check if we need to look up the number from the region or from the country
	//

	if (m_fHasRegions && m_wRegion)
		pAE = pcPBTemp->m_rgState[m_wRegion-1].paeFirst;
	

	// Find the Access Entries for the country
	//

	if (!pAE)
	{
		LPIDLOOKUPELEMENT pIDLookUp, pLookUpTarget;

		pLookUpTarget = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,sizeof(IDLOOKUPELEMENT));
		Assert(pLookUpTarget);
		if (!pLookUpTarget) goto FillNumberExit;
		pLookUpTarget->dwID = m_dwCountryID;

		pIDLookUp = NULL;
		pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(pLookUpTarget,pcPBTemp->m_rgIDLookUp,
			(int)pcPBTemp->m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);
		if (pIDLookUp)
			pAE = pIDLookUp->pFirstAE;
	}

	// Fill the list for whatever AE's we found
	//
	
	SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_RESETCONTENT,0,0);
	if (pAE)
	{
		//pAELast = pcPBTemp->m_rgPhoneBookEntry + pcPBTemp->m_cPhoneBookEntries;
		pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
		while (pAELast > pAE && pAE->dwCountryID == m_dwCountryID && pAE->wStateID == m_wRegion)
		{
			if ((pAE->fType & m_bMask) == m_fType)
			{
				wsprintf(szTemp,"%s (%s) %s",pAE->szCity,pAE->szAreaCode,
							pAE->szAccessNumber);
				idx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,
												CB_ADDSTRING,0,
												(LPARAM)((LPSTR) &szTemp[0]));
				if (idx == -1) goto FillNumberExit;
				SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETITEMDATA,
									(WPARAM)idx,(LPARAM)pAE);
			}
			pAE++;
		}

		// Select the first item
		//

		if (SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETCURSEL,0,0) == CB_ERR)
				EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),FALSE);
		else
				EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);
		hr = ERROR_SUCCESS;
	}
FillNumberExit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\business.cpp ===
/*********************************************************************
Registration Wizard
(c) 1994-95 Microsoft Corporation
Business Question

  04/26/98 - Suresh Krishnan

    06/18/98 - Add Blank Option for Software Role
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "RegPage.h"
#include "regwizmain.h"
#include "resource.h"
#include "dialogs.h"
#include "regutil.h"
#include <rw_common.h>

#define _INCLUDE_3RDPARTYLOGIC_CODE 

#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 
static int vDeclineOffers = -1;
#endif

static int siMaxSWRoleOptions=0;
BOOL ValidateBusinessUserDialog(HWND hwndDlg,int iStrID);
int  GetAndAddBusinessRoleFromResource(HINSTANCE hIns, HWND hwnd);

INT_PTR  CALLBACK BusinessUserDialogProc(HWND hwndDlg, UINT uMsg, 
										 WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that displays 
Business related Question 
network type, etc.
**********************************************************************/
{


	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
	BOOL NotboughtByCompany;
	HWND   hwBusinessRole;
	LRESULT    dwStatus;
	DWORD dwStart,dwEnd;
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 
	TriState shouldInclude;
#endif

	int	  iIndex; // Selection index for SW Role

	
	static int iShowThisPage= DO_SHOW_THIS_PAGE; 


	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
		hwBusinessRole = GetDlgItem(hwndDlg,IDC_COMBO2);
	}
	

    switch (uMsg)
    {
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;
		case WM_CLOSE:
			 break;			
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			siMaxSWRoleOptions = GetAndAddBusinessRoleFromResource(pi->hInstance, GetDlgItem(hwndDlg,IDC_COMBO2) );
			vDialogInitialized = FALSE;
            return TRUE;
		} // WM_INIT
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				NotboughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
				//
				// Check if System Inv DLL is present
				if( !NotboughtByCompany) {
					iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
				}else {
					iShowThisPage= DO_SHOW_THIS_PAGE;
				}
				if(iShowThisPage== DO_SHOW_THIS_PAGE) {
					NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
					NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
				}
				if( iShowThisPage== DO_NOT_SHOW_THIS_PAGE ) {
					//CB_GETCOUNT 
					//CB_GETCURSEL  // CB_ERR

					
					//CB_FINDSTRING wParam = (WPARAM) indexStart;    lParam = (LPARAM) (LPCSTR) lpszFind   
 

					pi->iCancelledByUser = RWZ_SKIP_AND_GOTO_NEXT;
					if( pi->iLastKeyOperation == RWZ_BACK_PRESSED){
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_BACK);
					}else {
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
					}

				}
				else {
					// Show this page
					pi->iCancelledByUser = RWZ_PAGE_OK;
					pi->iLastKeyOperation = RWZ_UNRECOGNIZED_KEYPESS;
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
										
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 					

					shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
					if (shouldInclude == kTriStateTrue ){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						vDeclineOffers = 1;
					}
					else if (shouldInclude == kTriStateFalse){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						vDeclineOffers = 0;
					}else if (shouldInclude == kTriStateUndefined){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
						vDeclineOffers = -1;
					}
					// Enable for previpously entred value in screen
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
#endif
					
#ifdef     USE_DROPDOWN
					if(pclRegWizard->GetInformationString(kBusinessRole,szInfo)) {
							//SendMessage(hwBusinessRole,	WM_SETTEXT,0,(LPARAM) szInfo);
							SendMessage(hwBusinessRole,CB_SELECTSTRING,(WPARAM) -1,(LPARAM) szInfo);
					}else {
							SendMessage(hwBusinessRole,	CB_SETCURSEL,0,0);
					}
#endif
					iIndex = 0;	
					if(pclRegWizard->GetInformationString(kBusinessRole,szInfo)) {
							iIndex = _ttoi(szInfo);
							if(iIndex < 10){
								iIndex = 0;
							}else {
								iIndex -=10;
                                iIndex++; // Added to include blank in option
							}
					}
					SendMessage(hwBusinessRole,	CB_SETCURSEL,iIndex,0);
					

					vDialogInitialized = TRUE;
					
				}
                break;

            case PSN_WIZNEXT:
					switch(pi->iCancelledByUser) {
					case  RWZ_CANCELLED_BY_USER : 
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					break;
					case RWZ_PAGE_OK:
					iRet=0;
					if( ValidateBusinessUserDialog(hwndDlg,IDS_BAD_SYSINV)) {
					    dwStatus = SendMessage(hwBusinessRole,	CB_GETCURSEL,0,0);
						if(dwStatus == CB_ERR) {
							dwStatus = 0;
						}
                        if(dwStatus > 0 ) {    
					        dwStatus--; // Added on 6/18  to include blank option	
                           _stprintf(szInfo,_T("%i"),dwStatus+10);
                        }
                        else {
                            dwStatus = 0; // to eleminate negative numbers 
                           _stprintf(szInfo,_T("%i"),dwStatus);
                        }
						pclRegWizard->SetInformationString(kBusinessRole,szInfo);


#ifdef USE_DROPDOWN
						dwStart = 128; 
						SendMessage(hwBusinessRole,	WM_GETTEXT,(WPARAM) (LPDWORD) dwStart,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kBusinessRole,szInfo);
						if(dwStatus == CB_ERR) {
							dwStatus = GetLastError();
							SendMessage(hwBusinessRole,	CB_GETEDITSEL,(WPARAM) (LPDWORD) &dwStart,(LPARAM) (LPDWORD) &dwEnd);
							SendMessage(hwBusinessRole,	WM_GETTEXT,(WPARAM) (LPDWORD) dwStart,(LPARAM) szInfo);
					 	}
#endif
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 
						if(vDeclineOffers == -1){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateUndefined);
						}
						else
						if(vDeclineOffers == 0){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateFalse);
						}
						else{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateTrue);
						}
						_stprintf(szInfo,_T("%i"),vDeclineOffers);
						RW_DEBUG << "\n Business Decline Offers " << szInfo << "\n" << flush;
						pclRegWizard->SetInformationString(kInfoDeclinesNonMSProducts,szInfo);
#endif

						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						// Set as Next Key Button Pressed
						}else {
							// Validation has failed so for it in the same screen
							// Force it it be in this screen
							iRet=-1;
						}
						SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet); 
					break;
					case RWZ_SKIP_AND_GOTO_NEXT:
					default:
						// Do not Validate the page and just go to the next page 
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;

					break;
				} // end of switch pi->iCancelledByUser
				break;
            case PSN_WIZBACK:
                pi->CurrentPage--;
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
				break;
			case PSN_QUERYCANCEL :
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kBusinessUserDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					pi->iLastKeyOperation = RWZ_CANCEL_PRESSED;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
        case WM_COMMAND:
		{
			switch (wParam)
            {
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 
              case IDC_RADIO2:
			  case IDC_RADIO1:
				if (vDialogInitialized){
					// If the 'No' button is checked, the user is declining
					// the "Non-Microsoft product" offers
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						vDeclineOffers = 1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						vDeclineOffers = 0;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else{
						vDeclineOffers = -1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
					}

				}
				break;
#endif
			  default:
				  break;
            }
		}// End of WM_COMMAND
        break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
       
}



BOOL ValidateBusinessUserDialog(HWND hwndDlg,int iStrID)
{
	return TRUE;
}

//
// returns Maximum number of elements 
//
int  GetAndAddBusinessRoleFromResource(HINSTANCE hIns, HWND hwndCB )
{
	
	int iCount =0;
	int iTokLen;
	int iResLen; 
	_TCHAR	seps[] = _T(",");
	_TCHAR *pDummy;
	LRESULT dwAddStatus ;

	LPTSTR	token;
	TCHAR   tcSrc[1024];

 	//SendMessage(hwndCB, CB_ADDSTRING, -1, (LPARAM) _T("             "));
	iResLen = LoadString(hIns,IDS_BUSINESSROLE_LIST,tcSrc,1024);
	
	token = _tcstok( tcSrc, seps );
    //	token = _tcstok( NULL, seps );
	while( token != NULL ) {
		iCount++;
		 RW_DEBUG  << "\n Add Business Role=[" << iCount << "]=" << token << flush;
 		 dwAddStatus = SendMessage(hwndCB, CB_ADDSTRING, -1, (LPARAM) token);
		/* Get next token: */
		token = _tcstok( NULL, seps );

   }
	return iCount;
   
  
   
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\cntryinf.cpp ===
/*********************************************************************
Registration Wizard

CNTRYINF.CPP
This file houses a set of function that use TAPI to access country
code/name information.

11/15/94 - Tracy Ferrier
05/08/97 - Suresh Krishnan
	Modified Country inforamtion retrival  using classes
	The class CCntryInfo  will get  the information of the country list using
	TAPI API.
	And it has methiods GetCountryCode() and GetCountryName() to Accessit.
	Also A Combo List can be generated using the
2/3/98   - Suresh Krishnan
	Added GetCountryCodeUsingTapiId() ;
	This uses RAS API to get the country ID
	
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include <rw_common.h>
#include "cntryinf.h"
#include <ATK_RAS.H>

//#define COMPILE_USING_VC   Enable this if U are compiling for UNICODE using VISULA c++ 5.0 compiler


static DWORD dwAPILowVersion = 0 << 16;
static DWORD dwAPIHighVersion = 3 << 16;

BOOL FGetLocationEntry(HLINEAPP hLineApp, DWORD dwAPI,LINELOCATIONENTRY *pLE);
BOOL FGetLineCountryList(LINECOUNTRYLIST **ppcl);
void CALLBACK CountryLineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);
BOOL PrepareCountryListFromTapi ( HINSTANCE hInstance,
								  LINECOUNTRYLIST	**pcl);

CCntryInfo  gTapiCountryTable; // Gloabal variable for buildind and maintaininf TAPI cntry info.

#define INVALID_PORTID (DWORD) -1
#ifndef _TAPI
#define _TAPI
#endif
BOOL GetTapiCurrentCountry(HINSTANCE hInstance,DWORD* dwpCountry)
/*********************************************************************
Returns the current code of the user's location, as determined by
Tapi.
**********************************************************************/
{
	#ifdef _TAPI
	DWORD				dwAPI;
	LINELOCATIONENTRY	LE;
	BOOL				fDefCountry;
	HLINEAPP 			hLineApp;
	DWORD 				numDevs;
	LONG tapiStatus = lineInitialize(&hLineApp, hInstance,
		(LINECALLBACK) CountryLineCallback, NULL, &numDevs);
	if (tapiStatus != 0)
	{
		char szMessage[256];
		sprintf(szMessage,"lineInitialize call failed: error = %li",tapiStatus);
		RW_DEBUG << szMessage << "\n"<< flush;
		//MessageBox(NULL,szMessage,_T("TAPI STATUS"),MB_OK);
		return FALSE;
	}
#ifdef SURESH
	DWORD dwAPILowVersion = 1 << 16;
	DWORD dwAPIHighVersion = 4 << 16;
#endif
	
	LINEEXTENSIONID extensionID;
	tapiStatus = lineNegotiateAPIVersion(hLineApp,0,dwAPILowVersion, dwAPIHighVersion,&dwAPI,&extensionID);

//	RW_DEBUG << "Api Version : " << dwAPI << flush;

	 //this gets the currently selected TAPI country
	//fDefCountry = FGetLocationEntry(hLineApp, dwAPI, &LE);
	fDefCountry = FGetLocationEntry(hLineApp, 0x30000, &LE);
	//if (LE.dwCountryID == kCountryCodeNorthAmerica)
	//{
	//	LE.dwCountryID = kCountryCodeUnitedStates;
	//}
	if(fDefCountry) {
		*dwpCountry = LE.dwCountryID;
	}else {
		*dwpCountry = 1; // Default To USA

	}
	lineShutdown(hLineApp);

	#endif	//_TAPI

	return (fDefCountry);
} // FFillCountryList()

//
//
//  Returns 0 if successful
//
//
DWORD GetCountryCodeUsingTapiId(DWORD dwCountryId, DWORD *dwCountryCode)
{
	DWORD dwRet;
	dwRet = 0;
	struct XXForRasCntry{
		RASCTRYINFO    rci;
		TCHAR          czB[256] ; // To Store the Country Name
		
	} Rc;
	DWORD dwSz;
	*dwCountryCode = 1; // Default Value

	// Init the Sizes of Data Struct and Buffer
	Rc.rci.dwSize = sizeof(Rc.rci );
	dwSz = sizeof(Rc);

	Rc.rci.dwCountryID = dwCountryId;
	ATK_RasGetCountryInfo((RASCTRYINFO *)&Rc,&dwSz);
	*dwCountryCode = Rc.rci.dwCountryCode;
	return  dwRet;

}

BOOL FGetLocationEntry(HLINEAPP hLineApp, DWORD dwAPI,LINELOCATIONENTRY *pLE)
 /***************************************************************************
 Allocate memory for and fetch a line country list (LINECOUNTRYLIST) from
TAPI
****************************************************************************/
{
	BOOL fRet = FALSE;

	#ifdef _TAPI
	DWORD dwRet, iLoc;
	LINETRANSLATECAPS ltc, *pltc;
	LPLINELOCATIONENTRY plle;

    if (pLE == NULL) return (fRet);

    ltc.dwTotalSize = sizeof(LINETRANSLATECAPS);
    dwRet = lineGetTranslateCaps(hLineApp, dwAPI, &ltc);
    pltc = (LINETRANSLATECAPS*) LocalAlloc(LPTR, ltc.dwNeededSize+100);
    if (!pltc) return (fRet);

    pltc->dwTotalSize = ltc.dwNeededSize;
    dwRet = lineGetTranslateCaps(hLineApp, dwAPI, pltc);
    plle = (LPLINELOCATIONENTRY) (((LONG_PTR) pltc) + pltc->dwLocationListOffset);
    for (iLoc = 0; iLoc < pltc->dwNumLocations; iLoc ++)
    {
        if (pltc->dwCurrentLocationID == plle->dwPermanentLocationID)
        {
            *pLE = *plle;
            fRet = TRUE;
            break;
        }
        plle ++;
   }

    LocalFree(pltc);
	#endif
    return (fRet);
} // FGetLocationEntry()




void CALLBACK CountryLineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1,
								  DWORD dwParam2, DWORD dwParam3)
{
;

}


BOOL PrepareCountryListFromTapi(HINSTANCE hInstance,
					  LINECOUNTRYLIST		**pcl )
{
	
	DWORD				dwAPI;
	HLINEAPP hLineApp;
	DWORD numDevs;

	LINECOUNTRYLIST cl;
	


	BOOL fRet = FALSE;

	LONG tapiStatus = lineInitialize(&hLineApp,
		hInstance, (LINECALLBACK) CountryLineCallback,
		NULL, &numDevs);
	if (tapiStatus != 0)
	{
		CHAR szMessage[256];
		sprintf(szMessage,"lineInitialize call failed: error = %li",tapiStatus);
		RW_DEBUG << szMessage <<"\n"<< flush;
		return FALSE;
	}

	
	LINEEXTENSIONID extensionID;
	tapiStatus = lineNegotiateAPIVersion(hLineApp,0,dwAPILowVersion, dwAPIHighVersion,&dwAPI,&extensionID);
	
	*pcl = NULL;
	cl.dwTotalSize = sizeof(LINECOUNTRYLIST);
	// find size needed for list
	if (0 != lineGetCountry(0, 0x10003, &cl)){
	 	goto EndFn;
	}
	*pcl = (LINECOUNTRYLIST *) LocalAlloc(LPTR, cl.dwNeededSize + 100 );
	if (NULL == *pcl){
		goto EndFn;
	}

	(*pcl)->dwTotalSize = cl.dwNeededSize + 100;
	if (0 != lineGetCountry(0, 0x10003, *pcl))
	{
		goto EndFn;
	}
	

EndFn:
	lineShutdown(hLineApp);
	return (fRet);
}




//
//
//
//
//

CCntryInfo :: CCntryInfo()
{
	HINSTANCE hIns= NULL;;

#ifdef _TAPI
	m_pCountry= NULL;
	PrepareCountryListFromTapi(hIns,
					 &m_pCountry);
#endif

		
}

CCntryInfo :: ~CCntryInfo()
{
#ifdef _TAPI
	if(m_pCountry) {
		LocalFree(m_pCountry);
	}
#endif
}

int CCntryInfo :: GetCountryCode( _TCHAR * czCountryName)
{
	
#ifdef _TAPI
	LINECOUNTRYENTRY	*plce;
	_TCHAR *			pTsz;
	PSTR                psz;
	DWORD				iCountry;

#ifdef COMPILE_USING_VC
	return 1;
#endif


	int iRet = -1;
	
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	for (iCountry = 0; iCountry < m_pCountry->dwNumCountries; ++iCountry)
	{
		psz = ((PSTR) m_pCountry ) + plce->dwCountryNameOffset;
		pTsz = (PTSTR) psz;
		//pTsz = ConvertToUnicode(psz);
		if(!_tcscmp(czCountryName,pTsz) ){
			return iCountry;
		}
		*plce ++;
	}
	return iRet;
#else
	return -1;
#endif
}

int CCntryInfo :: GetCountryCode( DWORD  dwTapiId)
{
	
#ifdef _TAPI
	LINECOUNTRYENTRY	*plce;
	_TCHAR *			pTsz;
	PSTR                psz;
	DWORD				iCountry;

#ifdef COMPILE_USING_VC
	return 1;
#endif


	int iRet = 0;
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	for (iCountry = 0; iCountry < m_pCountry->dwNumCountries; ++iCountry)
	{
		if( plce->dwCountryID  == dwTapiId){
				return iCountry;
		}
		*plce ++;
	}
	return iRet;
#else
	return -1;
#endif
}


_TCHAR * CCntryInfo :: GetCountryName(int iCode)
{
#ifdef _TAPI
	LINECOUNTRYENTRY	*plce;

	PSTR				psz;
	PTSTR                pTsz;
	int iRet = -1;

	if( iCode < 0 ){
		iCode = 0;
	}
	if ( iCode > (int)m_pCountry->dwNumCountries) {
		iCode = 0;
	}
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	psz = ((PSTR) m_pCountry ) + plce[iCode].dwCountryNameOffset;
	pTsz = (PTSTR) psz;
	//pTsz = ConvertToUnicode(psz);
	return pTsz;
#else
	return NULL;
#endif
}

int CCntryInfo :: GetTapiCountryCode(_TCHAR * czCountryName)
{
	LINECOUNTRYENTRY	*plce;
	PSTR				psz;
	_TCHAR *			pTsz;
	DWORD				iCountry;

	int iRet = 0;
	
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	for (iCountry = 0; iCountry < m_pCountry->dwNumCountries; ++iCountry)
	{
		psz = ((PSTR) m_pCountry ) + plce->dwCountryNameOffset;
		pTsz = (PTSTR) psz;
		//pTsz = ConvertToUnicode(psz);
		if(!_tcscmp(czCountryName,pTsz) ){
			return plce->dwCountryID;
		}
		
		*plce ++;
	}
	return iRet;
}
//
// Used for Field checking
int CCntryInfo::GetTapiIDForTheCountryIndex ( int iCode)
{
	return GetTapiCountryCode(GetCountryName(iCode));
}



//
//   Adds the country information in the ComboBox specified in hwndCB
//
//
//
void CCntryInfo :: FillCountryList(HINSTANCE hInstance,
								   HWND hwndCB)
{

#ifdef _TAPI
	LINECOUNTRYENTRY	*plce;
	PSTR				psz;
	PTSTR               pTsz;
	DWORD				iCountry;

	if(	hwndCB == NULL || m_pCountry == NULL ) {
		// if the country list or Combo control handle is Null
		return ;
	}
	int iRet = -1;
	
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	for (iCountry = 0; iCountry < m_pCountry->dwNumCountries; ++iCountry)
	{
		psz = ((PSTR) m_pCountry ) + plce->dwCountryNameOffset;
		pTsz = (PTSTR) psz;
		LRESULT dwAddStatus = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM) pTsz);
/**
#ifdef COMPILE_USING_VC
		DWORD dwAddStatus = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM) psz);
#else
		pTsz= ConvertToUnicode(psz);
		DWORD dwAddStatus = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM) pTsz);
#endif
**/		

		if (dwAddStatus == CB_ERR){
			return;
		}
		*plce ++;
	}
#endif


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\cbitmap.cpp ===
/*********************************************************************
Registration Wizard
Class: CBitmap

--- This class subclasses a Window control to create a control that
displays a bitmap

11/16/94 - Tracy Ferrier
04/15/97 - Modified to take care of crashing in Memphis as the default destoy was not handled 
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <stdio.h>
#include "cbitmap.h"
#include "Resource.h"
#include "assert.h"

static HBITMAP BitmapFromDib (
    LPVOID         pDIB,
    HPALETTE   hpal, WORD wPalSize);


LRESULT PASCAL BitmapWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

CBitmap::CBitmap(HINSTANCE hInstance, HWND hwndDlg,int idDlgCtl, int idBitmap)
/*********************************************************************
Constructor for our CBitmap class.  
**********************************************************************/
{
	m_hInstance = hInstance;
	m_nIdBitmap = idBitmap;
	m_hPal = NULL;
	m_hBitmap =  GetBmp(); //LoadBitmap(hInstance,MAKEINTRESOURCE(m_nIdBitmap));
	assert(m_hBitmap != NULL);

	HWND hwndCtl = GetDlgItem(hwndDlg,idDlgCtl);
	m_lpfnOrigWndProc = (FARPROC) GetWindowLongPtr(hwndCtl,GWLP_WNDPROC);
	assert(m_lpfnOrigWndProc != NULL);
	m_isActivePal = TRUE;
	SetWindowLongPtr(hwndCtl,GWLP_WNDPROC,(LONG_PTR) BitmapWndProc);
	SetWindowLongPtr(hwndCtl,GWLP_USERDATA,(LONG_PTR) this);
}


CBitmap::~CBitmap()
/*********************************************************************
Destructor for our CBitmap class
**********************************************************************/
{

	
	if (m_hBitmap) 
		DeleteObject(m_hBitmap);
	if( m_hPal ) 
		DeleteObject(m_hPal);

}

/* *****************************************************************
Create a 256 Color Bitmap
********************************************************************/

HBITMAP CBitmap::GetBmp()
{
       RECT rect;
       HDC  hDC;
       BOOL bRet;
 
       // detect this display is 256 colors or not
       hDC = GetDC(NULL);
       bRet = (GetDeviceCaps(hDC, BITSPIXEL) != 8);
       ReleaseDC(NULL, hDC);
       if (bRet) 
	   {                             
		   // the display is not 256 colors, let Windows handle it
          return LoadBitmap(m_hInstance,MAKEINTRESOURCE(m_nIdBitmap));
       }
 

       LPBITMAPINFO lpBmpInfo;               // bitmap informaiton
       int i;
       HRSRC hRsrc;
	   HANDLE hDib;
	   HBITMAP hBMP;
	   HPALETTE hPal;
       struct {
			   WORD            palVersion;
		       WORD            palNumEntries;
			   PALETTEENTRY    PalEntry[256];
	   } MyPal;
               
       hRsrc = FindResource(m_hInstance, MAKEINTRESOURCE(m_nIdBitmap),RT_BITMAP);
       if (!hRsrc)
         return NULL;
 
       hDib = LoadResource(m_hInstance, hRsrc);
       if (!hDib)
         return NULL;
 
       if (!(lpBmpInfo = (LPBITMAPINFO) LockResource(hDib)))
               return NULL;
                               
       MyPal.palVersion = 0x300;
       MyPal.palNumEntries = 1 << lpBmpInfo->bmiHeader.biBitCount;
 
       for (i = 0; i < MyPal.palNumEntries; i++) 
	   {
         MyPal.PalEntry[i].peRed   = lpBmpInfo->bmiColors[i].rgbRed;
         MyPal.PalEntry[i].peGreen = lpBmpInfo->bmiColors[i].rgbGreen;
         MyPal.PalEntry[i].peBlue  = lpBmpInfo->bmiColors[i].rgbBlue;
         MyPal.PalEntry[i].peFlags = 0;
       }
       m_hPal = CreatePalette((LPLOGPALETTE)&MyPal);

       if (m_hPal == NULL) 
	   {        // create palette fail, let window handle the bitmap
          return LoadBitmap(m_hInstance,MAKEINTRESOURCE(m_nIdBitmap));          
       }
       
       hBMP = BitmapFromDib(hDib,m_hPal,MyPal.palNumEntries);
       UnlockResource(hDib);
	   if( hBMP == NULL ) {
		   DeleteObject(m_hPal);
		   m_hPal = NULL;
		   hBMP = LoadBitmap(m_hInstance,MAKEINTRESOURCE(m_nIdBitmap));
       }
	   //DeleteObject(hPal);
	   return hBMP;
}


LRESULT PASCAL CBitmap::CtlWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	switch (message)
	{
		case WM_PAINT:
		{
			PAINTSTRUCT ps;
			HPALETTE hpalT;
			HDC hdc = BeginPaint(hwnd,&ps);
			HDC hMemDC = CreateCompatibleDC(hdc);
			SelectObject(hMemDC,m_hBitmap);
			RECT wndRect;
			GetClientRect(hwnd,&wndRect);
		    if (m_hPal){
				hpalT = SelectPalette(hdc,m_hPal,FALSE);
				RealizePalette(hdc);     
			}


			BitBlt(hdc,0,0,wndRect.right - wndRect.left,wndRect.bottom - wndRect.top,hMemDC,0,0,SRCCOPY);
			if( m_hPal ) 
				SelectPalette(hdc,hpalT,FALSE);

			DeleteDC(hMemDC);
			EndPaint(hwnd,&ps);
#ifdef _WIN95
			return CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#else
			return CallWindowProc((WNDPROC) m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#endif
			

			break;
		}
		case WM_QUERYNEWPALETTE :
				if(m_hPal && !m_isActivePal) 
					InvalidateRect(hwnd,NULL,FALSE);
				return 0;//CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);


		case WM_PALETTECHANGED :
			if( (HWND)wParam != hwnd ) {
				if(m_hPal ) {
					m_isActivePal = FALSE;
					InvalidateRect(hwnd,NULL,FALSE);
				}
			}
			else m_isActivePal = TRUE;
			return 0; //CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);

		case WM_DESTROY:
			SetWindowLongPtr(hwnd,GWLP_WNDPROC,(LONG_PTR) m_lpfnOrigWndProc);

		default:
#ifdef _WIN95
			return CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#else
			return CallWindowProc((WNDPROC) m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#endif

			

			break;
	}
	return 0;
}


LRESULT PASCAL BitmapWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	CBitmap* pclBitMap = (CBitmap*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
	LRESULT lret;
		
	switch (message)
	{
		case WM_DESTROY:

			//return 
			lret = pclBitMap->CtlWndProc(hwnd,message,wParam,lParam);
			delete pclBitMap;
			return lret;
			// fall through
		default:
			lret = pclBitMap->CtlWndProc(hwnd,message,wParam,lParam);
			return lret ;
			break;
	}
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BitmapFromDib(LPVOID hdib, HPALETTE hpal, WORD palSize)                  *
 *                                                                          *
 *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global *
 *               handle to a memory block in CF_DIB format                  *
 *                                                                          *
 *  RETURNS    : A handle to the DDB.                                       *
 *                                                                          *
 ****************************************************************************/

static HBITMAP BitmapFromDib (
    LPVOID         pDIB,
    HPALETTE   hpal, WORD wPalSize)
{
    LPBITMAPINFOHEADER  lpbi;
    HPALETTE            hpalT;
    HDC                 hdc;
    HBITMAP             hbm;

   

    if (!pDIB || wPalSize == 16 )
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)pDIB; // lock resource


    hdc = GetDC(NULL);

    if (hpal){
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);     
    }

    hbm = CreateDIBitmap(hdc,
                (LPBITMAPINFOHEADER)lpbi,
                (LONG)CBM_INIT,
                (LPSTR)lpbi + lpbi->biSize + wPalSize*sizeof(PALETTEENTRY),
                (LPBITMAPINFO)lpbi,
                DIB_RGB_COLORS );

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    ReleaseDC(NULL,hdc);

    return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\addr_fe.cpp ===
/*********************************************************************
Registration Wizard
Addr_fe.cpp
Address Dialog screen for Far East Countries
In getting the phone numbers the Area Code , Phone Number and Extension is got seperately.
And while sending the information to the backend the Area code is combined with Phone number. 

03/10/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <regpage.h>

#include <Winnt.h>
#include <stdio.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "cstattxt.h"
#include "cbitmap.h"
#include "cntryinf.h"
#include <rw_common.h>


static PROPSHEETPAGE  *spAddrSheet=NULL;
//static int vDeclineOffers = -1;
void ConfigureFEAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
void SetRegWizardCountryCode(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateFEAddrDialog(CRegWizard* pclRegWizard,HWND hwndDlg);
int ValidateFEAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);

///////////////////////////////
//#define CREATE_TAB_ORDER_FILE
///////////////////////////////

#ifdef CREATE_TAB_ORDER_FILE
void CreateAddrDlgTabOrderString(HWND hwndDlg);
BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam);
#endif
INT_PTR CALLBACK AddressFEDialogProc(HWND hwndDlg, 
					UINT uMsg, 
					WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the 
user's address,phone, etc.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
	_TCHAR szTemp[256];
    INT_PTR bStatus;
	static int iXY = 0;
	HWND hWnd;
	
	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}
	
	
    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;	
        case WM_INITDIALOG:
		{	
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			//SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
						
	
		
			HWND hwndStateField = GetDlgItem(hwndDlg,IDC_EDIT4);
			SetFocus(hwndStateField);
			
			//NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			//NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT5);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT6);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT7);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT8);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT9);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT10);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT12);
		
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			
			BOOL boughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
			int stringID1 = boughtByCompany ? IDS_ADDRDLG_TEXT1B : IDS_ADDRDLG_TEXT1A;
			int stringID2 = boughtByCompany ? IDS_ADDRDLG_TEXT2B : IDS_ADDRDLG_TEXT2A;
			LoadString(pi->hInstance,stringID1,szTemp,256);
			//HWND hWnd = GetDlgItem(hwndDlg,IDT_TEXT1);
			//SetWindowText(hWnd,szTemp);

			LoadString(pi->hInstance,stringID2,szTemp,256);
			hWnd = GetDlgItem(hwndDlg,IDT_TEXT2);
			SetWindowText(hWnd,szTemp);

			//new CStaticText(pclRegWizard->GetInstance(),hwndDlg,IDT_TEXT1,stringID1,NULL);
			//new CStaticText(pclRegWizard->GetInstance(),hwndDlg,IDT_TEXT2,stringID2,NULL);
			if (pclRegWizard->GetInformationString(kInfoMailingAddress,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
			}
/*			if (pclRegWizard->GetInformationString(kInfoAdditionalAddress,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
			}*/
			if (pclRegWizard->GetInformationString(kInfoCity,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoState,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoZip,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoPhoneNumber,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT6,WM_SETTEXT,0,(LPARAM) szInfo);
			}
		/*	if (pclRegWizard->GetInformationString(kInfoEmailName,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT7,WM_SETTEXT,0,(LPARAM) szInfo);
			}*/
			if (pclRegWizard->GetInformationString(kInfoPhoneExt,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT8,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kAreaCode,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_AREACODE,WM_SETTEXT,0,(LPARAM) szInfo);
			}

		
			pclRegWizard->ResolveCurrentCountryCode();

			gTapiCountryTable.FillCountryList(pclRegWizard->GetInstance(), 
				GetDlgItem(hwndDlg,IDC_COMBO1)	);
			PTSTR psz = gTapiCountryTable.GetCountryName ( pclRegWizard->GetCountryCode());
			SendMessage(GetDlgItem(hwndDlg,IDC_COMBO1),
			CB_SELECTSTRING, (WPARAM) -1,(LPARAM) psz); //select this country
			if (pclRegWizard->GetInformationString(kInfoCountry,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_SELECTSTRING,(WPARAM) -1,(LPARAM) szInfo);
			}
			ConfigureFEAddrEditFields(pclRegWizard,hwndDlg);

			#ifdef CREATE_TAB_ORDER_FILE
			CreateAddrDlgTabOrderString(hwndDlg);
			FResSetDialogTabOrder(hwndDlg,IDS_TAB_ADDRESS);
			#endif

			vDialogInitialized = TRUE;
            return TRUE;
		} // WM_INIT
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
                pi->iCancelledByUser = RWZ_PAGE_OK;

				{
						BOOL boughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
						int stringID1 = boughtByCompany ? IDS_ADDRDLG_TEXT1B : IDS_ADDRDLG_TEXT1A;
						int stringID2 = boughtByCompany ? IDS_ADDRDLG_TEXT2B : IDS_ADDRDLG_TEXT2A;
						LoadString(pi->hInstance,stringID1,szTemp,256);
						//HWND hWnd = GetDlgItem(hwndDlg,IDT_TEXT1);
					//	SetWindowText(hWnd,szTemp);
						LoadString(pi->hInstance,stringID2,szTemp,256);
						hWnd = GetDlgItem(hwndDlg,IDT_TEXT2);
						SetWindowText(hWnd,szTemp);
				}
						

				//if(spAddrSheet) {
				//	spAddrSheet->pszHeaderTitle = MAKEINTRESOURCE(IDS_WELCOME_SCR_TITLE);
				//}

				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;
            case PSN_WIZNEXT:
				iRet=0;
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					if( ValidateFEAddrDialog(pclRegWizard,hwndDlg)) {
						ConfigureFEAddrEditFields(pclRegWizard,hwndDlg);
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoMailingAddress,szInfo);
					/*	SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoAdditionalAddress,szInfo);*/
						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCity,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoState,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoZip,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT6,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoPhoneNumber,szInfo);
					/*	SendDlgItemMessage(hwndDlg,IDC_EDIT7,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoEmailName,szInfo);*/
						SendDlgItemMessage(hwndDlg,IDC_EDIT8,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoPhoneExt,szInfo);
						
						// Get Area Code 
						SendDlgItemMessage(hwndDlg,IDC_AREACODE,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kAreaCode,szInfo);


						LRESULT selIndex = SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETCURSEL,0,0L);
						SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETLBTEXT,selIndex,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCountry,szInfo);
					
						SetRegWizardCountryCode(pclRegWizard,hwndDlg);
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
					
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet); 
				}
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kAddressDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
		{
			if (HIWORD(wParam) == CBN_KILLFOCUS){
				ConfigureFEAddrEditFields(pclRegWizard,hwndDlg);
			}
		} // WM_COMMAND
		break;
	    default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}



BOOL ValidateFEAddrDialog(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Address
dialog.  If any required edit field input is empty, ValidateAddrDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateFEAddrEditFields(pclRegWizard,hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szLabel[128];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szLabel,128);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szLabel,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndInvField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndInvField);
		return FALSE;
	}
}


int ValidateFEAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
ValidateFEAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the first empty
edit field control will be returned as the function result.  If all 
fields are OK, NULL will be returned.
**********************************************************************/
{
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1; 
//	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2; 
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3; 
	if(pclRegWizard->GetCountryCode() == 0)
	{
		if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT4)) 
			return IDC_EDIT4; 
	}
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT5)) return IDC_EDIT5; 
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT6)) return IDC_EDIT6;
//	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT7)) return IDC_EDIT7;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT8)) return IDC_EDIT8;

	return NULL; 
}


void ConfigureFEAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	SetRegWizardCountryCode(pclRegWizard,hwndDlg);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecAddress,IDT_TEXT2);
//	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecAddress2,IDT_TEXT4);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecCity,IDT_TEXT5);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT4,kAddrSpecState,IDT_TEXT6);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT5,kAddrSpecPostalCode,IDT_TEXT7);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT6,kAddrSpecPhone,IDT_TEXT8);
//	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT7,kAddrSpecEmailName,IDT_TEXT12);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT8,kAddrSpecExtension,IDT_TEXT9);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_AREACODE,kAddrSpecAreaCode,IDT_AREACODE);
}




#ifdef CREATE_TAB_ORDER_FILE
void CreateAddrDlgTabOrderString(HWND hwndDlg)
/*********************************************************************
Creates a comma delimited list of ID's for all controls belonging to
the given dialog, and writes the list to a text file.
**********************************************************************/
{
	HANDLE hFile = CreateFile(_T"c:\\ADDRTAB.TXT",GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		EnumChildWindows(hwndDlg, EnumChildProc,(LPARAM) hFile);
		CloseHandle(hFile);
	}
}
#endif


#ifdef CREATE_TAB_ORDER_FILE
BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	_TCHAR rgch[128];
	int iCtrlId = GetDlgCtrlID(hwndChild);
	LPTSTR sz = GetFocus() == hwndChild ? _T"F" : _T"";
	wsprintf(rgch,_T"%i%s,",iCtrlId,sz);

	HANDLE hFile = (HANDLE) lParam;
	DWORD dwBytesWritten;
	WriteFile(hFile,rgch,_tcslen(rgch) * sizeof(_TCHAR),&dwBytesWritten,NULL);
	return TRUE;
}
#endif

//
//  This function is calles during the creation and deletion of
//  Address Property Sheet 
//  Store the Address of PPROPSHEETPAGE so the Subtitle can be changed
//
//
//
UINT CALLBACK AddressFEPropSheetPageProc(HWND hwnd, 
								UINT uMsg, 
								LPPROPSHEETPAGE ppsp 
								) 
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
		spAddrSheet = ppsp;
	default:
		break;

	}
	return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\regwiz\regwiz\cregwiz.cpp ===
/*********************************************************************
Registration Wizard
Class: CRegWizard

--- This class is responsible for accumulating information gathered
from the user by the Registration Wizard, and then writing it to the
Registration Database in preparation for transmission via modem.

11/3/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <stdio.h>
#include "cregwiz.h"
#include "resource.h"
#include "version.h"
#include "regutil.h"
#include "cntryinf.h"
#include "rwwin95.h"
#include "cntryinf.h"
#include "wininet.h"
#include "rw_common.h"

#define kRegBufferSize	260

CRegWizard::CRegWizard(HINSTANCE hInstance, LPTSTR szParamRegKey)
/*********************************************************************
Constructor for our Registration Wizard class.  The szParamRegKey
parameter should be a Registration Database key pointing to a block
of Reg Wizard input parameters.
**********************************************************************/
{

	m_hInstance = hInstance;
	_tcscpy(m_szParamRegKey,szParamRegKey);
	m_szInfoParentKey[0] = NULL;
	m_productNameCount = 0;
	m_searchCompleted = kTriStateFalse;
	m_systemInventoryCompleted = FALSE;
	m_lpfnProductSearch = NULL;
	m_countryCode= 0;  // CXZ   5/8/97   from NULL to 0
	m_dialogActive = FALSE;
	m_hwndStartDialog = NULL;
	m_hwndCurrDialog = NULL;
	m_wDialogExitButton = 0;
	m_szLogFilePath[0] = NULL;
	m_hLogFile = INVALID_HANDLE_VALUE;
	m_hwndDialogToHide = NULL;
	m_hwndPrevDialog = NULL;
	m_ccpLibrary	 = NULL;

	for (short index = 0;index < kInfoLastIndex;index++)
	{
		m_rgszInfoArray[index] = NULL;
		m_writeEnable[index] = TRUE;
	}

	// Since we want to perform a new product search each time, we'll delete any
	// existing product name keys.
	index = 0;
	_TCHAR szParentKey[255];
	_TCHAR szProductBase[64];
	LONG regStatus;
	HKEY hKey;
	GetInfoRegistrationParentKey(szParentKey);
	int resSize = LoadString(m_hInstance,IDS_PRODUCTBASEKEY,szProductBase,64);
	
	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szParentKey,NULL,KEY_ALL_ACCESS,&hKey);

	if (regStatus == ERROR_SUCCESS)
	{
		for (int x = 1;x <= kMaxProductCount;x++)
		{
			_TCHAR szProductValueName[256];
			_stprintf(szProductValueName,_T("%s %i"),szProductBase,x);
			regStatus = RegSetValueEx(hKey,szProductValueName,NULL,REG_SZ,(CONST BYTE*) _T(""),1);
		}
	}

	// Read any default information from the registry (if RegWizard
	// hasn't been run before, there will be no existing default info).
	ReadInfoFromRegistry();
	ResolveCurrentCountryCode();	

	// These four information strings we know implicitly,
	// so we'll set them now.
	_TCHAR szInfo[256];
	GetRegWizardVersionString(hInstance,szInfo);
	SetInformationString(kInfoVersion,szInfo);

	LoadString(hInstance,IDS_MAKERCOMPANY,szInfo,64);
	SetInformationString(kInfoMakerCompany,szInfo);

	SetInformationString(kInfoResultPath,m_szParamRegKey);

	GetDateFormat(LOCALE_SYSTEM_DEFAULT,0,NULL,_T("MM'/'dd'/'yyyy"),szInfo,256);
	SetInformationString(kInfoDate,szInfo);

	LANGID langID;
	GetSystemLanguageInfo(szInfo,256,&langID);
	wsprintf(szInfo,_T("%i"),langID);
	SetInformationString(kInfoLanguage,szInfo);

	// Build our tables specifying country-specific parameters
	// for all our edit fields.
	BuildAddrSpecTables();
    m_hAccel=LoadAccelerators(m_hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR));

}

CRegWizard::~CRegWizard()
/*********************************************************************
Destructor for our Registration Wizard class
**********************************************************************/
{

	if(m_addrJumpTable != NULL)
		GlobalFree( m_addrJumpTable );
	
	if(m_addrSpecTable != NULL)
		GlobalFree( m_addrSpecTable );
		
	for (short index = 0;index < kInfoLastIndex;index++)
	{

		if(m_rgszInfoArray[index] != NULL)
		{
			LocalFree(m_rgszInfoArray[index]);
			m_rgszInfoArray[index] = NULL;
		}
	}

	if (m_hLogFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hLogFile);
	}

	FreeLibrary(m_ccpLibrary);
}


void CRegWizard::StartRegWizardDialog(int wDlgResID, DLGPROC lpDialogProc)
/*********************************************************************
Given a dialog template resource ID (wDlgResID) and a pointer to a
DialogProc callback function, StartRegWizardDialog creates and
displays a dialog window.

Note: Creating our dialogs as modeless lets us keep the current dialog
displayed while the next dialog is initializing (which can take a
while for some RegWizard dialogs), and then immediately flip to the
next dialog.
**********************************************************************/
{
	if (m_hwndStartDialog == NULL)
	{
		m_hwndStartDialog = CreateDialogParam(m_hInstance,MAKEINTRESOURCE(wDlgResID),
			NULL,lpDialogProc, (LPARAM) this);
		m_dialogActive = TRUE;
		ActivateRegWizardDialog();
	}
}


void CRegWizard::ActivateRegWizardDialog( void )
/*********************************************************************
ActivateRegWizardDialog should be called after creating a RegWizard
dialog window.  This function will display the window, and will
then destroy the current dialog window (if any).
**********************************************************************/
{
	if (m_hwndStartDialog)
	{	
		HWND hW;
		RECT r;
		
		
		hW = m_hwndDialogToHide? m_hwndDialogToHide : m_hwndCurrDialog;
		if( hW )
		{
			GetWindowRect(hW, &r);
			SetWindowPos( m_hwndStartDialog, NULL, r.left, r.top,0,0,
												SWP_NOSIZE|SWP_NOZORDER);
		
		}
		
		
		ShowWindow(m_hwndStartDialog,SW_SHOW);
		
		if(m_hwndDialogToHide != NULL)
		{
			ShowWindow(m_hwndDialogToHide,SW_HIDE);
			m_hwndDialogToHide = NULL;
		}
		else
		{
			if(m_hwndCurrDialog != NULL)
				DestroyWindow(m_hwndCurrDialog);
		}
		m_hwndCurrDialog = m_hwndStartDialog;
		m_hwndStartDialog = NULL;
		HCURSOR hCursor = LoadCursor(NULL,IDC_ARROW);
		SetCursor(hCursor);
	}
}


void CRegWizard::SetPrevDialog(void)
{
	m_hwndPrevDialog = m_hwndCurrDialog;
}

INT_PTR CRegWizard::ProcessRegWizardDialog( void )
/*********************************************************************
After calling StartRegWizardDialog, ProcessRegWizardDialog should
next be called.  This function will retain control until the user
dismisses the current dialog.  The ID of the control used to
terminate the dialog will be returned as the function result.
**********************************************************************/
{
	if (m_hwndCurrDialog)
	{
		while (IsDialogActive())
		{
			MSG msg;
			GetMessage(&msg,NULL,0,0);
	        if (!TranslateAccelerator(m_hwndCurrDialog, m_hAccel, &msg))
		    {
				if (!IsDialogMessage(m_hwndCurrDialog,&msg))
				{
					TranslateMessage(&msg);
			        DispatchMessage(&msg);
				}
			}
		}
	}
	return GetDialogExitButton();
}



void CRegWizard::EndRegWizardDialog(INT_PTR wExitID)
/*********************************************************************
Should be called from within the DialogProc when the user wants to
dismiss the dialog.  The ID of the control used to terminate the
dialog should be passed as the wExitID parameter.
**********************************************************************/
{
	HCURSOR hCursor = LoadCursor(NULL,IDC_WAIT);
	SetCursor(hCursor);
	EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_EXIT),FALSE);
	if(wExitID == IDB_REG_LATER)
		EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_REG_LATER),FALSE);
	else
	if(wExitID == IDB_BACK)
		EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_BACK),FALSE);
	else
	{
		if(GetDlgItem(m_hwndCurrDialog,IDB_BACK) == NULL)
			EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_REG_LATER),FALSE);
		else
			EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_BACK),FALSE);
	}

	EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_NEXT),FALSE);
	m_wDialogExitButton = wExitID;
	m_dialogActive = FALSE;
}


BOOL CRegWizard::IsDialogActive( void )
/*********************************************************************
Returns TRUE if a RegWizard dialog is currently active (i.e. the
EndRegWizardDialog function has not been called by the active dialog's
DialogProc.
**********************************************************************/
{
	return m_dialogActive;
}


INT_PTR CRegWizard::GetDialogExitButton( void )
/*********************************************************************
Returns the ID of the control used to dismiss the current dialog.
**********************************************************************/
{
	return m_wDialogExitButton;
}

void CRegWizard::SetDialogExitButton( int nButton )
/*********************************************************************
Returns the ID of the control used to dismiss the current dialog.
**********************************************************************/
{
	m_wDialogExitButton = nButton;
}

TriState CRegWizard::GetProductSearchLibraryStatus( void )
/*********************************************************************
Returns:
- kTriStateTrue: the ProductSearch library is available and can be
	successfully loaded.
- kTriStateFalse: the ProductSearch library couldn't be found.
- kTriStateUndefined: product searching does not need to be performed.
**********************************************************************/
{
	FARPROC lpfnProductSearch;
	BOOL status = GetProductSearchProcAddress(&lpfnProductSearch);
	if (status == TRUE)
	{
		return lpfnProductSearch == NULL ? kTriStateUndefined : kTriStateTrue;
	}
	else
	{
		return kTriStateFalse;
	}
}


BOOL CRegWizard::GetProductSearchProcAddress(FARPROC* lpfnProductSearch)
/*********************************************************************
This function attempts to load the ProductSearch (CCP) library, and
if successful, returns the ProcAddress of the RegProductSearch
function.

Returns:
-- TRUE if the ProcAddress passed in lpfnProductSearch is valid,
OR if the input parameters to RegWizard specify that no product
searching is to be performed (in which case NULL will be returned in
the lpfnProductSearch parameter).

-- FALSE if the ProductSearch library could not be located, AND the
input parameters to the RegWizard specified that product searching is
to be performed.

Note: RegWizard determines whether product searching is to be
performed by looking at the InventoryPath "input parameter" registry
key.  If it is not present, or contains a blank value, then no
product searching is to be performed.
**********************************************************************/
{
	BOOL returnVal = FALSE;
	if (m_lpfnProductSearch)
	{
		*lpfnProductSearch = m_lpfnProductSearch;
		returnVal = TRUE;
	}
	else
	{
		*lpfnProductSearch = NULL;
		_TCHAR szLibName[kRegBufferSize];
		BOOL goodParam = GetInputParameterString(IDS_INPUT_INVENTORYPATH,szLibName);
		if (goodParam == FALSE || (goodParam == TRUE && szLibName[0] == NULL))
		{
			*lpfnProductSearch = NULL;
			returnVal = TRUE;
		}
		else
		{
			m_ccpLibrary = LoadLibrary(szLibName);
			if (m_ccpLibrary)
			{
				m_lpfnProductSearch = GetProcAddress(m_ccpLibrary,"RegProductSearch");
				if (m_lpfnProductSearch)
				{
					*lpfnProductSearch = m_lpfnProductSearch;
					returnVal = TRUE;
				}
			}
		}
	}
	return returnVal;
}



BOOL CRegWizard::GetInputParameterStatus( void )
/***************************************************************************
Returns TRUE only if the input parameter registrion key passed to the
CRegWizard constructor points to a valid key that contains a proper block of
input parameter subkeys.
****************************************************************************/
{
	BOOL returnVal = FALSE;
	_TCHAR szParam[kRegBufferSize];
	if (GetInputParameterString(IDS_INPUT_PRODUCTNAME,szParam))
	{
		if (GetInputParameterString(IDS_INPUT_PRODUCTID,szParam))
		{
			returnVal = TRUE;

			// 12/13/94: we will no longer consider a missing inventory
			// path key to be an error (it now means "don't do product
			// inventory").
			//if (GetInputParameterString(IDS_INPUT_INVENTORYPATH,szParam))
			//{
			//	returnVal = TR